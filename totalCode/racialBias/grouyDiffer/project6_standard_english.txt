A few factors:
- We've mostly avoided depending on other libraries.
- cglib doesn't work on Android.
- cglib has [an API similar to `Reflection.newProxy`](http://cglib.sourceforge.net/apidocs/net/sf/cglib/Enhancer.html#create(java.lang.Class,%20net.sf.cglib.Callback)) already. We expect for anything in the `-android` variant of Guava to work on Android. (We've occasionally found bugs in very strange edge cases, but we don't expect users to encounter them in practice.) That said, we don't recommend using, e.g., reflection, including APIs like `eventbus` that use reflection, because of poor performance on Android. If we could go back in time, we might well not have included the reflection utilities in our `-android` variant. But previously we didn't have a separate variant, so any classes we included needed to be available on Android. Now that we've released them there, we don't want to pull them back and break anyone who uses them there.
(There's another complication, which is that we recommend using the "Android" variant if you're stuck on Java 7. Reflection could be useful there, too.)  This works for me, too.  Did you try building in a freshly cloned branch to make sure that you don't have old artifacts preventing a clean build?  The immediate intent of deprecating`common.collect.TreeTraverser` is to discourage new uses of it in favor of `common.graph.Traverser`.
The `Files` and `MoreFiles` methods are not deprecated at this time, and I don't know what the plans are for them.  Options include (a) removing them outright, and (b) replacing them with methods that use Traverser; we probably won't just leave them alone indefinitely. `Files` and `MoreFiles` are also each `@Beta`.  No, there is no possible way in Java to do either of those things.  You will have to construct the `TypeToken` at the site where you know the exact type, and pass it around.  If there are "many lines of code," you should pull out a method.  If there aren't, then you should just execute the logic directly in the function, not in a lambda. I think you've demonstrated how easy it would be to define this on your own. This API doesn't serve much use in Guava but you can surely add it to your code and use it as you wish.   We used to have `ImmutableMap` implement `ConcurrentMap`, but it turned out not to help anyone, so we backed it out. I, too, am interested to hear about "bounds checking." Ah, interesting. I will run `ImmutableMap implements ConcurrentMap` by a few people to get their general impressions.
Obviously no workarounds are particularly appealing, but I feel obligated to list a few, anyway:
- use `unmodifiableMap` on the input to convert it to a `ConcurrentMap<X, Map<Y, Z>>`, and then use `getIfAbsent`
- store an empty map and pinky-swear not to modify it
- write a static `getIfAbsent` method with more convenient generics (We do provide [`Tables.synchronizedTable`](http://google.github.io/guava/releases/snapshot-jre/api/docs/com/google/common/collect/Tables.html#synchronizedTable-com.google.common.collect.Table-) for thread-safe tables, but I don't know how its performance would compare to truly concurrent collections in your use case.) Makes sense.
Other alternative: With Java 8, you could probably just declare your field as a `Map<X, Map<Y, Z>>`, since `getOrDefault` is available on `Map` nowadays. Then you can pass an `ImmutableMap` to `getOrDefault`. Initial reaction has been kind of lukewarm, so we'll likely leave things as they are, sorry.
A couple points:
- Our understanding is that the JDK people view `ConcurrentMap` as sort of a wart: They would have liked to just add the concurrency-oriented methods to `Map` itself, but `default` methods didn't exist yet. Now that `default` methods exist, `ConcurrentMap` doesn't serve as much purpose
- To the extent that `ConcurrentMap` does serve a purpose, it's mostly to document atomicity and memory-consistency effects, which don't make sense for an immutable map. Admittedly, it does also document general thread-safety, but even non-`ConcurrentMap` maps like `synchronizedMap` are thread-safe (as is nearly any other `Map` as long as you don't write it).
But mostly, people just found it weird to implement `ConcurrentMap`. That was true back when `ImmutableMap` did implement `ConcurrentMap`, and that's why we backed it out.  I've replied on #1388 to keep the discussion in one place.  Our current thinking is that we'll look into this next quarter. We have seen some problems from `module-info` files in third-party jars, since they're Java 9 `.class` files and not everyone uses Java 9 yet. So, if we can get away with `Automatic-Module-Name`, we'll continue to do so, possibly even beyond next quarter. But if there are cases in which `Automatic-Module-Name` isn't good enough, that would be good to know. Right, thanks. We've seen problems even when the main `.class` files are compiled for an older version but the `module-info.class` is present. As I understand it, various tools try to process all `.class` files, and they need to be updated to ignore `module-info.class`. I wasn't personally involved in fixing the problems, but the basic idea seems to be that people scan the whole classpath (using something like [`ClassPath.getTopLevelClasses`](http://google.github.io/guava/releases/snapshot-jre/api/docs/com/google/common/reflect/ClassPath.html#getTopLevelClasses--) -- which might be an example of something that needs updated to ignore `module-info.class` :)) and then try to examine/load the classes with a tool that understands only, say, Java 8.  +1 to @ooxi 's comment. It's possible that we may want to mention the new convenience factory methods, but we won't discourage the use of `ImmutableList`, etc. Yes, I think that is a good idea.  I had the old location bookmarked, and I was wondering why it wasn't updating :) I figured it out, but it would be nice if we had a way to redirect the old, since links exist (though perhaps [not very many](https://www.google.com/search?q=%22google.github.io%2Fguava%2Freleases%2Fsnapshot%22+-inurl%3A%22google.github.io%2Fguava%22)). I wasn't expecting that simply replacing the `snapshot` directory with a symlink to the `snapshot-jre` directory would work, but it actually does. Ok, it does _sort of_: it doesn't actually _redirect_ to the `snapshot-jre` URL, it just sort of aliases `snapshot-jre` as `snapshot` (which is probably expected, really, given how symlinks work). Actual redirects would probably be better (to canonicalize the URLs), but I'm inclined to think this is good enough for now.
Actual redirects could probably be handled by populating the `snapshot` directory with a "copy" of the `snapshot-jre` directory where every `.html` file is replaced with a `.html` file that simply has a `meta` redirect to the `snapshot-jre` location. The script that generates Javadoc/JDiff could be updated to ensure that the set of files under `snapshot` matches that under `snapshot-jre` at all times.  Interesting report, thanks. I think the short answer is that we call `triggerShutdown` under a lock, and we call `notifyFailed` under that same lock. So, if the `run` throws but `triggerShutdown` starts before the state changes to `FAILED`, the thread that's running `run` will never get the lock and thus _never_ change the state.
As for what to do about it... hmm. I don't think I've seen `AbstractExecutionThreadService` used with `SynchronousQueue` before. In principle, this is the kind of situation in which thread interruption could help, but we don't currently expose that, and given that we don't necessarily _really_ own the threads from the `Executor`, we technically probably shouldn't interrupt them, anyway.
It's presumably possible to build something directly atop `AbstractService`, using `AbstractExecutionThreadService` as a starting point, but that's naturally not very appealing.
Maybe your `triggerShutdown` method could set a `volatile boolean` in addition to adding to the queue, and the `run` method could consult that, too? That way, `triggerShutdown` could ensure that its notification would be delivered, even if `run` isn't ready to receive it at that moment and `triggerShutdown` doesn't want to wait around. The `SHUTDOWN` poison pill would still be important for cases cases in which the `run` method has nothing to do and is thus blocked in `take`. But the `boolean` could handle the simple cases in which it's already doing work. But I would want to think harder about this.
Maybe @lukesandberg has ideas. Ah, yes, that's nicer than a separate variable. Thinking about this more, I'm a little worried that there will still be a race.
override fun run() {
while (isRunning()) {
val event = inputQueue.take()
If the shutdown request happens between the two first lines of the method, does the thread hang in `take`? In practice, it might not hang forever, since some other thread may insert something into the queue.
Still, we might have solved the exception race but introduced a new one. Maybe a better fix is for the runner thread to set some kind of flag if it exits with an exception? Then `triggerShutdown` can consult that in its `offer` loop. (In any case, I will update the docs.)  This might work: https://stackoverflow.com/a/37702441/28465 I guess the link offline option copies the other projects' Javadoc into the Javadoc generated for Guava? It would be nice to avoid that, just because I worry a little bit about about increasing the size/number of files in the gh-pages branch (and the guava repo in general). It's already going to be increasing faster than it was before because of making releases much more often. On the other hand, since it's mostly just annotations and Guava already has a lot of Javadoc (and because, well, maybe the size of the repo doesn't really matter), maybe it's not that big a deal. linkoffline still links to an already published online source. It just requires you to have the package-info file locally rather than pulling it from online. Ohh, nice! Gave this a quick shot. Created local versions of package-info for jsr305 and j2objc-annotations. But I can't seem to get jsr305 to win out over the JDK for javax.annotations. And I'd previously noticed that j2objc-annotations doesn't have any `@Documented` annotations (though probably it should). So no real progress so far.
Luckily, we may switch off jsr305 (#2960), which would solve that problem, at least. Need `<detectJavaApiLink>false</detectJavaApiLink>`. Now to see if, with that, I can get both jsr305 and JDK links to work. Have it working.  I think `Server.join()` blocks until the server has _stopped_. I think you might want to call it in `doStop()` instead.  This looks like a really interesting tool! Maybe we should incorporate it into our release pages.  Nice catch. Likely the problem is in the `else` case of `fromEntries`. https://github.com/google/guava/commit/9bcedd8f5bd2354d133edcb3e058b8f0d4f28e8f  Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit <https://cla.developers.google.com/> to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If your company signed a CLA, they designated a Point of Contact who decides which employees are authorized to participate. You may need to contact the Point of Contact for your company and ask to be added to the group of authorized contributors. If you don't know who your Point of Contact is, direct the project maintainer to go/cla#troubleshoot.
- In order to pass this check, please resolve this problem and have the pull request author add another comment and the bot will run again.
<!-- need_sender_cla --> CLAs look good, thanks!
<!-- ok --> Thanks. Any opinion on whether we should set an `Automatic-Module-Name` for our `guava-testlib` test utilities? They're much, much less heavily used, but maybe we might as well? Or maybe it's not worth worrying about modules for code that runs only in tests, since it sounds like there might not be a good story yet for running most tests with modules on? Thanks.  AFAICT these are the annotations from that package that we use:
- `@Nullable`
- `@CheckForNull`
- `@CheckReturnValue`
- `@ParametersAreNonnullByDefault`
- `@concurrent.GuardedBy`
- `@concurrent.Immutable`
- `@concurrent.NotThreadSafe`
- `@concurrent.ThreadSafe`
`@Nullable` is probably the one that we have the most options, since almost everyone treats any annotation with the simple name of `Nullable` as the same.
The others are less clear to me - they're technically just for static analysis, but they all have `RUNTIME` retention. It's not abundantly clear how we could get around using them without having ErrorProne, IDEs, and all other static analysis pipelines adopting a new set of APIs.
It sounds like we should maybe be avoiding `javax.annotation.Generated` *entirely* until we can figure this out. This will be a large project (and span beyond just Google products). Would that solve the module issue? > JSR-250 contains other annotations, too
Seems to me that the others are significantly less heavily used. Migrating off the jsr305 annotations makes sense to me.
Hopefully most tools care only about the simple class name of the annotations, not their packages. For starters, I checked Error Prone's `@CheckReturnValue` and `@GuardedBy` checkers. They care only about the simple name. But I'm sure that some tools (inside and outside Google) will care about the package.
If we're moving off the "standard" annotations, I wonder what it makes the most sense for us to migrate to. Spotbugs is a natural choice, since we know it has all the annotations that we want. But of course [there are many nullability annotations](https://stackoverflow.com/q/4963300/28465). And arguably we aren't targeting Spotbugs nowadays so much as we're targeting Error Prone. Maybe Error Prone would be interested in adding some annotations of their own. Or maybe, for some of the annotations we use less frequently, we could have our own (package-private?) versions to avoid committing to any tool.
The question is: what kinds of problems are you trying to solve that require this data structure? Note Guava already has https://google.github.io/guava/releases/21.0/api/docs/com/google/common/math/Quantiles.html for that sort of operation. That's correct, but can you discuss your business use case for which this is clearly the best solution?  Where which the data set _is_ modified frequently or _doesn't_ consist of doubles?  What is in it?  Is it customer ID numbers?  Costs for pencils?  Please be more specific than "numbers" or "objects" or the like.
:memo: **Please visit <https://cla.developers.google.com/> to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If your company signed a CLA, they designated a Point of Contact who decides which employees are authorized to participate. You may need to contact the Point of Contact for your company and ask to be added to the group of authorized contributors. If you don't know who your Point of Contact is, direct the project maintainer to go/cla#troubleshoot.
- In order to pass this check, please resolve this problem and have the pull request author add another comment and the bot will run again.
<!-- need_sender_cla -->  It wasn't, but I hadn't known that we were releasing a point version of 23.
I mean, IMO it doesn't hurt anything, but I would prefer to wait on releasing such things until they're done.  Meanwhile, enjoy the sneak preview, I guess... :)  Guava does not provide a way to do this because there is no possible efficient way to do this.  Since there is no way to be informed of modifications to a collection from the outside, the only possible map implementation would be to do a full linear search of the collection on every query.  Moreover, there is no way to guarantee the Map contract from the outside, that keys are unique, short of verifying every invariant on every query to the Map.
A much better solution to your problem would be to write your own class that simultaneously managed the collection and map views of all your data -- a lightweight database, more or less -- and ensured that they stayed in sync externally.
Guava tries not to provide APIs where we think people would have misleading expectations as to their performance characteristics, and this is definitely such a case. I think you could do something like that; it's similar to what Louis is suggesting, but I think he's suggesting that rather than try to use the `Collection` and `Map` APIs directly for this, you create your own class that just does what you need (using `Map`s and such under the hood as needed). Something like this for example:
}
``` Also, you can't add observers to an arbitrary Collection.  You could maybe wrap another collection in an observer and get a _new_ collection, but that doesn't make the underlying Collection safe for use, and it adds lots of weird edge cases in that your wrapped collection can have new kinds of errors if there's e.g. a key conflict in the maps.  It just gets...weird.  It's much simpler, clearer, and usually cleaner to write the class Colin and I outlined.  You can even, if you choose, have the class provide _unmodifiable_ external `Collection` and `Map` views, and it works so long as you only allow the contents to be modified via the database object.  Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit <https://cla.developers.google.com/> to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If your company signed a CLA, they designated a Point of Contact who decides which employees are authorized to participate. You may need to contact the Point of Contact for your company and ask to be added to the group of authorized contributors. If you don't know who your Point of Contact is, direct the project maintainer to go/cla#troubleshoot.
- In order to pass this check, please resolve this problem and have the pull request author add another comment and the bot will run again.
<!-- need_sender_cla --> So there's good news and bad news.
:thumbsup: The good news is that everyone that needs to sign a CLA (the pull request submitter and all commit authors) have done so.  Everything is all good there.
:confused: The bad news is that it appears that one or more commits were authored by someone other than the pull request submitter.  We need to confirm that they're okay with their commits being contributed to this project.  Please have them confirm that here in the pull request.
*Note to project maintainer: This is a terminal state, meaning the `cla/google` commit status will not change from this State. It's up to you to confirm consent of the commit author(s) and merge this pull request when appropriate.*
<!-- need_author_consent --> Given that I don't know what this PR is for, it has no description and the CLA is apparently not signed, I'm closing it for now.  *sigh* Confirmed.  That's...a little embarrassing, on the built-in stream library's part?  That `mapToObj` destroys splittability.  But I've confirmed it.  A fix won't be difficult. https://github.com/google/guava/commit/e2a4a28427011c05702cf2c1568c5067baed5337  The second sounds fine to me. I just submitted your change for internal review. (Another reason to prefer your second option is that it makes sure `lazyStackTraceIsLazy` returns `false` in the case in which we aren't going to provide lazy access.)  Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit <https://cla.developers.google.com/> to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If your company signed a CLA, they designated a Point of Contact who decides which employees are authorized to participate. You may need to contact the Point of Contact for your company and ask to be added to the group of authorized contributors. If you don't know who your Point of Contact is, direct the project maintainer to go/cla#troubleshoot.
- In order to pass this check, please resolve this problem and have the pull request author add another comment and the bot will run again.
<!-- need_sender_cla --> CLAs look good, thanks!
<!-- ok --> Turns out the history behind the redundant tests was interesting :) I've changed this PR slightly to make them do what they used to do years ago, and I've merged it. Thanks!  I'm not clear on how `-ga` makes sense. "General availability" isn't a term we use in Guava releases and really doesn't have any particular relevance to "Android flavor". The scheme we've chosen is `<version>-jre` and `<version>-android` for the two flavors of Guava, and that's what we'll be going with barring significant evidence that we should be doing something different.  Interesting API, but as you mention, our preferred solution is [AutoValue](https://github.com/google/auto/tree/master/value). Updating a class to use `@AutoValue` can often be done w/o touching any existing callers.
I'll leave this request open for now to see how others feel, but generally I think we'd like to avoid having to write these implementations by hand. If you're going to do anything like this, I'd tend to want to see it the other way around: better factory methods for creating an `Equivalence`, and then putting that `Equivalence` as a private static constant in the class and delegating to it for both the equals and hashCode implementations, so you can't accidentally look at one field for `equals` and forget it in `hashCode` or vice versa.
Better Equivalence factory methods, like `Comparator`'s new factory methods that got massively improved in Java 8, aren't a bad idea.  As the summary says...  IMO, it is a bad idea to use `myInt` to store something that is either (1) a valid entry or (2) an indicator that the someone tried to access an element using a bad index.
I'm curious about a couple of things:
(1) What are you doing with the value of myInt after that point?
(2) What is the actual problem for which this seems to you like the best solution? +1 to what @cardamon said. `Iterables.get()` even does an `instanceof` check to support `O(1)` access for a `List` (assuming it supports `RandomAccess`) vs. `O(n)` for an unknown `Iterable`.  Are you just looking for the mixing functions? Or are you proposing writing an entire `HashFunction` wrapper around it?
I think we'd want to see evidence that this would be generally useful for cross language/system compatibility before adding yet another hash function to Guava.  Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit <https://cla.developers.google.com/> to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If your company signed a CLA, they designated a Point of Contact who decides which employees are authorized to participate. You may need to contact the Point of Contact for your company and ask to be added to the group of authorized contributors. If you don't know who your Point of Contact is, direct the project maintainer to go/cla#troubleshoot.
- In order to pass this check, please resolve this problem and have the pull request author add another comment and the bot will run again.
<!-- need_sender_cla --> CLAs look good, thanks!
<!-- ok -->  +1 to @Stephan202 's suggestion (although I'd probably go a step further and extract a static constant `ImmutableSet<String>`).  It's not actually easy to sort an `int[]` in reverse in Java.  The typical ways you'd sort an array in reverse don't work on primitives:
Arrays.sort(array, Collections.reverseOrder()); // no comparators for primitives
Arrays.sort(array);
Collections.reverse(Arrays.asList(array)); // view array as a List and reverse it, but Arrays.asList doesn't work for int[]
The shortest way I can think of is
Arrays.sort(array);
Collections.reverse(Ints.asList(array));
...which boxes every element in the array.
Perhaps we should consider e.g. `Ints.reverseSort` or the like.  I haven't thought about how practical this would be, but it ought to be doable with enough supersourcing.
It would mean shipping more code to GWT, though, since the server copy of AbstractFuture is larger. (It would also mean that we can't make some of the methods `final` in the GWT version, but making them `final` was just something I did opportunistically, not a requirement.)
The upside: We might get features and bug fixes. For example, I just heard that some GWT code has a problem with stack overflow because it didn't have the server copy's protections in `complete()` (compare GWT's `notifyAndClearListeners()`). We've also failed to update the GWT copy when updating the server copy (e.g., when fixing a bug in `pendingToString()`). Ideally we'd always catch these problems with tests, but occasionally we don't have them, or maybe we have them but not for GWT because they're convenient to write with threads.  It's more item 17: design and document for inheritance <i>or else prohibit it</i>.
If we let `BloomFilter` be subclassable, then we can't change its implementation later if we have a better implementation.  IIRC this has <i>already</i> been an issue for BloomFilter in terms of changes to its serialization behavior?  Note that we also changed `BloomFilter` in the past to make it thread-safe.  If `BloomFilter` had not been `final`, this would have broken anyone who was manipulating the underlying bit array.  Keeping classes final allows us to make changes like this without fear of breaking users.  BloomFilter is not designed to let you manipulate the bit array directly; it's not even guaranteed to have a bit array, or to have that bit array implemented in any particular way.  If you need a particular implementation, the best way to do it is to make your own.  That doesn't expose the size, it just allows you to preconfigure the expected size.
What would you expect this to do for `ImmutableSet`?  The number of elements after deduplication, or the number of elements before deduplication?  Exposing this API imposes some constraints on the implementation of the builder. I think we generally recommend using a mutable type and then calling `copyOf`. E.g.,
List<String> builder = new ArrayList<>();
// call builder.add(), .size(), etc.
ImmutableList<String> list = ImmutableList.copyOf(builder);
```
Are you concerned about the overhead of copying the list? In the cases where people have asked for this internally, we've found that their code reads better if it separates the "add things to builder" and "read from resulting collection" steps, rather than intermixing the two, even in the small way you suggest here. I would imagine that there are exceptions, of course, but overall, I fear that people will use this to make code worse rather than better.
We've also found that people try to avoid calling `build()` on an empty builder. That turns out not to be necessary because `build()` is free in that case.  I will express the opinion that I don't think it is a good idea to memoize an exception. When that exception gets thrown or logged later, the stack trace may be highly confusing.
I believe you want to create a result object that encapsulates whatever the state is that you want to have memoized. If this is an object that embodies either a successful or failed result, I think this satisfies both of your use cases. I wonder if a useful generalization of this advice is, "don't threat Throwable instances as data."  Hello,
Switching to Guava 20.0 as suggested in Android Studio make release build failed when it's done with Proguard shrinkRessources or/and minifyEnabled enabled.
`
Warning: com.google.common.util.concurrent.FuturesGetChecked$GetCheckedTypeValidatorHolder$ClassValueValidator$1: can't find superclass or interface java.lang.ClassValue
Warning: com.google.common.base.AbstractIterator: can't find referenced class com.google.errorprone.annotations.CanIgnoreReturnValue
`
(...)
`
Warning: there were 696 unresolved references to classes or interfaces.
You may need to add missing library jars or update their versions.
If your code works fine without the missing classes, you can suppress
the warnings with '-dontwarn' options.
`
`Warning: Exception while processing task java.io.IOException: Please correct the above warnings first.
:app:transformClassesAndResourcesWithProguardForRelease FAILED`
`FAILURE: Build failed with an exception.`
`* What went wrong:`
`Execution failed for task ':app:transformClassesAndResourcesWithProguardForRelease'.`
`> Job failed, see logs for details`
Android Studio 2.3.3
Proguard 4.7
JRE1.8.0_122
Thanks,
I have tryed with Guava 19.0 and 23.0-android with same result as 20.0 : Proguard complains about unresolved dependencies.  Less warning for 23.0-android. Thanks @jbduncan We need to publish our Proguard configurations someday (https://github.com/google/guava/issues/2117). For this particular problem, you can add:
`-dontwarn java.lang.ClassValue`
(We have [a fallback](https://github.com/google/guava/blob/c2c98c55c6bec6477bf2b5a9e82f9cb08c0c962c/guava/src/com/google/common/util/concurrent/FuturesGetChecked.java#L115) for systems on which `ClassValue` isn't available.) Hello,
With :
`-dontwarn java.lang.ClassValue`
Proguard (4.7) still throws errors.
In #2117 the link to that topic https://stackoverflow.com/questions/9120338/proguard-configuration-for-guava-with-obfuscation-and-optimization gives the solution for Guava 20.0 .
`-dontwarn com.google.common.base.**`
`-keep class com.google.common.base.** {*;}`
`-dontwarn com.google.errorprone.annotations.**`
`-keep class com.google.errorprone.annotations.** {*;}`
`-dontwarn   com.google.j2objc.annotations.**`
`-keep class com.google.j2objc.annotations.** { *; }`
`-dontwarn   java.lang.ClassValue`
`-keep class java.lang.ClassValue { *; }`
`-dontwarn   org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement`
`-keep class org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement { *; }`
@JakeWharton
Hello,
You are right, -keep are not needed.
I will spend more time on it.
https://www.guardsquare.com/en/proguard/manual/troubleshooting#unresolvedclass
With -keep at right, without to left :
![kept-not-kept](https://user-images.githubusercontent.com/11083657/29793467-3ab8d64a-8c44-11e7-8208-b86390549b98.jpg)
With -keep up, without down :
![kept-not-kept-count](https://user-images.githubusercontent.com/11083657/29798688-c2ecc566-8c5e-11e7-9dce-574d5131163a.jpg)
Thanks,
This has been there since 21.0, too =)  Thanks. Tentatively renamed to "NEXT." @ronshapiro @cgdecker may have more thoughts. (And I moved the 2 closed issues that were tagged 24.0 to a new 23.1 milestone, since they both made it into that release.) Somehow I completely failed to notice this issue previously; my apologies.
The behavior of `edgeValueOrDefault()` wasn't intended to change from 22.0 to 23.0; I introduced a regression when doing some internal refactoring that apparently wasn't caught by our tests.  Sorry about that.
I'll get a fix out for that as soon as I can. Fixed (see above commit).  Thanks, @rocketraman.  We do promise Java 7 compatibility at the moment (see [README](https://github.com/google/guava/blob/c2c98c55c6bec6477bf2b5a9e82f9cb08c0c962c/README.md)), so we can't use those features yet.
We have been considering trying to adopt desugar as part of our compilation process so that we can use lambdas, etc. in our implementations, but that won't be of much help to you :(  Guava's packages cannot have circular dependencies in Google's build system, and common.collect already depends on common.primitives, so we cannot have a common.primitives dependency on common.collect.  So there's good news and bad news.
:thumbsup: The good news is that everyone that needs to sign a CLA (the pull request submitter and all commit authors) have done so.  Everything is all good there.
:confused: The bad news is that it appears that one or more commits were authored by someone other than the pull request submitter.  We need to confirm that they're okay with their commits being contributed to this project.  Please have them confirm that here in the pull request.
*Note to project maintainer: This is a terminal state, meaning the `cla/google` commit status will not change from this State. It's up to you to confirm consent of the commit author(s) and merge this pull request when appropriate.*
<!-- need_author_consent -->  This is quite vague - if you're able to dissect the issue and get back to us with something specific, feel free to comment.  Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit <https://cla.developers.google.com/> to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If your company signed a CLA, they designated a Point of Contact who decides which employees are authorized to participate. You may need to contact the Point of Contact for your company and ask to be added to the group of authorized contributors. If you don't know who your Point of Contact is, direct the project maintainer to go/cla#troubleshoot.
- In order to pass this check, please resolve this problem and have the pull request author add another comment and the bot will run again.
<!-- need_sender_cla --> CLAs look good, thanks!
<!-- ok -->  I looked back at the history, and we initially had `expectedInsertions` as an `int`, and then changed it to a `long`. However, we later re-added the `int` overloads of `create()` to preserve binary compatibility.
> Re-add create() methods with an int expectedInsertions parameter.
> These methods should probably live on indefinitely for binary compatibility.
> Also add @since 19.0 to the versions with a long parameter, since they're technically newly added methods, and add a paragraph from the 3-param version that was missing to the 2-param version.
/cc @cgdecker who made the change (CL/95741164 - 2015-06-11)
Our understanding was that classifiers do not solve the problem. I'll see if I can dig up past conversations or test it out. Despite what [Maven's docs](https://maven.apache.org/pom.html) say about `classifier`...
> As a motivation for this element, consider for example a project that offers an artifact targeting JRE 1.5 but at the same time also an artifact that still supports JRE 1.4. The first artifact could be equipped with the classifier jdk15 and the second one with jdk14 such that clients can choose which one to use.
...we found that Maven will happily permit a project to depend on both `com.google.guava:guava:jar:22.0` and `com.google.guava:guava:jar:someclassifier:22.0`.
\[edit: see also [tbroyer on `classifier`](https://groups.google.com/g/guava-discuss/c/r6gJrMudYr4/m/KUKr9fixCAAJ)\]
As best we can tell, the only reliable solution is for users to manually request `<max-version-needed>` or, if they're running on Android/Java7, `<max-version-needed>-android`.
If there's another scheme that could work, we'd be happy to hear about it. A different project ID has the same effect as a different classifier, as far as we can tell. Our thinking was that it was pretty bad for people to be able to depend on both `guava` and `guava-android`, for the reasons @shs96c lays out.
What I probably need to understand better are the drawbacks of the current versioning scheme. It sounds like you want to be able to tell Maven "depend on the most recent version?" If we could use a version like `23.0-server` to make it "more recent" than `23.0-android`, as discussed in #2839, I think we could solve that problem[*]. Are there other problems?
[*] mostly: It still requires that you have at least one dep on `23.0-server`. If you don't but you do have deps on `22.0-server` and `23.0-android`, Maven is still going to do the wrong thing. Maybe you can ensure that you have that dep (or maybe there's a way to tell Maven "ignore which version everyone specifies, and just give me the max?"). But at that point, I'm wondering if it's easier to just tell Maven to use that specific version directly. RE: "Doing that will break android projects": Ah, you're saying that, if an Android project tells Maven "use the most recent available version of Guava," it will then get the server version? Good point.
RE: "maven dependency resolution": Thanks, I am aware of the BFS. Above you said: "Maven's dependency resolution looks at group and project IDs, and then attempts to find the most recent version." I was figuring that you were using something like [Gradle's "newest" strategy](https://docs.gradle.org/3.3/userguide/dependency_management.html#sub:version_conflicts) or perhaps some plugin that automatically updates your project to depend on the newest versions (update: like [this](http://www.mojohaus.org/versions-maven-plugin/))? I'm trying to understand the places where it matters which version Maven considers to be "newest." (I'm sure I don't know the _full_ horror of Maven dependencies yet, hopefully ever :))
True, "server" is the wrong word. I think that "jre" may technically mean "Oracle," which isn't necessarily what we mean, either. Hmm. (Update: Admittedly "Android" is itself not the best term, since we advise Java 7 users to use it, too.)
Sounds like Aether may be ["Maven Artifact Resolver"](http://maven.apache.org/resolver/) nowadays? The docs best docs seem to be [this Wiki](http://wiki.eclipse.org/Aether). Oops, I think you're right about "jre." Thanks. Thanks, @lukeis. That may have been clear to others but was not to me.
That does sound like a good reason for making sure that the jre artifact is newer than the android artifact. (As @shs96c noted, that doesn't help Android users, but I think we would have broken any Android users who used open-ended ranges when we released 21.0, which didn't come with an Android version.)
I'm guessing that there would still be problems -- say, if Selenium depended on something that requests 23.0-android, might Maven still pick that over the "newer" 23.0-jre, since it was requested specifically? And of course there's the problem I mentioned above in which someone wants 24.0-android and someone wants 23.0-jre: The only solution is 24.0-jre, which Maven is never going to figure out on its own.
I will keep thinking about all this. Sorry for the silence here. I'm going to try to discuss this with some others today.
Do you remember what the problems were when you switched from Guava's `Function` to Java 8's? It would also be good to hear from anyone else who is having a problem with this so that we get as good an idea as we can of the tradeoffs between 23.0-jre and 23.0. (The people I've been talking to have been recommending against version ranges, given that a build that works today might not work tomorrow when the dependency releases a new version. They say that a user can always force a newer version of a dependency when necessary. But I guess the upside of version ranges is that they increase the odds that Maven gives you the right version automatically? (And there's also the point you made about `Function`, which I'd like to understand better.)) Longer writeup here: https://docs.google.com/document/d/1NYGbfz56C0Oh4IGymXjeQUVK4FcRiqDbpc4vGLnDMrY/edit?usp=sharing
Comments welcome. I'm currently thinking that we should switch to the "24.0-jre" pattern, though we'd probably wait for Guava 24. > I think the root problem here is the difference between Java 8 and Android as base SDKs. Java 9 is coming in September, and will widen the gap further.
(We will likely keep the main artifact on Java 8, but I don't know that we've made that decision for certain. It's similar to how we stayed on Java 6 and (IIRC) upgraded straight to Java 8 without releasing a Java 7 version.)
> One solution is to shade the Android library into a different package. Libraries that expect to run on Android can make the move to the new package. Those that expect to run on the JRE need do nothing (or make a breaking change, and make everyone make a choice).
We're trying to serve the case of cross-platform libraries, too. It's possible that they could fork or preprocess their code, too, of course, but that has its own tradeoffs.
Ideally I should note this in the linked doc someday.
We also promise that it's usable as on the JRE (for Java 7 users). (I don't know enough about AAR to say more than that.)
> Given the fact that maven version/artifact resolution is not going to be
> incompatible, can we use some approach like maven-enforcer or whatever to
> supply constraints, such that a project won't have both in its deps graph?
My understanding has been that users can opt into such enforcement themselves, but we have no way of doing it for them. If users know enough to take action, the solution is generally simple enough (at least once we switch to `-jre`). The hard part is getting it right automatically most of the time. I replied to the latest comment on the doc a while back. I still need to go back and reply to the remaining comments on the doc. Sorry that I'm taking so long. For the moment, in any case, we're trying `-android` and `-jre`. Please let us know if that causes any new trouble.  Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit <https://cla.developers.google.com/> to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If your company signed a CLA, they designated a Point of Contact who decides which employees are authorized to participate. You may need to contact the Point of Contact for your company and ask to be added to the group of authorized contributors. If you don't know who your Point of Contact is, direct the project maintainer to go/cla#troubleshoot.
- In order to pass this check, please resolve this problem and have the pull request author add another comment and the bot will run again.
<!-- need_sender_cla --> CLAs look good, thanks!
<!-- ok -->  Note there is [already](http://google.github.io/guava/releases/23.0/api/docs/com/google/common/collect/ImmutableMap.html#toImmutableMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-) a `Collector` supporting a merge operation.  If you need query operations, then +1 to using a mutable map and doing `copyOf()` at the very end when you're ready to "freeze" it. Providing an O(n) containsKey might be actually worse than doing nothing, if people use it without checking the documentation and think it's O(1) instead of falling back to a mutable map.  javac9 -Xdoclint rejects this version :(
:memo: **Please visit <https://cla.developers.google.com/> to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If your company signed a CLA, they designated a Point of Contact who decides which employees are authorized to participate. You may need to contact the Point of Contact for your company and ask to be added to the group of authorized contributors. If you don't know who your Point of Contact is, direct the project maintainer to go/cla#troubleshoot.
- In order to pass this check, please resolve this problem and have the pull request author add another comment and the bot will run again.
<!-- need_sender_cla -->  We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA ([login here](https://cla.developers.google.com/) to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
In order to pass this check, please resolve this problem and have the pull request author add another comment and the bot will run again.
<!-- need_author_cla -->  Thanks.  GitHub ate my comment :( In short, I took most of this:
- not sure if we can do try-with-resources on old Android. ditto Integer.compare, etc.
- we aren't in the habit of omitting private from enum constructors (except on private enum classes)
- new instances in FreshValueGenerator is probably intentional
- double append() is harder to read in some cases, so string concat is nicer when performance doesn't matter
- MapsTest is specifically testing the newHashMap method
- not sure the Optional.map version is clearer than the original, but maybe I just need to get more used to functional programming in Java
- doesn't seem worth worrying about the semicolon after enum
- space in LittleEndianByteArray is from a google-internal comment
- maybe other things I forgot -- feel free to ask.  Is it possible for a thread to initialize, e.g., `InactiveComparisonChain` without first initializing `ComparisonChain`? If not, this may be benign. (See [a previous discussion of class-initialization deadlocks](https://github.com/google/guava/issues/1977#issuecomment-146659846).) And while eliminating benign cycles is still a good thing, I'm nervous about [using](https://github.com/google/guava/pull/2112#issuecomment-128842365) [`ThreadLocal`](https://github.com/google/guava/issues/2790) because it can produce leaks. There's probably a safe way to use `ThreadLocal`, but I'd prefer not to go down that road if we don't have to.  Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit <https://cla.developers.google.com/> to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If your company signed a CLA, they designated a Point of Contact who decides which employees are authorized to participate. You may need to contact the Point of Contact for your company and ask to be added to the group of authorized contributors. If you don't know who your Point of Contact is, direct the project maintainer to go/cla#troubleshoot.
- In order to pass this check, please resolve this problem and have the pull request author add another comment and the bot will run again.
<!-- need_sender_cla --> We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA ([login here](https://cla.developers.google.com/) to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
In order to pass this check, please resolve this problem and have the pull request author add another comment and the bot will run again.
<!-- need_author_cla -->  What a coincidence - we actually _just_ completed an API review on this
topic, so the changes should land externally soon (and be in Guava 24.0)
notifications@github.com> wrote:
>
> I've been using ImmutableList for a while. I notice that in more than 50%
> of the cases I know its size before I build it. Would it be possible to
> expose ImmutableList.builder(int capacity)?
>
> In fact, I can see this comment in the code:
>
> Builder(int capacity) {
>   super(capacity);
> }
>
> Best wishes,
> Paul
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2899>, or mute the thread
> .
>
--
These started landing recently by @lowasser in 7928bbe079303c54373453353c9ef2cd7de9365e and some other commits  I think that making our `@Beta` checker available so that you can get compiler errors if you try to use an `@Beta` API is more important for solving this (and that is something we'd like to do soon), but this doesn't seem like a bad idea either.
We can come back to this, but I'm not sure there's a stronger argument for this than there is for other Preconditions methods we've declined to add in the past.  A quick scan reveals e.g. #2053, #1833, #1572, #732.  Thanks - will be mirrored out shortly!  We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA ([login here](https://cla.developers.google.com/) to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
In order to pass this check, please resolve this problem and have the pull request author add another comment and the bot will run again.
<!-- need_author_cla --> CLAs look good, thanks!
<!-- ok -->  We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA ([login here](https://cla.developers.google.com/) to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
In order to pass this check, please resolve this problem and have the pull request author add another comment and the bot will run again.
<!-- need_author_cla -->  Why not just a Function? Note there already _is_ this for a bare `Function`: https://google.github.io/guava/releases/22.0/api/docs/com/google/common/cache/CacheLoader.html#from-com.google.common.base.Function- @ben-manes The type returned is `CacheLoader<Object, V>` because that's what the thing it returns is. It's a loader which is capable of accepting any Object, and returns a V. We could "pretend" that it's only capable of accepting some subtype of Object, but what would be the benefit of that? To the main question, I feel that creating doubled versions of everything to accommodate checked exceptions is a thing of the past. It's not worth it; you just have to tunnel them. > The current form forces the cache to be `Cache<Object, V>`
Does it? `CacheBuilder.build` has a `? super` for this reason.
https://google.github.io/guava/releases/22.0/api/docs/com/google/common/cache/CacheBuilder.html#build-com.google.common.cache.CacheLoader-
I'm not sure why you consider Optional "terrible considering performance."  Relative to almost any I/O operation, I'd expect the boxing incurred by Optional is going to be relatively minor.  I'd expect that to be the appropriate solution in most cases.
Do you have performance data -- perhaps from CacheStats -- suggesting otherwise? Maybe I'm missing something, but it sounds like you're thinking solely in terms of operations defined by `LoadingCache`, which is a subinterface of `Cache`.
Do the `Cache` methods `getIfPresent()`/`getAllPresent()` do what you want?  Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit <https://cla.developers.google.com/> to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If your company signed a CLA, they designated a Point of Contact who decides which employees are authorized to participate. You may need to contact the Point of Contact for your company and ask to be added to the group of authorized contributors. If you don't know who your Point of Contact is, direct the project maintainer to go/cla#troubleshoot.
- In order to pass this check, please resolve this problem and have the pull request author add another comment and the bot will run again.
<!-- need_sender_cla --> Can you explain your use case in more detail?  Why you're using `Properties` in the first place, given that it seems pretty ancient and rarely used?  I'm also not sure this adds all that much value over e.g. `properties.entrySet().stream().collect(toImmutableMap(...))`.  The types that we're catching are the ones documented to be thrown by [`Class.forName`](https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#forName-java.lang.String-). They're also sufficient to catch the failure we've seen if the class fails to load. If you're seeing something else thrown, let us know. Thanks! Sorry that I didn't try it myself. The failures we've seen have all been under Android, which may be implementing `Class.forName` differently. I'll see what I can do about this (and maybe report an Android bug, too).  Thanks, and sorry for the slow response. It's unfortunate that IBM would define this method only to make it not work, but I assume they have their reasons. If you're interested in adding `catch (UnsupportedOperationException e)` and an appropriate fallback, we could take a pull request. Thanks! I would probably lean toward `UnsupportedOperationException`. That way, if we accidentally break our implementation, we're likely to still see the resulting exception, rather than silently catch it.  In a recent review, I said:
> I wonder if there's a place for some kind of afterCommit() hook that, like afterDone(), runs upon a call to set()/setException()/cancel() but then *also* runs on a call to setFuture()....
The idea is that it could reduce duplication between `afterDone` and other "We just computed the value, so we're done with the inputs" code, like here:
https://github.com/google/guava/blob/2d4c517de9f12ba4dd2d9f720e700d7c835ecc4c/guava/src/com/google/common/util/concurrent/TrustedListenableFutureTask.java#L83
However, I'm not sure that a one-size-fits-all solution will work well here. Compare what we do in `AbstractTransformFuture`:
https://github.com/google/guava/blob/2d4c517de9f12ba4dd2d9f720e700d7c835ecc4c/guava/src/com/google/common/util/concurrent/AbstractTransformFuture.java#L89
There, we null out the input-future field even before we run the function. (Hmm, I guess that this prevents `toString` from giving full detail.... We might want to think about that more.)
I suppose that `TrustedListenableFutureTask` could similarly null out `this.task` immediately after reading it to a local variable. If so, then we could extract that nulling-out into a method that we call from both `run` and `afterDone`. But it's already just a single assignment. Even in the case of `AbstractTransformFuture`, it's only 2 assignments. Plus, it's nice to keep those assignments in the same method as the reads just to avoid needing to think more about cross-method dependencies. It would be one thing if we could automatically null out the fields at the beginning of `run`, but we can't because, well, we need the fields in `run` :) There is probably some possible crazy solution here -- a series of `RunnableTrustedFutureWithInputs1`, `RunnableTrustedFutureWithInputs2`, etc. classes with 1, 2, etc. fields of user-configurable type, all automatically read and passes as parameters to a `run(T1, T2, ...)` method (and `pendingToString(T1, T2, ...)`? and maybe even have a special class for "one of the inputs is a Future, so you should cancel it automatically?") -- but I don't think we need more layers of superclasses right now unless we have a very good reason. (Edit: And the T1, T2 parameters won't have useful names by default, though obviously subclasses can name them whatever they want.)
...OK, maybe I'm a *little* intrigued, in part because `AbstractTransformFuture`/`AbstractCatchingFuture` may share more code with `TrustedListenableFutureTask`/`InterruptibleTask` if we ever make them interruptible. At that point, we could consider sharing more code. But I don't think we're there yet.  Whoops, sorry. No, GraphTraverser is a dead end that you'll never have to see in Guava.  I've removed that reference from the release notes, thanks.  We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA ([login here](https://cla.developers.google.com/) to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
In order to pass this check, please resolve this problem and have the pull request author add another comment and the bot will run again.
<!-- need_author_cla -->  We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA ([login here](https://cla.developers.google.com/) to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
In order to pass this check, please resolve this problem and have the pull request author add another comment and the bot will run again.
<!-- need_author_cla -->  Looks like a guice bug to me.  ...in favor of just calling `setException` unconditionally.
I wrote in a code review:
> There's a decent argument that the work we do here and in MoreExecutors.rejectionPropagatingExecutor isn't really buying us much, since it's not clear where else a RejectedExecutionException would be coming from. And even if it is coming from somewhere else, the most plausible location of all the implausible locations is "somewhere after we already called set/setException/setFuture/cancel," in which case we could still call setException(), confident in the knowledge that it will be a no-op.
>
> Or maybe I'm forgetting something important. Beats me :) But certainly it's hard (impossible?) to write a test that covers this case. (`setException()` after `setFuture()` [should still be a no-op](https://github.com/google/guava/blob/71703b40b42c96dd1fef03a760e2e648db11f792/android/guava/src/com/google/common/util/concurrent/AbstractFuture.java#L674), weird as it is for `setException` to fail when the `Future` is not yet done. I actually forget why we did it that way. I guess it's probably faster to do the `setException` CAS that way, but I don't know that that would have driven our decision, especially since we could do an optimistic CAS first.) (I see a bit of internal discussion of the "no-op" question in go/hjmjt, but it doesn't go into a ton of detail.)
\[edit: see also introduction in go/omjqz and introduction of clone in go/trqox\]  I think I found a couple cases that didn't compile with `-source 7 -target 7` (which we use so that the Android version is usable under Java 7, too), thanks to difference in the compiler's type inference under those flags. But the rest of the changes are in. Thanks.  I'm not sure if it makes sense to expose spliterators as an API?  My impression has been that Collection exposes it primarily as a necessary implementation detail for the default Stream implementation, not because it's intended as an API for public use.  I believe these APIs already expose the appropriate primitive specialized stream implementations, from which you could, if you really wanted, extract a spliterator back out. Are we all talking about [`ImmutableIntArray`](http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/primitives/ImmutableIntArray.html) and friends? As Louis says, they currently [expose an `IntStream`](http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/primitives/ImmutableIntArray.html#stream--), from which you can get a `Spliterator.OfInt`, and [it's a "pure" `IntStream`](https://github.com/google/guava/blob/551343910c2974abf0e81d7728d975c6164f26b3/guava/src/com/google/common/primitives/ImmutableIntArray.java#L415), not a boxing one. This makes more sense to me now, but it's not automatically clear to me we can get the desired improvements.  `Longs.asList(long...).stream()` still has to return a `Stream<Long>`, not a `LongStream`, and we can't really expose new API methods on it.  It's not super clear to me whether overriding their internal spliterator implementations will actually result in the desired improvements, or just move the boxing from one place to another, but we can investigate.  Rather than try to provide a library for this, we recommend [AutoValue](https://github.com/google/auto/blob/master/value/userguide/index.md).  Thanks, fixed!  FYI, IIUC, Guava is unlikely to be using default methods in the near future because they aren't available in the Java 7 version.  Because we try to keep the 8 and 7 versions as close as possible, we generally end up using mechanisms that don't take advantage of Java 8.  This is a case where this probably won't be a high priority for us but we'd be happy to take a patch. You might also be interested in [`Monitor`](http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/Monitor.html), which includes `waitForUninterruptibly`.  It's unlikely that we would add something like this to Guava; while there are certainly good reasons to be looking for cliques (of various sorts) in a graph, the use cases are fairly specialized, by Guava's standards.
The next version of  [JUNG](http://jrtom.github.io/jung/), which is a more full-featured graph library, will be using the common.graph types; we're working on that conversion right now (see the common.graph branch for the current state of things).  Feel free to file a feature request there.   Updated: https://github.com/google/guava/wiki/CachesExplained/313fe22da68bca83ad5b688a1df39dbcb91a9208  Another option (instead of using a set) would be to use the old "fast pointer/slow pointer" trick.
I guess our only option would be to throw a runtime exception if we detect a loop? FWIW, I agree that it's _possible_ to cause an infinite loop here, but I'm not sure it's worth the small amount of code and the small runtime cost to avoid it. Then again, we could argue that these two methods are already trivial to write yourself, so it's worth doing everything we can to make them justify their existence.
I suppose that `getCausalChain` already has a `List` that it can call `contains` on (albeit in linear time, but presumably most chains aren't long enough for that to matter)....
I still tend to think it's not worth worrying about, but there are some thoughts, anyway. The only reason that I'm a little sympathetic to this request, is that I could see these APIs being used in exception handling code, which is often untested/unexecuted. If the user did have a causal chain with a loop, they wouldn't know it until the exception handling code was invoked (in production), at which point they'd get tossed into an infinite loop. Contrary to what Kevin says, I think that `printStackTrace` is smart enough to avoid this. I forget whether that protection existed from the beginning, though, or whether it was added when suppressed exceptions were. (Suppressed exceptions maybe make it slightly more believable that a loop would exist.)  Hopefully Ron is more familiar with this. I did find https://stackoverflow.com/a/27824549/28465 in some quick searching, plus the docs: https://docs.oracle.com/javase/tutorial/deployment/jar/packageman.html What's the difference between Specification-Version and Implementation-Version?
What's the expected value for Implementation-Version for log4j2 and what does it need it for with-respect-to Guava (how would that change what is logged)?
I found https://github.com/apache/logging-log4j2/blob/7fdca4ff159a4923949b45c33fd4601926be5ffc/src/site/xdoc/manual/layouts.xml.vm#L1617. It sounds like this would just include the Guava version in the stack trace?  I'm not sure I see the recursion here?  In fact, we've talked about changing `immutableEntry` to return `SimpleImmutableEntry` (especially on Android to save a class there). We were thwarted by some people who rely on `immutableEntry` to return a GWT-serializable object (though in principle we could do it anyway for Android, since we don't support GWT there). (We made some baby steps, deleting subclass `ImmutableMapEntry` in the Android branch in CL 150124044, and you can see where we got stuck removing `ImmutableEntry` itself in CL 146917938.)
At a higher level, I don't feel too bad about lacking a way to express `Entry` immutability in the type system: `Entry` objects rarely occur outside maps/multimaps, and the way Java generics work, `entrySet` is always declared as a set of plain `Entry` objects, never `ImmutableEntry`. (Possibly this is an argument for being willing to break the people who depend on `immutableEntry` to return a GWT-serializable type: How many people are serializing bare `Entry` objects, rather than serializing maps/multimaps? Of course I'm sure the answer is "more than zero," since presumably that's why we permitted serialization in the first place.)  This seems a special case of a more general question, which is -- to what extent should APIs that convert objects into strings deal specially with arrays?
Right now, essentially nothing I'm aware of does this.  No JDK collection has a `toString()` that deals specially with arrays.  I don't believe (?) the JDK even has a method for taking an arbitrary `Object` and using `o.toString()` if it's a normal Object and an appropriate `Arrays.toString` otherwise.  It seems like Java has just given up on this, in a lot of ways. > I don't believe (?) the JDK even has a method for taking an arbitrary `Object` and using
> `o.toString()` if it's a normal Object and an appropriate `Arrays.toString` otherwise.
```
String s = Arrays.deepToString(new Object[] { o });
return s.substring(1, s.length() - 1);
```
However, these "deep" methods are the exceptions that prove the rule; in every other case arrays are not given this kind of special treatment, and I agree that Joiner shouldn't either. Try to avoid using arrays as much as possible.  Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit <https://cla.developers.google.com/> to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If your company signed a CLA, they designated a Point of Contact who decides which employees are authorized to participate. You may need to contact the Point of Contact for your company and ask to be added to the group of authorized contributors. If you don't know who your Point of Contact is, direct the project maintainer to go/cla#troubleshoot.
- In order to pass this check, please resolve this problem and have the pull request author add another comment and the bot will run again.
<!-- need_sender_cla --> CLAs look good, thanks!
<!-- ok -->  Thanks. I'll remove that line.  @lowasser , any idea why we need null checks at all, given that `EnumMap` will do them? The checks date from http://go/34322860-null-checks My mistake: `EnumMap` permits null _values_. > It would be a little less efficient than using `EnumMap(map)` constructor in case of non-views (`put()` vs `putAll()`)
Only in the case of copying from an `EnumMap`, it seems? (And we could use `clone()` for that case if we really want.)
Actually, maybe what we should do is just perform the null checks _after_ copying to the `EnumMap`? "Not lazy" in the sense that, if the transformation function returns `null`, we might transform other values before throwing? That seems probably tolerable.
I think that that search was for top-level classes with a single `abstract` method, and `Monitor` happened to be one. A search for nested classes might well have turned up `Monitor.Guard` (and perhaps more).
And sorry, I thought I'd replied to this, but obviously I never did. I think I'd meant to run it by the main remaining author of `Monitor`. I'll do that tomorrow. This seems reasonable, but since it's an API change, it would need to go through our internal API Review process. That means it needs someone internal to drive it. I'll float the idea to people looking for such a project, but I can't promise anything soon. Sorry.  With the presence of try-with-resources, I'm not sure I understand what's painful anymore about resource management that requires the intervention of lambdas at all.  I'm not sure why you wouldn't just write
```
CharSource source = ... ;
Properties props = loadProperties(source);
Properties loadProperties(CharSource source) throws IOException {
try (Reader reader = source.openReader()) {
Properties properties = new Properties();
properties.load(reader);
return properties;
}
}
```
The addition of the lambdas doesn't seem to buy much; the only thing you're doing is eliminating the try-with-resources block, which is not really adding that much complexity here.  Am I missing something?  It sounds to me instead like this is a request for an unordered pair class that can be put into `Set`s.  This is at least a reasonable API, but we've generally been against pair classes; I'm not sure if unordered pairs are likely to be different. Why not represent this as an undirected common.graph.Graph with a self-loop incident to each node?  That's an obvious representation of a reflexive symmetric relation; transitivity is either implicit via reachability or you can enforce it when you add an edge. Seems like the options provided here cover most of the requested features. Feel free to comment if you think this issue isn't sufficiently addressed with them and we can reopen.  Thanks. We have some notes about this internally, to which I've added your points.
[Dagger](https://github.com/google/dagger) moved to Bazel a while back, so we have some reason to believe that it would work. On the other hand, Guava has some special requirements (like GWT testing) that I'm not sure are well supported in Bazel at the moment, so we might end up blocked on those. > Do you know if Dagger receives bug reports from its Windows users who wish to build Dagger from scratch?
I didn't see anything from a quick search of its bug database, but @ronshapiro would know better.  Sorry, I'm not too closely involved with the graph work, so I'll leave that to the people who are.  Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit <https://cla.developers.google.com/> to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If your company signed a CLA, they designated a Point of Contact who decides which employees are authorized to participate. You may need to contact the Point of Contact for your company and ask to be added to the group of authorized contributors. If you don't know who your Point of Contact is, direct the project maintainer to go/cla#troubleshoot.
- In order to pass this check, please resolve this problem and have the pull request author add another comment and the bot will run again.
<!-- need_sender_cla --> CLAs look good, thanks!
<!-- ok --> Why copy when you can use Iterables.unmodifiableIterable?  That'll let you safely treat an `Iterable<? extends T>` as an `Iterable<T>`. We're still working out the details, but we are working on integrating the capabilities of TreeTraverser into the new-ish package common.graph.  Specifically, I expect that we will _probably_ be retiring TreeTraverser in favor of capabilities based on the new [SuccessorsFunction](https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/graph/SuccessorsFunction.html) and PredecessorsFunction types.
And to come back to your original concern: those types _do_ return `Iterable<? extends N>`. Yes, there are going to be various traversal options including preorder.  Wouldn't be much of a replacement otherwise.  :) The details are still pending review but there should be something soon, probably in a few weeks.
Hope this helps.
We do release other things under `com.google.common`, but in the discussion linked by @Stephan202, we're told that's not a problem for using that module name. As @kevinb9n said [here](https://groups.google.com/forum/?utm_medium=email&utm_source=footer#!msg/guava-discuss/1I--H7xwwR8/fbvZJCRaBAAJ),
> Provisionally, the name `com.google.common` seems fine. @jodastephen's [recommendation](https://groups.google.com/d/msg/guava-discuss/1I--H7xwwR8/OLvJo-FhAwAJ) was simply to declare which module name we choose. (And I think we're all happy with `com.google.common`.) He hadn't recommended specifically to us that we set `Automatic-Module-Name`, but [his later blog post](http://blog.joda.org/2017/05/java-se-9-jpms-automatic-modules.html) sounds to me like it recommends the practice in general. Stephen -- just to check explicitly -- do you recommend that we set `Automatic-Module-Name`? Is there any downside, given that we're happy with `com.google.common`? Thanks.
I'll get this submitted internally and then mirror it out.  That does sound environmental: Apparently your system doesn't support `SecureDirectoryStream`.
Likely we should catch exceptions from the failing `deleteRecursively` call; we don't need to fail the test just because we fail the cleanup. I can give that a shot.  https://github.com/google/guava/commit/941932c2c4a10a11df6453ec7bc78f55e12617ce  Colin would know if there's a reason that this is the way it is. I can't think of a particular reason that it needs to be like it is. The suggested change is probably good. If we trust the known size when it's 0, I don't think there's any reason we shouldn't trust it when it's non-0. (In fact, I'd say it's _more_ likely that we should trust it when it's non-0.)  Personally, I'm not sure it was ever entirely correct to mark these methods deprecated. The hash function you need to use is often dictated by another system or data that was already persisted and can't be changed. If the format chosen was md5, then Hashing.md5() is the one and only best choice to use.
We want to discourage people from choosing it when they have the actual freedom to select their hash function - but there's no way to express that.
*Maybe* providing each under two different names, with only one of them marked deprecated, is indeed the right way out of this. I'm not sure yet. I would consider naming the non-deprecated ones with the prefix "legacy", like `legacyMd5()` -- the md5 you use when it's for legacy reasons. Interesting to know about Scala, thanks.
Is it possible to define your own `LegacyHashing` class that provides `md5` and `sha1` methods that delegate to ours and then to suppress warnings for that class only (either by compiling it separately with different flags or by doing something like [this](https://issues.scala-lang.org/browse/SI-7934?focusedCommentId=66403&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-66403))?
Possible solutions:
- Stop including benchmark sources in test compilation. (We manually include them, so we could just stop.)  Possible downside: We might not notice if we unintentionally release a benchmark publicly.
- Move benchmarks to an entirely separate `pom`. Downside: At least a mild pain.
- Move to Bazel someday, and do what we do internally: Put the benchmarks in a separate target. (This is similar to "separate `pom`" but easier, at least if we assume away the "move to Bazel" part :))
- Modify `PackageSanityTests` to skip benchmarks.
- Modify `PackageSanityTests` to skip `main` methods, which might be enough?
But we can also just live with this.  The badge on https://github.com/google/guava, that is. I guess that it considers 22.0-android to be the newest version? I thought we concluded that Maven considered 22.0 to be greater than 22.0-android, so perhaps this is just a bug in the badge service.
Ideally we'd probably pick 22.0, or really we might do both. I'm not sure if it's worth hacking up something manually, though, or trying to get https://github.com/jirutka/maven-badges to do the right thing.
(The doc links to [instructions on how to depend on Guava](http://search.maven.org/#artifactdetails%7Ccom.google.guava%7Cguava%7C22.0-android%7C), so getting it right would at least be helpful.) @elharo pointed out to me that [the Maven metadata](https://repo1.maven.org/maven2/com/google/guava/guava/maven-metadata.xml) also considers 22.0-android to be the most recent :(
We'd seen [some docs](https://docs.oracle.com/middleware/1212/core/MAVEN/maven_version.htm#MAVEN400) that said that all versions with qualifiers come before all versions without qualifiers. It sounds like that [had](https://stackoverflow.com/a/31482463/28465) [changed](http://wayback.archive.org/web/20150520230652/https://docs.codehaus.org/display/MAVEN/Versioning) as of Maven 3.0. [Now](https://maven.apache.org/ref/3.3.3/maven-artifact/apidocs/org/apache/maven/artifact/versioning/ComparableVersion.html) all qualifiers other than the standard ones (alpha, beta, rc, etc.) come after all the final version.
Maybe we should have 23.0-android and 23.0-server or something similar? I'm sure that will surprise people who just try to bump the version to 23.0, though. (I guess we could have 23.0, 23.0-android, *and* 23.0-server, with 23.0 identical to 23.0-server, but I'm not sure that's really buying us a lot, since people who use 23.0 may still end up with 23.0-android.) Now that I think about it, I wouldn't be surprised if this (Maven considering 22.0-android to be latest) simply has to do with the fact that I released 22.0 first and 22.0-android second (they can't be done at the same time AFAICT). I would like to think that Maven is smart enough to look for the "highest" version in any case (e.g., in case we were to go back and release a 22.0.1 after 23.0), but it's certainly possible that it uses release order as a tiebreaker when it's unsure what to do with the qualifier. After looking at https://cwiki.apache.org/confluence/display/MAVENOLD/Versioning, though, I'm pessimistic: "notice that the proposal reverted the order: in Maven 2, 2.0.1-xyz < 2.0.1 but in Maven 3, 2.0.1 < 2.0.1-xyz." Still, I think it's worth a shot, since presumably releasing the two in the other order isn't hard to try. And for what it's worth, no one has reported a problem other than elharo@. That's odd, though, because it sounds like it would mean that 23.0-rc1 > 23.0. I see, thanks.
I'd suggest that for starters we just get rid of the Maven version badge since the README itself is generally kept up to date with the latest release. Sounds like a good move.
Hopefully Gradle users aren't having too much trouble with 22.0-android as "latest." (Colin did remove the badge. I'll close this in favor of #2914, which has some more discussion about versioning in general.)  As a workaround, you can explicitly depend on the annotations from your own project: https://github.com/google/guava/issues/2721#issuecomment-275220035 At least, I've been led to believe that that works.
I am conflicted about releasing a 20.0.1 and 21.0.1 because apparently our change to provide the dependencies in 22.0 caused people some trouble, too: https://github.com/google/guava/issues/2824 + https://github.com/google/guava/issues/2831 Since we've seen less trouble with this than I expected, I feel OK with asking people to work around it. That's true especially because, if we release 20.0.1 and 21.0.1, people will probably upgrade and break in different ways (as noted above). But if other people are experiencing this, please speak up. Ditto if the workarounds don't work for you. It's possible that we could release something like a "20.0-rc99" that people could opt into but that most people wouldn't use because it's not considered an "upgrade" from 20.0. Thanks. I'm glad to hear that exclusion is working out better.  A stack trace without repo instructions doesn't give us much to work with...  How are you configuring your MapTestSuiteBuilder?  It sounds like maybe you're passing CollectionFeature.SUPPORTS_ADD, which you shouldn't be doing?  None of the views of a Map should support add methods, as per their Javadoc.  FWIW: I believe the reference implementation is `ArrayList`?
The Javadoc of `remove()` makes no reference to `hasNext`.  It specifies that ISE can be thrown if next hasn't been called at all, or if remove has been called "after the last call to the next method."  It certainly doesn't say `hasNext()` invalidates a `remove()` call, and the phrasing "after the last call to the next method" pretty strongly implies other calls are acceptable in between.  Can you explain in more detail why you think IAE should be accepted?
The `Collection.addAll` Javadoc specifies that an NPE should be thrown "if the specified collection contains a null element and this collection does not permit null elements."  The JDK has a similar policy generally of throwing NPE on null elements.  This looks like it's checking the spec correctly to me?  There's some discussion here: https://github.com/google/guava/issues/2824. The short answer is "yes" :)  With Java 8's enhanced comparators, we're trying to not make any changes to `Ordering`. The `ImmutableSortedSet.copyOf(Comparator, Iterable)` method should do the trick, right?  So, we *have* been thinking about this, but the approach we've been using, at least within Google, is a little surprising.
We tended to see reinventing `java.util.function` or especially `java.util.stream` as a non-starter.  Additionally, the situation gets astronomically more complex if you have multiple checked exception types; you either need functional types for 2, 3, etc. checked exceptions, or you need to accept a common supertype of all your checked exceptions, which isn't really satisfactory.
So what we did instead was to introduce a class `TunnelException`.  It looks like an entirely conventional runtime exception that wraps a checked exception.  It doesn't expose a constructor; there's a static method
<T> T tunnel(Callable<T> lambda)
...which runs `lambda` and wraps any thrown exceptions in a `TunnelException`.  So far this isn't much different from just wrapping your checked exceptions in a `RuntimeException`.  It's just a specific type of runtime exception.
But what we did on top of that was add specialized support in [Error Prone](https://github.com/google/error-prone/) that enforces at compile time that you catch `TunnelException` in the same method, and "un-tunnel" it: call `TunnelException.getCauseAs(SpecificExceptionType.class)` to extract exactly the checked exception types that the lambda could throw.  From there, you can rethrow them outside the method, handle them directly, or whatever you choose, just as a normal exception.  So your checked exceptions go through a `RuntimeException` "tunnel," and the compiler makes sure the tunnel comes out somewhere.
- using https://github.com/google/google-java-format to match https://google.github.io/styleguide/javaguide.html
- removing `@author` (we're trying to phase that out but haven't done so yet)
- testing parsing zero with various radixes
I'll put something in the release notes. We should think more about whether dependency version bumps should show up in the release notes in general. https://github.com/google/guava/wiki/Release22#additional-changes
That may be all we can do, but if anyone has other ideas, I'm all ears. Sorry for the trouble. Ah, sorry, I'd missed that one. I think I feel better with the current version, which requires action from people who use dependency convergence (and who presumably understand the problem and how to fix it), than with the proposed alternative, which requires action from people who are turning on warnings or using annotation processors (who might see a variety of different errors and might not know how to debug them). I know that that's still a bad experience for you; it just seems like it has to be a bad experience for someone for all the reasons to diamond dependencies normally are a bad experience :( /cc @cgdecker re. 23.0-rc1 concern @cpovirk's conclusion above seems to have been that of the two options we have, both of which cause issues for some people in some way, we should stick with what we're currently doing. So 23.0 will continue to have those dependencies as non-optional.  @ankit2771991 `ValueGraph.edgeValue(u, v)` returns the value of the edge between `u` and `v` if there is one, and throws otherwise: [Javadoc](https://google.github.io/guava/releases/21.0/api/docs/com/google/common/graph/ValueGraph.html#edgeValue-java.lang.Object-java.lang.Object-)
What you're asking for is effectively the length of a path between 1 and 3.  We're considering releasing capabilities for shortest paths and/or distances, but they likely won't be available until Guava 23.
`Range<C>.contains` accepts only a `C`.  That means at some point you did an unchecked cast from `Range<Integer>` to `Range<Double>` or the like, no?  And that unchecked cast should've given you a compiler warning telling you about potential ClassCastExceptions. But `Range range = Range.downTo(0)` is still a raw type that should give you a compiler warning: it should complain that Range is a raw type without generic arguments.  The issue is the same as the unchecked cast would be: the compiler should give you a warning that you're risking ClassCastExceptions.  The compiler would want you to write `Range<Integer> range = Range.downTo(0)` and that would reject an attempt to compile `range.contains` on a double. Stepping back: I don't think you can get a ClassCastException here without evading proper generic type checking and getting a compiler warning telling you so.  Raw types and unchecked casts can both produce that result, but they'll both cause compiler warnings telling you you're risking CCEs. I would have expected a raw types warning on the line `Range build()` there: shouldn't it require you to write `Range<T> build()`? As Louis points out, the raw `Range` type seems to be what's causing the problem. Closing.  See http://errorprone.info/bugpattern/CollectionIncompatibleType and http://smallwig.blogspot.com/2007/12/why-does-setcontains-take-object-not-e.html
(There's also [a Stack Overflow question](http://stackoverflow.com/q/857420/28465), but nearly all the answers are incorrect.)  Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit <https://cla.developers.google.com/> to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->  Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit <https://cla.developers.google.com/> to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->  We're certainly aware of this, but we haven't yet been deprecating *any* methods that have replacements in Java 8.  We have been documenting the equivalences, though, and we can probably do that here.
Without supporting data, we generally don't make [micro-optimizations](http://wiki.c2.com/?RulesOfOptimization) like these.  Can you back up a minute and explain what it is that you're trying to accomplish, i.e., what problem you're trying to solve and how your data structures relate to it?
For starters, why do you need Equivalence in the first place? Thanks for the explanation, that does clear things up.
Probably the API for such a thing--if we were to provide it--would involve adding an option to the *Builder classes, and probably to the `Graph`/`ValueGraph`/`Network` interfaces (so you could recover the `Equivalence` instance from the graph, to enable things like creating another graph with the same properties).
I would need to be convinced that we should make these changes, though:
* I suspect that there are relatively few people who would need this capability, so I'm not sure it would be worth the additional API load
* I'm pretty sure that it would mess with the implementations that we have something fierce.  :/
If you really need to use `Equivalence`, I'm afraid that your current solution, or providing a custom implementation of your own, is probably your best bet.
That said:
For the system that you're trying to model, it's not clear to me that any two nodes _should_ be equal.  In particular, the triple (computer, message, timestamp) seems like it would uniquely (and appropriately) identify an event, because a computer can't send two of the same message at exactly the same timestamp [1].  (And presumably you have to have timestamps because otherwise you wouldn't know how to induce edges.)
Perhaps there's a reason why your model is constructed such that there can be identical events, but I don't know what that reason would be.
[1]  Well, with multiprocessor systems and parallel I/O buses, maybe, but at that point it might be worth modeling the different processors as different entities anyway. For what it's worth, @kevinb9n, at least, has pushed back heavily against supporting custom equivalences (specifically for `MapMaker`, but his point was more general). He's pushed heavily for the `Equivalence.Wrapper` solution (on top of which you may wish to wrap the graph yourself to provide an API that speaks the underlying types you want).
I haven't thought about this in as much detail as he has, so I'll just say "I agree" and leave it to him to copy and paste from a "Equivalence/MapMaker" thread last year or otherwise weigh in if he's so inclined :) @jbduncan email sent.  :)
Based on the discussion up to this point, I think that we have pretty much arrived at not adding support for the requested feature.  Sorry for the inconvenience.
If you (or someone else) comes up with more compelling arguments for providing this capability later, then we can reopen this issue.  We just answered a feature request to make BloomFilters thread-safe in https://github.com/google/guava/pull/2761 , I think less than a week ago.  We found those arguments compelling: it doesn't seem to incur significant overhead; it was a pretty straight conversion from a long[] to an AtomicLongArray.
It does seem reasonable that we should expose a Java 8 collector, though, which we can give the [`Collector.Characteristics.CONCURRENT`](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.Characteristics.html#CONCURRENT) property, which would allow it to benefit from concurrency when used with parallel streams.  That makes tons of sense to me; I think we'd just have to figure out the API and method naming.  I'm not sure what you're saying?  We do have these collectors, in the respective immutable collection classes: e.g. [`ImmutableList.toImmutableList()`](http://google.github.io/guava/releases/21.0/api/docs/com/google/common/collect/ImmutableList.html#toImmutableList--).  Is there something about those that doesn't match what you're looking for? Mostly, I think, because the JDK set the opposite expectation. But it makes
collected... once you get used to looking for them there.
notifications@github.com> wrote:
> Argh... okay. That certainly isn't where I expected to find a collector. :/
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2809#issuecomment-299776024>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AA5Cl2Cjx9p77sBcoJ9J16qx33X_ABP8ks5r3qfCgaJpZM4NTemL>
> .
>
--
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit <https://cla.developers.google.com/> to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla --> We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA ([login here](https://cla.developers.google.com/) to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
<!-- need_author_cla -->  Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit <https://cla.developers.google.com/> to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla --> CLAs look good, thanks!
<!-- ok -->  I haven't checked, but I wonder if this was broken by CL 112701959. (And thanks very much for reporting this!)  I suspect that we want:
( cd android && ... )
Instead of:
cd android && ...
So that we restore the original directory for the later commands. Currently, I think that we're changing directory for `install` and then ending up in the wrong place for `verify`.  Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit <https://cla.developers.google.com/> to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla --> CLAs look good, thanks!
<!-- ok -->  Uh... weird.  The spreadsheet is at
https://docs.google.com/spreadsheets/d/1kq4ECwPjHX9B8QUCTPclgsDCXYaj7T-FlT4tB5q3ahk/edit?usp=sharing
... not sure why the link ?changed? or what happened.  Does that look worth
linking to?
On Sun, Apr 23, 2017 at 12:14 PM, Eric Edens <notifications@github.com>
wrote:
> The linked Google Spreadsheet is no longer available (at least
> externally). I think it's fine to remove since the link to unicode.org
> details which codepoints are defined as whitespace.
>
> Also, I double checked, and the list hasn't changed compared to what's
> used in CharMatchers.
> ------------------------------
> You can view, comment on, or merge this pull request online at:
>
>   https://github.com/google/guava/pull/2798
> Commit Summary
>
>    - Remove broken link in JavaDoc of CharMatcher
>
> File Changes
>
>    - *M* android/guava/src/com/google/common/base/CharMatcher.java
>    <https://github.com/google/guava/pull/2798/files#diff-0> (8)
>    - *M* guava/src/com/google/common/base/CharMatcher.java
>    <https://github.com/google/guava/pull/2798/files#diff-1> (8)
>
>
>    - https://github.com/google/guava/pull/2798.patch
>    - https://github.com/google/guava/pull/2798.diff
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/pull/2798>, or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AA5Cl6ySJDkKJwc-GtsYcLIrKw8C2C_tks5ry6MugaJpZM4NFgVV>
> .
>
--
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
No worries, it'll be easier to do it from my end - I'm on that now. Thanks
again.
On Wed, May 10, 2017 at 2:41 AM, Eric Edens <notifications@github.com>
wrote:
> Cool! That other link works from my side.
>
> I think the spreadsheet is a great reference (and I've seen it referenced
> around the net) so I think it's definitely worth keeping.
>
> I'll update the PR I'm the next few days to swap the link.
>
> 
> You are receiving this because you were assigned.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/pull/2798#issuecomment-300430894>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AA5ClxBwyzHu3IMvt8q-5BJgKkoYWSprks5r4YZEgaJpZM4NFgVV>
> .
>
--
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
We'll take a look. There are a number of things about it that we've hoped to eventually change, but it's hard to see when we would ever get around to them, so perhaps we should just finalize it. Sure, thanks.  Thanks, but: ["If the multimap is modified while an iteration over any of those collections is in progress, except through the iterator's methods, the results of the iteration are undefined."](http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/LinkedListMultimap.html). It's possible that we could guarantee the results, but the JDK generally does not, likely because it requires some extra work, could prevent future implementation changes, and ties the user to a particular choice of multimap.  Are you noticing actual performance problems from this API?
`ToStringHelper` is designed to make writing `toString()'s` easy. If you require a super performant implementation of `toString()`, you're probably better off rolling your own. I still think providing more flexibility here isn't a great idea. `ToStringHelper` already builds up a linked list of wrapped entries, so it's not designed to be high performance. I worry that by providing the overload, we're going to have users trying to count the number of characters in their `toString()`s by hand, and that seems wasteful.
`StringBuilder` expands by doubling it's internal buffer...the string would have to be pretty enormous for this to happen more than a few times. Yea, the reason we have to store the values is to allow the `omitNullValues()` option to come anywhere in the chain. Unfortunately, changing that behavior would be a breaking change, and therefore is probably off the table. >5k strings means ~9 resizes of the buffer, which I'll admit is less than ideal...where are your `toString()`s being invoked? Logging? Output? Is it performance critical code? (Does it actually mean that many resizes of the buffer, though?  new StringBuilder(32).append(fiveThousandCharString) should do just one resize.  If the 5K characters all come in one append, that shouldn't incur intermediate resizes, I'd expect?) @lowasser Right, sorry, if they come all at once, it'll do 1 resize. My number was worst case.
from 2^5 (32) to 2^13 (8096) means 13-5 = 8 resizes  The change itself gives it as `@since 23.0`. I'll add that we have every intention of a much shorter time gap between 22 and 23 than you're used to. I understand if that's not credible though. :-)  I wonder if there's any chance that the jar was corrupted during download. If you delete `.m2\repository\com\google\guava\guava-gwt\21.0` and let Maven download it again, does it work any better? Thanks. Are you able to provide a self-contained example that reproduces the problem? Unfortunately, my experience with Guava-GWT problems has been that I usually can't reproduce them unless someone hands me a project that I can run `mvn` on myself. Otherwise, I end up using different settings somewhere that fail to reproduce the problem :( Closing for now - please re-open if you are able to provide such an example.  Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit <https://cla.developers.google.com/> to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla --> CLAs look good, thanks!
<!-- ok -->  Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit <https://cla.developers.google.com/> to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla --> We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA ([login here](https://cla.developers.google.com/) to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
<!-- need_author_cla --> I'm not sure I follow what aspect of this new method is superior to the original.  The "boilerplate code" you're eliminating seems to be getting replaced with roughly the same number of characters in the method call.  The first version is utterly normal, predictable Java that you don't have to know about a special library method to interpret.  Or maybe not: I was pretty underwhelmed by what my search turned up:
$ grep -rcE '^  (protected|public) .*abstract' . | grep ':1$' | grep -v -e Immutable -e Forwarding -e ImmediateFuture -e Monitor -e ServiceManager -e Abstract -e CacheLoader -e Ordering -e TreeTraverser -e Sets -e LineBuffer -e ArrayBased -e CharMatcher | cut -d : -f 1
./com/google/common/base/Ticker.java
./com/google/common/util/concurrent/WrappingExecutorService.java
./com/google/common/escape/Escaper.java
./com/google/common/io/ByteSource.java
./com/google/common/io/ByteSink.java
I looked at the first dozen `ByteSource` implementations turned up by a search of Google's code. Only 2 could have used a hypothetical `ByteSource.from(IoCallable<InputStream>)` (and they'd be giving up `toString()` implementations to do so). And only now that I'm writing this do I realize that we'd need an `IoCallable<InputStream>` :) So the I/O classes are not a good example.
...OK, I just looked at about a dozen `Ticker` implementations. About 4 of them could have used a `Ticker.from(LongSupplier)`. But that projects out to only a few dozen users in all of Google's codebase. (And some of them are in Android, so they're not going to be able to use it.)
I think I'm just going to close this. It's looking more like the results of a not very exciting 15-minutes research project than an actual call to action :) Data if we extend to 2 methods:
$ grep -rcE '^  (protected|public) .*abstract' . | grep ':2$' | grep -v -e Immutable -e Forwarding -e ImmediateFuture -e Monitor -e ServiceManager -e Abstract -e CacheLoader -e Ordering -e TreeTraverser -e Sets -e LineBuffer -e ArrayBased -e CharMatcher | cut -d : -f 1 | grep -v /android/
./guava-testlib/src/com/google/common/collect/testing/SortedMapInterfaceTest.java
./guava/src/com/google/common/base/Converter.java
./guava/src/com/google/common/base/Equivalence.java
./guava/src/com/google/common/reflect/Invokable.java
We already did Converter and are considering Equivalence now. The others are false positives.
$ grep -rl 'public interface' . | grep -v -e /android/ | xargs grep -L 'interface .* extends ' | xargs grep -c '^[^*]*);' | grep :2$
./guava-testlib/src/com/google/common/collect/testing/google/TestBiMapGenerator.java:2
./guava/src/com/google/common/util/concurrent/FutureCallback.java:2
./guava-tests/test/com/google/common/io/TestStreamSupplier.java:2
We're considering FutureCallback sometime. The others are false positives. I'll do that next "doc fix-it day".
Since that's right now, I'll do that now.
On Fri, May 12, 2017 at 11:44 AM, Ben Manes <notifications@github.com>
wrote:
> I think you should highlight the existence of CacheLoader.from(func) for
> lambda usage in the JavaDoc.
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2785#issuecomment-301155619>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AA5Cl-s25KbG8btwz_8B_ZHRgotYQ4X2ks5r5KipgaJpZM4M7sa5>
> .
>
--
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
I think you're right, and that the change would be compatible for conventional consumers of this API. Unfortunately, it appears that a fair proportion of users unit-test their children() method directly, with some fraction of them storing its result in a variable, so we would break those callers.
We might be able to fix this for common.graph.{Suc,Prede}cessorsFunction, though, which has no compatibility issues yet. @HermanBovens we are discussing this internally now, thanks for starting the conversation.
For context: `SuccessorsFunction<N>` is a new `common.graph` API that, in conjunction with some other enhancements to the common.graph utilities, we expect to replace `TreeTraverser`, as part of unifying the graph-related Guava code under common.graph.  We're working out the details now, and it will be a while before `TreeTraverser` goes away entirely, but that's the plan, in broad strokes.
In any event: I'm not sure I understand your use case.
IIUC, you have a heterogeneous structure composed of InternalNodes and LeafNodes, and you want to traverse it, as type-safely as possible.  Let's say that InternalNode and LeafNode each extend TreeNode.
given
````
someGraphFunction(SuccessorsFunction<N> sf) { ... }
````
and
````
class TreeNode {
List<TreeNode> getChildren()
}
````
you want to call it like this:
someGraphFunction(TreeNode::getChildren)
This will already fail because `SuccessorsFunction.successors()` returns a `Set<N>`, not an `Iterable<N>`, so instead you'll need to do this:
someGraphFunction(n -> ImmutableSet.copyOf(n.getChildren());
which (copying) is one of the specific issues you were concerned about.
Note that `getChildren()` in this scenario returns a `List<TreeNode>` (not a `List<? extends TreeNode>`), so it dodges your original question; my purpose in starting here is to emphasize that (given the specifics of your scenario as I understand them) you already may have a reason that you need to copy.
(Why `Set`?  There was a lot of internal discussion about this, but what it came down to is that it has the right semantics, i.e., unique elements, as well as (typically) fast contains() implementations.)
But suppose `getChildren()` returned a `List<? extends TreeNode>` instead: how does that help anything?
`getChildren()` has to be able to return both leaves and internal nodes because it can't know a priori whether the nodes it's returning will be leaves, internal nodes, or both.  So it has to return a collection of `TreeNode`, and the wildcard seems useless.  You can't even cast it, because you don't know what's in it.
Am I missing something blindingly obvious? FYI, `{Predecessors,Successors}Function` will be released in Guava 23 (are currently in the snapshot) and the return type of the method has been changed to `<? extends Iterable>`: https://github.com/google/guava/blob/master/android/guava/src/com/google/common/graph/SuccessorsFunction.java
The fate of TreeTraverser is still being worked out, but I believe that we're fairly solid on the overall (incorporating that functionality into common.graph). Calling this resolved now that we've settled on a design for `Traverser` and for `SuccessorsFunction` that will resolve this issue going forward.  (Existing uses of `TreeTraverser` should be relatively easy to port to using the new `Traverser` class.)  This isn't something that would fit well in Guava - if you want to create your own injectable wrapper, that's fine. We don't expect injection of system properties in this manner much.  Thanks so much for finding and reporting this!  Please be specific.  What do you mean by "doesn't work"?
cleanUp won't eliminate entries unless they've actually expired after 600 seconds. Yep.  `Cache.cleanUp` only deletes entries which have properly expired, etc. but have not yet been evicted from the cache.  It will _not_ evict entries which would not otherwise be evicted.  Oops. Fixing. Java serialization and GWT serialization are both OK, as I understand it. The problem is just if someone uses reflection or bytecode generation to call the private constructor directly.
On the one hand, if we're going to make our code resilient to frameworks that call private constructors, we'll have a ton of work to do. On the other hand, using `==` instead of `instanceof` is merely an optimization, and one that I can't imagine will ever matter, and it's easy enough to make the switch in this one case where it's known to cause a problem. I've added the tests that should have existed, but they pass. Does "Kryo serialization" circumvent Java serialization and not invoke readResolve? Although Chris is right that making the specific change requested here
types in ways like this. They're going to have a lot of problems. I'm
On Wed, Apr 5, 2017 at 11:34 AM, Micha Sobkiewicz <notifications@github.com
> wrote:
> Absent extends Optional, so it can't extend Enum.
>
> 
> You are receiving this because you commented.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2779#issuecomment-291954620>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AA5Cl86Rsh3BZOIONw6-KE-GZgTb3LATks5rs96igaJpZM4M0Mw_>
> .
>
--
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
With such a tool, you should expect what happens to work to be completely unpredictable. Kryo and other tools that don't respect the way built-in serialization works, I think, where we're already taking the appropriate steps to e.g. handle singletons correctly.  I wonder if we might key this to whether the original graph permits self loops? We could certainly key this to whether the original graph permits self-loops; that's easy.
The question of correctness is a bit tricky, though.  Transitive closure is determined in terms of reachability (at least one [reference](http://reference.wolfram.com/language/ref/TransitiveClosureGraph.html) calls a transitive closure a "reachability graph"), and the definition of reachability that seems to be the most prevalent IME is "w is reachable from u if there exists a path from u to w".  Note that in Guava's definition of `Graphs.reachableNodes()` we specify that u is reachable from itself (and this seems to be consistent with most definitions AFAICT).
So the question is whether it makes sense to explicitly represent the reachability of u from itself as a self-loop or not.
Some options for resolving this:
(1) Make the definition more explicit so people won't be surprised.  (Right now the definition incorporates the definition of reachability by reference.)
(2) Let the addition of self-loops be contingent on whether the original graph permits them.
(3) Add an option (parallel method, boolean parameter, etc.) to allow (or require) the user to explicitly specify whether they want self-loops or not.  (One option here: require the user to provide their own GraphBuilder instance.)
There may be other options as well.
Thoughts, anyone?  Thanks so much for telling us -- it should actually be fixed in the next release candidate. Fixed by https://github.com/google/guava/commit/7b2c5ccbf7b1c8c6715a6c5aa9aded6420205d83  Evidently we have a competing internal class that we've been intending to reconcile this with. Possibly we should just admit that we'll never get around to it :(  It's by design, more or less.
I don't know if that particular example ever comes up (though it might), but I think that similar cases do. For example, I think that we have something like this: An `unmodifiableMap` implementation defines a `forwardingUnmodifiableEntrySet` method that wraps each entry in `unmodifiableEntry` before returning. If we start forwarding its `spliterator()` calls, then users can access the underlying modifiable entries.
For what it's worth, we suspect that [many forwarding collections already have bugs like this](https://github.com/google/guava/issues/1575), where users don't override all methods that they should. But the problem is worse for `default` methods, where the users couldn't override before. And in theory, Java could introduce new `default` methods at any time, so, even if we were writing `ForwardingCollection` today, we might have chosen not to forward any `default` methods, just to set a clear policy.  There's been no change to the signature of Optional.transform() since it was created. Your problem is unlikely to be Guava-specific. Try posting to Stack Overflow for help with it. Your first example code compiles for me with Guava 19, Guava 20 and Guava 21. If you can share a complete sample Maven project that demonstrates the problem with Guava 21 but not one of the other versions, then we could take a look.  Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit <https://cla.developers.google.com/> to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla --> CLAs look good, thanks!
<!-- ok -->  `mapWithIndex` is an _intermediate operation_ (which transforms a stream). You need a final _terminal operation_ to produce a result/side effect.
From the `java.util.stream.Stream` [javadocs](https://docs.oracle.com/javase/8/docs/api/?java/util/stream/Stream.html):
> computation on the source data is only performed when the terminal operation is initiated  You may be right that we should have done this, but it's not worth breaking binary compatibility for. The error you're catching is one that I think developers are exceedingly unlikely to make. (I suspect that the change wouldn't break binary compatibility, but I agree that it's not worth worrying about.) Sorry, I missed the part about keeping the method around as (int[]). That probably wouldn't break compatibility; I think it's even similar to something we did with ImmutableList long ago.  `Multimap.get(K)` is very clearly documented to return a view of the values for the given key.
If you're going to hand off the result of `multimap.get(key)` to another thread, you should defensively copy it into a new list (ideally, an `ImmutableList`).  Is there a difference between this issue and #2755? Are you certain?  These both seem to be issues asking for ways to measure the approximate number of elements in a bloom filter... Based on the discussion there, this does seem like a duplicate.  AFAICT it is not, according to the current list.
Specifically, I see...
`*.compute.amazonaws.com`
...but not...
`compute.amazonaws.com`
https://publicsuffix.org/list/public_suffix_list.dat The following tests all pass for me:
> [Our classes are not designed to protect against a malicious caller. You should not use them for communication between trusted and untrusted code.](https://github.com/google/guava#important-warnings)  LGTM, I'll try to get this merged internally. We ran into the trouble that LongAdder isn't present in Java 7.  We have a
fork of it in common.cache, we just ran into the issue that we'll need
another copy for the Java 7 branch in common.hash.
On Wed, Mar 29, 2017, 10:35 AM Val Markovic <notifications@github.com>
wrote:
> @lowasser <https://github.com/lowasser> Any updates? It's been 2 weeks
> since this PR reached a stable state...
>
> 
> You are receiving this because you were mentioned.
>
>
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/pull/2761#issuecomment-290164862>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAhPOcWV0AmvdiN3I1S-OxRmrbBXk_Uzks5rqpZugaJpZM4Mb59H>
> .
>
It's in the review process internally; we've been working on the comments significantly. https://github.com/google/guava/pull/2806  @bmekewar Questions like these are better suited for StackOverflow.com - please submit your question there.
Thanks!  Sorry about that. Please see
https://github.com/google/guava/wiki/Release21#java-8 and stay tuned for
22.0.
On Thu, Mar 9, 2017 at 12:09 PM, Piotr Ekert <notifications@github.com>
wrote:
> Hi,
>
> after adding `compile 'com.google.guava:guava:21.0' to my Android project
> Gradle's dependencies, I got this build error:
>
> Information:Gradle tasks [:app:assembleBrandAFastBuildDebug]
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Consumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Supplier
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Supplier
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BinaryOperator
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BinaryOperator
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BinaryOperator
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Consumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Consumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Supplier
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Consumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BinaryOperator
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BinaryOperator
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Supplier
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Consumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Consumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.ToIntFunction
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Supplier
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BinaryOperator
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BinaryOperator
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BinaryOperator
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Consumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.IntFunction
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.IntFunction
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Supplier
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BinaryOperator
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Supplier
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BinaryOperator
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.IntFunction
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.IntFunction
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiFunction
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiFunction
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiFunction
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Supplier
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BinaryOperator
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Supplier
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BinaryOperator
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Supplier
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Supplier
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BinaryOperator
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BinaryOperator
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Supplier
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Supplier
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BinaryOperator
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BinaryOperator
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Supplier
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Supplier
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BinaryOperator
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BinaryOperator
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Supplier
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Consumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Consumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Predicate
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Predicate
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Predicate
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiPredicate
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.ToIntFunction
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Supplier
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BinaryOperator
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiFunction
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Supplier
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BinaryOperator
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Consumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Predicate
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Predicate
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Consumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Predicate
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Supplier
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Supplier
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BinaryOperator
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Consumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Consumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.IntFunction
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Consumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Consumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Supplier
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BinaryOperator
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Supplier
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Consumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.IntFunction
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Predicate
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.
> LongBinaryOperator
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.
> LongBinaryOperator
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiFunction
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiFunction
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Predicate
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.ToLongFunction
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiFunction
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Consumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Consumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Consumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Consumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Consumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.BiPredicate
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Consumer
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath
> to be compiled, unknown interfaces are java.util.function.IntFunction
> Error:Default method void addAll(java.lang.Iterable ranges) not supported
> in Android API level less than 24
> Error:Default method boolean enclosesAll(java.lang.Iterable other) not
> supported in Android API level less than 24
> Error:Default method void removeAll(java.lang.Iterable ranges) not
> supported in Android API level less than 24
> Error:Default method boolean test(java.lang.Object input) not supported in
> Android API level less than 24
> Error:Default method void forEachEntry(java.util.function.ObjIntConsumer
> action) not supported in Android API level less than 24
> Error:Default method void forEach(java.util.function.Consumer action) not
> supported in Android API level less than 24
> Error:Default method java.util.Spliterator spliterator() not supported in
> Android API level less than 24
> Error:Static method void com_google_common_collect_
> Multiset_lambda$forEach$1(java.util.function.Consumer action,
> com.google.common.collect.Multiset$Entry entry) not supported in Android
> API level less than 24
> Error:Static method void com_google_common_collect_
> Multiset_lambda$forEachEntry$0(java.util.function.ObjIntConsumer action,
> com.google.common.collect.Multiset$Entry entry) not supported in Android
> API level less than 24
> Error:Default method void forEach(java.util.function.BiConsumer action)
> not supported in Android API level less than 24
> Error:Static method void com_google_common_collect_
> Multimap_lambda$forEach$0(java.util.function.BiConsumer action,
> java.util.Map$Entry entry) not supported in Android API level less than 24
> Error:Execution failed for task ':app:transformClassesWithPreJackPac
>
> com.android.build.api.transform.TransformException:
> com.android.builder.core.JackToolchain$ToolchainException: Jack
> compilation exception
> Information:BUILD FAILED
> Information:Total time: 1 mins 15.703 secs
> Information:190 errors
> Information:0 warnings
> Information:See complete output in console
>
> I'm already using:
>
> android {
>     compileSdkVersion 25
>     buildToolsVersion "25.0.2"
> ...
>  jackOptions {
>             enabled true
>         }
>
> compileOptions {
>         sourceCompatibility JavaVersion.VERSION_1_8
>         targetCompatibility JavaVersion.VERSION_1_8
>     }
>
>     buildTypes {
>         release {
>             minifyEnabled false
>             proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
>         }
>     }
>
> Gradle's project configuration snippet:
> classpath 'com.android.tools.build:gradle:2.5.0-alpha-preview-01'
>
> In gradle-wrapper.properties I have:
> distributionUrl=https://services.gradle.org/distributions-snapshots/
> gradle-3.5-20170213202653+0000-all.zip
>
> Cold you provide any resolution to this problem?
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2759>, or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AA5Cl1m0kx_kZ9ikU2UtKLNwkKuKJg_aks5rkFyBgaJpZM4MYkbK>
> .
>
--
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
Although I see that you're trying to tell it to use API level 25. There may
that -- notice its complaints are about things that are available in 24.
*Maybe* there's a way to make this work, but be aware that we don't promise
compatibility of Guava 21 with any version of Android and haven't tested it
that way. That will happen quite a while from now, as the vast majority of
developers aren't making apps that run only on Nougat.
On Thu, Mar 9, 2017 at 1:31 PM, Kevin Bourrillion <kevinb@google.com> wrote:
> Sorry about that. Please see https://github.com/google/
> guava/wiki/Release21#java-8 and stay tuned for 22.0.
>
> On Thu, Mar 9, 2017 at 12:09 PM, Piotr Ekert <notifications@github.com>
> wrote:
>
>> Hi,
>>
>> after adding `compile 'com.google.guava:guava:21.0' to my Android project
>> Gradle's dependencies, I got this build error:
>>
>> Information:Gradle tasks [:app:assembleBrandAFastBuildDebug]
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Consumer
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Supplier
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Supplier
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.BinaryOperator
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.BinaryOperator
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.BinaryOperator
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Consumer
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Consumer
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Supplier
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Consumer
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.BinaryOperator
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.BinaryOperator
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Supplier
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Consumer
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Consumer
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.ToIntFunction
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Supplier
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.BinaryOperator
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.BinaryOperator
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.BinaryOperator
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Consumer
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.IntFunction
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.IntFunction
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Supplier
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.BinaryOperator
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Supplier
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.BinaryOperator
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.IntFunction
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.IntFunction
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.BiFunction
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.BiFunction
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.BiFunction
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Supplier
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.BinaryOperator
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Supplier
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.BinaryOperator
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Supplier
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Supplier
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.BinaryOperator
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.BinaryOperator
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Supplier
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Supplier
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.BinaryOperator
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.BinaryOperator
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Supplier
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Supplier
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.BinaryOperator
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.BinaryOperator
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Supplier
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Consumer
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Consumer
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Predicate
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Predicate
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Predicate
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.BiPredicate
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.ToIntFunction
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Supplier
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.BinaryOperator
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.BiFunction
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Supplier
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.BinaryOperator
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Consumer
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Predicate
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Predicate
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Consumer
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Predicate
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Supplier
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Supplier
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.BinaryOperator
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Consumer
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Consumer
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.IntFunction
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Consumer
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Consumer
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Supplier
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.BinaryOperator
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Supplier
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Consumer
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.IntFunction
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Predicate
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.LongBinaryO
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.LongBinaryO
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.BiFunction
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.BiFunction
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.LongUnaryOp
>> erator
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.LongUnaryOp
>> erator
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.LongUnaryOp
>> erator
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Predicate
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.ToLongFunction
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.BiFunction
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Consumer
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Consumer
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Consumer
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Consumer
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Consumer
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.BiPredicate
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Consumer
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.Function
>> Error:Lambda coming from jar file need their interfaces on the classpath
>> to be compiled, unknown interfaces are java.util.function.IntFunction
>> Error:Default method void addAll(java.lang.Iterable ranges) not supported
>> in Android API level less than 24
>> Error:Default method boolean enclosesAll(java.lang.Iterable other) not
>> supported in Android API level less than 24
>> Error:Default method void removeAll(java.lang.Iterable ranges) not
>> supported in Android API level less than 24
>> Error:Default method boolean test(java.lang.Object input) not supported
>> in Android API level less than 24
>> Error:Default method void forEachEntry(java.util.function.ObjIntConsumer
>> action) not supported in Android API level less than 24
>> Error:Default method void forEach(java.util.function.Consumer action)
>> not supported in Android API level less than 24
>> Error:Default method java.util.Spliterator spliterator() not supported in
>> Android API level less than 24
>> Error:Static method void com_google_common_collect_Mult
>> iset_lambda$forEach$1(java.util.function.Consumer action,
>> com.google.common.collect.Multiset$Entry entry) not supported in Android
>> API level less than 24
>> Error:Static method void com_google_common_collect_Mult
>> iset_lambda$forEachEntry$0(java.util.function.ObjIntConsumer action,
>> com.google.common.collect.Multiset$Entry entry) not supported in Android
>> API level less than 24
>> Error:Default method void forEach(java.util.function.BiConsumer action)
>> not supported in Android API level less than 24
>> Error:Static method void com_google_common_collect_Mult
>> imap_lambda$forEach$0(java.util.function.BiConsumer action,
>> java.util.Map$Entry entry) not supported in Android API level less than 24
>> Error:Execution failed for task ':app:transformClassesWithPreJ
>> ackPackagedLibrariesForBrandAFastBuildDebug'.
>>
>> com.android.build.api.transform.TransformException:
>> com.android.builder.core.JackToolchain$ToolchainException: Jack
>> compilation exception
>> Information:BUILD FAILED
>> Information:Total time: 1 mins 15.703 secs
>> Information:190 errors
>> Information:0 warnings
>> Information:See complete output in console
>>
>> I'm already using:
>>
>> android {
>>     compileSdkVersion 25
>>     buildToolsVersion "25.0.2"
>> ...
>>  jackOptions {
>>             enabled true
>>         }
>>
>> compileOptions {
>>         sourceCompatibility JavaVersion.VERSION_1_8
>>         targetCompatibility JavaVersion.VERSION_1_8
>>     }
>>
>>         release {
>>             minifyEnabled false
>>             proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
>>         }
>>     }
>>
>> Gradle's project configuration snippet:
>> classpath 'com.android.tools.build:gradle:2.5.0-alpha-preview-01'
>>
>> In gradle-wrapper.properties I have:
>> distributionUrl=https://services.gradle.org/distributions-
>> snapshots/gradle-3.5-20170213202653+0000-all.zip
>>
>> Cold you provide any resolution to this problem?
>>
>> 
>> You are receiving this because you are subscribed to this thread.
>> Reply to this email directly, view it on GitHub
>> <https://github.com/google/guava/issues/2759>, or mute the thread
>> <https://github.com/notifications/unsubscribe-auth/AA5Cl1m0kx_kZ9ikU2UtKLNwkKuKJg_aks5rkFyBgaJpZM4MYkbK>
>> .
>>
>
>
>
> --
> Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
>
--
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
That's all we've got for you, sorry :( If it's any consolation, Guava 21 adds almost nothing except the Java 8 features. We should have Guava 22 (with Android-compatible version) our in the coming quarter.  Thanks, this is indeed one of the categories of transition tasks that we
have kept back-burnering.
Your change should be among the simplest of these, but even it has a few
- It's not *binary* compatible.
- Normally we'd skirt that by just keeping both overloads, but that
would be a disaster here, as target typing would fail for your lambda
expressions.
- Is it possible that breaking binary compatibility isn't a real
problem anymore in the modern world? I admit I'm out of touch
with that and
would love some edification.
- It's not *completely* source-compatible. For example, you can pass
`Suppliers::memoize` to a method that accepts
`Function<cgcb.Supplier<Long>, cgcb.Supplier<Long>>`, but that would break
- Though this is *probably* the kind of source incompatibility that
we have been okay with in the past and will need to continue to be...
- We have been trying to limit differences between the main and Android
present in one and absent in the other. APIs that exist in both but with
Thoughts?
On Wed, Mar 8, 2017 at 2:24 PM, Mark Elliot <notifications@github.com>
wrote:
> Now that Guava Supplier extends Java Supplier the Suppliers utility
> methods (e.g. Suppliers#memoize(Supplier) should accept a Java Supplier
> instead of a Guava one. From Guava 21 onwards, this shouldn't be a breaking
>
> I'd be willing to submit a PR for this change if this seems acceptable.
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2758>, or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AA5ClxfEQijwtFucBEaMycABrqI4v278ks5rjyqsgaJpZM4MXY7g>
> .
>
--
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
> Normally we'd skirt that by just keeping both overloads, but that
>      would be a disaster here, as target typing would fail for your lambda
>      expressions.
I'm pretty sure that target typing still "works": Java is smart enough to pick the more specific type. But "the more specific type" is _our_ `Function`, `Supplier`, etc., so we're accumulating more binary references that will break if/when we finally do remove those types :(
(Of course, your larger point and your various particular points still hold: There is plenty to cause problems.)
A `JavaSuppliers` class is one possibility. Things get a little trickier with classes like `Maps` and `Futures`. Do we have `Maps.transformValuesWithJavaFunction` or `FuturesUsingJavaFunctions.transform`? Perhaps some of the lower-value utilities will just go away, or we'll provide equivalents that use `Stream` instead... but we have a lot to work out here. @ogregoire Thanks for the patient explanation. To be clear, we have always worked hard to avoid any binary incompatibility, so I hate that that silly comment of mine is up there now looking to all the world like evidence that Guava developers don't get it. :-) We get it. Some of us just get momentarily confused and think "wait a minute, maybe it's really source incompatibility that causes all the bad problems". Derp.
(I'll freely admit that we're terribly spoiled by our internal everything-is-up-to-date-at-all-times environment.)  This sounds likely to be some problem with your build system setup. Can you provide some more details in a Stack Overflow question?  Where are you seeing this within Guava? Does that parent pom give us anything? Could we just remove it?  This is interesting...can you elaborate a bit on the use case for knowing the approximate size of the bloom filter? Just for monitoring purposes or something? The approximation seems to be fairly reasonable so as long as you don't exceed `expectedInsertions`. I suppose we could warn about this in the javadocs though. @tcbeutler I'll float this idea internally, but in the meantime, can you please sign the Guava CLA? https://github.com/google/guava/wiki/HowToContribute#new-features Thanks :-) Cool, verified. Thanks! Yep, still on my TODO list...sorry for the wait! Would most users be as well served by a counter that they increment each time put() returns true?  (It doesn't address the combining case, but other than that?) I think @kevinb9n was advocating for keeping a **separate** counter, external to the `BloomFilter` API. Note that the formula seems to use an approximation: it divides by `-k/m` instead of dividing by `ln(1 - k/m)` (which is what would fall out of solving `X = m - m * (1 - k/m)^n` for `n`). This is a fair approximation only because `k/m` should be very small.
My assumption is that `k/m` is SO small that this really doesn't matter [edit: plus, if it's not very small, your BF has bigger problems than this!], though I'm not 100% sure we shouldn't just do the full formula anyway.
If you were interested in applying your same testing methodology to the full formula to see what happens, that might be useful information.
I should also add that we don't currently have good data at hand on what parameters people's Bloom Filters tend to have in the wild, so we don't know if we're evaluating the right scenarios. Although the commit marked this closed, your feedback on it is still welcome, tcbeutler. We made substantial changes.  @cgrushko Sure, send me a CL.  Or (as discussed elsewhere) we'll get around to it eventually.  Do you have a way of reproducing this that you can share? Our GWT tests pass with Guava 21 and GWT 2.8, but I can imagine that some slightly different version of Maven or slightly different usages in the calling code could produce a bug that they miss. Tentatively closing, but if you can find a way for us to reproduce this, please do reopen.  I'm not sure what you're defining as "the start time"?  `Stopwatch`'s whole point is that it only lets you get the difference between times.  (And on the backend it's getting `System.nanoTime()` which has no independent meaning anyway...?) I'm not sure what the distinction is between what you're looking for and [`Stopwatch.elapsed(TimeUnit)`](https://google.github.io/guava/releases/21.0/api/docs/com/google/common/base/Stopwatch.html#elapsed-java.util.concurrent.TimeUnit-). Just use two Stopwatches, resetting one each time you read it?
On Fri, Mar 3, 2017 at 5:35 AM, Alberto Scotto <notifications@github.com>
wrote:
> Sorry, my bad. I now understand that elapsed(Timeunit) returns the
> elapsed time since the stopwatch was started.
> So what I'm missing is a method (let's call it "partialElapsed") to get
> the elapsed time between now and the previous call to elapsed, so that I
> can write:
>
> sw.start();
> do1();
> log.debug("do1 took " + sw.partialElapsed(MILLIS) + "ms);
> ..
> doN();
> log.debug("doN took " + sw.elapsedSincePrevious(MILLIS) + "ms);
> log.debug("The whole process took " + sw.elapsed(MILLIS) + "ms);
>
> For example, the stopwatch included in the Google app Clock on Android 6
> supports this.
>
> PS: @jbduncan <https://github.com/jbduncan> Thanks for the link, funny
> and useful video :)
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2752#issuecomment-283954031>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AA5Clx5b97rUV6ZrtXiP4EmIyHVXBiAFks5riBc5gaJpZM4MRgYJ>
> .
>
--
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
He also wants the total time.
On Fri, Mar 3, 2017 at 9:03 AM, Ryley Kimmel <notifications@github.com>
wrote:
> @kevinb9n <https://github.com/kevinb9n> that's not even necessary, you
> can achieve this result fairly easily using the existing Stopwatch API.
>
> Stopwatch stopwatch = Stopwatch.createStarted();
>
> benchmark();
> System.out.printf("benchmark() took %d ms.%n", stopwatch.elapsed(TimeUnit.MILLISECONDS));
> stopwatch.reset().start();
>
> benchmark();
> System.out.printf("benchmark() took %d ms.%n", stopwatch.elapsed(TimeUnit.MILLISECONDS));
> stopwatch.reset().start();
> ...
>
> 
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2752#issuecomment-284010571>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AA5Cl-Dkigbd8CpHdNpzShShe6teNhNaks5riEf_gaJpZM4MRgYJ>
> .
>
--
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
private interface Foo<T extends Number> {}
public void testUnboundedAndBounded() {
TypeToken<Foo<?>> a = new TypeToken<Foo<?>>() {};
TypeToken<Foo<? extends Number>> b = new TypeToken<Foo<? extends Number>>() {};
assertTrue(a.isSubtypeOf(b)); // fails
assertTrue(b.isSubtypeOf(a));
}
I think that we want that to pass. In our `isSubtypeOf()` docs, we claim to implement [a section of the JLS](http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1). That section mentions "capture conversion," which sounds like maybe something that `isSubtypeOf()` should be doing but isn't (or isn't doing completely)? But I'm in over my head.
Yes, thanks. See the commit referenced above (from 12 days ago -- I guess we needed to write "Fixes" rather than "Fix" to get it to happen automatically).  Thank you! Louis fixed this last week.
On Fri, Feb 24, 2017 at 3:50 AM, Xfel <notifications@github.com> wrote:
> While AbstractTable defines a method valuesSpliterator(), that method does
> not get called. Instead, the default implementation from AbstractCollection
> is used.
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2749>, or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AA5ClyTgXYwUdYVxrv73lwmJTQUKghv6ks5rfsQFgaJpZM4MLH4b>
> .
>
--
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
I took a crack at this once but never really focused on it.  If you've got something tested successfully in production, I'd love to see it.  (Though -- are there problems with keeping `bitcount` and `data` in sync correctly?)  This frankly sounds like a question for Spring, not Guava.  I have no idea how Spring builds its caches.
That said, nothing here should be surprising.  If you only put strings into the cache, then your `RemovalListener` only needs to handle strings.  If this passes even basic tests, it's not going to fail later by surprise. The advice is just there to help the generics all match without any casts; it's just for convenience.  If your basic tests work, the whole thing will work. Yes, that's fine.  That's what Java does under the hood anyway due to type erasure.  I suspect some of this is doc mismatches between Google-internal and Guava.  (We are much more aggressive about deletion inside Google, largely because we can perform the migrations ourselves.)
As Ordering is non-@Beta, it would not be deleted earlier than two years after the first release in which it was marked deprecated. On Thu, Feb 16, 2017 at 9:05 PM, Louis Wasserman <notifications@github.com>
wrote:
> I suspect some of this is doc mismatches between Google-internal and
> because we can perform the migrations ourselves.)
>
Yes, this is probably what happened... we have no intention of deprecating
Ordering any time soon.
> As Ordering is non-@Beta <https://github.com/Beta>, it would not be
> deleted earlier than two years after the first release in which it was
> marked deprecated.
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2744#issuecomment-280553626>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AA5Cl2NZH10NXhfDXY3irUHtwFVsNw9Pks5rdSp8gaJpZM4MD4Fc>
> .
>
--
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
Sorry about that - I assumed this had been resolved  Thanks, fixed! Unfortunately it looks like the sidebar is not generated programmatically, so this was a manual fix. Good eye though!  Thanks, I'll zap this and try to look for others.
On Tue, Feb 14, 2017 at 11:11 AM, mjustin <notifications@github.com> wrote:
> The doc comments
> <https://google.github.io/guava/releases/21.0/api/docs/com/google/common/base/Equivalence.html>
> for Equivalence state that "A future version of this class will implement
> BiPredicate<T, T>. In the meantime, to use an equivalence (say, named
> equivalence) as a bi-predicate, use the method reference
> equivalence::equivalent." However, as of Guava 21.0, Equivalence does
> implement that method. This section should therefore go away.
>
> I'm not sure whether this was a one-off miss when converting to Java 8, or
> if there are other similar misses in updating the doc comments.
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2740>, or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AA5Cl9-Slo037FOL6F0QCk8Eyd7sH6DZks5rcfxJgaJpZM4MA31A>
> .
>
--
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
If you're iterating over the nodes adjacent to a particular node, and you're removing edges while you're doing that, then you may be modifying adjacency relationships, and so throwing a CME sounds like exactly what I would expect to happen.  (Even if I hadn't been leading this project.  :) )
(Note that we have to do exactly this when a node is removed from the graph, because all incident edges must also be removed--so we have to be careful to do this in such a way as to not trigger a CME.)
So yes, either of @jbduncan's solutions would work, although the effects are not identical in general (they might be in this case, I haven't worked it through in detail).
If you create a copy [1] of the adjacent nodes (Solution (1)), it may make a difference in what order you visit the adjacent nodes, because the modifications you might do can be affected by previous modifications.
If you record the elements to remove and then remove them all at once in a second pass, then the modifications will (in effect) all happen in parallel and can't affect one another.
[1] it need not be an immutable copy, it just needs to not be a view into the graph)  @jbduncan no worries, I'm always open to the idea that I might have made a mistake.  :)
Glad to hear that the wiki has been helpful.
That said, if you think that there's some way in which this issue needs to be better highlighted there (or elsewhere, e.g., in the Javadoc), please file a bug.  Accurate and helpful documentation is important to us.  If you really want that behavior you can also always get it with
Sets.filter(set, not(in(Collection))).
On Mon, Feb 13, 2017, 9:03 AM Micha Sobkiewicz <notifications@github.com>
wrote:
> (...) for all usages of set2 argument everything would work as well if
> argument was of type Collection<?>, without impact on performance for
> current usages.
>
> Collection.contains(), which Sets.difference() uses a lot, is *O(1)* for
> hash based sets and *O(log(n))* for tree based sets. You can't guarantee
> anything below *O(n)* in general (List, Queue and so on). Iterating over
> Sets.difference() would be *O(n^2)* in that case - that's not something
> you want - it's about *O(n)* now.
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2738#issuecomment-279454201>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAhPObEnpQzq_tLYJbM7coIWoy1r034lks5rcIzbgaJpZM4L_Zdk>
> .
>
The other obvious thing that one could do:
`Sets.difference(rightFoos, ImmutableSet.copyOf(specialFoos.values())`
This would take up more space, but would be more efficient than filtering using collection.contains() (O(n) vs. O(n^2)).  I can see how this might be useful for some use cases, but I am utterly certain there are people depending on the cache never returning expired values, and we can't change this out from under them.
On the other hand, refresh behavior, unlike expiration, specifically does what you want; if you return a ListenableFuture from the reload method in CacheLoader, it will continue returning the old value until it asynchronously updates the cache with the refreshed value.  Does this satisfy your needs? You are correct that you will have to do some manual polling, and there is currently no way around that.  Refreshes occur on the first request to an entry after its `refreshAfterWrite` interval.  Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit <https://cla.developers.google.com/> to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla --> Hi!
As this is a new API, it's going to have to go through a process and some internal review before we even start thinking about the code.  (There's some explanation of this [here](https://github.com/google/guava/wiki/HowToContribute#code-contributions).)
As it stands, there's a few things we'd need to get together before we approved this feature:
- Some research on how common the need for this API is, ideally including several different places in real existing code that this API would have been helpful.  (This will probably end up needing to be done by a Googler, just because we have a large, easily-searchable codebase.)
- For each of those real uses, a discussion of whether or not this API is really the best way to help those users.  For this feature, I'd wonder why the maps were created separately in the first place?  Do people actually have an unbounded number of maps, or do they have a fixed number of maps that need to be combined?  For example, I'd tend to rewrite the example you gave to the stream-free `new ImmutableMap.Builder<>().putAll(foo).putAll(bar).build()`, which is very short and simple.  We've provided these for our sorted collections in the past, but I'm not sure we're convinced yet that we should add these overloads to the Collectors.  Some Java 8 APIs, such as `Stream.sorted`, require a `Comparator` and don't provide another overload -- and the statically imported `naturalOrder()` in your current code reads pretty well as-is.  We'll think about this, though.  Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit <https://cla.developers.google.com/> to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla --> googlebot might not know what to do with the corporate CLA. Addepar isn't showing up in the list I'm looking at, but I suspect it's not 100% up to date. I'll check again tomorrow. Hmm, still nothing :( Did you sign the corporate CLA or the individual? https://cla.developers.google.com/about says that it may be "a few days" before the signed CLA shows up in our list. I'll keep checking back. Still nothing :( I'll check back next week, and if I don't see the CLA, I'll email the people who handle that. I emailed our CLA people this morning. I'll let you know what I find out.
In the worst case, I can implement `@CheckForNull` support from scratch. After getting no response, I pinged the thread last week, and I still heard nothing. I just emailed a different group to see if that helps. Sorry that this has been an absurdly long wait. I'm told that, when a company submits the CLA, Google sends that person a Docusign agreement that the company then needs to sign. (I'm not sure why there are two steps here.) I don't know if it got lost or what, but apparently the Docusign doc for Addepar just expired this morning, so your CEO will have to resubmit to restart the process and get a new Docusign doc.
I presume that this is what the tiny footer [here](https://cla.developers.google.com/clas/new?domain=DOMAIN_GOOGLE&kind=KIND_CORPORATE) is trying to say: "(Submitting this form does not complete the Contributor License Agreement between your company and Google. The CLA must still be signed by the Authorized Signer.)"  
Addepar is in our list now. I'll run this through our internal tests. Tests pass. Running it past someone else internally. At last.  Can you discuss why you wouldn't just use a Stopwatch created with a mocked or faked Ticker? It's not clear what details of Stopwatch's implementation details you're avoiding?  Stopwatch's one and only job is to subtract the results of Ticker's output; there are no other implementation details.  /cc @fluentfuture @cpovirk  Sounds like something that we could take a pull request for. Otherwise, we might get there eventually, but it will probably never rise to the top of our list.  `ImmutableList`s must be `RandomAccess`, and `DiscreteDomain` does not provide a mechanism to do constant-time offsets from a given start point.  Given those constraints, I don't believe this to be possible. Yes, absolutely, knowing it's a list of exactly one type that you know how to offset lets you do this.  That isn't the case for all possible DiscreteDomains, though. I'm not certain, but DiscreteDomain doesn't currently have a method `E offset(E start, int number)`.  We could add one that just has a default implementation that does a for loop with `successor`, but this would cause existing `ContiguousSet.asList()` implementations to silently become quadratic to iterate over by index, which seems Very Bad. We ended up doing a thing where we provided a magic private API for Guava's *own* DiscreteDomains, (`integers()`, `longs()`, and `doubles()`) to use that supported the "nice" ImmutableList, but we didn't expose a way for external DDs to use it. Hopefully that will alleviate the worst of the problems. https://github.com/google/guava/commit/aaae2e9a6b9cab0429f4589f89603742f28f6bd0  The reason is that we don't make the Error Prone annotations available to our users at compile time. We could maybe change that, but our understanding has been that it shouldn't be necessary. Do you know if you're using any Maven plugins that might be plugging into the compiler (annotation processors, mainly)? Thanks. I tried pulling the `jdbi3` and running `mvn clean install`. It successes without the `CompatibleWith` message. Is there a different command I should use or a different commit I should check out? Running `mvn clean install` on `jdbi3` didn't give me any output that mentions "CompatibleWith" anywhere. I tried with `-Dmaven.compiler.forceJavacCompilerUse=true`, and I tried introducing a compile error into a file that uses `Multimap`, and I still don't see it.
If anyone can point me to a repository and a command that I can use to reproduce this, that would be a big help. There's definitely something wrong, but I need to figure out where to point the finger (which might be at us -- I'm not just not sure yet). In the meantime, as a workaround, you can probably add an explicit dependency on:
<groupId>com.google.errorprone</groupId>
<artifactId>error_prone_annotations</artifactId>
<version>2.0.15</version> @PhilippWendler , thanks, I'm now seeing the error. I'll poke around some more. And thanks @enwired. I can reproduce with that, too. As far as I can tell, this was our fault. Sorry about that. I've fixed it for 22.0. In the meantime, you can try [the workaround above](https://github.com/google/guava/issues/2721#issuecomment-275220035). Does the workaround work OK? Knowing that will help us prioritize.
@netdpb for an estimate on 22.0. My guess is that those warnings are unrelated -- that they'd be there even if Guava weren't using these annotations at all. I don't know enough about GWT to say what the cause would be, though :( Plain `javac` is trying to look at the annotation. I don't think it's "calling" its method per se. I'm not sure _why_ it's looking at it. Apparently the class name and value are both present in the compiled class:
#24 = Utf8               Lcom/google/errorprone/annotations/CompatibleWith;
#25 = Utf8               value
I guess the idea is that the file needs to encode which specific annotation fields are set (and we do set the `value` of `@CompatibleWith`) to which specific values in case the code runs against a newer version of the annotation that has more fields available.
JSR 305 does have annotations with values, like [`@GuardedBy`](https://static.javadoc.io/com.google.code.findbugs/jsr305/3.0.1/javax/annotation/concurrent/GuardedBy.html). I could imagine that they could cause the same problem, but I don't know whether it's happened in the wild. The error here apparently used to be fatal in all cases. The javac people changed it to be only a warning, and I guess they figured that was good enough. But of course that's still a problem for users of `-Werror`.
I found this bug: http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6550655 That links to http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6365854, which says:
> The rationale [for the warning] is that the missing annotation can cause problems when running the program.
And also:
As far as TreeMultiset is concerned, it does take duplicates, but it will also *collapse* them into a single element.  That's the point of its existence, basically; it just keeps track of how many duplicates there are, not keeping track of all the individual duplicates.  That is how all Multisets work.
It sounds like what you *actually* want is a comparator that compares both priority and some other fields, and then to store that in a TreeSet. To answer your other question, yes, your contract violating comparator is absolutely the reason clear() is not working.  Expressing this as sequential calls to the existing method seems fine to
me. This is often a precondition check, so the stack trace you get will
actually tell you which string was the problem case.
On Thu, Jan 19, 2017 at 3:16 PM, Cunha <notifications@github.com> wrote:
> Sometimes I want to check if more than one String is null or empty, but
> the method in the API only allows one String as argument.
>
> Tell me what you guys think about it:
>
> static boolean stringIsNullOrEmpty(@Nullable String... string) {
> 	for (int i = 0; i < string.length; i++) {
> 		if (string[i] == null || string[i].length() == 0) {
> 			return true;
> 		}
> 	}
> 	return false;
> }
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2719>, or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AA5ClykYleSc6HlV_zf2-akcBX_vx3fNks5rT-7VgaJpZM4Loupl>
> .
>
--
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit <https://cla.developers.google.com/> to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla --> CLAs look good, thanks!
<!-- ok -->  Thanks for bringing this to our attention, and please accept our apologies for this issue. We've gone through and obscured all email addresses for non-Google contributors in the same way they were obscured on Google Code.  Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit <https://cla.developers.google.com/> to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla --> I'm not sure I follow what you're going for with this.  Transient variables aren't serialized; these fields appear to need to be serialized...? We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA ([login here](https://cla.developers.google.com/) to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
<!-- need_author_cla --> That, too, seems working as intended to me.  The documented behavior is that the generated Converters are serializable if the original converter is serializable, which is accomplished with the status quo: if the underlying Converter is Serializable the serialization will work, otherwise you will get an exception when serialization is attempted.
Marking these fields transient will cause a NullPointerException if the object is serialized and deserialized, even if the original object was serializable.  (If our tests pass with your change, that probably reflects a problem with the tests?) Or, rather, to be specific: the converter, if serialized and deserialized while the fields are transient, will throw an NPE on an attempt to use them for conversions.  So far, when this has come up for our internal users, we've suggested
either .filter().map(), or just .filter() and deal with slapping an
unchecked cast somewhere to make it all work. And so far, this has
seemed... mostly acceptable. I intend to reevaluate after a few more months
Also, one vague concern I've always had with the existing filter(Class)
methods is that some fraction of their users probably don't even mean to
*filter*, but rather fully expect all the elements to already be of that
type. The fact that any unexpected objects are silently discarded then
saddens me, so one good thing about recommending .filter().map() is that in
this circumstance you can just drop the .filter(). But I haven't actually
dug into how common this circumstance is.
On Fri, Jan 13, 2017 at 10:48 AM, Philipp Wendler <notifications@github.com>
wrote:
> One of the things I miss most when switching from FluentIterable to
> streams is a filter method that takes a Class<T> argument and returns a
>
> Doing it manually like stream.filter(o -> o instanceof MyClass).map(o ->
> (MyClass)o) involves having to specify MyClass twice and is not safe
> against accidental modifications of only the latter operation. Furthermore
> I prefer to avoid manual casts where possible because someone reading the
> code would always need to ask themselves whether the cast is actually safe.
>
> I see two ways a utility method could be done:
>
>    - A method <T> Stream<T> filter(Stream<? extends T> stream, Class<T>
>    cls). Unfortunately this breaks the fluentness.
>    - A method <T> Function<? extends T, Stream<T>> filter(Class<T> cls)
>    which could be used with Stream.flatMap. Unfortunately, this adds
>    extra object allocations.
>
> I am not sure which of these would be better, partially because I am
> unsure what kind of guarantees and optimizations might be lost when using
> the flatMap approach (given that using flapMap makes it impossible to use
> any information about the size of the input stream, whereas with a
> combination of map and filter it is still knowable that the resulting
> size is at most the size of the input stream). This is one of the reason
> implementing it myself.
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2710>, or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AA5ClzP1qfmFYt6oXFqaGbxV2YPR3AgHks5rR8b1gaJpZM4LjL1v>
> .
>
--
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
Yeah, though Philipp mentioned that this approach causes a lot of garbage
can't see `.filter().map()` as bad enough to justify that.
But, if anyone reading wants to add this to their own codebase for their
own use, note that there's no need an `<S>` parameter; just use a return
type of `Function<Object, Stream<T>>` and you're set.
On Fri, Feb 10, 2017 at 11:48 PM, Simon Legner <notifications@github.com>
wrote:
> An other approach is to define the function
>
> public static <S, T extends S> Function<S, Stream<T>> subclasses(Class<T> clazz) {clazz) {
>     return x -> clazz.isInstance(x) ? Stream.of(clazz.cast(x)) : Stream.empty();
> }
>
> and then use stream.flatMap(subclasses(MyClass.class).
>
> 
> You are receiving this because you commented.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2710#issuecomment-279128259>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AA5Cl0B6_APpB7ki5eL7Xk-WC5AKbNxyks5rbWfSgaJpZM4LjL1v>
> .
>
--
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
It's probably not worth worrying about, but if we want to optimize it, we might be best off converting it to `if`-`else if`-`else if`-....  It's not actually clear to me that we can expose that API at all without the greater context of the list, because I think you need the `size()` to compute the index information for the reverse iterators.  (Confirmed by looking at the implementation.)
Do you really not have any control over this problematic API that's not giving you the List? I'm not sure I buy that, though.  A ListIterator, unlike a normal Iterator, has index information, and that really seems to make it invariably attached to a List.  The AbstractSequentialList implementation skeleton lets you implement a List with nothing more than the ListIterator and the size(), which is also the minimum you need to reverse a ListIterator anyway.  Ahh, you're right, thanks for reporting this! This was my fault. They're
it's too late to at least fix this doc for 21.
On Thu, Jan 5, 2017 at 12:51 AM, Petr Janeek <notifications@github.com>
wrote:
> In the new docs for Ordering#greatestOf()
> <http://google.github.io/guava/releases/21.0-rc2/api/docs/com/google/common/collect/Ordering.html#greatestOf-java.lang.Iterable-int->,
> there's a hint for Java 8 users:
>
> Use Streams.stream(iterable).collect(Comparators.greatest(k,
> thisComparator)) instead.
>
> <http://google.github.io/guava/releases/21.0-rc2/api/docs/com/google/common/collect/Comparators.html>
> doesn't have Comparators.greatest(), does it? Am I missing an obvious
> method on Stream that would do the right thing?
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2705>, or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AA5Cl0uBEpvR9Z6gtmNzxNAsKJNOx_qUks5rPK8SgaJpZM4Lbd1x>
> .
>
--
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
I think you may just need to look again. :-) There is a path that does a
full sort, but only when the conditions warrant it. The main path is
https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Ordering.java#L786
On Thu, Jan 5, 2017 at 9:18 AM, Petr Janeek <notifications@github.com>
wrote:
> Ah, good, thank you!
> During the day I took a look at the Ordering implementation and it does a
> full sort on the data, anyway :(. For that
>
> ImmutableList.of("a", "b", "c", "d", "e", "f")
> .stream()
> .sorted(Comparator.comparing(str -> str.toString()))
> .limit(5)
> .collect(Collectors.toList());
>
> might be good enough. I hoped to see a O(n) solution.
>
> 
> You are receiving this because you commented.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2705#issuecomment-270701455>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AA5Clxcqv05wL9zafg7ZtvYpSUJq7_IZks5rPSXWgaJpZM4Lbd1x>
> .
>
--
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
Heh, sorry... I had it on a list to do before the next release, but let me
just get that code shipped now.
On Thu, Mar 2, 2017 at 10:53 AM, Petr Janeek <notifications@github.com>
wrote:
> sweet code with Ordering#greatestOf()...
>
> 
> You are receiving this because you were assigned.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2705#issuecomment-283744188>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AA5Cl89Wy25Mctgr4QHh_gYSgUS52aICks5rhxAogaJpZM4Lbd1x>
> .
>
--
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
Looks like we have `Comparators.greatest` [in](http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/Comparators.html#greatest-int-java.util.Comparator-).  You can always just modify your removal listener to check that the
RemovalCause is EXPIRED.  Other than that, no, I don't believe there is a
mechanism to not notify the RemovalListener.
On Tue, Jan 3, 2017, 4:07 AM JakeAngell <notifications@github.com> wrote:
> Is there a way to invalidate an entry without causing removal listeners to
> be triggered?
>
> I want the removal listener to execute when an entry expires after a
> certain amount of time, not when it is invalidated manually.
>
> Thanks.
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2701>, or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AAhPOYV5E_ImG8stnFux6l0BXuBcHSGzks5rOjoUgaJpZM4LZj-3>
> .
>
This is the main issue I perceive as outstanding originally raised from https://github.com/google/guava/issues/2694. Here are mine, FWIW:
I see the appropriate API here as
ImmutableMultiset.toImmutableMultiset(Function<T, E>, ToIntFunction<T>)
ImmutableSortedMultiset.toImmutableSortedMultiset(
Comparator<E>, Function<T, E>, ToIntFunction<T>)
Multisets.toMultiset(Function<T, E>, ToIntFunction<T>, Supplier<Multiset>)
This seems like the appropriate subset: I don't think we should have Collectors for each mutable Multiset implementation when the Supplier approach works sufficiently, and it seems perfectly acceptable to depend on Collectors.toCollection for the `e -> 1` case.  The above seems to me like the right amount of API surface area.  This will need to go through the internal API review process, though. We have a standing team disagreement about the importance of `? extends E`, but I think we all agree on the need for `? super T` :) I'm sending a CL. This is a little weirder than the vanilla PECS case: It's not about permitting things that wouldn't have been permitted before, just about letting you force a different return type. (Actually, it's possible that the `Collector` case is still weirder than that; I haven't thought about it in detail.) We've spent a surprising amount of time on this discussion without reaching a conclusion, so I think we're just going to leave things as they are (even if it's inconsistent), rather than try again to reach consensus. We apply PECS consistently, but it only discusses types that are produced and consumed, and says nothing about "pass-through types", which you can look at as being neither produced nor consumed. We don't add additional wildcards and type parameters that only serve to massage the return type. The other approach was to decide that such types are *both* produced and consumed, and that would have been okay too, but is not the way we decided, and we would have to add a LOT more wildcards to Guava to do it the other way.
Sometimes we mess up. If there's code that should compile and doesn't, and isn't fixed by just adjusting what return type the code "prefers", then we need to add something. We've also messed up in the opposite direction: no one should ever have had to write `Predicates.<String>alwaysTrue()` because `alwaysTrue` should always have returned `Predicate<Object>` (because that's literally what it is: a predicate that can handle any object). Sorry, I meant to cancel the previous comment, because I remembered that we may have opted for our Collectors to be a special case that match upstream Collectors instead of other Guava APIs. I leave it up to @lowasser what should be done.  This is, I am afraid, an inevitable consequence of the contract of the method.  Sets.intersection is defined to return a view, which _must_ delegate to the methods of the input collections, so you are forcing one collection's methods to delegate to another to another to another...and forcing a stack overflow exception yourself.  This cannot be avoided in methods that return views.
Sets.intersection is _really_ not intended to be used in any sort of loop or nested fashion, in general, though.  We could make this clearer in the docs -- I actually thought we already had explicitly mentioned that this sort of thing would have bad results.  There are a lot of things in here, but some high-level points:
- Many of the mutable Multiset collectors you mention can be done with the JDK built-in `Collectors.toCollection(Supplier)`, which is a major reason we omitted them.  For example, `collect(toCollection(HashMultiset::create))`.
- We consciously do not expose an `ImmutableEnumSet` type; that is a package-private implementation detail.  `Sets.toImmutableEnumSet()` is a collector to an enum-based _implementation_ of `ImmutableSet` that only works for enum types.  For other types you should be using `ImmutableSet.toImmutableSet()`, and having the distinct name `toImmutableEnumSet` is meant to help avoid confusion on that point.
- As far as the `c.g.c.b` versus `j.u.f` function issues go, we expect ~all users of these functions to be passing in lambdas and method references for which there is no meaningful difference.
- As regards your footnote, I would _absolutely_ expect the `Function` type to be necessary for many uses.  For example, if you already have a `Stream<Multiset.Entry<E>>`, you would want a collector of the form `toImmutableMultiset(Entry::getElement, Entry::getCount)`, and you could not get the result you want with `Stream.map`.  I think, like the JDK does, we'd be inclined to require both functions and just expect you to pass the identity when appropriate. It does look like we used `c.g.c.b.Function` in `Mutlimaps, but `j.u.f.Function` in `Tables.java`.
@lowasser can you try to resolve these differences? Marking the `java.util`-`com.google.common.base` issue as blocking 21.0-final (@cgdecker). It does seem worth standardizing on `java.util` to me (though users can make the methods work as-is by passing `myFunction::apply`, etc.). But maybe lowasser wants to make the case to leave them as they are?
(Other things here might be worth attention, too. I'm trying to focus on things that would be difficult to change later.) I'm also seeing `Maps.toImmutableEnumMap` with a `com.google.common.base.Function`. Good catch, I missed that one. I may have been overeager in closing this bug entirely, since it covered several topics -- sorry. If there's anything else you'd still like to discuss, can you open additional bugs? This just got discussed on the mailing list:
> We know we want to make changes to those methods, but it's complicated enough we haven't worked out a full plan yet.  Some utilities around Guava's functional interfaces are rendered completely redundant by Java 8 (see e.g. Predicates.instanceOf(Class) versus Class::isInstance), some like Suppliers.memoize seem still useful -- we want to make sure we have a comprehensive plan for what to do with these methods before we start changing everything, and we're not there yet.
>
> You'll definitely start seeing work on these issues in future Guava releases, but for now I think we're leaving those methods be -- though we recommend passing in lambdas to these methods in general, in which case the compiler will just Do The Right Thing.  As @dimo414 mentioned, this is a dupe of #1087  Thanks.  This is tough because GWT doesn't recognize, for a `Range<Foo>`, that it needs to know how to serialize a `Foo`. The fix is to introduce a dummy field into `Range` of type `C`. Possibly we could get away with doing this only in the GWT version -- maybe introducing a superclass of `Range` for just that purpose. I am hesitant to invest a lot of time in the deprecated GWT-RPC at this point, but I can probably make an exception. I'll see what I can do, though possibly not until the new year. (I think I have it working.)  Interesting.  I'd have to think about what the API for such a thing would look like, but I'm certainly familiar with the use case (this is a pretty common case for reading a graph in from some common graph formats).
So to expand slightly, what you're asking for a method like this (as well as similar ones for other types):
MutableGraph<T> transformNodes(Graph<N> graph, Function<N, T> nodeTransformer) {
MutableGraph<T> transformedGraph = GraphBuilder.from(graph).build();
for (N node : graph.nodes()) {
transformedGraph.addNode(nodeTransformer.apply(node));
}
for (EndpointPair<N> endpoints : graph.edges()) {
transformedGraph.addEdge(
nodeTransformer.apply(endpoint.nodeU()), nodeTransformer.apply(endpoints.nodeV()));
}
return transformedGraph;
}
``` I observe that doing this as a copy would be inconsistent with the other transform methods, but doing this as a view seems impractical: you'd need bidirectional conversion, I'd expect; a Function wouldn't be enough. =/ @lowasser You could do it as a view fairly straightforwardly using Collections2.transform() on the returned Sets; this would require more boilerplate (because you'd have to override each affected method) but would otherwise look (in terms of implementation) internally much like Graph.transpose().
The point of my code above was to make sure that I correctly understood the specification, not necessarily as a concrete proposal.  :)  @lowasser Why would you expect that you might want bidirectional conversion? I'm not sure I follow?  Collections2.transform returns a Collection, not a Set, isn't that a dealbreaker?  We don't *have* a Sets.transform because you can't do contains efficiently. @lowasser Ah, I see what you mean, that's why you would need a bidirectional conversion in order to make a view work.  `Collections2.transform()` would work but would be inefficient for contains() checks.
Which explains, also, why Maps.transform*() doesn't include anything that transforms the keys, just the values.
In any case, in the specific use case mentioned here, the original graph (built using the IDs and not anything else) is just going to be thrown away, so I don't know that building a copy would be a big deal.
(1) have `equals()` and `hashCode()` for the node objects be based only on the IDs
(2) populate the rest of the node fields as they're available; you could do this by maintaining a `Map<NodeId, Node>` yourself, so you could efficiently access the node objects you'd added.
That would probably be more efficient than creating a transformed copy of the original graph. @ogregoire I wasn't very clear in my last post: (1) and (2) together are part of a unified strategy.
Also, (1) is necessary if the nodes are to be mutable; otherwise you might be changing the hashcodes of the nodes as you populate them, which would break things.  (See this section of the common.graph User's Guide: https://github.com/google/guava/wiki/GraphsExplained#graph-elements-nodes-and-edges)
I understand that the performance of the transformation isn't necessarily the most important consideration to you in the context of deserialization.
A third option would be to create the graph based only on the node IDs, and maintain a map from node IDs to node objects, but then you'd have to carry that map around.
(In the meantime, the above code should work just fine for anyone that needs this capability.) That's a good observation, although the Bazel team hasn't contacted us to ask for that capability (and that comment has been sitting there since the file was created over a year ago).  :)
(Just curious: how did you happen to come across that?)
Also, that particular method does specialized checks that the transformation code above doesn't (and wouldn't) do, so they actually might want to do a two-stage transformation: first, check the nodes to see whether any of them are illegal by their standards (and filter self-loops), and second, do the actual transformation.  I don't think we should change this just because some times people grep for `Exception`? Yeah, I think this would also imply that no one should never include "Exception" in a method name. For that matter, it would imply that no one should ever use "Exception" in a class name, since presumably you're grepping only for the first line of a logged exception. Possibly you'd have better luck grepping for something like `^[\w.]*Exception:` (or something else adapted to your logging format) or at least for `Exception\b`. Or you can just pipe the result through `grep -v loadExceptionCount`.  Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit <https://cla.developers.google.com/> to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla --> Bulk closing all pull requests that are listed as needing CLA signing. If you'd like us to look at your pull request, you'll need to sign the CLA and report back here.
If this is a false positive, I apologize. Please reopen the pull request, and we'll have a look.  Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit <https://cla.developers.google.com/> to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla --> CLAs look good, thanks!
<!-- ok --> Thanks. I think we're satisfied with the tests that we have:
assertNull(Ints.tryParse("\u0662\u06f3"));
assertNull(Longs.tryParse("\u0662\u06f3"));
I've gone back and closed the old bug. Thanks for checking into this.  I believe the intended idiom is #2: "Inline, no cast, but reflection."
Observations, one at a time:
- Something ArrayList-like will _have_ to get used internally, because we don't know ahead of time how many elements to expect.  We're going to be doing dynamic resizing.
- I would expect "Inline, cast" to fail at runtime with a ClassCastException.  An `Object[]` is not-a `String[]`.
- It may be counter-intuitive, but `new String[0]` is _faster_ than `new String[splitList.size()]`.  https://shipilev.net/blog/2016/arrays-wisdom-ancients/ is a ludicrously thorough document explaining how and why.
If we were to add a utility method to do this, I would implement it as `splitToList(string).toArray(new String[0])`.  I don't think any other implementation could do better.  We're not ready at this time to add a method like this to Guava, sorry.  Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit <https://cla.developers.google.com/> to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla --> CLAs look good, thanks!
<!-- ok -->  I'd be a little nervous about this?  I had plans to potentially change the underlying value type in AtomicLongMap's underlying ConcurrentMap, which would break people using this API if it existed.
More generally, I'm not sure how much of a place there is for AtomicLongMap in a Java 8 world; its features are really easy to write using Java 8 features, e.g. `concurrentHashMap.merge(key, 1L, Long::sum)`.  Is there any reason why MediaType.create(type, subtype) doesn't work for you?  We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA ([login here](https://cla.developers.google.com/) to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
<!-- need_author_cla --> Bulk closing all pull requests that are listed as needing CLA signing. If you'd like us to look at your pull request, you'll need to sign the CLA and report back here.
(Another workaround, though not one you can use inline, would be the actual implementation: `checkArgument(x >= 0 && x < (1L << 32));`
I'll look at getting this added, though. Added this to the internal API review queue; will keep this updated. Added in 6fff60802ed6d8157b6178842ff9d164aa0fe928  Your implementation of TestObject does not appear to override hashCode to comply with the contract for that method, which makes essentially all hash based collections, not just HashMultiset but also the JDK built in collections, fail to work correctly.  This should work correctly if you do that: override hashCode to match equals. Can you specify which line of the documentation you're referring to? If Multiset differs significantly from Map it's probably worth fixing, but I didn't think HashMap/Set offered any more guarantees. @nirsoffer, the fact that the equals() and hashCode() methods must be consistent is probably one of the most-forgotten pieces of Java lore.  Quoting from Object.equals()' Javadoc:
_Note that it is generally necessary to override the hashCode method whenever this method is overridden, so as to maintain the general contract for the hashCode method, which states that equal objects must have equal hash codes._
starting point is an Iterator<Integer> in the first place. Something else
On Thu, Dec 1, 2016 at 6:45 AM, Kurt Alfred Kluever <
notifications@github.com> wrote:
> Perhaps better suited for common.primitives? I'm not sure...any thoughts
> on this @cgdecker <https://github.com/cgdecker> and @lowasser
> <https://github.com/lowasser> ?
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2666#issuecomment-264191046>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AA5Cl3h0IjS-17V5XEdtTTPSCIhBPHQTks5rDt2mgaJpZM4LBAcV>
> .
>
--
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
Well, there is `IntStream.empty().iterator()`, though it's not optimal.
On Fri, Dec 2, 2016 at 7:16 AM, Zheka Kozlov <notifications@github.com>
wrote:
> Also, Java standard library has no methods for getting empty iterators:
>
> public static PrimitiveIterator.OfInt emptyIntIterator();public static PrimitiveIterator.OfLong emptyLongIterator();public static PrimitiveIterator.OfDouble emptyDoubleIterator();
>
> 
> You are receiving this because you commented.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2666#issuecomment-264477349>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AA5Cl_dqfNcerEOXE6igisdoraeLVnIbks5rEDZkgaJpZM4LBAcV>
> .
>
--
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
Can you discuss what APIs exist that need a PrimitiveIterator.OfXyz?  Or what use cases you have for them directly?   I'm not sure I have a sense yet of when these are needed, which we'll probably need before these go through Guava's API review process.  Could you live with a `RangeMaps.coalesced` operation, that is, a one-off coalesce operation rather than doing it online?  This sounds like it could be satisfied by TreeBasedTable, except with more sub-table view methods? IIRC TreeMap's iteration is worst-case O(log(size)) for each next() call, but is always amortized O(1)?  That is, iterating over a whole TreeMap is always O(n) in total even if some of those next() calls take longer than others.
If I remember the analysis correctly, the iteration walks each edge of the tree at most twice: once on the way down, and once again on the way up, so the total number of edge walkings is at most 2n, so the whole iteration is O(n) and the average time among all the calls to next() is O(1). The definition of a "view" in the convention of the Collections framework is something that reads through to the backing collection, and reflects any modifications made to it.  I think we'd be pretty leery of violating that approach?
That approach also has significant performance benefits of its own: getting the view itself takes constant time, so it doesn't do any more work than it has to, especially if you just want it for a very simple operation: e.g. copying parts of the internal data structure would be overkill if you just wanted the size of a particular sub-range of the tree.  If you wanted to have "direct references to the internal data structures", it's not clear how you'd expect that to work.  You could copy that entire section of the internal binary search tree, but as alluded to above that's depressingly expensive.  But if you don't do any copying...what do you do?  If one of the elements in your sub-range happens to be the root of the entire data structure's tree, then you're carrying the whole thing around anyway; you're not actually saving anything.  And with either approach, you're violating decades of precedent of how Java's collections have always been built and how developers have expected them to work.  Additionally, we'd need to build a whole new binary search tree implementation, which we're generally pretty leery of: we made a special exception for TreeMultiset because we believed subMultiset().size() was a really important operation to optimize; that "histogram"-style queries where you asked "how many elements are in this range?" were a key use case.
Finally: how big is your data structure expected to get that O(log n) isn't acceptable?  I would tend to expect, I confess, that by the time O(log n) becomes a serious performance bottleneck, you should be using an actual database instead of an on-heap collection implementation.  Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit <https://cla.developers.google.com/> to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla --> CLAs look good, thanks!
<!-- ok -->  Thanks. We're aware of this, but we haven't emphasized it in the docs, and realistically everyone is going to have the same expectation as you, anyway. I ran across a similar bug several months ago when we added `@CheckReturnValue` to the method. (I did just look at ~60 more callers, and I found only one other instance of the bug. The common denominator between your code and that code is that the `tryAcquire` call is in a `while` loop, so possibly we could have static analysis for this.)
We do think that the current behavior is potentially useful: Why wait to say "no" when we can say "no" now? But it's also error-prone. Probably we should have accepted an enum parameters that chooses between `IfUnavailable.RETURN_IMMEDIATELY` and `IfUnavilable.WAIT`.
We might take a stab at this someday. `RateLimiter` could use some attention in general, but it's never the most important thing.... Sorry that it bit you.  I'm not sure what you mean.  contents already includes all elements of the set, and the first element is definitely staying in; this is the deduplication phase, where we only need to check each element against its predecessor.
Could you provide a reproduction test case for returning n-1 elements? Based on that behavior I would conclude that BB-second.compareTo(CC-third)
== 0.  Can you show us the details and implementation of that comparison?
On Mon, Nov 28, 2016, 12:02 PM Jonathan Bluett-Duncan <
notifications@github.com> wrote:
> Hi @MrNikita <https://github.com/MrNikita>, are you trying to show us in
> your screenshots above that the element at index 2 (which starts off as
> "CC-third") is somehow being overwritten with "AA-last", which you believe
>
> 
> You are receiving this because you commented.
>
>
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2659#issuecomment-263328578>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAhPOQ-fW403ur6zeSsrr_ktwStWIcPxks5rCwk1gaJpZM4K97P4>
> .
>
It's not clear what the implementation of compareTo for these objects is?
On Mon, Nov 28, 2016, 2:20 PM Dmytro Melnychuk <notifications@github.com>
wrote:
> @lowasser <https://github.com/lowasser> , here is comparing of these
> objects:
>
> [image: screen shot 2016-11-28 at 20 17 00]
> <https://cloud.githubusercontent.com/assets/11968111/20682353/f39ab40e-b5a7-11e6-86cd-94c0902f5481.png>
>
> 
> You are receiving this because you were mentioned.
>
>
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2659#issuecomment-263366887>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAhPOXRVkgNLusytkwpk7gg075Ko-tUZks5rCymRgaJpZM4K97P4>
> .
>
That doesn't answer the question: what is the implementation of the
compareTo method in the RolledSectionRectangularData class?
On Mon, Nov 28, 2016, 2:39 PM Dmytro Melnychuk <notifications@github.com>
wrote:
>
> if (comparator.compare(cur, prev) != 0)
>
> [image: screen shot 2016-11-28 at 20 39 04]
> <https://cloud.githubusercontent.com/assets/11968111/20683025/c02ae64a-b5aa-11e6-87d6-0388f0d439d7.png>
>
> 
> You are receiving this because you were mentioned.
>
>
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2659#issuecomment-263371981>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAhPOVVp2oTzeUn9jm2GZUsCmQOnlbuAks5rCy4DgaJpZM4K97P4>
> .
>
That is, I want to see the body of the method with the signature int compareTo(RolledSectionRectangularData). Your earlier screenshot did not show the priority field for BB-second; could you show us that please? Thank you.
The debug info you've shown shows that BB-second.priority == CC-third.priority.  So BB-second.compareTo(CC-third) will return zero, based on the implementation you've shown us.
ImmutableSortedSet, like TreeSet, eliminates duplicate elements when they compare as equal, which is the case here based on the information you've given us.  TreeSet would do exactly the same thing.
ImmutableSortedSet is doing exactly what it's supposed to based on the information you've given us.  A MinMaxPriorityQueue fails at removing the correct object after a series of operations. See output and code below.
> [5.6, 6.0, 5.7, 5.9]
Try to remove 5.7 :
[5.6, 6.0, 5.7]
Obtained from :
> MinMaxPriorityQueue<Double> values = MinMaxPriorityQueue.create();
values.add(6.2);
values.pollLast();
values.add(6.1);
values.add(6.2);
values.pollFirst();
values.add(6.3);
values.add(6.1);
values.pollLast();
values.add(5.1);
values.pollLast();
values.add(5.7);
values.pollFirst();
values.add(5.5);
values.pollFirst();
values.add(6.2);
values.add(6.3);
values.pollLast();
values.add(5.5);
values.pollLast();
values.add(5.5);
values.pollFirst();
values.add(5.6);
values.pollFirst();
values.add(6.2);
values.pollFirst();
values.add(5.8);
values.pollFirst();
values.add(6.0);
values.remove(6.2);
values.add(5.7);
values.add(5.6);
values.pollLast();
values.pollFirst();
values.add(5.8);
values.add(5.7);
values.pollLast();
values.add(6.0);
values.pollFirst();
values.add(6.3);
values.pollFirst();
values.pollFirst();
values.add(6.1);
values.add(6.4);
values.pollFirst();
values.add(5.8);
values.pollLast();
values.add(6.4);
values.pollFirst();
values.remove(6.3);
values.add(5.8);
values.remove(5.8);
values.add(6.4);
values.remove(6.0);
values.add(5.8);
values.pollFirst();
values.add(6.3);
values.pollLast();
values.add(6.3);
values.add(5.8);
values.pollLast();
values.add(5.5);
values.pollLast();
values.pollLast();
values.add(5.4);
values.remove(5.4);
values.add(5.7);
values.remove(6.1);
values.add(5.6);
values.add(5.4);
values.pollLast();
values.remove(5.5);
values.add(5.8);
values.pollLast();
values.add(5.6);
values.add(5.8);
values.pollFirst();
values.add(5.8);
values.pollFirst();
values.add(5.6);
values.pollLast();
values.add(5.8);
values.pollFirst();
values.add(5.6);
values.pollLast();
values.add(5.8);
values.pollFirst();
values.remove(5.8);
values.add(5.6);
values.add(6.0);
values.pollFirst();
values.pollFirst();
values.add(5.7);
values.add(6.0);
values.pollFirst();
values.remove(5.7);
values.add(6.1);
values.pollLast();
values.add(5.9);
values.pollFirst();
values.add(6.1);
values.pollFirst();
values.add(6.1);
values.add(6.1);
values.pollFirst();
values.remove(6.1);
values.add(6.0);
values.add(6.0);
values.pollLast();
values.remove(6.0);
values.add(5.9);
values.remove(6.0);
values.add(5.7);
values.add(5.6);
values.pollLast();
values.add(6.1);
values.pollFirst();
values.add(5.6);
values.pollLast();
System.out.println(values);
System.out.println("Try to remove 5.7 :");
values.remove(5.7);
System.out.println(values); Yikes, this does seem like a bug. Thanks for the report @forestier and for the simple repo case @perceptron8 !
MinMaxPriorityQueue<Long> values = MinMaxPriorityQueue.create(asList(2L, 3L, 0L, 4L, 1L));
System.out.println("toString():   " + values);
System.out.println("remove(4L):   " + values.remove(4L));
System.out.println("toString():   " + values);
System.out.println("remove(1L):   " + values.remove(1L));
System.out.println("contains(1L): " + values.contains(1L));
System.out.println("toString():   " + values);
System.out.println("remove(1L):   " + values.remove(1L));
System.out.println("contains(1L): " + values.contains(1L));
System.out.println("toString():   " + values);
Yields:
toString():   [0, 3, 4, 2, 1]
remove(4L):   true
toString():   [0, 3, 1, 2]
remove(1L):   true
contains(1L): true
toString():   [0, 3, 1]
remove(1L):   true
contains(1L): false
toString():   [0, 3] @Bezier89 found the bug and has a fix for it, which is under review now. Thanks again for the report! Thanks for the quick fix!  We have one of these internally, but we need to open source it.  Where is the CheckForNull annotation from?  I think we want to be consistent with normal `Object.equals` and `hashCode` here. I recognize that that's inconvenient in cases with arrays, but arrays are inconvenient in a lot of ways (including direct calls to `equals`), so the best course of action is typically to wrap them in lists as soon as possible.
In particular, the JDK's `Optional` behaves like `Object.equals` and `hashCode`, and we don't want to interfere with migrations to that type (or with migrations from nullable references to `Optional`).  Try filing an issue there? Doesn't seem to be a Guava issue on face value  we use striped<Lock> generate lock to gurantee sync operation.but we detect thread dead lock when multi thread run.
example:
```
thread1->getLock(A1)->getLock(B1)
thread2->getLock(A2)->getLock(B2)
```
all use striped.get(key) and lock.lock then run...
as before,when getLock(A2),it may return B1 lock. just then same bucket.'
i think it must use the **strict** equals to get the right lock,just as the concurrentHashMap do it. ok, i finally use the internal impl such as
```
lockStriped = new MapMaker().weakValues().initialCapacity(size).makeMap();
lockStriped.computeIfAbsent(key, t -> new ReentrantLock());
```
the reason not only the two instance.
I look the source,  tow DIFFRENT key may return the same lock, THIS is the question. I MUST guarrenty diffrent key mus return diffrent lock.  I reread @Maaartinus  write thing. It want reduce lock num, but i wont that, to reduce lock, i think weak reference can do it. I need is real lock like sync, but he says the impl not satisfy my need.  Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
It should still be "optional" in the Maven sense (meaning that it needs to be present when compiling Guava but not when compiling projects that use Guava. What problem are you seeing?  We just discussed this in https://github.com/google/guava/issues/2645, where @jrtom asked:
> We generally prefer to avoid implementing Serializable in our interfaces (see Effective Java Item 74 for some reasons why).
>
> Can you tell us more about what you're trying to accomplish? It may make more sense for you to do your own serialization and deserialization.
Thanks. If you want to persist the data for multiple runs, you might want to avoid Java serialization, since Guava doesn't promise to keep serialized forms from one Guava version readable in the next (https://github.com/google/guava#important-warnings).
We have been inconsistent in deciding when to make something `Serializable`, it's true. Part of the story is that we implemented `Serializable` more frequently in the past, before we really caught on to the many problems of Java serialization. Another part is that we ended up adding it later, anyway, in places where we got requests. I'm not sure what the takeaway is here. "Maybe we'll do it if we get enough demand, but I have no idea?" :)
I would strongly suggest that you do your own serialization/deserialization code.  Or wait (hopefully no more than a couple of months) until [JUNG](jrtom.github.io/jung) is re-released using common.graph as its data model, at which point you'll have at least a couple of different I/O options available.  Serialization is not particularly difficult if you're only trying to maintain the topology; it gets messier when you want to serialize/deserialize element and graph data as well.
@mfulton26 Yes, I'm actively working on a JUNG re-release, but the migration process is taking longer than I'd hoped (in part because I'm fixing some other issues in the process, and in part because I've recently transferred to a new team at Google and am still ramping up).
You can watch the progress of the JUNG migration on the [common.graph branch](https://github.com/jrtom/jung/tree/common.graph). Calling this issue closed for now, as it's not something that we anticipate doing in Guava for common.graph.
JUNG 3.0 still isn't released, but we've made a lot of progress on the common.graph branch and we hope to at least merge it back into master soon, to make it more visible.  I agree, that seems like a really expensive workaround.  :(
A somewhat less expensive workaround is below, assuming that your tree is fixed (not being mutated).  It costs you an extra HashMap and a copy of successors(), but for nodes with a small number of successors that shouldn't be a big deal.
If your tree is being mutated, I don't have any great suggestions for you; you'd essentially have to listen to the mutations and update `nodeIndex` ad hoc, which would be kind of a pain (and probably hideously inefficient).  :/
In general, at the moment, if you want successors() to be ordered, you need to do the sorting yourself.
``` java
// build this index once at tree creation time; this establishes the ordering
// as returned by nodes()' Iterator
Map<N, Integer> nodeIndex = new HashMap<>();
int i = 0;
for (N node : graph.nodes()) {
nodeIndex.put(node, i++);
}
Comparator<N> nodeComparator = new Comparator<N>() {
int compare(N n1, N n2) {
return nodeIndex.get(n1) - nodeIndex.get(n2);
}
}
...
fun <N> Graph<N>.children(node: N): Set<N> {
return Collections.sort(new ArrayList<N>(graph.successors(node)), nodeComparator));
}
```
Adding to my observations from above: if you want the successors of a node in a specified order, then your major options are:
(1) roll your own implementation of the interface (subclassing `AbstractGraph` if at all possible)
(2) sort the successors yourself as you retrieve them.
I don't expect Guava to provide an implementation that provides the in the near future; if you're reading this and you'd like us to reconsider, please leave a comment (and ideally explain why (2) is not practical in your case).
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit <https://cla.developers.google.com/> to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla --> Bulk closing all pull requests that are listed as needing CLA signing. If you'd like us to look at your pull request, you'll need to sign the CLA and report back here.
If this is a false positive, I apologize. Please reopen the pull request, and we'll have a look. CLA verified offline.  This is okay to merge. I've sent this to someone to review, so we'll take care of it before then next auto-closing. Sorry for the trouble. The internal reviewer found one thing to tweak. You can have a look at 7c11b8d if you'd like. Thanks for the fix, and sorry for the CLA trouble.  Thanks for reporting this. I've filed https://github.com/google/error-prone/issues/480 to see if we can get Error Prone to build newer versions of its annotation package to be compatible with Java 7.
In the meantime, people should let us know how big a problem this is. We'll add it to the list with your other bug report (#2638) for possible reasons to do a 20.0.1.
We upgraded `error_prone_annotations` from 2.0.12 to 2.0.15 in https://github.com/google/guava/commit/f81aa2d4ebdd92d2594989eabce878b60327e8a4
However, as best I can tell, 20.0.12 was compatible with Java 7:
$ JAR=Downloads/error_prone_annotations-2.0.12.jar; for F in `jar -tf $JAR | grep '[.]class$' | a .class 1`; do javap -v -cp $JAR $F; done | grep 'major version' | sort -u
major version: 51
Now 20.0.13 and 20.0.14 required Java 8, but we don't seem to be depending on them. Do you think there's any way that you could be depending on another version somewhere? Tentatively closing, since I think 2.0.12 was OK, and 2.0.15 should be, as well.  We generally prefer to avoid implementing Serializable in our interfaces (see Effective Java Item 74 for some reasons why).
Can you tell us more about what you're trying to accomplish, and whether you're targeting JSON or Java?  It may make more sense for you to do your own serialization and deserialization.
@tarushgpb OK, thanks for the update.  Closing this issue.
Fixed, thanks.
The BaseEncoding class follows [RFC 4648](https://tools.ietf.org/html/rfc4648) as specified in its Javadoc, and that specifies the '=' padding.
That said, I'm not sure this is something we could realistically change at an API level at this point?  BaseEncoding doesn't appear marked `@Beta`, and this seems like something that would be difficult to transition smoothly in open source.
@liach: as @Bezier89 mentioned on the other issue, we have an internal implementation of topological sorting that we are considering releasing in a subsequent release.
@kashike It's still on our radar.  I don't have a schedule for when we'll be able to get it out the door, though.  This convenience sounds great for a project's utilities but not common enough for Guava to add it. We generally prefer people to use `List`s from the getgo anyway over an array.  Thanks. I figured this was what was going on in http://stackoverflow.com/questions/40360901/gwt-2-8-throws-exception-when-compiling-with-guava-20, but I'd been hoping the original poster would get back to me. We'll fix this.
> Also I am not so sure why `Base.gwt.xml` pulls in `Util.gwt.xml` as the code in the base package does not seem to depend on anything from java.util.concurrent, but maybe that's because inside Google you have more code covered through `Base.gwt.xml`.
That was my first guess, as well. After looking, though, I think it's for `TimeUnit`.
This will be fixed in the next Guava release. In the meantime, you can manually add `java.lang.Lang` to your `.gwt.xml`. If it's been a problem for a year and it affects only people who avoid `collect` (with only 2 reports to us), I don't know if it's worth a 20.0.1, given that I think we plan to release 21.0 soonish. @cgdecker ?
We've talked to GWT about this on occasion. Part of the question is what the `Future` emulation will look like: Will it contain `get()`, which can't behave "correctly" on GWT? Another part is that, until we have `CompletableFuture` (or unless you have `ListenableFuture`), `Future` is of no use on it own, since, again, `get()` can't block. And part of it has been just differences in how important types are to Guava vs. how important they are to the GWT community at large.
Broadly speaking, we're happy to contribute whatever we can to GWT.
I'm thinking "by the end of the month" for 21.0, FWIW. I suppose that means an RC next week. Is truth8-gwt out in a release yet? I suppose we could depend on a snapshot for a RC if not. Should also check with others if there's anything else we feel needs to happen before 21.0.
I don't think we have truth8-gwt yet. I guess we'll want to poke cgruber again soon.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA ([login here](https://cla.developers.google.com/) to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
<!-- need_author_cla -->
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
Though it has a better worst case, it's not clear to me that this is actually likely to be a win in practice.  For example, Java's built-in String.indexOf has long stuck to an O(mn) algorithm just because its constant factors in practice tend to be so dramatically better.  How much does this change affect the constant factor of the "good" case, as opposed to the worst case?
We do test this but only internally, so it's always possible that something went wrong externally.
Is the `ImmutableList` stored in a `final` field in the object you're serializing? If so, GWT won't be able to recognize that it is serialized. I can try to find some docs on this and give some suggestions if that's what's going on.
I'm closing this issue as we don't have enough info to properly address it. If you respond back, we can reopen.  There's no relationship. (Except that we like Ben and he's contributed more than a few cool things to Guava in the past.) MG is basically a "personal playground" project, which I don't mean to sound derogatory (really, we should all have one of those).
Guava APIs have to jump through an infamous number of hoops before being approved; projects like this have essentially no hoops at all... each is good in its own way. +1 for adding this to Guava.
I do want to dig through the openjdk archives to discover why they dropped `BiStream` in the first place; that may yield useful intel.
One nice thing about `BiStream` is we could add `stream()` methods to `Multimap` and `ImmutableMap` that return it directly. That would be quite pleasant.
A pitch for the idea.
I too think its utility is beyond creating Maps. I've seen people creating List<Pair<A, B>> or even returning it. Such code is all over the places. Some I guess could have used Map or Multimap but a common argument could be that the user didn't logically need a map, but rather just trying to process some arbitrary pairs that are only meaningful in a method body (like, if you are trying to look at Doctor-Patient pairs to do some analysis).
An alternative is to create value objects. Thanks to autovalue, it's a lot easier than it used to be. But there can be cases where a class name is hard to come by (is it DoctorAndPatient?)
What I like about BiStream is that it can provide another alternative to these otherwise `List<Pair<A, B>>` use cases.
In addition to `List<Pair<>>`, I've run into the following use cases a few times:
1. Processing stream elements with indices ([stackoverflow](http://stackoverflow.com/questions/18552005/is-there-a-concise-way-to-iterate-over-a-stream-with-indices-in-java-8)).
BiStream.indexed(inputs)  // Returns a BiStream<Integer, V>
.forEach((i, v) -> println(i + ": " + v));
```
2. Guava's [Streams.zip()](https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/Streams.html#zip-java.util.stream.Stream-java.util.stream.Stream-java.util.function.BiFunction-) and [Streams.forEachPair()](https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/Streams.html#forEachPair-java.util.stream.Stream-java.util.stream.Stream-java.util.function.BiConsumer-). I think BiStream would be a better home for them, and they will be more flexible:
BiStream.zip(doctors, patients)
.filter((doctor, patient) -> doctor.likes(patient))  // No equivalence today
.map((doctor, patient) -> ...)  // Equivalent to Streams.zip()
.forEach((doctor, patient) -> ...);  // Equivalent to Streams.forEachPair()
```
Overall, I'm hoping a BiStream can eliminate another 50% of use cases where Pair may still have some appeals. Eliminating usages of Pair is a compelling argument. :-) I got curious and went digging openjdk archive.
Found two points explained by openjdk devs.
[No killer use case](http://mail.openjdk.java.net/pipermail/lambda-dev/2013-April.txt):
> For what its worth, we gathered a lot of uses cases for MapStream and
found that the vast majority were better served by what has now become
Collector.
>
> For example, the most commonly suggested use case was tabulations like:
>
> Map<Author, Integer> totalPagesByAuthor =
>    docs.stream().groupBy(Doc::getAuthor) // MapStream<Author, List<Doc>>
>                .mapValues(v -> v.stream().map(Doc::pageCount).sum());
>
> Doing this as a reduce is just as simple and actually far more efficient
> (and more flexible too).
>
> Map<Author, Integer> totalPagesByAuthor =
>    docs.stream().collect(groupingBy(Doc::getAuthor),
>                                     sumBy(Doc::getPageCount)));
>
> When we saw that what seemed like 90% of the use cases were better
served by better combinators for reduction, the return-on-complexity
>
> Some of the remaining use cases are acceptably served by streams of
Map.Entry (though this is clearly a slippery slope since once you stray
>
> So given the substantial incremental cost in complexity and code size,
we're still looking for killer use cases that would justify this.
[No tuple](http://mail.openjdk.java.net/pipermail/core-libs-dev/2016-January/038079.html)
> However, it would likely stick out like a sore thumb when Value types and then Tuples arrive (when? when they are ready!), and then we can do much better.
So, `groupingBy()` was once considered a killer use case for MapStream but then it was realized that it can be done better as `Collector`.
And mapping from `(k1, v1)` to `(k2, v2)` in MapStream/BiStream is clunky without language tuple support -- mapping to a Map.Entry is weird at best. In Mug, I'm hoping users can use one of the following workarounds:
1. call [map()](https://google.github.io/mug/apidocs/com/google/mu/util/stream/BiStream.html#map-java.util.function.BiFunction-) to go from `(k, v)` to `AProperValueObject`.
2. call `forEach((k, v) -> ...)`.
3. call `flatMap2((k, v) -> anotherBiStream)` or, heck, `flatMap2((k, v) -> BiStream.of(k2, v2))`.
4. or maybe `toMap()` and `toMultimap()` can cover some use cases.
This is also why Mug didn't add `BiStream#min()/max()` because having to return and use `Map.Entry` feels kinda unfortunate.
From openjdk perspective though, Pair will naturally disappear when tuple is added to the language so I guess in the long run it may be a non-goal or at least premature to solve yet.
I would not assume that tuples will ever be added to the language. As for value types, they are trying, but the challenges are great. Anyway, good to know that their arguments against aren't particularly dissuasive for us.  I think that we're unlikely to add visualization capabilities to common.graph, but I'm in the process of porting [JUNG ](http://jrtom.github.io/jung/) to use common.graph as its data model, so please feel free to file a feature request against JUNG for that.
Having methods be `@CheckReturnValue` by default is important to us, so we don't want to have to put it on each method individually. The IntelliJ fallout is pretty sad, though :( One thing that would be good to do is to ask the IntelliJ people if they can respect `@CanIgnoreReturnValue`. And as you note, it may be worth [asking the Error Prone team](https://github.com/google/error-prone/issues/new) if they would add their own `@CheckReturnValue` annotation. (And if you haven't already checked, it would be good to verify that IntelliJ recognizes only `javax.annotation.CheckReturnValue` and not any other annotation with simple name `CheckReturnValue`.)
I understand romani's point, though. It's just that I think we can solve this so that both sides are happy; it's premature to talk about an us vs. our users conflict.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA ([login here](https://cla.developers.google.com/) to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
<!-- need_author_cla -->
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
This is `size()`.
> The size() of a Multiset is the total number of all occurrences of all elements.
https://github.com/google/guava/wiki/NewCollectionTypesExplained#multiset
It helps to not think of a Multiset as having "keys and values". It is a Collection, so it has just "elements"; these elements might look like [a, a, b, b, b, c]. The size of that Multiset would be 6. (It also has a "distinct elements" view which looks like [a, b, c].)
This is confusing because most of us realize that a Multiset would naturally be _implemented_ as a Map. But it implements Collection, so it has to behave like a Collection at an API level.
If you prefer something that both works like a Map and _looks_ like a Map, we have this:
https://google.github.io/guava/releases/20.0/api/docs/com/google/common/util/concurrent/AtomicLongMap.html
Guava-GWT specifies the transitive dependencies it needs in its Maven pom file. If you're manually providing your dependencies, you'll need to include some additional jars. See [here](https://github.com/google/guava/blob/v20.0/pom.xml#L202) and [here](https://github.com/google/guava/blob/v20.0/guava-gwt/pom.xml#L49).
For the two particular errors you're seeing, you can download [error_prone_annotation](http://repo1.maven.org/maven2/com/google/errorprone/error_prone_annotation/2.0.14/) and [j2objc-annotations](http://repo1.maven.org/maven2/com/google/j2objc/j2objc-annotations/1.1/).
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA ([login here](https://cla.developers.google.com/) to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
<!-- need_author_cla -->
CLAs look good, thanks!
<!-- ok -->
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
We have some tooling for this: https://github.com/google/error-prone/commit/8182e1730618d33f88718bd59a1d7bca26025ff9
We used it to generate https://github.com/google/guava/commit/58986e98ddc00501be697faef89c8ac454b94ac5 on `common.base`. I will run it on the other packages and see what it spits out.
The tool identifies `readFirstLine` but not `readLine` (I think because `CharSource.readFirstLine` is `@Nullable` but `Queue.poll()` is, while nullable, not `@Nullable` :))
Let me see how hard the tool's output is to submit (since it might break some Google users' null checks). If it goes well, then you can have a look and see whether you'd like to do more.
I see a double-digit number of nullability-test failures from adding `@Nullable` to various APIs, so we probably won't pursue this further. Sorry :(
Looks like mostly, though I didn't audit them all :) A lot of them were methods like...
`getOrDefault(K key, @Nullable V defaultValue)`
...where the return might be `null` but only if `defaultValue` is null. This is what [`@PolyNull`](http://types.cs.washington.edu/checker-framework/api/org/checkerframework/checker/nullness/qual/PolyNull.html) is for, but we haven't taken the plunge to the Checker Framework, so we're stuck with plain `@Nullable` at the moment.
We do have someone internally who's been working on nullability checks (including creating the tool I referred to above), so hopefully we'll have some more progress to report in time.
Thanks.
For trees, there is a more efficient way of doing this, but it requires that you build the graph starting from the root node(s).
For DAGs you'd obviously need something a bit more sophisticated for depth checks (plus a way to add an edge between two existing nodes) and I'm not sure if there's a way to make that work, but...maybe something like that might be at least less overhead than a UnionFind data structure.
It's been on my list of things that I'd like to support, but I don't know if it's going to make it into v21.
In fact, a DAG would currently be the only item from the common.graph package I really need for my current project. For now I am using a class I have written myself, but I would gladly exchange it for a clean guava implementation.
Thus, this addition would be much appreciated, thanks!
@jbduncan I don't see how that paper helps.  It's about maintaining a topological ordering of the nodes in a DAG as it's mutated (the mutations appear, at a first skim, to be presumed to preserve the DAG properties), not about guaranteeing that a graph continues to be a DAG as it's mutated.
No worries.  I admit that I was skeptical, but it would have been really cool if it turned out to have been helpful.  :)
My guess is that if you really want real-time DAG updates, you're either willing to pay the performance hit to do the hasCycle() check every time, or you're willing to do a lazy check once a batch of edges have been added (depending on whether it's more important that you be able to identify the specific edge that first triggered the problem, or have good performance).  There might also be fast heuristic checks that could catch many common violations, but that sort of solution doesn't sound like a good fit for common.graph.
Can you say more about what you would want out of this?
I believe what jrtom was getting at is that you don't need that information encoded in the type (not to mention, ImmutableDirectedAcyclicGraph is a mouthful!). The current Graph interface can already be either directed or undirected (see the [isDirected()](https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/graph/Graph.html#isDirected--) method). Additionally, it can be acyclic, so it should satisfy your use case. However, something like "Acylic" is unlikely to be part of the interface type, since the methods an "Acyclic" graph would expose would be identical to a normal graph. We could potentially add an allowsCycles() method similar to allowsSelfLoops(), but that has some pretty hefty performance implications, per above discussion.
If what you're saying is that you want to be able to order the nodes, you can already do that with a comparator that you provide or according to their natural order if they are Comparable (and that doesn't have anything to do with whether the graph has any cycles or not).
Can you tell me about the problem that you're trying to solve that's causing you to ask for these capabilities?  The first one (providing a list), in particular, seems like a strange thing to want to do.
Based on the research that @Bezier89 did, I am strongly inclined to suggest that DAGs, in particular, not be directly supported: if you want to check to see whether a graph that you've already built is a DAG, then you can easily do that.
The thing about how constraints such as "no parallel edges" (etc.) work is that they can easily and cheaply be checked as mutations happen; the acyclicity constraint can't be (as far as we know).
I mean, I suppose there is one way we could do this that would be reasonably efficient:
- Add `hasCycles()` to the Graph and Network interfaces.
- Add an implementation of `hasCycles()` to the AbstractGraph/Network classes.  This would return `Graphs.hasCycles(this)`.
- In our internal implementations:
- Add a `hasCycles` Boolean to the internal implementations (mutable and immutable), initialized to `false`.
- Add code to the edge mutation methods that would set `hasCycles` to `null` when they were called.  (You could get clever and set it to `true` when a self-loop was added, and possibly on other special cases.)
- In the mutable implementation classes, the `hasCycles` method implementation would be essentially "if `hasCycles is null`, set it to the output of `Graphs.hasCycles(this)`; otherwise, return the `hasCycles` value".
- The immutable implementation classes would initialize the `hasCycles` bit inside the creation method (`copyOf()`) and then cache the result.
This would still be inefficient if someone called hasCycles() while the graph was being built, but if the primary use case is enabling efficient checks of this state, that would do it, and we could document this drawback.
The problem with this is that it would add complexity to the implementations (and additional surface area to the interfaces), and it would present a problem for people who wanted to implement these interfaces themselves: if they didn't essentially recapitulate this logic, hasCycles() would not reflect the cached state and would have the same cost every time.
(The other alternative would be to put the `hasCycles` Boolean in the abstract classes themselves; I'd prefer not to add anything to those classes unnecessarily, but that would at least let the 'default' implementations be efficient as long as you were subclassing the appropriate Abstract class, and doing the right thing in the mutation implementations.)
Just to clarify: this API change would _not_ come with an associated `*Builder` constraint, i.e., we would not provide any way to guarantee that cycle-inducing edges would be rejected (as self-loops are if `allowsSelfLoops()` is set to false in the `Builder`).  We would only be providing a built-in way to check if a graph had cycles, that would not necessarily require a relatively expensive check of the entire graph.
Putting things in the Abstract implementations works fine.  The overall issue is just a question of how much utility we'd be providing, and to how many users.
To be clear, the only way in which this helps _at all_ is if you're going to be calling a few different methods that each want to ensure that they're being called on acyclic graphs, and it's not convenient (or possible) to pass along a guarantee of acyclicity, e.g.:
```
void A(Graph<N> graph) {
Preconditions.checkArgument(!Graphs.hasCycles(graph));
...
B(graph);
}
void B(Graph<N> graph) {
Preconditions.checkArgument(!Graphs.hasCycles(graph));
...
}
```
If you're only going to be calling B (and only once), then you don't gain anything by the proposal above, since you do the cycle check once in that case.  If you're calling A, and you don't own B (so you can't provide a method B-prime that skips the hasCycles check), then at that point you have to do the hasCycles() check twice and being able to cache the answer starts to become important.
@liach That's not really in scope for Guava, and doesn't generalize well.  `common.graph` doesn't plan to provide a wide array of methods that operate on DAGs; its purpose is primarily to provide a common language for working with graphs, not to be a full-service graph library like JUNG or JGraphT.
Stepping back a bit:
Right now, someone that wants to write code that operates only on acyclic graphs can, and should, document that it fails (has an infinite loop, gives nonsensical answers, throws an exception, etc.) if given a graph with cycles in it.
The only way to avoid that would be to provide a compile-time guarantee that the graph was acyclic, which we do not plan to do: `common.graph` doesn't even provide compile-time guarantees that a graph is (or isn't) directed!  We gave a lot of thought to how to handle types and constraints, and finally came to the conclusion that having compile-time guarantees for anything more than the minimum (mutability, different graph types) would cause a combinatorial type explosion, and opted for providing methods (e.g., `isDirected()`) that allow for run-time type-checking.
So the farthest that we might go would be to provide another such method (`hasCycles()`) that would allow for such run-time type-checking.  And in that case you would _still_ need to document that the method would reject a graph with cycles; we'd just be providing the implementors of such methods with a way of doing an up-front check that caches the answer for a given graph _in the graph_ after the question is first asked.  (As opposed to requiring the user to cache the answer.)
It's likely that we will provide support for topological ordering, although that's an entirely separate issue from providing DAG support; if you want that to happen, please open a separate issue.
We're still figuring out what the boundaries of `common.graph` should be, though.
Well, topological ordering isn't actually DAG-related: you can generate a topological ordering for a graph regardless of whether it's directed, undirected, cyclic, or acyclic.
But by all means do open a separate issue.  :)
In any event, so far as DAG support is concerned, I think that the closest that we have to an actual proposal that we might consider doing would be what I outlined in the comment above: https://github.com/google/guava/issues/2609#issuecomment-260071602
Closing this as out of scope for common.graph, if not 100% infeasible (see the discussion above).  We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA ([login here](https://cla.developers.google.com/) to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
<!-- need_author_cla -->
Just a minor issue, but many javadocs of the new common.graph package contain a specific typo, using the word (?) "iff" instead of "if" in conditional expressions, e.g. "Returns true iff graph has at least one cycle."
Maybe you like to fix this by a package-global search/replace?
Oops, sorry did not know this, being not a native English speaker.
Something learned again, thx!
Thanks for your comments, @jbduncan and @Stephan202! Yes, according to Wikipedia it is more common in logic, maths and philosophy, and I think it is quite useful there (iff you know this term).
AFAIK there is no similar abbreviation in German language, so I was not aware of it at all.
IMHO, in the current context of the graph package, the "iff" (or "if and only if") could easily be replaced by a simple "if" in most cases: "Returns true if graph has at least one cycle." Especially, this would conform to the common usage throughout the Guava API docs, e.g. Strings.isNullOrEmpty(): "Returns true if the given string is null or is the empty string."
This has been fixed per the above commit.
True, malicious (or careless) callers can mutate the array. We will probably not fix this, given that it doesn't seem to cause problems in practice. (Plus, fixing it would reduce performance.) We should probably document `ByteSource.wrap` and any other affected methods, though.
@cgdecker , what do you think?
I believe this is the JDK's bug, not ours?
That is, all we're doing is calling the TreeMap's subMap methods, IIRC.
Thanks. Fixed.
@cpovirk is did your commit ae80b8a fix this? Or is there more to be done?
/cc @PeteGillinGoogle  Yep, thanks. I guess my "Fixes" line in the description didn't work.  This is specified in so many words in the CacheBuilder Javadoc: "If expireAfterWrite or expireAfterAccess is requested entries may be evicted on each cache modification, on occasional cache accesses, or on calls to Cache.cleanUp(). **Expired entries may be counted by Cache.size(), but will never be visible to read or write operations.**"
Cache.size() also documents that it is only approximate.
Which release candidate of GWT 2.8 are you using?
Do you have a project you can reproduce this with that you can share? I've run some GWT tests that use `ConsumingQueueIterator` with GWT 2.8.0-rc3 and Guava 20.0-rc1, and they pass.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
The argument "we get ?s in the log" (with the implied "and we wouldn't if we used the SI symbol rather than the Greek one") seems like a pretty decent one for using the SI symbol.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
Bulk closing all pull requests that are listed as needing CLA signing. If you'd like us to look at your pull request, you'll need to sign the CLA and report back here.
If this is a false positive, I apologize. Please reopen the pull request, and we'll have a look.  Err, didn't mean to close this one, sorry.
We've mirrored out [our implementations](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/CollectCollectors.java) (along with [other Java 8 changes](https://groups.google.com/d/topic/guava-announce/o954PqvaXLY/discussion)). Let us know if you have any particular suggestions.
Now that you mention it, a new issue is probably the way to go for any suggestions, given how broad this feature request currently is. I'll close it, and yes, please do open a new issue. Everyone else, feel free to do the same.
Those presentations are very out of date at this point, so I've just removed them.
For the record, here is what they _were_:
- [Presentation slides focusing on base, primitives, and io](http://guava-libraries.googlecode.com/files/Guava_for_Netflix_.pdf)
- [Presentation slides focusing on cache](http://guava-libraries.googlecode.com/files/JavaCachingwithGuava.pdf)
- [Presentation slides focusing on util.concurrent](http://guava-libraries.googlecode.com/files/guava-concurrent-slides.pdf)
At the very least, we should document that the method does not support IPv6 addresses with scope IDs.  It's honestly not clear what your issue is, but it's certainly not something to do with Guava.
No rush, of course, but now that we're close to putting our Java 8 features out there, we can finally do the same for our Java 7 features :)
@cgdecker (but again, no rush)
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
Yeah, we've fallen behind on removing things. `sameThreadExecutor` is on our to-do list. We won't hold up Guava 20 over it, though, so it might hang on longer :(
Anyway, thanks for the comment fix.
FWIW, `Constraints` _was_ public from Guava 3.0 to 15.0, but the idea of a List/Set that has "invisible" constraints on it was not a great one, so we deprecated and eventually removed public visibility from those APIs.
I'm actively working on removing `MapConstraints` from Guava as well (which has already been deprecated for quite some time). For similar reasons, it was not a great idea to begin with.
Some library (not jsonschema, but *something* else in your class path) is
jars in your class path to find it.
On Thu, Jan 5, 2017 at 10:01 AM, Trent Brown <notifications@github.com>
wrote:
> 20.0 and still happens.
>
> Not using Cloudera. Just trying to use validator in a servlet.
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2578#issuecomment-270711985>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AA5Cl4zfnGu1sgPynZPdRC-jQ327los5ks5rPS_jgaJpZM4KImte>
> .
>
--
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
This might be the case for a user of Files, but each method in Files should properly document its semantics and whether or not it closes the stream.  It's the user of the Files API who has the responsibility to deal with that correctly.
Actually...let's check.  Is your tool any more specific about what part has the potential issue?
I suspect the tool is just complaining that c.g.c.io.Files has helper methods to create new streams, including newReader and newWriter.  If there's a more specific issue, we can look into it, but I would expect this to be a false positive.
This seems like it could at least conceivably be a problem if, and only if, you used FileBackedOutputStream.  Do you?
No, this is not "used where security is a concern."
In this case, no.  Even if security is a concern for your project, this API is fine; it's perfectly okay if the randomness is predictable or controllable.
I am not sure I follow.
You do not have to do anything.  Randomness is an optimization here.  The worst that can happen is hash collisions.
Not sure what you're asking here.  You don't need to do anything.  This is not a plausible attack vector.
The tool's advice is "If this random number is used where security is a concern, such as generating a session identifier or cryptographic key, use a trusted cryptographic random number generator instead."
This random number is not used where security is a concern.  There is nothing you need to do.
We've historically resisted making Builders any more full featured than just basic add-only APIs.  Note ImmutableMap.Builder's internal implementation is just a list of entries, not a map that supports efficient contains queries...and messing with that implementation would impose costs on all existing users of ImmutableMap.Builder, not just the ones who want computeIfAbsent.
At the moment there's a super easy workaround: use a LinkedHashMap, computeIfAbsent on it, and then ImmutableMap.copyOf that.  That's essentially the implementation we'd be using internally anyway if we supported this feature.
I don't believe there's an implementation of the Builder we could write
that would support computeIfAbsent efficiently that would be any better
than the hash map you're already using.
On Fri, Sep 23, 2016 at 10:04 AM cgrushko notifications@github.com wrote:
> Yep, we're using copyOf on a hash map. Thought I'd save some memory,
> though.
>
> On Fri, Sep 23, 2016, 13:00 Louis Wasserman notifications@github.com
> wrote:
>
> > We've historically resisted making Builders any more full featured than
> > just basic add-only APIs. Note ImmutableMap.Builder's internal
> > implementation is just a list of entries, not a map that supports
> > efficient
> > contains queries...and messing with that implementation would impose
> > costs
> > on all existing users of ImmutableMap.Builder, not just the ones who want
> > computeIfAbsent.
> >
> > At the moment there's a super easy workaround: use a LinkedHashMap,
> > computeIfAbsent on it, and then ImmutableMap.copyOf that. That's
> > essentially the implementation we'd be using internally anyway if we
> > supported this feature.
> >
> > 
> > You are receiving this because you authored the thread.
> > Reply to this email directly, view it on GitHub
> > https://github.com/google/guava/issues/2573#issuecomment-249246375,
> > or mute
> > the thread
> > <
> >
> > .
>
> 
> You are receiving this because you commented.
>
> Reply to this email directly, view it on GitHub
> https://github.com/google/guava/issues/2573#issuecomment-249247671, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/AAhPOZkLSvjYmvHWuZwkLmFRF3-yxHk8ks5qtAasgaJpZM4KFLRN
> .
Fixed...thanks!
@eamonnmcmanus might know what we'd need to do. @cpovirk can you log a separate issue for that and assign it to me? Filed https://github.com/google/guava/issues/2723 (I'm already assigned on #2723 and I don't think I'm otherwise involved here.) @netdpb did a bunch of work here after I stopped, and it's been released in [23.1](https://github.com/google/guava/releases/tag/v23.1).
Remaining:
- https://github.com/google/guava/issues/2920 (Automatic-Module-Name on submodules)
- https://github.com/google/guava/issues/2723 (inheritableThreadLocals)
I don't believe there's anything to do with `Unsafe` yet, as it's [remaining exposed in Java 9](http://openjdk.java.net/jeps/260).
Let's track remaining work with the separate bugs. Please open more if you encounter more problems.  Can you provide a failing test that shows the behavior you'd like changed?
" Is it part of the contract in a doc I missed?"  I think so: https://google.github.io/guava/releases/19.0/api/docs/com/google/common/collect/ForwardingCollection.html#standardAddAll(java.util.Collection)
"A sensible definition of addAll(java.util.Collection<? extends E>) in terms of add(E). If you override add(E), you may wish to override addAll(java.util.Collection<? extends E>) to forward to this implementation."
Thanks. We'll bump the timeout.
That helped a little, but it looks like we're hitting a limit set by Travis:
https://travis-ci.org/google/guava/jobs/162808090
https://github.com/prov-suite/interop-test-harness/issues/13#issuecomment-228038376
Possibly we should just disable GWT tests for Travis entirely.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
It looks like you're still not showing up in the CLA list. Is it under some email address other than dave-github@earth.li?
CLAs look good, thanks!
<!-- ok -->
Yep, sorry :( It's at least a one-time cost, if that's any consolation. I'm submitting this internally now, and it will be mirrored out shortly.
/cc @jrtom @Bezier89
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA ([login here](https://cla.developers.google.com/) to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
<!-- need_author_cla -->
Not sure why you feel this is necessary?  log2, which these methods call immediately, already does this check.
There's no reason to check twice.  We have tests to make sure the exception gets thrown somewhere, and throwing the exception is part of log2's contract, which we can depend on.
Bulk closing all pull requests that are listed as needing CLA signing. If you'd like us to look at your pull request, you'll need to sign the CLA and report back here.
If this is a false positive, I apologize. Please reopen the pull request, and we'll have a look.  Thanks!
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
Have you seen https://github.com/google/guava/pull/1949 ? We already have this but have not yet decided whether we want this in external Guava.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
I think we're actually going to aim to kill off this class entirely and replace it with Truth rather than try to fix its brokenness.
Bleahhhhh it looks like we might have to live with this class due to some dependency weirdnesses.
Going to reopen this so we can fix this issue, at least.
CLAs look good, thanks!
<!-- ok -->
@lowasser do you mind handling this request? thanks
I'm pretty sure I got this already, not sure if it's sync'd out yet though.
https://github.com/google/guava/commit/6c63cf3c8a9d94821e2b24a96fb4c3564377051f
This would be a backwards incompatible change, and thus unlikely for us to do.
Assuming you control the types inside the nested iterables, can you have your type return an empty list instead of null? (e.g., `ImmutableList.of()`)?
2) yes, that's the case for `Objects.toString()` and `String.valueOf()`, but very few other APIs use the magic string "null".
Presumably somewhere you're calling `Iterables.toString(possiblyNullList)`, right? Why not just wrap that call in a conditional (or use a ternary as I suggested above)?
This sounds like a bug in the third party library if it is passing
iterables that may be null to Iterables.toString.
On Mon, Aug 22, 2016, 11:49 PM guyman notifications@github.com wrote:
> Closed #2553 https://github.com/google/guava/issues/2553.
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> https://github.com/google/guava/issues/2553#event-764036651, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/AAhPOTEOYt9oA3VTDCeduj8vopWLQe9Uks5qipf7gaJpZM4Jp6xf
> .
Internally, Chris said:
Guava 20 is going to require GWT 2.8.0 (rc1 or later). We could conceivably back out some recent changes so that it works with beta1, but it feels weird to maintain compatibility with a beta for the long term, especially when that beta is known to have problems with Guava: https://github.com/gwtproject/gwt/issues/9351#issuecomment-228155079. Can you tell us what blocks you from updgrading to rc1? Is it just a bug that has hope of being fixed before the final 2.8.0?
Thanks. Looking at this now.
Nice, didn't realize that GWT had added this.
And thanks. I didn't realize that we'd fully duplicated `TreeTraverser`, either.
We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA ([login here](https://cla.developers.google.com/) to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
<!-- need_author_cla -->
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
Duplicate of #1264
Which link? Can you be more specific?
That link seems to work for me...is it not working for you?
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
Bulk closing all pull requests that are listed as needing CLA signing. If you'd like us to look at your pull request, you'll need to sign the CLA and report back here.
If this is a false positive, I apologize. Please reopen the pull request, and we'll have a look.  Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
as are it's very few dependences.  What is this pull request accomplishing?
On Wed, Jul 20, 2016, 07:24 Kurt Alfred Kluever notifications@github.com
wrote:
> Assigned #2534 https://github.com/google/guava/pull/2534 to @cgruber
> https://github.com/cgruber.
>
> 
> You are receiving this because you were mentioned.
>
> Reply to this email directly, view it on GitHub
> https://github.com/google/guava/pull/2534#event-729050744, or mute the
> thread
> .
Bulk closing all pull requests that are listed as needing CLA signing. If you'd like us to look at your pull request, you'll need to sign the CLA and report back here.
If this is a false positive, I apologize. Please reopen the pull request, and we'll have a look.  This has been fixed  This is explicitly in the list of features that have been rejected for Guava; see https://github.com/google/guava/wiki/IdeaGraveyard#iterablesisnullorempty, which also links to a discussion of the issue on StackOverflow.
This sounds like a problem with compiler type inference and not something Guava can do anything about.
Thanks.  Good eye! Will get this fixed up
Are you familiar with AutoValue?  (https://github.com/google/auto/blob/master/value/userguide/index.md)
AutoValue is our current preferred approach for dealing with the pain of equals/hashCode/toString in Java value classes.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
Thanks Raffi, but we've been hard at work on a Guava for Java 8 branch which should be out later this year. That being said, I'm going to close this out.
FYI @lowasser - you might be interested in seeing what was proposed here.
Oh man, I think this is going to cause some serious breakages inside of google if we merge it. This is pretty scary.
> HTTP/2 requires lowercase
Can you send a reference to the RFC or whatever? I'm going to start an internal thread about this and see what folks think.
Ahh, I think I found it:
> header field names MUST be converted to lowercase prior to their encoding in HTTP/2. A request or response containing uppercase header field names MUST be treated as malformed
https://httpwg.github.io/specs/rfc7540.html#rfc.section.8.1.2
Hey Jesse,
We discussed this internally quite a bit, and decided to leave it as is.
> The fact that HTTP headers are lowercase on the wire is an implementation detail. It does not need to be surfaced to users.
And...
> The HTTP/2 protocol is mostly binary, so you'd be using an encoder anyway.
Yes, there is a slight performance penalty for lowercasing, but it's not even close to large enough for us to try to push a change of this magnitude through.
Cheers,
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
We do expect to support this use case eventually, but we're still looking to settle the API. Hopefully someday :(  I'm not sure what's unsuitable about Iterables.partition for this use case?
On Thu, Jun 30, 2016, 12:25 AM lpbak notifications@github.com wrote:
> The utility class Sets could use a new method <T> Set<Set<T>>
> partition(Set<T> set, int size), similar to the one in Lists class. Such
> a method would be useful for various applications, e.g. for batch
> processing elements for which order is unspecified/unimportant, and I don't
> think there is a straightforward way of achieving the same effect with Java
> 8 streams API.
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> https://github.com/google/guava/issues/2516, or mute the thread
> .
I'm not sure why you wouldn't write
```
Iterables.partition(elements, batchSize)
.forEach(batch -> processElements(new HashSet<>(batch)))
```
I'm also a bit concerned about issues like Sets.partition(myTreeSet, batchSize) not being able to identify which set implementation to use.  It's not even clear what set implementation we'd want -- immutable?  LinkedHashSet? -- where there's no real ambiguity for lists.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA ([login here](https://cla.developers.google.com/) to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
<!-- need_author_cla -->
CLAs look good, thanks!
<!-- ok -->
Hmmm.  The docs of expireAfterWrite say
- <p>When {@code duration} is zero, this method hands off to {@link #maximumSize(long)
- maximumSize}{@code (0)}, ignoring any otherwise-specificed maximum size or weight. This can be
- useful in testing, or to disable caching temporarily without a code change.
This logic is implemented in CacheBuilder.getMaximumWeight().
Did you actually experimentally verify that the values are returned?  Or did you just guess that from the code?
More or less a duplicate of https://github.com/google/guava/issues/330 -- not exactly, but close enough.  It certainly seems to me like this is better done either a) imperatively or b) using the feature for exactly this in Java 8, `Stream.collect(toMap(keyFunction, valueFunction))`.
I think we're inclined against adding more of these features that Java 8 does so much better when we're hard at work making Guava for Java 8 a thing.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
Fixed a little differently in 1b1163b7e2c121d4a5b25b8966714201551976c4. Thanks for reporting.
Presumably `getDelay` would just return `0`, which is probably good enough for the kinds of places I'd expect to see it used.
`ScheduledFuture` is rarely used enough that I hate to introduce new APIs for this :\ We could always retrofit the old `immediate*` methods to return `ListenableScheduledFuture`. To maintain compatibility, we'd have to either inject bridge methods or continue to declare only `ListenableFuture` as a return type while promising in the docs to also by `Scheduled`.
Needs more thought.
Fixed the bug; I think we ended up slightly changing the implementation (and doing much more aggressive testing).  The fix should be mirrored out shortly.
Thanks, fixed! The wiki is only editable by team members currently.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
That API is non-@Beta, and this might be an incompatible change. Can you confirm @cpovirk ?
We could hack around this by creating a package-private superclass of `Iterators` with the old signature. Probably it's not worth the trouble, though. Returning `ListIterator` would have been better, but you can call `asList(array).listIterator()` or `asList(array).subList(x, y).listIterator()` where necessary.
I'm not certain why this wouldn't be working as intended, or even breaking to other users who depended on this behavior.  Registering two of the same handlers seems like an indication that the user specifically wants events to be handled twice.
It sounds like that's an issue your builder should be addressing, not EventBus.
Generally speaking nulls usually indicate a bug you should actually deal
with rather than just silently accepting them.
Anyway, why not use compare(firstName, o.firstName,
Ordering.natural().nullsFirst())?
On Tue, Jun 14, 2016, 10:35 PM wshen324 notifications@github.com wrote:
> At ComparisonChain.java line 81.
> Argument left can be null, if left is null, will throw NullPointException.
> Must write as below code, not elegant.
>
> return ComparisonChain.start()
> .compareFalseFirst(firstName != null, o.firstName != null)
> .compare(firstName, o.firstName)
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> https://github.com/google/guava/issues/2503, or mute the thread
> .
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
Thanks. I think I'm going to keep it as a constructor call but add the required parameter.
We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA ([login here](https://cla.developers.google.com/) to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
<!-- need_author_cla -->
CLAs look good, thanks!
<!-- ok -->
`FluentIterable.from(...).transform(...).join(joiner)`
Maybe we should document this pattern on `Joiner`.
One difficulty with an overload of `join` is that we already have `join(Object, Object)`.
We could create a `transformAndJoin` method, but I think we're better off with the `FluentIterable` approach, which can also support `filterAndJoin`, `limitAndJoin`, etc.
Adding transform functionality directly to Joiner has been discussed and ruled out in #1392 and #1064.
In any event, in Java 8 you have access to the superior `collection.stream().map(function).collect(joining(...))`.
Thanks, Louis. I filed https://github.com/google/guava/issues/2497 for the possible doc change.
This seems a pretty clear duplicate of https://github.com/google/guava/issues/1442.
To summarize the conclusion of that issue: the null values in ArrayTable are, in every sense, "really there." They count, whether or nut null was explicitly put in.
We should probably document `ArrayTable` to say "This is probably not the `Table` implementation that you want." It accounts for <2% of the `Table` usages in Google code, for example.
It's true that you have to explicitly put the null values in, but that's the point: `ArrayTable` _has those null values._  That's how it's defined; it starts filled with nulls.  It's not an implementation detail, it's a conscious and deliberate part of the API design.  If that hadn't been intentional, we would've done something like what EnumMap does, with an internal explicit object being used to represent null that gets translated away.
Thanks. We should emphasize it: https://github.com/google/guava/issues/2495
lowasser@ is right.  That said, Monica, you might find this useful if you think your account may have been compromised: https://support.google.com/mail/answer/50270?hl=en
We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA ([login here](https://cla.developers.google.com/) to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
<!-- need_author_cla -->
We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA ([login here](https://cla.developers.google.com/) to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
<!-- need_author_cla -->
Duplicate of https://github.com/google/guava/issues/2071
Thanks. Unfortunately, this is expected right now, as we don't have a convenient continuous build to verify that things work on Windows.
Interesting. While we're unlikely to change `Table` itself at this point, we could conceivably add something like this to the `Tables` utility class.
Does anyone have a pointer to code that might use this?
Thanks. Please report to GWT, since this appears to be an internal error in their compiler.
For my reference: https://github.com/gwtproject/gwt/issues/9351
Thanks for taking care of that.
We have one internally, but it has never been very popular. I assume you're looking for a stream that forwards every write to several other streams?
We do have one implemented. We just need to decide if it's worth releasing (and if it needs any API changes, like switching to using suppressed exceptions when available). If you need one for yourself, though, you probably should stick with your own. We might take a long time :(
We do throw an aggregate `IOException`. We don't provide a reference back to the particular `OutputStream` that failed, though. I hadn't thought about that.
We use it internally. It would be nice for external contributors if we extended that to our open-source build. And it would set a good example. Possibly we could even turn on some compile errors that haven't been enabled for all of Google. Further, this may make it easier for us to switch from Animal Sniffer to the (currently internal but maybe to be released someday?) Error Prone version checker.
For compound operations, try `FluentIterable`:
`FluentIterable.from(iterable).filter(predicate).size()`
(Or, if you can use Java 8, use similar `Stream` code.)
What is the volley repository? Are you sure you reported this to the correct project?
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
Sorry for the trouble that this caused you. This is indeed intentional. The best documentation I know of at the moment is [Error Prone's](http://errorprone.info/bugpattern/CollectionIncompatibleType). We do want to extend Error Prone to catch bugs not just with the use of JDK collections but also with `Cache`, but we haven't gotten there yet. Our hope is to do so by introducing some kind of `@TypeCompatibleWith` annotation. If we do that, then IntelliJ could read the annotation and provide the same warning. (Or they could just special-case `Cache` today.)
Cache, but actually FindBugs has beaten us to that by a few years. I would
suggest adopting it in your project. It's unfortunate, but static analysis
is the only real solution here.
On Mon, May 16, 2016 at 6:44 AM, Chris Povirk notifications@github.com
wrote:
> Sorry for the trouble that this caused you. This is indeed intentional.
> The best documentation I know of at the moment is Error Prone's
> http://errorprone.info/bugpattern/CollectionIncompatibleType. We do
> want to extend Error Prone to catch bugs not just with the use of JDK
> collections but also with Cache, but we haven't gotten there yet. Our
> hope is to do so by introducing some kind of @TypeCompatibleWith
> annotation. If we do that, then IntelliJ could read the annotation and
> provide the same warning. (Or they could just special-case Cache today.)
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/pull/2481#issuecomment-219427998
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA ([login here](https://cla.developers.google.com/) to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
<!-- need_author_cla -->
This makes some sense in Java 8 where a Supplier is just a lambda and an
Object with an overridden toString is an anonymous inner class.  And using
this approach at all lets you avoid front loading computations on the
objects that get captured by the lambda.
That said, until Java 8, the Object anonymous class is just as good.
On Wed, May 25, 2016, 9:44 AM Luke Sandberg notifications@github.com
wrote:
> re: Preconditions
>
> why not just pass a custom object with an overridden toString method?
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/pull/2480#issuecomment-221631532
On Wed, May 25, 2016 at 10:13 AM, Louis Wasserman notifications@github.com
wrote:
This makes some sense in Java 8 where a Supplier is just a lambda and an
> Object with an overridden toString is an anonymous inner class. And using
> this approach at all lets you avoid front loading computations on the
> objects that get captured by the lambda.
Preconditions was never designed with the notion that "if you _ever_ have
we ever introduced Preconditions at all.
> That said, until Java 8, the Object anonymous class is just as good.
>
> On Wed, May 25, 2016, 9:44 AM Luke Sandberg notifications@github.com
> wrote:
>
> > re: Preconditions
> >
> > why not just pass a custom object with an overridden toString method?
> >
> > 
> > You are receiving this because you are subscribed to this thread.
> > Reply to this email directly or view it on GitHub
> > https://github.com/google/guava/pull/2480#issuecomment-221631532
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/pull/2480#issuecomment-221640710
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
Bulk closing all pull requests that are listed as needing CLA signing. If you'd like us to look at your pull request, you'll need to sign the CLA and report back here.
If this is a false positive, I apologize. Please reopen the pull request, and we'll have a look.  Google Code is being turned down, but I'm not sure whether or not JSR 305 has just moved?
As surprising as this behavior is, I think it's...technically...spec-compliant.  Took me a couple minutes to figure it out.  That doesn't mean it's not unacceptably surprising, or fixable, though.
The issue isn't the laziness, it's the _weak_ part.  The lock is weakly referenced by the Striped; it says so in the "weak" part of the method name.
The issue is that those two methods of yours don't hold on to the `ReadWriteLock` itself.  They hold on to the read lock and to the write lock.  Separately.  And those don't hold references back to the `ReadWriteLock`.  So the `ReadWriteLock` is eligible for garbage collection in the middle of the method, and a new one gets generated the next time someone asks for it, and since it's not the same lock they interoperate at the same time.
RE: fixing in JDK: That sounds like a good idea to me. Are you interested in reporting on http://altair.cs.oswego.edu/mailman/listinfo/concurrency-interest? If not, I can do it -- probably not immediately but well before I do the API thing, at least :)
Also, FWIW, I tend to consider ~all JDK classes that are not explicitly abstract to be implicitly final, and extending them to be a dangerous practice. Yeah, it's a weird case that the JDK might not be interested in handling. I think it's worth asking them, but I could understand if they were to say no.
I also agree in general about extension, but I am willing to occasionally make exceptions for `java.util.concurrent` classes, which seem to be designed at least a little more for extension, in only so that people can save a little indirection by using inheritance. And classes like `ReadLock` have docs like "Constructor for use by subclasses," which is also encouraging. Nevertheless, I do think that composition is nicer here; I just consider inheritance to be a little safer than usual, if still hairy. > Posted.
If I recall correctly, I had to join the list before I could post. I'm not seeing your post, so that would explain it.  See https://github.com/google/guava/issues/2474
Sadly we have no way to make them redirect to github either :(
Also I've reported the bad search results internally...not sure how easy it is to get those fixed, but we'll see.
The entire Google Code project-hosting service has been turned down, so the links are permanently broken. You've found the right new location, though 19.0 is out, so you can use that: http://google.github.io/guava/releases/19.0/api/docs/
Wrote a G+ post about this last night, but sadly those links won't work anymore
https://plus.sandbox.google.com/+googleguava/posts/e1ATtGUxSy7
@jrtom Josh: what's our plan w.r.t `TreeTraverser` and the new graph APIs?
Sorry, I think I missed this when it first came around.
We're currently looking at some changes that would affect what TreeTraverser is and how it would fit in with the common.graph APIs.  I hope that we'll have this resolved for Guava 22, but I don't think that we're ready to remove the @Beta annotation just yet.
We intend for rejecting null parameters to be the default. The official documentation of that is `@ParametersAreNonNullByDefault` [on each package](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/collect/package-summary.html).
That said, I thought that we tried to explicitly say "if foo is null" in cases where we already have to say "if any element in foo is null." If someone can dig up examples, that might help us figure out whether to zig or zag. Or maybe we already made an official decision one way or the other here that I don't remember. Anyone?
It just does `throw new RuntimeException(e)`. (This became clearer in https://github.com/google/guava/commit/f400dd0b93272a156bbf471edf03b3bf2ba65d70 .) That's probably good enough (and `WrappingExecutorService` is package-private in Guava, with only "safe" users) that it will never be worth our trouble to fix. But it would be nice to at least document more clearly.
There's no problem for Guava users. There's a potential problem for users internal to Google, who can create their own `WrappingExecutorService`. If we ever open the class up for public use in Guava, Guava users could encounter the same problem.
The problem exists only if the wrapped `Callable` returned by `wrapTask` throws a checked exception that the original `Callable` didn't already. In that case, we wrap the checked exception in a `RuntimeException`. This is probably what a lot of users want -- assuming that _anyone_ actually writes a `wrapTask` method like the one I've described -- but is different enough from how we normally handle checked exceptions that I'd like to document it.
Do you have an actual use case where the value collection is a Set?  Can you discuss it?
Calls to `ImmutableSetMultimap.copyOf(Multimaps.index(...))` account for about half a percent of all `Multimaps.index` calls in Google's code. But probably `SetMultimap` would be a good choice for a decent fraction of all callers. For starters, it would be interesting to see how many calls to `index` pass a `Set`.
We should add this to `MapEntrySetTester` so that all our collections benefit. This is similar to what CL 116244562 did for "normal" `setValue` calls.
Closer is definitely the thing to use here.  Also note that if you have AutoCloseable, you have try-with-resources, which works better and more cleanly than anything Guava could do.
@simonmcooper I discussed that some above -- I'm not sure I follow in what sort of situation you might have an unbounded collection of resources in need of closing?  Or do you just want more of them in one line, in which case a varargs overload might make sense?
Again -- the low-boilerplate way of dealing with both Closeables and AutoCloseables is try-with-resources, which you must have available if you have AutoCloseables.
Is there a reason you couldn't do this filtering in the listener itself?
It's not the implementation; the implementation is required by the Cache
interface to do this (although that could be made clearer).
Null values would break at least the getAll, getIfPresent, and
getAllPresent methods. This would also imply that CacheLoader.load() should
be able to return null, but we discovered that many users assume that null
values get cached and many users assume they *don't *get cached, so that
Use a Cache<YourKey, Optional<YourValue>> and it will make your code
clearer anyway!
On Tue, Apr 19, 2016 at 12:16 AM, Shrikant notifications@github.com wrote:
> In LocalCache.java
> @Override https://github.com/Override
> public V put(K key, V value) {
> checkNotNull(key);
> checkNotNull(value);
> int hash = hash(key);
> return segmentFor(hash).put(key, hash, value, false);
> }
>
> is there a specific reason for adding a null check for the value as well.
> why can't cache have null values.
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2461
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
My understanding from glancing at the Javadocs is that Iterables.partition already does what you want, and that it is only Iterables.paddedPartition that does the padding.  Are you certain this is actually a problem for you?
You have a good point but bad timing :) I'm just recently coming to believe that submitting a `FutureTask` to an `Executor` is an antipattern: It permits users to call `cancel(true)`, which is only safe for executors that are actually designed for that:
https://github.com/google/guava/issues/1989#issuecomment-199262664
https://github.com/google/guava/issues/2440
A couple things I glossed over:
- Submitting a `FutureTask` is fine if we disable interruption (not that `FutureTask` provides an easy API for that, but we could come up with one). However, interruption is a large part of `SimpleTimeLimiter`'s purpose -- not its _entire_ purpose, but without interruption, it might well use arbitrary numbers of threads. (Admittedly it can already do this if the task simply isn't interruptible by nature.)
- If you do want to use a plain `Executor`, you can get most of the implementation for free by creating an `AbstractExecutorService` that delegates `execute` to the `Executor`. That still leaves you with the shutdown methods to implement (probably as `throw new UnsupportedOperationException()`). And, as you've noted, it's clearly not a clean solution.
- `listeningDecorator` already takes the "pragmatic compromise" I described above. And my guess is that we're not going to want to change it. So we should probably document the compromise somewhere and adopt it more widely. (Again, I know that this doesn't help you here.)
Thanks! I've tweaked a couple things (mostly to leave the soon-to-be-deprecated methods as `@GwtIncompatible`) and will get this submitted internally and mirrored back out.
I'm not sure why you would need this?  You can just do `Collections.max(Arrays.asList(bigIntegerArray))` or use any of the other ways to get a max of `Comparable`s.
Please stick with standard methods for Comparables.  If you really feel the available options for Comparables are too long, please submit a feature request for something that works for all Comparables.
I would fix this problem by removing the superfluous "? extends" from the
second and third functions. It doesn't serve any valuable purpose. Yes, we
way, but hopefully you can still get your signatures right.
Here's an excerpt from an internal resource that tries to explain the
situation.
"Pass-through" types
In some less common cases, a type is neither being produced nor consumed,
only "passed through" to the return type:
public static <T> Iterator<T> filter(
Iterator<T> input, Predicate<? super T> predicate) { ... }
Here, predicate consumes Ts, so by the PECS rule it needs the super. And as
mentioned above, we don't put a wildcard on the returned iterator. But what
about the input iterator? It produces Ts, so it needs extends, right?
Not quite. It turns out that we don't need any additional wildcard here.
with legal inputs will be able to invoke the method," and this is already
the case with the signature shown above. You can invoke it with an
Iterator<Integer> and a Predicate<Number>, just as you should be able to.
And you'll get an Iterator<Integer> back, which is exactly what you should
get.
The only effect of adding extends to the input iterator is that it lets the
user arbitrarily choose to store the result in a variable of type
Iterator<Number> instead. In other words, we've used the occasion of
invoking the filter method as a convenient opportunity to "upcast" the
iterator at the same time, for no particular reason that has anything to do
Iterator<Object> back -- which is _no less reasonable_ than wanting
Iterator<Number> -- it wouldn't work.
gave up.
On Thu, Apr 14, 2016 at 6:54 PM, Joel Croteau notifications@github.com
wrote:
> Is there a reason that Collections2.transform accepts a Function<? super
> F, T> as its second argument instead of a Function<? super F, ? extends T>?
> The latter is the type used by the underlying TransformedCollection type
> and would expand usability. It would also make in consistent with similar
> functions in other classes in collect like Lists and Iterables. In
> particular it would help resolve a certain ambiguity that comes up when
> overloading with this method in Java 8. Consider the following example:
>
> public class Fns {
>   public static <E, T> Collection<E> map(Function<? super T, E> fn, Collection<T> coll) {
>     return Collections2.transform(coll, fn);
>   }
>
>   public static <E, T> List<E> map(Function<? super T, ? extends E> fn, List<T> coll) {
>     return Lists.transform(coll, fn);
>   }
>
>   public static <E, T> List<E> map(Function<? super T, ? extends E> fn, T[] coll) {
>     return map(fn, Arrays.asList(coll));
>   }
> }
>
> This code works in Java 7, but in Java 8, the third overload generates an
> ambiguous reference error, because the compiler is not sure which of the
> first two overloads to use. This can be fixed by making the first version
> accept a Function<? super T, ? extends E>, but of course, this won't work
> with Collections2. If the type of the function argument to
> Collections2.transform could be changed, it would make our migration to
> Java 8 much easier.
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2455
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
A change here would have help a small number of users, and it stands a chance of breaking others, so we will probably end up living with this wart forever :(
The easiest thing is probably for you to cast:
```
Collection<Super> output = (Collection) transform(input, function);
```
If you want to avoid the unchecked cast, you can call `Collections.unmodifiableCollection` instead.
Can you clarify what you're requesting?
First note that the Graph API is still going through a lot of changes as we
prepare for release.
I haven't seen that Stack Overflow post. I'm not sure what this means:
Set could have no direct implementations, instead having MutableSet and
ImmutableSetas subinterfaces which are then used for implementing classes.
This has the same issue as above: at some point in the hierarchy, an
interface has conflicting invariants. One says "this set must be mutable"
and the other says "this set cannot change."
That is, I don't see the conflict they are talking about. In our case,
MutableGraph and ImmutableGraph are sibling types. If you interact with
something of type Graph, yeah, it might be mutable or might not be, but
that's what you're signing up for by choosing that type.
Btw, here's the official answer
http://docs.oracle.com/javase/1.5.0/docs/guide/collections/designfaq.html#1
to
this question for Collections.  It has mostly to do with interface
overload, a problem we aren't facing in the Graph realm.  And it's
of the Collections design.
On Wed, Apr 13, 2016 at 3:38 PM, Jonathan Bluett-Duncan <
notifications@github.com> wrote:
> curious as to why the Java Collections framework didn't do the same. I
> googled it up and found this StackOverflow answer
> http://programmers.stackexchange.com/a/289372, which I think gives a
> very convincing explanation as to why Sun Microsystems opted to go for
> optional, UnsupportedOperationException-based mutation methods rather
> than mutable sub-interfaces.
>
> approaches?
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2452
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
To expand a little bit on what @kevinb9n said, the reason that common.graph isn't particularly facing interface overload is that we've basically made the decision that just about everything type-wise will be handled by runtime checks.  This is because trying to capture the following options:
- graphs {do, do not} allow parallel edges (graphs that have || edges are normally called "multigraphs")
- graphs {do, do not} allow self-loops (graphs that have self-loops or || edges are called "pseudographs")
- graphs have {directed, undirected} edges
and so on; this is only a partial tally of properties.  Using compile-time types for each of these combinations would have been a disaster.
The decision to make `MutableGraph` a subinterface of `Graph` came pretty late in our design process.  We'd considered it a while back, but at the time we decided that we should probably stay consistent with the JCF convention for collections/maps, in part because at the time more of our type system manifested in separate interfaces (e.g. directed vs. undirected).
In this particular case, creating separate `Mutable*` interfaces also resolved a design issue that we had with `Graph` vs. `Network`: `Graph` is a natural supertype of `Network`, but `addEdge(n1, n2)` simply doesn't make sense for `Network`.
I personally prefer designs in which we don't have to worry about throwing `UnsupportedOperationException` because the methods simply don't exist where they don't make sense.  And I think that it's beneficial to have a visible signal that something _can_ be modified.
I think those are both good points.
On Thu, Apr 14, 2016 at 12:08 PM, Jonathan Bluett-Duncan <
notifications@github.com> wrote:
> Hi @kevinb9n https://github.com/kevinb9n and @jrtom
> https://github.com/jrtom, thank you both for your explanations. I can
> see that things aren't as clear-cut as I first imagined.
>
> On a side note, if you ultimately decide that having MutableGraph as a
> sub-interface is the right thing to do, I wonder if it'd be worth adding a
> note to Graph that if one is using Graph directly, they shouldn't assume
> the impl is immutable (even if the interface has no mutation methods), due
> to MutableGraph being a sub-type. (It certainly wasn't obvious to me at
> first that Graphs could be anything but immutable.)
>
> I also wonder it'd be worth recommending the use of MutableGraph/
> ImmutableGraph over Graph to avoid this sort of confusion. I imagine this
> would be similar to how List and Set are encouraged over Collection (or
> (List|Set)Multimap over plain Multimap for that matter).
>
> 
> You are receiving this because you were mentioned.
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2452#issuecomment-210103637
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
I believe that the current Javadoc for the graph types addresses the above request:
https://google.github.io/guava/releases/23.0/api/docs/com/google/common/graph/Graph.html
If further clarification is desired, please reopen this issue.  Thanks - as it happens, I do have this on the list, and I think chances are good.
I wonder if this is something that can be worked around by adding the dep that includes `CheckReturnValue`:
```
<dependency>
<groupId>com.google.code.findbugs</groupId>
<version>1.3.9</version>
</dependency>
```
Guava's dependency on `jsr305` is marked `optional`, so it makes sense that the `.class` file would be missing. The weird part is that `javac` cares. My understanding is that `javac` shouldn't error out for mere missing annotations. But I can't find this specified anywhere, and I even found a [bug report](https://bugs.openjdk.java.net/browse/JDK-6331821) that suggests more or less the opposite.
My first suspicion would be that an annotation processor or other compiler plugin is causing the problem -- [e.g., Lombok](https://github.com/rzwitserloot/lombok/issues/425). Do you know if you're using any?
For cases where a common type is necessary, we recommend the `Consumer` in Java 8. This won't help Android users or those stuck on older versions of Java, but given that we can usually get by without a common type, anyway, we don't see the need to supply one.
It sounds like this would have the side effect of breaking source compatibility with Java 7 users of these methods?
`unmodifiableMultimap` has some questionable behavior that makes this unsafe, albeit in unlikely situations. The `Multimap` it returns has a "smart" `get` method that will return you `SortedSet` if the delegate collection is a `SortedSet`. This gives you access to `comparator()`. As a result, if we let you turn a `Multimap<K, Integer>` into a `Multimap<K, Number>`, we also let you turn a `Comparator<Integer>` into a `Comparator<Number>`, and it might not work on arbitrary `Number` types.
Again, the questionable behavior lies in `unmodifiableMultimap`. If not for that, I _think_ that this proposal would be safe. But as things are, it's not safe -- again, albeit only in unlikely situations. But given that the workaround, if you're willing to do unchecked conversions, is an unchecked cast, I don't think it's worth trying to change `unmodifiableMultimap` (which might break some users who depend on its "smart" `get` return types).
Oddly enough, I think it's the _keys_ that we can safely be covariant in: `keySet` and `keys` omit the problematic special casing for `Sorted*`.
<strike>Ha, actually, fun fact: The key methods _used_ to have the special casing, too -- implicitly, because `transformValues` used to check `instanceof SortedMap`. But we removed that for unrelated reasons: 2d97fd8466f9bf00c7a90d1795b3ce0b891c030c That's arguably a bit of evidence that we could safely change the behavior of `unmodifiableMultimap(...).get(...)`.</strike> Wait, no: I'm not sure why I think `transformValues` is involved in `keys` or `keySet`. At most, it's involved in `asMap`, but there, we're wrapping the result of `transformValues` in an `unmodifiableMap`, so it ends up as a plain `Map` with no access to the key comparator.
Values is another story: That's where `get(...).comparator()` (and, I now see, `valueComparator()`) are available.
The reason that we're backward from `SortedMap` is that we offer `valueComparator()` but `SortedMap` offers [key]`Comparator`. It would make some sense for us to offer `keyComparator()`, too, but we were wary of the combinatorial explosion of `Multimap` types.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
Bulk closing all pull requests that are listed as needing CLA signing. If you'd like us to look at your pull request, you'll need to sign the CLA and report back here.
If this is a false positive, I apologize. Please reopen the pull request, and we'll have a look.  I'm not sure we'd want to commit to the current implementation.  Can you use values().asList() or ImmutableList.copyOf(values()), either of which would return what you want in O(1)?
From a glance, TreeMultimap is just delegating to TreeSet.add, so I'd expect `TreeMultimap` to just be getting whatever `TreeSet`'s behavior is.
> currently there's no official way (in JDK 8) for converting between `java.util.concurrent.TimeUnit` and `ChronoUnit` (there will be in [JDK 9](https://bugs.openjdk.java.net/browse/JDK-8141452), though).
So we should consider providing one. Maybe it's time to start selectively open sourcing our `com.google.common.time` package?
We just made the transition to Java 8 internally last week, and we plan on releasing a Guava 21 (with Java8 support) sometime next quarter.
I have a pending CL with this...I'll try to prioritize getting it API reviewed and released. Thanks for the bump.
The reason we've been on the fence about adding this is that it already exists in [`threeten-extra`](www.threeten.org/threeten-extra/) as:
* [`Temporals.chronoUnit(TimeUnit)`](http://www.threeten.org/threeten-extra/apidocs/org/threeten/extra/Temporals.html#chronoUnit-java.util.concurrent.TimeUnit-)
* [`Temporals.timeUnit(ChronoUnit)`](http://www.threeten.org/threeten-extra/apidocs/org/threeten/extra/Temporals.html#timeUnit-java.time.temporal.ChronoUnit-)
And we're hesitant to add competing solutions when a reasonable solution already exists. We've decided not to compete with threeten-extra.  What the cache does is LRU, but on a per-segment basis: the cache is divided into concurrencyLevel segments, each of which does LRU internally with a size cap of maximumSize/concurrencyLevel.
It's probably worth adding this clarification to the javadocs.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
We ended up attempting what I think is this with a fallback:
https://github.com/google/guava/commit/896c51abd32e136621c13d56b6130d0a72f4957a
We added some tests to create actual jars to test against. If you know of cases that still fail, let us know.  If someone submits two `FutureTask` instances and calls `cancel(true)` on the first, that interrupt will propagate from the first task to the second. Perhaps worse, it will propagate _only if_ the second task is submitted before the first is done.
Possibly we should do something about this. If so, the right thing to do might be to check for interruption each iteration. If the thread was interrupted, then exit from the current `QueueWorker.run`, calling `startQueueWorker` to queue up another. In the scenario described above, this will start a new, un-interrupted worker. In the other possible scenario, that of a `shutdownNow` call on the delegate executor, the `execute` call will fail (and hopefully the exception will at least be dumped to standard error). That's probably a defensible thing to do, since it's similar to what would have happened to other un-executed tasks (except that those would be returned from `shutdownNow`... though in practice, I think almost no one looks at those, anyway).
But... I think there's a good case to be made that submitting a `FutureTask` and calling `cancel(true)` on it is a bogus thing to do: [We shouldn't be interrupting threads that we don't own.](https://github.com/google/guava/issues/1989#issuecomment-199262664) So maybe there's nothing that `SerializingExecutor` needs to do here.
I do think we can at least make a case that `SerializingExecutor` takes ownership of the underlying executor's threads. But I think that only _partially_ lets us wriggle out of this one: If `SerializingExecutor` is the thread owner, and if we can assume that the underlying executor implements cancellation "normally," then yes, we can reasonably allow it to clear the interrupt. But we still can't reasonably allow some _user_ of `SerializingExecutor` to interrupt the thread. Well, I guess we could, assuming that we document all the caveats. It would be a little hacky, but it would probably work.
Alternatively, we could do is make `SerializingExecutor` an `ListeningExecutorService` and then enable `submit()` so that users can get a `Future` back that they can then `cancel(true)`. Then `SerializingExecutor` is still in control of the interruption.
This is another case in which I'm not yet sure what we want to do :(
@vharuty , if you want a medium-sized project, I suggest https://github.com/google/guava/issues/1190#issuecomment-61350932
The specific comment that I've linked to is about reimplementing `Splitter.onPattern` to follow the ECMAScript contract. I can't guarantee that we would take the result, but I would love to have the implementation to test against our codebase to see if it's practical to use.
Right, you'd be changing `Splitter.onPattern`. You might need to change other code, too.
I can look at the code change you made, sure. You can post directly on #1190.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
Also FWIW, `Ticker` used to be an `interface` and I intentionally [changed](https://github.com/google/guava/commit/c87142e306811f7ac9094d43de45dca4339a2898) it to an `abstract class` back in 2011.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
Thanks. I'm asking around to find out whether `NumberFormat` is going to pull in undesired internationalization data (currency formats, mainly). I'll report back here.
The feedback I got:
- `NumberFormat` may pull in code that apps don't want.
But I also heard an alternative approach that uses JsInterop. I'm trying that now.
I asked a similar question internally a couple weeks ago...I've copied out the relevant parts of that discussion:
me: Should Cache.invalidate(Object) return the cached value (if present)?
@lowasser : Note that if you want this behavior, Cache.asMap().remove(key) will do this
@cgdecker : I think it just doesn't make much sense in general to get the value back from a Cache when you want to invalidate it... the reason you want to invalidate it is presumably because the cached object is no longer current and you want a new version. Also, Cache is out of @Beta as of 19.0 so I do think it's probably not something we can change regardless.
fry: For the record it was (as everything else in Cache) an explicit design decision. @kevinb9n might remember better than I, but the elements I recall were that we were semantically trying to model something which could be thought of as a Cache instead of a Map, and in such a model invalidate simply had no need to return anything, even though it was possible.
I'd tend to expect this sort of problem to be best solved with Java 8 type annotations, and passing a variable around as a `@Sensitive String` rather than a `Sensitive<String>`?
The spec is not super clear here.
"If data for a URI component would conflict with a reserved character's purpose as a delimiter" means more than "If the character is ever a delimiter." There has to be potential for a conflict -- as in your hostname example.
- https://url.spec.whatwg.org/#syntax-url-path-segment
- https://url.spec.whatwg.org/#url-units
- https://url.spec.whatwg.org/#url-code-points
The old RFC 3986 (which I should stop linking to in the Javadoc -- will fix) agrees here:
```
segment-nz-nc = 1*( unreserved / pct-encoded / sub-delims / "@" )
```
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
You've changed the code to make the `Iterator` serializable, but your description suggests that you want `resultList` to be serializable. Which one are you interested in?
Making the Iterator serializable shouldn't affect the actual `List` at all, and even so it's really not clear to me that single-use stateful objects like Iterators should ever be serialized.
The root issue seems to be that your `Function` isn't serializable.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
For `X-Forwarded-Port`, I found http://httpd.apache.org/docs/2.2/mod/mod_proxy.html#x-headers
For `X-Forwarded-Host`, I found https://en.wikipedia.org/wiki/X-Forwarded-For
Do you know of any better (more official) links we could use? (BTW, your AWS link doesn't go anywhere - did you have a good reference for that?)
Thanks - this should be mirrored out shortly.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
Hello,
We'll consider this feature request. Thank you.
On Wed, Mar 16, 2016 at 4:29 AM, Enes Gnday <notifications@github.com>
wrote:
> *public static int lcm(int a, int b)*
>
> /*
> Returns least common multiple of two numbers. Uses gcd method of this library.
> */
>
> ------------------------------
> You can view, comment on, or merge this pull request online at:
>
>   https://github.com/google/guava/pull/2427
> Commit Summary
>
>    - Update IntMath.java
>    - Update IntMath.java
>
> File Changes
>
>    <https://github.com/google/guava/pull/2427/files#diff-0> (7)
>
>
>    - https://github.com/google/guava/pull/2427.patch
>    - https://github.com/google/guava/pull/2427.diff
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly or view it on GitHub
> <https://github.com/google/guava/pull/2427>
>
--
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
We added an isPrime implementation.
:)
Fixed, thanks: https://github.com/google/guava/wiki/CollectionUtilitiesExplained#lists
This reminds me that I should sync out the changes I made to these files when bringing them into our internal repository... I cleaned up the markdown when doing that, which should have fixed issues like this. Unfortunately I changed the filenames and changed wiki links to normal markdown links which means it's not just a matter of copying the files back out. So I'll probably just wait until I'm ready to move this content to the Github Pages site.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
I agree with @TeknoCepni - I don't see why this method is useful. If you're passing var-args, then you might as well just use `new byte[] {a, b, c}`.
If there's an issue you're having, please describe it.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
`CharMatcher` doesn't implement `equals` (or `hashCode`), so the only way 2 instances will be equal is if they are the same constants.
Is there a reason you need or want `CharMatcher` to define equality? It would be nearly impossible to normalize CharMatcher instances. For example, should these instances be `equal`?
```
CharMatcher.inRange('a', 'b').and(CharMatcher.isNot('b'))
```
There is no logic to collapse or normalize CharMatchers other than simple cases like negation.
The two functionally equivalent CharMatchers from my example above will have very different `toString()` representations:
```
CharMatcher.is('\u0061')
CharMatcher.and(CharMatcher.inRange('\u0061', '\u0062'), CharMatcher.isNot('\u0062'))
```
You still never explained why you want functionally equivalent CharMatchers to be equal. What is your use case?
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
The way I look at it is that it changes every paragraph in the documentation. Since you're adding a new method, not changing behavior, that's in some sense OK. But I think the change is too large even for an overload, and I think the operation is too niche to justify adding a separate name for.
"Returns the maximal range... _unless_..."
"The intersection exists if and only if... _unless_..."
"The intersection operation is commutative, associative and idempotent... _unless_..."  Duplicate of #738
Agreed. Thanks for the report. I will take care of this.
I briefly wondered if maybe we should have a separate `MapFeature.NON_STANDARD_TOSTRING`. But if anything, we should probably try to eliminate the cases in which we duplicate a property between `MapFeature` and `CollectionFeature` (internal bug 6238930).
For starters, we could see what's involved in eliminating our own usages of it.
`ForwardingFuture` also defeats our `AbstractFuture`-specific optimizations.
Thanks!
Thanks - we've had an open feature request for this internally (8912151) as well. I'm copying over some of my notes:
An idea we could investigate would be automatically pre or post pending the size of the data they just added. I proposed we add a method onto `HashFunction` called `newDelimitingHasher()` or something which returns a decorated `Hasher`:
```
Hashing.md5().newDelimitingHasher()
.putInt(getId())
.hash();
```
This wouldn't duplicate any methods in `Hashing`.
It would have to be an opt-in option, not the default.
Can you give some more details about how modeling this action sequence with
a graph helps you?  What graph utilities would you use with this data
structure?
On Sat, Mar 5, 2016, 2:26 PM Jonathan Bluett-Duncan <
notifications@github.com> wrote:
> http://mathworld.wolfram.com/Tree.html data structure, which would be
> similar to a DirectedGraph but which has a single root, disallows cycles
> and self-looping edges, and is fully connected.
>
> My use case for such a feature would be to model a sequence of actions,
> which may branch depending on some criteria.
>
> I'm aware that such a data structure already exists in JUNG 2 (and this is
> probably the solution I'll use in the meantime), but I believe it would be
> something that users of the com.google.common.graph package, in a future
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2411.
Even better - can you show us a sample of what your code would look like if
you were using the API you have in mind?
On Sat, Mar 5, 2016, 2:28 PM Louis Wasserman wasserman.louis@gmail.com
wrote:
> Can you give some more details about how modeling this action sequence
> with a graph helps you?  What graph utilities would you use with this data
> structure?
>
> On Sat, Mar 5, 2016, 2:26 PM Jonathan Bluett-Duncan <
> notifications@github.com> wrote:
>
> > http://mathworld.wolfram.com/Tree.html data structure, which would be
> > similar to a DirectedGraph but which has a single root, disallows cycles
> > and self-looping edges, and is fully connected.
> >
> > My use case for such a feature would be to model a sequence of actions,
> > which may branch depending on some criteria.
> >
> > I'm aware that such a data structure already exists in JUNG 2 (and this
> > is probably the solution I'll use in the meantime), but I believe it would
> > be something that users of the com.google.common.graph package, in a
> >
> > 
> > Reply to this email directly or view it on GitHub
> > https://github.com/google/guava/issues/2411.
I _think_ @jrtom has some plans around this, but he can clarify...
Yes, I do have plans to support tree topologies in common.graph.  Right now it's an open question whether it would be represented as its own type, or as a specialized implementation class, or solely in terms of constraints that will be specified as part of the graph's GraphConfig.  (We're trying to keep the type system from exploding, but there are certain capabilities, like asking for the root node, that wouldn't make sense to have on the Graph interface but that seem useful for trees.)
Since you bring up JUNG, which I also own: FYI, in parallel with the common.graph work, I'm in the process of releasing JUNG 2.1 (it's on GitHub already as http://github.com/jrtom/jung), which replaces commons-collections with Guava.  I plan to release JUNG 3.0 in a few months with the core graph API replaced with that of common.graph.
First, I'm not actually sure that using a graph (or tree) would actually help you much here.  It doesn't sound like you're using, or interested in, much (if any) of the topological properties of the graph.
(I am speaking as someone who likes using graph models for _everything_.  ;) )
Second, you can already use common.graph to build your trees; we just don't (yet) have built-in support for guaranteeing that the Graph you build is actually tree-shaped.  When we do, it would most likely be in the form of throwing run-time exceptions if you tried to populate your graph in such a way that it's not tree-shaped.
Third, I consider it extremely unlikely that we'd provide a toString() representation for trees that looked anything like that.  The current toString() representation tells you how things are connected, but it's not meant to be visual, and that wouldn't change for trees or other topologies.  For that part, you're on your own.  :)
That was pretty much the direction I was going in -- I was going to argue for rolling a very simple tree type of your own, pretty much just `class Tree { private Foo data; private List<Tree> children; }`.  Guava does have some limited facilities for working with this sort of tree in `TreeTraverser`.
Yes, some sources refer to trees more or less as you do (although "connected" is part of the definition), and refer to a directed graph with similar topological properties as an arborescence.
However, it seems pretty clear that what many people mean by "tree" is what you might call a "directed rooted tree", i.e., they think of a tree as a directed (weakly) connected acyclic graph in which all edges are both directed away from [1], and reachable from, the root.  E.g., "(rooted) binary tree".  In such cases people often refer to nodes of such a structure as being "leaves" or having "children", which implies directionality.
We'll certainly give careful thought to what terminology we use when we add capabilities like this, but ultimately we may have to use terms for which there is no strong consensus definition; that's just the way graph theory is in my experience.
[1] A term I've heard for such a graph in which edges are directed _towards_ the root is "uptree".
Thanks for poking us on that -- I'm going to review what things are overdue
wrote:
> At work we use a lot the Verify utility class to make postconditions
> checks, it's a simple and effective way to do such checks. Nevertheless,
> https://github.com/google/guava/wiki/PhilosophyExplained#beta-apis and
> would like to ask for @Beta https://github.com/Beta removal from
> Verify, taking into account that the usage of Verify in our codebase has
> grown. Would it be possible? Thanks for your attention.
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2409.
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
It also came up in #91, but we closed that once we added `immutableEnumMap`, and AFAICT no one ever opened a new issue about exhaustiveness checking. So I guess this issue takes care of that :)
It's something that we should probably do someday.
Yeah, designing the API is the tricky part :) That design probably won't be a priority in the near future, but maybe someone else on the team will surprise me and pick it up.
For what it's worth, here's what I had in mind:
- don't make ImmutableEnumMap public; it's more an implementation difference than a semantic difference
- expose it through the builder: something like
ImmutableMap.enumBuilder(MyEnum.class)
with possibly an "exhaustive" modifier, maybe ImmutableMap.exhaustiveEnumBuilder or ImmutableMap.enumBuilder().exhaustive().
I'm not sure I follow.
ImmutableMap is supposed to correspond to the Map interface; ImmutableSortedMap is supposed to correspond to the SortedMap interface.  EnumMap is just another implementation of Map, just as HashMap is; it just happens to be more efficient for its specific use case.
Of course ImmutableMap diverges from Map, and EnumMap diverges from Map in some ways, but the only way I see that ImmutableEnumMap would diverge from ImmutableMap is the iteration order?
As far as I can tell, our suites don't exercise this. I noticed because a non-Guava user of our collection testers fails the forthcoming Java 8 `replaceAll()` tests, and that's precisely because it doesn't support `setValue()`.
@lowasser might know our plans for the Java 8 branch generally and testlib specifically.
We haven't focused much on getting our Java 8 branch set up to work with open source correctly -- I'm not certain what issues would be involved in getting MOE to work correctly there -- but we might be able to dump something over the wall in the short term.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
Forbidding the empty `Range` was an intentional choice that has been baked pretty deeply into the class's model at this point, so we won't be changing it. Users who require it may be able to get by with using `RangeSet` objects (which can be empty), using `Optional<Range>`, or rolling their own.
- Your example gives fixed lengths for the first and last names, the street address, etc., but in reality those don't usually have fixed lengths.
- Any API we could write would presumably have to take those lengths one at a time, but that doesn't buy you nearly as much over just doing one `substring` at a time by hand.
- `Splitter` returns an undifferentiated `Iterable<String>`, but if you have several different fixed lengths, then it seems more like you don't want an `Iterable<String>`, you want to read out one field at a time into some other data structure.
You can probably do something like this:
```
Copyright 2016 Google Inc.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
...
int start = 0;
String first = input.substring(start, start += 4);
String last = input.substring(start, start += 3);
String address = input.substring(start, start += 18);
```
If you need something other than that, I suggest [asking on StackOverflow](https://stackoverflow.com/questions/ask?tags=guava+java).
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
As @pivovarit notes, we want to work on older versions of Java. And while we will be [requiring Java 8 soon (except on Android)](https://groups.google.com/d/topic/guava-discuss/ZRmDJnAq9T0/discussion), we would prefer to minimize differences in behavior between the Java 8 and Android versions.
Thanks - this will be mirrored out shortly!
I just noticed that we use it in `TrieParser` -- particularly egregious because IIRC that code exists largely to help on GWT, where I would assume `LinkedList` is even more terrible.
- in tests (which we might as well also fix)
- in GWT `*TreeTraverser` (and I forget what the situation is with GWT... we could probably roll our own `ArrayDeque` there, but probably we shouldn't bother)
For a time, Java 5 / Froyo compatibility kept us from using `ArrayDeque`. But now we can use it, and we should. (But we probably should never have used `LinkedList`, anyway. For example, `TrieParser` could probably use `ArrayList` if it were written to modify the end of the list instead of the beginning.)
Oh, obviously `TrieParser` has the same GWT problem with using `ArrayDeque` as `*TreeTraverser` does. And it does look like `ArrayDeque` is unavailable there.
We could still use `ArrayList`, but I note that `TrieParser` calls `join(stack)`, so we'd need to use `Lists.reverse` to view it in the proper order. That's possibly still worth doing, but maybe we should just do the `ArrayDeque` emulation....
Alternatively, we could operate on the end of the list as I suggested above but then reverse the result when we're done. That might be better than what we do now, which is to operate on the beginning of the list and reverse every individual chunk in place.
I have a working CL, but I feel bad about it, partially because I can see a way to do even better and partially because I have no idea if I'm addressing a real bottleneck here. I'll abandon it for now.
We took a lot of these out, but we have some left.
Note that it's probably not worth much effort to mess with `TreeTraverser` because that's hopefully going to be deprecated in the next release in favor of the new `common.graph`-based `Traverser`.  It is not at all clear how or even if this is related to Guava.  Can you provide more details?
This is definitely working as intended -- `transformValues` does no storage of its own; it you pass it the function you've passed it here, you'll get a new `AtomicInteger` every time.
The doc isn't quite as explicit about this as it could be, but it's the only implementation that would satisfy the spec.  Particularly relevant is the last paragraph:
>  The function is applied lazily, invoked when needed. This is necessary for the returned map to be a view, but it means that the function will be applied many times for bulk operations like Map.containsValue(java.lang.Object) and Map.toString(). For this to perform well, function should be fast. To avoid lazy evaluation when the returned map doesn't need to be a view, copy the returned map into a new map of your choosing.
@cpovirk Any chance you could take a look at this one?
`RateLimiter` needs a serious redesign :( Maybe someday, but I don't think I even know where to start at the moment, sorry.
As noted on #2384, we decided to move away from this approach a while back.
We used to have the code like this, but we ultimately felt it wasn't worth the extra allocations. I do wish that we had another way to reduce duplication.
Right, an allocation per method. It's not clear how big the cost is, but `getUninterruptibly` specifically is used through our `Futures` methods, which are heavily used, including in our Android apps, where allocation costs more. The right way to determine the costs of allocation (or reflection, which is unfortunately probably worse on Android) is probably a full benchmark of such an app, which of course I can't exactly ask you to produce :(
I understand the appeal of the generic API. It's a big part of the reason that we originally did the code that way, too. But we had it for years, and no on used it. I'm sure that a handful of people could have, but that's a lower bar than we like to have for our APIs.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
Sorry for the delay on this. Now that `UninterruptiblesTest` is released, can you add some tests for your new methods, patterned off the existing tests? Then I'll take a look.
A recent concurrency-interest thread suggests that we should override `removeIf` in our Java 8 branch:
- http://cs.oswego.edu/pipermail/concurrency-interest/2016-February/014900.html
- http://stackoverflow.com/q/29876083/28465
- http://stackoverflow.com/q/3768554/28465
- http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8078645
Does that sound like something we should do?
Implementations that might need an update:
```
$ extends java.util.concurrent.ConcurrentMap | grep com.google.common
java:com.google.common.cache.LocalCache
java:com.google.common.collect.ComputingConcurrentHashMap
java:com.google.common.collect.ComputingConcurrentHashMap.ComputingSerializationProxy
java:com.google.common.collect.ForwardingConcurrentMap
java:com.google.common.collect.ForwardingConcurrentMapTest.TestMap
java:com.google.common.collect.MapMaker.ComputingMapAdapter
java:com.google.common.collect.MapMakerInternalMap
java:com.google.common.collect.MapMakerInternalMap.AbstractSerializationProxy
java:com.google.common.collect.MapMakerInternalMap.SerializationProxy
java:com.google.common.collect.MapMaker.NullComputingConcurrentMap
java:com.google.common.collect.MapMaker.NullConcurrentMap
java:com.google.common.labs.concurrent.ConcurrentEnumMap
```
@lowasser , is this something we should try to do for Java 8?
@ben-manes I see this in the `ConcurrentMap.replaceAll` Javadoc:
```
The default implementation is equivalent to, for this map:
for ((Map.Entry<K, V> entry : map.entrySet())
K k = entry.getKey();
V v = entry.getValue();
} while(!replace(k, v, function.apply(k, v)));
```
https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html#replaceAll-java.util.function.BiFunction-
Apparently added here: http://hg.openjdk.java.net/jdk8/jdk8/jdk/rev/1f7cbe4829fe#l8.1
So maybe we no longer need to worry about `replaceAll`, only `removeIf`?
Fixed internally. Will show up when we release our Java 8 version of Guava.
Do you have an immediate use for this (compatibility reasons)? We tend not to add features just to add features.
(I did search internally in google's codebase, and found very few usages of base85 encoding in Java.)
Thanks. I suspect no other libraries offer it because, most likely, for 99.9% of purposes base 64 is perfectly fine. If there are very compelling reasons for ascii85 then those should be argued. But we really don't compare ourselves to Apache.
Yuck. Thanks for the report.
I'm wondering if `closure-compiler` is somehow getting two separate versions of Guava. (After all, I don't think that 1ef638f _removed_ anything.) I see a reference to 19.0 [here](https://github.com/google/closure-compiler/blob/7278fff6e7f76c9a789245ae5fed4c2ecac00731/pom-main.xml#L73). Can that be changed to 20.0-SNAPSHOT to match `pom-gwt.xml`?
This should be reported to closure-compiler; they have a classpath issue.
On Tue, Feb 2, 2016 at 9:03 AM, Michael Zhou notifications@github.com
wrote:
> I'm getting many
> java.lang.NoSuchMethodError:
> com.google.common.base.Preconditions.checkState(ZLjava/lang/String;I)V
>
> exceptions with 20.0-SNAPSHOT
>
> To reproduce:
> 1. Checkout google/closure-compiler@583b50c
> https://github.com/google/closure-compiler/commit/583b50ce47215846ef8e81025ac27e8fc1cac448
> 2. Run "mvn test"
> 3. Will see errors like:
> java.lang.NoSuchMethodError:
> com.google.common.base.Preconditions.checkState(ZLjava/lang/String;I)V
>
> https://github.com/google/guava/commit/1ef638f369964c1d1f56bd0ae588535c6abd99a4
> might have something to do with this?
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2380.
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
(Hadn't seen Chris's reply yet, but looks like my suspicion may have been
right on the money :-))
On Tue, Feb 2, 2016 at 9:25 AM, Chris Povirk notifications@github.com
wrote:
> Yuck. Thanks for the report.
>
> I'm wondering if closure-compiler is somehow getting two separate
> https://github.com/google/guava/commit/1ef638f369964c1d1f56bd0ae588535c6abd99a4
> _removed_ anything.) I see a reference to 19.0 here
> https://github.com/google/closure-compiler/blob/7278fff6e7f76c9a789245ae5fed4c2ecac00731/pom-main.xml#L73.
> Can that be changed to 20.0-SNAPSHOT to match pom-gwt.xml?
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2380#issuecomment-178699974.
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
I'm not sure why we ended up with our own implementation instead of this one, but we ended up adding one in https://github.com/google/guava/commit/e3f9ba6a707b03559910bceffb74244ac9a8db13  On an internal thread, @kevinb9n said:
"I regret the error. By this point, though... no telling how many things we'd break by changing it."
I'm moderately in favor of making this change, so I'm testing the change against google's internal codebase, and will see how much stuff it breaks.
We didn't make the toString() contract explicit, so technically we can change it, but it still may break stuff (imagine if Oracle decided to change the toString() of List...it would definitely break stuff, even though there's no explicit contract).
> - {@link Range#toString()} prints a unicode character of \u2025 (two dot leader) between the lower
> - and upper bound. Neither terminal nor [our internal test tool] prints this character correctly. This is a
> - workaround.
@kluever etc. can do that search themselves, but some examples include `range.toString().replace("\u2025", " to ")`, and even worse,
```
// string gets passed around, I think through an RPC?
String[] range = string.split("\u2025|\\[|\\]");
return Range.closed(Long.parseLong(range[1]), Long.parseLong(range[2]));
```
Mutable global variables are an antipattern the team feels very strongly about avoiding under any circumstances.  We'd definitely prefer the status quo to introducing static state.
As far as parsing goes, that's sort of addressed in #1911 , but generally speaking, there's no general "parsable" interface in Java (nor is such a thing even possible in Java, really?), so we couldn't really support that for Range, since we'd have to also know how to parse the element type.
Internal CL with the change (and cleanups) is 113872392.
Summary:
1 user who is purposefully changing `\u2025` to `", "`
1 user who is purposefully changing `\u2025` to `" to "`
1 user who is calling `String.split("\u2025|\\[|\\]")`, and then doing parsing of the values
15 users who have (somewhat) brittle tests that are expecting exactly `\u2025` in a failure or log message
OK, we discussed this at our internal API review, and decided to go ahead with the change to ".." (that is, dot-dot, not the "two dot leader" character).
We may look slightly silly when we have to put this in the release notes for the next Guava release, and we may break some users tests, but hopefully that's the worst of it.
I'm submitting the change internally and it should be mirrored out shortly.
At some point (I have a plan but just haven't found time to actually finish doing it) I want to add a builder for `EventBus` since constructors are bad for optional parameters like this.
Definitely a misunderstanding; this is expected behavior.  `Range`, by itself, knows nothing about the type except that it is `Comparable`; it certainly can't do `upper-1` for non-integer types.  This is definitely working as intended.
Depending on what behavior you want, `Range.atLeast(0)` might be what you want?
> How would I check whether some value is included in [min, max) if max can't be equal to Integer.MAX_INTEGER?
Do you mean `x >= min && x < max`?
The `Range` API is intended to work simply and correctly for arbitrary `Comparable`s.  `Range.closedOpen(a, b)` contains exactly those elements `x` for which `x.compareTo(a) >= 0 && x.compareTo(b) < 0`.  That avoids off-by-one shenanigans and keeps everything clean and simple.
If your API takes an inclusive `min` and an exclusive `max`, then it sounds like it can't include `Integer.MAX_VALUE` as a valid element inside the range.
If it helps, think of it as working exactly like normal mathematics.  If we're just talking about arbitrary integers mathematically, [0, -2147483648) makes no sense.  [0, infinity) makes sense; [0, 2147483647] makes sense.  Guava's just staying consistent with that.
I'm not sure there's anything we _could_ do to support what you're going for; again, `Range.closedOpen` accepts `Comparable` arguments, not `Integer`s specifically, so we can't do any arithmetic with them.
> Does it really makes sense for Range to enforce a > b if it doesn't have the ability to translate b from open to closed? Wouldn't it better to leave out this check and let the user assert it outside the API?
If `a < b`, then by the contract for `Comparable`, nothing can be `>= a` and `< b`.  The ability to translate between open and closed is handled optionally with e.g. `Range.canonical` for those types that support it with `DiscreteDomain`, but not for all ranges generally.
> Update (having read your last post): Is there a way to represent [0, infinity] as you mentioned using Range for Integers? If so, how?
Yes.  `Range.atLeast(0)` will do that.
> Is it reasonable to use this as a workaround? Range.closed(min, max-1) If so, perhaps it makes sense to mention this in the Javadoc? Example: "Please note that closedOpen() cannot contain the maximum value of the underlying type. Consider using closed(min, max-1) for such cases instead of closedOpen(min, max)."
That doesn't make sense for many or even most types used with `Range`, which don't necessarily have addition or even a maximum value.  The docs for `closedOpen` say
> Returns a range that contains all values greater than or equal to lower and strictly less than upper.
which seems relatively unambiguous.
Thanks! Fixed.
~6% of callers of our old `Futures.combine` either pass a `Callable<Void>`, ignore the result of `combine`, or both. Some of these might need to use `Callable` because they throw checked exceptions, but others would probably prefer not to write the extra boilerplate (mostly `return null` but also `<Void>`).
We could help them out by providing `run(Runnable)` alongside `call(Callable)`. We could still return `ListenableFuture<?>` for users who need to check for errors or await the result.
6% is a small percentage, but the API is also very low cost (easy to understand and "hidden" in the `FutureCombiner` type). It would also match the overloads of [`ExecutorService.submit`](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html#submit%28java.lang.Runnable%29).
We may well add it someday. It's just a matter of our finding the time to run it through our internal API-review process. Unfortunately it's an internal-only process. But this addition *should* be straightforward enough, so I'll try to take care of it when I have a spare moment.  If we were to implement this, then we'd almost certainly just throw on
On Wed, Jan 27, 2016 at 7:37 AM Piotr Chromiec notifications@github.com
wrote:
> but your code returns 0 for 0 and all negative integers, and should return
> 1
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2370#issuecomment-175692420.
We're not going to be able to look into this, but if anyone knows how to solve it and has a patch we'll certainly take a look.
There's definitely nothing we can do about this until we actually support Java 8; the default implementation of replaceAll is almost certainly not recoverable.
It's not immediately obvious to me that there's any good default implementation in the BiMap interface.  We can patch AbstractBiMap, but the only fully general implementation I can think of involves copying all the keys into a separate data structure, clearing the map, and then rebuilding the map from scratch.
As Louis says, we don't think this can be fixed except in the forthcoming Java 8 version of Guava (where it is already fixed).
Our implementation is still based on a single long[], so it can still only handle ~64*(MAX_VALUE-4) bits ... we need to make this clearer in the docs at the very least.
Not a high priority. I just feel a little bad that users there would get something like "com.google.common.base.Stopwatch@0xdeadbeef".
First, sorry: It looks like `ContributorSetUp` is out of date. I've filed https://github.com/google/guava/issues/2405 for us to update it. For now, just ignore them. The files you're interested in don't exist anymore.
Second, as a general rule, we try not to maintain parallel copies of our classes for GWT and server. [Sometimes](https://github.com/google/guava/tree/master/guava-gwt/src-super/com/google/common) we have to, but usually we just hide the platform-specific code behind a method in the an aptly named `Platform` class. You would create something like `Platform.stopwatchToString(Stopwatch)` with separate implementations in the [server](https://github.com/google/guava/blob/master/guava/src/com/google/common/base/Platform.java) and [GWT](https://github.com/google/guava/blob/master/guava-gwt/src-super/com/google/common/base/super/com/google/common/base/Platform.java) copies.
Alternatively, you could look for a way to implement `Stopwatch.toString` itself in a GWT-compatible way, maybe with some multiplication and rounding. We _might_ even be to tolerate slightly changes in rounding in the output if it helps.
We believe addressing this would add a lot of complexity compared to very small payoff, but if anyone wants to make a specific proposal, please reopen.
You can already do this with RangeSet, by adding one Range, removing the other, and using asRanges.
Turns out this is a duplicate of #2096.
This is a duplicate of https://github.com/google/guava/issues/463.
`equals()` shouldn't be allowed to throw. The collection under test sounds faulty.
I have a CL for this internally as well (CL/102147951)...we had a question about L24 vs. l24, but I think we decided just to go with l24.
Submitted internally...it should be mirrored out shortly.
Sorry for the trouble. Various GWT changes have made it impossible for a single version of Guava to support both GWT 2.7 and GWT 2.8. We intend to release a new Guava that is compatible with GWT 2.8 once 2.8 is out: https://github.com/google/guava/issues/1999 You can follow that issue for updates.
(This is in the release notes but easy to miss: https://github.com/google/guava/wiki/Release19#gwt-notes)
There are some other issues. GWT is adding a `Charset` emulation that would conflict with ours, for instance.
The above fix compiles but doesn't actually return a `T[]`, only an `Object[]` that looks like one. The method is expected to return a `T[]`.
> Eviction doesn't work if the the key is assigned to a local variable:
Eviction isn't supposed to happen in this case: weakly referenced objects are only supposed to be garbage collected if there are no strong references to them remaining, and by assigning the key to a local variable, you create a strong reference to it.  The key is not supposed to be gc'd; this works as intended.
This is also working as intended.  Note the line from the `weakKeys` Javadoc:
> Warning: when this method is used, the resulting cache will use identity (==) comparison to determine equality of keys.
A re-boxed `double` will not be `==` to the earlier boxing, so `getIfPresent` is supposed to return null here.  Generally speaking, `weakKeys` does not make sense to use with objects that have a notion of equality other than reference equality.
It's not clear to me why you think `.weakKeys()` is a good idea for your use case.  All of this is based around how weak references work, at a fundamental level.  Guava doesn't even control when weak references are GC'd; that's implemented as part of the Java language.
As far as why Guava uses `==` reference equality for `weakKeys`: the use of `weakKeys` indicates that you care when the original key put into the cache has no other `==` references to that key anywhere in the JVM.  (Again, that's something built into the language.)  Based on that, the use of `weakKeys` is a pretty strong signal that reference equality is what matters to that use case, so `==` is the equivalence used to test for the presence of the key in the cache.
It is intended for the GC based caching, it's just that if you want to GC the cache entry as soon as there are no other `==` references -- which is how weak references work in Java -- then there's not much point in using `.equals`, as if you don't have another `==` reference, your cache entry will be GC'd before you can do anything with it.
Seems like something we should supply when we do Java 8 support.
Thanks.
As best I can tell, `order()` is called only from other `order()` implementations and from `AbstractContainerTester.getOrderedElements()`.
`getOrderedElements()` is called from:
- `expectUnchanged`
- `createOrderedArray`
The easy way out for us here is probably to say that `order` can return the elements in whatever order it wants if the container doesn't have `KNOWN_ORDER`. (This is in fact the "default" behavior of classes like `TestStringSetGenerator`, which we use for `HashSet` in `TestsForSetsInJavaUtil`/`OpenJdk6SetTests`.) This is a spec change, but given what you've shown here, I would expect it to be a positive change for everyone.
Sorry for the extremely slow responses to your bug reports here. I do appreciate the reports.
Duplicate of #897.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
That's an interesting issue, but I think I'm still -1 on this. Any thoughts @lowasser ?
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
So this is actually some deprecated code that we have internally, and is publicly accessible for our internal users (the method is deprecated).
To be clear, the code is used internally, and we mirror out our internal codebase by passing it through a stripping tool, which has more trouble stripping out this code than usual because of the way it's written.  Internally, we're _extremely_ aggressive about stripping out unused code -- much more aggressive than we can be externally -- but this happens to hit an edge case where we can't strip out something that we've eliminated externally.
If you use the interface type as the type (`ListMultimap` instead of `ArrayListMultimap`), this should work fine. Or if you use a lambda instead of a method reference, it should also work.
The added pain of adding NO-OP methods to all of our collection types is probably too much to work around this soon-to-be fixed issue.
We did consciously decide to go with Object-type parameters for the reason that you guessed (congruence with the JCL interfaces), but it may be worth revisiting in light of Valhalla.  We'll discuss it and get back to this issue when we've resolved it.  Thanks.
Migrating out some comments I made internally:
> The linked Valhalla thread has been very interesting. My impression, though, is that they still feel that Object is the right signature. For example:
>
> http://mail.openjdk.java.net/pipermail/valhalla-spec-experts/2015-December/000009.html
>
> Now, they're probably going to change methods like contains() somehow -- for example, to have contains(T) if T is a primitive -- but the old versions will remain, and they don't [seem] too sad about that. If there's anything they wish for, it seems to be more methods like getOrDefault.
>
> On the other hand:
> - As noted on the public issue, it may be easier to call containsEdge() when you mean containsNode() (or vice versa) than it is to make the analogous error with Map (or with Collection, where there's no such thing as an analogous error).
> - My impression [based on some internal research that I can't easily link here] has been that the need for Object is rarer than my link above suggests. And if you do need it -- mainly in implementing equals() -- you can always cast to `Graph<Object, Object>`.
jrtom's response to part of it:
> I assume you mean things like incidentEdges() vs. incidentNodes(), since containsEdge() isn't a thing (it would be edges().contains(), because we made an explicit decision to just let the Set interface do the talking except for the *degree() methods).
>
> I think that confusing edges for nodes is something that's a sufficiently broken mistake that I'm not too worried about it (although I do generally advise people to use different types for the two, just to make it easier to spot things like that).  If you ask for containsKey() when you meant containsValue(), or vice versa, you're gonna have a Bad Time (TM).
>
> I'll note that because we're tending to use Maps (or other Collections) under the hood of the Graph implementations, we probably wouldn't get a lot of mileage (if any) out of having the actual type present in the signature; we're just going to call Map.get() on the input(s) anyway, so until and unless the Map signature changes, I don't think it would change how we're doing anything internally.
I should also remind myself that methods like `adjacentNodes` throw an exception if given a node that isn't present. So we at least have checking at runtime (not as good as compile time, but something).
Also, if we stick with `Object`, we should extend Error Prone's checks to cover `Graph`.
Yeah, we ended up doing this, albeit motivated by the creation of [`SuccessorsFunction`](http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/graph/SuccessorsFunction.html) and [`PredecessorsFunction`](http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/graph/PredecessorsFunction.html), where the tighter type parameter makes it easier for users to write implementations.  Are you referring to the uniqueIndex overloads taking an Iterable in one
case and an Iterator in the other?  I couldn't follow your link.
On Mon, Dec 21, 2015, 11:11 PM honey.and.sw notifications@github.com
wrote:
> I'm watching here: MapsuniqueIndex
> http://googlegithubio/guava/releases/snapshot/api/docs/com/google/common/collect/Mapshtml#uniqueIndex(javalangIterable,%20comgooglecommonbaseFunction)
> I think those two are equivalent :)
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2263.
Hmm, are you looking [here](https://oss.sonatype.org/content/repositories/google-snapshots/com/google/)? As far as I know, Guava has hasn't used that `google-snapshots` repository.
I would expect for the Guava snapshot to be [here](https://oss.sonatype.org/content/repositories/snapshots/com/google/guava/guava/20.0-SNAPSHOT/). Our continuous build [seems to think that it's uploaded it](https://s3.amazonaws.com/archive.travis-ci.org/jobs/98136478/log.txt), and your Maven build works for me if I switch `pom-gwt.xml` to `20.0-SNAPSHOT`.
Fixed internally; will be mirrored out soon.
Can you provide the Android version, the equivalent Java code, and the error you see when using Guava?
does happen?
On Mon, Dec 21, 2015 at 6:12 PM Jiawen Geng notifications@github.com
wrote:
> Android Build Version Info
>
> ```
> compileSdkVersion 23
> buildToolsVersion "23.0.2"
> ```
>
> Equivalent Java code
>
> ```
> public static String readFileContent(File file) {
>     InputStream inputStream;
>     StringBuilder total = new StringBuilder();
>     try {
>         inputStream = new FileInputStream(file);
>         BufferedReader r = new BufferedReader(new InputStreamReader(inputStream));
>         String line;
>         while ((line = r.readLine()) != null) {
>             total.append(line);
>         }
>     } catch (FileNotFoundException e) {
>         LogUtil.d(TAG, String.format("e = %s", e));
>     } catch (IOException e) {
>         LogUtil.d(TAG, String.format("e = %s", e));
>     }
>
>     return total.toString();
> }
> ```
>
> I tried the guava 18.0, it can't read the file contents too.
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2257#issuecomment-166480719.
Your `LogUtil` message suggests that you're not running `Files.toString` at all. There's probably a bug you need to track down. I recommend [asking on StackOverflow](https://stackoverflow.com/questions/ask?tags=guava+java).
:(
This is sad, though probably not sad enough for the churn that the fix would produce.
If we do want to do something here, I think we want the `Comparator` to come second, since it's more or less an "optional parameter."
There's only O(hundreds) of usages in google, so this change isn't necessarily impossible. It would be a relatively safe deprecation + migration, unless someone decided to implement both Comparator and Iterable on _both_ of the objects (_gasp_).
`ImmutableSortedSet` isn't `@Beta`, so we'd need to do the 2 year deprecation cycle. It's still not out of the question though.
We discussed this at API review, and while we acknowledge that this was absolutely a mistake (in the purest design sense), it's probably not worth the churn and potential problems to our open source users to fix it at this time.
If we did change it, most users would just get annoyed at us for making them swap the param ordering (they wouldn't necessarily realize it was to correct a mistake). Also, even given our generous 2 year deprecation cycle for non-@Beta APIs, we still think it might cause version compatibility issues for our open source users.
Given that the incorrect param ordering isn't hurting anything (it's more or less impossible to get the order "wrong"), we're just going to live with this inconsistency. Feel free to cite this issue as a known Guava API mistake if ever asked :-)
Sorry that I missed replying here. This might be worth looking at someday, but it's a big project to even figure out what API might be widely useful, so I don't know whether we'll end up getting to it or not.  Thanks.
This doesn't entirely shock me, but I don't know that we've discussed it before.
The same problem would exist in `CompletableFuture` if not for [some special handling](http://concurrency.markmail.org/message/24ptlusoytgpzk6n). If we want to build something similar, we'll probably need to loosen up the spec for `directExecutor`... though I worry that that will have ill effects for other users who justly rely on the current, documented behavior. Perhaps we'd need another executor entirely, one that we encourage over `directExecutor` unless you really need `directExecutor` specifically. Or maybe we really need to build something into `ListenableFuture` itself -- possibly tricky because its API _requires_ an executor that we would be ignoring in some cases. (Or we would need it to recognize a special executor -- impossible to guarantee when other `ListenableFuture` implementations already exist.)
A workaround, of course, is to pass in an executor that will actually hand things off to a new thread. This, of course, has costs....
Have you run across this kind of problem in "real" code, or is it something you discovered during other testing?
Thanks -- and sorry for the trouble this caused you.
If we're lucky, we can just do something like changing...
```
setException(t);
```
...to...
```
if (!setException(t)) {
logger.log(..., t);
}
```
There's still a possibility of stack overflow, though, especially if the logger code has deep nesting. Another option would be to wrap (if necessary) and rethrow the exception. That should require less stack, and eventually the exception should reach the top-level `directExecutor` exception handler... I think? Hmm, or maybe the _top-most_ `directExecutor` handler will catch it, in which case we're back in danger of a stack overflow.
I will think about this some more.
Nice: It turns out that a candidate for `FutureExecutionRuntimeException` already exists: It's the `Error` we have! Here's what I have right now. It's enough to propagate the exception all the way back to whoever called `set()` in the first place:
```
@@ -117,7 +117,36 @@
setException(e.getCause());
} catch (Throwable t) {
// This exception is irrelevant in this thread, but useful for the client.
-      setException(t);
+      if (!setException(t)) {
+        /*
+         * Uh-oh. Most likely cause: set() succeeded in storing the value in the output Future, but
+         * when it went to run the Future's listeners, it got a StackOverflowError because of deep
+         * directExecutor() listener nesting. If user code relies on that listener (e.g., to
+         * complete a downstream, transformed Future), then it may hang. We can't do much to fix
+         * that: Anything we do may overflow the stack again. (And of course stack overflows are bad
+         * news in general. For example, we may have overflowed in the middle of defining a class.
+         * If so, that class will never be loadable in this process.) However, we at least want to
+         * show the error to the user somehow. The simplest way forward is to rethrow it. Because it
+         * is an error, it won't be caught and logged by AbstractFuture.executeListener. Instead, it
+         * can propagates through many layers of AbstractTransformFuture up to the root call to
+         * set().
+         *
+         * https://github.com/google/guava/issues/2254
+         */
+        if (t instanceof Error) {
+          throw (Error) t;
+        }
+        /*
+         * TODO(cpovirk): RuntimeException: Consider rethrowing them, too, though it will buy us
+         * only a couple stack frames before AbstractFuture.executeListener catches and tries to log
+         * it. Or wrap them in an Error (though that's kind of scary) or a special-purpose
+         * RuntimeException that our Future implementations know to pass through.
+         */
+        /*
+         * TODO(cpovirk): checked exceptions: Consider restructuring the code so that the compiler
+         * can see that they're not possible here.
+         */
+      }
}
}
```
In other words, this test now passes:
```
public void testTransform_StackOverflow() throws Exception {
SettableFuture<Object> root = SettableFuture.create();
ListenableFuture<Object> output = root;
for (int i = 0; i < 10000; i++) {
output = Futures.transform(output, identity());
}
try {
root.set("foo");
fail();
// TODO(cpovirk): What terrible problems could this cause for subsequent tests? Can we avoid them by running in a different ClassLoader?
} catch (StackOverflowError expected) {
}
}
// TODO(cpovirk): replicate to transformAsync and also to catching/catchingAsync
```
I haven't sent this for internal review yet. Any opinions on it?
A `RuntimeException` from the executor would be caught by `AbstractFuture.executeListener` (if that's what you're asking about).
In working out things like that, my reviewer and I got confused enough that we decided to restructure things further. The diff is a little long to post here, but basically we eliminated nested control flow entirely :) I think we're pretty happy with it, so once I replicate the code and its tests to `Futures.catching`, you should see the commit. It's always nice when a bug report prompts us to simplify things.
We're hesitant to make any changes to the behavior of Optional given Java 8. Also ogregoire's work around sounds reasonable.
I'm not sure what `ImmutableMap.copyOf(ImmutableMap.copyOf(...))` is doing for you?  I wouldn't expect the double copying to have any effect.
Duplicate of #1650, which i can see we haven't updated in a while. I'll do so now.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
Sorry that we sat on this (and so many pull requests) for so long.
If "A message" appeared inline in the setup for the test, I would agree that there's a clear benefit to including it inline in the assertion. But it's already defined elsewhere, so this test already fails to be readable on its own :( You could probably fine a way to move all the information inline if you want, but I'd encourage you to look for something more substantial. Maybe https://github.com/google/guava/issues/2394 if you're still interested.  Were performance not a concern, I would probably suggest that you use `Equivalence.Wrapper`. It's a little ugly, but code that uses collections with custom equality is likely going to need to use `Equivalence.Wrapper`, anyway.
For your case, that sounds like defeating the purpose :)
Another way to come at the problem is to make sure that your `equals` implementation is as fast as it can be, with a `==` special case at the top (and probably some `hashCode` caching, too -- I'm guessing that you may already do that, since it doesn't sound like you're seeing `hashCode` in your profiling?). But I guess that doesn't necessarily help with the `!=` case (though hopefully that's the much less common case if hashing is doing its job... though I suppose it could add up even then). One way to address that is to use `==` exclusively, but maybe that's not an option for the type in other uses.
I am nervous about something like `Ordering.explicit(Collection, Equivalence)` (or `Ordering.explicitUsingIdentity(Collection)`) because users who query the `Map` (or `Set`) are _also_ going to have to use the same instances. You can probably arrange for that to work in your case -- and it's really no worse than any other `IdentityHashMap` or other collection that's inconsistent with equals (frowned upon as those may be).
My guess is that we probably won't add this. But the `Ordering.explicit()` code is pretty self-contained IIRC, so you can probably clone and modify.
Thanks. The trick will be seeing if any existing Google code fails and needs to be fixed. I have a feeling that we tried this before and had problems, but I'm hoping for the best. I'll let you know how it goes.
Actually, I went and found the CL from last year. It does break people. This includes some people who define Comparators that throw if given equal elements! That's terrible, but it's also hard to prioritize fixing. I've teased the project to a couple people without success.
Sorry for not putting this information in the bug report. I'll do so now.
Closing, since we need to do cleanup internally to take this :(  Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
``` java
Iterator<Foo> foos = Iterators.mergeSorted(...); // 1
// some time passes here
while (foos.hasNext()) { // 2
}
```
It is necessary to read the first element each off _all_ the supplied iterators as of statement //3, but it currently happens at statement //1. Have I described the issue correctly and completely?
Okay, I was hoping you'd confirm that 2 instead of 1 gives you the lion's share of the benefit.
This seems at least reasonable.
For now I've updated the numbers to 19.0, but yeah, we may want to get rid of this page.
Is that a spec-compliant implementation?  https://docs.oracle.com/javase/7/docs/api/java/net/URLClassLoader.html#getURLs() doesn't seem to suggest the possibility of returning null there.
As Louis points out, `URLClassLoader.getURLs()` doesn't say anything about returning null. Since `_getURLs()` isn't part of the public `URLClassLoader` API, we couldn't call it anyways.
Please open a bug against IBM WebSphere.
These should all throw a NPE...not sure why that's not the case. It seems like `Doubles.tryParse()` should throw:
```
public static Double tryParse(String string) {
if (FLOATING_POINT_PATTERN.matcher(string).matches()) {
```
I just added the following tests, and these tests all pass (i.e., they all throw `NullPointerException`):
```
public void testTryParse_withNullGwt() {
try {
long unused = Longs.tryParse(null);
fail("Expected NPE");
} catch (NullPointerException expected) {
}
try {
int unused = Ints.tryParse(null);
fail("Expected NPE");
} catch (NullPointerException expected) {
}
}
public void testTryParse_withNullNoGwt() {
try {
double unused = Doubles.tryParse(null);
fail("Expected NPE");
} catch (NullPointerException expected) {
}
try {
float unused = Floats.tryParse(null);
fail("Expected NPE");
} catch (NullPointerException expected) {
}
try {
long unused = Longs.tryParse(null);
fail("Expected NPE");
} catch (NullPointerException expected) {
}
try {
int unused = Ints.tryParse(null);
fail("Expected NPE");
} catch (NullPointerException expected) {
}
}
```
@osundblad Where are you seeing the null -> null behavior?
@Quurks I don't think this discussion is about the string `"null"`, but rather the value `null`.
To be clear: `tryParse("null")` returns `null` for all of the methods in question.
Please see my test cases above. The methods are behaving exactly as they should (they throw a `NullPointerException` when passed `null`).
@Quurks we've fixed the test, and we're still correctly getting an NPE for each of those cases.  (We haven't mirrored it out yet, though.)
Based on our tests resulting in correct, consistent behavior, marking this invalid.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
Bulk closing all pull requests that are listed as needing CLA signing. If you'd like us to look at your pull request, you'll need to sign the CLA and report back here.
If this is a false positive, I apologize. Please reopen the pull request, and we'll have a look.  [Docs](http://maven.apache.org/surefire/maven-surefire-plugin/examples/single-test.html):
> NOTE : This feature is supported only for Junit 4.x and TestNG.
(Guava is stuck on JUnit 3 for GWT reasons.)
The best you can do that I'm aware of is to filter by filename:
```
mvn -Dtest.include="**/UntrustedInputFutureTest.java" test
```
That will still run all the GWT tests, so you probably want something like:
```
mvn -Dtest.include="**/UntrustedInputFutureTest.java" -Dgwt.test.include="NothingWillMatchThis" test
```
(Hopefully I got those right. I haven't been able to test them as thoroughly as I'd like because of some [problems with GWT deps](https://groups.google.com/d/topic/google-web-toolkit/Ty78TNg58iA/discussion) at the moment.)
compiler.  Java methods are limited to 65536 bytes of bytecode, from what I
can tell, which it looks like your code is likely to approach or exceed.
Enormous constants like this should usually be loaded from a file or a
static initializer with logic to build the constant.
On Fri, Nov 20, 2015, 4:57 PM kentmchenry notifications@github.com wrote:
> This could be a compiler bug, or it could be an issue with the way
> ImmutableMap.Builder() functions.
>
> Here is my sample class which produces the compilation error (stack
> overflow during compile)
>
> import java.util.Map;import java.util.UUID;import com.google.common.collect.ImmutableMap;public class MapTest {
>   private static final Map<String, Object> map = new ImmutableMap.Builder<String, Object>()
>       .put("cbc3fdad-01ed-4f90-a75d-b239fb99acab", new Object())
>       .put("621a7f96-3513-4b4a-9c35-bc80fbc42f18", new Object())
>       .put("c95de3a1-da02-45a8-9cd4-2f6014fb47a6", new Object())
>       .put("6a759307-b797-40d7-9e53-fc3c335b73b4", new Object())
>       //... (10,000 total puts)
>       .build()
> }
>
> Here is the command used to compile the class (note: I first encountered
> duplicated the error with v 18)
>
> $> javac -classpath guava-18.0.jar MapTest.java
>
> The system is out of resources.
> Consult the following stack trace for details.
> java.lang.StackOverflowError
>     at java.util.regex.Pattern$1.isSatisfiedBy(Pattern.java:4111)
>     at java.util.regex.Pattern$5.isSatisfiedBy(Pattern.java:5251)
>     at java.util.regex.Pattern$5.isSatisfiedBy(Pattern.java:5251)
>     at java.util.regex.Pattern$CharProperty.match(Pattern.java:3776)
>     at java.util.regex.Pattern$GroupHead.match(Pattern.java:4658)
>     at java.util.regex.Pattern$Branch.match(Pattern.java:4602)
>     at java.util.regex.Pattern$Branch.match(Pattern.java:4602)
>     at java.util.regex.Pattern$Branch.match(Pattern.java:4602)
>     at java.util.regex.Pattern$BranchConn.match(Pattern.java:4568)
>     at java.util.regex.Pattern$GroupTail.match(Pattern.java:4717)
>     at java.util.regex.Pattern$Curly.match0(Pattern.java:4279)
>     at java.util.regex.Pattern$Curly.match(Pattern.java:4234)
>     at java.util.regex.Pattern$GroupHead.match(Pattern.java:4658)
>     at java.util.regex.Pattern$Branch.match(Pattern.java:4604)
>     at java.util.regex.Pattern$Branch.match(Pattern.java:4602)
>     at java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3798)
>     at java.util.regex.Pattern$Start.match(Pattern.java:3461)
>     at java.util.regex.Matcher.search(Matcher.java:1248)
>     at java.util.regex.Matcher.find(Matcher.java:664)
>     at java.util.Formatter.parse(Formatter.java:2549)
>     at java.util.Formatter.format(Formatter.java:2501)
>     at java.util.Formatter.format(Formatter.java:2455)
>     at java.lang.String.format(String.java:2940)
>     at com.sun.tools.javac.comp.DeferredAttr$DeferredTypeMap.<init>(DeferredAttr.java:828)
>     at com.sun.tools.javac.comp.Attr.checkMethod(Attr.java:3815)
>     at com.sun.tools.javac.comp.Attr.checkIdInternal(Attr.java:3593)
>     at com.sun.tools.javac.comp.Attr.checkMethodIdInternal(Attr.java:3504)
>     at com.sun.tools.javac.comp.Attr.checkMethodId(Attr.java:3479)
>     at com.sun.tools.javac.comp.Attr.checkId(Attr.java:3466)
>     at com.sun.tools.javac.comp.Attr.visitNewClass(Attr.java:2072)
>     at com.sun.tools.javac.tree.JCTree$JCNewClass.accept(JCTree.java:1516)
>     at com.sun.tools.javac.comp.Attr.attribTree(Attr.java:566)
>     at com.sun.tools.javac.comp.Attr.attribArgs(Attr.java:664)
>     at com.sun.tools.javac.comp.Attr.visitApply(Attr.java:1806)
>     at com.sun.tools.javac.tree.JCTree$JCMethodInvocation.accept(JCTree.java:1465)
>     at com.sun.tools.javac.comp.Attr.attribTree(Attr.java:566)
>     at com.sun.tools.javac.comp.Attr.visitSelect(Attr.java:3227)
>     at com.sun.tools.javac.tree.JCTree$JCFieldAccess.accept(JCTree.java:1897)
>     at com.sun.tools.javac.comp.Attr.attribTree(Attr.java:566)
>     at com.sun.tools.javac.comp.Attr.visitApply(Attr.java:1815)
>     at com.sun.tools.javac.tree.JCTree$JCMethodInvocation.accept(JCTree.java:1465)
>     at com.sun.tools.javac.comp.Attr.attribTree(Attr.java:566)
>     at com.sun.tools.javac.comp.Attr.visitSelect(Attr.java:3227)
>     at com.sun.tools.javac.tree.JCTree$JCFieldAccess.accept(JCTree.java:1897)
>     // stack trace repeats
>
> Here is my Java version
>
> java version "1.8.0_60"
> Java(TM) SE Runtime Environment (build 1.8.0_60-b27)
> Java HotSpot(TM) 64-Bit Server VM (build 25.60-b23, mixed mode)
>
> Here is the dummy code I used for generating the source code to do 10,000
> puts on the map
>
> import java.util.UUID;
> public class MapTest {
>   public static void main(String[] args) {
>     StringBuilder sb = new StringBuilder();
>     for (int i = 0; i < 10000; i++) {
>       String id = UUID.randomUUID().toString();
>       sb.append("    .put(").append(quote(id)).append(", new Object()").append(")").append(System.lineSeparator());
>     }
>     System.out.println(sb);
>   }
>
>   private static final String quote(String s) {
>     return '"' + s + '"';
>   }
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2234.
This is just a function of javac's default stack size; you want to pass something like -J-Xss4m to give it more stack space.
Louis's points stand as well.
Might want to paste the recommended flag directly instead of retyping it. :-)
To solve your example problem with the current API, you might write
```
// Assume lowBound and highBound are Optional<T extends Comparable<T>>
Range<T> lowCut = lowBound.isPresent() ? Range.atLeast(lowBound.get()) : Range.all();
Range<T> highCut = highBound.isPresent() ? Range.atMost(highBound.get()) : Range.all();
return lowCut.intersection(highCut);
```
Could this approach address your problems more generally, by just using the exposed Range APIs with intersection?
I always felt pleased with my little implementation choice there, but I've
implementationy and just doesn't really _represent_ anything in the real
world.
A Bound that is like a Cut that also knows whether it's being used as a
lower or upper (and therefore actually knows whether it's closed or not!)
is easier for a user to deal with, and I guess I can't rule out the
possible value of adding Bound-based methods.
On Fri, Nov 20, 2015 at 1:07 PM, Josh Rosenblum notifications@github.com
wrote:
> At present, the Range abstraction is implement in terms of Cut, but the
> Cut type (and the Range constructor that utilizes that type) is
> package-private.
>
> Cut seems like a mathematically-sound concept -- something that's unlikely
> to change soon. And there are a number of Range construction use cases
> where the ability to define a new Range in terms of Cuts would be a useful
> public operation to support. One common use case has to do with Nullable
> (or Optional, as you will) bounds. It's often the case that APIs,
> particularly external APIs like RESTful interfaces, might provide either or
> none of the endpoints of a range, particularly as part of a filtering
> request from a client. It's difficult to use the existing bounds-based
> static factories on Range to construct an appropriate Range easily because
> they (understandably) don't accept null bounds. So there's typically a lot
> of branching code to call the correct static factory such as .all(),
> .atLeast(), .atMost(), or closed() depending on whether none, either, or
> both of the bounds have been specified by a client
>
> express the range constraints it wants much more directly, such as:
>
> // Assume lowBound and highBound are Optional<T extends Comparable<T>>
> final Cut<T> lowCut = lowBound.isPresent() ? Cut.<T>belowValue(lowBound.get()) : Cut.<T>belowAll();
> final Cut<T> highCut = highBound.isPresent() ? Cut.<T>aboveValue(highBound.get()) : Cut.<T>aboveAll();
> return new Range<T>(lowCut, highCut);
>
> Without the ability to express the range conditions a bit more abstractly,
> code like that above leads to a lot of branching code to determine the
> correct static factory to invoke on Range.
>
> If Cut is not the abstraction to expose publicly, maybe there's some other
> compact solution to this (at least in my experience) common use case of
> Optional / Nullable bounds?
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2233.
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
I think this is adequately covered by [the existing docs](http://google.github.io/guava/releases/18.0/api/docs/com/google/common/collect/Collections2.html#filter%28java.util.Collection, com.google.common.base.Predicate%29):
> **Warning:** `predicate` must be _consistent with equals_, as documented at Predicate.apply(T). Do not provide a predicate such as Predicates.instanceOf(ArrayList.class), which is inconsistent with equals.
Thanks for the report. This sounds like a bug and something we should look into.
> Returns a snapshot of this counter's values. Note that this may be an inconsistent view, as it may be interleaved with update operations.
Synchronizing would defeat the purpose of CacheStats and, frankly, the purpose of Cache itself: the whole idea is for many threads to be able to operate on the cache without contending for a common lock, but if the SimpleStatsCounter were globally synchronized, every thread accessing the cache would content for that lock.
Additionally, SimpleStatsCounter itself depends on a thread-safe but not atomic abstraction, LongAdder, whose sum() method carries the Javadoc
```
/**
* Returns the current sum.  The returned value is <em>NOT</em> an
* atomic snapshot; invocation in the absence of concurrent
* updates returns an accurate result, but concurrent updates that
* occur while the sum is being calculated might not be
* incorporated.
*
* @return the sum
*/
```
From what I can tell, SimpleStatsCounter is essentially in the same position as LongAdder, though it does have the added issue that it has multiple fields which may be updated inconsistently.
I think the conclusion here has to be that a) SimpleStatsCounter is intended to be used from multiple threads, b) it implements its intended semantics correctly, though those intended semantics only make weak guarantees, c) "threadsafe" is a very vague word and we should possibly document the intended semantics more clearly.
I would support adding some text to CacheStats explaining the non-atomic
updates.  It may be worth a special warning on
hitRate/missRate/exceptionRate as well, and a tweak to guarantee that the
returned value is always <= 1.0?
On Thu, Nov 19, 2015 at 10:26 AM, Ben Manes notifications@github.com
wrote:
> Oh, I forgot to add padding to avoid false sharing. A big improvement, but
> reads are still pretty poor. Updated commit
> https://github.com/ben-manes/caffeine/commit/ab0da7e09b96ad92c0c43131f4a88b7245b2edcc
> .
>
> StatsBenchmark.stats:record        atomic  thrpt   10  215337580.177 ops/s
> StatsBenchmark.stats:snapshot      atomic  thrpt   10     182681.894 ops/s
> StatsBenchmark.stats:record    concurrent  thrpt   10  156842262.685 ops/s
> StatsBenchmark.stats:snapshot  concurrent  thrpt   10    4037267.672 ops/s
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2230#issuecomment-158146813.
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
If we always increment the denominators before the numerators we shouldn't
have that problem?  I'm not certain which order we increment things now.
On Thu, Nov 19, 2015, 10:35 AM kevinb9n notifications@github.com wrote:
> I would support adding some text to CacheStats explaining the non-atomic
> updates. It may be worth a special warning on
> hitRate/missRate/exceptionRate as well, and a tweak to guarantee that the
> returned value is always <= 1.0?
>
> On Thu, Nov 19, 2015 at 10:26 AM, Ben Manes notifications@github.com
> wrote:
>
> > Oh, I forgot to add padding to avoid false sharing. A big improvement,
> > but
> > reads are still pretty poor. Updated commit
> > <
> > https://github.com/ben-manes/caffeine/commit/ab0da7e09b96ad92c0c43131f4a88b7245b2edcc
> >
> > .
> >
> > StatsBenchmark.stats:record atomic thrpt 10 215337580.177 ops/s
> > StatsBenchmark.stats:snapshot atomic thrpt 10 182681.894 ops/s
> > StatsBenchmark.stats:record concurrent thrpt 10 156842262.685 ops/s
> > StatsBenchmark.stats:snapshot concurrent thrpt 10 4037267.672 ops/s
> >
> > 
> > Reply to this email directly or view it on GitHub
> > https://github.com/google/guava/issues/2230#issuecomment-158146813.
>
> ##
>
> Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2230#issuecomment-158149466.
The current implementation is approximately per-segment LRU, which would _not_ evict the least-recently used entries from the cache as a whole, but only the least-recently-used entries that happened to be hashed into the cache segment that overflowed.  Even so, that policy is not specified and is subject to change.
This sounds reasonable, but adding this API would require a new dependency from reflect -> io, which doesn't currently exist (...but it's probably OK, since we'd never want an io -> reflect dependency).
Colin is going to see if this is a common pattern inside google code.
So, the number of callers of `ResourceInfo.url()` is quite low, but 100% of them want to read the bytes from that URL either as bytes or a string.
`ResourceInfo.asByteSource()` and `asCharSource(Charset)` have been added and should be mirrored out soon.
It's consistent with the rest of Guava and all of the JDK Collections: an
object that might be _stored_ is of type K; otherwise it's Object.
On Sun, Nov 15, 2015 at 10:11 PM, Nick Tan notifications@github.com wrote:
> Hi folks
>
> as we can see the methods of Cache interface, most of them are generic
> except getIfPresent(Object key):
>
> public interface Cache<K, V> {...
>   V getIfPresent(Object key);
>
>   V get(K key, Callable<? extends V> valueLoader) throws ExecutionException;...
>   void put(K key, V value);...
>
> is it intended? why not V getIfPresent(K key) to be consistent?
>
> thanks
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2227.
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
This is deliberately consistent with the rest of Java, which made this design decision deliberately.  There have been some explanations above; http://stackoverflow.com/questions/857420/what-are-the-reasons-why-map-getobject-key-is-not-fully-generic has some more.
I'm not sure what behavior you're expecting.  If you cap _any_ LRU cache at 9 items, and then rotate through fetching 10 items in order, yes, you won't get any cache hits.  Configuring a Guava cache with maximumSize and with expireAfterWrite means that entries will be expired whenever the cache exceeds maximumSize _or_ an entry is old enough.
More or less, that means that this particular access pattern is the worst case for LRU.  If cache entries aren't accessed cyclically, but, say, randomly, then the cache will work relatively well.  An example:
```
LoadingCache<Integer, Integer> cache =
CacheBuilder.newBuilder().maximumSize(9).recordStats().build(
CacheLoader.from(Functions.<Integer>identity()));
for (int i = 0; i < 100000; i++) {
cache.getUnchecked(rng.nextInt(10));
}
System.out.println(cache.stats().hitRate());
```
This prints out a value near 0.9, which is exactly what you'd expect.  I don't think this has anything to do with expireAfterAccess, it's just that your access pattern happens to be the worst case for LRU.
@doit-ceo, part of the issue is that "your method" also has worst cases that can come up in practice.  For example, imagine that your cache is YouTube, and you (naturally) fill your cache as big as it can get, and suddenly someone posts Gangnam Style and now everybody is searching for that.  But now that new thing will never get into the cache, because the cache is full already, and you'll never put that new hot element into the cache.  Once the cache gets filled up once, new entries will never enter the cache.
That may be different if you also use expireAfterWrite and the like, but CacheBuilder _should_ work effectively even if you just specify maximumSize, and your caching algorithm would accept maximumSize elements and then the cache would never change again, even if 90% of users start looking up an entry that was added after the cache got filled.
Guava's Cache implementation uses LRU because it is simple to implement, has low overhead, and reasonably effective in scenarios we think are realistic.  The CacheBuilder spec does not tie Guava to LRU, but changing that implementation would be a massive undertaking for us.  Caffeine's use of TinyLFU represents one direction -- a very impressive, highly promising direction -- this might go in the future.
It's not clear that there is a specific, actionable feature request or bug report here. If so please reopen and make that request very clear.
For what it's worth, the JDK upstream appears to be doing something along these lines; see http://openjdk.java.net/jeps/269.
That said, off the cuff: I suspect we'd prefer that you just not static import this, rather than having us provide multiple methods that do the same thing?
Yep. We have one of these internally (with a slightly different but broadly similar API -- we should consider switching to yours), and we've been meaning to release. But obviously we haven't done that :)
It seems to us that your methods should just return your own subtypes of CharSink/Source and those can have whatever useful contextual methods on them that you want.
I've removed the broken links from this page... not sure they were adding much value anyway.
I did a bunch of automatic migrations to Truth a while back. I'm wondering if we should just convert all the ones that are "OK" as JUnit tests -- like `assertThat(foo).isEqualTo(bar)` -- too.
My main concerns are:
- small payoff (slightly nicer source code)
- code of allocations on Android+GWT
If we go to the trouble, we should measure the impact on these allocation-sensitive platforms.
For what it's worth this seems like a very barely useful thing to do.....
- It would be nice if we didn't have to worry about speed in unit tests, but our Android tests already time out too often, so we'll want to make sure that we aren't making them worse.
- I agree that this is barely useful. I filed the bug mostly so that I had a place to put the warning about Android. I'll close it, and we can reopen if we are motivated.
- We could wait for Truth 1.0, but we already use Truth heavily, so the timing probably doesn't make a difference.
- We do have a Refaster plugin to migrate to Truth. I assume that one day we will release it.
Can you also describe the behavior that you see and the behavior that you expect?
We don't see a clear issue report here; you may just want to ask for help with your use case on Stack Overflow.
Thanks. I've merged all 4 of the PRs.
To argue successfully for a new feature, one thing we need is a good set of real-world use cases for which the feature is a clear win. Along with a reason to believe this need comes up with any reasonably frequency among our users. This one seems very unlikely to clear the bar, but if you feel strongly and can provide the requested info, you can reopen.
I just ran into a need for this as well, and we've had a few reports internally asking for something like this. I think the most reasonable API would be to have an instance method which returns true/false for whether a given string matches the `CaseFormat`.
Would that satisfy most use cases here?  Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
(transitive) To display; to have as a notable feature.
Jen's sporting a new pair of shoes;  he was sporting a new wound from the combat
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
We may end up doing this. The reasons that I haven't just merged it are:
- Our theory is that few operations are (a) slow and yet (b) unable to fail. Most are either predictably fast (in which case you don't need the timeout) or able to fail (in which case you need the checked exception -- say, for an RPC).
- Users who do have slow yet unable to fail operations may be better served by the full ForkJoin framework, which... hmm, I thought that it provided timed gets, but it seems not, at least not on `ForkJoinTask`? Maybe it's defined somewhere else?
- In most cases, it's hard to see a timeout as a "programming error." (Now, we do already have `UncheckedTimeoutException` for `TimeLimiter`, as you've noted... but that's an API that we've felt kind of icky about since we created it.)
- It's not 100% clear what to do with interruption. I think that what you do is probably right. But if the wait is expected to sometimes be long, then waiting uninterruptibly may not be ideal for all users.
- I have some general regret around the `getChecked`/`getUnchecked` family of methods. This comes mainly from the fact that `getChecked` is poorly suited for Android: It's likely to be slow (especially in the failure case but even somewhat slow in the success case on old versions), and more importantly, it doesn't play nice with Proguard. But how does that tie in to `getUnchecked`? Well, if people can't use `getChecked`, they're going to be tempted to use `getUnchecked`, even if it's not the right thing for them. So there's a part of me that wishes that we hadn't added either method.
Again, we still might do this. It just requires some weighing of pros and cons. Having the code waiting for us is nice, at least :)
I am similarly unconvinced.
The bar is very high for adding new configuration methods to CacheBuilder; to me, I don't think this clears it.  If even stronger arguments (like hard performance data) emerge, please reopen.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
I only see about 3200 hits on a popular search engine for `X_FORWARDED_PORT`.
If you can dig up an RFC, or some official-looking source, that would help justify it's addition.
https://www.google.com/search?q="X-Forwarded-Port"
"About 7,450 results (0.26 seconds) "
Question: Have you considered setting the java.io.tmpdir system property?
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
We have been slowly going through and reformatting all our code with
https://github.com/google/google-java-format; that's why you didn't find
that will take care of this automatically.
On Fri, Oct 23, 2015 at 12:01 PM, googlebot notifications@github.com
wrote:
> CLAs look good, thanks!
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/pull/2204#issuecomment-150664293.
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
Our `transform*` methods return views, not copies. As a result, when the user calls `get(k2)`, we would need a way to compute the corresponding `k1` value to find it in the original map.
We could support this if we required a two-way function, but this has its own dangers. See the similar case of `Sets.transform`: https://code.google.com/p/guava-libraries/wiki/IdeaGraveyard#Sets.transform()
Someone can probably suggest a way to do this with streams if you [ask on StackOverflow](https://stackoverflow.com/questions/ask?tags=guava+java).
Dup of issue 2115.
#2115
The plan is to release Guava 19 with support for GWT <2.8 and then quickly Guava 20 with support for GWT >=2.8: https://github.com/google/guava/wiki/Release19#gwt-notes
Does that sound OK?
The easiest thing is probably for you to follow https://github.com/google/guava/issues/1999. I've retitled it to better emphasize what it's about now.
Adding this to our public API may be an option, but can you provide some specific motivation for why you want to use this?
This is good information to put in the source code. Probably we should have a `@UsedFromReflection` annotation for just this purpose. In fact, we do, but it's internal only... and there are at least two :( ... I've started a discussion about what we should do about that.
Sorry, I should have said that it was a discussion inside Google (since that's where the teams that currently use the annotation are). I'll let you know how it goes.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA ([login here](https://cla.developers.google.com/) to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
<!-- need_author_cla -->
The current build failure is an issue with the latest GWT 2.8.0 snapshot, which I reported over here: https://github.com/gwtproject/gwt/issues/9206
This fix LGTM once the test issues are resolved.
Thanks. I'm sending the PR for internal review now.
Thanks. That should be enough to get `intersection` out of my sights for now :)
I suppose that @cgdecker could try to get this into 19.0-rc3...? But I do feel bad that we keep holding that up.
Very, very low priority.
True, we'd need to measure. My thinking had been that caching the instances might help under Android, where we don't have Hotspot, but probably Android users won't want to use this method, anyway, as it's hostile to Proguard.
It's possible that this would still be a win on the server, since from what little I understand, escape analysis is rarely good enough to perform these optimizations. But that could always change someday.
In the absence of any current motivation, I'll close this.
Does it work if you use `mvn install`?
We should really have some documentation that says to do that, probably on https://github.com/google/guava/wiki/HowToContribute. I had been thinking that we did, but if so, I can't find it.
We should have this and readily findable.
One thing that this could address is https://github.com/google/guava/issues/2235: how to run a specific test. (Arguably that's more of a Maven question, but (a) it would be nice to lower the barrier anyway, and (b) one common "Maven way" of doing it doesn't work for Guava, as noted in that thread.)
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA ([login here](https://cla.developers.google.com/) to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
<!-- need_author_cla -->
CLAs look good, thanks!
<!-- ok -->
In some cases, it's necessary to update the GWT sources. This isn't one of them.
Thanks to https://github.com/google/guava/commit/63360f3f588a4a30d2d2e43ee6ec3f724d38b546, we are no longer putting these "unimportant" sources in Github. In fact, the specific source touched here was deleted in that CL.
@lowasser , aside from the GWT question, did you end up reviewing this?
I don't think I did.  You're welcome to, @cpovirk, or I can do it if you'd rather.
Be my guest, @lowasser :)
@lowasser just fixed this...thanks for the report!
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
`readObject` is a method automatically invoked during deserialization, so it's still "used."
All that said, we decided a while ago that we weren't going to try to keep our `Immutable*` types immutable even in the presence of malicious users, so we can remove this if we want.
The class you're looking for is `AbstractFuture`. I will add some doc to `SettableFuture` to point there. (We currently have doc on `ListenableFuture`, so I may just add a pointer back there.)
Another thing we need to do is figure out our recommendations for extending `AbstractFuture`. Our hope is that users will rarely have to override `cancel()` (which doesn't always get invoked on cancellation, surprisingly enough: https://github.com/google/guava/issues/1958 https://github.com/google/guava/issues/1905). In many cases, all you need is to override `interruptTask()`. For cases in which that is not enough, we are probably going to expose a `done()` hook for users to override (https://github.com/google/guava/issues/2075).
I'll leave this request open until I at least add the doc.
`cancel()`, `set()`, and `setException()` are all available on `AbstractFuture`, too. (I haven't formed a full picture of your requirements, but I'm confident that anything that can be done with `SettableFuture` can be done with `AbstractFuture`.)
But I guess I have been dodging the question :) A reason for `SettableFuture` to be final is that it gives us freedom to perform [optimizations](https://github.com/google/guava/blob/60fe0bb1bf3257779474af8fd80a59cb9a2f402a/guava/src/com/google/common/util/concurrent/AbstractFuture.java#L701). Well, OK, for that particular optimization, we need only `get()` to be `final`, not `cancel()`. But we want to leave ourselves the freedom to do additional optimizations in the future. In fact, this `get()`-based optimization is new for Guava 19, so if we had permitted overriding of arbitrary methods, we would have prevented ourselves from introducing it. We also have the freedom to make other changes besides optimizations. (I don't remember if this has been important for `SettableFuture` yet, but that's the general principle at work. And again, for people who do need to extend the type, we provide `AbstractFuture`, so we're just pushing users to take a slightly different approach.)
I've added some documentation to `SettableFuture`.
When you refer to "duplicating the code," are you talking about duplicating the overrides of `set` and `setException` that exist only to make them accessible? Often this ends up being unnecessary if you call the methods from within your `AbstractFuture` subclass.
To your `cancel()` request, I think you're describing a `Future` that diverges from the `Future` spec. [That spec](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html#cancel-boolean-) requires that the `Future` be done when `cancel()` returns.
If the need to redeclare `set` and `setException` is distasteful, you can put your `3rdparty.method().addListener` call inside your `AbstractFuture` subclass, probably declared inside your `MyThirdPartyUsingService` class. This might turn out to be the simplest place to define your subclass, anyway, to keep the `set` and `cancel` logic near one another.
RE: "subsequent calls to `isDone()` will always return true": I think that the natural reading of "always" is "at any time," not "after some arbitrary future time." Otherwise, all the statement would be saying is "Once the `Future` is done, it's always done," and that doesn't seem like something to document on `cancel()`.
You seem to be suggesting that the `isDone` concept of "completed" ("Returns `true` if this task completed") has no connection to the concept of "completed" used elsewhere in the `Future` docs ("The result can only be retrieved using method `get` when the computation has completed").
Returning to `SettableFuture` and `final`: I regret that I haven't formed a clear enough picture of how `SettableFuture` would be used in your code to be more helpful. As far as the feature request goes, though, the Guava team is satisfied with `AbstractFuture` as a solution here.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
We don't need to merge the release branch into master.
I don't think so?  I think you can just add more changes to this pull request?
Then probably leave it out -- it's not clear what we should do there.
What about `Lists.newArrayList(Iterable)` or `ImmutableList.copyOf(Iterable)`?
Most users who want a `Collection` are going to want a specific type of `Collection`: a `Set` that has a fast `contains()` implementation, a `List` that has fast random access, or whatever. The main exception, of course, is exactly your use case: Someone wrote an API that should have accepted `Iterable` but doesn't.
There are a couple things to watch out for even in that case. First, will the method mutate or store the given `Collection`? If so, do you want mutations it makes to be reflected in your original `Iterable`? Do you want changes to your original `Iterable` to affect the `Collection` you passed in? Again, for some use cases, you won't need to care, but for a general-purpose API, we need to nail this down. And under the current API, the answer is "It depends." To reflect this, we'd probably have to rename the method to "castOrCopyToCollection."
But what about the case where the method you're calling really does just iterate over the input, not modify or store it? In that case, the distinction I make above doesn't matter. But now someone is going to tell us that we should just provide a `Collection` _view_ of the underlying `Iterable`, since there's no need to copy it. So if we restrict ourselves to that use case, we probably want `Iterables.asCollection()`. But then will users get bit when someone calls its an O(n) `size()` implementation in a loop?
A final irony in all this is that `Iterables.toCollection()` is not actually an ideal tool for how we use it, either: We use it only to implement `Iterables.toArray()`, but that means that we end up making an extra copy that we don't need. That's not a big deal, but we would get better performance if we just wrote the array-expansion logic ourselves.
Thanks for explaining so well, Ben.
It's not clear that this really matters, but it might to Android or to our heaviest internal server users. We'll wait for macrobenchmarks from one or the other before doing anything. (OK, we did already do https://github.com/google/guava/commit/1269ba4833c8ed134444963069bb3b664c945fcf, which I think was based on at least some evidence.)
Things we could do:
- See whether this `RunningState` abstraction is buying us anything anymore now that we've realized it still needs code to clear its fields. (Its purpose was to give us an easy way to throw away all fields at once. This doesn't really buy us anything now that we've found we need to clear the fields anyway.) Of course, this is small potatoes.
- Consider reusing the same `List` for the list of input `Future` objects and the list of result objects. We already using a mutable list for the latter (which we later "make immutable"), so we could just put the original `Future` objects in it and then overwrite them with the outputs as we go. (Caveat: We may one day want to change `successfulAsList` to stop returning `null` for failures, preferring instead to omit those elements entirely. If we're reusing a `List` for this, we may need to do a lot of `arraycopy`-ing to eliminate the elements in question (or else lose our ordering guarantees, which might be something we'd be willing to offer as an option but probably shouldn't be required... unless we want to direct users who require "ordering" to `successfulAsMap`, about which more below). Or maybe there's deeper surgery that could help here.
- IIRC we have yet another `List` involved: We first put results into a `List<Optional>` and then copy them to the "real" list. This is at least in part to support the currently Google-internal `allAsMap`/`successfulAsMap`, which could perhaps be supported in different ways (and which lukes@ wants dead IIRC), but maybe there are other reasons for it.
This is one of those things that is technically absolutely correct, but still confusing.
This is minor enough that I think it's not worth even a couple extra lines, sorry. If you know of a place in which this is a bottleneck and can provide a benchmark, we could reconsider.  We assume that anyone who wants to compile Guava will do so with javac 7. That said, if anyone wants to propose a noninvasive fix, we could merge it.
This looks like [this JDK bug](http://bugs.java.com/view_bug.do?bug_id=6889255) but I think that should be fixed in the 1.6.0_45 version.
@cpovirk the issue occurs when compiling with Guava in the classpath, not when compiling Guava itself.
Oh, sorry, thanks. We should figure this out.
Thanks for the easy way of reproducing the problem.
I've tried backing out your suggested commit and everything else related to j2objc (c62b07df3a68126e1cf549c85c35f4e55178990b 9615497daa21fd9eba838949c52af979184fdf19 b21afd3bab31518b4a1c74784d3fd7f95783cb23 a02e1656a4be29fd6f8441f444c3b30cc62467c6 4fe1c9c76ba9e7a9cfd8073ab750a73404c685a0), but this didn't help. I'm kind of glad, since I don't know what we would do if that were the problem :) Not that I'm sure what we'll do, anyway.... I'll binary search from here.
@cgruber, is it possible for us to configure Travis to run with Java 6?
The problem seems to be 26342f6fe1f8b629a2ce1bdb3ef872f84a7e960a.
Or maybe I'm doing `git bisect` wrong. Or maybe there's more than one problem commit.
From the sound of the bug amonn linked, I would guess that it is :) That one would at least be easy to fix :)
But I do think I got the commit wrong. I'm suspecting that I need to learn more about `git bisect` in the presence of branching/merging.
Actually, if I now rebuild 19.0-rc1, I get the failure there, too. The problem seems to be that we've upgraded the compiler on our workstations between when we built 19.0-rc1 and 19.0-rc2. Hermetic builds are overrated, so Maven doesn't care :-P
I'll see if we can build with an older compiler.
Yep, that's the problem. I've updated our release instructions to include building with an older JDK. We will do so for 19.0-rc3. @cgdecker as an FYI.
Thanks again for the report.
Ideally we would report this to Oracle, but I envision that a small enough example program will be painful to produce.
A workaround:
```
diff --git a/guava/src/com/google/common/collect/ImmutableMultimap.java b/guava/src/com/google/common/collect/ImmutableMultimap.java
index 5790218..b75d6fb 100644
@@ -696,4 +696,9 @@ public abstract class ImmutableMultimap<K, V> extends AbstractMultimap<K, V>
}
private static final long serialVersionUID = 0;
+
+  public boolean containsEntry(@Nullable Object key, @Nullable Object value) {
+    return super.containsEntry(key, value);
+  }
}
```
```
diff --git a/guava/src/com/google/common/collect/AbstractMultimap.java b/guava/src/com/google/common/collect/AbstractMultimap.java
index 6b94c12..3d79361 100644
@@ -55,8 +55,7 @@ abstract class AbstractMultimap<K, V> implements Multimap<K, V> {
public boolean containsEntry(@Nullable Object key, @Nullable Object value) {
-    Collection<V> collection = asMap().get(key);
-    return collection != null && collection.contains(value);
+    return false;
}
```
@cpovirk We might be able to configure Travis to use openjdk6 for something, but I'm not clear on what we'd do. We can't do the normal build/test we do on other JDKs because Guava just won't build on JDK6. And even if we could, is a build/test enough to catch this problem? Don't we need to build something else with guava + annotation processor on the classpath?
Sorry, I guess I still haven't quite accepted that this is a different problem than I initially thought. Ideally we would still have a regression test, but it would have to be more complex than I had expected, so it's probably not worthwhile.
I've managed to reproduce it. I'm not sure whether Oracle will feel the need to do anything, since Java 6 (and even Java 7) are [no longer publicly updated](http://www.oracle.com/technetwork/java/javase/eol-135779.html), but maybe there's some chance that they'll view it as a bug in the Java 8 compiler. But I'm not feeling too lucky.
(For example, the problem exists with all other public subclasses of `AbstractMultimap`, too: `ArrayListMultimap`, `LinkedHashMultimap`, `LinkedListMultimap`, `HashMultimap`.)
Thanks.
I guess I'm focusing too much on the negatives: We do have the workaround of compiling 19.0 with an older javac, so we should be able to maintain compatibility.
Ok, so if we just compile 19.0 on, say, openjdk7, the resulting artifact shouldn't have this problem when used with an annotation processor? Not something we want to have to keep doing long-term probably, but should certainly be able to do that for 19.0.
Yep. I previously claimed to have updated our Release Process instructions with the information about which specific JDK version I was having success with. But I realized that I hadn't saved the change to the page because I'd been planning to link to back to this thread. I did eventually make the change, but if you looked relatively shortly after I claimed to have made it, it wasn't there. It is now.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
What exactly is this?
CLAs look good, thanks!
<!-- ok -->
I'm not sure why you expect to be able to?  Comparator specifies only that some negative number is returned to indicate the first argument is less than the second argument; it doesn't specify any greater detail.
Issue #902 requests `Multitable`, which we have been hesitant to add because of complexity.
When the JDK was hesitant to add even `Multimap` and `Multiset`, they added `Map.computeIfAbsent`, which serves many of the same use cases noticeably less well but with a significantly smaller API footprint. Perhaps we could do the same here? We could wait for Java 8 to add a true default method, or we could provide it as a static method.
You may safely assume now is a good time for us to be making these decisions.  We have Java 8, Guava 21 will hopefully follow swiftly on the heels of 20 since we already have all the Java 8 stuff internally, and as usual, we often test things out for a while internally before releasing them into Guava.
Now is a good time to discuss this. :)
I think at the moment the question isn't whether it should be a default method, but whether it should be provided at all?
"How much demand is there" _is_ the question we'd want to ask, it means we need to do research on Google's codebase to see how many people are using common workarounds for the nonexistence of this method.
Very rough searches: ~6% of `Table` usages inside Google are either a `Table<..., ..., List>` or `Table<..., ..., Set>`. Compare to ~8% of `Map` usages with `List`/`Set` values (despite the existence of `Multimap`, which is itself ~13% as popular as `Map`).
(And of course, users may be using different workarounds -- `Map<R, Map<C, List<V>>`, `Multimap<R, Pair<C, List<V>>`, or whatever.)
If anyone wants to dig deeper, I suggest a search along the lines of:
`\bTable<[^(=]*,\s*(List|Set)<.*>> case:yes lang:java`
FWIW, `ValueGraph` has two existing methods that (as far as I can tell) supports the requested need on the read side:
```
Optional<V> edgeValue(N nodeU, N nodeV);  // use with orElse()
V edgeValueOrDefault(N nodeU, N nodeV);
```
But there's nothing on the write side, i.e., `MutableValueGraph.putEdgeValueIfAbsent()` does not exist.  I could imagine adding it but so far no one's asked for it (in that context, at least).  I'm not positive that this can be removed, because it _might_ be being used as a volatile read for memory consistency reasons. It's not commented with `// read-volatile` like some other reads of `count` are and it's slightly weird, but it doesn't seem worth trying to change on its own.
> Serialized forms of ALL objects are subject to change unless noted otherwise. Do not persist these and assume they can be read by a future version of the library.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
You can apply synchronization around any code you need to... I don't see anything special we need to document about Bloom filters.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
See https://github.com/google/guava/issues/384
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
I'm not sure we're ready to accept new features that are dependent on Java 8, in the sense that if you're working with Java 7, this is much less readable than the "conventional" code you would write with a perfectly normal ternary or if statement.
Personally, I feel that `Optional` is a much better way to approach this. `firstNonNull` preceded the existence of our `Optional` class and has the advantage of being very simple to understand. I think when you get into something like this `ifNotNull(T, Function, R)` it becomes much less obvious to readers what you're doing, whereas `Optional.fromNullable(value).transform(function).or(fallback)` is pretty clear.
Thanks for the idea, but I'm fairly certain this isn't an API we want to add, so I'm going to close this. For future reference, if you want to see an API added or changed it's better to start by just opening an issue for discussion of it. Pull requests are better for changes that don't affect the APIs themselves or changes that we've decided should be made and that we'd like a contribution for.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
Not sure what this is for, but we definitely don't want to merge the jdk5-backport branch into master.
We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA ([login here](https://cla.developers.google.com/) to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
<!-- need_author_cla -->
CLAs look good, thanks!
<!-- ok -->
Your example uses Java 8 method reference syntax, but Java 8 already has a solution to this problem that makes ComparisonChain more-or-less unnecessary: you would write
```
import static java.util.Comparator.*;
Comparator<Foo> comparator =
comparing(ThisClass::cheapProperty)
.thenComparing(ThisClass::expensiveProperty);
```
In the absence of Java 8, an existing solution to this problem -- similar to the solution you've already proposed -- is just to write
```
Ordering.natural().onResultOf(function1)
.compound(Ordering.natural().onResultOf(function2))
```
We have an internal disagreement over whether java 8's Comparator upgrades actually make ComparisonChain obsolete; Louis is clearly on that side, but it's not settled.
If we do decide ComparisonChain has lasting value then at this moment I think this seems like a pretty good feature for it.
Dump of notes from our discussion:
boilerplate:
If using ComparisonChain with Compara_tor_, need:
```
new Comparator<Foo>() {
public int compare(Foo left, Foo right) {
...
}
};
```
vs.
If using Java 8 with Compara_ble_, need:
```
return ....compare(this, other)
```
Which is the more common use case? If I'm doing my search right, ComparisonChain is used 2.5x as often with Comparator as with Comparable. Googlers can look at https://paste.googleplex.com/6704089245155328
ComparisonChain saves on allocation if implementing compareTo
do we want compare(object, object, function) or other "best of both worlds" solutions?
former requires you to repeat "left, right, " ever time
do we want ComparisonChain2.on(left, right).compare(function).compare(function2)? but this interferes with the singleton nature and uses unfamiliar tools in comparison to JDK8 methods
thenComparingInt exists (though apparently with a different method name, unlike in ComparisonChain)
lambdas don't work for fields. but how often does this come up? we disagree on this. need numbers.
ComparisonChain failure modes:
1. people write "left.foo" on both sides. We could write an Error Prone check. Internal users can see https://paste.googleplex.com/6193752238456832
2. people write "left.foo" vs. "right.bar"
3. Java 8 is lazy, whereas ComparisonChain only "sounds lazy" -- can even fail with an exception if first checking "is null" and then checking a computed property on that variable
correction: lambdas work with fields, just not method references, but that shouldn't be a problem.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
Thanks for the PR... I've updated this internally along with another change to the README and it should be mirrored out soon.
It's not clear what Guava could offer here that isn't offered in more detail by libraries like fastutil.
I'm not certain such a thing would be even possible while supporting both row and column concurrent access.  Do you have an implementation in mind?
Hmm, we seem to not even have a `synchronizedTable` method.
That'd certainly be doable...
Pull request welcome.
Looks like we have this filed as #1297, too.  I'm looking at the MANIFEST.MF file for Guava 18, and it looks like it's exported there to me. I've highlighted it below with > and **.
```
Manifest-Version: 1.0
Build-Jdk: 1.7.0-google-v6
Built-By: cgdecker
include    utility classes, google's collections, io classes, and much
much more.    Guava has only one code dependency - javax.annotation
,    per the JSR-305 spec.
Bundle-DocURL: https://guava-libraries.googlecode.com/
Bundle-License: http://www.apache.org/licenses/LICENSE-2.0.txt
Bundle-ManifestVersion: 2
Bundle-Name: Guava: Google Core Libraries for Java
Bundle-SymbolicName: com.google.guava
Bundle-Version: 18.0.0
Created-By: Apache Maven Bundle Plugin
Export-Package: com.google.common.net;uses:="javax.annotation,com.google
.common.base,com.google.common.hash,com.google.common.io,com.google.com
ion="18.0.0",com.google.common.html;uses:="com.google.common.escape,jav
ax.annotation";version="18.0.0",com.google.common.collect;uses:="com.go
ogle.common.base,javax.annotation,com.google.common.primitives,com.goog
le.common.math";version="18.0.0",com.google.common.primitives;uses:="co
> m.google.common.base,javax.annotation,sun.misc";version="18.0.0",**com.go
> ogle.common.base;uses:="javax.annotation";version="18.0.0"**,com.google.c
ommon.escape;uses:="com.google.common.base,javax.annotation";version="1
8.0.0",com.google.common.cache;uses:="com.google.common.collect,com.goo
gle.common.util.concurrent,javax.annotation,com.google.common.base,com.
ventbus;uses:="com.google.common.collect,com.google.common.cache,javax.
annotation,com.google.common.base,com.google.common.util.concurrent,com
.google.common.reflect";version="18.0.0",com.google.common.util.concurr
ent;uses:="com.google.common.base,javax.annotation,com.google.common.co
llect,com.google.common.primitives,com.google.common.math";version="18.
0.0",com.google.common.hash;uses:="com.google.common.primitives,com.goo
gle.common.base,javax.annotation,com.google.common.math";version="18.0.
0",com.google.common.io;uses:="javax.annotation,com.google.common.base,
com.google.common.math,com.google.common.hash,com.google.common.collect
ses:="com.google.common.escape,javax.annotation";version="18.0.0",com.g
oogle.common.reflect;uses:="javax.annotation,com.google.common.base,com
.google.common.collect,com.google.common.primitives";version="18.0.0",c
om.google.common.math;uses:="com.google.common.base,com.google.common.p
ons;version="18.0.0"
Import-Package: javax.annotation;resolution:=optional,sun.misc;resolutio
n:=optional
```
Answered on [StackOverflow](http://stackoverflow.com/a/32531498/13792).
@fluentfuture
Previously: https://github.com/google/guava/issues/1899
eamonnmcmanus suggested https://weblogs.java.net/blog/kohsuke/archive/2007/04/how_to_convert.html at that point. I'm not sure whether we had a reason for not doing it that way then.
/cc @cpovirk Any idea who the right owner should be? Besides @fluentfuture, you could try @eamonnmcmanus and @lukesandberg. Hopefully fixed with the commit mentioned above. Please let us know if you still see problems. Sorry, this will be in 22.0.  I am not certain why you would expect useful properties like order independence after hashing to be preserved after putting a set through serialization?
Put another way: serialization _must_ preserve iteration order; that's part of ImmutableSet's contract, that order is preserved.  But it's mathematically impossible, then, for hashing after serialization to be order-independent.  _Something_ must be different in the serialization of {1, 2} and {2, 1}, and at least some hash functions will care about that something.
If you want anything like this to work you must use http://docs.guava-libraries.googlecode.com/git-history/master/javadoc/com/google/common/hash/Hashing.html#combineUnordered(java.lang.Iterable) .  The details of serialization are unspecified to begin with; behavior after hashing the serialized form is always going to be inconsistent.
Fixed.  The problem is just that the project in question was migrated from Google Code to Github.
That link is dead to everyone; it's on Google Code, which is getting shut
page.) The new link on the wiki page should be to the new correct
destination.
On Sat, Sep 12, 2015, 23:22 yzzzd notifications@github.com wrote:
> https://code.google.com/p/memory-measurer/wiki/ElementCostInDataStructures
> This link still can not be opened. @lowasser https://github.com/lowasser
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2150#issuecomment-139846697.
Duplicate of #1070.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
Hi, can you discuss more details about your use case for this method?
Do you actually need an end parameter?  I observe String.indexOf does not have that.
See #475.
This is actually something I'd considered and done some work on at one point. I think the main reason it hasn't been added is that there's a very limited number of situations where you'd actually want this and not something else, and having it there would probably lead to people using it when they really shouldn't. Despite that, it's probably worth considering again.
And mostly likely if it is a CharSource backed by a byte source and you give this the same encoding it's already using, it would skip the round trip.
Oh hey, we added this in 20.0.  Hi,
We already have extensive plans for Java 8 support, but this feature in particular would actively hurt, not help.  Lambdas can already be used with c.g.c.base.Function, and every other single-method interface anywhere.  If we added overloads for two different interfaces -- e.g. our Predicate and j.u.f.Predicate -- that would actively break lambdas; you would have to explicitly cast the lambda to the desired type, which would make the code significantly less readable for everyone.  You would _have_ to write
```
Multimaps.filterEntries(multimap,
(java.util.function.BiPredicate<K, V>) (key, value) -> test(key, value));
```
Even if you do have a java.util.function.Function stored as a constant or returned from a method somewhere, and you want to pass it to a method expecting a com.google.common.base.Function, all you have to write is myFunction::apply.
Or something like that. Right now, if the underlying `Executor` returns `Future` instances that do something interesting on `cancel()` (like free resources), we don't take advantage of it, since we're calling `execute()` all the time.
Are you using Maven or some other dependency-aware build system? If not, you'll need to download [J2Objc Annotations](http://mvnrepository.com/artifact/com.google.j2objc/j2objc-annotations/0.1) yourself.
Agreed, I think it should be enough that we have it in the parent pom.
The value of adding these specializations of `FluentIterable` (particularly for JDK types like `Date` and `Calendar` which people really shouldn't be using) would be extremely minor and the added complexity would be huge. We won't be doing this.
can't be a weak reference, and the view holding a strong reference?  I know
very little about this other than that the goal is to avoid circular strong
references.
On Mon, Aug 24, 2015 at 11:37 AM Keith Stanger notifications@github.com
wrote:
> One strategy is not _better_ than the other. The point is, neither
> strategy is fully _correct_ and we had to chose one. I'm happy to
> reconsider this decision based on your feedback, but this will be done with
> very careful consideration when I have the time to focus on this problem.
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2139#issuecomment-134332661.
> That scenario would result in the collection's reference to the view
> being a dead pointer at some point in the future.
In most cases I believe we'd be okay with that -- it's supposed to be a
cache; it's okay if the view gets deleted.
On Mon, Aug 24, 2015 at 12:06 PM Keith Stanger notifications@github.com
wrote:
> That scenario would result in the collection's reference to the view being
> a dead pointer at some point in the future. Keep in mind we don't
> necessarily have ARC's automatically nil'ed __weak reference semantics, and
> if we did we'd still need to make the necessary modifications to check for
> nil.
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2139#issuecomment-134342830.
Ahhh, got it.
On Mon, Aug 24, 2015 at 12:12 PM Keith Stanger notifications@github.com
wrote:
> It's not okay because the collection will continue to return the same
> pointer after it's deleted. It has no way to detect that the pointer has
> been deleted.
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2139#issuecomment-134344281.
I'm not sure this can be compatibly fixed?  Java 8's approach with the Collector sidesteps some of these issues.
That said, it's relatively trivial to work around this by just using t -> (BaseClass) new SubClass(t)) instead.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
See also past discussion on https://github.com/google/guava/issues/1070#issuecomment-61348831
We actually already have methods for this internally (`of()` and `of(E, E...)`) and are planning to release them soon.
If you're presuming Java 8, then I'm not sure why it wouldn't be easiest to do this yourself:  `(Iterable<T>) () -> Iterators.forEnumeration(tree.preorderEnumeration())` _is_ the `Iterable` you're looking for.
Without saying yes or no yet, some thoughts:
a) It's not clear where a Supplier<Enumeration<T>> would come from that couldn't be changed to provide an Iterable in the first place.
b)
```
((Iterable<MyTreeNode>) () -> Iterators.forEnumeration(tree.preorderEnumeration()))
.forEach(node -> node.doSomething());
```
can also be written
```
Iterators.forEnumeration(tree.preorderEnumeration()))
.forEachRemaining(node -> node.doSomething());
```
...without bringing `Iterable` into it at all.
You say that you're seeing logging "if one future fails." Can you confirm that? My understanding of [the code](https://github.com/google/guava/blob/6221f96f36240f5b0296ec2910306ac326af3590/guava/src/com/google/common/util/concurrent/AggregateFuture.java#L185) is that we log only if:
- any input fails with an `Error`
or
- You called `allAsList`, and _more than one_ input failed, and the failures were different exceptions
The logging is still not great, but as a starting point, let's figure out if there another bug on top of it :)
OK, let's start with the error message. What would you think of something like this?
> Got more than one input Future failure. Logging failures after the first
@lukesandberg now, since I'll end up sending him the CL to make this change. Luke, what do you think of the message I propose in my previous post? (I will make it conditional so that we say something different for an `Error`.)
(I'm ignoring the larger logging issue for the moment.)
An improvement to the log message might be able to be included in release 19 if we want. The underlying problem of having too much logging requires more thought, so I wouldn't expect anything until at least release 20. Sorry :(
Oh! I was thinking that this was one of the recurring methods, for which the return value is always `null`, anyway. Thanks. I'll see what we can do.
Thanks for the investigation.
For starters, we should document that this "decorator" doesn't always forward calls to the corresponding methods.
Going beyond that is likely to be tricky. Is there any chance that your `schedule(Runnable, ...)` method could check whether the input is already a `Future` and avoid wrapping in that case?
OK, it looks like we do document this:
> Creates an ExecutorService whose submit and invokeAll methods submit ListenableFutureTask instances to the given delegate executor. Those methods, as well as execute and invokeAny, are implemented in terms of calls to delegate.execute.
http://google.github.io/guava/releases/18.0/api/docs/com/google/common/util/concurrent/MoreExecutors.html#listeningDecorator(java.util.concurrent.ExecutorService)
It's possible that we could change that behavior, but I'm not sure what the implementation would look like. It seems like what you ultimately want is for the `Future` returned by the delegate to match the `Future` returned by the decorator, but keeping two `Future` instances in sync is something that's impossible to guarantee in general. We could maybe get it closer, and that might be good enough in your case, but we already have a workaround there, so I hesitate to complicate things. (I think we've already had bugs in `listeningDecorator`.)
This was definitely a behavior change from 14 to 15. We should have put this in our release 15 release notes. I've gone back and done so, but of course this is of much less help to you now :( That's probably the best place to put it, at least, since anyone upgrading is more likely to read it there than the Javadoc.
> `ListeningScheduledExecutorService` now returns the new `ListenableScheduledFuture` type from its `schedule*` methods. To implement this, methods on `MoreExecutors.listeningDecorator` executors have been changed to no longer directly call the corresponding methods on the delegate. For example, the decorator's `schedule(Callable, long, TimeUnit)` now calls the delegate's `schedule(Runnable, long, TimeUnit)`.
It looks like this happened in https://github.com/google/guava/commit/fc6a72e81f6cbf81de64105105f296f0c84abdd0, the commit that made `ListeningScheduledExecutorService` actually return `ListenableFuture` from the `schedule*` methods.
I started on this, but the `audio/L24` one is interesting because our MediaType class requires that all subtypes be lowercased. I didn't dig too much into it, but I suspect we do this for normalization (e.g., "image/gif" and "image/GIF" are treated as equal).
Maybe we shouldn't do this though? I'm not really sure. Any thoughts @gk5885 ?
> All portions of the media type that are case-insensitive (type, subtype, parameter attributes) are normalized to lowercase.
So I wonder if we can just define it as:
`createConstant(AUDIO_TYPE, "l24");`
And @cpovirk points out:
> Both top-level type and subtype names are case-insensitive.
via https://tools.ietf.org/html/rfc6838#section-4.2
Let's just add it as l24, lower-case. I don't see anything to worry about there.
We're handling the first 11, but if you want to add these others, would you be willing to send us a pull request?
From what I can tell, the attempt to fix this in commit bb5673f60ce9dcda1c228b0d0e2ce2485468f965 didn't work. I tried the sample program provided and am still seeing the issue. I'm looking into it now.
So, the `count != 0` check doesn't seem to have any bearing on the behavior here, because the `count` being incremented is only an indicator that the loaded value has been stored (that is, that the entry's `LoadingValueReference` has been replaced with a `StrongValueReference`, in this case.) Even with the check removed, the code ends up calling `LoadingValueReference.get()`, which returns `null`.
The general issue seems to be that `get[Unchecked]` is allowed to return as soon as it can get the loaded value. Meanwhile, the thread that's actually doing the loading gets the loaded value and then must _store_ the loaded value. Meanwhile, other threads that were waiting on the value loading can call `getIfPresent`, racing with the storing of the value.
I can see a couple possible ways to fix this:
1. Don't let threads blocking on the loading of the value see the value until it's been stored. This seems like (potentially?) a fairly invasive change, though I haven't tried it yet.
2. `LoadingValueReference.get()` could be changed to check if its `futureValue` future is done, returning the value from it if so on the assumption that the value, having loaded successfully, is in the process of being stored. This is a very simple change and fixes the issue for the example program given, but I'm not certain it's a correct change.
I'm going to spend a bit more time looking at this today, but I'm likely going to push any changes back to 20.0 since this isn't a simple matter of removing a `count != 0` check.
I've got a solution in the works... it looks like it's not TOO invasive to make blocking gets only return after the value has been stored.
Thanks for filing the bug!
`ClassPathTest` is a pretty clear case of our assuming that we're running on a Linux-style filesystem. `ThrowablesTest` is more interesting -- probably a bad assumption that newlines are always represented by `\n`.
@cgdecker @cgruber Do we have any way of running our tests regularly on Windows? These shouldn't be hard to fix, but it would be good to have an easy way to test them and a way to make sure errors won't creep back in.
Sure, we are really not Windows-enabled here, so we would greatly appreciate any patches.
I think "jbduncan got," as in "You influenced the Error Prone team to do it." In either case, the idea is that we now have an example of how to do this by another team at Google that we know well, so Guava might be able to adopt it more easily, too.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
> RegularContiguousSet.equals() does not use Sets.equalsImpl() either but instead compares the DiscreteDomain and first+last.
_could_ provide
an efficient hashCode() specialized for their type.
e.g. in Integers, Range.closed(0, n).asSet().hashCode() == n \* (n + 1) / 2,
and all that.  Even if the implementation still had to loop it could still
This would be fun programming but... not sure whether
ContiguousSet.hashCode() is called enough to be worth worrying about or not.
On Tue, Aug 11, 2015 at 10:00 AM, rcpoison notifications@github.com wrote:
> @lowasser https://github.com/lowasser: Of course you're right :/ Sorry,
> should've thought harder.
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/pull/2129#issuecomment-129968386.
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
Not sure I would close this yet. Given how awful what this method does really is, caching the result might be a very good idea.
Bulk closing all pull requests that are listed as needing CLA signing. If you'd like us to look at your pull request, you'll need to sign the CLA and report back here.
I know it's generated and my IDE can download it from Maven Central (and it does), but the rendered window is intended to help **understanding** but not **learning**. A proper browser can do that.
I didn't know about any of those two links. They're very helpful and answer exactly my request, thank you! What about putting a link in the README.md towards one or the other link?
javadoc.io is quite cool... I do think we should probably try to get the Javadoc for it up on our site as well though.
I don't particularly care about the badge, though we could reconsider all the badges we want to use and how to arrange them at some point (there are a lot of choices).
I would still perhaps like to get testlib included in the Javadoc we host on the gh-pages branch... unfortunately the current path structure for the Javadoc (`/releases/18.0/api/docs/`) doesn't lend itself especially well to handling multiple artifacts... it probably should have been `/releases/18.0/guava/api/docs/`. Still, I don't really want to change that URL and it's probably not _too_ weird to keep that URL and use `/releases/18.0/testlib/api/docs/` for testlib Javadoc.
Thanks, this should all be fixed now.
In some cases, if you're interested in constructing a `Map` more concisely, you can probably build the inverse `Multimap` and then invert it. Something like this:
```
private final ImmutableSetMultimap<Class<?>, Randomizer> RANDOMIZERS = new ImmutableSetMultimap.<Class<?>, Randomizer>builder()
.putAll(byteRandomizer, byte.class, Byte.class)
.putAll(shortRandomizer, short.class, Short.class)
.putAll(collectionRandomizer, Collection.class)
.build().inverse();
```
- This returns a `Multimap`, not a `Map`. You can call `getOnlyElement(RANDOMIZERS.get(...))`, or you could use a `Multimap`-to-`Map` converter. I don't think we have one before JDK8.
- This won't work if you need arbitrary predicates, as it sounds like you do.
So it probably doesn't work for you. But I think it will eat away at the users of a utility like this. In your case, you probably are better served with `if`-`else`. (`if`-`else` also gives you a way to break "ties" in which multiple `Predicates` would match, for better or for worse.)
Merged. Thanks, Ben.
If possible, I'd strongly recommend using Java 7's file API for this. If you have a `Path`, calling [`normalize()`](http://docs.oracle.com/javase/7/docs/api/java/nio/file/Path.html#normalize%28%29) on it will simplify the path for you in a file-system dependent way. We should actually probably consider removing `Files.simplifyPath`.
I think we can probably do this. You should be seeing a version that's current as of May 15, is that correct?
This is done (possibly not mirrored out yet, but will be).
Done in https://github.com/google/guava/commit/2b8b6fd9f3da35b0a7c28316a8167092bafd6179
Note that we have since done _another_ update in https://github.com/google/guava/commit/3a604328c28919480caea60e754debb8ec84b75b. That one may or may not make release 19.
**Related**: This issue came out of #2118.
**Proposal**: Introduce `MinMaxPriorityQueue#builder` to adhere to the above principle. Currently the API is somewhat unclear how the builder works. Is there a reason why the builder method doesn't exist?
The big problem with MMPQ is that it's very rarely used and most of the time when it is used, a careful reading of the Javadoc would have told the user something better. It's an extremely niche utility, and we're unlikely to spend time improving it futher - sorry.
To be honest, I'd guess the most likely thing we would like to do with MinMaxPriorityQueue is deprecate it and schedule it for deletion rather than expand it.  As Kevin said, most of the time when it is used, there is something better, and in the past we've tended to delete APIs that are used incorrectly more often than not.
Thanks. I take it that our `<optional>true</optional>` dependencies on various projects' annotation artifacts aren't a problem here?
@netdpb any ideas? We do have `proguard.cfg` files internally. We've just never published them :( Shouldn't be too hard. I will make myself a note for when I'm finished with my current project (probably a couple weeks, or maybe I'll need a small project before then).
(We'll still want to do the `aar` setup eventually, but that will be a bigger project. Or maybe someone can provide a pull request once the files are actually present.) Ended up needing to take on another project, so I've delayed working on this again, sorry. It's still on my list.  This is a classic symptom of classpath conflicts.  Please ask Hadoop to follow the "important warnings" on https://github.com/google/guava.
Maps.transformValues, and the rest of Guava's transformation methods, deliberately provide _views_ -- not copies of the original collection, but views -- that can be supported efficiently.  Mapping keys cannot be supported efficiently as a view.
It can, but we found that few bidirectional mappings are completely one-to-one, and when they're not we end up with weird behavior.
Anecdote: We once introduced `Sets.transform`, implemented with a bidirectional mapping. We kept it private because we were worried about misuse, using it only in one carefully selected implementation. Then, months later, we discovered... our mapping wasn't one-to-one, and we had a bug as a result :)
One thing that we could consider, though, is a `MapStream`/`EntryStream` (https://github.com/google/guava/issues/2632). There, it would make sense for us to provide a `mapKeys` method that, unlike our existing `transformValues`, etc. methods, would be applied as a one-time mapping, not as a live view.
(It would be nice if we could remove the live-view methods entirely someday (which also might save us from having to come up with a name for the versions that accept `java.util.Function` instead of `c.g.c.base.Function`). But the migration from live views to one-time computation has the potential to break people.)  I agree with @lvxiang in the sense that usually people have a set of constraints and want to generate strings according to those sets of constraints, without having to redefine them everywhere.
You can have something like a step-based mechanism in which you first define/compile constraints and then you can fastly generate strings based on those constraints.
Answers saying that you can "simply" store your string of acceptable characters discard the need for modularity, reusability and ease. The "simply" is only the core of the issue and a lot can be done around it to make it better for the developer. It's like reinventing the wheel all over again: we want to avoid that in development ;)
Therefore, all I can recommend today is to check the library [Passay](http://passay.org/) or, without trying to put any light on it, [my modest take on the problem](https://github.com/ogregoire/password-tools/tree/master/password-rule).
With these libs, you can declare which generator you want and then generate as much as you want very very easily.
@lvxiang Well, I'm glad you like it. If you have suggestions, please file an issue there and let's continue this conversation there as well.
It's not the only metric, but it's an important one.  Utility is the other primary consideration, and obviously the difficulty of implementing a correct solution is an aspect of that.  We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA ([login here](https://cla.developers.google.com/) to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
<!-- need_author_cla -->
CLAs look good, thanks!
<!-- ok -->
We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA ([login here](https://cla.developers.google.com/) to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
<!-- need_author_cla -->
CLAs look good, thanks!
<!-- ok -->
We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA ([login here](https://cla.developers.google.com/) to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
<!-- need_author_cla -->
CLAs look good, thanks!
<!-- ok -->
Sorry for how long this has taken, @berndhopp.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
We found a Contributor License Agreement for you (the sender of this pull request) and all commit authors, but as best as we can tell these commits were authored by someone else.  If that's the case,  please add them to this pull request and have them confirm that they're okay with these commits being contributed to Google.  If we're mistaken and you did author these commits, just reply here to confirm.
<!-- need_author_consent -->
I think the bit you're looking for in the docs is
> Certain cache configurations will result in the accrual of periodic maintenance tasks which will be performed during write operations, or during occasional read operations in the absence of writes. The Cache.cleanUp() method of the returned cache will also perform maintenance, but calling it should not be necessary with a high throughput cache. Only caches built with removalListener, expireAfterWrite, expireAfterAccess, weakKeys, weakValues, or softValues perform periodic maintenance.
In short, the cache accumulates tasks like passing expired entries to the removal listener and only occasionally performs accumulated tasks every so often on other cache operations.  You can explicitly call `cleanUp()` to force cache maintenance.
Yep, that can happen.  (Actually, what happens is that the get call itself discovers that the entry is expired and adds it to the queue of entries to be cleaned up.)  Calling `cleanUp()` will take care of that maintenance work.
I'm not sure what you mean there.  Expired entries are never returned by get queries, but they can still be in the cleanup queue.
I'm not sure what exactly you mean?  If you want to get them out of the cache, the only way is to receive them in a RemovalListener.
Correct.
The point is controlling the amount of work done on any one normal cache operation, which is important for maintaining consistent performance.
It sounds like your needs are sensitive enough to not fit into the common case Ben described.  Guava's cache balances the needs we've found most common to most of our applications at Google, but it's genuinely possible that your needs are different.
I'm not sure if there are any obvious documentation improvements to be made; I thought the CacheBuilder documentation explaining how cache maintenance was performed was fairly unambiguous.  But I think these are the semantics that best serve the majority of our users.
This is the intended behavior that gets the best balance for the majority of our use cases, even if not for your specific use case, and the docs are already relatively clear about this behavior.
Following #2102 which was closed and not commented upon, calling `flush()` on the stream returned by `BaseEncoding.encodingStream(...)` should flush its internal state.
Here's the failing test case:
``` java
import static com.google.common.base.Charsets.US_ASCII;
import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.is;
import static org.junit.Assert.assertThat;
import com.google.common.io.BaseEncoding;
import org.junit.Test;
import java.io.IOException;
import java.io.OutputStream;
import java.io.StringWriter;
import java.io.Writer;
public class BaseEncodingTest {
@Test public void encodingStreamFlushShouldFlushInternalState() throws IOException {
Writer writer = new StringWriter();
try (OutputStream encoder = BaseEncoding.base64().encodingStream(writer)) {
encoder.flush(); // does not flush its internal buffer/state.
writer.write(" there should be nothing past this ");
}
assertThat(writer.toString(), is(equalTo("YWI= there should be nothing past this ")));
}
}
```
The current behavior is working as intended relative to my understanding of
the semantics of flush().  Specifically, I expect that
```
try (OutputStream o = anything) {
o.write(bytes1);
o.flush();
o.write(bytes2);
}
```
should always result in the same output as
```
try (OutputStream o = anything) {
o.write(bytes1);
o.write(bytes2);
}
```
In other words, I expect flush() to write any intermediate buffers to the
output stream destination but never to change the actual bytes that are
written.
On Wed, Jul 15, 2015, 07:49 Olivier Grgoire notifications@github.com
wrote:
> Following #2102 https://github.com/google/guava/issues/2102 which was
> closed and not commented upon, calling flush() on the stream returned by
> BaseEncoding.encodingStream(...) should flush its internal state.
>
> Here's the failing test case:
>
> import static com.google.common.base.Charsets.US_ASCII;import static org.hamcrest.Matchers.equalTo;import static org.hamcrest.Matchers.is;import static org.junit.Assert.assertThat;
> import com.google.common.io.BaseEncoding;import org.junit.Test;
> import java.io.IOException;import java.io.OutputStream;import java.io.StringWriter;import java.io.Writer;
> public class BaseEncodingTest {
>   @Test public void encodingStreamFlushShouldFlushInternalState() throws IOException {
>     Writer writer = new StringWriter();
>     try (OutputStream encoder = BaseEncoding.base64().encodingStream(writer)) {
>       encoder.flush(); // does not flush its internal buffer/state.
>       writer.write("cd");
>     }
>     assertThat(writer.toString(), is(equalTo("YWI=cd")));
>   }
> }
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2109.
Well, Okay, maybe `.flush()` isn't the problem.
@swankjesse Of course, 2 bytes is only to show the issue at hand. Run the test case, remove the `flush()` call if you want, you'll see the error. An output of exactly 10 KB, 10 MB, 10 KiB or even 10 MiB can never be divided by 3, but this only showcases the base issue, which is that I don't have the hand on the underlying stream.
So after I write x bytes where x % 3 != 0, I have the following problem:
- If I close the stream, the underlying stream is closed as well and I cannot append anything
- If I keep the stream open and write after it, I get the final base64 characters written _after_ my own text.
I could buffer the whole base64-ed string in an array, but then what's the point of the method encodingStream then?
I've never had the issue because in my application I've always used inputs of 30 KB or multiples of it. But the issue #2102 showed me that my code is vulnerable to this problem.
@lowasser I know you don't like creating new classes, but this use case is a real one where the functionality is not entirely thought, I believe. And creating an EncodingOutputStream becomes a necessity then, if you don't like the `flush()` idea as I suggested.
But you have to admit that the test case, flush or no flush, fails. So there must exist a way to take the control back on the underlying stream while still saying to the encoding stream that I want my base64 to be done with.
Mistakenly closed the issue, sorry.
Compare [Louis's statement above](https://github.com/google/guava/issues/2109#issuecomment-121686756) to this warning in the [`Escaper`](http://google.github.io/guava/releases/18.0/api/docs/com/google/common/escape/Escaper.html) Javadoc:
> Because, in general, escaping operates on the code points of a string and not on its individual `char` values, it is not safe to assume that `escape(s)` is equivalent to `escape(s.substring(0, n)) + escape(s.substing(n))` for arbitrary `n`. This is because of the possibility of splitting a surrogate pair.
But I think this has come up in the context of streams before, too. It does at times seem like we need a special `EncodingOutputStream`. (In its absence, I've heard people suggest something like `encoder = encodingStream(nonClosePropagatingOutputStream(stream)); ...; encoder.close(); // do more with stream`.) Maybe we would benefit from having one, but I don't know how complicated the design would become or where it would fit in our priorities.
It does seem like we could use some way to _finish_ encoding some data to a stream (adding padding if needed) without closing the underlying stream. Using a wrapper that doesn't close the stream doesn't seem ideal.
We could do that if we needed to.  There's some precedent in GZIPInputStream (http://docs.oracle.com/javase/7/docs/api/java/util/zip/GZIPOutputStream.html#finish()); I'm just somewhat resistant to the API change without more thinking about the demand.
Are your caches _really_ big? I see we do some summing up of segment sizes in a loop - maybe we are overflowing Integer.MAX_VALUE?
Is it enough to max(0, entireSize) or should it be done to each individual segment count?
Patch submitted internally; that should make it out into the next RC.
We are almost certainly never going to make this class public. It's extremely rare to do what you're trying to do and most users in that case can even use ForwardingTable.
I'm not sure what your ultimate goal is here, but you might want to post details to Stack Overflow and get advice on the best way to go about it.
Thanks. We'll get this merged shortly.
I believe that you can find all the information you want on the [ReleaseHistory](https://github.com/google/guava/wiki/ReleaseHistory) wiki page.
https://github.com/google/guava/wiki/ImmutableCollectionsExplained#why refers to https://code.google.com/p/memory-measurer/wiki/ElementCostInDataStructures (link text: analysis), which doen't exist anymore.
The old equivalent https://code.google.com/p/guava-libraries/wiki/ImmutableCollectionsExplained#Why? also points to that same broken link.
Actually, I'll reopen this. The documentation links need to be updated.
Yeah, we do need to update our link. Also, we should perhaps consider making a copy of that page so that it can be viewed as rendered markdown rather than as text.
I think this is fixed?
I'm not sure why you think that InPredicate.equals is required to hold for collections that are not equal by Collection.equals.  The predicates are equivalent, sure, but I don't believe there's any requirement for the predicates to actually be equal.
Look at the doc of Predicate.equals:
> Most implementations will have no reason to override the behavior of Object.equals(java.lang.Object). However, an implementation may also choose to return true whenever object is a Predicate that it considers interchangeable with this one. "Interchangeable" typically means that this.apply(t) == that.apply(t) for all t of type T). Note that a false result from this method does not imply that the predicates are known not to be interchangeable.
Looking at the [Javadoc](http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/io/BaseEncoding.html#encodingStream%28java.io.Writer%29), it already says
> When the returned OutputStream is closed, so is the backing Writer.
This behavior is consistent with just about every other stream wrapper I'm aware of -- BufferedReader/Writer, InputStreamReader/OutputStreamWriter, ObjectInput/OutputStream, and so on, all close their backing streams when you close the outer stream.
I'm not sure what documentation or implementations changes you think would be reasonable here?
The problem, Louis, is that the `BaseEncoding::encodingStream::close` method writes on the underlying stream. And that is an unexpected behavior.
For instance, I used the following code:
``` java
String lineSeparator = System.lineSeparator();
BaseEncoding encoder = BaseEncoding.base64().withSeparator(lineSeparator, 64);
byte[] bytes = "{\"en_US\",0,0,\"\",-1,\"\",\"\",\"\",\"\"}".getBytes();
ByteArrayOutputStream writerStream = new ByteArrayOutputStream(100);
try (Writer writer = new OutputStreamWriter(writerStream);
OutputStream target = encoder.encodingStream(writer)) {
try (ByteArrayInputStream stream = new ByteArrayInputStream(bytes)) {
ByteStreams.copy(stream, target);
}
writer.write("\n}, other text to be written");
}
System.out.println(new String(writerStream.toByteArray()));
```
This results in the following:
```
eyJlbl9VUyIsMCwwLCIiLC0xLCIiLCIiLCIiLCIif
}, other text to be writtenQ==
```
`BaseEncoding::encodingStream` should definitely return a custom stream (`EncodingOutputStream`?) where **we** can say "I'm done with encoding, flush your current state" -- though calling `flush()` would also be inappropriate -- and if we don't say "I'm done with encoding", the current behavior applies.
I was under the impression that this was still consistent with built-in JDK stream wrappers, some of which required close() to finish up the stream (and closed the underlying stream) at the same time.  I'd very much prefer to avoid creating new types if at all possible.
You haven't?  http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/java/io/BufferedWriter.java#265  Line 265 does it.
That try-with-resources block `try (Writer w = out) {` will close the backing writer, too.
@lowasser The ticket is now closed but I still believe that the use case I underlined is totally appropriate, even if you're reluctant to create new types. I re-read `flush()` carefully and it actually might be appropriate to call it. Should a new ticket be opened?
If you (or anyone else) has a patch for this particular issue, we would love to accept it, I think; this looks like a valid bug.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
Note that Java 8 added some unsigned type support, so I'm not sure we want to further expand Guava in this area.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
Committed: https://github.com/google/guava/commit/ee50c94031ae9449d52802d03241791cc2964194
Thanks!
I'm afraid this is not a use case that Guava's BloomFilter support will be addressing. Most of our users by far have far less extreme requirements.
This should be fixed now.
Is this still broken?
This is difficult without a DiscreteDomain.  Your current implementation would treat [0, 1) and (0, 1] as overlapping, even though there aren't actually any integers in their intersection.
I see 32 hits in Google code for `isConnected[^;{}]*intersection[^;{}]*isEmpty` (PCRE:yes, exclude `com/google/common/collect`). I wonder if these are worth a look, either as evidence for the usefulness of the method or evidence that the approach is bug-prone.
This should be fixed in 19.0.
Internal CL 96698287 is about to add `@Weak` and `@WeakOuter` annotations to `common.collect`, mostly its collection views, so that reference-counted j2objc environments can use the collections without reference cycles. I'd like to think that we can do better:
- Do does caching collection views really save resources? They're always(?) "immutable" objects with just a reference back to the collection as a whole (and maybe another object or two, like how `Multimap.get(key)` needs to store `key` in the returned collection). These are fast to allocate -- for all we know, faster than following the reference to an existing view (not cache friendly? tough on branch prediction? Who knows?).
- Of course, allocation can be bad on Android. But the amount of allocation is likely tiny, and anyway, it comes during a time that users are already likely to be allocating: Calls to, say, `keySet()` are usually(?) followed by a call to `iterator()`. And maybe Android benefits on net because the main collection object is now slightly smaller and because the views can go away quickly. And maybe we can penny-pinch some helper methods. But I think the most likely outcome is no discernible effect.
- Caching collection views adds a small amount of complexity. We've gotten our lazy initialization wrong in the past, in theory opening users to `NullPointerException`. We have places where we have to do things like override `createDescendingSet()` to throw `AssertionError` because we're actually overriding `descendingSet()` directly. (Hmm, the blame might not lie with caching here exactly. I'd need to think about it more.)
- Going back to the j2objc situation: The added annotations prevent memory leaks, but they also have the potential to create problems with object lifecycles. We hear that this is rare, but wouldn't it be nice if it were impossible?
@lowasser (This isn't a high priority, but it seems likely to be something you've thought about.)
I'm told that j2objc could conceivably have an annotation that "turns off" the caching:
> we'd probably want a special annotation that can be applied to the cache field so that J2ObjC strips all uses of it and assumes `null` wherever its value is read. This is probably do-able, especially if you feel the cache fields are providing little value.
I'd love if we could wipe out the caching entirely, though.
Some of what I've thought about is -- as far as Android goes, sure, allocation is bad.  But what we've been told in more detail is that allocation during the draw loop is bad, because e.g. allocating while users are scrolling makes you GC at a time when the user is directly interacting with the app.
But conversely, caching collection views means you allocate once and never again.  You're not allocating over and over; you're not filling up the memory until you hit garbage collection.
That said, caching a view collection that itself allocates when used -- e.g. caching an entrySet when you're allocating an Entry every time you iterate -- doesn't seem likely to win.
Are you looking for `RangeSet.span()`?
It's not immediately clear to me, I confess, what your objection is to the simple for loop of repeatedly calling `Range.span`?
You can use `AbstractFuture`, which does everything `SettableFuture` does but is extensible.
Do all the other tests pass?
IIRC, we've made a best-effort attempt to block patterns with zero width from working at all, because no matter what we did, something reasonable-looking wouldn't work.
Previous discussion on the subject in https://github.com/google/guava/issues/1190
Sorry for dropping this. We ended up accepting https://github.com/google/guava/pull/2615 instead (for no good reason).
Similar to what we've done for `Lists.newArrayList()` and friends.
Otvio, the proposal is only to discourage them in the similar fashion to
how we already do Lists.newArrayList():
_Note for Java 7 and later:_ this method is now unnecessary and should be
treated as deprecated. Instead, use the ArrayList constructor
directly,
On Sun, Jun 21, 2015 at 10:16 PM, Otvio Garcia notifications@github.com
wrote:
> we can think in this when Guava requirements when updated to Java 7.
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2085#issuecomment-114008469.
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
See also my fears at https://github.com/google/guava/issues/2079#issuecomment-117189783 about Proguard problems resulting from the implementation in terms of `MapMaker`. Things don't seem to be as bad as I expected, but it might be enough that we should change the implementation.
It seems to me like we already have sort of what you want, in `Equivalence`.  You can't plug an `Equivalence` directly into `MapMaker` -- that was rejected in https://github.com/google/guava/issues/576, with the justification
> I know that many people want this, but we have come to the conclusion that Java's collection APIs are not cut out for this. Josh was right to leave this functionality out. We recommend you just pay the extra cost of the EquivalenceWrappers, just as we use Strings instead of char[]s. This will lead to less surprising code.
What you can do, easily enough, is use the `Equivalence.Wrapper` to wrap your byte arrays, which works just fine.  (Or you can create your own class directly wrapping the `byte[]` and implementing your `hashCode` and `equals` as desired.)
Our usual suggestion in this case is to use a class like [`ByteString`](https://github.com/google/guava/issues/1281) instead of a `byte[]`.
We expected the more general feature of a pluggable `keyEquivalence` to be useful, but we found that [it wasn't providing much value](https://github.com/google/guava/issues/940#issuecomment-61342592).
(I see that Louis has posted while I'm typing, but conveniently, there seems to be almost no overlap between our responses.)
`ImmutableList.of()` says this:
> Returns the empty immutable list. This set behaves and performs comparably to `Collections.emptyList()`, and is preferable mainly for consistency and maintainability of your code.
The use of the phrase "the empty immutable list" suggests that this method always returns the same object, as indeed it does. But this is implied only by the use of the definite article and the reference to `Collecitons.emptyList()`. It would be better to state it more explicitly. By comparison, `Collections.emptyList()` itself says this:
> Implementation note: Implementations of this method need not create a separate `List` object for each call. Using this method is likely to have comparable cost to using the like-named field. (Unlike this method, the field does not provide type safety.)
Of course the same applies to the other empty-collection methods.
Yes, this seems worth noting. We use `<b>Performance note:</b> ...` for things like this.
I'm surprised that we haven't heard about this from internal Eclipse users. Thanks for pointing it out.
We might as well got off raw types where we can. I've found another approach that I'll submit shortly.
It seems that the bug is new in the Eclipse compiler since the introduction of support for Java 8. I'm guessing internal users who might have looked at this code with Eclipse aren't on a version with that support yet.
I think that's similar enough to count as "comparably," since code should typically not depend on the specific type of `RuntimeException` thrown. We probably avoided the word "identically" for reasons like the one you mention.
As for the question you added about "Returns **the** empty immutable [list/map/set]": That's our way of saying that the instance is a singleton so that you know you can call the method without allocating.
I'll note that it isn't a question of the particular exception thrown, but that `Collections.emptyList()` doesn't throw an exception at all for `clear()` (or for `remove` or `removeAll`). I agree that this still fits the description "comparably", though. It is also consistent with the method signature, which suggests an immutable list that happens to contain no elements rather than a special kind of list. So you would expect it to behave the same for `clear`, `remove`, etc. Those methods in `ImmutableList` throw an exception whether or not they would have an effect on the list contents.
The behaviour of `Collections.emptyList().clear()` is unspecified. Indeed, this text from the `Collections` class doc suggests that that is deliberate:
> The "destructive" algorithms contained in this class, that is, the algorithms that modify the collection on which they operate, are specified to throw `UnsupportedOperationException` if the collection does not support the appropriate mutation primitive(s), such as the `set` method. These algorithms may, but are not required to, throw this exception if an invocation would have no effect on the collection. For example, invoking the `sort` method on an unmodifiable list that is already sorted may or may not throw `UnsupportedOperationException`.
So code should not be relying on this behaviour anyway.
Oops, thanks for the correction, amonn.
Can you open a separate issue about documenting that the no-arg methods return a singleton?
I was going to open an issue about documenting singletonness, but in fact the existing documentation says "behaves and performs comparably to `Collections.emptyList()`", and the documentation for `Collections.emptyList()` says "Using this method is likely to have comparable cost to using the like-named field". Together those two statements already imply that this method returns a singleton object.
I don't see how `ImmutableList.of()` could "perform comparably to `Collections.emptyList()`" if it didn't return a singleton. However, since I had already written the bug report, I've gone ahead and submitted #2083 anyway.
Looks like this was added to Mozilla's list:
```
// design : 2014-11-07 Top Level Design, LLC
design
```
I looked at ~30 callers of `Futures.dereference`, and about a third of them were implementing something like this. (A lot of the rest were doing `dereference(transform(...))`, which should be `transformAsync(...)`, so the `submit` case might be the majority of "good" use cases.
There was at least one person writing `dereference(schedule(...))`, so `dereference` may yet have reason to live.
@lukesandberg adds: "I guess we could create an `TrustedListenableFutureAsyncTask` that calls `setFuture` instead of set much like the difference between `transform` and `transformAsync`."
Also, I'm wondering if `submitAsync` is a better name, given that (IIRC) all our other `AsyncFunction`/`AsyncCallable` methods have the `Async` suffix (albeit to keep them from being overloads of the `Callable` versions, which isn't a concern here).
We should also decide whether `MoreExecutors` or `Callables` is a better place for this. I would think `MoreExecutors` (home of `invokeAnyImpl`, the closest analog to this method).
@lukesandberg also suggests that we may want `submit(Executor, Callable)` for users who have an `Executor` rather than an `ExecutorService`. Currently these users have to use `ListenableFutureTask` manually. (And I have some thoughts about that, which I've dumping in a posting on similar issue #1989.)
People also call `dereference(ScheduledExecutorService.schedule(task))`, so we may need to provide a method for that, too.
I think my March 22 comment may be saying something that was already covered by my initial report :)
Anyway, it appears to be possible to hack around that problem by writing `executor.schedule(doNothing()).transformAsync(ignored -> executeTheTask(), executor)` -- or perhaps other formulations, but at least one tempting one, `executor.schedule(task).transformAsync(x -> x, executor)`, is not going to propagate cancellation in some cases, much like the current `dereference` version is not!). But we could also consider adding `MoreExecutors.scheduleAsync(ScheduledExecutorService, long, TimeUnit, Callable)`.  `AbstractMapBasedMultiset` isn't a public type. The `add(E, int)` method is defined in `Multiset.java`, which specifies:
```
this operation would result in more than {@link Integer#MAX_VALUE}
occurrences of the element
```
workaround?
ImmutableMap.builder()
.put(k1, v1)
.put(k2, v2)
...
.build()
shouldn't be that awkward.
On Sun, Jun 7, 2015 at 6:38 AM Maik Riechert notifications@github.com
wrote:
> I'm using ImmutableMap for building structures that I can then
> automatically serialize to JSON, like the following adapted from
> http://json.org/example:
>
> Map j = ImmutableMap.of(
>         "id", id,
>         "title", title,
>         "debug", "on",
>         "window", ImmutableMap.of(
>                 "title", "Window title",
>                 "name", "window_1",
>                 "width", 500,
>                 "height", 500
>                 )
>         );
>
> Coming from Python where JSON can be used in source code as-is, the above
> make it any better, syntax-wise. However, I hit the limit of the maximum 5
> key-value pairs of ImmutableMap::of, and then I had to use rather ugly
> workarounds (with Builder or alternatively splitting a big Map up into
> two and joining them together again...).
>
> I fully understand that there is no variable arguments overload like in
> ImmutableSet::of -- you couldn't guarantee at compile-time that the
> number of ImmutableMap::of arguments is even (to form key-value pairs),
> it would fail at run-time, and we don't want that.
>
> I also understand that there probably is some resistance in providing a
> high number of overloads. However, I still think the limit of 5 entries is too
> low https://stackoverflow.com/q/9489384/60982. And resorting to Builder
> is just plain ugly in some cases. I therefore propose to raise the number
> of overloads to 10, as this should cover most use cases and will create
> less headache for users. On the implementation side it is a trivial change
> and I don't see any problem.
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2071.
It may help us to generate a histogram of how many entries people are putting in their ImmutableMap.builder().....build() statements.  Maybe there will be clear evidence.
refaster-matcher-hits-Entry6    N
refaster-matcher-hits-Entry7    0.7 N
refaster-matcher-hits-Entry8    0.63 N
refaster-matcher-hits-Entry9    0.39 N
refaster-matcher-hits-Entry10   0.32 N
Kurt, can we get that compared for entries <= 5 so we know how sharp the
dropoff is after that point?
On Thu, Jul 30, 2015 at 12:42 PM Kurt Alfred Kluever <
notifications@github.com> wrote:
> refaster-matcher-hits-Entry6 N
> refaster-matcher-hits-Entry7 0.7 N
> refaster-matcher-hits-Entry8 0.63 N
> refaster-matcher-hits-Entry9 0.39 N
> refaster-matcher-hits-Entry10 0.32 N
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2071#issuecomment-126451572.
Yep, I'm running that right now...sorry, I should have included that last time.
For those you'll have to sum up the builder-style and the of() calls, yes?
On Thu, Jul 30, 2015 at 12:47 PM, Kurt Alfred Kluever <
notifications@github.com> wrote:
> Yep, I'm running that right now...sorry, I should have included that last
> time.
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2071#issuecomment-126452848.
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
@kevinb9n Yea, I'm actually separating them out during the Refaster run (I'm curious how many people use the builder when they could use using .of()), but I'll sum them manually.
@JakeWharton It's a P1 goal this quarter for @lowasser - fingers crossed :-)
1   N
5   8.5% N
7   3.6% N
8   3.4% N
10  1.7% N
More or less follows N/2 for each extra pair of K/V.
Okay, so there's no great justice behind the choice of 5.
On Thu, Jul 30, 2015 at 1:17 PM, Kurt Alfred Kluever <
notifications@github.com> wrote:
> 2 53% N
> 3 28% N
> 4 15% N
> 5 8.5% N
> 6 5% N
> 7 3.6% N
> 8 3.4% N
> 9 2% N
> 10 1.7% N
>
> More or less follows N/2 for each extra pair of K/V.
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2071#issuecomment-126468933.
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
@konradr25, it's not clear to me what you're looking for there.  That case only uses one map entry, so it can use ImmutableMap.of, and I'm not sure how you expect us to improve on that case.  This issue is for expanding ImmutableMap.of to accept more than 5 entries.
The example you've given has nothing to do with more than five entries.  I can't tell what the error actually is in your example, but it looks like something to do with generics?  In that case, that's the Java compiler failing to do the type inference you want, and Guava can't possibly do anything about it.  (The solution is to add explicit type arguments.)
We may have already come up with one. If so, I'm sure someone can point me to it.
- Will we change types like `HashMultimap` to maintain order (basically making it `LinkedHashMultimap`)? This used to be extremely appealing. Now that we're looking more at Android users, we might prioritize memory usage. If so, the extra pointers required are less appealing.
- Would we consider a "nudge" approach in which `MultimapBuilder` and the forthcoming `BiMapBuilder` (which may supplant public classes like `HashMultimap` in time) treat `hashKeys` as a request for `linkedHashKeys` and provide `unorderedHashKeys` for users who really want to save memory?
Yeah, I get the sense that we care more about minimizing garbage allocation
that reducing footprint.
On Tue, Jun 2, 2015 at 10:26 AM, Jesse Wilson notifications@github.com
wrote:
> I don't think the extra links will make a meaningful difference on Android
> users. The bulk of the RAM in an Android app is used by high-resolution
> images!
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2068#issuecomment-108023481.
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
My understanding was always that it was number of distinct objects, rather
than their size?
On Tue, Jun 2, 2015 at 10:54 AM kevinb9n notifications@github.com wrote:
> Yeah, I get the sense that we care more about minimizing garbage allocation
> that reducing footprint.
>
> On Tue, Jun 2, 2015 at 10:26 AM, Jesse Wilson notifications@github.com
> wrote:
>
> > I don't think the extra links will make a meaningful difference on
> > Android
> > users. The bulk of the RAM in an Android app is used by high-resolution
> > images!
> >
> > 
> > Reply to this email directly or view it on GitHub
> > https://github.com/google/guava/issues/2068#issuecomment-108023481.
>
> ##
>
> Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2068#issuecomment-108030561.
IIRC, LinkedHashMultimap allocates at most as many objects as HashMultimap, and possibly fewer, due to the deeply customized implementation.
- the thread that runs `startUp` and then invokes the `running` listener
- the main test thread
Your use of `directExecutor` prevents that from increasing to three, but there are already enough threads for a race: The `startUp` thread releases the main test thread (`monitor.leave()`) before it starts running the listeners (`executeListeners()` -- see `AbstractService.notifyStarted()` for both calls).
How do you work around this? Well, it depends on what you really want your test to do. If all we're doing is verifying that the listeners eventually ran, we can use a `CountDownLatch` instead of an `AtomicBoolean`: `running()` calls `countDown()`, and `coreCanStartUp()` calls `await(5, SECONDS)` (or however long you want it to wait in the failure case, which you will hopefully never see).
I don't expect this to get very far, for a couple reasons:
- easy in Java 8: iterable.stream().anyMatch("ApPle"::equalsIgnoreCase)
- the logic used in Java's equalsIgnoreCase is noticeably problematic; it tries to deal with more than ASCII and doesn't do a very good job of it; you either want to be using Ascii.equalsIgnoreCase or something significantly more sophisticated for all of Unicode; Guava doesn't really try to address this itself
- this would be more usefully/broadly expressed as a general Predicate passed to Iterables.any
Sounds at least reasonable.
Actually, now I'm wondering:  just why does it make sense to create a hard-coded EQ, whether in a test or not?
I searched through google's internal code base and could only find 1 potential user of these static factory methods. I don't think we have enough supporting use cases to proceed with this issue.
Thanks for submitting it though!
It's not actually delegating to your List; it delegates to an internal ArrayDeque, which (like every Queue (except the one that also implements List)) doesn't have value-based equality.
Could simplify your assertions a bit with [Truth](https://github.com/google/truth):
`EvictingQueue<Integer> lastFive = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10).collect(Collectors.toCollection(() -> EvictingQueue.create(5));
assertThat(lastFive).containsExactly(6, 7, 8, 9, 10).inOrder();`
@cpovirk said:
["Queue implementations generally do not define element-based versions of methods equals and hashCode but instead inherit the identity based versions from class Object, because element-based equality is not always well-defined for queues with the same elements but different ordering properties."](http://docs.oracle.com/javase/7/docs/api/java/util/Queue.html) This is true of ArrayDeque, so our equals() method would be delegating to an object that uses Object.equals(). The net effect of the proposed change will be no change in behavior.
I'm going to try to find time to take a crack at this, though I'm not 100% confident when I'll be able to.
We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA ([login here](https://cla.developers.google.com/) to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
<!-- need_author_cla -->
CLAs look good, thanks!
<!-- ok -->
I'm submitting a version of this change internally and it'll get mirrored out shortly. Thanks for pointing it out!
Can you go into some more detail about what you're looking for? A common pattern for dealing with null values is to pass a custom comparator:
```
.compare(left.getCreateDate(), right.getCreateDate(), Ordering.natural().nullsFirst())
```
It wouldn't know whether you want the nulls to go first or last... why not
just do what Chris is suggesting?
On Thu, May 28, 2015 at 12:53 PM, Vctor Pineda notifications@github.com
wrote:
> I have a class "MyClass" that is filled from a sql query. It has 3 String
> fields: equip, family and shift. That class implements Comparator and I use
> ComparisonChain that compares equip, family and shift, in that order.
>
> Well, the query returns some null values for Equip, of 100 elements, 5 has
> null values for equip. So the ComparisonChain throws a NullPointerException.
>
> So, I use a Optional to replace the null values with empty, just to
> continue the comparison correctly.
>
> But, if the ComparisonChain has the ability to test null values before
> compare the values, this doesn't throws the NullPointerException, and it
> doesn't break the code.
>
> I don't know, but I think that with a boolean parameter passed to
> constructor to define if the ComparisonChain needs test for null values
> before it do the comparison. And with this our code will be less.
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2061#issuecomment-106578950.
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
I'm with Chris and Kevin -- this should be easily addressable just by comparing the nullable values with Ordering.natural().nullsFirst() or nullsLast().
It's not clear whether users would actually want nullsFirst or nullsLast.  Keeping it this way lets users make the choice explicitly and follows the principle of least surprise.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
Bulk closing all pull requests that are listed as needing CLA signing. If you'd like us to look at your pull request, you'll need to sign the CLA and report back here.
If this is a false positive, I apologize. Please reopen the pull request, and we'll have a look.  It should say what `ListenableFuture.addListener` says (or, if we don't like that, we should use a different formulation in both places):
> Exceptions thrown by a listener will be propagated up to the executor. Any exception thrown during Executor.execute (e.g., a RejectedExecutionException or an exception thrown by direct execution) will be caught and logged.
h/t https://stackoverflow.com/q/29770106/28465
`MapMaker.weakKeys().makeMap()` ?
In general, with methods like `Maps.newHashMap()`, I think we only intended to provide the most commonly used types. And with Java 7, the static factory methods are mostly redundant: the diamond operator allows you to write `new WeakHashMap<>()` to avoid repeating the type arguments, so we're almost certainly not going to add new static factory methods like `Maps.newHashMap()` in the future.
Louis has it. This is a superior choice to WeakHashMap.
On Thu, May 21, 2015 at 10:01 AM, Louis Wasserman notifications@github.com
wrote:
> MapMaker.weakKeys().makeMap() ?
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2057#issuecomment-104355121.
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
Sorry - I don't understand your request. java.util.Collections.sort() let's you sort any List (not just ArrayList).
Note that sorting a CopyOnWriteArrayList might be wildly inefficient because it, well, copies the underlying array on every mutate. Is that what you're asking about?
Actually, I think `Collections.sort` doesn't work on a `CopyOnWriteArrayList` since it uses `ListIterator.set`, and `CopyOnWriteArrayList`'s `ListIterator` is a snapshot that doesn't support `set`.
That sounds like a straight-up JDK bug, then?
On Thu, May 21, 2015 at 8:26 AM, Colin Decker notifications@github.com
wrote:
> Actually, I think Collections.sort doesn't work on a CopyOnWriteArrayList
> since it uses ListIterator.set, and CopyOnWriteArrayList's ListIterator
> is a snapshot that doesn't support set.
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2056#issuecomment-104318922.
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
It's not technically a bug since apparently `Collections.sort` does specify this:
> UnsupportedOperationException - if the specified list's list-iterator does not support the set operation.
Related:
http://www.javacreed.com/sorting-a-copyonwritearraylist/
http://comments.gmane.org/gmane.comp.java.jsr.166-concurrency/933
@vrstest There is no thread-safe way to sort CopyOnWriteArrayList given its exposed API.  I'm not sure what you'd want us to do that would actually solve your problem.
It sounds, though, like you need to build your application to be actually thread-safe, perhaps using synchronization.
https://groups.google.com/d/topic/guava-discuss/xJJggXuhhbs/discussion
Would you take a look at http://stackoverflow.com/a/12824556 (mostly the "Then again, consider this caller, which catches ExecutionException e..." part) and let me know what you think?
We have begun working to remove `Throwables.propagate`, so I'm marking this as obsolete.
I don't believe we're likely to want support for these, for a couple reasons --
- "blank" is a term we've avoided referring to in Guava, because where we've seen it used in the past, it refers to an ill-specified definition of whitespace.  We would prefer users to refer explicitly to CharMatcher.is(' '), CharMatcher.WHITESPACE, or some other unambiguous definition.
- Preconditions is deliberately relatively minimal.  There's not that big a win between checkEmpty(Collection) and checkArgument(Collection.isEmpty()), and checkArgument is unambiguous about which exception it throws.
I'm not sure how you wanted these to handle nulls, either, but if you wanted "empty" to mean "empty or null," see http://stackoverflow.com/questions/6910002/google-guava-isnullorempty-for-collections for our thoughts on that.
> I assume the checkEmpty(String) / checkNotEmpty(String) is also not wanted? Ex. checkNotEmpty would have to be non-null and length > 0.
Yes, I believe so, for similar reasons.
I'm not sure I see a good reason to commit to this behavior in the
specification.  In case of equality, it should not _matter_ which instance
is returned. That's what equality means.
On Wed, May 13, 2015 at 9:06 AM, Qays H. Poonawala <notifications@github.com
> wrote:
>
> ## Make the JavaDoc more clear about what happens in cases of equivalence.
>
> You can view, comment on, or merge this pull request online at:
>
>   https://github.com/google/guava/pull/2052
> Commit Summary
> - Update JavaDoc for Maps Difference.
>
> File Changes
> - _M_ guava/src/com/google/common/collect/Maps.java
>   https://github.com/google/guava/pull/2052/files#diff-0 (8)
>
> - https://github.com/google/guava/pull/2052.patch
> - https://github.com/google/guava/pull/2052.diff
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/pull/2052.
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
Whoops!  So it does.  I hadn't noticed that when it came through.  I would
be more inclined to take it out than to do more of it, though.
On Wed, May 13, 2015 at 10:44 AM, Qays H. Poonawala <
notifications@github.com> wrote:
> That's a fair point, and maybe it should be removed completely.
> The JavaDoc had already mentioned this for the second method (which takes
> a user supplied equivalence class comparator), and it was confusing to me
> for not only what you mentioned, but also it wasn't clear to me at first
> what it meant by "returned in the difference".
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/pull/2052#issuecomment-101756447.
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
Hmm, looking at the commit from your second pull request (https://github.com/javajosh/guava/commit/8b472b14a14a8c60094535a5631d6fdee862530b) I see the commit author is set to `Josh Rehman <josh@joshrehman.com>`. I think it's probably because what you did ("changed the value, reverted, created a new branch 'javajosh' and merged my change from master") didn't actually change the commit itself at all.
You'd need to use `git commit --amend --author "New Author Info <email>"` to actually change it.
We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA ([login here](https://cla.developers.google.com/) to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
<!-- need_author_cla -->
Thanks Josh! We don't have a good mechanism for merging patches, so I'm going to submit a change internally and it should get mirrored out shortly.
There were actually a handful of unnecessary checkNotNulls in this file...I think I got 'em all.
Thanks again!
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA ([login here](https://cla.developers.google.com/) to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
<!-- need_author_cla -->
Thanks Josh! We don't have a good mechanism for merging patches, so I'm going to submit a change internally and it should get mirrored out shortly.
There were actually a handful of unnecessary checkNotNulls in this file...I think I got 'em all.
Thanks again!
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
Thanks Archie...I've fixed this internally and it'll be mirrored out shortly. Sadly, it's typically easier for us to just fix it internally and mirror it out vs. merging pull requests. I hope we get that fixed soon though.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
@cgruber , is this something that we should do?
This seems reasonable to me.
Thanks! This change has been made in commit 01d5493fa96a16e4217dd5c3d2e953fca0e93a94.
Yeah.  This is good. Thanks!
On Wed, May 20, 2015, 13:44 Colin Decker notifications@github.com wrote:
> Closed #2043 https://github.com/google/guava/pull/2043.
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/pull/2043#event-309973541.
So the opposite of Maps.fromProperties(Properties)?
Someone pointed out that Properties extends HashTable, so you can just do:
`Properties properties = new Properties();`
`properties.putAll(map);`
...so we probably don't need a whole new API for this. However, we could add something to the javadocs of fromProperties()?
> Because Properties inherits from Hashtable, the put and putAll methods can be applied to a Properties object. **Their use is strongly discouraged** as they allow the caller to insert entries whose keys or values are not Strings.
Hmm, thoughts? It is not accepted yet. We'll need to have an API review of this proposal, which requires doing some research into the google codebase to find compelling use-cases.  This is probably my fault. We used to have 2 APIs:
Stopwatch.elapsedMillis()
Stopwatch.elapsed(TimeUnit)
When cleaning up elapsedMillis(), I probably just migrated it to elapsed(MILLISECONDS) and left the old test. I'll get it fixed up.
There were a few other redundant tests in that file...nuked em all. It should be mirrored upstream in a few days.
Thanks!
Re. the other duplication in that test...I already deleted those when I removed the first test you mentioned.
Re. the constructors: it's not a big deal...but I'll end up fixing that at some point when the constructors become private (and thus that line will no longer compile).
This issue can probably stay closed.
Thanks!
ClassPath tries to define its behavior in terms of the classloader. If a class is loadable through the given ClassLoader, whether directly or through a parent class loader, ClassPath needs to find it.
If you don't want ClassPath to inspect the parent loader, could perhaps do `new URLClassLoader(urls, null)`. Although, if you already have the jar files, it's probably easier to just loop over them directly:
```
for (File file : files) {
try (JarFile jarFile = new JarFile(file)) {
Enumeration<JarEntry> entries = jarFile.entries();
while (entries.hasMoreElements()) {
JarEntry entry = entries.nextElement();
...
}
}
}
```
ResourceInfo.url() sometimes throw exception when the resource can't be loaded through the given classloader, despite being found through classpath scanning.
Can you check ResourceInfo.getName() instead?
Can you elaborate more on what "context" you are looking for? Is it the jar file name? If so, are you trying to scan only certain jar files and skip the others?
Sorry I'm not following on this statement. What do you have to do with the strings that can be saved if using ClassLoader? Care to give an example?
I'm trying to figure out if the main problem is "url() throws Exception" or it's a new use case that ClassPath could add support for.
So, is the problem that `ClassPath.from(ClassLoader)` doesn't provide a `getResourcesStartingWith("/package/path")`?
Or that ClassPath loading the full classpath into memory causes performance problem?
I've never used ResourceFinder and the API document as you suggested doesn't make it easy to see what you are implying as the desired API by looking at ResourceFinder.
Can you be a bit more specific and show me some example code snippet using the proposed API addition? That would make it a lot easier for me to get the point.
Okay. I think I have a better idea of the asks now. Let me try to summarize:
1. Allow flexible configuration of "sources", ClassLoader is just one among other sources.
2. Do not automatically walk up the classloader hierarchy.
3. Allow wildcard match.
Please let me know if I'm missing any.
For 1 and 2,  suppose you can construct your own URLClassLoader to solve it? It would be a "workaround" if you don't already have a ClassLoader but have to construct one just to pass the data to ClassPath.
It's not nice. Agreed. I guess the first question I'd need to answer if we are to add it to Guava: what is the **real** use case that you have to manually configure the jars, which aren't from a ClassLoader? With a ClassLoader, one can use the standard JDK ClassLoader#getResources() so no need to create parallel API doing the same thing.
ClassPath was designed with the assumption that you need to search the "current" class path, not a manually configured set of jar files. So if that assumption doesn't match the use case, it's certainly not going to fit well.
Fyi, in the next version, NulPointerException is going to be changed to NoSuchElementException to make it more friendly for clients to catch.
Oops. This was probably my mistake.
We can fix this by changing Absent.hashCode() to return some other random
number.
On Mon, Apr 20, 2015 at 4:04 AM, Alexei notifications@github.com wrote:
> Uncorrect hashCode() implementation at com.google.common.base.Absent and
> com.google.common.base.Present - for example if hashCode() of reference at
> Present return 0 then it hashCode() equal Absent.
>
> example: Optional.absent() has same hash code as Optional.of(0.0) or
> Optional.of(0)
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2037.
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
For what it's worth, this isn't actually _wrong_ per se, and there will always be Optional.present values with the same hash as Optional.absent.  We can certainly make it a rarer case, though?
Right.  The standard we have tried to apply is that "at least there
shouldn't be an obvious / trivially explained way to generate collisions."
So it's okay if Optional.of(6639813) collides with absent(), but
On Mon, Apr 20, 2015 at 12:35 PM, Louis Wasserman notifications@github.com
wrote:
> For what it's worth, this isn't actually _wrong_ per se, and there will
> always be Optional.present values with the same hash as Optional.absent. We
> can certainly make it a rarer case, though?
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2037#issuecomment-94548795.
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
(Another way to explain what we're shooting for is that collisions should
On Mon, Apr 20, 2015 at 12:38 PM, Kevin Bourrillion kevinb@google.com
wrote:
> Right.  The standard we have tried to apply is that "at least there
> shouldn't be an obvious / trivially explained way to generate collisions."
>
> So it's okay if Optional.of(6639813) collides with absent(), but
> Optional.of(emptySet) colliding with absent() is pretty sad.
>
> On Mon, Apr 20, 2015 at 12:35 PM, Louis Wasserman <
> notifications@github.com> wrote:
>
> > For what it's worth, this isn't actually _wrong_ per se, and there will
> > always be Optional.present values with the same hash as Optional.absent. We
> > can certainly make it a rarer case, though?
> >
> > 
> > Reply to this email directly or view it on GitHub
> > https://github.com/google/guava/issues/2037#issuecomment-94548795.
>
> ##
>
> Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
Fixed in https://github.com/google/guava/commit/20a42756c477b03c0123870b763148f4a18bdc8e
Thanks.
Multimap.get() never returns null (it'll return an empty collection if there isn't a mapping).
Optional<T> value = Optional.fromNullable(Iterables.getFirst(multimap.get(key), null));
Also I should mention that changing the Multimap interface is basically a non-starter at this point. It's non-@Beta and it would cause immense pain to all of our open source users.
It's non-final (since it's subclassed for the sorted variety, etc.) and has a public no-arg constructor. There may be other `Builder`s in this boat. We should consider deprecating the public no-arg constructor, given that having two ways to create a `Builder` is unusual and unnecessary in the first place.
There seem to be a few subclasses internally of ImmutableMap.Builder. One does a null check on the value and ignores the `put` if it doesn't pass, and the others add a method which delegates to `put()` and only call that method. The latter cases are all used in the same file they're defined and could easily be migrated. There are also a few usages of a subclass only to be able to have a class initializer, which doesn't actually buy them much since the API is fluent already.
Note that if we decide to fix this, we should also fix it for `ImmutableSortedSet`. That has the same few kinds of subclasses, plus one that really should just be an `@AutoValue.Builder`.
One option here would be to make a `BaseImmutableMapBuilder` that's package-private and then have `ImmutableMap.Builder` be a simple shell over that, exposing the public constructor but making the class `final`. Then `ImmutableBiMap.Builder` and `ImmutableSortedMap.Builder` could extend `BaseImmutableMapBuilder`.
`ImmutableSortedMap.Builder` currently has no subclasses and seems like it should probably be `final` (`ImmutableSortedSet.Builder` is `final`).
These would all technically be breaking changes to non-`@Beta` APIs however. Given that we're committing to not making breaking changes to non-`@Beta` APIs (with the exception of removing the `CharMatcher` constants), I don't think we can do this. Fortunately, I also don't think it's too big a deal, really. Most people won't do it, and those that choose to can just deal with that. It usually won't affect things across API boundaries since builders typically aren't passed around, and AFAIK it doesn't give other packages access to any internals that shouldn't be exposed... at the very least I'm sure it doesn't give them the ability to construct actual `ImmutableMap`s that violate its contract.  Okay, so the code you want to write at _least_ needs to be modified to insert the explicit `<ListenableFuture<?>>` type parameter either way, correct?
Your current workaround is either to use unmodifiableCollection as shown, or just cast to `(Collection)` and suppress a warning, correct?
_Normally_ we don't add wildcards to cover a case like this. But...
The quirk here is `append`; it can only deal with its argument being an iterable of a subtype; there's no way for it to handle the case that its argument is a supertype. As a result, the need to cast arises. This might be enough justification to use a few more wildcards in FluentIterable.
It's going to haunt us that Range does... because now the JDK has its own different Predicate interface.
Anyway, this was intentional. We avoid implementing the functional type directly except when were completely convinced that there could be no two different behaviors a user would expect or want it to have when used in that way.  A little bit of doubt in this case (should the predicate accept a C or a Range<C>) was enough to make us steer clear.
Currently Guava is targeted at JDK6, so it can't use anything from JDK7. This is something we could consider in the future though.
I don't think so - the primary issue is Google internal?
As it stands, for essentially all immutable collections, a good implementation is
IntStream.range(0, collection.size()).mapToObj(collection.asList()::get)
The Google internal Comment was a statement, not a question.
I'm not certain the IMMUTABLE characteristic is actually used for anything?  That should still be an adequate substitute for most use cases I can think of...
FWIW, Suppliers.compose matches Functions.compose, which is also a reasonable point of comparison?  A Supplier seems as much like an argumentless Function as it seems like an Iterable/Iterator.
We discussed this almost 4 years ago but didn't have the motivation to do anything about it :)
I strongly agree that "compose" is a bad name here. I can see the case that "composition" is technically a broad enough concept to cover this, but "composition" is technically a broad enough to cover all sorts of methods, e.g., `Iterables.transform`. It's _too_ generic. Better to restrict it to the case in which both inputs are functions that accept a "real" input.
If we could justify the effort, I would like to see:
- `Suppliers.compose` -> `Suppliers.transform`
- `Predicates.compose` -> `Predicates.onResultOf` (while we're stamping out "compose")
But again, I don't know how much effort it's worth spending on these classes. What is their future in the JDK8 world?
(Well... I'm not sure if `onResultOf` works well as a two-parameter static method. It _might_ still be better than what we have, but it's not as good a name here as it is as an instance method on `Ordering`.)
Much as I regret various things about this, we're stuck with it. Sorry.  This feels like a relatively uncommon use case to me, and something that would just be confusing for most people who should probably be using `CharSource.copyTo(CharSink)` instead.
You can of course already do this yourself relatively easily like this:
``` java
try (final Writer writer = sink.openStream()) {
source.readLines(new LineProcessor<Void>() {
@Override public boolean processLine(String line) throws IOException {
writer.write(line);
writer.write(System.getProperty("line.separator"));
return true;
}
@Override public Void getResult() {
return null;
}
});
}
```
We should do something about this. In addition to this method returning `ExampleStackTrace`, `PotentialDeadlockException` itself _extends_ `ExampleStackTrace`. While it's not the end of the world, a public type extending a private type is something that seems preferable to avoid.
There's a few things we could do, and we may need to do one or more of them.
- Make the method non-public. It's already not documented and (internally at least) only called from `CycleDetectingLockFactory` itself. This seems likely to be the right thing to do, but I don't know if it's public because there is some reason that users might actually want to use it.
- Change the method return type to `Throwable`. There aren't any special methods on `ExampleStackTrace`.
- Change `PotentialDeadlockException` to not extend `ExampleStackTrace`, if possible.
- Make `ExampleStackTrace` public. I'd rather not if we can avoid it.
Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA).
:memo: **Please visit https://cla.developers.google.com/ to sign.**
Once you've signed, please reply here (e.g. `I signed it!`) and we'll verify.  Thanks.
---
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
- If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
This looks like you could easily do it yourself as Optional.fromNullable(Iterables.get(Iterable, into, null)).  Is it worth adding another method when it's that easy to roll yourself?
I think this gets into the territory that ByteBuffer is already there for.
Agreed, this is what `ByteBuffer.putLong(long)` is for.
Okay, so we _could_ override methods like sortedCopy and isOrdered and add special-case code for 1-element collections. I believe we do this for a 1-element ImmutableSortedSet, 1-entry TreeMultiset, etc. In those cases it's a little more clear that we shouldn't allow "bad" elements into the collection. In these cases it seems a little less clear that it's worth the bother. But not clear that it isn't, either.
`Maps.fromProperties` returns an `ImmutableMap`, and `ImmutableMap`s aren't allowed to contain `null`.
Thanks for your pull request.
It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA) at https://cla.developers.google.com/.
If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check the [information on your CLA](https://cla.developers.google.com/clas) or see this help article on [setting the email on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
Once you've done that, please reply here to let us know.  If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA ([login here](https://cla.developers.google.com/) to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
<!-- need_author_cla -->
Bulk closing all pull requests that are listed as needing CLA signing. If you'd like us to look at your pull request, you'll need to sign the CLA and report back here.
If this is a false positive, I apologize. Please reopen the pull request, and we'll have a look.  This is happening!
It's been moved here:
https://github.com/DimitrisAndreou/memory-measurer/blob/master/ElementCostInDataStructures.txt
Sorry for the confusion.
On Mon, Mar 30, 2015 at 8:13 PM, Ben Manes notifications@github.com wrote:
> The project memory-measurer https://code.google.com/p/memory-measurer
> was removed. Guava's documentation link Footprint of JDK/Guava data
> structures
> https://code.google.com/p/memory-measurer/wiki/ElementCostInDataStructures
>
> I wanted to verify my analysis
> https://github.com/ben-manes/caffeine/wiki/Memory-overhead using jamm
> https://github.com/jbellis/jamm. Using OpenJDK's Java Object Layout
> http://openjdk.java.net/projects/code-tools/jol/ will be the best, but
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2018.
##
@dimo414 Which sidebar? Can you give a link please? Thanks!
Cool, fixed. Thanks!
Given the fact that the change is rather trivial and cannot have negative impact, I was kind of hoping it would make it for the next release, but I see it doesn't.
I'm not asking about the other dozen of tickets I have opened, but come on, this one is actually trivial and is a quick win.
I confess that we just didn't notice this in time to pick it up.  The fix has been submitted internally; I think it should go in 19?  Not sure if we're going to have another RC...
I think we will have another RC, there's a couple `@since 19.0` things that were added around the time I made the first rc. I'll probably do the next rc in a week when I'm back from vacation.
Thank you!
We're not inclined to add more functional APIs to Guava at this point, now that jdk 8 addresses FP so much more thoroughly.  Once Guava requires jdk 8 you may wish to re-file this as being about java.util.function.Function.  I am rather skeptical that this is will be a common need, though.
Thanks for your pull request.
It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA) at https://cla.developers.google.com/.
If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check the [information on your CLA](https://cla.developers.google.com/clas) or see this help article on [setting the email on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
Once you've done that, please reply here to let us know.  If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
Our current policy is that Guava runs with Java 6+ but that it may require a newer version to build. I would not mind if we fixed this occurrence up, but we currently have no way to prevent future violations. Animal Sniffer, which we use for Java 6 enforcement, seems to work only on the main compile, not the test compile. (I was able to run it only by telling Maven that our test sources were normal sources and that all of our test-only deps were normal deps.) If anyone can figure out a way to run it on the test sources, we'd probably be interested.
\[edit: Animal Sniffer [starts checking test code in 1.19](https://github.com/mojohaus/animal-sniffer/issues/5).\]
(Also, see the CLA warning above. If it's something you'd rather not sign, I can submit my own workaround. (This is a problem we've had to confront in ours tests previously where it affected GWT compatibility.))
CLAs look good, thanks!
<!-- ok -->
I guess that the bot just takes a little while to run. Or maybe someone needs to come and say the magic work "CLA?" Anyway, looks good now. Thanks!
I think the bot might just require someone (possibly the author?) to comment on the pull request again after the CLA has been signed for it to check again.
Done in https://github.com/google/guava/commit/9131ddb3bd2ff2f3ad08dd06f59d0597d33b8bdf
It looks like we got the commit metadata wrong -- sorry.
Have you seen `Files.hash(File, HashFunction)`?
@cgdecker Any thoughts on the idea of a nullByteSink?
With regard to @fror's use case: I think that clearly, the best thing here\* would be for us to release `MoreFiles`, which would allow `MoreFiles.asByteSource(path).hash(Hashing.sha1())`. Barring that, using `ByteStreams.copy(in, ByteStreams.nullOutputStream())` doesn't seem that bad. There's also a question of whether we should have something like `ByteStreams.hash(InputStream, HashFunction)`.
`*` I still think that ideally `common.hash` should depend on `common.io` rather than the other way around and that `Hasher` and `HashFunction` should have methods for hashing an `InputStream`, `ByteSource`, etc. Though that's likely impossible to change at this point.
I'm going to @-mention Louis on #1650 to see if he has anything to report.
In that case you could just use `Iterables.concat()` to do what you want:
```
Traverser t = Traverser.forTree(n -> yourChildrenMethod(n));
Iterable nodeList = Iterables.concat(
t.breadthFirst(page1),
t.breadthFirst(page3),
t.breadthFirst(page5));
```
(This uses the new `Traverser` class--currently in development--but the principle is the same.)
Am I missing something, or would that do what you want?
I am somewhat reluctant to have a method on `Traverser` that allows you to specify multiple starting nodes, because the behavior is not intrinsically well-defined: what do you do, for example, if you encounter the same node starting from different start nodes?  How do you define what legal inputs are?
Since this issue hasn't (until today) been updated for over a year, my take on this is:
(a) it doesn't sound like there's a lot of demand for this, and
(b) the above solution (use `Iterables.concat()`) is what people should be doing, unless someone comes back and explains why that doesn't work for them.
So I'm closing this; if I've overlooked something or if there are enough people for which this mechanism is overly burdensome, we'll reopen it. Thanks for the clarification as to what you wanted, although the question of what such a method should do if it encounters the same node multiple times (which it certainly could, in general) is still open.
In order to do the specific thing that you want, I think that your first instinct--to use a virtual root node that has your starting points as successors--is actually the right one to use.  It's the right semantics for what you're trying to do, i.e., treat the union of the _k_ input trees (presuming that they are actually disjoint) as if they were subtrees of an implicit root.  You'd want to use `Iterables.skip()` to get past the virtual root, but that's easy enough:
```
SuccessorsFunction<N> successorsFunction =
n -> { n == virtualRoot ? ImmutableList.of(page1, page3, page5) : yourChildrenMethod(n) };
Iterable<N> traversal = Iterables.skip(
Traverser.forTree(successorsFunction).breadthFirst(virtualRoot),
1);
```
IMO this doesn't sound like something that is likely to be of sufficiently broad interest to be a suitable candidate for inclusion in Guava.  And I think that it would be quite difficult to come up with a name that would correctly convey the semantics, because the semantics you requested are definitely not what I  expected.
I'm happy to reconsider this if one of the other Guava owners thinks that it's likely to be more broadly useful (and can propose a name that will convey the semantics you want), or if more people show up wanting this functionality.  If you're trying to traverse a binary tree, why not use BinaryTreeTraverser?
http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/BinaryTreeTraverser.html
Fixed internally; fix will be mirrored out soon.
Sensible request.
There is one small issue I see. We round to 4 significant digits. Currently, that doesn't cause too many problems since we constrain the value to be < 1000, so there's always a decimal part. (Well, technically you could have a single stopwatch running for more than 1000 _days_, but that's damn unlikely.)
But now it would be possible to see a message of
A took 12340 ms
... when the actual value might have been 12335, and there is no way to indicate that rounding took place.
Not necessarily a deal-breaker, just raising it.
Do any of the `java.time` utilities + [`Stopwatch.elapsed()`](https://github.com/google/guava/blob/f2be0be06ef49dee7c5dfcb3a0231c5ecaf5b621/guava/src/com/google/common/base/Stopwatch.java#L212) solve this need? This could be solved by just not relying on our custom `toString()`, but instead writing your own static function to format the string.  I think the chances of this being accepted are high, given that we did the exact same thing for Converter and CacheLoader. It's very annoying in JDK 8 to be unable to use a lambda. I would call the method TreeTraverser.from().  And I'd go ahead with the unchecked cast in the constructor so the field can just be a plain old Function<T, Iterable<T>>.
I'd prefer to find a method name that made clearer what the Function was being used for -- to get the children of a node.
I believe this is taken care of by [`common.graph.Traverser.forTree(SuccessorsFunction)`](https://github.com/google/guava/blob/f2be0be06ef49dee7c5dfcb3a0231c5ecaf5b621/guava/src/com/google/common/graph/Traverser.java#L128) once it's implemented (which should be very soon)  Thanks for the report! This is fixed (in the Guava Wiki). cl/171543884 internally has the fix as well for when we start syncing this all out to gh-pages.  I don't see the difference?
Ah, that was silly.  Done.
`s3.amazonaws.com` is a public suffix, so `bucket.s3.amazonaws.com` is the top private domain. See https://publicsuffix.org/list/effective_tld_names.dat
This is similar to #1890. It's a common question that we get, so we should probably improve documentation here.
- @lowasser internal CL 88242480 wants to use `SimpleImmutableEntry`.
- Internal CL 86210805 can be rolled back to use `AssertionError(String, Throwable)`.
- @kak internal CL 83767705 wanted to use `Arrays.copyOf`.
- My internal CL 59647656 wants to remove `AbstractIteratorTester` workarounds for bugs in `java.util` classes fixed in new releases of GWT.
GWT 2.7.0 was released in November. But note that we had bug reports from users of GWT 2.5.1 as late as October 2014, 9 months after the release of 2.6.0. We should get some idea of how quickly external users update the version of GWT they use.
FYI, trying to bump our pom from 2.6.1 to 2.7.0 gives me the following error:
[ERROR] Plugin org.codehaus.mojo:gwt-maven-plugin:2.7.0 or one of its dependencies could not be resolved: Failed to read artifact descriptor for org.codehaus.mojo:gwt-maven-plugin:jar:2.7.0: The repository system is offline but the artifact org.codehaus.mojo:gwt-maven-plugin:pom:2.7.0 is not available in the local repository. -> [Help 1]
org.apache.maven.plugin.PluginResolutionException: Plugin org.codehaus.mojo:gwt-maven-plugin:2.7.0 or one of its dependencies could not be resolved: Failed to read artifact descriptor for org.codehaus.mojo:gwt-maven-plugin:jar:2.7.0
Am I missing something?
That's an error we get internally only. We have Maven set up not to download anything, relying completely on a set of dependencies we downloaded in advance. The error is telling us that one of the needed dependencies wasn't pre-downloaded. You should be able to fix it by running our `update_maven_local_repository.sh` script.
I'll try to look into this problem now. I was surprised at the report that people can't use 2.7.0 if we use 2.6.1. (Thanks for letting us know.)
- We'd like to remove our GWT-specific version of `Sets.newSetFromMap`.
@filip26, can you let us know what errors you're seeing when using Guava with `gwt-maven-plugin` 2.7.0? [The first `guava-gwt`-using project I found on Github](https://github.com/xose/gwt-persona) continues to work fine if I change it to use `gwt-maven-plugin` 2.7.0.
To figure out how many users we'd cut off if we required 2.7.0, I [asked on StackOverflow](http://stackoverflow.com/q/30493893/28465). The answer: A survey taken [at the end of November](http://grokbase.com/p/gg/google-web-toolkit/14bvw19n6f/future-of-gwt-study), about [a week after 2.7.0 was released](http://www.gwtproject.org/versions.html), had 35% of users using the new version (or HEAD). Look at all versions released within the past year, and the number rises to >80%. The ">80%" trend held for the two previous surveys, too: Within a year of a version's release, >80% of users are using it. That would give us 6 months until GWT 2.7.0 is at 80%. I think that would be a reasonable time to pull the trigger (barring developments in the reports that we're currently cutting off users of 2.7.0).
(Internally, I've put together CL 99196888 for `newSetFromMap`.)
- One (soon to be two) of our `GwtPlatform` classes would like to use `Arrays.copyOf`. Instead, they have to use `copyOfRange`.
- Use `String.getBytes(Charset)`, as discussed in #2124.
- Update our internal "Guava JDK6 compatibility" doc to reflect the new version of GWT.
- Note in the release notes that we will no longer support Dev Mode: https://github.com/gwtproject/gwt/issues/9206#issuecomment-150033463 Then convert our GWT tests to prod mode (which would make them very slow, so maybe turn most/all off by default?), and post on the linked GWT issue.
(retitled to reflect that we're going straight to GWT 2.8.0 when available)
> This requires both the double rollbacks http://cl/98113442 http://cl/100051360 and also some kind of plan for Charset: http://cl/99780060 Guava 19 and lower has its own copy of Charset, which will conflict with the copy GWT is adding in 2.8.0. I don't know of any way to avoid that problem.
But maybe someone can find one.
Can you also report this to GWT? I would have hoped that our 20.0-SNAPSHOT would work with GWT 2.8.
I think I have CLs out or submitted for all the points mentioned above, aside from Louis's CL 88242480, which I've told him should now be safe to submit.
Because Guava 19 may have problems with GWT 2.8, we're hoping to release Guava 20 shortly after the GWT release.
I think so, anyway. @cgdecker?
Hmm, maybe we should get a release candidate out so that we're able to promote to final faster?
@cgdecker, given the news of GWT 2.8-rc2. (I'm not actually trying to be passive-aggressive by CCing you on all these threads, I promise :))
20.0-rc1, out now-ish, supports/requires GWT 2.8.0.
Today I ran into a code snippet like this:
```
V value = cache.getIfPresent(key);
return (value == null) ? 0 : value.getFoo();
```
The code would have been more concise if the lookup method returned an Optional:
```
return cache.peek(key).or(defaultValue()).getFoo();
```
Could Cache be added with a method returning Optional? (Although, with Java 8 adding its own Optional, I can imagine us not investing into Guava's Optional any further).
I'm going to close this, as it's unlikely that we're going to add additional APIs using our own `Optional` type, and we'd prefer not to diverge the pre-Java8 fork and Java8 fork very much. There's also plenty of easy work arounds, including the `asMap()` view or just using `ofNullable(cache.getIfPresent(key)).orElse(0)`  I think we suppressed these in 20bb6c3c898185ca87294a7e5405415b0e337543, which I think is in 18.0. Is there any chance that you have an older version?
We've been meaning to report this to upstream, as we think it's bogus: The `add()` method can't follow its contract:
```
map.put("foo", 1);
map.entrySet().add(entry("foo", 2)); // removes <foo, 1>, inserts <foo, 2>, returns false(!)
```
On Thu, Mar 12, 2015 at 10:45 AM, Ben Manes notifications@github.com
wrote:
> Interesting, that commit suppresses those tests for OpenJdk6MapTests,
> whereas I copied from TestsForMapsInJavaUtil which does not. What is the
> rational for the duplication between the two and is the latter enabled?
>
> java.util implementation; it's just an invalid test. Suppressing in OJ6MT
> just means OpenJDK has a bug.
>
> It _can_ support the add contract, but you're right that there is a bug!
> It should be delegating to putIfAbsent(), which is how I implemented it.
> It appears that there is a typo in OpenJDK which passes false to the
> internal put's onlyIfAbsent method. That bug exists in Doug's CVS repo so
> it should be reported.
>
> you have to throw an exception.
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
See https://github.com/google/guava/issues/1927#issuecomment-68305122
Thanks for your pull request.
It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA) at https://cla.developers.google.com/.
If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check the [information on your CLA](https://cla.developers.google.com/clas) or see this help article on [setting the email on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
Once you've done that, please reply here to let us know.  If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
CLAs look good, thanks!
<!-- ok -->
I think Colin puts together a pretty good list for each release, e.g.:
https://github.com/google/guava/wiki/Release21
We also provide automated diffs between the current snapshot and the previous release:
http://google.github.io/guava/releases/snapshot/api/diffs/
We could try to keep a running changelog between releases, but I fear it will never become a high enough priority in comparison to the changes themselves, given the existing things we provide here.  The execution of Google-internal `Callable.call` by `Futures.combine` (hopefully to be released in Guava as `whenAllComplete(...).call(...)`) is already interruptible, though we don't have a test. (We intend to add one in the forthcombing changes.) We should treat the other methods similarly and add tests for them.
I've developed some scruples about this (including the existing interruption support in `Futures.combine`). I think we need to avoid interruption with `directExecutor` (and `newDirectExecutorService`) and perhaps even more widely than that.
In principle, any interruption of a thread should be done through an API provided by its "owner." The owner is generally its `ExecutorService`. Otherwise, a caller that intends to interrupt one task can end up interrupting another:
```
ListenableFuture<Result> rpcFuture = makeRpc(...);
ListenableFuture<String> derivedFuture = rpcFuture.transform(..., directExecutor());
SomeSharedNetworkThread:
rpcFuture.set(result);
// Request timed out. Cancel our RPC:
```
If `derivedFuture.cancel` interrupts the execution of its `directExecutor` listener, then it's interrupting `SharedNetworkThread`. That's bad.
The easy fix for this it to disable interruption specifically for `directExecutor`. In theory, though, the right fix is probably to check `instanceof ExecutorService` and then use `submit` and `cancel` through the normal `ExecutorService` API instead of our current `ListenableFutureTask`-like approach.
Additional notes:
- `newDirectExecutorService` probably permits interruption with `cancel` right now. It shouldn't.
- Using the `ExecutorService` API probably involves creating extra objects.
- Skipping interruption for `directExecutor` listeners is probably fine, since they're supposed to be lightweight, anyway.
(This was prompted by reviewing some work on `whenAllSucceed(...).call(...)` (hopefully coming soon to Guava!). It might also help with other bulk APIs, like `inCompletionOrder` and `ListeningExectorService.invokeAny`, and maybe we could write non-bulk APIs (like `addCallback`?) differently in the future to also take advantage.)
(As written, this feature request presumes Java 8 default methods. But we could accomplish much the same thing even without them: We'd just introduce a static addFutureListener method that could do what the default implementation would do but that would have a special case for `TrustedFuture`, which would again know how to add the special listeners directly. But would we bother before Java 8?)
The benefit of this API isn't in the API itself (if that makes any sense). Rather, the benefit is that `TrustedFuture` could implement `addFutureListener` specially. Instead of doing what the default implementation would need to do -- create a Runnable that captures the target Future -- it could insert the `FutureListener` directly into its list of listeners. This saves us from allocating any more objects.
But why is _that_ useful? Because now we can reuse a `FutureListener` across more than one `Future`. Of course, we can sometimes do this already with a `Runnable`. And of course, it doesn't eliminate _all_ reasons that users might need multiple listeners. But it does mean that, if you're attaching listeners to each `Future` in a collection, and if those listeners differ only in which `Future` they read, you may now be able to create only 1 listener instead of N. This might end up being important in settings like Android and GWT, where we're seeing interest in using `ListenableFuture`. (Possibly it would also reduce the number of situations in which objects need to be created in lambdas? I'm not sure.)
(One sub-case that we will won't serve: Listeners who want access to their `Future` as a particular subclass will still need to store their instance... or just cast. But I guess that casting is an ugly thing to do when the `FutureListener` could theoretically be used with a `Future` that doesn't extend that subclass.)
We probably wouldn't support arbitrary sizes, since the enum-ness of collection features is baked in pretty deeply. One thing we've considered is a `HUGE` size to catch bugs that arise with many, many elements (whether from things like hash collisions or from changes in implementation, as in your case), but of course that comes with the time costs of running many of our tests on large collections. I should admit that the collection testers aren't too much of a priority for us anymore, though, since they're mostly good enough, so I'm mostly just letting you know that this probably won't happen soon. Sorry.
I'm going to close this given @cpovirk's response from 2 years ago that this isn't a high priority for us.  We finally did this, I think in 20.0.
Thanks for your pull request.
It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA) at https://cla.developers.google.com/.
If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check the [information on your CLA](https://cla.developers.google.com/clas) or see this help article on [setting the email on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
Once you've done that, please reply here to let us know.  If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
Bulk closing all pull requests that are listed as needing CLA signing. If you'd like us to look at your pull request, you'll need to sign the CLA and report back here.
If this is a false positive, I apologize. Please reopen the pull request, and we'll have a look.  You can do this with, for example:
```
return Ordering.natural()
.nullsLast()
.onResultOf(someFunction)
.nullsFirst()
.sortedCopy(stuff);
```
In this example, null elements in the collection appear first, and objects in the collection that evaluate to null in the function appear last.
Take another look at my sample code; you're missing a key bit.
Each call in the chain returns a new Ordering which contains a reference back to the Ordering that spawned it. In this example:
```
Ordering.natural()
.nullsLast()
.onResultOf(f)
.nullsFirst()
.compare(left, right)
```
The ordering you are actually calling `compare` on is a `NullsFirstOrdering`.  That ordering will immediately sort nulls to the front, and for everything else must delegate to its backing ordering, which is `Ordering.natural().nullsLast().onResultOf(f)`.
_That_ ordering invokes `f` on every element (which is always non-null) and gets a bunch of surrogate objects to compare. In order to compare these new objects, it must delegate to _its_ backing ordering, which is `Ordering.natural().nullsLast()`.
Etc. In other words, to understand the behavior of chained Ordering construct, it is helpful to read the chain _backwards_.
I won't paste the full failure log, but:
```
testGetAllClasses(com.google.common.reflect.ClassPathTest): Not true that <[com.google.common.reflect.TypeToken$TypeSet, com.google.common.reflect.ClassPath$ResourceInfo, com.google.common.reflect.Types$ParameterizedTypeImpl, com.google.common.reflect.TypeToken$TypeCollector, com.google.common.reflect.TypeResolver$1, com.google.common.reflect.Types$TypeVariableInvocationHandler, com.google.common.reflect.Types$GenericArrayTypeImpl, com.google.common.reflect.Invokable$ConstructorInvokable, com.google.common.reflect.Invokable, com.google.common.reflect.ClassPath, com.google.common.reflect.Types$ClassOwnership$1, com.google.common.reflect.TypeToken$TypeFilter$1, com.google.common.reflect.TypeToken$TypeFilter$2, com.google.common.reflect.Types$ClassOwnership$3, com.google.common.reflect.ImmutableTypeToInstanceMap$1, com.google.common.reflect.Types$ClassOwnership$2, com.google.common.reflect.ImmutableTypeToInstanceMap$Builder, com.google.common.reflect.ClassPath$Scanner, com.google.common.reflect.TypeToken$InterfaceSet, com.google.common.reflect.TypeToken$SimpleTypeToken, com.google.common.reflect.TypeToken$ClassSet, com.google.common.reflect.Types$JavaVersion$2, com.google.common.reflect.TypeResolver$WildcardCapturer, com.google.common.reflect.Types$JavaVersion$1, com.google.common.reflect.Reflection, com.google.common.reflect.MutableTypeToInstanceMap$1, com.google.common.reflect.Types$JavaVersion$4, com.google.common.reflect.TypeToken$InterfaceSet$1, com.google.common.reflect.Types$JavaVersion$3, com.google.common.reflect.TypeToInstanceMap, com.google.common.reflect.AbstractInvocationHandler, com.google.common.reflect.Types, com.google.common.reflect.TypeResolver$TypeTable, com.google.common.reflect.MutableTypeToInstanceMap, com.google.common.reflect.Parameter, com.google.common.reflect.ClassPath$1, com.google.common.reflect.TypeToken$TypeFilter, com.google.common.reflect.TypeToken, com.google.common.reflect.Types$ClassOwnership, com.google.common.reflect.MutableTypeToInstanceMap$UnmodifiableEntry$2, com.google.common.reflect.MutableTypeToInstanceMap$UnmodifiableEntry$1, com.google.common.reflect.TypeToken$TypeCollector$ForwardingTypeCollector, com.google.common.reflect.TypeToken$Bounds, com.google.common.reflect.ClassPath$ClassInfo, com.google.common.reflect.Invokable$MethodInvokable, com.google.common.reflect.package-info, com.google.common.reflect.Element, com.google.common.reflect.Types$TypeVariableImpl, com.google.common.reflect.TypeResolver$TypeTable$1, com.google.common.reflect.Types$NativeTypeVariableEquals, com.google.common.reflect.TypeVisitor, com.google.common.reflect.TypeCapture, com.google.common.reflect.MutableTypeToInstanceMap$UnmodifiableEntry, com.google.common.reflect.TypeToken$3, com.google.common.reflect.TypeToken$4, com.google.common.reflect.TypeToken$1, com.google.common.reflect.Types$WildcardTypeImpl, com.google.common.reflect.TypeToken$2, com.google.common.reflect.TypeParameter, com.google.common.reflect.ImmutableTypeToInstanceMap, com.google.common.reflect.Types$JavaVersion, com.google.common.reflect.TypeResolver, com.google.common.reflect.TypeToken$TypeCollector$1, com.google.common.reflect.Types$2, com.google.common.reflect.Types$1, com.google.common.reflect.Types$ClassOwnership$1LocalClass, com.google.common.reflect.TypeResolver$TypeMappingIntrospector, com.google.common.reflect.TypeToken$TypeCollector$2, com.google.common.reflect.TypeToken$TypeCollector$3, com.google.common.reflect.TypeToken$TypeCollector$4, com.google.common.reflect.TypeResolver$TypeVariableKey]> contains all of <[com.google.common.reflect.ClassPathTest$1, com.google.common.reflect.ClassPathTest$1LocalClass, com.google.common.reflect.ClassPath, com.google.common.reflect.ClassPathTest]>. It is missing <[com.google.common.reflect.ClassPathTest$1, com.google.common.reflect.ClassPathTest$1LocalClass, com.google.common.reflect.ClassPathTest]>
testGetTopLevelClasses(com.google.common.reflect.ClassPathTest): Not true that <[com.google.common.reflect.ImmutableTypeToInstanceMap, com.google.common.reflect.TypeParameter, com.google.common.reflect.TypeResolver, com.google.common.reflect.Reflection, com.google.common.reflect.package-info, com.google.common.reflect.Element, com.google.common.reflect.TypeVisitor, com.google.common.reflect.TypeCapture, com.google.common.reflect.TypeToInstanceMap, com.google.common.reflect.AbstractInvocationHandler, com.google.common.reflect.Types, com.google.common.reflect.Invokable, com.google.common.reflect.MutableTypeToInstanceMap, com.google.common.reflect.ClassPath, com.google.common.reflect.Parameter, com.google.common.reflect.TypeToken]> contains all of <[com.google.common.reflect.ClassPath, com.google.common.reflect.ClassPathTest]>. It is missing <[com.google.common.reflect.ClassPathTest]>
testGetTopLevelClassesRecursive(com.google.common.reflect.ClassPathTest): Not true that <[interface com.google.common.reflect.package-info, class com.google.common.reflect.ImmutableTypeToInstanceMap, interface com.google.common.reflect.TypeToInstanceMap, class com.google.common.reflect.TypeCapture, class com.google.common.reflect.Reflection, class com.google.common.reflect.Element, class com.google.common.reflect.TypeParameter, class com.google.common.reflect.ClassPath, class com.google.common.reflect.Parameter, class com.google.common.reflect.TypeResolver, class com.google.common.reflect.TypeToken, class com.google.common.reflect.AbstractInvocationHandler, class com.google.common.reflect.MutableTypeToInstanceMap, class com.google.common.reflect.Types, class com.google.common.reflect.Invokable, class com.google.common.reflect.TypeVisitor]> contains all of <[class com.google.common.reflect.ClassPathTest, class com.google.common.reflect.subpackage.ClassInSubPackage]>. It is missing <[class com.google.common.reflect.ClassPathTest, class com.google.common.reflect.subpackage.ClassInSubPackage]>
testGetTopLevelClasses_diamond(com.google.common.reflect.ClassPathTest): failed to find class com.google.common.reflect.ClassPathTest
```
The bottom line seems to be things like:
```
It is missing <[com.google.common.reflect.ClassPathTest]>
```
I suppose this must have been introduced in https://github.com/google/guava/commit/0fd4c5832699b3fb43bfe280794e02d29ba51ea2?
I assume as much.
Here's another one, which we see only in Travis, e.g., https://travis-ci.org/google/guava/jobs/53659073
```
testUrls(com.google.common.reflect.ClassPathTest): Number of URLs from system classloader (3) and number of URLs from ClassPath (1) do not match for resource META-INF/INDEX.LIST
```
While I've stripped the other tests out of Guava, I've left this one in, at least for now.
The Guava tests on Travis have been failing consistently for a while now because of this last last thing Chris mentions. We should really get this fixed somehow. Anyone want to investigate? @fluentfuture?
Latest errors form Travis output:
Oracle JDK8:
testUrls(com.google.common.reflect.ClassPathTest): Number of URLs from system classloader (3) and number of URLs from ClassPath (1) do not match for resource META-INF/INDEX.LIST
Oracle JDK7:
testUrls(com.google.common.reflect.ClassPathTest): META-INF/ORACLE_J.RSA has different content when loaded by resource.url()
OpenJDK7:
testUrls(com.google.common.reflect.ClassPathTest): META-INF/services/javax.sound.sampled.spi.MixerProvider has different content when loaded by resource.url()
The error message isn't detailed enough to tell if the resources were collected from a directory or a jar file.
I think first step is to change the test to use Truth assertThat() to get more information.
At the same time, what is the trick to reproduce the error locally?
I presume this is a stale bug? Our open-source build seems to be fine, so I'd guess so. Admittedly I don't know which CL fixed it. Maybe CL 90897375? Possibly we added debugging in CL 87967592 and CL 88115213? I'll close this, but if anyone is still seeing it, please reopen.  I'm glad you have your answer. But the issue is about whether this answer is clear in the documentation; if it's not, we should reopen it.
I believed that the first sentence of CacheBuilder was enough to cover this:
"A builder of LoadingCache and Cache instances having **any combination** of the following features."
(emphasis added)
Should we do more?
Thanks for your pull request.
It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA) at https://cla.developers.google.com/.
If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check the [information on your CLA](https://cla.developers.google.com/clas) or see this help article on [setting the email on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
Once you've done that, please reply here to let us know.  If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
Bulk closing all pull requests that are listed as needing CLA signing. If you'd like us to look at your pull request, you'll need to sign the CLA and report back here.
If this is a false positive, I apologize. Please reopen the pull request, and we'll have a look.  Can you elaborate on the deadlock? I guess the idea is that one thread starts to load ImmutableList while the other starts to load RegularImmutableList? That's probably not good, though we may have this problem in a lot of places, and I haven't heard reports of trouble... yet...
Sorry, I missed the last part of your message (about how you've hit this in prod). That makes more much more worried about this.
Part of the reason I'm worried is that we might have these cycles in lots of places. I'll fix this one, but we may have others. Maybe we should write a test that loads each of our classes in a new, instrumented `ClassLoader`. I'm always in over my head with `ClassLoader`, but I'm hoping that maybe we can override `loadClass` to record all classes loaded during the loading of the class. Then we can build a graph and look for cycles. If they're all over, we may just wait for reports to come in.... Hopefully there would be a manageable number.
`ClassLoader` is probably the wrong approach. @lukesandberg suggests that ASM may help. For now, though, I'm dropping this.
(The specific problem of `RegularImmutableList` has been fixed internally, so it will be mirrored out soon.)
Thought about this a little more today.
One subtlety here is how the app starts to initialize `RegularImmutableList` without first initializing `ImmutableList`. How does the app get at package-private `RegularImmutableList` except through `ImmutableList`? Well, it turns out that Guava calls directly into `RegularImmutableList` in places outside `ImmutableList`. For example, `ImmutableSortedMap.fromEntries` does this.
But if I turn off the restriction, again, I get many results, most of which are false positives. But to actually determine which are true positives, I'd have to soup up the analyzer. I think I need to find cases where we can get from a `public`/`protected` API into a clinit for a class? This sounds like a mess.
Given that, I think I'll just go after the high-visibility classes with _potential_ problems: `ImmutableSortedMultiset`, `ImmutableSortedSet`, and `ImmutableTable`. We should probably follow the `ImmutableList` pattern there if only to set a good example for ourselves.
I'll put this on my list, thanks.
wrote:
> The inherited doc should be overridden and mentioned that containsValue
> works in O(1) time in contrast to O(N) with a normal HashMap.
>
> The javadoc for #inverse should mention that it always returns the same
> Inverse instance and thus saving the Inverse as a separate instance
> variable is not mandatory to reduce overhead.
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/1973.
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
Kevin mentioned our issues with the Eclipse formatter in #1971, so I'm going to close this too. In addition to the Eclipse formatter issue, I'd also note that anything affecting large swaths of the codebase like this really needs to be done internally and then synced out. We just don't have a good way to make changes in the other direction.
Thanks for your pull request.
It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA) at https://cla.developers.google.com/.
If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check the [information on your CLA](https://cla.developers.google.com/clas) or see this help article on [setting the email on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
Once you've done that, please reply here to let us know.  If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
We found a Contributor License Agreement for you (the sender of this pull request), but were unable to find agreements for the commit author(s).  If you authored these, maybe you used a different email address in the git commits than was used to sign the CLA ([login here](https://cla.developers.google.com/) to double check)?  If these were authored by someone else, then they will need to sign a CLA as well, and confirm that they're okay with these being contributed to Google.
<!-- need_author_cla -->
We have found that no matter what the configuration, eclipse does not do an
acceptable job of auto-formatting code to Google style. We are planning to
open-source our own formatter in the next few months. Thanks for your
interest.
On Thu, Feb 12, 2015 at 2:50 AM, Raquel Pau notifications@github.com
wrote:
> Hi,
>
> I have applied the eclipse formatter using the Google configuration for
> Java projects available at
> https://code.google.com/p/google-styleguide/source/browse/trunk/eclipse-java-google-style.xml
> Is there another formatter configuration for this project?
>
> ## Thanks!
>
> You can view, comment on, or merge this pull request online at:
>
>   https://github.com/google/guava/pull/1971
> Commit Summary
> - google style
>
> File Changes
> - _A_ google-style.xml
>   https://github.com/google/guava/pull/1971/files#diff-0 (337)
> - _M_
>   guava-gwt/src/com/google/common/ForceGuavaCompilationEntryPoint.java
>   https://github.com/google/guava/pull/1971/files#diff-1 (24)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-2 (27)
> - _M_
>   guava-gwt/src/com/google/common/base/GwtSerializationDependencies.java
>   https://github.com/google/guava/pull/1971/files#diff-3 (63)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-4 (23)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-5 (20)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-6 (26)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-7 (37)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-8 (38)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-9 (38)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-10 (38)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-11 (20)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-12 (29)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-13 (33)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-14 (33)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-15 (31)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-16 (38)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-17 (45)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-18 (38)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-19 (27)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-20 (27)
> - _M_ guava-gwt/src/com/google/common/collect/GwtPlatform.java
>   https://github.com/google/guava/pull/1971/files#diff-21 (29)
> - _M_
>   guava-gwt/src/com/google/common/collect/GwtSerializationDependencies.java
>   https://github.com/google/guava/pull/1971/files#diff-22 (102)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-23 (9)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-24 (36)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-25 (36)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-26 (27)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-27 (28)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-28 (35)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-29 (33)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-30 (37)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-31 (32)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-32 (28)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-33 (28)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-34 (35)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-35 (28)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-36 (23)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-37 (23)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-38 (28)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-39 (11)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-40 (40)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-41 (32)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-42 (37)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-43 (32)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-44 (44)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-45 (30)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-46 (31)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-47 (38)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-48 (38)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-49 (37)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-50 (40)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-51 (42)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-52 (38)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-53 (35)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-54 (39)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-55 (38)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-56 (42)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-57 (34)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-58 (38)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-59 (29)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-60 (36)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-61 (34)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-62 (16)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-63 (20)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-64 (9)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-65 (21)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-66 (37)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-67 (31)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-68 (21)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-69 (66)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/AbstractCollectionTester.java
>   https://github.com/google/guava/pull/1971/files#diff-70 (37)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/AbstractContainerTester.java
>   https://github.com/google/guava/pull/1971/files#diff-71 (122)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/AbstractIteratorTester.java
>   https://github.com/google/guava/pull/1971/files#diff-72 (376)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/AbstractMapTester.java
>   https://github.com/google/guava/pull/1971/files#diff-73 (91)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/AbstractTester.java
>   https://github.com/google/guava/pull/1971/files#diff-74 (45)
> - _M_ guava-testlib/src/com/google/common/collect/testing/AnEnum.java
>   https://github.com/google/guava/pull/1971/files#diff-75 (20)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/BaseComparable.java
>   https://github.com/google/guava/pull/1971/files#diff-76 (26)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/CollectionTestSuiteBuilder.java
>   https://github.com/google/guava/pull/1971/files#diff-77 (48)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/DerivedCollectionGenerators.java
>   https://github.com/google/guava/pull/1971/files#diff-78 (164)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/DerivedComparable.java
>   https://github.com/google/guava/pull/1971/files#diff-79 (20)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/DerivedGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-80 (27)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/DerivedIteratorTestSuiteBuilder.java
>   https://github.com/google/guava/pull/1971/files#diff-81 (48)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/DerivedTestIteratorGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-82 (27)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/ExampleIteratorTester.java
>   https://github.com/google/guava/pull/1971/files#diff-83 (23)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/FeatureSpecificTestSuiteBuilder.java
>   https://github.com/google/guava/pull/1971/files#diff-84 (103)
> - _M_ guava-testlib/src/com/google/common/collect/testing/Helpers.java
>   https://github.com/google/guava/pull/1971/files#diff-85 (126)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/IteratorFeature.java
>   https://github.com/google/guava/pull/1971/files#diff-86 (49)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/IteratorTestSuiteBuilder.java
>   https://github.com/google/guava/pull/1971/files#diff-87 (38)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/IteratorTester.java
>   https://github.com/google/guava/pull/1971/files#diff-88 (71)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/ListIteratorTester.java
>   https://github.com/google/guava/pull/1971/files#diff-89 (53)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/ListTestSuiteBuilder.java
>   https://github.com/google/guava/pull/1971/files#diff-90 (59)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/MapInterfaceTest.java
>   https://github.com/google/guava/pull/1971/files#diff-91 (160)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/MapTestSuiteBuilder.java
>   https://github.com/google/guava/pull/1971/files#diff-92 (139)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/MinimalCollection.java
>   https://github.com/google/guava/pull/1971/files#diff-93 (64)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/MinimalIterable.java
>   https://github.com/google/guava/pull/1971/files#diff-94 (59)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/MinimalSet.java
>   https://github.com/google/guava/pull/1971/files#diff-95 (46)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/NavigableMapTestSuiteBuilder.java
>   https://github.com/google/guava/pull/1971/files#diff-96 (91)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/NavigableSetTestSuiteBuilder.java
>   https://github.com/google/guava/pull/1971/files#diff-97 (126)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/OneSizeGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-98 (33)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/OneSizeTestContainerGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-99 (35)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/PerCollectionSizeTestSuiteBuilder.java
>   https://github.com/google/guava/pull/1971/files#diff-100 (91)
> - _M_ guava-testlib/src/com/google/common/collect/testing/Platform.java
>   https://github.com/google/guava/pull/1971/files#diff-101 (31)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/QueueTestSuiteBuilder.java
>   https://github.com/google/guava/pull/1971/files#diff-102 (40)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/ReserializingTestCollectionGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-103 (28)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/ReserializingTestSetGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-104 (29)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/SafeTreeMap.java
>   https://github.com/google/guava/pull/1971/files#diff-105 (159)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/SafeTreeSet.java
>   https://github.com/google/guava/pull/1971/files#diff-106 (137)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/SampleElements.java
>   https://github.com/google/guava/pull/1971/files#diff-107 (54)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/SetTestSuiteBuilder.java
>   https://github.com/google/guava/pull/1971/files#diff-108 (61)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/SortedMapInterfaceTest.java
>   https://github.com/google/guava/pull/1971/files#diff-109 (47)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/SortedMapTestSuiteBuilder.java
>   https://github.com/google/guava/pull/1971/files#diff-110 (80)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/SortedSetTestSuiteBuilder.java
>   https://github.com/google/guava/pull/1971/files#diff-111 (69)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/TestCharacterListGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-112 (27)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/TestCollectionGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-113 (23)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/TestCollidingSetGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-114 (23)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/TestContainerGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-115 (59)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/TestEnumMapGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-116 (39)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/TestEnumSetGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-117 (20)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/TestIntegerSetGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-118 (47)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/TestIntegerSortedSetGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-119 (32)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/TestIteratorGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-120 (20)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/TestListGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-121 (20)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/TestMapEntrySetGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-122 (32)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/TestMapGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-123 (23)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/TestQueueGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-124 (20)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/TestSetGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-125 (20)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/TestSortedMapGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-126 (44)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/TestSortedSetGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-127 (20)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/TestStringCollectionGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-128 (23)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/TestStringListGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-129 (27)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/TestStringMapGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-130 (42)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/TestStringQueueGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-131 (24)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/TestStringSetGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-132 (38)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/TestStringSortedMapGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-133 (26)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/TestStringSortedSetGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-134 (35)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/TestSubjectGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-135 (24)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/TestUnhashableCollectionGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-136 (30)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/TestsForListsInJavaUtil.java
>   https://github.com/google/guava/pull/1971/files#diff-137 (276)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/TestsForMapsInJavaUtil.java
>   https://github.com/google/guava/pull/1971/files#diff-138 (258)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/TestsForQueuesInJavaUtil.java
>   https://github.com/google/guava/pull/1971/files#diff-139 (146)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/TestsForSetsInJavaUtil.java
>   https://github.com/google/guava/pull/1971/files#diff-140 (359)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/UnhashableObject.java
>   https://github.com/google/guava/pull/1971/files#diff-141 (29)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/WrongType.java
>   https://github.com/google/guava/pull/1971/files#diff-142 (25)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/features/CollectionFeature.java
>   https://github.com/google/guava/pull/1971/files#diff-143 (87)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/features/CollectionSize.java
>   https://github.com/google/guava/pull/1971/files#diff-144 (59)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-145 (29)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/features/Feature.java
>   https://github.com/google/guava/pull/1971/files#diff-146 (20)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/features/FeatureUtil.java
>   https://github.com/google/guava/pull/1971/files#diff-147 (194)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/features/ListFeature.java
>   https://github.com/google/guava/pull/1971/files#diff-148 (41)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/features/MapFeature.java
>   https://github.com/google/guava/pull/1971/files#diff-149 (63)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/features/SetFeature.java
>   https://github.com/google/guava/pull/1971/files#diff-150 (27)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/features/TesterAnnotation.java
>   https://github.com/google/guava/pull/1971/files#diff-151 (31)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/features/TesterRequirements.java
>   https://github.com/google/guava/pull/1971/files#diff-152 (42)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/AbstractBiMapTester.java
>   https://github.com/google/guava/pull/1971/files#diff-153 (26)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/AbstractListMultimapTester.java
>   https://github.com/google/guava/pull/1971/files#diff-154 (11)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/AbstractMultimapTester.java
>   https://github.com/google/guava/pull/1971/files#diff-155 (34)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/AbstractMultisetSetCountTester.java
>   https://github.com/google/guava/pull/1971/files#diff-156 (90)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/AbstractMultisetTester.java
>   https://github.com/google/guava/pull/1971/files#diff-157 (23)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/BiMapClearTester.java
>   https://github.com/google/guava/pull/1971/files#diff-158 (20)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/BiMapGenerators.java
>   https://github.com/google/guava/pull/1971/files#diff-159 (36)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/BiMapInverseTester.java
>   https://github.com/google/guava/pull/1971/files#diff-160 (25)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/BiMapPutTester.java
>   https://github.com/google/guava/pull/1971/files#diff-161 (28)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/BiMapRemoveTester.java
>   https://github.com/google/guava/pull/1971/files#diff-162 (20)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/BiMapTestSuiteBuilder.java
>   https://github.com/google/guava/pull/1971/files#diff-163 (50)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/DerivedGoogleCollectionGenerators.java
>   https://github.com/google/guava/pull/1971/files#diff-164 (52)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/ListGenerators.java
>   https://github.com/google/guava/pull/1971/files#diff-165 (90)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/ListMultimapAsMapTester.java
>   https://github.com/google/guava/pull/1971/files#diff-166 (45)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/ListMultimapEqualsTester.java
>   https://github.com/google/guava/pull/1971/files#diff-167 (25)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/ListMultimapPutAllTester.java
>   https://github.com/google/guava/pull/1971/files#diff-168 (11)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/ListMultimapPutTester.java
>   https://github.com/google/guava/pull/1971/files#diff-169 (6)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/ListMultimapRemoveTester.java
>   https://github.com/google/guava/pull/1971/files#diff-170 (6)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/ListMultimapReplaceValuesTester.java
>   https://github.com/google/guava/pull/1971/files#diff-171 (11)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/ListMultimapTestSuiteBuilder.java
>   https://github.com/google/guava/pull/1971/files#diff-172 (65)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MapGenerators.java
>   https://github.com/google/guava/pull/1971/files#diff-173 (65)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultimapAsMapGetTester.java
>   https://github.com/google/guava/pull/1971/files#diff-174 (44)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultimapAsMapTester.java
>   https://github.com/google/guava/pull/1971/files#diff-175 (42)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultimapClearTester.java
>   https://github.com/google/guava/pull/1971/files#diff-176 (37)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultimapContainsEntryTester.java
>   https://github.com/google/guava/pull/1971/files#diff-177 (34)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultimapContainsKeyTester.java
>   https://github.com/google/guava/pull/1971/files#diff-178 (23)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultimapContainsValueTester.java
>   https://github.com/google/guava/pull/1971/files#diff-179 (23)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultimapEntriesTester.java
>   https://github.com/google/guava/pull/1971/files#diff-180 (50)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultimapEqualsTester.java
>   https://github.com/google/guava/pull/1971/files#diff-181 (35)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultimapFeature.java
>   https://github.com/google/guava/pull/1971/files#diff-182 (23)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultimapGetTester.java
>   https://github.com/google/guava/pull/1971/files#diff-183 (43)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultimapKeySetTester.java
>   https://github.com/google/guava/pull/1971/files#diff-184 (14)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultimapKeysTester.java
>   https://github.com/google/guava/pull/1971/files#diff-185 (40)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultimapPutAllMultimapTester.java
>   https://github.com/google/guava/pull/1971/files#diff-186 (72)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultimapPutIterableTester.java
>   https://github.com/google/guava/pull/1971/files#diff-187 (44)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultimapPutTester.java
>   https://github.com/google/guava/pull/1971/files#diff-188 (25)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultimapRemoveAllTester.java
>   https://github.com/google/guava/pull/1971/files#diff-189 (31)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultimapRemoveEntryTester.java
>   https://github.com/google/guava/pull/1971/files#diff-190 (28)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultimapReplaceValuesTester.java
>   https://github.com/google/guava/pull/1971/files#diff-191 (45)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultimapSizeTester.java
>   https://github.com/google/guava/pull/1971/files#diff-192 (25)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultimapTestSuiteBuilder.java
>   https://github.com/google/guava/pull/1971/files#diff-193 (271)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultimapToStringTester.java
>   https://github.com/google/guava/pull/1971/files#diff-194 (9)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultimapValuesTester.java
>   https://github.com/google/guava/pull/1971/files#diff-195 (7)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultisetAddTester.java
>   https://github.com/google/guava/pull/1971/files#diff-196 (49)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultisetContainsTester.java
>   https://github.com/google/guava/pull/1971/files#diff-197 (11)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultisetCountTester.java
>   https://github.com/google/guava/pull/1971/files#diff-198 (49)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultisetElementSetTester.java
>   https://github.com/google/guava/pull/1971/files#diff-199 (26)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultisetEntrySetTester.java
>   https://github.com/google/guava/pull/1971/files#diff-200 (117)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultisetEqualsTester.java
>   https://github.com/google/guava/pull/1971/files#diff-201 (31)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultisetFeature.java
>   https://github.com/google/guava/pull/1971/files#diff-202 (21)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultisetIteratorTester.java
>   https://github.com/google/guava/pull/1971/files#diff-203 (29)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultisetNavigationTester.java
>   https://github.com/google/guava/pull/1971/files#diff-204 (43)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultisetReadsTester.java
>   https://github.com/google/guava/pull/1971/files#diff-205 (64)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultisetRemoveTester.java
>   https://github.com/google/guava/pull/1971/files#diff-206 (100)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultisetSerializationTester.java
>   https://github.com/google/guava/pull/1971/files#diff-207 (23)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultisetSetCountConditionallyTester.java
>   https://github.com/google/guava/pull/1971/files#diff-208 (45)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultisetSetCountUnconditionallyTester.java
>   https://github.com/google/guava/pull/1971/files#diff-209 (38)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/MultisetTestSuiteBuilder.java
>   https://github.com/google/guava/pull/1971/files#diff-210 (83)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/SetGenerators.java
>   https://github.com/google/guava/pull/1971/files#diff-211 (232)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/SetMultimapAsMapTester.java
>   https://github.com/google/guava/pull/1971/files#diff-212 (45)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/SetMultimapEqualsTester.java
>   https://github.com/google/guava/pull/1971/files#diff-213 (27)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/SetMultimapPutAllTester.java
>   https://github.com/google/guava/pull/1971/files#diff-214 (9)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/SetMultimapPutTester.java
>   https://github.com/google/guava/pull/1971/files#diff-215 (9)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/SetMultimapReplaceValuesTester.java
>   https://github.com/google/guava/pull/1971/files#diff-216 (10)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/SetMultimapTestSuiteBuilder.java
>   https://github.com/google/guava/pull/1971/files#diff-217 (82)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/SortedMapGenerators.java
>   https://github.com/google/guava/pull/1971/files#diff-218 (47)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/SortedMultisetTestSuiteBuilder.java
>   https://github.com/google/guava/pull/1971/files#diff-219 (245)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/SortedSetMultimapAsMapTester.java
>   https://github.com/google/guava/pull/1971/files#diff-220 (14)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/SortedSetMultimapGetTester.java
>   https://github.com/google/guava/pull/1971/files#diff-221 (28)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/SortedSetMultimapTestSuiteBuilder.java
>   https://github.com/google/guava/pull/1971/files#diff-222 (58)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/TestBiMapGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-223 (24)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/TestEnumMultisetGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-224 (26)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/TestListMultimapGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-225 (24)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/TestMultimapGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-226 (24)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/TestMultisetGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-227 (20)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/TestSetMultimapGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-228 (24)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/TestStringBiMapGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-229 (42)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/TestStringListMultimapGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-230 (39)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/TestStringMultisetGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-231 (24)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/TestStringSetMultimapGenerator.java
>   https://github.com/google/guava/pull/1971/files#diff-232 (39)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/google/UnmodifiableCollectionTests.java
>   https://github.com/google/guava/pull/1971/files#diff-233 (178)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/AbstractListIndexOfTester.java
>   https://github.com/google/guava/pull/1971/files#diff-234 (54)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/AbstractListTester.java
>   https://github.com/google/guava/pull/1971/files#diff-235 (45)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/AbstractQueueTester.java
>   https://github.com/google/guava/pull/1971/files#diff-236 (20)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/AbstractSetTester.java
>   https://github.com/google/guava/pull/1971/files#diff-237 (25)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/CollectionAddAllTester.java
>   https://github.com/google/guava/pull/1971/files#diff-238 (77)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/CollectionAddTester.java
>   https://github.com/google/guava/pull/1971/files#diff-239 (81)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/CollectionClearTester.java
>   https://github.com/google/guava/pull/1971/files#diff-240 (35)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/CollectionContainsAllTester.java
>   https://github.com/google/guava/pull/1971/files#diff-241 (38)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/CollectionContainsTester.java
>   https://github.com/google/guava/pull/1971/files#diff-242 (40)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/CollectionCreationTester.java
>   https://github.com/google/guava/pull/1971/files#diff-243 (32)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/CollectionEqualsTester.java
>   https://github.com/google/guava/pull/1971/files#diff-244 (33)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/CollectionIsEmptyTester.java
>   https://github.com/google/guava/pull/1971/files#diff-245 (25)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/CollectionIteratorTester.java
>   https://github.com/google/guava/pull/1971/files#diff-246 (67)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/CollectionRemoveAllTester.java
>   https://github.com/google/guava/pull/1971/files#diff-247 (57)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/CollectionRemoveTester.java
>   https://github.com/google/guava/pull/1971/files#diff-248 (58)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/CollectionRetainAllTester.java
>   https://github.com/google/guava/pull/1971/files#diff-249 (86)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-250 (28)
> - _M_
>   https://github.com/google/guava/pull/1971/files#diff-251 (23)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/CollectionSizeTester.java
>   https://github.com/google/guava/pull/1971/files#diff-252 (25)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/CollectionToArrayTester.java
>   https://github.com/google/guava/pull/1971/files#diff-253 (98)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/CollectionToStringTester.java
>   https://github.com/google/guava/pull/1971/files#diff-254 (41)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/ListAddAllAtIndexTester.java
>   https://github.com/google/guava/pull/1971/files#diff-255 (47)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/ListAddAllTester.java
>   https://github.com/google/guava/pull/1971/files#diff-256 (38)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/ListAddAtIndexTester.java
>   https://github.com/google/guava/pull/1971/files#diff-257 (43)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/ListAddTester.java
>   https://github.com/google/guava/pull/1971/files#diff-258 (37)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/ListCreationTester.java
>   https://github.com/google/guava/pull/1971/files#diff-259 (24)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/ListEqualsTester.java
>   https://github.com/google/guava/pull/1971/files#diff-260 (39)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/ListGetTester.java
>   https://github.com/google/guava/pull/1971/files#diff-261 (25)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/ListHashCodeTester.java
>   https://github.com/google/guava/pull/1971/files#diff-262 (31)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/ListIndexOfTester.java
>   https://github.com/google/guava/pull/1971/files#diff-263 (35)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/ListLastIndexOfTester.java
>   https://github.com/google/guava/pull/1971/files#diff-264 (34)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/ListListIteratorTester.java
>   https://github.com/google/guava/pull/1971/files#diff-265 (57)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/ListRemoveAllTester.java
>   https://github.com/google/guava/pull/1971/files#diff-266 (33)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/ListRemoveAtIndexTester.java
>   https://github.com/google/guava/pull/1971/files#diff-267 (28)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/ListRemoveTester.java
>   https://github.com/google/guava/pull/1971/files#diff-268 (39)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/ListRetainAllTester.java
>   https://github.com/google/guava/pull/1971/files#diff-269 (30)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/ListSetTester.java
>   https://github.com/google/guava/pull/1971/files#diff-270 (55)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/ListSubListTester.java
>   https://github.com/google/guava/pull/1971/files#diff-271 (148)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/ListToArrayTester.java
>   https://github.com/google/guava/pull/1971/files#diff-272 (37)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/MapClearTester.java
>   https://github.com/google/guava/pull/1971/files#diff-273 (37)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/MapContainsKeyTester.java
>   https://github.com/google/guava/pull/1971/files#diff-274 (45)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/MapContainsValueTester.java
>   https://github.com/google/guava/pull/1971/files#diff-275 (45)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/MapCreationTester.java
>   https://github.com/google/guava/pull/1971/files#diff-276 (35)
> - _M_
>   guava-testlib/src/com/google/common/collect/testing/testers/MapEntrySetTester.java
>   https://github.com/google/guava/pull/1971/files#diff-277 (0)
> - _I_
>   guava-testlib/src/com/google/common/collect/testing/testers/MapEqualsTester.java
>   https://github.com/google/guava/pull/1971/files#diff-278 (0)
> - _I_
>   guava-testlib/src/com/google/common/collect/testing/testers/MapGetTester.java
>   https://github.com/google/guava/pull/1971/files#diff-279 (0)
> - _I_
>   guava-testlib/src/com/google/common/collect/testing/testers/MapHashCodeTester.java
>   https://github.com/google/guava/pull/1971/files#diff-280 (0)
> - _I_
>   guava-testlib/src/com/google/common/collect/testing/testers/MapIsEmptyTester.java
>   https://github.com/google/guava/pull/1971/files#diff-281 (0)
> - _I_
>   guava-testlib/src/com/google/common/collect/testing/testers/MapPutAllTester.java
>   https://github.com/google/guava/pull/1971/files#diff-282 (0)
> - _I_
>   guava-testlib/src/com/google/common/collect/testing/testers/MapPutTester.java
>   https://github.com/google/guava/pull/1971/files#diff-283 (0)
> - _I_
>   guava-testlib/src/com/google/common/collect/testing/testers/MapRemoveTester.java
>   https://github.com/google/guava/pull/1971/files#diff-284 (0)
> - _I_
>   guava-testlib/src/com/google/common/collect/testing/testers/MapSerializationTester.java
>   https://github.com/google/guava/pull/1971/files#diff-285 (0)
> - _I_
>   guava-testlib/src/com/google/common/collect/testing/testers/MapSizeTester.java
>   https://github.com/google/guava/pull/1971/files#diff-286 (0)
> - _I_
>   guava-testlib/src/com/google/common/collect/testing/testers/MapToStringTester.java
>   https://github.com/google/guava/pull/1971/files#diff-287 (0)
> - _I_
>   guava-testlib/src/com/google/common/collect/testing/testers/NavigableMapNavigationTester.java
>   https://github.com/google/guava/pull/1971/files#diff-288 (0)
> - _I_
>   guava-testlib/src/com/google/common/collect/testing/testers/NavigableSetNavigationTester.java
>   https://github.com/google/guava/pull/1971/files#diff-289 (0)
> - _I_
>   guava-testlib/src/com/google/common/collect/testing/testers/Platform.java
>   https://github.com/google/guava/pull/1971/files#diff-290 (0)
> - _I_
>   guava-testlib/src/com/google/common/collect/testing/testers/QueueElementTester.java
>   https://github.com/google/guava/pull/1971/files#diff-291 (0)
> - _I_
>   guava-testlib/src/com/google/common/collect/testing/testers/QueueOfferTester.java
>   https://github.com/google/guava/pull/1971/files#diff-292 (0)
> - _I_
>   guava-testlib/src/com/google/common/collect/testing/testers/QueuePeekTester.java
>   https://github.com/google/guava/pull/1971/files#diff-293 (0)
> - _I_
>   guava-testlib/src/com/google/common/collect/testing/testers/QueuePollTester.java
>   https://github.com/google/guava/pull/1971/files#diff-294 (0)
> - _I_
>   guava-testlib/src/com/google/common/collect/testing/testers/QueueRemoveTester.java
>   https://github.com/google/guava/pull/1971/files#diff-295 (0)
> - _I_
>   guava-testlib/src/com/google/common/collect/testing/testers/SetAddAllTester.java
>   https://github.com/google/guava/pull/1971/files#diff-296 (0)
> - _I_
>   guava-testlib/src/com/google/common/collect/testing/testers/SetAddTester.java
>   https://github.com/google/guava/pull/1971/files#diff-297 (0)
> - _I_
>   guava-testlib/src/com/google/common/collect/testing/testers/SetCreationTester.java
>   https://github.com/google/guava/pull/1971/files#diff-298 (0)
> - _I_
>   guava-testlib/src/com/google/common/collect/testing/testers/SetEqualsTester.java
>   https://github.com/google/guava/pull/1971/files#diff-299 (0)
> - _I_
>   guava-testlib/src/com/google/common/collect/testing/testers/SetHashCodeTester.java
>   https://github.com/google/guava/pull/1971/files#diff-300 (0)
>
> - https://github.com/google/guava/pull/1971.patch
> - https://github.com/google/guava/pull/1971.diff
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/pull/1971.
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
> But do you follow the guide of Java code conventions writen by Google?
Yes.  Some of our team members are on the committee that writes Google's Java style guide.
I'm not sure what you expect here, other than "it generates awkward code or code that doesn't satisfy our style guide no matter how we configure it."
Don't use an automatic formatter; format only the lines you change, by hand.
It seems unproductive to try to give a long explanation of what we found unacceptable about eclipse's formatter, when we will be releasing our formatter and you can see the differences for yourself.
Rather than merging this into jdk5-backport-master, I think I'll just pull it as a separate branch and give it a tag. Running the tests against a JDK5 rt.jar, I found one test in `ByteStreamsTest` that was calling `getBytes(Charset)` which didn't exist in JDK5. I'll just add a commit fixing that to the branch.
I've pulled the branch in (plus the fix I mentioned) with the tag `jdk5-backport-v17.0-compatibility` (https://github.com/google/guava/commits/jdk5-backport-v17.0-compatibility).
Thanks for your pull request.
It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA) at https://cla.developers.google.com/.
If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address.  Check the [information on your CLA](https://cla.developers.google.com/clas) or see this help article on [setting the email on your git commits](https://help.github.com/articles/setting-your-email-in-git/).
Once you've done that, please reply here to let us know.  If you signed the CLA as a corporation, please let us know the company's name.
<!-- need_sender_cla -->
You say that it "should be able to accept more inputs", but it will already accept your `Map<Integer, String>` just fine as it is. It returns you a `Function<Integer, String>` which is the correct type for what it is. Now, if you have a reason to want to cast that to a different type, that's up to you.
The value probably drops off rapidly after the first couple:
- `Equivalence`: `doEquivalent`, `doHash`
- `AbstractService`: `doStart`, `doStop`
- `AbstractExecutionThreadService`: `run`
- `AbstractIdleService`: `shutDown`, `startUp`
- `AbstractScheduledService`: `runOneIteration`, `scheduler`
- `AbstractFuture`: `newCancellationCause` (if we add it), `interruptTask`
- `AbstractCheckedFuture`: `mapException`
We could probably look at even more classes:
$ grep -r '^  protected abstract' . | grep -v -e delegate -e ' class ' -e escape
./com/google/common/collect/AbstractIterator.java:  protected abstract T computeNext();
./com/google/common/collect/AbstractSequentialIterator.java:  protected abstract T computeNext(T previous);
./com/google/common/collect/AbstractIndexedListIterator.java:  protected abstract E get(int index);
./com/google/common/hash/AbstractByteHasher.java:  protected abstract void update(byte b);
./com/google/common/hash/AbstractStreamingHasher.java:  protected abstract void process(ByteBuffer bb);
./com/google/common/hash/AbstractStreamingHasher.java:  protected abstract HashCode makeHash();
./com/google/common/base/AbstractIterator.java:  protected abstract T computeNext();
./com/google/common/base/Converter.java:  protected abstract B doForward(A a);
./com/google/common/base/Converter.java:  protected abstract A doBackward(B b);
./com/google/common/base/Equivalence.java:  protected abstract boolean doEquivalent(T a, T b);
./com/google/common/base/Equivalence.java:  protected abstract int doHash(T t);
./com/google/common/util/concurrent/AbstractCheckedFuture.java:  protected abstract X mapException(Exception e);
./com/google/common/util/concurrent/AbstractScheduledService.java:  protected abstract void runOneIteration() throws Exception;
./com/google/common/util/concurrent/AbstractScheduledService.java:  protected abstract Scheduler scheduler();
./com/google/common/util/concurrent/AbstractExecutionThreadService.java:  protected abstract void run() throws Exception;
./com/google/common/util/concurrent/WrappingExecutorService.java:  protected abstract <T> Callable<T> wrapTask(Callable<T> callable);
./com/google/common/util/concurrent/AbstractService.java:  protected abstract void doStart();
./com/google/common/util/concurrent/AbstractService.java:  protected abstract void doStop();
./com/google/common/util/concurrent/AbstractIdleService.java:  protected abstract void startUp() throws Exception;
./com/google/common/util/concurrent/AbstractIdleService.java:  protected abstract void shutDown() throws Exception;
./com/google/common/reflect/AbstractInvocationHandler.java:  protected abstract Object handleInvocation(Object proxy, Method method, Object[] args)
./com/google/common/io/LineBuffer.java:  protected abstract void handleLine(String line, String end) throws IOException;
But I think the ones we've already done (or are in the process of doing) are the ones with the most value, especially `AbstractService`. (It might be worth doing the other `Service` classes, too -- not that they appear to have many violations (if any) inside Google, but if anyone does misuse them, they're turning asynchronous code into synchronous code, just as we saw with `AbstractService`.)  I took a look at existing callers inside Google, and only found about 2% (of both asMap/toMap) that pass the identity function to these methods. I'm not sure I really see this as a common enough operation to warrant adding these new APIs.
Can you try to make a stronger case for why we should add these?
Thanks,
I think what you have now (passing Functions.identity()) is probably OK...marking this as won't fix.
Thanks for the feedback though!
Concur: a reasonable idea, but just not common enough.
We'll discuss this at our weekly API review meeting on Monday and I'll get back to you.
@bacar Sorry for not getting back to you on this.  We did discuss it at our API meeting, and we decided to leave it as Beta for now.  There's a few open issues w.r.t. MapSplitter, but following issues were the most worrisome:
https://github.com/google/guava/issues/1900 : MapSplitter should ignore key-value separator after first
https://github.com/google/guava/issues/870 : MapSplitter doesn't trim keys and values as expected
We'll discuss this at our weekly API review meeting on Monday and I'll get back to you.
These methods will be graduating from `@Beta`. Thanks for the request!
We picked up this update to the Mozilla Public Suffix list in November. It will show up in Guava 19.0.
I don't see how this could be possible without unacceptable performance cost?  I think if you tried to implement this in ImmutableList you'd see why, but in summary -- you have to maintain a reference to _something_, either the array or the ImmutableList.  Copying the array on an iterator() call would increase the asymptotic cost of an iterator() call from O(1) to O(n), and nulling out the elements behind you would break ImmutableList generally, if you could only iterate over it once.  I don't see any way of doing this feature request without breaking asymptotic or semantic guarantees.
It sounds like this is the wrong solution for your problem, however -- perhaps you'd be better off with a queue of some kind, where elements are expected to be consumed once.
All the immutable collections are expected to have competitive performance with their most popular JDK mutable alternatives; ImmutableList is array-based because arrays are by far the fastest and most efficient way to implement lists.  O(1) get(int) is definitely not negotiable.
It really does look like a list isn't really the data structure you really want in this context.  Is there a compelling reason ImmutableList ought to be used here?
As mentioned above, a queue seems more like what you're looking for?  Queues _expect_ to have an element consumed once and never used again.
I didn't have using Queue.iterator() in mind, I had in mind using the Queue directly instead of an iterator.
FWIW, I don't believe _any_ JDK iterator implementation has the property you're looking for?  All of ArrayList, LinkedList (over doubly linked list nodes), HashSet, LinkedHashSet, and TreeSet have iterators that appear to retain references to the entire collection.
As far as "a Collection that lets you stream over immutable data once" goes, the immutability of the collection data structure and the immutability of the data inside it are orthogonal concerns.  ImmutableList can be used freely for mutable element types; ArrayList can be used freely for immutable data types.
Possibly relevant: Iterables.consumingIterable, which has a special implementation for Queue.
toString() has worked as you describe since 15.0. Do you have an older version of Guava on your classpath alongside 18.0?
(sorry, "worked as you describe" meaning "returns the name")
Guava-for-Android is something we're working on actively now, in collaboration with Android teams within Google, so I figured I'd discuss some of the work we're doing there and how we expect that to look.
Guava 22 will include a Java 7 backport.  We see Android as a key customer of that backport, so the backport will reflect that.
We're not going to split Guava up into multiple jars; we still don't think that's likely to help.  We still see the use of ProGuard as key to just about any Android app period.  What we're working on includes
- monitoring what code ProGuard retains, so that when you use any particular Guava API, the code ProGuard retains is exactly the code that actually gets used.  So far we haven't changed public API, and I'm not sure we will, but we've been reorganizing and inlining code to make sure you're not picking up wasteful code and ProGuard is able to eliminate everything it should.
- redesigning key data structures to reduce or eliminate allocation and memory waste; in some cases we're creating an entirely new implementation to live in the Java 7 branch.
- investigating potential new libraries motivated by Android use cases
By no means will all this work be done by the release of Guava 22, but we're starting with the immutable collections and working outward from there.  We'll discuss in the release notes what APIs we've worked over for each release.  Thanks, I've merged in a slightly modified version of this in https://github.com/google/guava/commit/65c42d94306c3d9e16b4722c1d71a7d910c610a3.
AFAICT, we actually have this already implemented but restricted to @GoogleInternal.
@philipp-classen We don't actually consider guava-testlib to be "internal". Users are free to depend on guava-testlib from their tests; we don't want to include the stuff there in the main guava artifact because depending on utilities intended for testing in non-test code isn't something you want to do generally.
Marvin, isn't it easier to write checkArgument(!xyz.isEmpty())?
pressure, and I don't see any value having coming from it at all. Is there
response to null input? Could one recognize which type of API should be
which? I don't think so; it comes down to mere developer preference, so we
benefit from having a single standard instead, which we've had for well
over a decade.
On Sat, Jan 28, 2017 at 4:26 AM, Marvin Z <notifications@github.com> wrote:
>  We are using checkArgument(!Strings.isNullOrEmpty(xyz)) a lot, which
> is why this addition would be really great. I know it's called
> NullPointerTester and not PreconditionsTester or something, but if you have
> it internally, could you 'publish' it? :)
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/pull/1949#issuecomment-275845505>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AA5ClwcuF_JXwwM-Ia9GlOmWQcn75-pkks5rWzP-gaJpZM4DTeU2>
> .
>
--
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
https://github.com/google/guava/commit/252832d66a77cc19ba8b4d9c40afd2796127404c
Hmm, can't figure out how to assign this to a non-team member, but @marceljuenemann is gonna take care of this for us.
`String.format` depends on the default locale, leading to problems like #1567. We can fix it by passing `Locale.ROOT` to each call, but this is kind of ugly, especially for an API that exists in large part to eliminate ugly string-concatenation code.
Where would it go?
- `Strings.format`: looks like `String.format`, possibly too much so
- `RootLocale.format`: gives a place for future such methods. Are there any candidates?
And how worried are we about use of the default locale here? Oddly, I'm not sure I've ever heard anyone crusading against `String.format`, even though there are crusaders against many other default-locale APIs. Maybe it's just less frequently noticed there, in part because users often just use `%s`? Plus, the output is probably more often used for debugging than it would be for, e.g., `SimpleDateFormat`.
The link you've included takes me to this...
"""
Returns a serializable ordering that uses the natural order of the values. The ordering throws a NullPointerException when passed a null parameter.
The type specification is <C extends Comparable>, instead of the technically correct <C extends Comparable<? super C>>, to support legacy types from before Java 5.
"""
...which seems to speak to the issue. Any suggestions for how we could make it better?
https://github.com/google/guava/commit/3c090f535a548473adf3a7bd66520c377e6a696b
I think you're right. Seems like just the reason we left this comment. That
said, there's probably no hurry to do this.
On Sun, Jan 11, 2015 at 10:28 PM, Bernardo Sulzbach <
notifications@github.com> wrote:
> Please see
> https://github.com/google/guava/blob/master/guava/src/com/google/common/primitives/Booleans.java#L235
> .
>
> Isn't Java 6 available?
> If it is, should that comment be removed?
> Should the method be removed? (It is private and only used in a single
> place).
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/1942.
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
We actually need to do this for all of the primitive utility classes in c.g.common.primitives. I'm submitting a fix internally and it'll get mirrored out within the next few days. Thanks for finding this!
Actually...as it turns out we can't fix this quite yet, because the methods don't exist in GWT 2.6.1 (they do in GWT 2.7.0). So we can't fix this until we upgrade to GWT 2.7.0.
For the moment, I would assume that all GWT-Java 8 errors are the same underlying problem. Let's track this as part of #1939.
Can you find the section of the log that shows which tests failed? I see "Failures: 16" in the final summary, but can you see which "Running com.google.common.SomeTest" section those failures come from? While I see the logging from UncaughtExceptionHandlersTest and probably ServiceManagerTest, that logging is expected. (It would be nice for us to silence it, but we haven't.)
My initial suspicion from seeing "SCHWERWIEGEND" in your output is that you're seeing https://github.com/google/guava/issues/1567, which we really ought to fix.
That's great, thanks. This does look like #1567. I'll fix that shortly.
I put together a problem with Java 8, guava-gwt-18, GWT 2.7.0, and a client call to `Collections2.filter`, and it works in both SuperDevMode and Prod Mode. Can you give me some more detail about how to reproduce the problem (ideally a small example GWT project)?
Thanks! I am still being a bit clueless here -- a bit caught in my bubble of writing GWT applications only with our internal tools :( I've loaded the project into Eclipse to compile there. If I pass `-strict`, then it fails with the `BitSet` problem (issue 1824). If I omit `-strict`, then it compiles successfully. Any other hints for how to reproduce the `Collections`/`Maps`/`Multimaps` problem?
Are you able to reproduce this in the sample project? And is the sample project using GWT 2.5.1?
I found the other discussion on http://stackoverflow.com/q/27870181/28465, which suggests that you're seeing this problem with the latest GWT snapshot rather than with 2.5.1. That may explain why I haven't been able to reproduce it. (I started looking into pulling files from, e.g., https://oss.sonatype.org/content/repositories/google-snapshots/com/google/gwt/gwt-servlet/2.8.0-SNAPSHOT/)
Thanks. I'm able to reproduce with the GWT 2.8 snapshot and Java 8.
Since the GWT team has [an accepted bug](https://code.google.com/p/google-web-toolkit/issues/detail?id=9036) for this problem, and since [the underlying problem in the Eclipse compiler](https://bugs.eclipse.org/bugs/show_bug.cgi?id=443596) has been fixed, and since it occurs only at the GWT trunk, I don't think there's much for us to do here.
It sounds like GWT has made the necessary upgrade on their end: https://code.google.com/p/google-web-toolkit/issues/detail?id=9036#c7
New GWT link: https://github.com/gwtproject/gwt/issues/8989
We would need to review `dereference` callers to see if they'd work similarly well with the `setFuture` style. Among the "styles" of calls I've seen in a quick glance:
- `dereference(transform(input, function))`: probably can be written as `transform(input, *async*Function)`
- `dereference(executor.submit(taskReturningFuture))`: probably can be written as `executor.submit(taskSettingValueOfFuture)`, but I feel like that will have bad effects. For example, might cancellation no longer work proerly?
- `dereference(combine(...))`: Hmm... :( I'm sure it can be done, but this is starting to sound messy.
We should at least document `dereference` to guide users toward `setFuture`.
https://github.com/google/guava/issues/2076 proposes the addition of `MoreExecutors.submitAsync`, which would help with the `dereference(executor.submit)` case.  You can. You'll get a `FluentIterable<? extends T>`.
I think Kevin's arguing that you should change the other code to accept a
FluentIterable<? extends T> instead of changing the Guava code to return a
FluentIterable<T>.
On Mon Dec 29 2014 at 10:51:01 PM Eugene Petrenko notifications@github.com
wrote:
> This is not clear why we cannot have
> public <T> FluentIterable<T> from(Iterable<? extends T> foo)
> Similar constructions works for me in many cases
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/1933#issuecomment-68312285.
During some investigation of potential `@CheckReturnValue` methods (https://github.com/google/error-prone/issues/276), I found a number of users who call `Iterators.getLast` (~3 times) or especially `Iterators.size` (~17 times) solely for the side effect of exhausting the iterator. The calls to `size` feel particularly questionable. `getLast` feels more acceptable but still pretty strange, and if users use the one-arg version (as all 3 users I found do), they need to think to guard it with a `hasNext` check. (Of the 3, 1 did, and the other 2 are in tests where at least one element is expected.)
One thing arguing against the addition of this method is that advancing iterators shouldn't typically have side effects. For the particular case in which cleanup at the end is necessary, the iterator should perhaps instead implement `Closeable`. Would we want to add a method to support what we consider to be a questionable use case simply because it would let users do their questionable thing in a more explicit way?
As you suggest at the end... I believe it is important that no Iterator should ever care whether it is exhausted or not. Any that does is an accident waiting to happen. We have some like this (at least Iterators.consumingIterator()) and I think they were mistakes. So I would not want to add this method.
So I'm trying to add `@CheckReturnValue` to `com.google.common.collect.Lists`, and there are _lots_ of folks using `Lists.newArrayList(iterable/iterator)` just to force iteration of their underlying iterator. Lots of these are in tests, where they're expecting an exception to get thrown during iteration or something.
I don't think `Iterables.exhaust()` makes sense (what does it mean to exhaust an iterable?), but `Iterators.exhaust()` is sounding more and more appealing. The alternative is to just write silly loops for loops:
For an iterable:
```
for (String foo : iterable) {
// do nothing
}
```
For an iterator:
```
while (iterator.hasNext()) {
iterator.next();
}
```
Both of these could be better served by an `Iterators.exhaust()` method.
I would rather make them write the loops :) Mainly, I don't want to signal that such an `Iterable`/`Iterator` is a good idea. I think we'd be sending that signal if we added an `exhaust` method. (Yes, I know that I'm the one that filed this issue :))
So the "iterators that throw exceptions" thing is kind of gross, but I've also seen folks do this to preload the underlying data. I guess a for-loop is reasonable there too though.
I think I'm with Chris.
On Fri, Jan 22, 2016 at 1:16 PM, Chris Povirk notifications@github.com
wrote:
> I would rather make them write the loops :) Mainly, I don't want to signal
> that such an Iterable/Iterator is a good idea. I think we'd be sending
> that signal if we added an exhaust method. (Yes, I know that I'm the one
> that filed this issue :))
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/1932#issuecomment-174051563.
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
Also to be clear, the for-each loop above needs to be:
```
for (String unused : iterable) {
// do nothing
}
```
Otherwise you'll get an unused variable warning ;-)
Duplicate of #1890.
I don't believe there's a universal rule for when clearing is preferable to creating a new variable.  Depending on the GC conditions, reusing the variable can move the variable into another generation of the heap, which can make its eventual GC more expensive.
Related questions on StackOverflow seem to have conflicting opinions; I'd lean towards not changing things where it's not obvious which version is faster?
A strategy we took once on an internal CSV API (CL 6442357, it looks like) was to create a new object for each line but to set its initial capacity based on the lengths of previous lines. Granted, that approach probably makes more sense for a CSV API, where all lines are likely to have similar lengths, than a general line-reading API.
(My usual inclination is to not worry too much about optimizing an algorithm that's already O(n) when there's I/O going on.  I can see some arguments to the contrary: If the buffer is very large, the extra allocations may hurt. Or, the LineBuffer might be being used on in-memory data. (But then maybe a different API would be best, one that can avoid copying altogether.))
Generics aren't, but specific uses of generic types that happen to be covariant should be -- e.g. most places that accept a Function<F, T> should accept a Function<? super F, ? extends E> where appropriate.
Is there a place you cannot make this change to the user of the Function?
Your solution is just to cast. It feels wrong because you have to suppress
circumstance @SuppressWarnings is there for.
class Dummy implements Interface<A, B> {
@SuppressWarnings("unchecked") // safe contravariant cast
@Override Function<A, B> method() {
return (Function) Functions.constant(someB);
}
}
On Tue, Dec 23, 2014 at 5:27 AM, vincentk notifications@github.com wrote:
> Here's my specific use case. I'd like to have an interface that returns a Function<A,
> B>. I'd like to have a dummy implementation of that, which always returns
> the same (constant) value. Naturally, I can build my own constant function
> easily (which I did), and yet it seems odd I would need to do that.
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/1927#issuecomment-67950534.
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
handle each one differently, so we made a single decision several years
ago, with a lot of input from Bloch and Gafter.  We decided that the
purpose of type parameters and wildcards in a library API is to ensure that
the method _can be called_ with any parameter types that make logical
sense. Once that condition is met, we stop, instead of continuing to also
add type params/wildcards that serve only to let you "massage" the specific
result type you want to get.  We did make a few mistakes such as
Predicates.alwaysTrue() where we didn't adhere to this rule, but we have
mostly followed it, and we are satisfied with the results.
Duplicate of #1313.
kevinb says so of Truth's `DoubleSubject` comparison, so I assume we'll want `DoubleMath` to follow suit.
(I'm pretty sure that it permits -0.0 now.)
What is the benefit of having a reference to the 'future' instance instead
of the result (or throwable)?  What information is available on the future
object itself?
wrote:
> And return the future that is passed to the method.
>
> This will remove the need for intermediary variable when submitting a list
> of tasks.
>
> Here is the use case;
>
> List< ListenableFuture< Boolean > > futures = new ArrayList<>( );
> for ( Callable<Boolean> task : tasks )
> {
>       executor.submit( task ),
>       new FutureCallback<Boolean>(){...}
>     )
>   );
> }
> ListanableFuture< List< Boolean > > listFuture = Futures.succesfulAsList( futures );
>
> Without the fix, there has to be a variable inside the loop, which adds to
> clutter:
>
> List< ListenableFuture< Boolean > > futures = new ArrayList<>( );
> for ( Callable<Boolean> task : tasks )
> {
>   ListenableFuture<Boolean> future = executor.submit( task );
>
>     future,
>     new FutureCallback<Boolean>(){...}
>   )
>
>   futures.add( future );
> }
> ListanableFuture< List< Boolean > > listFuture = Futures.succesfulAsList( futures );
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/1923.
Yeah but if you are executing in a _callback_ all the 'delay' has already
elapsed, the future is done and Future.addCallback has just handed you the
result (or exception).  If you need a future (say to pass it to some other
api that requires a future instance), you can just wrap in
Futures.immediateFuture() or Futures.immediateFailedFuture(), it would be
no different.
I feel like I'm missing something, what specifically do you want to do with
the future that you can't do with the unwrapped value?
wrote:
> ListenableFuture allows for delayed decision making. This article
> explains it nicely ->
> https://code.google.com/p/guava-libraries/wiki/ListenableFutureExplained
>
> Here is the main point of the article:
>
> The most important reason to use ListenableFuture is that it becomes
> possible to have complex chains of asynchronous operations.
>
> Note, that you need ListenableFuture, not Future to derive this benefit.
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/1923#issuecomment-67517383.
This seems pretty minor,  but doable.  I'll defer to @cpovirk on whether he wants to do this.
But I've since developed a reservation: I just learned that [`CompletableFuture.whenComplete`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html#whenComplete-java.util.function.BiConsumer-), the closest thing the JDK has to `addCallback`, returns a `Future` in part because _the result of the callback can affect the value of the returned future_. Users can write...
`return foo.whenComplete(postValidationTask)`
...where `postValidationTask` can throw and, if it does throw, the returned `Future` fails.
This leads me to worry that someone would try the same with `addCallback`...
`return addCallback(foo, postValidationTask) // fail the Future if validation fails`
...and then the method will return unvalidated data. (I think we'll at least log the validation failure, but users might not realize that we're not _also_ propagating it to the output `Future`, or they may think it's coming from their own logging after a call to `get()`.)
In short, it's muddying the waters about `Futures` methods that return `ListenableFuture`: If we make this change, then they will only _usually_ return a new `Future`. I'd prefer to keep the distinction clear. (We already see a very occasional call to methods like `Futures.transform` where the user ignores the output, apparently believing that it mutates in place.)
This kind of problem would _probably_ be rare, but it's enough to change my mind about this change. The good news is that it's easy to write a wrapper with the behavior you want. (Depending on your use case, maybe there are more sophisticated ways to write the wrapper, like performing the wrapping in a wrapper `Executor`.)
Hmm, the `CompletableFuture.whenComplete` implementation does not do when the doc says. (Well, actually the doc contradicts itself on this point.) I should note that I'm looking at [the copy from the jsr166 project](http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/CompletableFuture.html#whenComplete-java.util.function.BiConsumer-). The JDK8 copy I linked to earlier doesn't have the (apparently incorrect) Javadoc.
There is [some discussion about the doc](http://concurrency.markmail.org/message/7qw67mbcmpionxgz) underway.
- fails with the exception from the input `Future` if there is one. If not...
- succeeds with the value from the input `Future`
That's actually what the new docs say AFAICT. It still doesn't match what `addCallback` does. I suppose we could change `addCallback`, but at that point, we're doing more than just a "callback" would.
Some more thoughts on `CompletableFuture` that aren't really important to `addCallback`:
`whenComplete` has similarities to another `CompletableFuture` method, `handle`. I find `handle` easier to understand: Since its `BiFunction` accepts an input exception, we can reasonable assume that it has the responsibility to, well, _handle_ it :) Thus, the output `Future` doesn't fail unless the `BiFunction` decides that it should.
`whenComplete` had seemed to me to be straddling the line between exception handling and transformation. Then someone on the thread I linked suggested that it's analogous to try-with-resources (or I suppose, to a lesser extent, a `finally` block). That makes much more sense to me... though now I'm wondering why it would then need access to the result or exception.
Mutable view collections are generally not serializable. (Do you know of any that are?) You should copy the data into a "real" collection, or in this case just use toMap() instead.
Looks like we followed the JDK's lead (which also makes only unmodifiable
views serializable).
And looks like you found our one mistake. Lists.transform() bears this
_Note:_ serializing the returned list is implemented by serializing fromList,
its contents, and function -- _not_ by serializing the transformed values.
recommended_. Instead, copy the list using ImmutableList.copyOf(Collection)
http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/ImmutableList.html#copyOf(java.util.Collection)
(for
example), then serialize the copy. Other methods similar to this do not
implement serialization at all for this reason.
On Wed, Dec 17, 2014 at 8:56 AM, simonmcooper notifications@github.com
wrote:
> The unmodifiable ones are Serializable, the modifiable ones are not,
> except for TransformingSequentialList and TransformingRandomAccessList
> (that I could find)...
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/1922#issuecomment-67353853.
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
I'm not sure what qualifies as a "view", but Collections.synchronizedMap and Collections.checkedMap both return mutable and serializable maps that are arguably views of the backing Map.
What's in common to all of these (save our mistake) is that they produce
view maps that are equals() to the original map, so the same ambiguities
aren't there.
Consider the idea of a static serializeMapContents(Map, ObjectOutput)
method, which serializes the _data inside_ a map in such a way that it will
deserialize as an ImmutableMap. At the moment I'm not thinking of anything
fundamentally _wrong_ with that idea, but it's an optimization (over
copy-then-serialize) that I don't know how strong the demand for is.
On Wed, Dec 17, 2014 at 10:17 AM, amonn McManus notifications@github.com
wrote:
> I'm not sure what qualifies as a "view", but Collections.synchronizedMap
> and Collections.checkedMap both return mutable and serializable maps that
> are arguably views of the backing Map.
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/1922#issuecomment-67366699.
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
> Consider the idea of a static serializeMapContents(Map, ObjectOutput)
> method, which serializes the _data inside_ a map in such a way that it will
> deserialize as an ImmutableMap.
I don't think this helps much, as in many cases you're going to be passing the Map to some other code that does the serialization for you, so you won't even have access to the ObjectOutput to use that method with.
It is pretty trivial though to make a ForwardingMap that wraps an existing Map and serializes it as an ImmutableMap with the same contents:
``` java
public final class SerializableMapView<K, V> extends ForwardingMap<K, V> implements Serializable {
private final transient Map<K, V> delegate;
public SerializableMapView(Map<K, V> delegate) {
this.delegate = delegate;
}
protected Map<K, V> delegate() {
return delegate;
}
Object writeReplace() {
return ImmutableMap.copyOf(delegate);
}
}
```
If your goal is a cache that interns its values -- because an Interner is essentially what you've built -- then you can either change its CacheLoader to call the deduplicating function on the loaded value, or you can build a thin wrapper around a Cache to intern values being put into the Cache, or whatever.
It's not 100% clear what you're looking for, however?
I looked through existing Google callers of `fuzzyEquals` to see how many might benefit from a null-accepting version of the method. In 89 files with calls to `fuzzyEquals`, I found 2. Surprisingly, neither was in a test. (If both had been in tests, I would have suggested that [the Truth testing library](https://github.com/google/truth) would be the best place for the check. It might still be, though we'd want to give it some thought even before adding it there.)
My guess is that we'll end up deciding that this utility is easily implemented enough that it's not worth adding, but we'll see what others think.
Comment Close and comment
While initially `EventBus` had some protected methods, they have been removed... it's not intended to be extended and overridden outside the package. This does seem to be a duplicate of #780.
Ah, it looks like we decided to extend this deadline back in June but it
didn't filter out to every piece of documentation.
On Thu, Dec 11, 2014 at 7:24 AM, Jens Rantil notifications@github.com
wrote:
> https://code.google.com/p/guava-libraries/source/browse/README states
> 1. Deprecated non-beta APIs will be removed two years after the
>    release in which they are first deprecated.
>
>    while
>    https://code.google.com/p/guava-libraries/wiki/PhilosophyExplained#Non-Beta_APIs
>    states
>
> Deprecated non-beta APIs will be removed eighteen months after the release
> in which they are first deprecated.
>
> Is it 18 or 24 months?
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/1915.
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
I just fixed the Wiki. Thanks. Let us know if you find "18 months" anywhere else.
Note that the fact that it allows _catching_ of the exception was never seen as an advantage of making it public, as any API that forces you to catch an unchecked exception is already broken. Can you explain what makes this necessary for you?
Definitely not - this would break a lot of things. Plenty of ranges are for non-serializable types; the contract is to be serializable if and only if the element type is.
There is also the fact that even when something is serializable, it is the _concrete_ class that implements the Serializable marker interface, while an abstract supertype may be the type you are interacting with. (Example: ArrayList vs. List... not that you would ever have a _range_ of those, of course.)
TODO(someone@google.com): Distill comments from the internal thread "Range<LocalDate> to a range of micros."
My summary from a quick glance: The most likely use case for `Range` transformation is indeed date logic, and date logic is tricky enough that it indeed requires special handling. The direction that we were moving on that thread was requiring a separate transformation function for each endpoint. Maybe:
```
Range<LocalDate> dates = transform(years, new RangeTransformer<Integer, LocalDate>() {
public LocalDate valueAtStartOf(Integer year) {
return new LocalDate(year, 1, 1);
}
public LocalDate valueAtEndOf(Integer year) {
// I imagine this ends up being more complex than "return new LocalDate(year, 12, 31)"...
}
});
```
And the reverse:
```
Range<Integer> years = transform(days, new RangeTransformer<LocalDate, Integer>() {
public Integer valueAtStartOf(LocalDate day) {
return day.getYear();
}
public Integer valueAtEndOf(LocalDate day) {
return day.getYear();
}
});
```
An advantage to that is that we can preserve the bound types. That's potentially important in some cases where there's no single lowest value... which won't necessarily come up with date APIs (and might not come up for their users) but which might be nice to support in general. Or maybe we'll end up needing different APIs for date and non-date use cases.
(One thing that I took for granted in my previous post: My guess is that we would provide `Range<B> transform(Range<A>, function)` rather than `Function<Range<A>, Range<B>> transformer(function)`. The good news is that Java 8 will make constructing the latter simpler: `range -> transform(range, function`.)
Duplicate of #1551.
(AFAICT, you'll need to manually subscribe to comments on that issue. Sorry.)
AFAIK, most languages' concept associated with the word "tail" would not be
the last n elements, but rather, equivalent to skipping the first n
elements.  We might need a different name here.
On Mon Dec 08 2014 at 5:38:56 PM Michael Diamond notifications@github.com
wrote:
> I have a need to select the most recent n elements from a list that I
> know is ordered; for instance, to display data from the last ten years, in
> a (potentially long) list of data ordered by year.
>
> For existing Lists it's tedious but not complicated to write out:
>
> list.subList(Math.max(list.size() - n, 0), list.size())
>
> though I'd argue the cleanliness of a simple .tail() method is still a
> nice win over the above. More valuable however is providing support for
> arbitrary Iterables, in order to avoid creating a copy of the whole data
> stream simply to take a small sublist. I imagine many users (myself
> included) simply absorb the cost of the full copy rather than take the time
> to implement a circular buffer or similar memory-efficient solution.
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/1906.
@lowasser: Hmm, any examples? We use `skip` for that, as does Java 8's `Stream`. `tail` is also a Unix command that outputs the last _n_ lines of something.
Hmmm.  I was thinking about Haskell, where "tail" refers to a list without
its first element, and doesn't really have a name for that feature that I
can think of?
I do think that e.g. FluentIterable.last(5) would be fairly unambiguous,
though, FWIW.
On Mon Dec 08 2014 at 5:52:40 PM Colin Decker notifications@github.com
wrote:
> @lowasser https://github.com/lowasser: Hmm, any examples? We use skip
> for that, as does Java 8's Stream. tail is also a Unix command that
> outputs the last _n_ lines of something.
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/1906#issuecomment-66203552.
Few thoughts:
- I would be ok with having a method on `Iterables`/`FluentIterable` that always does the copy behavior and a separate method on `Lists` that always does the view behavior.
- This sounds fairly useful to me, but as with anything we'll need to get an idea about how generally useful it really is.
Note that our current offering here is [EvictingQueue](http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/EvictingQueue.html).
```
Queue<Foo> q = EvictingQueue.create(n);
q.addAll(everything);
for (Foo foo : q) { ... }
```
Can you clarify how this is different than the #418 you've referenced?
Thanks. Can you reopen that one to continue the discussion there?
Sorry about that. Done.
What happens with Invokable and almost everything in the reflect package when we are on Java 8?
That's a question we are currently discussing about.
This would be another thing that begs the same question.
If we decide that we can freely add Java 8 specific code without worrying about backward compatibility, I think we should do this. Actually, Invokable could be rewritten with Executable in mind: we don't have to create ConstructorInvokable and MethodInvokable, JDK is already unifying them for us.
We also have a lot new things to do, for example, most of the AnnotatedType implementations would also benefit from TypeToken's type resolving.
Sounds reasonable to me.
Do you mind elaborating a bit the reason you need to find out the underlying Member for the Invokable? I'm curious to know if it's because Invokable should have provided some functionality that it doesn't today.
Thanks!
When we do have `Invokable.from(Executable)`, the second use case can just flip so that the Executable-overload delegates to the Invokable-overload.
Was about to do it then realized an awkward API design issue.
Invokable today implements Member. So it seems weird for it to also expose getMember(). getExecutable() would be less weird. But...
Hmmm.  Java 8's Optional has this, IIRC; does it make _enough_ sense in the Java 7 world, with all the boilerplate needed to write a Supplier, to add it directly on Optional?
Basically, after encountering the first key-value separator, it may be reasonable to just include any other separators that appear before the next entry separator in the value rather than throwing `IllegalArgumentException` as we do now.
Example:
``` java
MapSplitter splitter = Splitter.on(";").withKeyValueSeparator("=");
splitter.split("key=value;key2=value"); // normal
splitter.split("key=value;key2=value="); // currently throws IAE
// proposed change would make the second entry split to "key2" -> "value=" instead
```
Maybe we could use the technique described at https://weblogs.java.net/blog/kohsuke/archive/2007/04/how_to_convert.html ?
We don't necessarily have to use URI. The goal is just to turn the URL to a key object with sane hashCode().
Perhaps we can just use URL.getFile() because we only support file:/// urls anyway.
Wildcard doesn't always mix intuitively with TypeToken, unfortunately. `Type<?>` is _not_ necessarily a WildcardType. It can be anything:
```
TypeToken<?> type = TypeToken.of(String);
```
So is `TypeToken<? extends Comparable<String>>`. It can possibly be `MyComparable<String>`, which isn't a supertype of String.
Only the question marks at least nested two levels deep belong to the represented runtime type. That is, this should return true:
`TypeToken<Foo<? extends Comparable<String>>.isAssignableFrom(TypeToken<Foo<String>>)`
Sorry. I misread and misunderstood the case.
You said
> if "to" is <? super Foo>, "from" can be: Foo, SubFoo, <? extends Foo>...
This snippet of code shows why I'm not following:
```
Iterable<? super Comparable<String>> it;
Iterable<String> strings = null;
// Type mismatch: cannot convert from Iterable<String> to Iterable<? super Comparable<String>>
```
For expression `a.isAssignableFrom(b)`, I always try to think of it as:
```
A a = b;
```
If `isAssignableFrom()` returns true, the assignment should compile.
Wildcard types is a little special. You cannot have an expression like this:
```
? super Foo foo = subFoo;
```
So to me there isn't a clear rule dictating what '''supertypeOfFoo.isAssignableFrom(subFoo)''' should return. The document you quoted was written with a enclosing parameterized type in mind. When it said`? super Foo`, it actually meant to say `SomeParameterizedType<? super Foo>`.
Yes. This seems to be calling for a generic type inferrer. Basically, it can be defined as:
Given formal types A, B, C, and actual types x, y, z, resolve the type context under which [x, y, z] can be assigned to [A, B, C].
That is, if A, B and C are type expressions with type variables, which have bounds, resolve those type variables.
A few concrete examples:
```
Yes.
```
```
```
```
No
```
I've contemplated about implementing this because it seemed useful and powerful to me. But I haven't been able to justify the complexity (it's non-trivial) with good use cases. Ideally if we could reuse the javac type inferer, or if javac can reuse this utility, that would be easier to justify.
If you already have the mappings of all TypeVariables, I believe you could use `TypeResolver` on the return type alone, just disregarding all the method parameters.
For example, in method:
```
Multimap<K, V> makeMap(Iterable<K> keys, Iterable<V> values);
```
You can just do:
```
TypeResolver resolver = new TypeResolver();
for (...) {
resolver.where(typeVar, actualType);
}
resolver.resolveType(method.getGenericReturnType());
```
With regard to type checking however, I'm afraid the complexity of doing it right may not be much easier than full inference. Consider this:
```
<T1, T2 extends Iterable<T1>, T3 extends Map<T1, T3>>
void foo(T2 t2, T3 t3) {}
```
If you only have mappings for T2 and T3, you'll still need to infer T1.
It's easier if the mapping of T1 is also available. But in that case, you could likely use TypeResolver to first resolve all the type bounds, and then use `isAssignableFrom` on the resolved types?
Hi, I discussed with others on the team. The general sentiment is so far reserved on adding any of these features (inference, parsing, or newParamterizedType() etc).
I do think if you could write a complete type inferrer, it'd make a nice project by itself. And then using the type inferrer, a type safe parser is a good first use case.
Fwiw, I created a tiny spin-off project with public [TypeParser](https://github.com/fluentfuture/jparsec-g/blob/master/javaparser/src/main/java/org/jparsec/java/TypeParser.java) and also [Types](https://github.com/fluentfuture/jparsec-g/blob/master/javaparser/src/main/java/org/jparsec/java/Types.java).
It doesn't do type bounds checking yet but it can definitely use a type inferrer to properly check bounds.
Just fixed this (for MoreObjects.toStringHelper). Thanks for the report!
Apparently we had a similar class internally at one point but ended up removing it because it got so little usage.
We also considered `Striped<RateLimiter>` to replace the internal `ThrottleSet` class, and we might want `Striped<Monitor>`. Generic support is probably worth adding, but it probably won't be a priority for us in the near future. We could take a patch from someone who's signed [the CLA](https://cla.developers.google.com/).
CLAs look good, thanks!
<!-- ok -->
Thanks! This has been merged and synced in 1a7ecdee7b51e7b77a2518320525faf92fbf9c49.
This is awesome!
These seem to be the top findings:
926 ParameterName
This is one of the "should be avoided" guidelines in the style guide that is _not_ treated as a bona fide rule. In fact, I don't think anyone ever really intended it to apply to non-public methods in the first place. While I imagine there are a _few_ parameter names in here that really should be improved, I think that checkstyle should stop warning on single-character names. (And I'll try to get the guide fixed.)
As you can see from browsing through Guava's generated docs, there aren't really anywhere near that many missing method docs. These violations are mostly things like _CustomFieldSerializer classes and other invisible details. (I will grant you that the style guide ought to somehow make it clear that these are exempt.) But actually, according to Google style it is really impossible to enforce this check anyway, since the developer is allowed to use judgment about when the documentation would "have nothing useful to say" and is allowed to skip it in that case.
512 EmptyLineSeparator
Yes, in this case we were just really bad about following this rule and at some point decided we would address it by auto-reformatting all the code one day (which we will probably actually do soon).
Same as with parameter names, the guide never meant to make these actually illegal, and I think we need to fix this.
Single-line javadoc is explicitly allowed by 7.1.1.
185 EmptyBlock (empty catch block)
When the caught exception is named 'expected' the warning should not be given (6.2). The fix for almost all these cases is just to rename things like 'ignored' or 'tolerated' to expected.
Ok, most of these seem to be real problems.
92 OverloadMethodsDeclarationOrder
Ok now this is awesome. I definitely think we should fix all of these.
80 WhitespaceAround
Colin: as all this github migration stuff is settling down, maybe looking at checkstyle convergence might be possible? :-) :-)  (What do you want for Christmas?)
Re: SingleLineJavadoc, I will try to fix the bit about "no at-clauses present", as it seems totally unnecessary. We never intended for this to require
```
/**
* @see blah
*/
```
over
```
/** @see blah */
```
```
/** Blah blah including a {@code bit of code}. */
```
Again, I will try to fix this.
Re: EmptyBlock,
(a) the current guide says this: "Exception: In tests, a caught exception may be ignored without comment if it is named `expected`."
(b) otherwise, as for what comments are allowed, checkstyle has to assume that _any_ comment is good enough.
For EmptyBlock, we're also just allowing _any_ exception named `expected` to be ignored. People should only be doing that in tests, but it's not worth it to try to enforce that.
EmptyBlock:  yes, that's what we do too. The guide may not _say_ you can name it 'expected' and skip the comment in production code, but checkstyle will let you.
WhitespaceAround: agreed.
Most of the rest of your comment looks like just echoing what we already know needs to be fixed. I can't promise a fixed version of the document will be coming _soon_ though.
That one is addressed here:
https://google-styleguide.googlecode.com/svn/trunk/javaguide.html#s4.6.2-horizontal-whitespace
"Beyond where required by the language or other style rules, and apart from literals, comments and Javadoc, a single ASCII space also appears in the following places **only** ."
"s3.amazonaws.com" does not have a private domain, as it itself is a public suffix:
https://publicsuffix.org/list/effective_tld_names.dat
This sounds like [the burstiness described in a corner of the `RateLimiter` docs](http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/util/concurrent/RateLimiter.html#create%28double%29). Without the `sleep` call, I think you'll see the expected behavior.
We got an internal security review for `HtmlEscapers`. It's always possible that the reviewers missed something, but I feel reasonably good about the current behavior. Well, I feel as good about it as it's possible for me to feel about an HTML escaper. More on that at the end.
A browser that treats other brackets in the same way as `<>` wouldn't shock me (What browser behavior would shock anyone? :)). That said, I'm unaware of any examples of this problem in the wild. In principle, we would have to escape brackets, dashes (for CDATA sections), quotes, and so forth. We could, perhaps at the cost of changing our escaping with each revision of Unicode. More likely, though, is that we'd go to...
My understanding is that most escapers do this because of a combination of (a) not knowing that it's possible to include UTF-8 (or whatever) data directly in an HTML document, since that didn't use to be easy, and (b) working with systems where it's _still_ not easy to include UTF-8 data directly in an HTML document. We could conceivably support that use case someday. We just haven't seen the demand.
But back to security. In the end, I'm basically back to (a) "our security team said it was OK" and (b) [the best HTML spec I'm aware of says nothing about escaping other characters](https://html.spec.whatwg.org/multipage/syntax.html#escapingString) (except, probably for historical reasons, `nbsp`). Changing it now would make generated HTML for many languages less readable and larger.
###### Encoding of code points
Our choice to not `&#` encode anything conveniently sidesteps this, as noted :)
###### Characters 128-159
[The WHATWG HTML spec that I linked to above](https://html.spec.whatwg.org/multipage/syntax.html) is probably the place to look currently. It's based in large part on what browsers accept. If in practice those characters are accepted, then we're probably OK generating them.
This is a reasonable feature. We left it out more for social reasons: We want for choosing the correct escaper to be as easy as possible. If we can produce an escaper that's always safe, we do it. If we can't, then we at least want for users not to have fatigue from making a lot of previous escaper decisions that we could have made for them. For HTML, we saw that there was one escaper that was always[*] safe, so we went for it.
###### Further conditionalized escaping in CSS/JavaScript sections (the [*] from above)
The punch line to all this is just what you've said: People shouldn't really use these escapers at all. We've tried to emphasize this [throughout the `HtmlEscapers` Javadoc](http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/html/HtmlEscapers.html) and [in other contexts](https://plus.google.com/+googleguava/posts/FtEW8Jvqfoo). Some users, though, really don't want to use a templating system, even though they probably should. For users who aren't going to spend the effort to use a templating system, there is probably little we can do to get them to spend the effort to understand which escaper to use :(
One issue with this is that `BaseEncoding` is for both encoding and decoding, while an `ignoreCase()` option would only make sense for decoding. That's not to say that it's necessarily something we shouldn't do, but it would be pretty awkward.
Can you explain some more about why you have to deal with both upper and
lowercase input?  Aren't you usually receiving your input from another
program that outputs in a particular format?
In the worst case, Ascii.toLowerCase and Ascii.toUpperCase are efficient
ways to preprocess a string for conversion here.
On Wed Nov 12 2014 at 10:51:34 AM Colin Decker notifications@github.com
wrote:
> One issue with this is that BaseEncoding is for both encoding and
> decoding, while an ignoreCase() option would only make sense for
> decoding. That's not to say that it's necessarily something we shouldn't
> do, but it would be pretty awkward.
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/1886#issuecomment-62771878.
stackoverflow.com, not on this discussion list.
On Thu, Nov 6, 2014 at 1:08 PM, Jens Rantil notifications@github.com
wrote:
> @haochun https://github.com/haochun Are you refering to anything in the
> Guava documentation? If your question has nothing to do with Guava I'm
> afraid you are not going to get your answer here.
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/1884#issuecomment-62051519.
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
(Oops, didn't even notice this is not the discussion list. Still, though, stackoverflow)
I think that I have made the following distinction before, and no one has told me it's crazy yet:
- expireAfterWrite is to avoid keeping around data that gets stale.
- expireAfterAccess is to avoid keeping around data that isn't likely to be used again soon.
My first reaction is that the current semantics make some sense: an entry still being computed isn't really in the cache; it's not really there to be invalidated?
Let's assume that we did what you're saying: we invalidated the pending fetch.  What exactly should the ongoing get() call from the other thread return?  Restarting the load() call seems awkward, if it's even possible.
Okay.  If I understand correctly, that stale value will never be stored, but will be returned from the get?
I don't think that's 100% obvious -- I suspect there are cases where you don't want the value-in-flight to be invalidated -- and I'd also expect this to require a fairly significant rewrite to the internals of Cache, but we can research this further.
I don't really have anything concrete to say here, but I remember that, when it came to `CacheBuilder`/`MapMaker`, fry@ used to talk about "linearizability" (e.g., in internal bug 1774366). That might be the property that we want. But I don't know what that would imply for the behavior here, let alone whether implementing that behavior is feasible (if in fact it differs from the current behavior).
Please do; I think we'd welcome contributions on this.
Yes, this is correct.
The numBits param is the _number of bits_ of the underlying data array.
The dataLength param is the _length_ of the underlying data array.
number of bits = length \* Long.SIZE;
Thanks... as I said on the other pull request, we'll just need you to sign the Google [individual CLA](https://cla.developers.google.com/about/google-individual) before we can accept the change.
Submitted internally; should be mirrored out soon.
Thanks! Can you sign the Google [individual CLA](https://cla.developers.google.com/about/google-individual)?
Just FYI, we're going to be handling pull requests by applying the changes internally and then syncing them out rather than by merging the pull request directly. See #1878 for a little more on that.
I've gone ahead and submitted this change internally with the one minor change to use SSH for the `<developerConnection>` URL. Should be mirrored out shortly. Thanks!
Duplicate of #218.
That's awesome.  Even for such a small change, can you fill out https://cla.developers.google.com/about/google-individual ?
Also, just to make sure  @cgruber and @cgdecker, we have the repository sync working both ways, right?
@gk5885 I don't think we do have sync working both ways at the moment, unfortunately. If possible I'd definitely like to get it working of course, but I've been under the impression that 2-way syncing is difficult with the google-internal stuff mixed in.
In the meantime I suppose we can handle pull requests by patching in the changes internally... can even set the author of the commit to the right person when syncing out potentially.
@Xaerxess Thanks! While we can't merge pull requests directly (see #1878), I merged this change internally and it's been synced out in 1b82532. In the future we should be able to make commits from pull requests actually attributed to you, but we didn't with this one, so sorry about that.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1872) created by **manderson23** on 2014-10-27 at 10:59 PM_
---
InternetDomainName.isValid returns false for the parameter "8server".
RFC1123 suggests that names should be able to start with a digit. See https://groups.google.com/forum/#!topic/guava-discuss/8Sycya7Fkok on guava-discuss for a discussion of the issue.
I also asked for clarification on Server Fault at http://serverfault.com/questions/638260/is-it-valid-for-a-hostname-to-start-with-a-digit
My final suggestion on the mailing list for solving this was as follows:
"What about if the final part starts with a digit actually checking if the complete name is an IP address e.g. calling InetAddreses.isInetAddress? The discussion section in RFC 1123 does suggest a full syntactic check to prevent a dotted decimal number getting through."
but there was no response.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1871) created by **dborowitz@google.com** on 2014-10-23 at 07:32 PM_
---
"To implement a cache, the programmer needs only to extend this class and provide an implementation for the #get(Object) and #getIfPresent methods. #getUnchecked, #get(Object, Callable), and #getAll are implemented in terms of get"
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1870) created by **thecoop1984** on 2014-10-23 at 08:42 AM_
---
Maps.unmodifiableNavigableMap is declared as follows:
&lt;K, V> NavigableMap&lt;K, V> unmodifiableNavigableMap(NavigableMap&lt;K, V> map);
this could be changed to
&lt;K, V> NavigableMap&lt;K, V> unmodifiableNavigableMap(NavigableMap&lt;K, ? extends V> map);
as there are no methods in NavigableMap that take a V as a method parameter. This would also be consistent with the declarations of Collections.unmodifiableSortedMap and ImmutableSortedMap.copyOfSorted.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1870#c1) posted by **kevinb@google.com** on 2014-10-23 at 02:20 PM_
---
I believe you are correct. And this will probably be sufficiently safe to change. Thanks!
---
**Status:** `Accepted`
**Labels:** -`Type-Enhancement`, `Type-Defect`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1867) created by **venkateshamurthyts** on 2014-10-20 at 03:22 PM_
---
Need a putIfAbsent type method which takes a Builder rather than a created object as value along with Key K.
This in specific tries to create the object iff the key is absent.
Advantage: The value doesn't get un-necessarily created.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1867#c1) posted by **wasserman.louis** on 2014-10-20 at 03:23 PM_
---
Java 8 provides this as a new default method on Map, but I imagine this would be unnecessarily complicated before Java 8, if you had to write the anonymous Supplier instance -- it'd probably take more lines than just writing it the old-fashioned way.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1867#c2) posted by **venkateshamurthyts** on 2014-10-20 at 04:40 PM_
---
Given that migrating to Java 8 takes significant amount of time ; i was hoping if it were to be implemented in guava
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1867#c3) posted by **lowasser@google.com** on 2014-10-20 at 04:41 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1867#c4) posted by **venkateshamurthyts** on 2014-10-20 at 04:42 PM_
---
OK got it. thanks for clarification
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1865) created by **cpovirk@google.com** on 2014-10-17 at 06:12 PM_
---
From an internal discussion:
---
Huh. I had assumed that "success" was the usual name for this, but I can't find it anywhere in the Future docs. The closest term used there is "completed normally," used in contrast to "an exception" and "cancellation": http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html#isDone-- But other parts of the doc seem to consider there to be only two cases, "completed normally" and "cancelled," suggesting that "an exception" is a kind of "completed normally."
---
The word "success" is used throughout http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/FutureTask.html
---
It would be super-confusing for "success" to mean anything other than "completed without throwing", so the meaning of "success" is relatively obvous.  But it would be better if docs like in FutureCallback replaced
&nbsp;&nbsp;&nbsp;\* Invoked with the result of the {@code Future} computation when it is
&nbsp;&nbsp;&nbsp;\* successful.
with
&nbsp;&nbsp;&nbsp;\* Invoked with the result of the {@code Future} computation when it completes
&nbsp;&nbsp;&nbsp;\* normally.
&nbsp;&nbsp;&nbsp;\* Invoked with the result of the {@code Future} computation if and when it completes normally (that is, without throwing an exception).
---
I'm still conflicted about this, given that "completed normally" is slightly ambiguous. Perhaps we could define "success" in our package-info and link to that? But mostly I'm just having trouble prioritizing this above other issues.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1864) created by **kevinb@google.com** on 2014-10-10 at 07:22 PM_
---
For some nested classes you would really rather toStringHelper chose the canonical name "Foo.Bar" instead of just the simple name "Bar".
1. Which is the best default behavior?
2. If that is the canonical name, would it be evil to change it now? It is perhaps debatable whether the current behavior really is strongly promised by spec. Some overenthusiastic unit tests would have to be changed, but how bad is that?
3. Does this choice actually merit a new configuration option to ToStringHelper? Note that without it, users who want the opposite behavior will need to change typical (85%) usage code like so:
&nbsp;toStringHelper(this) --> toStringHelper(getClass().getCanonicalName())
... which is not pleasant. However, we don't want ToStringHelper to become too complex.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1864#c1) posted by **cpovirk@google.com** on 2014-10-14 at 02:02 PM_
---
Possibly we should apply our decision here equally to AutoValue. (AutoValue currently appears to use "Bar.")
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1862) created by **christian.walczyk** on 2014-10-10 at 09:58 AM_
---
The post order of enqueued events is not guaranteed. In practice the order of enqueued events is the same for the majority of the time but not always. In my case, each start of my application could have a different order of posted events. This makes testing and bugfixing a lot harder.
Changing the subscribersByType from HashMultimap to LinkedHashMultimap in the EventBus class fixed it for me.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1860) created by **joeheyming** on 2014-10-01 at 08:06 PM_
---
Maps.asMap("key1", 1, "key2", "value2")  would yeild a hashmap, or immutable map.
In json it would look something like this:
{'key1': 1, 'key2': 'value2'}
I don't think its too crazy to use variable arguments here.  Arrays.asList uses var args, why can't guava do this?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1860#c1) posted by **lowasser@google.com** on 2014-10-01 at 08:07 PM_
---
You're losing all the available type safety here: you can't have a distinct key/value type, and your example actually illustrates that you're no longer enforcing types on the values.
What's wrong with ImmutableMap.builder().put(key1, value1).put(key2, value2).build()?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1860#c2) posted by **joeheyming** on 2014-10-01 at 08:09 PM_
---
Code sample for a map of string to object:
public static Map&lt;String, Object> asMap(Object... args) {
&nbsp;&nbsp;&nbsp;&nbsp;Map&lt;String, Object> argMap = new HashMap&lt;String, Object>();
&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i < args.length; i += 2) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key = (String) args[i];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (ClassCastException cce) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println(cce.getMessage());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.err.println("args[" + i + "] " + args[i].toString());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw cce;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (i + 1 < args.length) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object value = args[i + 1];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;argMap.put(key, value);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return argMap;
&nbsp;&nbsp;}
It doesn't necessarily have to be string -> object, we could just write a generic Map&lt;Object,Object> function.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1860#c3) posted by **joeheyming** on 2014-10-01 at 08:11 PM_
---
I'm proposing a non-builder approach.
ArrayList.asList is not a builder.
We don't have
List&lt;String> foo = ImmutableList.builder().add("foo").add("bar").add("baz").build();
List&lt;String> foo = Arrays.asList("foo", "bar", "baz");
Tell me which one is cleaner?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1860#c4) posted by **lowasser@google.com** on 2014-10-01 at 08:13 PM_
---
Arrays.asList doesn't have to give up type safety, but this would.  Additionally, we do provide ImmutableMap.of() for small numbers of entries.  Would that help for your use case?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1860#c6) posted by **joeheyming** on 2014-10-01 at 08:16 PM_
---
ImmutableMap.of doesn't work with variable arguments.
If I have a funcion:
void foo(Object ... args) {
&nbsp;&nbsp;ImmutableMap.of(args)  // doesn't work
}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1860#c7) posted by **lowasser@google.com** on 2014-10-01 at 08:18 PM_
---
That's because your foo function is losing the type safety, too.  If you have arguments that are being passed around in pairs, they should probably be passed with ImmutableMap.of to start with.  Consider changing the arguments of your foo function instead?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1860#c8) posted by **cgdecker@google.com** on 2014-10-01 at 08:22 PM_
---
Not just losing type safety, losing safety in even the number of arguments.
---
**Labels:** `Package-Collect`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1860#c9) posted by **joeheyming** on 2014-10-01 at 08:30 PM_
---
Sometimes type safety isn't that big of a deal.  Lets say you wanted to write a test with a dummy map?  You know the type of the arguments because you explicitly put them in the test.
Either way, I'm sure you could make it so types are enforced in the pairs of arguments with generic types.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1860#c10) posted by **lowasser@google.com** on 2014-10-01 at 08:34 PM_
---
> Either way, I'm sure you could make it so types are enforced in the pairs of arguments with generic types.
Not...really?  There's no good way to enforce generics even at runtime when you would be getting nested generics, e.g. Map&lt;Key, Future&lt;Value>>.  And in practice, essentially all users would have to cast the resulting map -- there's not much actual use for a Map&lt;Object, Object>, and most users' APIs won't accept anything of the sort.
As far as tests go, I'd definitely expect the majority of test maps to be quite small, small enough that they can use the ImmutableMap.of factories.  And for larger maps, there's a reasonable, type-safe alternative that's only slightly longer, via the ImmutableMap.Builder.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1860#c11) posted by **joeheyming** on 2014-10-01 at 08:36 PM_
---
What if Maps.asMap  was a wrapper to the builder pattern?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1860#c12) posted by **lowasser@google.com** on 2014-10-01 at 08:37 PM_
---
How exactly would that work differently from your previous suggestions?  The API would still have to take Object..., wouldn't have type safety, and wouldn't enforce that there was an even number of arguments.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1860#c13) posted by **cgdecker@google.com** on 2014-10-01 at 08:40 PM_
---
I'm going to go ahead and just say this isn't something we'll be doing. There's little to be gained by writing
Maps.asMap(
&nbsp;&nbsp;a, b,
&nbsp;&nbsp;c, d,
&nbsp;&nbsp;e, f);
instead of
ImmutableMap.of(
&nbsp;&nbsp;a, b,
&nbsp;&nbsp;c, d,
&nbsp;&nbsp;e, f);
or even (if you have lots of entries)
ImmutableMap.builder()
&nbsp;&nbsp;.put(a, b)
&nbsp;&nbsp;.put(c, d)
&nbsp;&nbsp;.put(e, f)
&nbsp;&nbsp;// ...
&nbsp;&nbsp;.build();
and lots of disadvantages. It's also not really similar to Arrays.asList, which is a lightweight view of an array, not something new built from the contents of an array.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1860#c14) posted by **cgdecker@google.com** on 2014-10-01 at 08:40 PM_
---
_(No comment entered for this change.)_
---
**Status:** `WontFix`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1860#c15) posted by **joeheyming** on 2014-10-01 at 08:44 PM_
---
Yeah I figured you were going to reject this.  Thanks for listening to my stupid idea.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1860#c16) posted by **cgdecker@google.com** on 2014-10-01 at 08:58 PM_
---
Thanks for the suggestion. In this case, I just think that the APIs we currently provide for this cover the use cases such a method would have sufficiently well while preserving type safety, which is valuable.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1860#c17) posted by **tomas.zalusky** on 2014-10-02 at 06:40 AM_
---
joeheym..., FYI just academic case for completeness and linkage to related issue:
You could reach your goal with recently added feature: https://github.com/google/guava/issues/320 , which makes possible to call
ImmutableMap.copyOf(ImmutableList.of(Maps.immutableEntry("key1", 1),Maps.immutableEntry("key2", "value2")))
(working out from my head, probably some explicit generic type inference would be necessary)
Anyway I cannot imagine why one would write it this way and really discourage it, the ImmutableMap.builder (or constructor for 5- entries) is certainly the best approach.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1860#c18) posted by **joeheyming** on 2014-10-02 at 04:21 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1860#c19) posted by **joeheyming** on 2014-10-03 at 06:59 PM_
---
Well, anyway, this was the best I could come up with to guarantee the pairs and type safety:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@SafeVarargs
&nbsp;&nbsp;&nbsp;&nbsp;public static &lt;K,V> Map&lt;K, V> asMap(Pair&lt;K, V>... entries) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Map&lt;K, V> argMap = new HashMap&lt;K, V>();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(Pair&lt;K,V> entry : entries) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;argMap.put(entry.k, entry.v);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return argMap;
&nbsp;&nbsp;&nbsp;&nbsp;}
```
public static class Pair<K,V> {
public K k;
public V v;
Pair(K key, V value) {
this.k = key; this.v = value;
}
}
public static <K,V> Pair<K,V> p(K key, V value) {
return new Pair<K, V>(key, value);
}
```
Then:
Map&lt;String,Integer> pairMap = asMap(p("a",1), p("b",2));
System.out.println(pairMap);
Yields:
{b=2, a=1}
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1858) created by **sebastian.davids** on 2014-09-28 at 10:07 PM_
---
FindBugs reports "inherits equals and uses Object.hashCode()" for Converter-subclasses.
http://findbugs.sourceforge.net/bugDescriptions.html#HE_INHERITS_EQUALS_USE_HASHCODE
@ test/Test.java @
package test;
import com.google.common.base.Converter;
import java.io.Serializable;
public final class Test {
&nbsp;&nbsp;private static final class TestConverter
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extends Converter&lt;String, String> implements Serializable {
```
/*package*/ static final TestConverter INSTANCE = new TestConverter();
private static final long serialVersionUID = 1;
public String toString() {
return "TestConverter.testConverter()";
}
protected String doForward(String string) {
return string;
}
protected String doBackward(String string) {
return string;
}
private Object readResolve() {
return INSTANCE;
}
```
&nbsp;&nbsp;}
&nbsp;&nbsp;public static Converter&lt;String, String> testConverter() {
&nbsp;&nbsp;&nbsp;&nbsp;return TestConverter.INSTANCE;
&nbsp;&nbsp;}
&nbsp;&nbsp;private Test() {
&nbsp;&nbsp;}
}
@ pom.xml @
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
&nbsp;&nbsp;&nbsp;&nbsp;xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
&nbsp;&nbsp;&nbsp;&nbsp;&lt;modelVersion>4.0.0&lt;/modelVersion>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupId>test&lt;/groupId>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;artifactId>test&lt;/artifactId>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;version>1.0.0-SNAPSHOT&lt;/version>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;dependencies>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;dependency>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupId>com.google.guava&lt;/groupId>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;version>18.0&lt;/version>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/dependency>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/dependencies>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;build>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;plugins>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;plugin>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupId>org.codehaus.mojo&lt;/groupId>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;artifactId>findbugs-maven-plugin&lt;/artifactId>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;version>3.0.0&lt;/version>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;executions>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;execution>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;goals>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;goal>check&lt;/goal>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/goals>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/execution>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/executions>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/plugin>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/plugins>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/build>
&lt;/project>
mvn clean install
...
[INFO] --- findbugs-maven-plugin:3.0.0:check (default) @ test ---
[INFO] BugInstance size is 1
[INFO] Error size is 0
[INFO] Total bugs: 1
[INFO] test.Test$TestConverter inherits equals and uses Object.hashCode() ["test.Test$TestConverter"] At Test.java:[lines 9-32]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 6.516 s
[INFO] Finished at: 2014-09-29T00:00:54+01:00
[INFO] Final Memory: 23M/118M
[INFO] ------------------------------------------------------------------------
[ERROR] Failed to execute goal org.codehaus.mojo:findbugs-maven-plugin:3.0.0:check (default) on project test: failed with 1 bugs and 0 errors -> [Help 1]
...
&nbsp;&nbsp;@Override
&nbsp;&nbsp;public boolean equals(@Nullable Object object) {
&nbsp;&nbsp;&nbsp;&nbsp;return super.equals(object);
&nbsp;&nbsp;}
But there is no corresponding override for hashCode:
&nbsp;&nbsp;@Override
&nbsp;&nbsp;public int hashCode() {
&nbsp;&nbsp;&nbsp;&nbsp;return super.hashCode();
&nbsp;&nbsp;}
This forces everyone to either ignore the FindBugs warning or include the snippet above in their subclass.
Please add
&nbsp;&nbsp;@Override
&nbsp;&nbsp;public int hashCode() {
&nbsp;&nbsp;&nbsp;&nbsp;return super.hashCode();
&nbsp;&nbsp;}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1858#c1) posted by **kak@google.com** on 2014-09-29 at 05:33 AM_
---
To be clear, this is actually a false positive from FindBugs (since there isn't actually a bug here).
Looks like we only override equals so we can add additional documentation. I wonder if we should just move that documentation into the class docs, or drop it all together.
---
**Labels:** `Type-ApiDocs`, `Package-Base`
So I agree that the FindBugs check is doing what it should (e.g., alerting you of a potential problem), but AFAICT, the bug it's warning about (equal objects must have equal hashcodes) is impossible to occur here, right?
Options:
a) report false positive to findbugs, ask that they recognize when an
override is not really an override.
b) what kurt suggested; either removing the information or promoting it to
c) just add a docless override of hashCode() to Converter and make the
problem go away
c feels bad but I don't actually see anything _wrong_ with it. It's
certainly easy...
On Thu, Apr 9, 2015 at 6:04 AM, Simon Barbey notifications@github.com
wrote:
> Hi !
>
> Admitting your sub-class name ends with Converter, this "false positive"
> can be filtered with this rule instead of overriding hashCode() in every
>
> <?xml version="1.0" ?>
> <FindBugsFilter>
>
> ```
> <Match>
>     <Class name="~.+Converter" />
> </Match>
> ```
>
> </FindBugsFilter>
>
> By the way, do you have any idea when this will be fixed ?
>
> Thx
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/1858#issuecomment-91224752.
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
I'm going to close this, assuming FindBugs has been fixed. If it hasn't, please link us to their open bug report.  _[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1854) created by **crai...@microsoft.com** on 2014-09-23 at 04:57 PM_
---
Presently size-based eviction divides maxWeight by the number of segments (concurrency level) and then each segment checks individually on writes for the need to evict entries.
This leads to under utilization of ram when the size of the data in each segment varies a lot.  One can pick a larger maxWeight, of course, but then if the distribution of the sizes of the segments changes, one is in danger of ram really being overcommitted.  One might also pick a better hash function, but it is not clear that will solve this consistently.
A better solution is to coordinate eviction across the segments so that the total cache more or less stays below the maxWeight, but allows segments to be larger when they are imbalanced.  The additional need is that when one segment is below it's max and yet the cache as a whole is still over weight, one needs to poke at least one other segment to evict.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1854#c1) posted by **lowasser@google.com** on 2014-09-23 at 04:58 PM_
---
---
**Labels:** `Type-Performance`, `Package-Cache`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1854#c2) posted by **crai...@microsoft.com** on 2014-09-23 at 06:15 PM_
---
Guava is used in several places in ElasticSearch.  In the case of the fielddata cache, the concurrency level is 16.  Many of us have set the fielddata cache to use size-based eviction only to find that evictions are happening well before the cache is 'full'.  In my case, I specified a 2GB cache and only 650mb was used when evictions started.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1854#c3) posted by **kevinb@google.com** on 2014-09-23 at 07:02 PM_
---
It is, however, expected behavior when entries are much coarser than that. You really have 16 independent caches, which is of course where the high concurrency comes from.
So this FR makes sense, but I suspect it's not highly feasible given the way common.cache works now.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1854#c4) posted by **crai...@microsoft.com** on 2014-09-23 at 07:07 PM_
---
In case it wasn't clear, I already wrote the code and worked to ensure the independent (in the concurrency sense) of the segments.  Let me know what you think after reviewing the code.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1854#c5) posted by **lowasser@google.com** on 2014-09-23 at 07:16 PM_
---
Part of the point of the way LocalCache is currently implemented is that operations on two different segments should not contend for any locks.  From what I can tell, your approach seems to require a global AtomicLong updated on every operation on every segment.
The current approach was a deliberate tradeoff: accepting imprecise weight-based evictions for the sake of keeping segments as independent as possible.  For more typical usages of Cache, this seems likely to be a significant performance loss as lots of small, cheap cache operations are forced to contend on a single AtomicLong.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1854#c6) posted by **fry@google.com** on 2014-09-23 at 07:25 PM_
---
The real solution here is to implement the eviction queue globally instead of per-segment. We have an internal issue about this (which needs to be made external), but we know how to do this and even wanted to do it in 2011 but didn't have a compelling case for justifying the change. This seems like a pretty compelling reason to do that right.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1854#c7) posted by **fry@google.com** on 2014-09-23 at 07:35 PM_
---
_(No comment entered for this change.)_
---
**CC:** fry@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1854#c8) posted by **crai...@microsoft.com** on 2014-09-23 at 07:49 PM_
---
As for how often it is called, AtomicLong.addAndGet() is called in two places -- same two places that this.totalWeight is updated.  These calls occur only for writes and removals which already take the per-segment lock and are relative heavy weight.
In particular, AtomicLong.addAndGet() is NOT called in the normal read case.  There is one edge case I covered, but it is likely very rare and may not be worth coding for.
However, I might have missed some other problematic case and would be happy to know what I missed.
As for the "real solution" I agree and of course would be happy with any better solution than the one I have proposed.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1854#c9) posted by **lowasser@google.com** on 2014-09-23 at 07:59 PM_
---
> As for how often it is called, AtomicLong.addAndGet() is called in two places -- same two places that this.totalWeight is updated.  These calls occur only for writes and removals which already take the per-segment lock and are relative heavy weight.
My understanding is that taking the segment lock is one thing, but that many threads hammering on a single AtomicLong can be a serious performance issue.  For example, Doug Lea's most recent ConcurrentHashMap implementation avoids AtomicLong for this reason, using some seriously magic alternatives.  We actually have that class in Guava, under the name LongAdder, but I'm not sure we could use that and still preserve the invariant that the cache as a whole never goes over the limit.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1854#c10) posted by **crai...@microsoft.com** on 2014-09-24 at 02:57 AM_
---
The existing Segment.totalWeight values are like the Cell values in Doug Lea's approach.  I changed my code to avoid the AtomicLong completely at the cost of a sum of the segments totalWeight values.
Let me know what you think.
---
I may be blind, but I can't see there any visibility guarantee for segment.totalWeight in evictEntriesFromLargestSegment.
For normally behaving caches, there'd no contention at all as all segments would reach and stay at about their maximum size and never update the AtomicLong.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1854#c12) posted by **crai...@microsoft.com** on 2014-09-29 at 03:07 PM_
---
That's another good idea to reduce the potential cost / contention of using AtomicLong.
My most recent version avoids AtomicLong altogether -- summing up the total segment weights as needed during eviction.
What are the next steps here?  Do you have perf tests against which we can measure this change?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1854#c13) posted by **crai...@microsoft.com** on 2014-09-30 at 04:32 PM_
---
It was mentioned above and in another forum that perhaps a better hash function would solve this.  The issue stems from the combination of the hash function distribution AND the distribution of the sizes of the elements -- the later of which cannot be encoded in the hash function.  With a "perfect" hash function, each cache segment would have an equal number of (and let's say equal aged) entries.  If the entries vary in size then the cache will still be out of balance (size-wise) and likely never utilize the specified cache fully.  The more the size varies, the more the cache won't utilized RAM fully.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1854#c14) posted by **greg.mar...@elasticsearch.com** on 2014-10-08 at 08:18 PM_
---
Any update on this?  Would like to get an idea of where this is heading in order to take the appropriate action in ES (see https://github.com/elasticsearch/elasticsearch/issues/7836).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1854#c15) posted by **lowasser@google.com** on 2014-10-13 at 09:30 PM_
---
I think my concrete issue with the current version of the change is that it's back to allowing races: totalSegmentView() can have an inconsistent view of the size of the different segments.  You'd encounter this issue with LongAdder, too, I believe.
The current solution manages to _guarantee_ that the weight cap is never exceeded even in a multithreaded context, and keeps each operation local to the specific segment it needs to access, without contending with operations on any other segment.  In exchange, it works poorly for a very narrow range of use cases like this, where the size of individual cache entries is a large fraction of the total weight cap, relative to the concurrencyLevel.
To be honest, I can't see any way of maintaining these invariants while accomplishing something like your goal here.  If we come up with a way to maintain these invariants while increasing cache utilization, we can come back to this, but I don't think this is likely to go anywhere in the near term.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1854#c16) posted by **crai...@microsoft.com** on 2014-10-14 at 12:13 AM_
---
The current solution, in fact, does NOT guarantee that the weight cap is never exceeded.  On cache miss the following high level steps happen in this order:
1. load new data and store into segment
&nbsp;&nbsp;&nbsp;&nbsp;(cf. code called from loadSync())
2. _then_ check to see if segment is _over_ full (while (totalWeight > maxSegmentWeight) { &lt;do evict> } )
&nbsp;&nbsp;&nbsp;&nbsp;(this is in eviceEntries())
Which means that every segment can be at 100% full and the very next load on any segment will cause the memory usage to exceed the segment weight and thus the whole cache weight.  If this happened all at the same time for many/all segments, each of those segments could go over at the same time and the cache would be over weight by the size of the data just loaded.
I believe that my proposal will result in a cache level over commit amount similar to the current code (not identical, but similar).
Of course, the problem I'm trying to solve is the under commit amount.  My proposal dramatically improves the behavior on the under commit side.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1852) created by **cairomassimo** on 2014-09-21 at 09:43 AM_
---
Suppose I have checked at runtime that TypeToken.of(Base.class).isAssignableFrom(type), where "type" is a java Type.
I now want to do TypeToken.of(type).getSupertype(Base.class).
However, this will not compile as TypeToken.of(type) returns TypeToken<?>, and getSuperclass wants its argument to be a Class<? super T>, where T is the capture type for <?>.
AFAIK, there is no way to get a TypeToken<? extends Base> from TypeToken.of(type), even if we know at runtime that Base is assignable from "type".
A possible solution would be to add a checked narrowing operation to TypeToken, such as:
public &lt;U> TypeToken<? extends U> as(TypeToken&lt;U> other) {
&nbsp;&nbsp;// check other is assignable from this
&nbsp;&nbsp;return (TypeToken<? extends U>) this;
}
and a similar method that accepts a Class&lt;U> instead of TypeToken&lt;U>.
This would avoid the need of unchecked conversions by the user.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1851) created by **argaul** on 2014-09-19 at 05:34 PM_
---
Lists.newArrayList and Maps.newHashMap include blurbs like:
&nbsp;&nbsp;&nbsp;\* <p><b>Note for Java 7 and later:</b> if {@code elements} is a {@link
&nbsp;&nbsp;&nbsp;\* Collection}, you don't need this method. Use the {@code ArrayList}
&nbsp;&nbsp;&nbsp;\* {@linkplain ArrayList#ArrayList(Collection) constructor} directly, taking
&nbsp;&nbsp;&nbsp;\* advantage of the new <a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.
Sets.newHashSet should include a similar note.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1851#c1) posted by **kevinb@google.com** on 2014-09-19 at 05:41 PM_
---
Indeed, a lot of things still need this, thanks for the kick.
---
**Status:** `Accepted`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1851#c2) posted by **argaul** on 2014-09-23 at 01:47 AM_
---
modernizer-maven-plugin has a more complete list of there:
https://github.com/andrewgaul/modernizer-maven-plugin/blob/master/src/main/resources/modernizer.xml
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1849) created by **sebastian.davids** on 2014-09-17 at 12:34 PM_
---
Please support bcrypt in com.google.common.hash.Hashing
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1849#c1) posted by **tavianator** on 2014-09-24 at 06:27 PM_
---
No one should be using bcrypt for hash tables, which is what Hashing is for.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1849#c2) posted by **cgdecker@google.com** on 2014-09-24 at 06:39 PM_
---
Hashing is not only (or even primarily) for hash tables: https://code.google.com/p/guava-libraries/wiki/HashingExplained
---
**Labels:** `Package-Hash`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1849#c3) posted by **sebastian.davids** on 2014-09-24 at 07:03 PM_
---
Bcrypt is one of the three good password hashing schemes -- md5() or sha256() are outdated and insecure.
https://password-hashing.net
http://security.stackexchange.com/questions/4781/do-any-security-experts-recommend-bcrypt-for-password-storage
---
> sha256() are outdated and insecure.
That's pure nonsense. SHA-256 is still rather modern (SHA-3 is out, but it'll take years) and secure HASH FUNCTION.
bcrypt is NO hash function, it's a key derivation function. Using hash functions as a KDF is insecure, no matter how good the function.
A KDF is no com.google.common.hash.HashFunction as it always needs a salt. This is can be an additional input[1](http://docs.spring.io/autorepo/docs/spring-security/3.1.7.RELEASE/apidocs/org/springframework/security/crypto/bcrypt/BCrypt.html) or generated randomly[2](https://github.com/wg/scrypt/blob/master/src/main/java/com/lambdaworks/crypto/SCrypt.java). Fitting it to the interface by fixing an argument would be a very stupid idea. Allowing a hash function to behave randomly would be no smarter.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1842) created by **cpovirk@google.com** on 2014-09-04 at 02:34 PM_
---
http://stackoverflow.com/q/25646191/28465
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1842#c1) posted by **cpovirk@google.com** on 2014-09-04 at 02:35 PM_
---
For comparison, Range_Set_ says:
"The iterators returned by its Iterable#iterator method return the ranges in increasing order of lower bound (equivalently, of upper bound)."
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1842#c2) posted by **cgdecker@google.com** on 2014-09-04 at 03:25 PM_
---
Would it make sense for RangeMap.asMapOfRanges() to return SortedMap&lt;Range&lt;K>, V>? Similarly for RangeSet.asRanges().
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1842#c3) posted by **cpovirk@google.com** on 2014-09-04 at 05:50 PM_
---
Internally, comments on CL 23059491 and CL 23565836 touch on this, as does &lt;http://go/more-on-range-collection-sorted-views>. I feel like there may have been other discussions, too.
In short, there is some weirdness around defining a Comparator that does the right thing. I think that we're required to use RANGE_LEX_ORDERING: We must compare the beginning of the ranges first to get order right, and we must compare the end of the ranges also so that contains() works. But is that Comparator prone to misuse with other methods?
(Part of the discussion was that few users are likely to need the SortedMap/SortedSet features. The one counterexample we'd come across so far was a need for last*() methods.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1842#c4) posted by **lowasser@google.com** on 2014-09-04 at 05:53 PM_
---
I'm comfortable guaranteeing the iteration order, but not for returning a SortedMap.  As Chris alluded to, I see the reasoning as similar to why SortedMap.entrySet() doesn't return a SortedSet.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1842#c5) posted by **cpovirk@google.com** on 2014-09-04 at 06:05 PM_
---
Oh, right. I forgot that the Map case is especially bad -- definitely bad news for any comparator we might define, since it has to be a Comparator&lt;Entry<...>>, and the value isn't necessarily Comparable.
RangeSet.asRanges() might be less bad than that, since both endpoints of the Range object are Comparable, but it's still potentially error-prone when used with any kind of element-relative method.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1842#c6) posted by **cgdecker@google.com** on 2014-09-04 at 06:06 PM_
---
Hmm, yeah... I was just thinking in terms of the ranges that are in the RangeSet/Map, which are non-overlapping and as such easy to represent as Sorted*. But I can see that it would be confusing with sub/head/tailSet/Map etc.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1842#c7) posted by **lowasser@google.com** on 2014-09-24 at 06:54 PM_
---
Fixed internally; change will be mirrored out soon.
---
**Status:** `Fixed`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1840) created by **stefan.liebig** on 2014-09-03 at 06:14 AM_
---
The handleException() method on the LoggingSubscriberExceptionHandler is called with exception.getCause(). This is fine - it returns the target exception of the InvocationTargetException.
However, the handleException() method logs this failure with exception.getCause() which than skips one exception.
A simple workaround is to provide an own SubscriberExceptionHandler.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1840#c1) posted by **cgdecker@google.com** on 2014-09-03 at 06:30 PM_
---
Good catch. It looks like this is already fixed in some changes to EventBus for Guava 19, but we may need to consider an 18.0.1 release for this.
---
**Labels:** `Type-Defect`, `Package-EventBus`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1839) created by **SeanPFloyd** on 2014-08-29 at 08:36 AM_
---
Ints.tryParse(String s, int radix)
Longs.tryParse(String s, int radix)
That way, Ints/Longs.tryParse could be used as drop-in replacements both String versions of Integer/Long.valueOf
Another thing worth thinking about would be to add similar methods that return Optional&lt;Integer / Long>, forcing client code to actually react on the changed semantics of using tryParse rather than valueOf. Of course the question of how to name these methods is a nasty one. tryParse would've been a perfect naming choice for that
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1839#c1) posted by **cgdecker@google.com** on 2014-08-29 at 08:33 PM_
---
_(No comment entered for this change.)_
---
**Owner:** lowasser@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1839#c2) posted by **cpovirk@google.com** on 2014-08-29 at 08:38 PM_
---
Did we have any reservations that tryParse("foo", 10) might look like it's providing a default value rather than a radix? I forget.
(We did give some thought to Optional&lt;Integer> and so forth. Our reasoning for sticking with Integer was that the method was intended to be fast. But it's not clear cut. For example, and extreme version of that reasoning could have led to our choosing to return |long| with an out-of-int-bounds value used to indicate invalid inputs. We could also have introduced OptionalInteger/OptionalLong classes.)
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1838) created by **kofemann** on 2014-08-25 at 02:40 PM_
---
Hi,
it looks like CacheStats is missing putCount, which makes statistics not complete if you have situations where cache is populated by load and explicit put.
An possible implementation can be found at:
https://code.google.com/r/kofemann-kofemann-cache-with-put-count/source/detail?r=4810e0e85ea406b0e23324f0379351a23f8eb514
-k
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1838#c1) posted by **kak@google.com** on 2014-08-25 at 06:05 PM_
---
_(No comment entered for this change.)_
---
**Owner:** lowasser@google.com
**Labels:** `Package-Cache`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1837) created by **bedla.czech** on 2014-08-23 at 11:18 AM_
---
Hi,
I have attached test case with workaround and probable fix when LoadingCache uses weakKeys with weakValues.
Could you look at it - code will tell you more. You can build test case with Guava 14 and 17 (Maven profile) when symptoms are the same.
Thx
_Test case 1_
class com.google.common.eventbus.EventBus loaded by sun.misc.Launcher$AppClassLoader@1d6535bf
--- start ---
class guava.Callback loaded by java.net.URLClassLoader@25b0eadd
class guava.Callback$Event loaded by java.net.URLClassLoader@25b0eadd
&nbsp;&nbsp;&nbsp;&nbsp;Callback    java.net.URLClassLoader@25b0eadd
&nbsp;&nbsp;&nbsp;&nbsp;Event        java.net.URLClassLoader@25b0eadd
--- end ---
Loading cache result {class guava.Callback=[public void guava.Callback.onEvent(guava.Callback$Event)]}
=== Memory leak detected? ===`
_Test case 2_
_Note: take a look at inconsistency message_
class com.google.common.eventbus.EventBus loaded by sun.misc.Launcher$AppClassLoader@5fab9dac
--- start ---
Test with weak values loading cache
class com.google.common.cache.LocalCache$LocalLoadingCache loaded by sun.misc.Launcher$AppClassLoader@5fab9dac
class guava.Callback loaded by java.net.URLClassLoader@1f4cc34b
class guava.Callback$Event loaded by java.net.URLClassLoader@1f4cc34b
&nbsp;&nbsp;&nbsp;&nbsp;Callback    java.net.URLClassLoader@1f4cc34b
&nbsp;&nbsp;&nbsp;&nbsp;Event        java.net.URLClassLoader@1f4cc34b
--- end ---
Loading cache result {}
=== Memory leak detected? ===
Inconsistent .toString({}) and .size(1) when LoadingCache.asMap() called ???`
_Test case 3_
class com.google.common.eventbus.EventBus loaded by sun.misc.Launcher$AppClassLoader@5fab9dac
--- start ---
Test with loading cache invalidation workaround
class guava.Callback loaded by java.net.URLClassLoader@f785762
class guava.Callback$Event loaded by java.net.URLClassLoader@f785762
&nbsp;&nbsp;&nbsp;&nbsp;Callback    java.net.URLClassLoader@f785762
&nbsp;&nbsp;&nbsp;&nbsp;Event        java.net.URLClassLoader@f785762
--- end ---
Loading cache result {}`
---
I guess this is caused by the static members of `SubscriberRegistry`: `flattenHierarchyCache`&nbsp;and `subscriberMethodsCache`. They use `weakKeys`, but this seems to be of no use at all, because of the strong value references. In your example, an entry linking `Callback.class`&nbsp;to `ImmutableList.of(Callback#onEvent)`&nbsp;gets created, and the method strongly references its class, so nothing can be GC'ed.
---
I know why it is caused :-) . Anyways thanks for summarization...
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1837#c3) posted by **cgdecker@google.com** on 2014-08-30 at 05:44 PM_
---
I'm not sure what can be done about this. In the flattenHierarchyCache case (used for event types), I think we could safely store the values in WeakReferences. In the subscriberMethodsCache, I'm pretty sure we can't, because Class always returns _copies_ of the Method objects. In other words, if we store WeakReferences to the Methods, nothing will be strongly referencing those Method objects and they'll just get GC'ed, meaning we aren't really caching anything. And just not caching the Methods seems like it could have a significant performance impact.
As an aside, I don't feel like using a shared EventBus to communicate between separate web applications is a good idea. In particular, I'd be concerned about things like different applications loading the "same" class with different classloaders. There are other tools that are better suited for what is effectively interprocess communication.
---
**Labels:** `Type-Enhancement`, `Package-EventBus`
---
> nothing will be strongly referencing those Method objects
I'd say, as long as they're used in an `EventBus`, their `Subscriber`s will. But if they're not, then they can be GC'd even when their classes are loaded and this is AFAIK unsolvable without ephemerons.
And you'd have to use `ImmutableList<WeakReference<Method>>`&nbsp;which means that you could get an incomplete method list from the cache. Surely solvable, but ugly.
Anyway, using `weakKeys`&nbsp;in the current design doesn't help at all, does it?
A minor optimization: I guess `getAnnotatedMethodsNotCached`&nbsp;could use `flattenHierarchyCache`&nbsp;instead of `TypeToken.of(clazz).getTypes().rawTypes()`.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1837#c5) posted by **cgdecker@google.com** on 2014-08-30 at 08:48 PM_
---
> I'd say, as long as they're used in an `EventBus`, their `Subscriber`s will. But if they're not, then they can be GC'd even when their classes are loaded and this is AFAIK unsolvable without ephemerons.
True, though if you've got a class that is subscribed and unsubscribed repeatedly it's not really helping.
> And you'd have to use `ImmutableList<WeakReference<Method>>`&nbsp;which means that you could get an incomplete method list from the cache. Surely solvable, but ugly.
Actually, if the Methods are being thrown into WeakReferences in the CacheLoader, they wouldn't have any strong references left even before the call to LoadingCache.get that loads them completes. Which makes it sound like it's possible that you might _never_ get a complete list of Methods back.
> Anyway, using `weakKeys`&nbsp;in the current design doesn't help at all, does it?
No, not really.
> A minor optimization: I guess `getAnnotatedMethodsNotCached`&nbsp;could use `flattenHierarchyCache`&nbsp;instead of `TypeToken.of(clazz).getTypes().rawTypes()`.
It could, but I don't feel like it's really an optimization at all given that the result of getAnnotatedMethodsNotCached is cached itself. Right now, that TypeToken.of(clazz).getTypes().rawTypes() should only be called once per class anyway, so we'd be caching the result for no reason. (And I think it's very unlikely that there would be any overlap between the current usage of flattenHiearchyCache and this, since currently it's only used for event classes, while this would be using it for subscriber classes.) If we weren't caching the result, that would be a different story.
---
I think that good enought solution would be having flush cache methods on EventBus (or on AnnotatedSubscriberFinder) like JavaBeans Introspector have.
java.beans.Introspector#flushCaches()
java.beans.Introspector#flushFromCaches(Class<?>)
Btw. In my design I have MyEvent classes loaded by same shared classloader which loads Guava. And shared event classes refer to classes from same shared classloader or from parent class loaders.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1835) created by **tadamson** on 2014-08-19 at 11:20 PM_
---
Creating a singleton immutable sorted set by calling of() with a non-Comparable object is not allowed (via "FauxverideShim"). However, one can be created by first instantiating a single element Collection and creating a copyOf() it.
&nbsp;&nbsp;Object notComparable = new Object();
&nbsp;&nbsp;ImmutableSortedSet.of(notComparable);
Example (works):
&nbsp;&nbsp;Object notComparable = new Object();
&nbsp;&nbsp;ImmutableSortedSet.copyOf(ImmutableSet.of(notComparable));
I submit that they should both work or both fail. While technically a singleton non-comparable SortedSet violates the SortedSet contract ("All elements inserted into a sorted set must implement the Comparable interface"), it make senses to me that an immutable SortedSet of 1 element could be an exception (and thus not throw an Exception). In fact, TreeSet does not fail with a single non-Comparable element:
&nbsp;&nbsp;SortedSet&lt;Object> sortedSet = new TreeSet&lt;Object>();
&nbsp;&nbsp;sortedSet.add(notComparable);
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1835#c1) posted by **kevinb@google.com** on 2014-08-20 at 01:18 PM_
---
Nice find. I believe we should make copyOf fail.
I believe the TreeSet bug you mention is finally fixed for JDK 8.
---
**Status:** `Accepted`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1835#c2) posted by **tadamson** on 2014-08-20 at 05:30 PM_
---
I checked and you're correct that the TreeSet bug is fixed (in a Java 7 release). For enterprise (read too boring to enumerate here) reasons, we're still on a late build of Java 6. I retract my final comment and agree with your assessment.
We tried to do this last year, but we found that it would break some internal users. That means two things:
- We need to fix those users.
- It's probably going to break external users, too.
It might still be a good idea to fix, but things are no longer as simple as hoped :(
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1825) created by **dpletcher@google.com** on 2014-08-01 at 09:32 PM_
---
[Via email, kevinb encouraged me to submit this request.]
RangeSet is great, and provides me with lots of useful capabilities. There is one fundamental, useful operation that's unexpectedly missing: intersect. There's a subRangeSet method, but it only operates on a single Range, not another RangeSet.
Since there is a union method (aka addAll), and a complement method, I should be able to cobble together an intersect method thus:
&nbsp;&nbsp;&lt;T> RangeSet&lt;T> intersect(RangeSet&lt;T> a, RangeSet&lt;T> b) {
&nbsp;&nbsp;&nbsp;&nbsp;RangeSet inverse = TreeRangeSet.create(a.complement);
&nbsp;&nbsp;&nbsp;&nbsp;inverse.addAll(b.complement());
&nbsp;&nbsp;&nbsp;&nbsp;return inverse.complement();
&nbsp;&nbsp;}
Nonetheless, life would be simpler and more worry-free for all users if the API directly supported an intersect method.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1825#c1) posted by **heuermh** on 2014-08-05 at 03:35 PM_
---
See also issue 1778, which addresses this use case but unfortunately has received no review or triage in two months.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1825#c2) posted by **lowasser@google.com** on 2014-08-06 at 05:47 PM_
---
---
**Owner:** lowasser@google.com
**Labels:** `Type-Addition`, `Package-Collect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1825#c4) posted by **heuermh** on 2014-09-24 at 09:38 PM_
---
The code referred to in issue 1778 has been open sourced under the LPGL version 3 or later license.
https://github.com/nmdp-bioinformatics/ngs/tree/master/range/src/main/java/org/nmdp/ngs/range/tree
We'll probably be considering this soon.
One quick note: I think that the copying version of this method can skip most of the `complement` calls by using `removeAll` instead of `addAll`:
```
<T> RangeSet<T> intersect(RangeSet<T> a, RangeSet<T> b) {
RangeSet<T> copy = TreeRangeSet.create(a);
copy.removeAll(b.complement());
return copy;
}
```
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1823) created by **qi.c...@ocado.com** on 2014-07-31 at 10:51 AM_
---
Could there be a method on Invokable or static factory in Functions to convert Invokable to a Function assuming arg-less invocation?
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1822) created by **archie.cobbs** on 2014-07-30 at 09:42 PM_
---
Test program:
&nbsp;&nbsp;import com.google.common.reflect.TypeToken;
&nbsp;&nbsp;public class Outer {
```
public abstract static class Inner<T extends Inner<T>> {
}
public void foo(Iterable<? extends Inner<?>> arg) {
}
public static void main(String[] args) throws Exception {
System.out.println(
TypeToken.of(Outer.class.getMethod("foo", Iterable.class)
.getGenericParameterTypes()[0]));
}
```
&nbsp;&nbsp;}
Expected output:
&nbsp;&nbsp;java.lang.Iterable<? extends Outer$Inner<?>>
Actual output:
&nbsp;&nbsp;java.lang.Iterable<? extends Outer.Outer$Inner<?>>
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1822#c1) posted by **archie.cobbs** on 2014-07-30 at 09:43 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1822#c2) posted by **cpovirk@google.com** on 2014-07-30 at 10:03 PM_
---
_(No comment entered for this change.)_
---
**Owner:** benyu@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1822#c3) posted by **benyu@google.com** on 2014-07-30 at 11:55 PM_
---
Any strong opinion between Outer.Inner vs. Outer$Inner?
The tricky part is when the outer class is parameterized.
innerClass.getName() would print: "O$I"
But one may prefer to see "O&lt;T>.I&lt;S>".
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1822#c4) posted by **archie.cobbs** on 2014-07-31 at 12:35 AM_
---
Actually I reduced the test case to something so simple I think it obscured the real bug.
If you add "package pkg" at the top of the test case, then this will be the output:
&nbsp;&nbsp;java.lang.Iterable<? extends pkg.Outer.pkg.Outer$Inner<?>>
So it's not just a question of preference - "pkg.Outer.pkg.Outer" is clearly wrong.
Back to your question, seems like staying consistent with Class.getName() is good, but that means we lose the outer type parameter, and IMHO the latter is more important... i.e., TypeToken.toString() should reveal as much of its secret type information as possible because people are mainly using it to understand what the type really is.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1822#c5) posted by **benyu@google.com** on 2014-08-01 at 05:35 AM_
---
Interestingly, JDK7's built-in ParameterizedType.toString() does the same thing.
Map.Entry&lt;String, String>.toString() => "java.util.Map.java.util.Map$Entry&lt;java.lang.String, java.lang.String>"
Do we want to make our types behave differently from builtin types?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1822#c6) posted by **benyu@google.com** on 2014-08-01 at 05:45 AM_
---
Well. Actually, when you call TypeToken.of(jvmType).toString(), it's really just calling jvmType.toString().
TypeToken isn't doing anything in the middle here.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1822#c7) posted by **archie.cobbs** on 2014-08-02 at 03:55 PM_
---
FWIW I filed a bug on bugs.sun.com (which, in my experience, is just a black hole fronted by a web site).
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1821) created by **jbjrke** on 2014-07-30 at 07:35 AM_
---
Error from our log:
com.google.gwt.user.client.rpc.SerializationException: could not get type signature for class com.google.common.collect.DenseImmutableTable$Row
There is no CustomFieldSerializer for the subclasses of ImmutableArrayMap which is an inner class of DenseImmutableTable
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1821#c1) posted by **cpovirk@google.com** on 2014-08-01 at 03:45 PM_
---
Thanks. I'm hoping that GWT will make some changes to make this easier. I've been hoping that for a while, though. I just filed a GWT feature request to try to get an update:
https://code.google.com/p/google-web-toolkit/issues/detail?id=8844
---
**Labels:** `Package-Collect`
Your best bet is to call `ImmutableList.copyOf(...subList...)` to get a `RegularImmutableList` back :(
We could probably make `SubList` serialization work under GWT, but it's unlikely to ever be a high enough priority, given the deprecation of GWT-RPC. Sorry.
(I'd be happy to review a pull request. You'd probably need to make `SubList` a top-level type.)
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1819) created by **ogregoire** on 2014-07-29 at 03:35 PM_
---
When I call the following, the test case fails (see full test case in attachment).
&nbsp;&nbsp;new ClassSanityTester().testNulls(MyObject.class);
I get the following error: No exception thrown for parameter at index 0 from MyObjectTest$MyObject.public boolean MyObjectTest$MyObject.equals(java.lang.Object)[null] for class MyObjectTest$MyObject
Clearly, this indicates that it expects a call to "equals(Object)" to throw a NullPointerException. That method should never throw an exception but rather return true or false. The test seems to skip this assertion and I'm surprised this hasn't been reported earlier.
Please make it so ClassSanityTester#testNulls(Class) doesn't fail when equals is behaving correctly (see the test case where testEquals(MyObject.class succeeds).
On a side note, the text returned should be adapted as it mentions three times MyObjectTest$MyObject. That's 2 too many, and it renders the whole error message nearly not understandable.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1819#c1) posted by **ogregoire** on 2014-07-30 at 03:21 PM_
---
Okay, I found one issue on my side: the lack of online javadoc available. I had to check in the code online to find out that it's playing nice only if @Nullable is present.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1818) created by **cristianofontes** on 2014-07-29 at 06:18 AM_
---
I really like those 2 and have used them from Underscore.js a couple times.
I Think they are more like a functional thing, but nevertheless they are very useful for handling UI events.
http://underscorejs.org/#throttle
http://underscorejs.org/#debounce
Cheers
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1817) created by **henn...@schmiedehausen.org** on 2014-07-25 at 05:59 PM_
---
As issue #1348 is not really going anywhere right now, I am trying to shut down an AsyncEventBus instance in a controlled manner (ensure that no new events are enqueued, make sure that all events in the queue get dispatched before shut down).
It would be great to have a defined way to "shut down" an event bus so that it no longer accepts new events and also a way to ask it whether it is "fully drained" (No events in flight).
As the current event bus code is all package private, the only way to actually implement it is to shim my code into the com.google package which seems to be weird. So consider this another vote to make EventBus and AsyncEventBus easily extendable.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1814) created by **jens.ran...@tink.se** on 2014-07-24 at 11:24 AM_
---
Proposal: Add a method to CacheBuilder that allows for randomization of expiration. This will eventually spread expiration evenly over time.
Workaround: Instantiate a Random instance and use it as input to `.expire*`&nbsp;method. Cumbersome.
I'd love to hear your input on this.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1813) created by **j...@nwsnet.de** on 2014-07-23 at 03:21 PM_
---
I didn't find information on the immutability of `Range`&nbsp;instances in the JavaDocs [1]; only the wiki page [2] explicitly states it.
I suggest documenting the immutability directly in the JavaDocs, and thus in the implementation itself.
(Slightly unrelated: The comments disappeared from the wiki, especially helpful ones which I remembered to be on the page on ranges are gone. I'd like to state that I don't welcome that change.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1813#c1) posted by **kevinb@google.com** on 2014-07-23 at 03:44 PM_
---
---
**Status:** `Accepted`
**Labels:** `Type-ApiDocs`, `Package-Collect`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1812) created by **cpovirk@google.com** on 2014-07-21 at 08:03 PM_
---
There are a number of distinct issues here, and it's not really fair of me to mark them all as duplicates. However, we've got at least 7 bugs filed, and in broad strokes, they come down to 3 basic points:
1. Annotate return types as @Nullable/@NonNull more consistently.
2. Follow the annotation interpretations used by different versions of Findbugs / by Eclipse / by the Checker Framework.
Kevin is likely to attempt to do some of (1), but we will never get it 100% unless we do (2) or (3), both of which look more difficult than we expect to take on soon.
Again, I apologize for the oversimplification of collapsing these all to one bug. I'm just trying to better capture the way we think of the situation, which is basically "annotation some return types, then give up for a while."
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1812#c1) posted by **cpovirk@google.com** on 2014-07-21 at 08:05 PM_
---
_Issue #1811 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1812#c2) posted by **cpovirk@google.com** on 2014-07-21 at 08:05 PM_
---
_Issue #1810 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1812#c3) posted by **cpovirk@google.com** on 2014-07-21 at 08:06 PM_
---
_Issue #1677 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1812#c4) posted by **cpovirk@google.com** on 2014-07-21 at 08:06 PM_
---
_Issue #1278 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1812#c5) posted by **cpovirk@google.com** on 2014-07-21 at 08:06 PM_
---
_Issue #1221 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1812#c6) posted by **cpovirk@google.com** on 2014-07-21 at 08:06 PM_
---
_Issue #920 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1812#c7) posted by **cpovirk@google.com** on 2014-07-21 at 08:06 PM_
---
_Issue #1279 has been merged into this issue._
---
In our main Java application we drew a line in the sand to minimize null values in every class. This involved implementing the Null Object pattern in many cases but mostly being consistent with our annotations.
We started by creating the missing package-level annotations FieldsAreNonnulByDefault and ReturnValuesAreNonnullByDefault and ensuring they are applied to every package along with ParametersAreNonnullByDefault. From there it was easy: apply CheckForNull whenever null is allowed.
The beauty of this approach is that anyone reading the code knows what to expect in the absence of an annotation. If most elements allow null, create your own defaults, but I highly recommend using the same default for fields, parameters, and return values. Mixing defaults across the three will only cause confusion.
I would be happy to help out in this endeavor because I feel it would help lots of developers use this awesome library.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1811) created by **bogdanb** on 2014-07-21 at 12:36 PM_
---
ImmutableMap.get (and its analogue in the various subclasses like BiMap) does not have any annotation on its return value. As far as I can determine the intent is that it should be (correctly) inferred as possibly null.
Unfortunately Eclipses null analysis is (and probably will be for quite a long time) somewhat limited. Among other things, it doesnt know about the jsr305 annotations, using its own versions by default. It can be configured to look for the jsr305 ones, but unfortunately its default nullity annotation is NonNullByDefault, with the semantics that it applies to method return values as well. (Unlike ParametersAreNonnullByDefault, which is supposed to apply to parameters only.)
Since ParametersAreNonnullByDefault are used more or less everywhere in Guava, Eclipse at mistakenly infers ImmutableMap.get to never return null, which is both dangerous (it can't warn about errors) and annoying (it reports correct null checks as redundant).
It would be nice if Guava added an explicit @Nullable annotation on that method. Itd be at worst redundant, and since it'll take quite a bit for Eclipse to improve its nullity annotation support (they were still discussing how the last time I checked), itd help a lot of developers in the mean time.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1811#c1) posted by **cpovirk@google.com** on 2014-07-21 at 08:05 PM_
---
I am somewhat inaccurately collapsing a bunch of nullability-annotation bugs into &lt;https://github.com/google/guava/issues/1812 My apologies for the oversimplification.
---
**Status:** `Duplicate`
**Merged Into:** #1812
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1809) created by **NatalyaDobry** on 2014-07-21 at 10:40 AM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1809#c1) posted by **NatalyaDobry** on 2014-07-21 at 11:47 AM_
---
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1806) created by **smrtprjcts** on 2014-07-17 at 10:44 AM_
---
Hi,
I've got this:
java.lang.ExceptionInInitializerError
&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.base.Splitter.&lt;init>(SourceFile:110)
&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.base.Splitter.on(SourceFile:174)
&nbsp;&nbsp;&nbsp;&nbsp;at com.x.y.BaseApplication.count(SourceFile:900)
&nbsp;&nbsp;&nbsp;&nbsp;at com.x.y.CheckNewApps.doInBackground(SourceFile:106)
&nbsp;&nbsp;&nbsp;&nbsp;at com.x.y.CheckNewApps.doInBackground(SourceFile:1)
&nbsp;&nbsp;&nbsp;&nbsp;at android.os.AsyncTask$2.call(AsyncTask.java:288)
&nbsp;&nbsp;&nbsp;&nbsp;at java.util.concurrent.FutureTask.run(FutureTask.java:237)
&nbsp;&nbsp;&nbsp;&nbsp;at android.os.AsyncTask$SerialExecutor$1.run(AsyncTask.java:231)
&nbsp;&nbsp;&nbsp;&nbsp;at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)
&nbsp;&nbsp;&nbsp;&nbsp;at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)
&nbsp;&nbsp;&nbsp;&nbsp;at java.lang.Thread.run(Thread.java:811)
Caused by: java.lang.UnsupportedOperationException
&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.base.CharMatcher.a(SourceFile:775)
&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.base.CharMatcher.&lt;clinit>(SourceFile:212)
&nbsp;&nbsp;&nbsp;&nbsp;... 11 more
&nbsp;public int count(String string, String substring) {
&nbsp;&nbsp;&nbsp;int count=0;
&nbsp;&nbsp;&nbsp;try{
&nbsp;&nbsp;&nbsp;&nbsp;count = Iterables.size(Splitter.on(substring).split(string)) - 1;
&nbsp;&nbsp;&nbsp;} catch (Exception e){
...
&nbsp;&nbsp;&nbsp;}
Yes, count = ... is the line 900?
Thanks
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1806#c1) posted by **smrtprjcts** on 2014-07-17 at 10:45 AM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1806#c2) posted by **smrtprjcts** on 2014-07-17 at 02:34 PM_
---
String parameters aren't null.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1806#c3) posted by **cgdecker@google.com** on 2014-07-17 at 03:53 PM_
---
&nbsp;&nbsp;public static final CharMatcher JAVA_ISO_CONTROL =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inRange('\u0000', '\u001f')
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.or(inRange('\u007f', '\u009f'))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.withToString("CharMatcher.JAVA_ISO_CONTROL");
(https://github.com/google/guava/blob/v17.0/guava/src/com/google/common/base/CharMatcher.java#L212)
But withToString is being called on a CharMatcher returned by or(...), and the Or CharMatcher definitely overrides withToString and doesn't throw UOE from it.
Is there another version of Guava on your classpath somehow? Seems unlikely to cause this issue given that the problem here seems to be constrained to just 1 class, but probably worth checking. I also wonder if the obfuscation that appears to have been done could be causing it somehow. This obviously doesn't normally happen, as it would cause CharMatcher and anything that uses it to never work.
---
**Labels:** `Package-Base`, `Type-Defect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1806#c4) posted by **smrtprjcts** on 2014-07-17 at 04:55 PM_
---
Hi,
I have on guava lib in the project, but I use proguard.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1806#c5) posted by **smrtprjcts** on 2014-07-17 at 04:55 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1806#c6) posted by **cgdecker@google.com** on 2014-07-17 at 05:09 PM_
---
I have to think this is somehow caused by proguard. I wonder if it's for some reason stripping out the override of withToString from CharMatcher.Or, causing the default implementation of withToString on CharMatcher to be called?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1806#c7) posted by **smrtprjcts** on 2014-07-17 at 05:59 PM_
---
I'm no an expert, I cannot help you :D
But if it's a proguard thing why this comes in one device? Is it possibe?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1806#c8) posted by **cgdecker@google.com** on 2014-07-17 at 06:05 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1806#c9) posted by **smrtprjcts** on 2014-07-21 at 04:42 PM_
---
Is it uptodate? Seems to be a bit old
https://code.google.com/p/guava-libraries/wiki/UsingProGuardWithGuava
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1803) created by **archie.cobbs** on 2014-07-16 at 06:28 PM_
---
This issue is a suggestion for some new classes, based on my own experience. Working example code is provided.
Request #1:
&nbsp;&nbsp;Add support superclasses AbstractNavigableSet and AbstractNavigableMap
Rationale:
Creating NavigableSet and NavigableMap implementations from scratch is really tricky and error-prone, due to the sheer number of methods to implement and their semantic intersection with order reversal, optional lower & upper bounds, subSet(), subMap(), etc.
Fortunately, abstract superclasses can implement most methods in terms of others, and manage the bounds in such a way that leaves the subclass to handle the "essence" of the set/map.
FWIW I've done this already and these classes could be used as an basis to start with. See https://code.google.com/p/jsimpledb/source/browse/#svn%2Ftrunk%2Fsrc%2Fjava%2Forg%2Fjsimpledb%2Futil
Request #2:
&nbsp;&nbsp;Add a NavigableSet-specific implementation of Sets.intersection()
Rationale:
&nbsp;&nbsp;Sets.intersection() suffers from the flaw that even if the intersection of two sets is empty, iterating their intersection takes time proportional to the size of first of the two sets given, no matter how small the second set is. Since often you won't know which set is smaller, this means you have a 50% chance of getting it badly wrong.
&nbsp;&nbsp;For two NavigableSets that use the same Comparator, there is a more efficient algorithm that iterates in O(N) queries, where N is the number of elements in the _smallest_ of the two sets - no matter in which order they are presented.
&nbsp;&nbsp;In common scenarios such as iterating through key/value ranges in large datasets, this can make a huge difference.
I also have an implementation for this intersection iteration algorithm here: https://code.google.com/p/jsimpledb/source/browse/trunk/src/java/org/jsimpledb/util/IntersectionNavigableSet.java
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1803#c1) posted by **lowasser@google.com** on 2014-07-16 at 06:41 PM_
---
Please file these as separate requests.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1803#c2) posted by **archie.cobbs** on 2014-07-16 at 06:48 PM_
---
"Add a NavigableSet-specific implementation of Sets.intersection()" filed as issue #1804.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1799) created by **jens.ran...@tink.se** on 2014-07-09 at 08:50 AM_
---
I have a use case where I am transforming an `Optional`, transforming it into the value of a member variable. The issue: The member variable can be null so I'd like to convert it to an Optional if it exists.
Proposal:
class Optional&lt;T> ... {
&nbsp;&nbsp;&nbsp;&nbsp;...
```
public Optional<F> Optional#transformToOptional(Function<T, F> transformer) {
try {
return this.transform(transformer);
return Optional.<F>.absent()
}
}
```
}
(which reservations to typos and probably not catching NullPointerException in real implementation, instead checking for null)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1799#c1) posted by **tomas.zalusky** on 2014-07-09 at 09:17 AM_
---
I've reported similar issue in October 2012 and cannot wait for resolution, see https://github.com/google/guava/issues/1171 (the cause of NPE can be arbitrary so I feel weird of globally catching NPE, instead I suggested transforming null result to Optional which eventually showed to be consistent with JDK8).
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1791) created by **jroesler** on 2014-06-25 at 02:02 PM_
---
Once a RateLimiter is configured with permitsPerSecond == Double.POSITIVE_INFINITY, it can never deliver a non-infinite rate. Tested on Guava 17.0.
Test case:
public static void main(String[] args) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RateLimiter rateLimiter = RateLimiter.create(Double.POSITIVE_INFINITY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final double permitsPerSecond = 1.0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rateLimiter.setRate(permitsPerSecond);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final long l = System.currentTimeMillis();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final int totalPermits = 60;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final int permitsEachTime = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i < totalPermits; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rateLimiter.acquire(permitsEachTime);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(i + ",");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final double seconds = 1.0 \* (System.currentTimeMillis() - l) / 1000;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(seconds);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println((totalPermits / permitsPerSecond));
&nbsp;&nbsp;&nbsp;&nbsp;}
The behavior should be that it prints out the numbers about once a second and then prints the two "seconds" metrics roughly in agreement, like
0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,
59.0
60.0
When the rate limiter is initialized with a non-infinite value (like 10.0), we see the desired behavior.
What the code above actually produces is:
0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,
0.002
60.0
showing that the limiter is still issuing permits at an infinite rate.
in com.google.common.util.concurrent.RateLimiter.Bursty#doSetRate
&nbsp;&nbsp;&nbsp;&nbsp;storedPermits = (oldMaxPermits == 0.0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;? 0.0 // initial state
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: storedPermits \* maxPermits / oldMaxPermits;
once the rate has been set to infinity, we also have an infinite number of stored permits, as well as an infinite number of oldMaxPermits. This division yields NaN, which then goes on to ensure that com.google.common.util.concurrent.RateLimiter#reserveNextTicket will return 0 micros to wait.
It seems you may want to look at the whole rateLimiter with infinity in mind. Infinity is a reasonable value to configure a rate limiter with, so I think you should continue to accept it, but there may be other places where the math requires special handling of Infinity.
Let me know if I can help.
Thanks,
-John
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1791#c1) posted by **cpovirk@google.com** on 2014-06-25 at 02:09 PM_
---
Interesting. The test method testInfinity_Bursty() is supposed to check this, but it must miss some case that your test catches. I'll look into it.
---
**Status:** `Accepted`
**Owner:** cpovirk@google.com
**Labels:** `Type-Defect`, `Package-Concurrent`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1791#c2) posted by **cpovirk@google.com** on 2014-06-25 at 02:19 PM_
---
It looks like the test doesn't catch this because no time elapses between the creation and the changing of the rate. As soon as I tell the fake stopwatch that time has elapsed, things go haywire.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1791#c3) posted by **cpovirk@google.com** on 2014-06-25 at 03:08 PM_
---
For a fix, I think we can get by with the same test as SmoothWarmingUp.doSetRate has. I don't have 100% confidence in that -- in particular, I can imagine that it's possible for maxPermits or another computed value to overflow to POSITIVE_INFINITY in another way -- but based on the facts that (a) SmoothWarmingUp is set up for this and (b) we had tests for this, I suspect that we'd given at least a passing thought to infinite-rate RateLimiters before.
Thanks for the report. I'll post again when the fix is submitted.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1788) created by **bardur.arantsson** on 2014-06-22 at 10:00 AM_
---
I'd like to suggest making the
&nbsp;&nbsp;ByteStreams.toByteArray(InputStream in, int expectedSize)
method "public" rather than having package visibility. I'm aware that limit() and the single-argument toByteArray() methods could be combined to achieve a similar effect, but that would incur an extra array copy since toByteArray(InputStream in) uses ByteArrayOutputStream's toByteArray() method.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1788#c1) posted by **cgdecker@google.com** on 2014-06-23 at 04:21 PM_
---
Out of curiosity, what are you interested in using this method for? It's primarily designed around the use case of files, where the actual number of bytes in the stream could differ from what you get when you check the length of the file beforehand (but in most cases won't). It handles the stream having both more and fewer bytes than the expected size gracefully... for other use cases, it's possible that's not the best behavior.
Note that using limit() with toByteArray() does not have the same result: if there are more than the expected number of bytes in the stream when using limit, it will read at most the expected number of bytes, where this method will read all bytes regardless.
---
**Labels:** `Type-Addition`, `Package-IO`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1788#c2) posted by **bardur.arantsson** on 2014-06-23 at 04:57 PM_
---
Dang it, you're right -- I misread the code. However, I could still use it in combination with ByteStreams.limit -- that would get me the behavior I would like, i.e. avoiding the extra copy of ByteStreams.toArray(InputStream). That would probably be too contrived as an API, though.
Thinking a bit more about it, I think I'll probably be better off just using a customized ByteArrayOutputStream (to gain access to its internal buffer) and using ByteStreams.copy().
Feel free to close this.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1783) created by **abecc...@mantano.com** on 2014-06-16 at 02:48 PM_
---
Reproduce: System.out.println(LOWER_CAMEL.to(UPPER_UNDERSCORE, "ISBN"));
Result: I_S_B_N
Desired Output: ISBN
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1783#c1) posted by **cgdecker@google.com** on 2014-06-16 at 03:42 PM_
---
FYI, in upper camel case (at least using the style we recommend for Java--obviously there are other views on this), an acronym like ISBN should be written "Isbn", in which case you get "ISBN" as desired. In lower camel case, it'd just be "isbn".
Whether or not we want to change the behavior is a different story, though my inclination is somewhat against it unless we're sure it's harmless to existing usages.
---
**Labels:** `Package-Base`, `Type-Enhancement`
---
I know It should be the case but even java api is not consistent with acronyms in camel case (ex: URL,HttpHeaders,..).
:)
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1782) created by **rattigan** on 2014-06-14 at 09:26 PM_
---
It would be nice to have an option to allow null values in ImmutableMaps. There are perfectly legitimate use cases for maps with null values, e.g. representing the properties and values of a bean, some of which may be null-valued.
Most implementations of Map allow null values, and this restriction unnecessarily limits the places where ImmutableMap can be used to replace existing small mutable maps, and for no good reason that I can see. Ambiguity is not an issue, since there containsKey can resolve the question of whether a null value was inserted or not. In cases where map entries are iterated there is no ambiguity.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1782#c1) posted by **wasserman.louis** on 2014-06-14 at 09:30 PM_
---
What's wrong with the workaround of using Collections.unmodifiableMap on a mutable map?
Large amounts of code already assume that anything Immutable\* can't have null values.  (Additionally, you'd have to extend this to every immutable collection type, not just Map.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1782#c2) posted by **kak@google.com** on 2014-06-15 at 10:46 PM_
---
https://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained
You could also store an Optional&lt;V> as your value.
---
**Status:** `WontFix`
@orbfish, you don't need to create a whole new wrapper library.  You can either create a special Null object (if you control the type you're storing) or you can use Optional, as @kak suggested.  The latter would cause you to explicitly handle null objects in your code, which seems like a good thing. I don't understand why you think that you would need to.  What problem are you trying to solve? Why can't you use Optional as your Map value type?  Do you not control the place where values are read out of the Map? I'd tend to just fall back to LinkedHashMap for this scenario; I'm not sure what advantages an explicit builder provide for this scenario when you can just build into a real Map (and wrap it with unmodifiableMap at the end if you care). Can you post the code with and without a builder?  I'm not seeing what makes it more readable. Are you initializing this as a constant, or is this something you're extracting out of a database?  In the second case your code is going to have to be approximately the same anyway. Hello.
An important clarification: it isn't merely that these collections "don't support `null`"; they *promise* to never contain `null`. The world now contains a very large amount of code that is happily benefiting from that promise. As just one example, you never have to check both `containsKey` *and* `get`. The latter suffices. For another example, a public method receiving a collection doesn't have to loop through it to check for unwanted `null`s -- it just makes an immutable copy and gets on with life. There are many conveniences like this.
It has been, for a very long time, completely impractical to renege on this promise.
(We also still think it was the right decision.) As I've explained, there is no freedom to "change our minds" on a behavior that an enormous number of thousands of classes depend on. It sounds like you want to have a debate about something that this isn't the right forum for. In general, the traditional workaround involves making a copy so nobody else has a reference to the underlying map and nobody *can* modify it. @orbfish No worries, but thanks for the response.
To reiterate something that a couple of other folks (e.g. @swankjesse) had suggested above, if you have a special null object (or other representation of null, e.g., Optional.empty()) then you just need to convert on read and on write.  This might mean a less elegant way of doing reads and writes, though (i.e., iterating through the map rather than using a single built-in method call). I'd like to remind everyone that this issue is closed. As pointed out April 26 and 27, this behavior cannot be changed, not even optionally. A huge number of programs now *depend* on knowing that immutable collections will never contain null. With that in mind, it would be best if we could take these discussions elsewhere and let this issue die in peace. Thanks!  _[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1778) created by **heuermh** on 2014-06-06 at 04:58 PM_
---
Neither RangeMap nor RangeSet meet my use case, which is finding all ranges that overlap with a given range or endpoint.
I have an interface
interface RangeTree&lt;C extends Comparable>
{
&nbsp;&nbsp;int size();
&nbsp;&nbsp;boolean isEmpty();
&nbsp;&nbsp;boolean contains(C location);
&nbsp;&nbsp;int count(C location);
&nbsp;&nbsp;Iterable&lt;Range&lt;C>> query(C location);
&nbsp;&nbsp;int count(Range&lt;C> query);
&nbsp;&nbsp;Iterable&lt;Range&lt;C>> intersect(Range&lt;C> query);
&nbsp;&nbsp;boolean intersects(Range&lt;C> query);
&nbsp;&nbsp;Iterable&lt;Set&lt;Range&lt;C>>> intersect(Iterable&lt;Range&lt;C>> query);
&nbsp;&nbsp;boolean intersects(Iterable&lt;Range&lt;C>> query);
}
and a naive implementation based on a centered interval tree
http://en.wikipedia.org/wiki/Interval_tree#Centered_interval_tree
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1778#c1) posted by **lowasser@google.com** on 2014-08-06 at 05:45 PM_
---
This proposal makes sense, but I'd tend to wait to hear more demand before adding another data structure to Guava to maintain on the same order of complexity as RangeSet and RangeMap?  Those two data structures had existing, more awkwardly designed versions within Google with significant enough usage to convince us to take on the project, but I'd like a better sense of the demand for RangeTree before pursuing it in earnest.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1778#c2) posted by **heuermh** on 2014-08-08 at 07:40 PM_
---
Thanks for the comment.
This use case is common in the field of bioinformatics, and as such one can find many different implementations of the same thing, e.g.
https://github.com/samtools/htsjdk/blob/master/src/java/htsjdk/samtools/util/IntervalTree.java
https://github.com/pcingola/SnpEff/blob/master/src/main/java/ca/mcgill/mcb/pcingola/interval/tree/IntervalTree.java
https://github.com/lowasser/intervaltree/blob/master/src/main/java/edu/uchicago/lowasser/intervaltree/IntervalTree.java
...
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1778#c4) posted by **heuermh** on 2014-09-24 at 09:38 PM_
---
The code referred to above has been open sourced under the LPGL version 3 or later license.
https://github.com/nmdp-bioinformatics/ngs/tree/master/range/src/main/java/org/nmdp/ngs/range/tree
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1778#c5) posted by **tomas.zalusky** on 2014-09-25 at 06:46 AM_
---
> hear more demand
> I am working on projects whose part is graphic visualization of rectangular shapes in 2D. In horizont of months, I will need to efficiently detect overlapping shapes. I supposed to use some IntervalTree implementation, however if RangeTree were part of Guava, it would be certainly practical to build my solution upon RangeTree.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1775) created by **matt.nathan** on 2014-06-03 at 12:44 PM_
---
I've frequently come across situations in my unit tests where I'd like to know if a particular method is triggering the loading of a particular file, ideally without actually loading that file.
public class LoadsSomething {
&nbsp;&nbsp;@VisibleForTesting
&nbsp;&nbsp;static class LoadStrategy {
&nbsp;&nbsp;&nbsp;&nbsp;SomeObject load(ByteSource source) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return BackendLoadingApi.loadFromBytes(source.read());
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;}
&nbsp;&nbsp;private final LoadStrategy loadStrategy;
&nbsp;&nbsp;LoadsSomething(LoadStrategy loadStrategy) {
&nbsp;&nbsp;&nbsp;&nbsp;this.loadStrategy = checkNotNull(loadStrategy);
&nbsp;&nbsp;}
&nbsp;&nbsp;SomeObject loadObjectA() {
&nbsp;&nbsp;&nbsp;&nbsp;ByteSource data = Resources.asByteSource(Resources.getResource("/a.data"));
&nbsp;&nbsp;&nbsp;&nbsp;return loadStrategy.load(data);
&nbsp;&nbsp;}
}
though trying to write a unit test for the following class would also be hit by this issue:
public class ResourceIndex {
&nbsp;&nbsp;public ByteSource defaultProperties() {
&nbsp;&nbsp;&nbsp;&nbsp;return Files.asByteSource(new File(".config"));
&nbsp;&nbsp;}
}
In my unit test I pass a mock LoadStrategy and inspect/capture the argument passed to the load method which gives me the ByteSource that was intended to be loaded. What I then want to do is assert that the resource that was going to be loaded is the correct one.
The only way I've found to do this so far is to check the toString of the ByteSource, which is very flakey:
assertTrue(byteSource.toString().contains("/a.data"));
I'd like an official way to check that the ByteSource instance will load data from the correct place without actually loading the data. I can think of a few options:
1. Implement equals on ByteSource implementations that make sense, UrlByteSource, FileByteSource, EmptyByteSource, etc.
2. Define (via the api contract) that the toString contains the information needed to verify the source.
3. Make the ByteSource subclasses public (or introduce new interfaces) so that they can contain public methods per type to return the internal state for comparison (i.e. add a url() method to UrlByteSource)
4. I just accept that my unit tests will need to read the file contents :(
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1775#c1) posted by **kak@google.com** on 2014-06-03 at 03:56 PM_
---
_(No comment entered for this change.)_
---
**Owner:** cgdecker@google.com
**Labels:** `Type-Addition`, `Package-IO`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1774) created by **itt...@wix.com** on 2014-06-03 at 05:39 AM_
---
I'd like to be able to use rateLimiter and so I need to be able to test it.
I see you have a factory method which accepts a ticker but that is internal only; Such a method would help me.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1774#c1) posted by **kak@google.com** on 2014-06-03 at 03:57 PM_
---
_(No comment entered for this change.)_
---
**Owner:** cpovirk@google.com
**Labels:** `Package-Concurrent`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1774#c2) posted by **stephan202** on 2014-06-06 at 08:11 AM_
---
We're not supposed to answer with "+1", but I'll do it anyway: +1. Had exactly the same observation and request.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1774#c3) posted by **irvingdave1** on 2014-09-05 at 01:04 PM_
---
This would be useful for me too.
I have a simulator where there can be no coupling to 'real time' - as the code's notion of current time moving forward is driven by external events.
I have a use for a good rate limiter, but would also be able to control it's underlying ticker.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1769) created by **sim.herter** on 2014-06-01 at 03:03 PM_
---
Hi,
it would be wonderful if I could use the new lambda expressions in the register method of EventBus like so:
eventBus.register((String s) -> System.out.println(s));
I use EventBus currently with a slightly modified command pattern, where I pass paramters to the execute() method. Registering would be much easier:
eventBus.register((Command c) -> c.execute("Hi!"));
eventBus.register((Command c) -> c.execute("Bye!"));
Instead of using anonymous classes:
commandBus.register(new Consumer&lt;Command>() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Subscribe
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void accept(Command c) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.execute("Hi!");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});
commandBus.register(new Consumer&lt;Command>() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Subscribe
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void accept(Command c) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.execute("Bye!");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});
What do you think?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1769#c1) posted by **kak@google.com** on 2014-06-03 at 03:57 PM_
---
_(No comment entered for this change.)_
---
**Owner:** cgdecker@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1769#c2) posted by **cpovirk@google.com** on 2014-06-05 at 07:37 PM_
---
_Issue #1776 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1769#c3) posted by **cpovirk@google.com** on 2014-06-05 at 07:38 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Duplicate`
**Merged Into:** #1549
---
Similar to the assertJ library (for checking post conditions of test runs), I would suggest some additional methods for the Preconditions class to make checking arguments easier.
http://joel-costigliola.github.io/assertj/assertj-core-features-highlight.html
So instead of
StringAssert assertThat(String value) throws AssertionException
StringCheck checkThat(String value) throws IllegalArgumentException, NullPointerException
is defined.
AssertJ defines assertions for basic data types and collections. Each assert type defines different method chains are possible.
Example:
StringCheck checkThat(String value)
checkThat(aString).isNotEmpty().containsIgnoringCase("")...;
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1762#c1) posted by **Wolfram.Nickl** on 2014-05-23 at 07:40 AM_
---
Vote! this would really be a nice feature to get the code more readable.
Eg.
public void bla(List&lt;Blub> list) {
&nbsp;checkThat(list).describedAs("list has to be not null and not empty").isNotNull().isNotEmpty();
}
instead of:
public void bla(List&lt;Blub> list) {
&nbsp;checkNotNull(list, "list null");
&nbsp;checkArgument(!list.isEmpty(), "list empty");
}
This feature would really be appreciated!
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1762#c2) posted by **lowasser@google.com** on 2014-05-23 at 07:45 AM_
---
The Truth library (https://github.com/truth0/truth), which shares some of Guava's developers, might be able to support this as a test verb option, almost without modification.
Off the top of my head, though, I am concerned that the performance cost of a fluent API like this would be unacceptable for most applications of preconditions.  checkThat(list).describedAs("list has to be not null and not empty").isNotNull().isNotEmpty() essentially _must_ allocate four objects, and preconditions are generally expected to be cheap.  (To be fair, Guava's Preconditions incurs varargs overhead, but this is at most one object.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1762#c3) posted by **Wolfram.Nickl** on 2014-05-23 at 09:02 AM_
---
Ok, thanks for the comment. I understand that performance is relevant.
I personally like e.g. assertJ but performance in unit tests is not as critical as at product code.
thanks anyway.
---
Thank you all for your feedback! I will definetly take a look at the Truth library.
I understand that performance is critical. Wouldn't it also work with just one simple object which is reused for all checks ("return this")? The only property which has to be hold as a state is the describedAs text as far as I can see that. Ignoring that, a StringCheck does not keep any state...
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1762#c5) posted by **lowasser@google.com** on 2014-05-26 at 09:48 AM_
---
At least two objects, then: the reference to the string itself, and the description text.  But more complex conditions on Iterables will probably need more objects to be useful.
---
Running com.google.common.testing.anotherpackage.ForwardingWrapperTesterTest
Tests run: 19, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.165 sec
Running com.google.common.testing.ArbitraryInstancesTest
May 16, 2014 10:47:09 AM com.google.common.testing.ArbitraryInstances get
WARNING: Exception while invoking default constructor.
java.lang.RuntimeException
&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.testing.ArbitraryInstancesTest$WithExceptionalConstructor.&lt;init>(ArbitraryInstancesTest.java:429)
&nbsp;&nbsp;&nbsp;&nbsp;at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
&nbsp;&nbsp;&nbsp;&nbsp;at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
&nbsp;&nbsp;&nbsp;&nbsp;at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
&nbsp;&nbsp;&nbsp;&nbsp;at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.testing.ArbitraryInstances.get(ArbitraryInstances.java:359)
&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.testing.ArbitraryInstancesTest.testGet_class(ArbitraryInstancesTest.java:293)
&nbsp;&nbsp;&nbsp;&nbsp;at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
&nbsp;&nbsp;&nbsp;&nbsp;at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
&nbsp;&nbsp;&nbsp;&nbsp;at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
&nbsp;&nbsp;&nbsp;&nbsp;at java.lang.reflect.Method.invoke(Method.java:597)
&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestCase.runTest(TestCase.java:168)
&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestCase.runBare(TestCase.java:134)
&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestResult$1.protect(TestResult.java:110)
&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestResult.runProtected(TestResult.java:128)
&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestResult.run(TestResult.java:113)
&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestCase.run(TestCase.java:124)
&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.runTest(TestSuite.java:243)
&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.run(TestSuite.java:238)
&nbsp;&nbsp;&nbsp;&nbsp;at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:83)
&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:35)
&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:115)
&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:97)
&nbsp;&nbsp;&nbsp;&nbsp;at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
&nbsp;&nbsp;&nbsp;&nbsp;at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
&nbsp;&nbsp;&nbsp;&nbsp;at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
&nbsp;&nbsp;&nbsp;&nbsp;at java.lang.reflect.Method.invoke(Method.java:597)
&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.maven.surefire.booter.ProviderFactory$ClassLoaderProxy.invoke(ProviderFactory.java:103)
&nbsp;&nbsp;&nbsp;&nbsp;at com.sun.proxy.$Proxy0.invoke(Unknown Source)
&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.maven.surefire.booter.SurefireStarter.invokeProvider(SurefireStarter.java:150)
&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.maven.surefire.booter.SurefireStarter.runSuitesInProcess(SurefireStarter.java:91)
&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:69)
Tests run: 25, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.03 sec
Running com.google.common.testing.ClassSanityTesterTest
Tests run: 71, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.069 sec
Running com.google.common.testing.EqualsTesterTest
Tests run: 18, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.006 sec
Running com.google.common.testing.EquivalenceTesterTest
Tests run: 7, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.007 sec
Running com.google.common.testing.FakeTickerTest
Tests run: 10, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.028 sec
Running com.google.common.testing.FreshValueGeneratorTest
Tests run: 60, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.135 sec
Running com.google.common.testing.GcFinalizationTest
Tests run: 10, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.31 sec
Running com.google.common.testing.NullPointerTesterTest
Tests run: 60, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.148 sec
Running com.google.common.testing.RelationshipTesterTest
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.001 sec
Running com.google.common.testing.SerializableTesterTest
Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.005 sec
Running com.google.common.testing.TearDownStackTest
Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.005 sec
Running com.google.common.testing.TestLogHandlerTest
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.001 sec
Running com.google.common.util.concurrent.testing.TestingExecutorsTest
Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.045 sec
Results :
Failed tests:
&nbsp;&nbsp;testAddAll_unsupportedNonePresent[SafeTreeMap with natural comparator [collection size: zero] keys [collection size: zero] descending [collection size: zero]](com.google.common.collect.testing.testers.CollectionAddAllTester): addAll(nonePresent) should throw
...
veral] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionAddTester): add(notPresent) should throw
&nbsp;&nbsp;testRemoveAll_allPresent[SafeTreeMap with null-friendly comparator [collection size: several] subMap EXCLUSIVE-EXCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionRemoveAllTester): removeAll(intersectingCollection) should return true
&nbsp;&nbsp;testRemoveAll_somePresent[SafeTreeMap with null-friendly comparator [collection size: several] subMap EXCLUSIVE-EXCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionRemoveAllTester): removeAll(intersectingCollection) should return true
&nbsp;&nbsp;testRemoveAll_containsNullYes[SafeTreeMap with null-friendly comparator [collection size: several] subMap EXCLUSIVE-EXCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionRemoveAllTester): removeAll(containsNull) should return true
&nbsp;&nbsp;testRemove_present[SafeTreeMap with null-friendly comparator [collection size: several] subMap EXCLUSIVE-EXCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionRemoveTester): remove(present) should return true
&nbsp;&nbsp;testRemove_nullPresent[SafeTreeMap with null-friendly comparator [collection size: several] subMap EXCLUSIVE-EXCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionRemoveTester): remove(null) should return true
&nbsp;&nbsp;testAddAll_unsupportedNonePresent[SafeTreeMap with null-friendly comparator [collection size: several] subMap EXCLUSIVE-INCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionAddAllTester): addAll(nonePresent) should throw
&nbsp;&nbsp;testAddAll_unsupportedSomePresent[SafeTreeMap with null-friendly comparator [collection size: several] subMap EXCLUSIVE-INCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionAddAllTester): addAll(somePresent) should throw
&nbsp;&nbsp;testAdd_unsupportedNotPresent[SafeTreeMap with null-friendly comparator [collection size: several] subMap EXCLUSIVE-INCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionAddTester): add(notPresent) should throw
&nbsp;&nbsp;testRemoveAll_allPresent[SafeTreeMap with null-friendly comparator [collection size: several] subMap EXCLUSIVE-INCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionRemoveAllTester): removeAll(intersectingCollection) should return true
&nbsp;&nbsp;testRemoveAll_somePresent[SafeTreeMap with null-friendly comparator [collection size: several] subMap EXCLUSIVE-INCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionRemoveAllTester): removeAll(intersectingCollection) should return true
&nbsp;&nbsp;testRemoveAll_containsNullYes[SafeTreeMap with null-friendly comparator [collection size: several] subMap EXCLUSIVE-INCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionRemoveAllTester): removeAll(containsNull) should return true
&nbsp;&nbsp;testRemove_present[SafeTreeMap with null-friendly comparator [collection size: several] subMap EXCLUSIVE-INCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionRemoveTester): remove(present) should return true
&nbsp;&nbsp;testRemove_nullPresent[SafeTreeMap with null-friendly comparator [collection size: several] subMap EXCLUSIVE-INCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionRemoveTester): remove(null) should return true
&nbsp;&nbsp;testAddAll_unsupportedNonePresent[SafeTreeMap with null-friendly comparator [collection size: several] subMap INCLUSIVE-INCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionAddAllTester): addAll(nonePresent) should throw
&nbsp;&nbsp;testAddAll_unsupportedSomePresent[SafeTreeMap with null-friendly comparator [collection size: several] subMap INCLUSIVE-INCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionAddAllTester): addAll(somePresent) should throw
&nbsp;&nbsp;testAdd_unsupportedNotPresent[SafeTreeMap with null-friendly comparator [collection size: several] subMap INCLUSIVE-INCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionAddTester): add(notPresent) should throw
&nbsp;&nbsp;testRemoveAll_allPresent[SafeTreeMap with null-friendly comparator [collection size: several] subMap INCLUSIVE-INCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionRemoveAllTester): removeAll(intersectingCollection) should return true
&nbsp;&nbsp;testRemoveAll_somePresent[SafeTreeMap with null-friendly comparator [collection size: several] subMap INCLUSIVE-INCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionRemoveAllTester): removeAll(intersectingCollection) should return true
&nbsp;&nbsp;testRemoveAll_containsNullYes[SafeTreeMap with null-friendly comparator [collection size: several] subMap INCLUSIVE-INCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionRemoveAllTester): removeAll(containsNull) should return true
&nbsp;&nbsp;testRemove_present[SafeTreeMap with null-friendly comparator [collection size: several] subMap INCLUSIVE-INCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionRemoveTester): remove(present) should return true
&nbsp;&nbsp;testRemove_nullPresent[SafeTreeMap with null-friendly comparator [collection size: several] subMap INCLUSIVE-INCLUSIVE [collection size: several] keys [collection size: several] descending [collection size: several]](com.google.common.collect.testing.testers.CollectionRemoveTester): remove(null) should return true
&nbsp;&nbsp;com.google.common.collect.testing.SafeTreeMapTest: Java heap space
Tests run: 60963, Failures: 612, Errors: 1, Skipped: 0
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO]
[INFO] Guava: Google Core Libraries for Java ............. SUCCESS [ 12.746 s]
[INFO] Guava Testing Library ............................. FAILURE [03:39 min]
[INFO] Guava GWT compatible libs ......................... SKIPPED
[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 03:52 min
[INFO] Finished at: 2014-05-16T10:47:09-08:00
[INFO] Final Memory: 18M/265M
[INFO] ------------------------------------------------------------------------
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.7.2:test (default-test) on project guava-testlib: There are test failures.
[ERROR]
[ERROR] Please refer to /Users/bpan/git/guava-libraries/guava-testlib/target/surefire-reports for the individual test results.
[ERROR] -> [Help 1]
[ERROR]
[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.
[ERROR] Re-run Maven using the -X switch to enable full debug logging.
[ERROR]
[ERROR] For more information about the errors and possible solutions, please read the following articles:
[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException
[ERROR]
[ERROR] After correcting the problems, you can resume the build with the command
[ERROR]   mvn &lt;goals> -rf :guava-testlib
I found changing MAVEN_OPTS="-Xms256m -Xmx5512m" to adjust java heap size does not work.
Does anybody know a way to resolve this issue?
Thank you.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1757#c1) posted by **lowasser@google.com** on 2014-05-16 at 05:58 PM_
---
What version of Java are you using?
---
jdk1.7.0_51.jdk on mac.
---
actually, the java i used inside mvn is this (not jdk1.7)
Apache Maven 3.2.1 (ea8b2b07643dbb1b84b6d16e1f08391b666bc1e9; 2014-02-14T09:37:52-08:00)
Maven home: /usr/local/apache-maven/apache-maven-3.2.1
Java version: 1.6.0_65, vendor: Apple Inc.
Java home: /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home
Default locale: en_US, platform encoding: MacRoman
OS name: "mac os x", version: "10.9.3", arch: "x86_64", family: "mac"
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1755) created by **fgaliegue** on 2014-05-15 at 12:49 PM_
---
I am going to use EventBus for this project:
so that matches are delivered as events to subscribers which can then handle it.
However, it requires that said subscribers be annotated with @Subscribe and, if needed, @AllowConcurrentEvents. Which means you need to write them.
What I'd like to be able to do is what Jackson does, for instance, with its modules: even if a class you want to {de,}serialize has no Jackson annotations (@JsonProperty, @JsonTypeInfo and whatnot), a module allow you to define a mixin class which can then be used as a "{de,}serialization aid". A simple example:
public abstract class RectangleMixin
{
&nbsp;&nbsp;&nbsp;&nbsp;@JsonProperty("height")
&nbsp;&nbsp;&nbsp;&nbsp;// in Rectangle, it's called..
&nbsp;&nbsp;&nbsp;&nbsp;int h;
&nbsp;&nbsp;&nbsp;&nbsp;@JsonProperty("width")
&nbsp;&nbsp;&nbsp;&nbsp;// in Rectangle, it's called..
&nbsp;&nbsp;&nbsp;&nbsp;int w;
}
You can then .setMixinAnnotations(Rectangle.class, RectangleMixin.class).
I'd like to be able to do the same with EventBus... Either using a mixin class as above or maybe a pure programmatic API, such as, for instance:
final EventBusMixin mixin = EventBusMixin.forClass(MyClass.class);
// simple case
mixin.methodByName("theName").isSubscriber();
// with concurrent delivery
mixin.methodByName("otherName").isConcurrentSubscriber();
Comments?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1755#c1) posted by **kak@google.com** on 2014-06-03 at 04:00 PM_
---
_(No comment entered for this change.)_
---
**Owner:** cgdecker@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1755#c2) posted by **cgdecker@google.com** on 2014-06-26 at 11:14 PM_
---
Could you do something like:
&nbsp;&nbsp;public class FooSubscribingWrapper {
&nbsp;&nbsp;&nbsp;&nbsp;private final Foo foo; // some class you don't control
&nbsp;&nbsp;&nbsp;&nbsp;public FooSubscribingWrapper(Foo foo) { ... }
```
@Subscribe public void someMethod(SomeEvent event) {
foo.someMethod(event);
}
@Subscribe public void someOtherMethod(SomeOtherEvent event) {
}
```
&nbsp;&nbsp;}
&nbsp;&nbsp;bus.register(new FooSubscribingWrapper(foo));
This is very similar to the mixin strategy you describe except that it requires the "mixin" to be applied at the registration site and works with EventBus as-is. Not that it's exciting to have to do this. I'm reluctant to allow ways of registering subscribers that don't involve the @Subscribe annotation, because I think it's core to this EventBus library and that if anything we're likely to want to do more with annotations on subscriber methods than less in the future.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1755#c3) posted by **fgaliegue** on 2014-10-15 at 04:33 PM_
---
> I'm reluctant to allow ways of registering subscribers that don't involve the @Subscribe annotation, because I think it's core to this EventBus library and that if anything we're likely to want to do more with annotations on subscriber methods than less in the future.
Well, it looks like you and I have two different approaches of the same problem, that is, plug legacy code into EventBus.
The approach I recommend here is to extend the EventBus "build API"; you recommend wrapper classes. Both approaches have their pros and cons. The main con I can see against my approach is the need to use reflection; the main con I see against your approach is the need to create a wrapper class.
Notwithstanding the amount of code written, I still believe my approach to be better; it can also be extended to new annotations.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1752) created by **cpovirk@google.com** on 2014-05-13 at 12:04 AM_
---
Hmm, it looks like we never released it because it depends on another Google open-source project that hasn't been set up for Maven. I've filed #2387 to figure out what to do there. Thanks for pointing this out.
The test is now released. Note that:
- It is, as noted above, "a mess" :)
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1749) created by **rudi.mail90** on 2014-05-10 at 07:07 AM_
---
When creating EventBus, we can pass "identifier" that will be used by LoggingSubscriberExceptionHandler.
However, otherwise identifier is never accessible.
I propose to add:
1. getIdentifier() so it can be used by application for its own logging and diagnostics purposes
2. implement toString() that mention the identifier, and preferably the number of registered subscribers. Some examples:
EventBus demo1234 (5)
AsyncEventBus testABC (12)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1749#c1) posted by **kak@google.com** on 2014-06-03 at 04:01 PM_
---
_(No comment entered for this change.)_
---
**Owner:** cgdecker@google.com
**Labels:** `Type-Addition`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1746) created by **ddlatham** on 2014-05-06 at 11:24 PM_
---
For my use case I want to iterate over all possible combinations of size k from a given Set.  Existing methods that satisfy similar use cases are Collections2.permutations and Sets.powerSet.  I would imagine it would take an input Collection&lt;E> and return a Collection&lt;Set&lt;E>>
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1746#c1) posted by **ddlatham** on 2014-05-06 at 11:26 PM_
---
I suppose if the output is a Set&lt;E> then the input should also be a Set&lt;E> to be clear that there are no duplicates involved.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1746#c2) posted by **kak@google.com** on 2014-06-03 at 06:18 PM_
---
---
**Owner:** lowasser@google.com
**Labels:** `Type-Addition`, `Package-Collect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1746#c3) posted by **ddlatham** on 2014-06-03 at 06:27 PM_
---
Not sure about how using Collections2.permutations would work.
Filtering from Sets.powerSet would be correct but unworkably inefficent.  For example, to iterate over all triples from 100 elements would require filtering 2^100 sets to get the 1 million that I care about.
---
Assuming I didn't forget what a combination is, you want 100_99_98/6 triples. You could use `Sets.cartesianProduct(ImmutableList.of(a, a, a))`&nbsp;to get 1e6 triples and then filter out all triples which aren't strictly isotone.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1746#c5) posted by **ddlatham** on 2014-06-04 at 12:24 AM_
---
I like the suggestion of filtering results of doing a cartesian product against repeated references of the input set.  That is more efficient than filtering the powerSet, and likely good enough for many cases.  I think it's still wanting for many others, though.  For example, to iterate over combinations of 10 elements out of a set of 20 you'd have to filter through 10^13 candidates whereas a more direct implementation would be closer to 10^5 results.  Another challenge is that it would require an Ordering over elements to determine monotonicity or a more complex method to track unique combinations.
A direct implementation of combinations would seem a natural complement to permutations, powerSet, and cartesianProduct and is not purely derivative.
---
You could simply use Ordering.arbitary(). Another possibility would be to convert the lists to sets and put them all into a set, but this mean to keep them all in memory.
Anyway, the overhead factor of k! for "n choose k" is there.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1745) created by **electrum** on 2014-05-06 at 03:23 PM_
---
I ran into a situation with CacheLoader that doesn't seem to have an easy solution. We use CacheBuilder.refreshAfterWrite() along with an asynchronous reload() method. Inside reload(), we can tell when an object should be invalidated/removed from the cache (for example, the remote object has been deleted). When this happens, we want to invalidate it immediately rather than continuing to return a stale cached value.
The reload() method cannot call Cache.invalidate() because it does not have a reference to the Cache (the LoadingCache is constructed using the CacheLoader).
Maybe the reload() method could throw a special exception that would invalidate the entry?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1745#c1) posted by **kak@google.com** on 2014-06-03 at 06:19 PM_
---
_(No comment entered for this change.)_
---
**Owner:** lowasser@google.com
**Labels:** `Package-Cache`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1745#c2) posted by **electrum** on 2014-06-03 at 06:25 PM_
---
A colleague pointed out an obvious solution: use Optional for the cache value.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1743) created by **electrum** on 2014-05-05 at 07:18 PM_
---
It is occasionally necessary to cast to a subtype when the expected subtype is an invariant. In these cases, we have found the following method to be very helpful:
```
public static <A, B extends A> B checkType(A value, Class<B> target, String name)
{
checkNotNull(value, "%s is null", name);
checkArgument(target.isInstance(value),
"%s must be of type %s, not %s",
name,
target.getName(),
value.getClass().getName());
return target.cast(value);
}
```
This has the following benefits:
1) Adds some type-safety at compile time by only allowing a cast to a subtype.
2) Avoids boilerplate of performing these checks inline.
3) Ensures a helpful message at runtime rather than a ClassCastException.
The method is used like this:
```
Number number = 123L;
...
Long n = checkType(number, Long.class, "number");
```
As a more concrete example, consider a plugin framework with the following interface method:
```
void processTable(TableHandle tableHandle);
```
Without the checkType() method, an implementation looks like this:
```
public void processTable(TableHandle tableHandle) {
checkNotNull(tableHandle, "tableHandle is null");
checkArgument(tableHandle instanceof HiveTableHandle,
tableHandle.getClass().getName());
HiveTableHandle handle = (HiveTableHandle) tableHandle;
...
}
```
With the checkType() method:
```
public void processTable(TableHandle tableHandle) {
HiveTableHandle handle = checkType(tableHandle, HiveTableHandle.class, "tableHandle");
...
}
```
`ClassCastException` error messages are pretty good nowadays...
`java.lang.Integer cannot be cast to java.lang.String`
...so this is mostly about the type safety. It might be interesting to do some static analysis of casts to types that aren't subtypes and see if any common bug patterns emerge. But given that most people are going to use plain casts, I don't think we'd add this to Guava. Projects that are conscientious about casts certainly could have their own helpers.  _[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1740) created by **cgdecker@google.com** on 2014-04-27 at 01:09 AM_
---
Recently I've seen a number of issues with EventBus that derive from the way events that are posted on a thread that is already handling one event are queued rather being dispatched immediately so that only one event is being handled at a time per thread.
One issue was with the fact that eventBus.post(event) returns without that event being posted yet when invoked within an @Subscribe method. But it's actually more subtle than that: it can behave differently even within the same method depending on whether or not the method was called in the context of an event dispatch somewhere down the stack. Of course, we can say that when using EventBus, event handling should be decoupled from event posting in such a way that it doesn't matter exactly when an event you post is handled. But the difference in behavior between when post() is called inside or outside the context of an event dispatch is rather surprising.
Another issue (http://stackoverflow.com/questions/23315689) involved creation of a Swing modal dialog in response to an event (in an @Subscribe method). Since the modal dialog blocks the Swing event queue thread (on which the @Subscribe method was called), event handling for that event can't complete until the dialog closes. And because of that, events posted to the bus in response to actions in the dialog are just queued and not dispatched until the dialog is closed. This behavior is surprising too.
I'm not clear on how much the current strategy buys us, given that it clearly causes people some problems sometimes. I know it's necessary to ensure that all subscribers to an event get notified of it as soon as possible rather than letting one subscriber hog it by dispatching more and more events, but I'm not sure whether that benefit outweighs the problems. Anyway, this issue is for gathering thoughts on this in one place. Such as: AsyncEventBus is nice.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1738) created by **socram8888** on 2014-04-24 at 10:38 AM_
---
Apparently Oracle has added a new abstract method to TypeVariable (getAnnotatedBounds) which is not implemented.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1738#c1) posted by **lowasser@google.com** on 2014-04-24 at 04:41 PM_
---
---
**Labels:** `Type-Dev`, `Package-Reflect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1738#c2) posted by **cpovirk@google.com** on 2014-04-24 at 05:15 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1738#c3) posted by **lowasser@google.com** on 2014-04-24 at 05:17 PM_
---
The internal build is actually addressed, and I know about guava-bootstrap.  I'm mostly saying we'd have to revive it, and I don't remember the nitty-gritty about how we'd do that.
I _think_ providing the bootclasspath would make Guava build on Java 6, 7, _and_ 8, but we don't need to build on 6 internally, so that would need testing too.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1738#c4) posted by **socram8888** on 2014-04-24 at 07:22 PM_
---
In Java 7, AnnotatedElement and TypeVariable are independent, but in Java 8 TypeVariable extends AnnotatedElement.
Couldn't you just implement the said method, and then add change "implements TypeVariable" by "implements TypeVariable, AnnotatedElement"? I don't know if Java would let you do that, however, implementing an interface and an another interface that extends the first.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1738#c5) posted by **lowasser@google.com** on 2014-04-24 at 07:23 PM_
---
That doesn't help.  In Java 8, TypeVariable gets a new method, without a default implementation, returning AnnotatedType, a type that did not exist in Java 7.  There's no way around the bootclasspath approach.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1738#c6) posted by **socram8888** on 2014-04-24 at 08:23 PM_
---
Sorry, I thought the new method was being inherited from the AnnotatedElement class.
Another idea: wouldn't it be possible to just implement the method, without the @Override annotation? In Java 7 and 6, it would be just "ignored", while it would override the new abstract method in the interface.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1738#c7) posted by **lowasser@google.com** on 2014-04-24 at 08:24 PM_
---
It would be possible to implement the method if the return type existed in Java 7, but it doesn't.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1738#c8) posted by **socram8888** on 2014-04-24 at 08:32 PM_
---
You can create just the new method without actually specifiying that it implements anything (ie without the @Override). In Java 7, this would act like any other public method, while in Java 8 it would act like an implementation of the said method in the interface.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1738#c9) posted by **lowasser@google.com** on 2014-04-24 at 08:34 PM_
---
I'm not being clear.  In Java 8, the bare minimum you'd have to write is
```
AnnotatedType[] getAnnotatedBounds() {
return null;
}
```
...with no @Override annotation.  But that _cannot_ compile in Java 7 without adding the AnnotatedType interface to the bootclasspath.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1738#c10) posted by **socram8888** on 2014-04-24 at 08:35 PM_
---
My bad, forgot that Java 7 SE didn't had the AnnotatedType class :/
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1738#c11) posted by **zbys...@in.waw.pl** on 2014-06-14 at 12:04 AM_
---
https://bugzilla.redhat.com/show_bug.cgi?id=1106742
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1738#c12) posted by **lchh555** on 2014-10-10 at 12:27 AM_
---
Has this been fixed?
I still have this problem with Java8 for guava-18.0-SNAPSHOT.
It's likely that we are not going to be able to make Guava compile on JDK8 as long as it supports a JDK < 8.
I presume we are talking about com.google.common.reflect.Types.TypeVariableImpl. Wouldn't it be possible to use a dynamic proxy instead of that class?
Yes, `TypeVariableImpl` is the issue.
@fluentfuture @lowasser Any thoughts? The main thing we probably can't do is add `AnnotatedType` to the bootclasspath for the compilation.
I don't know enough about dynamic proxies to have any sense of whether they would or wouldn't help here =/
If all we want to do for the new `getAnnotatedBounds()` is to throw UnsupportedOperationException or to return null, then dynamic proxy can solve it easily. There is still some ugliness involved with it, because unlike AbstractWrapper, you cannot use an abstract class to get type safety, it would have to be full duck typing.
But regardless of that, it seems that we do need to properly support getAnnotatedBounds(). We need to do the same type resolving as we do for getBounds().
Is this the only compatibility problem in Java 8? I guess if we had two or three, then the cost of hacking up patches would be high enough to be not worth it.
Is it possible, for example, to tack on different source files per JDK version? For example, what if we have a ResolvedTypeVariable.8 file and ResolvedTypeVariable.old file and whatever the build rule can copy one of them as ResolvedTypeVariable.java? Going forward, versioned source file solution would work better for any other similar situations we may run into.
I think it does depend on how many other problems we encounter. As far as I know this is the only one for now, and I don't think it justifies cooking up a special build solution just for it. I believe the only impact of throwing UnsupportedOperationException is that users can't call getAnnotatedBounds() on the TypeVariable implementations we give them from TypeResolved.resolveType. It may be that they can live with that. :-)
In addition to getAnnotatedBounds(), there are other getAnnotated*() methods in Java 8 that could benefit from TypeToken type resolution. For example, method.getAnnotatedParameterTypes(), Class.getAnnotatedSuperclass() etc.
It seems like we are in a dilemma that we either be backward compatible, or add support for JDK 8 features.
Dynamic proxy seems like a short-term solution that gets us compiled (although the TypeVariable impl becomes crippled). Longer term, it seems we just need to drop support for older versions at some point, in order to be able to add more value.
`TypeVariableImpl` is already crippled under JDK 8, right? Currently you'd get `NoSuchMethodError` or something when you call `getAnnotatedBounds()` on it. I also don't know that there's any way to provide any reasonable implementation of it (besides returning `null` or throwing `UOE`) while targeting a JDK <8. Given that, I don't expect whatever we do here to be any more than a band-aid to allow compilation on JDK 8. Whether being able to compile on JDK 8 is worth the effort, I don't know.
It's already crippled under JDK 8 internally. I guess it was done just to unblock the upgrade process. Proper implementation of getAnnotatedBounds() and support for all the other new Annotated\* types can come after we are fully on JDK 8.
It's crippled under JDK 8 externally as well. The `getAnnotatedBounds()` method just doesn't exist if someone who's running under JDK 8 tries to call it. I'm just saying that adding an implementation that throws `UOE` doesn't make it any more crippled than it is now.
Externally, Guava doesn't compile under JDK 8 so that's where my confusion is.
Yep, I'm referring to what happens at runtime on JDK 8, with Guava compiled under JDK 7.
I am very uncomfortable with the idea of shipping a jar that deliberately includes classes that we know can provoke a LinkageError in environments where we expect it to be used. There's a quantitative difference between NoSuchMethodError and UnsupportedOperationException, which is immediately visible since one of them is an Error and the other isn't.
For _us_, there's not much of an advantage. The main question is how many users there are compiling Guava from source and how important it is to them that they be able to use JDK 8 to do that. If all users just used the Guava jar we compile there's no problem. Even if they are compiling from source, is it really major issue that Guava needs JDK 7 to compile? I guess it could be annoying if you're just trying to build Guava in your IDE to experiment with it and your only JDK is JDK 8.
(Do agree with @eamonnmcmanus about UOE vs. NoSuchMethodError though.)
Though it's a result from the user trying to use a jar precompiled under a previous version of JDK. So somehow it feels to me understandable to get a NoSuchMethodError on a new method introduced in JDK 8.
The compiler error is trying to tell us something: you didn't implement this method. So I feel that throwing UOE is just like cheating with the compiler: "Yes, I know I didn't implement it, but please don't say a word."
> Though it's a result from the user trying to use a jar precompiled under a previous version of JDK. So somehow it feels to me understandable to get a NoSuchMethodError on a new method introduced in JDK 8.
In general, there shouldn't be any problem using a class compiled on an older JDK on a newer JDK runtime. Java generally goes to great lengths to ensure backwards compatibility, which is why it could never add new methods to interfaces until the introduction of default methods in JDK 8. It's very strange that they did just go and add a new method to an interface in this case. I'm guessing they did it because:
- They seem to be assuming that no one outside the JDK will implement `TypeVariable`, and possibly other interfaces in `reflect`. As seen when they made another reflect-related change in a JDK7 update release that caused us problems.
- There's no default implementation that could actually work as expected, though really they probably should have just made a default that throws `UOE` themselves, thus saving us all this trouble.
It seems to me that a default implementation of TypeVariable.getAnnotatedBounds() could return an array of AnnotatedType such that getAnnotatedBounds()[i].getAnnotations().length == 0 and getAnnotationBounds()[i].getType() == getBounds()[i]. In other words, pretend that there are no annotations on the bounds even if there are. That seems like an implementation that would work as expected. But it would admittedly be rather verbose since you would want the elements in the array to have the appropriate subtype of AnnotatedType (AnnotatedWildcardType etc).
A sane default, at least for our implementation, is for the returned TypeVariable object from `resolveType(typeVariable)` to delegate for all unimplemented methods, including `getAnnotatedBounds()`.
Something like a ForwardingTypeVariable would do.
For us to deliberately implement it to throw UOE feels to me like we are endorsing this as "feature intended", while actually it's not.
Hmm. Just thinking out loud, it's possible to create ForwardingTypeVariable through dynamic proxy. So that would seem to be a better alternative?
Could you go into a bit more detail about what you have in mind?
Today, we implement `resolveType(typeVariable)` like this:
```
Type resolveType(TypeVariable var) {
var.getName(), var.getDeclaration(), resolveTypes(var.getBounds());
}
```
Now that the annotated bounds come into play, the above code cannot be 2-way compatible. But if it were implemented using ForwardingTypeVariable:
```
Type resolveType(TypeVariable var) {
final Type[] resolvedBounds = resolveTypes(var.getBounds());
return new ForwardingTypeVariable(var) {
Type[] getBounds() { return resolvedBounds; }
};
}
```
That way, we reduce the problem to creating a 2-way compatible ForwardingTypeVariable.
Of course it's still impossible at source level. But it's possible to use a slight variant of your dynamic proxy to implement ForwardingTypeVariable.
I see. So instead of throwing UOE from getAnnotatedBounds(), we would return the result of getAnnotatedBounds() on the original, unresolved TypeVariable. That could be inconsistent with getBounds(), since normally tv.getAnnotatedBounds()[i].getType().equals(tv.getBounds()[i]), but if any bound has been changed by resolution that won't hold. I'm not sure it is better to return an inconsistent result than to throw an exception, though I could probably be persuaded of it here.
There are other members of the getAnnotated*() family introduced in Java 8 that we by default don't do anything. Class.getAnnotatedSuperclass(), Class.getAnnotatedInterfaces(), Method.getAnnotatedReturnType() etc.
I agree that it's less weird because users don't get to access them from Guava API so in a sense it's understandable that we don't cover them.
Still, I feel delegation is more right than just throwing. You call resolveType() to get a better type, not to get a crippled one that could be waiting to break your application.
This also addresses any future interface changes. Chances are, the new addition doesn't necessarily need type resolving so delegation is a safer default to me.
There is also a possibility that we could use duck typing all the way through to implement getAnnotatedBounds() properly. I know we cannot statically reference AnnotatedType interface, but we could do deep dynamic proxy:
```
return as(TypeVariable.class, new ForwardingHandler(var) {
public Type[] getBounds() {
return resolveTypes((Type[]) proceed());
}
// return values and parameters annotated by this will be automatically converted by as()
// from/to the right type at runtime.
@DuckTyped
return resolvedAnnotatedTypes(
}
});
...
}
```
At some point, we'll need to say that Guava supports Java 8 features and it's no longer backward compatible, for big things like stream, default methods, lambda, or small things like supporting `AnnotatedType` properly.
If that time is near, I'm in favor of leaving pre-JDK8 Guava alone and spend the time figuring out what common.reflect looks like in Java 8.
The compilation issue should be fixed now. I'm seeing a test failure, though, which I've reported separately in #1926.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1737) created by **daniel.norberg** on 2014-04-24 at 03:45 AM_
---
ImmutableList.Builder does not need to make copies of the contents array when building, as it is append-only and multiple ImmutableList instances can safely share the same backing contents array.
I propose making ImmutableList.Builder use the backing contents array as-is when creating RegularImmutableList instances. This helps reduce garbage generation in applications making heavy use of ImmutableList and eliminates most of the garbage penalty of using ImmutableList.Builder over the ImmutableList.of() factory methods.
See the attached patch or below link to commit on github.
https://github.com/danielnorberg/guava-libraries/commit/64b18b01747b9e36af73625c6d87c44bb2e5c6a8
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1737#c1) posted by **wasserman.louis** on 2014-04-24 at 04:00 AM_
---
This can't really be done without causing memory leaks.  For example, if you write
ImmutableList.Builder&lt;Object> builder = ImmutableList.builder();
builder.add(a);
ImmutableList&lt;Object> list1 = builder.build();
builder.add(b);
ImmutableList&lt;Object> list2 = builder.build();
...but now list1 might hold a reference to b, even if list2 is garbage collected.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1737#c2) posted by **daniel.norberg** on 2014-04-24 at 04:11 AM_
---
Good point.
So how about instead deferring the copying until the next builder mutation? This would avoid copies in the cases where a builder is only used to create a single list, which I think is likely to most common case.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1737#c3) posted by **daniel.norberg** on 2014-04-24 at 04:20 AM_
---
Attached a new patch and pushed a new change to github.
https://github.com/danielnorberg/guava-libraries/commit/36861b49263a11f3d845b0ecfd2ad16f3e0c23a5
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1737#c4) posted by **daniel.norberg** on 2014-04-29 at 06:10 PM_
---
If the above change is not acceptable, would you consider at least exposing a way to instantiate ImmutableList.Builder with the expected capacity, making it possible for the user to avoid an extra copy in case the number of items is known in advance?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1737#c5) posted by **lowasser@google.com** on 2014-04-29 at 06:16 PM_
---
That's issue 196.
---
I think it would make sense to have a equals method on the FluentIterables.
e.g. when I call FluentIterable.from(myIterable), then since FluentIterable is itself an Iterable wrapping the myIterable, I expect it to be equal to myIterable.
I encountered this problem when mocking a method that hass a Iterable parameters to which I pass a FluentIterable. The mocking framework returns null since the expected callee and the actual callee are not equal.
workaround: if I return FluentIterable.from(myIterable).toList() then the equals problem is gone.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1735#c1) posted by **lowasser@google.com** on 2014-05-05 at 08:15 PM_
---
This seems inconsistent: even if the FluentIterable is .equals to the original Iterable, FluentIterable can't do anything to make the converse true: the original Iterable won't equal the FluentIterable.  So this would seem to be asking for an asymmetric equals method that breaks its contract...?
---
You're absolutely right. But two FluentIterables could be equal if they refer to the same Iterable.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1735#c3) posted by **cgdecker@google.com** on 2014-05-12 at 03:33 PM_
---
I think it's better for FluentIterable not to implement equals. In the simplest case, when you've just wrapped a Collection in a FluentIterable, equals seems sensible. But once you start filtering and transforming, the question of "does this FluentIterable equal that one" starts to get a lot murkier. Add to that the fact that you can create your own FluentIterable implementation by subclassing it, trying to define an equals contract for the class just doesn't seem worth it.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1727) created by **thierryler** on 2014-04-15 at 11:29 AM_
---
Hello,
Here is what i looks like :
public interface Multirator&lt;E> extends Iterator&lt;E>, Iterable&lt;E> {
&nbsp;&nbsp;&nbsp;&nbsp;void add(final Iterator&lt;E>... iterators);
&nbsp;&nbsp;&nbsp;&nbsp;void add(final Iterable&lt;E>... iterables);
}
I wrote a first implementation who choose the next element as the smallest available :
public class SortedPeekingMultirator&lt;E extends Comparable&lt;E>> implements Multirator&lt;E> {
```
private final List<PeekingIterator<E>> iterators = new ArrayList<>();
/* Constructors */
public SortedPeekingMultirator(final Iterator<E>... iterators) {
add(iterators);
}
public SortedPeekingMultirator(final Iterable<E>... iterables) {
add(iterables);
}
/* From Multirator.java */
@SuppressWarnings("unchecked")
public void add(final Iterator<E>... iterators) {
for (final Iterator<E> iter : iterators) {
final PeekingIterator<E> pi = Iterators.peekingIterator(iter);
this.iterators.add(pi);
}
}
@SuppressWarnings("unchecked")
public void add(final Iterable<E>... iterables) {
for (final Iterable<E> iterable : iterables) {
add(iterable.iterator());
}
}
/* From Iterator.java */
public boolean hasNext() {
if (pi.hasNext()) {
return true;
}
}
return false;
}
public E next() {
if (!hasNext()) {
throw new NoSuchElementException();
}
E smallest = null;
int pos = 0;
int i = 0;
if (!pi.hasNext()) {
i++;
continue;
}
final E elt = pi.peek();
if (smallest == null) {
smallest = elt;
pos = i++;
continue;
}
smallest = elt;
pos = i++;
}
}
// next
iterators.get(pos).next();
return smallest;
}
```
}
Please have a look at the attached files for complete source code and tests.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1727#c1) posted by **thierryler** on 2014-04-15 at 12:08 PM_
---
Or simpler :
```
public E next() {
if (!hasNext()) {
throw new NoSuchElementException();
}
E smallest = null;
int pos = 0;
int i = 0;
if (pi.hasNext()) {
final E elt = pi.peek();
if (smallest == null || smallest.compareTo(elt) > 0) {
smallest = elt;
pos = i;
}
}
i++;
}
// next
iterators.get(pos).next();
return smallest;
}
```
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1727#c2) posted by **SeanPFloyd** on 2014-04-15 at 01:30 PM_
---
Are you aware of the existing method Iterators.concat(Iterator ...)?:
https://google.github.io/guava/apidocs/com/google/common/collect/Iterators.html#concat%28java.util.Iterator...%29
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1727#c3) posted by **thierryler** on 2014-04-15 at 02:00 PM_
---
Well I was not aware of the method "concat". It looks great.
But I would say that it does not provide exactly the same thing. With concat, you can not specify the order for example. And it works with copies.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1727#c4) posted by **lowasser@google.com** on 2014-05-05 at 08:13 PM_
---
Is it really the case that this is a common enough need to be preferable to just writing specific iterators for each case?  For the particular example, we already have Iterators.mergeSorted.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1726) created by **limpbizkit** on 2014-04-14 at 02:19 AM_
---
I'm doing some web crawling with OkHttp, and I ran into some Content-Type declarations that are malformed but harmless. Most notable is the malformed media type on http://netscape.aol.com.
&nbsp;&nbsp;Content-Type: text/html;;charset=utf-8
I fixed OkHttp's MediaType to handle this case, and also the case of a dangling semi-colon that also appears in-the-wild. You may want to do the same with Guava, or not, depending on how strict you want to be.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1726#c1) posted by **kevinb@google.com** on 2014-04-14 at 10:31 PM_
---
Hey Jesse... are you thinking of some sort of MediaType.parseLenient() option?
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1726#c2) posted by **limpbizkit** on 2014-04-14 at 10:58 PM_
---
That would work. Or you could just change the existing parse() to support unnecessary semicolons. (Postel's law).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1726#c3) posted by **fgaliegue** on 2014-05-14 at 06:27 PM_
---
Or introduce .parseStrict()?
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1716) created by **lowasser@google.com** on 2014-04-07 at 09:36 PM_
---
http://stackoverflow.com/questions/22923370/does-the-java-memory-model-reorders-non-synchronized-accesses-of-volatile-variab
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1715) created by **cpovirk@google.com** on 2014-04-07 at 05:42 PM_
---
One time, when running the tests of the JDK5 backport[*] -- no, I don't know if the JDK5-ness (e.g., ArrayDeque -> LinkedList) is relevant -- ServiceManagerTest appeared to hang. jstack output is attached. I don't know if there were any exceptions or other hints of a cause. (Certainly our Maven test output always has exceptions in it; I didn't see if any looked related, and I've since overwritten the output files :) The interesting part of the stacks is below.
The test worked fine the next time I ran it, and it worked fine when I made the equivalent internal change and ran 10x against the normal internal JDK with the normal tools.
I could believe that we hit a crazy VM bug or something, but in case there's anything actually wrong in ServiceManager or its test, I figured I'd file this bug.
&nbsp;&nbsp;at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)
&nbsp;&nbsp;at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:834)
&nbsp;&nbsp;at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:994)
&nbsp;&nbsp;at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1303)
&nbsp;&nbsp;at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:236)
&nbsp;&nbsp;at com.google.common.util.concurrent.Uninterruptibles.awaitUninterruptibly(Uninterruptibles.java:55)
&nbsp;&nbsp;at com.google.common.util.concurrent.ServiceManagerTest$4.failure(ServiceManagerTest.java:365)
&nbsp;&nbsp;at com.google.common.util.concurrent.ServiceManager$ServiceManagerState$5.call(ServiceManager.java:689)
&nbsp;&nbsp;at com.google.common.util.concurrent.ServiceManager$ServiceManagerState$5.call(ServiceManager.java:687)
&nbsp;&nbsp;at com.google.common.util.concurrent.ListenerCallQueue.run(ListenerCallQueue.java:118)
&nbsp;&nbsp;at com.google.common.util.concurrent.MoreExecutors$SameThreadExecutorService.execute(MoreExecutors.java:297)
&nbsp;&nbsp;at com.google.common.util.concurrent.ListenerCallQueue.execute(ListenerCallQueue.java:86)
&nbsp;&nbsp;at com.google.common.util.concurrent.ServiceManager$ServiceManagerState.executeListeners(ServiceManager.java:700)
&nbsp;&nbsp;at com.google.common.util.concurrent.ServiceManager$ServiceManagerState.transitionService(ServiceManager.java:671)
&nbsp;&nbsp;at com.google.common.util.concurrent.ServiceManager$ServiceListener.failed(ServiceManager.java:774)
&nbsp;&nbsp;at com.google.common.util.concurrent.AbstractService$9.call(AbstractService.java:484)
&nbsp;&nbsp;at com.google.common.util.concurrent.AbstractService$9.call(AbstractService.java:482)
&nbsp;&nbsp;at com.google.common.util.concurrent.ListenerCallQueue.run(ListenerCallQueue.java:118)
&nbsp;&nbsp;at com.google.common.util.concurrent.MoreExecutors$SameThreadExecutorService.execute(MoreExecutors.java:297)
&nbsp;&nbsp;at com.google.common.util.concurrent.ListenerCallQueue.execute(ListenerCallQueue.java:86)
&nbsp;&nbsp;at com.google.common.util.concurrent.AbstractService.executeListeners(AbstractService.java:433)
&nbsp;&nbsp;at com.google.common.util.concurrent.AbstractService.startAsync(AbstractService.java:180)
&nbsp;&nbsp;at com.google.common.util.concurrent.ServiceManager.startAsync(ServiceManager.java:287)
&nbsp;&nbsp;at com.google.common.util.concurrent.ServiceManagerTest.testListenerDeadlock(ServiceManagerTest.java:371)
[*] at https://github.com/google/guava/commit/566894361b48cec7d391127fe4b0f9547b4549c6
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1715#c1) posted by **lukes@google.com** on 2014-04-07 at 05:57 PM_
---
looks like a bug in the test.  though a pretty crazy one.  I doubt the backport change you made would make a difference.  Though possibly the recent ListenerCallQueue changes made this race more likely (since there is slightly less locking going on)
The failure callback was supposed to run on another thread, but it looks like thread scheduling allowed notifyFailed to run prior to when the original executeListeners call from Service.startAsync call returned.  So the failure listeners ended up running on the wrong thread (in particular it ran on the test thread).  The fix is to introduce another synchronization point between the background thread and the main test thread to make sure that all started callbacks have fired prior to calling notifyFailed.... phew!
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1713) created by **ddlatham** on 2014-04-04 at 11:20 PM_
---
Is there are reason these are limited to 2 billion? Iterators can represent long running streams of data that can exceed that amount.
If we did it for limt(), we'd presumably also want to change the other ints here as well:
int frequency()
int size()
partition(int)
paddedPartition(int)
int indexOf()
get(int)
This doesn't look possible to change at this point for return types, only for parameter types, since it's not source-compatible?  (It's not the end of the world, for what it's worth, for Guava to only be able to handle more common cases.)
At this point, it's probably too late to change this on `Iterables`. However, the Streams API in Java 8 does use longs.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1711) created by **j...@canva.com** on 2014-04-01 at 06:25 AM_
---
When multiple threads call LodingCache.getAll() separate independent value loads are performed. This behaviour is not inline with LoadingCache.get() which will only attempt to load values that aren't loading or aren't in the cache.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1711#c1) posted by **kak@google.com** on 2014-04-02 at 06:52 PM_
---
_(No comment entered for this change.)_
---
**Owner:** lowasser@google.com
**Labels:** `Type-Defect`, `Package-Cache`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1711#c2) posted by **cpovirk@google.com** on 2014-04-02 at 07:09 PM_
---
I can't find the (probably internal) thread about this. My recollection is:
1. getAll() is designed primarily for use with custom CacheLoader.loadAll() implementations.
2. loadAll() is typically expected to take roughly the same length of time regardless of the number of keys.
3. If loadAll() waited for both its own loads and the loads from n other pending loadAll() calls, its runtime would be max(time0, time1, time2, ..., timen) rather than just time0.
(1) and (2) are both shaky arguments; we've certainly made compromises here. As a result, I could see an argument for a tweak -- say, that getAll()'s behavior changes if the backing CacheLoader doesn't override loadAll().
My guess is that that's as far as we will go, though, thanks to (3) -- at least in LoadingCache specifically. An AsyncLoadingCache (issue 1350) ought to solve this and other issues.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1710) created by **rdicr...@lapis.com** on 2014-03-31 at 07:36 PM_
---
All of the primitives have stock Converter implementations, except for booleans. Such a converter should be added.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1710#c1) posted by **kak@google.com** on 2014-03-31 at 07:41 PM_
---
This question came up internally, so I'm just copying what Kevin wrote earlier:
If we do add Booleans.stringConverter() (which we're not exactly fundamentally opposed to, it's just that even things this small take work), I think the best thing it can do is convert only the exact strings "true" and "false", nothing else. Any surprises will just prompt users to write the particular converter they really want (any two of which I suspect will be unlikely to be exactly the same)."
4 use Boolean.valueOf() or parseBoolean()
2 convert "", "no", "false", "0", "null" (ignoring case) to false
1 converts "Yes" (ignoring case) to true, everything else converst to false
What semantics would you expect Booleans.stringConverter() to have?
---
**Status:** `Research`
**Labels:** `Type-Addition`, `Package-Primitives`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1710#c2) posted by **rdicr...@lapis.com** on 2014-03-31 at 08:37 PM_
---
I would expect the same semantics as Boolean.valueOf() / parseBoolean(); my implementation uses the latter.
I agree that there are a lot of different ways to represent a boolean, but those methods are baked into Java and thus are a "standard" conversion in my opinion. So it would make sense to have a stock converter for the standard behavior, and then non-standard behavior can be covered by custom converters.
That there is an expectation for it to call method X does not mean that people actually expect that behavior, and it also doesn't mean it's the safest behavior.
At this point I still stand by my previous points:
3. If this converter does exist, the most conservative behavior is to reject any input but "true" and "false". 95%+ of usages will probably be just fine with that, and the rest, who see an exception, will be prompted to decide what they want. No surprises can lurk undetected.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1707) created by **kak@google.com** on 2014-03-26 at 04:28 PM_
---
See discussion here:
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1707#c1) posted by **andreou@google.com** on 2014-03-26 at 05:51 PM_
---
We didn't invest the time to do an API review on this. E.g. finding an agreeable method name, and argument names (I recall I had trouble writing the javadoc for explaining the arguments).
&nbsp;&nbsp;&nbsp;\* @param permitsPerSecond the rate of the returned {@code RateLimiter}, measured in
&nbsp;&nbsp;&nbsp;\*        how many permits become available per second. Must be positive
&nbsp;&nbsp;&nbsp;\* @param maxBurstBuildup the maximum period of time where unused permits are accumulated by the
&nbsp;&nbsp;&nbsp;\*        rate limiter, that can later be handed out with no wait time
&nbsp;&nbsp;&nbsp;\* @param unit the time unit of the maxBurstBuildup argument
&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;public static RateLimiter createWithCapacity(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double permitsPerSecond, long maxBurstBuildup, TimeUnit unit)
This allows, for example, the default implementation to always produce a maximum burst of "1 second-worth-of-permits" (the permits that a RateLimiter would produce in a single second, e.g. if the rate is 10qps, then this is a burst of "10 permits"), i.e. something that should be tiny, no matter what the rate limit is.
Another option would be to say, "screw this, let's describe bursts as maxPermits" (this is simpler to explain), and add a warning of the sort, "if you call setRate(...), then the relative size of the burst (in relation to the rate limit) changes".
E.g., a maxBurst of "100 permits" for a rate limit of 0.01qps, would imply that the RateLimiter could allow in a burst the throughput that would otherwise need almost three hours to go through. If the rate limit is 100qps, then this burst would merely allow in a burst the throughput of that would take one second.
So it's a choice between a burst description that remains invariant in terms of time, and a burst description that remains invariant in terms of permits. I thought the first is more useful (to be able to describe "small" and "big" bursts, without even knowing the rate), but the second is certainly easier to describe and understand.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1707#c2) posted by **goo...@tom-fitzhenry.me.uk** on 2014-05-29 at 06:08 PM_
---
+1 to being able to configure maxBurstBuildup/capacity.
My usecase
I want to rate limit incoming requests to M requests per N seconds, in a sliding window manner. (e.g. 20 requests in 5 seconds. Note that this isn't the same as 4 requests in 1 second. The difference is that the former can build up tokens.)
I believe I could achieve this with RateLimiter.createWithCapacity(M/N, M, TimeUnit.SECONDS).
Sorry for the total lack of response here.
For the "sliding window" case, we should probably supply a non-"smooth" `RateLimiter` implementation. We have one internally, but it has a granularity of one second. We should figure out whether we can change that or whether we have to provide a separate one with finer granularity.
Wading into `RateLimiter` will probably also mean resolving some of the long-standing issues, like how it should be an interface (or at least a "true" abstract class) and how it has a package-private method that will make that tricky.
This would be good to do someday. It's just too big to do as a background task, and it's a lower priority than things like Java 8.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1704) created by **david.nouls** on 2014-03-25 at 01:28 PM_
---
I am using JBoss Fuse to deploy a GWT Application but I cannot guava collection classes in the RPC payloads because the _CustomFieldSerializer classes are not in the guava.jar but in the guava-gwt.jar.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1701) created by **soe...@glorien.com** on 2014-03-20 at 06:43 PM_
---
Within Preconditions.java you defined "args" as Nullable but in line 416 (...new StringBuilder(template.length() + 16 \* args.length);) a NullPointerException can be thrown!
I would expect at least the Nullable-Annotation should be removed (even for the calling methods, like checkNotNull) or it should be null-safe.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1701#c1) posted by **lowasser@google.com** on 2014-03-20 at 06:52 PM_
---
args is declared as @Nullable Object..., and I believe it was intended to indicate that the individual objects were permitted to be null, not the array itself.
Passing a null array to a varargs method would require an explicit cast, as I understand it -- (Object[]) null.  Is there a reason to believe this might actually cause issues in real code?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1701#c2) posted by **soe...@glorien.com** on 2014-03-20 at 09:28 PM_
---
To be honest, there is no real code error-szenario. It was just popping up during some tests and I was wondering that creation of error-message causes an error that was more or less unexpected.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1692) created by **ddlatham** on 2014-03-12 at 01:43 PM_
---
Currently it states "An immutable, hash-based Map with reliable user-specified iteration order."
That's not obvious on the face of it that it means you can rely on iterating elements in the order they were added to the builder.
See for example:
http://stackoverflow.com/questions/3810738/google-collections-immutablemap-iteration-order
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1692#c1) posted by **kevinb@google.com** on 2014-03-12 at 02:00 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Accepted`
**Owner:** kevinb@google.com
**Labels:** `Type-ApiDocs`, `Package-Collect`
The clarification should go on both the immutable collection types and their builders.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1691) created by **cow...@bbs.darktech.org** on 2014-03-09 at 06:20 AM_
---
Please add functionality that reverses the effects of Escaper.escape(String).
Use-case: When converting from URL to URI, we need to decode the URL components before passing them into the URI constructor to be re-encoded. See http://stackoverflow.com/a/22279061/14731 for an example.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1691#c1) posted by **cpovirk@google.com** on 2014-03-11 at 07:11 PM_
---
Is the use case served by the JDK URLDecoder method used in the StackOverflow answer?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1691#c2) posted by **cow...@bbs.darktech.org** on 2014-03-11 at 10:24 PM_
---
I have a feeling I know what's going to happen once I answer this... :)
Yes, the use-case is served by the JDK URLDecoder method. I don't have an immediate use-case for decoding the other Escaper implementations but perhaps others do...?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1691#c3) posted by **cpovirk@google.com** on 2014-03-12 at 04:02 PM_
---
> I have a feeling I know what's going to happen once I answer this... :)
:)
> Yes, the use-case is served by the JDK URLDecoder method. I don't have an
> immediate use-case for decoding the other Escaper implementations but
> perhaps others do...?
Our general thinking here is that a proper URL class ought to handle unescaping as part of parsing, similar to what parsers do for HTML, etc. Such a URL class has been on our to-do list forever. See issue 1005.
---
**Labels:** `Type-Addition`, `Package-Escape`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1691#c4) posted by **cow...@bbs.darktech.org** on 2014-03-12 at 11:47 PM_
---
Jersey's UriBuilder does an excellent job in that department, but there are still a few use-cases it fails to handle nicely.
Imitation is the highest form of flattery :) Have you considered "extending" their UriBuilder design?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1691#c5) posted by **cpovirk@google.com** on 2014-03-13 at 03:08 AM_
---
Would that be this one? https://jersey.java.net/apidocs/2.0/jersey/javax/ws/rs/core/UriBuilder.html
(In this case, we do have one internally. The problem is that it has a flaw or two. We'd like to fix it up rather than introduce a new one, but the impact on existing users (who might rely on, e.g., the exact hash generated by a UriBuilder usage) makes the fix difficult.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1691#c6) posted by **cow...@bbs.darktech.org** on 2014-03-13 at 04:15 AM_
---
Yes, that's the one.
"We do have one internally": What do you mean internally? Internally at Google?
"who might rely on, e.g., the exact hash generated by a UriBuilder usage": since when does the specification guarantee the exact hash generated? Isn't it a code smell if users need to depend on this kind of (implementation-specific) information?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1691#c7) posted by **cpovirk@google.com** on 2014-03-13 at 01:00 PM_
---
Yeah, sorry, internally at Google.
And the hash they're relying on isn't hashCode(); it's the output of some well defined hashing algorithm that they run against the URL string. Consequently, if we change the URL string by improving our class's escaping behavior, the hash will change, and their code will break.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1691#c8) posted by **cow...@bbs.darktech.org** on 2014-03-13 at 06:08 PM_
---
Couldn't you release the fixed version to the public, and apply a "normalization" process inside Google before passing it on to the hashing algorithm?
Meaning, I would expect you to retain backwards compatibility by modifying the wrapper code (the code that invokes the UriBuilder and passes the result to a hashing algorithm), as opposed to holding UriBuilder's implementation back.
Are you saying there isn't a deterministic way to convert from the "fixed" format back to the format expected by the hashing function?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1691#c9) posted by **cpovirk@google.com** on 2014-03-13 at 06:14 PM_
---
Something like that should work. The challenge is in identifying all the lines of Google code that depend on the exact URL. This can be more difficult than I've made it out to be: Some callers might build a URL and send it via RPC to an entirely different service, and only in that different service is the URL hashed.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1691#c10) posted by **cow...@bbs.darktech.org** on 2014-03-13 at 06:29 PM_
---
If you normalize it as the source before sending it out via RPC you should be safe. Meaning: Find Usages on your UriBuilder class and always normalize the result regardless of where it goes. You could always optimize this later by removing normalization where it's not necessary.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1691#c11) posted by **cpovirk@google.com** on 2014-03-13 at 06:33 PM_
---
We'd be talking a 5-digit number of callers here. I'd additionally worry that new users within an app might omit the normalization call. We'd almost need to force users to choose which escaping policy they want.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1691#c12) posted by **cow...@bbs.darktech.org** on 2014-03-13 at 07:36 PM_
---
How about having the Google UriBuilder wrap/extend the Guava UriBuilder implementation? This way your code keeps on running without changing any references, and Guava users still benefit.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1691#c13) posted by **cpovirk@google.com** on 2014-03-13 at 07:44 PM_
---
That could work.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1689) created by **rhvarona** on 2014-03-03 at 06:21 AM_
---
Optimize the result array, by presizing when a column limit has been set.
Change from:
&nbsp;&nbsp;public List&lt;String> splitToList(CharSequence sequence) {
&nbsp;&nbsp;&nbsp;&nbsp;checkNotNull(sequence);
```
Iterator<String> iterator = splittingIterator(sequence);
List<String> result = new ArrayList<String>();
while (iterator.hasNext()) {
result.add(iterator.next());
}
return Collections.unmodifiableList(result);
```
&nbsp;&nbsp;}
To:
&nbsp;&nbsp;public List&lt;String> splitToList(CharSequence sequence) {
&nbsp;&nbsp;&nbsp;&nbsp;checkNotNull(sequence);
```
Iterator<String> iterator = splittingIterator(sequence);
List<String> result = Integer.MAX_VALUE == limit ? new ArrayList<String>() : new ArrayList<String>(limit);
while (iterator.hasNext()) {
result.add(iterator.next());
}
return Collections.unmodifiableList(result);
```
&nbsp;&nbsp;}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1689#c1) posted by **rhvarona** on 2014-03-03 at 06:23 AM_
---
Might want to have a sanity check also:
private static final int MAX_PRESIZE_ARRAY_SIZE = 200;
List&lt;String> result = Integer.MAX_VALUE == limit ? new ArrayList&lt;String>() : new ArrayList&lt;String>(Math.min(limit, MAX_PRESIZE_ARRAY_SIZE));
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1689#c2) posted by **kak@google.com** on 2014-03-03 at 10:57 PM_
---
Sounds reasonable.
Not quite sure I understand why you'd want that "sanity check" that you talk about in update #1 ?
---
**Owner:** kak@google.com
**Labels:** `Type-Performance`, `Package-Base`
---
Yes, to protect against someone making the limit one billion, for example.
I find the proposed behaviour questionable. Splitter.limit(n) is documented to mean that it will split to no more than n items. It is not documented to mean that the returned list will always be backed by an array of size n. If I use limit(10000) to prevent bogus input from blowing up too badly, I think I would be surprised to find that I am suddenly using arrays of size 10000 where previously it was using the small arrays that ArrayList uses by default. There is one use case that the change would improve slightly, where I expect that there will always be at least n items and if there are more than n I just want to put them together; but there are other use cases that will be substantially worsened.
I thought of that but it still seems obnoxious to me to allocate a giant array in this case, where we didn't before. The default behaviour of ArrayList is to start with capacity 10 and multiply by 1.5 every time capacity is exceeded. It seems to me that that is already a great fit for most uses of Splitter, including with a limit. I'm not seeing any evidence that would support the proposed change.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1686) created by **justinrmiller** on 2014-02-27 at 07:57 PM_
---
Hi all,
Can someone explain why partition was removed from FluentIterable? It seems like it would be really handy to have (for instance, a list of user ids could be filtered for certain values, then passed to partition to finally present an iterable of iterables (?) for GET query construction).
It appears to have been removed here:
https://github.com/google/guava/commit/1a7e408ce9f1e2c256635d6673595282fed8805a
Is there a better way of doing partitioning within FluentIterable that I'm missing?
Best,
Justin
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1686#c1) posted by **cpovirk@google.com** on 2014-02-27 at 08:04 PM_
---
We've gotten requests for two kinds of partitioning: "split into N groups, and split into groups of size N." We'd like to support both, so we'll need to find names for both. Probably both will have to be more specific than "partition," so we removed partition while we got it figured out. (I don't think we've figured it out yet :)
---
**Status:** `Accepted`
**Labels:** `Type-Addition`, `Package-Collect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1686#c2) posted by **cpovirk@google.com** on 2014-02-27 at 08:07 PM_
---
We still need to look into current usages (to see whether we `FluentIterable<List<E>>` would be a better return type) and also bring this to API review to decide on a name.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1685) created by **pmjpmj** on 2014-02-27 at 06:31 PM_
---
It would be great to be able to set CacheBuilder.statsCounterSupplier field.
This would allow use of different stats collectors such as codahale metrics with ease on existing cache implementations. (then I can take advantage of it and use various stat exporters with ease)
Since there was more discussion on #2209, I'm marking this issue as a duplicate of that one.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1682) created by **mikael.barbero** on 2014-02-25 at 02:40 PM_
---
There is an issue about Guava and the next Eclipse Simultaneous release (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=427862).
Some participants are using a version of guava while other use another one. This cause some ClassCastException between plugins. This would be less frequent if the packages were exported with a semantic version instead of the global release number. This way, Guava's user may be confident while importing package with a range dedicated to their usage.
I will try to propose a patch to the POM file with comments made on https://www.osgi.org/bugzilla/show_bug.cgi?id=161. But first, I would like to know if the guava team member agree with such a change (knowing that it does not change anything for anyone not using OSGi, but helps a lot people using it...)
Best.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1682#c1) posted by **cgdecker@google.com** on 2014-02-25 at 05:09 PM_
---
We actually do use semantic versioning with Guava. Every Guava release may contain incompatible API changes (according to the policy for @Beta and non-@Beta APIs described here: https://code.google.com/p/guava-libraries/wiki/PhilosophyExplained#Beta_APIs) and as such, every major release requires a new major version in accordance with semantic versioning.
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1682#c2) posted by **mikael.barbero** on 2014-02-25 at 05:27 PM_
---
Semantic versioning is not about what a release _may_ contain compared to the previous release but how much it _has_ changed. Moreover, I am not suggesting to change the release numbering of Guava in any way. Most of the time the major bump is required because at least one of its package has been broken. But some packages are very stable, and people wants to be able to be linked to a newer version of guava if they only use packages that contains no API breakage for them.
I am proposing to change the versioning of exported packages (i.e. in the MANIFEST.MF, the version of the packages listed in the export-package directive). It is something that is really useful in an OSGi environment. The idea is: if a package A did not change its API from one version to another, only the micro part of its version is incremented; if it changed its API for providers (i.e. implementers), its minor part is incremented; and if its API changed for consumer (i.e. users of the API) then the major part is upgraded. See http://www.osgi.org/wiki/uploads/Links/SemanticVersioning.pdf if you are interested in the reasoning.
This numbering can be made automatic and I'm proposing to implement this automation in the POM. Are you OK with that?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1682#c3) posted by **cpovirk@google.com** on 2014-02-25 at 05:35 PM_
---
Would it be accurate to title this bug "Set Export-Package versions on a per-package basis?"
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1682#c5) posted by **mikael.barbero** on 2014-02-25 at 05:37 PM_
---
Yes, it would be absolutely accurate.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1682#c6) posted by **cpovirk@google.com** on 2014-02-25 at 05:38 PM_
---
_(No comment entered for this change.)_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1682#c7) posted by **mikael.barbero** on 2014-03-06 at 06:40 AM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1682#c8) posted by **alexander.klimetschek** on 2014-09-15 at 05:17 PM_
---
+1
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1682#c9) posted by **robert.munteanu** on 2014-09-16 at 09:04 AM_
---
I see you're trying to use the aries versioning plugin to help with semantic versioning. Since that does not seem to be really maintained, perhaps you can try using the maven-bundle-plugin, which since version 2.5.0 can generate baseline reports and even fail the build if changes are not taken into account through versioning.
The documentation is mostly at https://issues.apache.org/jira/browse/FELIX-4512 , but I'm happy to answer any questions you might have about its usage.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1682#c10) posted by **mikael.barbero** on 2014-09-18 at 10:09 AM_
---
Thanks Robert for pointing this out. I will give it a try very soon.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1680) created by **xaerxess** on 2014-02-24 at 02:58 PM_
---
[http://stackoverflow.com/questions/21986551/guava-cachebuilder-doesnt-call-removal-listener In this Stackoverflow question] user pointed out that RemovalListener isn't called on removal entry. That behavior is not explicitely documented, as CacheBuilder#removalListener(RemovalListener) documentation says:
> Specifies a listener instance that caches should notify each time an entry
> is removed for any reason. Each cache created by _this builder will invoke
> this listener as part of the routine maintenance described in the class
> documentation above_.
The "documentation above" says:
> Caches built with CacheBuilder do not perform cleanup and evict values
> "automatically," or instantly after a value expires, or anything of the sort.
> Instead, it performs small amounts of maintenance during write operations,
> _or during occasional read operations if writes are rare_.
I think user can expect RemovalListener to be called on actual removal.
Internally, the cleanup is (not) made by postReadCleanup():
```
/**
* Performs routine cleanup following a read. Normally cleanup happens during writes. If cleanup
* is not observed after a sufficient number of reads, try cleaning up from the read thread.
*/
void postReadCleanup() {
if ((readCount.incrementAndGet() & DRAIN_THRESHOLD) == 0) {
cleanUp();
}
}
```
so "occasionally" means every 64 reads, if no write or cleanup occured meanwhile. This is some kind of optimization, so I'd like to request either:
&nbsp;\- adding a clarification in CacheBuilder#removalListener(RemovalListener),
&nbsp;\- changing postReadCleanup() to just do cleanUp() (it should probably be benchmarked),
&nbsp;\- adding something like CacheBuilder#doNotDeferRemovalListener() which would bypass DRAIN_THRESHOLD check in postReadCleanup().
I've checked LoadingCache tests and it looks like the third option (which is a win-win IMO) would not break any tests, while second option breaks testDrainRecencyQueueOn{Read,Write}.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1680#c1) posted by **lowasser@google.com** on 2014-02-24 at 06:19 PM_
---
I'm not sure I follow the issue here.  Are you expecting the entry to be passed to the RemovalListener immediately after being removed from the table, i.e. no longer accessible to queries?
Or are you expressing concern over _why_ the decision was made to only cleanup "occasionally" on reads?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1680#c2) posted by **xaerxess** on 2014-04-18 at 11:53 AM_
---
After checking the example and reading source and docs again, it seems that it's a documented behavior and changes in code I proposed wouldn't be suitable for Guava's (Loading)Cache not-heavyweight design.
---
The error message is: java.lang.NoSuchMethodError: com.google.common.base.Splitter.splitToList(Ljava/lang/CharSequence;)Ljava/util/List;
My mvn dependency:tree is showing exactly one guava 16.0 and I don't have google collections. This is the tree (minus our own packages):
[INFO] +- org.springframework:spring-core:jar:3.2.5.RELEASE:compile
[INFO] |  - commons-logging:commons-logging:jar:1.1.1:compile
[INFO] +- org.springframework:spring-web:jar:3.2.5.RELEASE:compile
[INFO] |  +- aopalliance:aopalliance:jar:1.0:compile
[INFO] |  +- org.springframework:spring-aop:jar:3.2.5.RELEASE:compile
[INFO] |  +- org.springframework:spring-beans:jar:3.2.5.RELEASE:compile
[INFO] |  - org.springframework:spring-context:jar:3.2.5.RELEASE:compile
[INFO] +- org.springframework:spring-webmvc:jar:3.2.5.RELEASE:compile
[INFO] |  - org.springframework:spring-expression:jar:3.2.5.RELEASE:compile
[INFO] +- org.springframework.data:spring-data-mongodb:jar:1.3.2.RELEASE:compile
[INFO] |  +- org.springframework:spring-tx:jar:3.1.4.RELEASE:compile
[INFO] |  +- org.springframework.data:spring-data-commons:jar:1.6.2.RELEASE:compile
[INFO] |  +- org.mongodb:mongo-java-driver:jar:2.10.1:compile
[INFO] |  - org.slf4j:jcl-over-slf4j:jar:1.7.1:runtime
[INFO] |  - org.hamcrest:hamcrest-core:jar:1.3:test
[INFO] +- org.springframework:spring-test:jar:3.2.5.RELEASE:compile
[INFO] +- org.easytesting:fest-assert-core:jar:2.0M10:compile
[INFO] |  - org.easytesting:fest-util:jar:1.2.5:compile
[INFO] +- org.apache.tomcat:tomcat-servlet-api:jar:7.0.47:provided
[INFO] +- javax.servlet.jsp:jsp-api:jar:2.2:provided
[INFO] +- javax.servlet.jsp.jstl:jstl-api:jar:1.2:compile
[INFO] +- org.glassfish.web:jstl-impl:jar:1.2:compile
[INFO] +- com.google.code.gson:gson:jar:2.2.4:compile
[INFO] +- com.google.guava:guava:jar:16.0:compile
[INFO] +- org.slf4j:slf4j-api:jar:1.7.5:compile
[INFO] +- org.slf4j:slf4j-log4j12:jar:1.7.5:compile
[INFO] |  - log4j:log4j:jar:1.2.17:compile
[INFO] +- commons-codec:commons-codec:jar:1.4:compile
[INFO] +- org.codehaus.jackson:jackson-mapper-asl:jar:1.9.13:compile
[INFO] |  - org.codehaus.jackson:jackson-core-asl:jar:1.9.13:compile
[INFO] +- javax.mail:mail:jar:1.4.5:compile
[INFO] |  - javax.activation:activation:jar:1.1:compile
[INFO] +- joda-time:joda-time:jar:2.3:compile
## [INFO] - org.ocpsoft.prettytime:prettytime:jar:3.2.4.Final:compile
Thanks in advance.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1668#c1) posted by **LukeISandberg** on 2014-02-14 at 07:53 AM_
---
https://java.net/jira/browse/GLASSFISH-20850
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1668#c2) posted by **stephan202** on 2014-02-14 at 09:19 AM_
---
General Maven remark: `mvn dependency:tree`&nbsp;will list only the _selected_ dependencies. Thus you'll always see Guava at most once (provided it was not shaded under another GAV). Add the -Dverbose flag to see which dependencies (versions) were suppressed. This should tell you against which version of Guava other third party dependencies are built.
---
@Stephan...I used the -Dverbose. No other dependency is including Guava. Checking at other forums, including the one Luke posted, we made a decision to move to Tomcat. GlassFish's own dependencies leak into apps classpath (and GF uses an older Guava.) Fixing the issue requires meddling with GF's own libraries and is error-prone. Such errors are a disaster waiting to happen.
Thanks all for the help.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1666) created by **jacek99** on 2014-02-11 at 05:13 PM_
---
We have a complex key consisting of a POJO with 4 string fields, an Integer and a DateMidnight (from Joda Time). 2 out of the 4 String fields can be null at any time.
It seems with a simple key (e.g. a single String) the cache is very fast,
Hit rate: 33.30 %
Miss rate: 66.69 %
Average load penalty: 5.44 ms
Eviction count: 15002
Request count: 24402
Load exception rate: 0.00 %
if we convert all these keys into a single String using a StringBuilder is starts being super fast again with a hit rate of ~99.9%.
The problem with that is in the loading method we have to parse the String to break out the original 6 pieces that made it. Not preferable for an application with near real-time SLAS.
Set up:
cache = CacheBuilder.newBuilder()
.maximumSize(100_000)
.expireAfterWrite(5, TimeUnit.MINUTES)
.concurrencyLevel(100)
.recordStats()
.build(
new CacheLoader&lt;ItineraryResultCacheKey, ItineraryResult>() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public ItineraryResult load(ItineraryResultCacheKey key) throws Exception {
.... cache loading code....
```
});
}
```
On OpenJDK 7. Tested this with both 14.01 and 16.01, same results.
I've tried multiple things (using Date with all hours/minutes/seconds set to 0 to ensure key equality), converting all values to a single string and coding the equals() and hashCode() to use that instead of the other fields.
To no avail.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1666#c1) posted by **jacek99** on 2014-02-11 at 05:15 PM_
---
I've also played around with the concurrencyLevel, anywhere from 1 to exact number of threads in the HTTP server. Made no discernible difference either.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1666#c2) posted by **kak@google.com** on 2014-02-11 at 05:18 PM_
---
Curious what your equals/hashCode methods look like on your ItineraryResultCacheKey POJO...
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1666#c3) posted by **jacek99** on 2014-02-11 at 05:30 PM_
---
At first I had a default one generated via Lombok. That is how we found the original issues.
Since that was my first suspicion I overrode it manually to just use the aforementioned single String representation of all the parts of the POJO, e.g.
```
private String id;
public boolean equals(Object obj) {
if (obj instanceof ItineraryResultCacheKey) {
return this.id.equals(((ItineraryResultCacheKey) obj).getId());
} else {
return false;
}
}
public int hashCode() {
return this.id.hashCode();
}
```
where "id" gets created in the Constructor by appending all the 6 fields into a single string using a StringBuilder (with "" put if string is null and the explicit year/month/day integers put into it for the date part (so no actual Date.toString() where we could get millsecond/second differences).,
Also, we found this in simple perf testing where we are basically sending the same 10 requests over and over (using multi-mechanize) so the range of keys being sent is actually very small.  It's not real-life data.
Is there some part of code you could recommend for me to trace or debug manually (a particular Class/method)?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1666#c4) posted by **jacek99** on 2014-02-11 at 05:56 PM_
---
I hang my head in shame. Equals()/hashCode() are not the problem.
We had previously existing code in a totally different section  of the app that was actually mutating this key during multiple parts of the processing (one of the fields). This was done as part of a naive attempt to reduce GC pressure by reusing object instances (instead of instantiating them multiple times with minor variations).
Once I removed that and made it properly instantiate a new instance every time every started running properly.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1666#c5) posted by **lowasser@google.com** on 2014-02-11 at 05:57 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Invalid`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1661) created by **magiciankid** on 2014-02-09 at 07:37 AM_
---
wanntted a testcase or formula get this value , at least need a javadoc to comment it
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1661#c2) posted by **magiciankid** on 2014-02-10 at 06:59 AM_
---
etc:
IntMath.gcd  documented http://en.wikipedia.org/wiki/Binary_GCD_algorithm
javadoc of Collections2.permutations notes it describe in TAOCP
these methods were well documented
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1661#c3) posted by **kevinb@google.com** on 2014-02-10 at 04:58 PM_
---
Hm; I thought our Type- categories were complete enough, but we've never had a feature request for an implementation comment before.
As an internal implementation detail I'd expect this to be very low priority. Is there any particular reason you need this information?
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1661#c5) posted by **magiciankid** on 2014-02-11 at 01:02 AM_
---
implementation details helps mastering skill  .
CharMatcher.WHITESPACE's makes me doubted:  why WHITESPACE_MULTIPLIER is that value ? why change sequence of  WHITESPACE_TABLE  can't get MULTIPLIER (http://goo.gl/AGdkCu) .  can't find any information to understand it  by myself , may be this problem will douted other people
that's all reason
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1661#c6) posted by **magiciankid** on 2014-02-11 at 02:35 AM_
---
at this version (http://goo.gl/0YmP0L) documented very well  , the latest change was submit by "Colin Decker"
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1661#c7) posted by **lowasser@google.com** on 2014-02-18 at 07:21 PM_
---
We have a WhitespaceMatcherGenerator class that we could open-source; the main issue is that it depends on icu4j, which would be a new dependency for tests, and we may or may not be okay with adding that dependency.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1661#c8) posted by **magiciankid** on 2014-02-19 at 03:29 AM_
---
hmm , how about put it in wiki or comment it in someplace  , anticipate WhitespaceMatcherGenerator .
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1658) created by **dimo414** on 2014-02-06 at 02:53 PM_
---
Calculating roots isn't available for BigDecimal in the JDK, leading to many different thrown together solutions (http://stackoverflow.com/questions/13649703/square-root-of-bigdecimal-in-java), none of which are clearly correct or ideal.
I imagine this has not been implemented by the JDK or other major libraries due to the complexity of "getting it right", however in my mind that makes Guava the ideal candidate for providing this behavior - with whatever caveats are necessary - as a trusted source of quality utilities.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1652) created by **cpovirk@google.com** on 2014-01-30 at 04:37 PM_
---
(split off from issue 1651)
"""
The hashcode of the streamed content is available independent of the stream state (open/flushed/closed).  In the case where the stream is wrapped (directly or indirectly) with a BufferedOutputStream (or any other stream that buffers the content), the HashingOutputStream won't yet have seen anything that is buffered, resulting in the hash() method calculating a likely incorrect hashcode (the hash would be technically correct, but not what the user expected as it isn't based on the full input).
This can be addressed by not allowing the hashcode to be available until after close() is called, throwing an exception if accessed otherwise (this uncovered a number of subtle errors when we implemented it):
```
public HashCode getHashCode()
{
checkState( hashCode != null, "Attempted to retrieve hashCode without having closed the stream first" );
return hashCode;
}
public void close() throws IOException
{
super.close();
}
```
"""
(Possibly this also goes for CountingOutputStream and retrieving its count?)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1652#c1) posted by **cgdecker@google.com** on 2014-03-17 at 08:07 PM_
---
Personally, I don't see this as a problem: it's just something that users have to be aware of when dealing with a stream like this. Any time you're writing through a BufferedOutputStream to some sink, you need to flush() the buffered stream before you do something with the underlying sink.
I also don't think that requiring the stream to be closed to get the hash code is the right thing to do, for a couple reasons:
1. In some cases, someone might want to get the hash code at multiple points while writing something.
2. It doesn't really solve the issue with buffering streams, because you can still close() the HashingOutputStream without closing the buffering stream, resulting in the exact same issue with the buffered bytes not being written.
---
> 1. In some cases, someone might want to get the hash code at multiple points while writing something.
Someone might want it, but no one can get it since Hasher.hash() "... is unspecified if this method is called more than once on the same instance."
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1652#c3) posted by **cgdecker@google.com** on 2014-03-20 at 03:24 PM_
---
True enough. Though I think in practice it works fine for some hash functions and not for others.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1652#c4) posted by **ch...@digitalascent.com** on 2014-03-20 at 03:52 PM_
---
It would be unfortunate for the caller of HashingOutputStream.hash() to have to either know that it is wrapped in a BufferedOutputStream (that may not be evident), or remember to call flush() first; in both these cases, it is a 'soft' bug (no exception, just an incorrect hash value that may go unnoticed).
Requiring that the stream be closed first guarantees that HashingOutputStream can't silently return a hash of partial input.
---
> True enough. Though I think in practice it works fine for some hash functions and not for others.
I'm afraid it works for no usable hash function, especially Murmur and all the MessageDigestHashFunctions. It could be implemented rather easily via cloning, but this might have non-negligible runtime cost (which is bad as partial hashing is probably rarely needed).
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1650) created by **leventov.ru** on 2014-01-30 at 01:05 PM_
---
.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1650#c1) posted by **cpovirk@google.com** on 2014-01-30 at 02:46 PM_
---
Louis is working on this as part of his JDK8 investigations. It will be a while before Guava supports JDK8... though I suppose we could see now whether the tests could invoke the default methods reflectively? (I'm not sure how that works with default methods, and I'm not sure whether we'll go through with it just yet either way.)
---
**Status:** `Started`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1650#c2) posted by **leventov.ru** on 2014-06-04 at 12:17 PM_
---
Is there internal progress? I could do something, but don't want to duplicate efforts.
@lowasser , we've gotten a little more interest in this. I suspect that we're probably not going to be able to add anything to Guava itself within the next couple quarters, but where do we stand with this now? Do we have code for JDK8 methods in a branch somewhere, or is this a case where code contributions may be helpful?
We have these internally in our Java 8 branch. They'll make their way out when we release Java 8 Guava (hopefully mid-year). I don't know if @lowasser has other plans to publish them any other way before then.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1645) created by **archie.cobbs** on 2014-01-24 at 09:56 PM_
---
I'd like the ability to take the output of TypeToken.toString() and parse it back into the equivalent TypeToken.
For example, one should be able to say:
&nbsp;&nbsp;&nbsp;foo = TypeToken.parse("java.util.List&lt;java.lang.String>");
and have foo equal to new TypeToken&lt;List&lt;String>>() {}.
NOTE 1: it seems reasonable to have the restriction that no type variables are allowed (would it even make sense to allow them? If you did you'd have to have some way of deciding whether "T" was a type variable or a class name).
NOTE 2: a ClassLoader should probably be a parameter to the parse method
I tried to implement this myself but it seems impossible without using package/private methods or generating bytecode (if it's possible to implement this idea using the standard public TypeToken API, please advise on how it would be done).
For example, this doesn't work:
```
TypeVariable tv = List.class.getTypeParameters()[0];
System.out.println(new TypeResolver().where(
tv, String.class).resolveType(List.class));
```
prints:
```
java.util.List
```
instead of:
```
java.util.List<String>
```
Also can't use TypeToken.of(List.class).getTypes(), which returns:
```
java.util.List, java.util.Collection<E>, java.lang.Iterable<E>
```
instead of:
```
java.util.List<E>, java.util.Collection<E>, java.lang.Iterable<E>
```
What seems to be stopping this is the ability to convert a raw class into its parameterized Type or TypeToken. E.g., wish there was a method like this:
```
public Type Class.getGenericType();
```
That is, this feature request could be answered by adding a new method that does the equivalent, e.g.:
```
public TypeToken<? extends T>  TypeToken.getGenericType();
```
So that e.g. TypeToken.of(List.class).getGenericType() -> List&lt;E>
Thanks.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1645#c1) posted by **lowasser@google.com** on 2014-01-24 at 10:09 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Reflect`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1645#c2) posted by **archie.cobbs** on 2014-01-24 at 10:15 PM_
---
Snooping through the code, it looks like such a method as suggested at the end of comment #1 already exists:
```
static <T> TypeToken<? extends T> TypeToken.toGenericType()
```
Any reason this method can't be made public?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1645#c3) posted by **archie.cobbs** on 2014-01-27 at 04:46 PM_
---
Just to clarify things a bit here, as this issue has evolved and the issue title is no longer accurate.
The original request for a String parser is no longer needed... I can do that part myself, but need TypeToken.toGenericType() to made public in order for it to be feasible.
So instead what is being requested here is simply that TypeToken.toGenericType() be made public.
This method provides useful functionality that is not available anywhere else; and you can consider the original string parsing question as a motivating example (i.e., how could you implement string parsing without it?).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1645#c4) posted by **archie.cobbs** on 2014-02-22 at 09:29 PM_
---
Please change the title of this feature request to:
&nbsp;&nbsp;Make method TypeToken.toGenericType() public
Thanks.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1645#c5) posted by **cpovirk@google.com** on 2014-02-25 at 04:54 PM_
---
_(No comment entered for this change.)_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1645#c6) posted by **benyu@google.com** on 2014-06-25 at 08:57 PM_
---
Exposing toGenericType() sounds reasonable.
Although can you show us how it's going to be used in this use case? I wonder if it can be done with existing utilities such as where(), getSupertype(), getSubtype() etc.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1645#c7) posted by **archie.cobbs** on 2014-06-26 at 12:11 AM_
---
As mentioned above, the original motivating example is a TypeToken parser (converts String -> TypeToken).
I tried to implement one using all available public API's but it seemed impossible.
The root problem is that e.g. TypeToken.of(List.class) returns "java.util.List", not "java.util.List&lt;E>". Because of this, there's no way to take an arbitrary Class object representing a parameterized type, create a corresponding TypeToken, and then set the type parameters for the TypeToken.
However, if TypeToken.toGenericType() is available then that makes it easy.
You can see the current implementation of the parser here:
&nbsp;&nbsp;https://code.google.com/p/jsimpledb/source/browse/trunk/src/java/org/jsimpledb/util/TypeTokenParser.java
Currently it uses reflection to access Types.newParameterizedType() directly (note, it invokes Types.newParameterizedType() instead of TypeToken.toGenericType() because the parser doesn't handle arrays).
I could be completely missing something... if so, I'd be interested to see how you'd rewrite TypeTokenParser.java using only existing public API's.
Thanks.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1645#c8) posted by **benyu@google.com** on 2014-06-27 at 01:26 AM_
---
Were you trying to use toGenericType() to implement newParameterizedType()?
Although it doesn't seem easy to do though? For example, when parsing "List&lt;String>", after calling List.class.toGenericType(), you have TypeToken&lt;List&lt;E>>, but there isn't any easy way to turn that into List&lt;String> unless you use reflection to get the type variable &lt;E> and do substitution using TypeResolver.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1645#c9) posted by **benyu@google.com** on 2014-06-27 at 01:48 AM_
---
Oh. I guess you sort of implied it's what you are going to do: use clazz.getTypeParameters() to get the type vars and use TypeResolver to substitute. So never mind my previous question then.
It still seems like newParameterizedType() is what's really needed.
It was asked before that newParameterizedType() be exposed. That Guice already has it was one of the reasons we haven't done that, yet.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1645#c10) posted by **archie.cobbs** on 2014-06-27 at 02:21 AM_
---
Thanks.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1645#c11) posted by **benyu@google.com** on 2014-06-27 at 02:40 AM_
---
I think you have a perfectly reasonable use case here.
1. Just expose newParameterizedType(). But then we overlap with Guice. And it'd be weird not to also open up newArrayType(), subtypeOf(), supertypeOf() etc.
2. Expose toGenericTye(). It doesn't immediately solve the issue, but it makes it easier to do because you can then use TypeResolver to implement newParameterizedType(). And who knows, there may be other use cases of it.
Or, maybe even more directly:
1. Just offer a TypeToken parser.
Hmm...
---
**Status:** `Research`
Technically, a type token parser can still work, right?
```
for (Class<?> raw : array) {
TypeToken<?> typeToken = TypeToken.parse(raw.getName() + "<?, ?, ?>");
}
```
It's better if you don't have to manually implement WildcardType or any of these Type impls.
Your WildcardType impl wouldn't be equal to the JDK built-in wildcards when you get them through reflection like `method.getGenericReturnType()`.
And then, getUpperBounds() isn't necessarily Object.class. Even if it's "?" literally. If `type` is Enum.class, the upper bound is actually Enum<?>.
The use case you mentioned above seems to call for a different utility: `toWildcardType()`.
Of course, if there is `TypeToken.parse()`, you can perhaps get it with:
```
TypeToken.parse(type.getName() + "<" + Joiner.on(",").join(
nCopies(type.getTypeParameters().length, "?") + ">");
```
If we offer TypeToken.parse(), we should make sure we get the upper/lower bounds right.
Agreed.
Based on earlier use cases in this thread and the one you just brought up, I'm more convinced that a `parse()` utility would be the omnipotent solution to most of these problems.
In contrast, either `toGenericType()` or `toWildcardType()` would only solve a small subset of the problems.  For `newParameterizedType()` to solve your use case, we'd still need `newWildcardType()` and even then, user code is left prone to getting the type bounds wrong:
```
newParameterizedType(Enum.class, newWildcardType()); // Oops, wrong!
```
Compared to providing 5 extra API methods (newParameterizedType, newWildcardType, supertypeOf, subtypeOf, newTypeVariable) that are somewhat hard to use, a simple parse() method is also simpler from API perspective.
Thanks!
By getTypes() not including wildcard types, do you mean this?
```
List<String>.getTypes() =>
[Collection<String>, Iterable<String>, Object]
+ [List<?>, List<? extends Comparable>, List<? extends CharSequence>, Collection<?>, ..., Iterable<?>, ...]
```
?
I believe `List<?>.getTypes()` should return `Iterable<?>` etc.
About exposing the public methods that already sit there, the concerns have been:
1. It's not a single method to make public. It's a pack of them: `newParamterizedType()` `newParamterizedTypeWithOwner()`, `newArrayType()`, `supertypeOf()`, `subtypeOf()`.
2. These methods as they are today (internal utilities only), don't do type checking. So if you call `newParameterizedType(String.class, String.class)`, it will let you. But for a public utility method, that seems a bit too loose.
3. Even if we expose all of them, we still don't have a good enough solution to your "wildcardify" use case. As mentioned earlier, `newParameterizedType(cls, subtypeOf(Object.class))` can easily get the bounds wrong. In contrast, the parse() utility gets the job done: `parse(cls.getName() + "<?>");`
4. Yeah. Guice already has it. So we aren't adding significant values by just duplicating the API here.
Good point about the serialization/deserialization of TypeToken. Thanks!
Here's a tiny [TypeParser](https://github.com/fluentfuture/jparsec-g/blob/master/javaparser/src/main/java/org/jparsec/java/TypeParser.java), and [Types](https://github.com/fluentfuture/jparsec-g/blob/master/javaparser/src/main/java/org/jparsec/java/Types.java)
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1642) created by **kevinb@google.com** on 2014-01-22 at 09:00 PM_
---
One reason we check in our benchmarks is so that people can verify that they get equivalent results in their own environments.  It would be nice if they had a "simple" how-to for running one.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1642#c1) posted by **cgdecker@google.com** on 2014-01-22 at 09:17 PM_
---
Step one: release new Caliper beta so they can actually compile.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1640) created by **skypencil** on 2014-01-22 at 02:13 AM_
---
Hello, I am trying to implement static code analysis tool which detects illegal method call like below:
&nbsp;&nbsp;// an implementation which has a method annotated by @VisibleForTesting
&nbsp;&nbsp;class MyImplementation {
&nbsp;&nbsp;&nbsp;&nbsp;@VisibleForTesting
&nbsp;&nbsp;&nbsp;&nbsp;/\* private */ void method() { ... }
&nbsp;&nbsp;}
&nbsp;&nbsp;// another implementation
&nbsp;&nbsp;class AnotherImplementation {
&nbsp;&nbsp;&nbsp;&nbsp;void method() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new MyImplementation().method(); // illegal method call, because this class is not test code
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;}
To find illegal method calling, we should know the original visibility of annotated element (method in this case). In some case it is difficult to guess original visibility, so I want to enhance @VisibleForTesting to explain it like below:
```
@VisibleForTesting(original = Visibility.PRIVATE)
void method() { ... }
```
I think all static analysis tool which uses this annotation needs method to judge illegality of method call, so I have added methods into Visibility enum in attached diff. It is also good to make this enum simple like com.android.internal.annotations.VisibleForTesting annotation. See https://github.com/android/platform_frameworks_base/blob/8b2c3a14603d163d7564e6f60286995079687690/core/java/com/android/internal/annotations/VisibleForTesting.java
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1640#c1) posted by **christianedwardgruber** on 2014-01-23 at 11:45 PM_
---
If we were to do this, and I am not suggesting we should, we should probably make it value() not original(), so we can just write @VisibleForTesting(PRIVATE).  I think it's really obvious what's going on - the extra verbiage seems superfluous.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1640#c2) posted by **skypencil** on 2014-04-04 at 12:20 PM_
---
Any progress?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1640#c3) posted by **kak@google.com** on 2014-04-04 at 03:18 PM_
---
Do you have some special static analysis tools that make it useful?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1640#c4) posted by **skypencil** on 2014-04-05 at 03:14 AM_
---
Hello, thanks for your reply.
> Do you have some special static analysis tools that make it useful?
I have a plan to implement new FindBugs detector which uses on this annotation. It might be a part of my FindBugs plugin(https://github.com/eller86/findbugs-plugin), or it might be merged into FindBugs itself (I'll try to send a patch).
I wish this post will help you to judge. Thanks.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1640#c5) posted by **skypencil** on 2014-04-08 at 08:55 AM_
---
FYI: simple implementation is here.
https://github.com/eller86/findbugs-plugin/commit/e53e0e168d37101f2e7daeecdc53b148d84125b7
---
In MapMakerInternalMap line 2074:
/*\*
- A counter of the number of reads since the last write, used to drain queues on a small
- fraction of read operations.
*/
final AtomicInteger readCount = new AtomicInteger();
While profiling my code I have noticed that postReadCleanup spends 70% of its exec time incrementing this atomic integer.
Incrementing this atomic integer is about 15% of the get operation.
My measurements were done with a sampling profiler at 20 hz on a 80 core cc-numa intel box,
with 64 threads heavily reading from a guava cache (real code not a benchmark).
It looks to me that this counter's purpose is to drain some queue after a arbitrary number of reads, and its overhead seems a bit excessive to me.
Can this counter be made NON atomic, maybe even non volatile ?
the ensuing race condition might be acceptable by eventually draining the queues but not after exactly 64 reads ?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1634#c1) posted by **zolyfar...@yahoo.com** on 2014-03-24 at 02:32 PM_
---
A followup,
since in my use case the cache access was in a contended hotspot (caching the result of some expensive reflection), I created a LoadingCache implementation which is based on jdk ConcurrentHashMap: https://code.google.com/p/spf4j/source/browse/trunk/spf4j-core/src/main/java/org/spf4j/concurrent/UnboundedLoadingCache.java
This allows me to use a simpler and faster implementation where it makes sense.
This implementation is deprecated by the enhancements done to JDK 1.8 ConcurrentHashMap. (computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction))
I believe it is worth improving the CacheBuilder and provide a more lightweight implementation where the parameter constraints allow?
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1632) created by **dhar...@getjive.com** on 2014-01-10 at 06:10 AM_
---
Java 7's NIO.2 has a Files utility class. I was hoping that, similar to Collections2, you guys would rename the class so it won't conflict for those of us that use both.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1632#c1) posted by **tomas.zalusky** on 2014-01-10 at 07:35 AM_
---
Objects is the same case. Using full name is not so much inconvenient, though, this issue should IMHO handle both cases consistently.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1632#c2) posted by **kak@google.com** on 2014-01-10 at 08:22 AM_
---
Our new naming convention for resolving duplicate class names is "MoreFoos".  So eventually we will have base.MoreObjects to go with java.util.Objects.
Colin should be able to answer whether or not we plan to do the same for Files.
---
**Owner:** cgdecker@google.com
**Labels:** -`Type-Addition`, `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1632#c3) posted by **SeanPFloyd** on 2014-01-10 at 09:07 AM_
---
+1 for MoreFoos. It's way nicer than Foos2!
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1632#c4) posted by **dhar...@getjive.com** on 2014-01-10 at 09:09 AM_
---
I agree, but it would be nice to have it consistent. With some classes being Foos2 and others being MoreFoos, its a little confusing on what to look for.
David Harris
Software Developer | Jive Communications, Inc.
Jive.com| 801.426.5782ext. 1000| dharris@getjive.com
On January 10, 2014 at 2:08:07 AM, guava-libraries@googlecode.com (guava-libraries@googlecode.com) wrote:
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1632#c5) posted by **cgdecker@google.com** on 2014-01-10 at 04:45 PM_
---
We don't currently have any plans to rename Files to MoreFiles (or Files2). Particularly given that our internal Files-like class for working with NIO.2 Paths is called MoreFiles. I hadn't placed much importance on renaming our Files class since it seemed like it would be relatively uncommon to be using both the old java.io.File API and the new file APIs in the same class, and if you aren't using java.io.File there isn't much reason to use our Files class at all.
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1632#c6) posted by **kak@google.com** on 2014-01-10 at 05:13 PM_
---
Re. consistency:
Collections2 is sadly a bit of a wart we're "stuck with". We made the decision to use the "More" prefix a while ago, hence MoreExecutors.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1632#c7) posted by **dhar...@getjive.com** on 2014-01-10 at 05:49 PM_
---
My use case is fairly simple: Im watching a directory for changes to files of a specific extension. Im using NIO2 Files for it newDirectoryStream method, and Guavas Files for the getFileExtension method.
David Harris
Software Developer | Jive Communications, Inc.
Jive.com| 801.426.5782ext. 1000| dharris@getjive.com
On January 10, 2014 at 10:13:21 AM, guava-libraries@googlecode.com (guava-libraries@googlecode.com) wrote:
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1632#c8) posted by **cgdecker@google.com** on 2014-01-10 at 06:40 PM_
---
One way you could avoid having to fully qualify com.google.common.io.Files in the body of your code would be to do a static import of getFileExtension.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1631) created by **jos.k.strauss** on 2014-01-07 at 08:58 PM_
---
In many instances that the Splitter class is used a programmer may want to rejoin it or vice versa. However, instances of Splitter are completely separated from instances of Joiner even though many of the features overlap because they are inverse functions.
It would perhaps be useful to have a method in Splitter called joiner and a method in Joiner called splitter which would create the inverse function if possible, or through an exception.
Alternatively, a third class could be used that would only allow methods that are shared by both Joiner and Splitter such as skipNulls/omitEmptyStrings on(String) and on(char), but not on(Pattern), etc.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1631#c1) posted by **kak@google.com** on 2014-01-07 at 09:03 PM_
---
As of Guava 16, you can make a Converter&lt;String, Iterable&lt;String>> that encapsulates your Joiner/Splitter.
Does that help?
---
**Labels:** `Type-Addition`, `Package-Base`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1631#c2) posted by **kevinb@google.com** on 2014-01-07 at 09:06 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1631#c3) posted by **jos.k.strauss** on 2014-01-07 at 10:36 PM_
---
In response to Comment 1:
Converter would not help for two reasons.
#1 There is no easy way to turn a Splitter/Joiner into a function
#2 The point of the common functionality would be to have a common way of declaring that splitting/joining will be on a specified character/string without having to repeat it.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1631#c4) posted by **kak@google.com** on 2014-01-07 at 10:50 PM_
---
1) You'd declare them separately, like (excuse any typos):
class StringCleaver extends Converter&lt;String, Iterable&lt;String>> {
private static final String SEPARATOR = "!";
private static final Splitter SPLITTER = Splitter.on(SEPARATOR);
private static final Joiner JOINER = Joiner.on(SEPARATOR);
protected String doBackward(Iterable&lt;String> input) {
&nbsp;&nbsp;return JOINER.join(input);
}
protected Iterable&lt;String> doForward(String input) {
&nbsp;&nbsp;return SPLITTER.split(input);
}
}
2) see the constant above
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1630) created by **stephan202** on 2014-01-06 at 10:22 AM_
---
Scenario: in some unit tests, I'd like to test whether some object was (un)registered with an EventBus, similar to Issue 784. I use a construction akin to the following (I am aware of this method's side effect, that's fine for my purposes):
```
private void verifyRegistration(final EventBus eventBus, final Object object, final boolean expectedRegistered) {
try {
eventBus.unregister(object);
assertTrue(expectedRegistered);
} catch (final IllegalArgumentException e) {
assertFalse(expectedRegistered);
}
}
```
Now, it turns out that this does not work in case the object of interest does not define any @Subscribe methods. The documentation for EventBus#unregister states that an IllegalArgumentException is thrown "if the object was not previously registered", but in this case no Exception is thrown. The following two unit tests illustrate the issue more clearly (only the first one passes):
```
@Test(expected = IllegalArgumentException.class)
public void testUnregisterWithSubscriber() {
new EventBus().unregister(new Object() {
@Subscribe
public void handleEvent(final Object event) { }
});
}
@Test(expected = IllegalArgumentException.class)
public void testUnregisterWithNonSubscriber() {
new EventBus().unregister(new Object());
}
```
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1630#c1) posted by **cgdecker@google.com** on 2014-01-06 at 06:16 PM_
---
Hmm... the problem with doing this is that we don't currently store anything at all when an object has no @Subscribe methods, because we only need to store event type -> subscriber mappings. Having to add a whole new Set&lt;Object> for everything that's been passed to register just to make this work seems undesirable to me, though it wouldn't be the end of the world. It does seem slightly preferable for unregister to be throwing an exception if the object was never passed to register regardless of whether or not it has an @Subscribe method though.
---
> Having to add a whole new Set&lt;Object> for everything that's been passed to register
It would be enough to store the non-subscribers. However, they may constitute the majority as it's common to register all newly created objects without any thoughts.
There's an asymmetry in the behavior: While `unregister`&nbsp;seems to try to protect people from accidentally passing a wrong object, `register`&nbsp;accepts everything and even allows registering twice (which is a no-op). Assuming there's a good reason for un-registering throwing (which I personally doubt), the same reason should apply for re-registering.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1628) created by **gareth.o.collins** on 2014-01-04 at 09:04 AM_
---
When cancel is called on an AbstractFuture, it appears that a CancellationException is created:
```
boolean cancel(boolean interrupt) {
return complete(null, null, interrupt ? INTERRUPTED : CANCELLED);
}
private boolean complete(@Nullable V v, @Nullable Throwable t,
int finalState) {
boolean doCompletion = compareAndSetState(RUNNING, COMPLETING);
if (doCompletion) {
// If this thread successfully transitioned to COMPLETING, set the value
// and exception and then release to the final state.
this.value = v;
// Don't actually construct a CancellationException until necessary.
this.exception = ((finalState & (CANCELLED | INTERRUPTED)) != 0) <<<< HERE
? new CancellationException("Future.cancel() was called.") : t; <<<<
releaseShared(finalState);
} else if (getState() == COMPLETING) {
// If some other thread is currently completing the future, block until
// they are done so we can guarantee completion.
acquireShared(-1);
}
return doCompletion;
}
```
&nbsp;&nbsp;}
yet when get is called another CancellationException is created (the first exception isn't used):
```
private V getValue() throws CancellationException, ExecutionException {
int state = getState();
switch (state) {
case COMPLETED:
if (exception != null) {
throw new ExecutionException(exception);
} else {
return value;
}
case CANCELLED:
throw cancellationExceptionWithCause( <<<
"Task was cancelled.", exception); <<<
default:
"Error, synchronizer in invalid state: " + state);
}
}
```
&nbsp;&nbsp;static final CancellationException cancellationExceptionWithCause(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Nullable String message, @Nullable Throwable cause) {
&nbsp;&nbsp;&nbsp;&nbsp;CancellationException exception = new CancellationException(message); <<<
&nbsp;&nbsp;&nbsp;&nbsp;return exception;
&nbsp;&nbsp;}
It would be nice if the creation of the CancellationException on calling "cancel" could be removed. If the user of the future then checks "isCancelled" the creation of the CancellationException object can be avoided entirely.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1628#c1) posted by **cpovirk@google.com** on 2014-01-04 at 04:05 PM_
---
The first CancellationException is used as the cause of the second CancellationException. The idea is to have a record of who called cancel() in case it happens by mistake.
Have you seen performance impact, or did you just notice the redundant instance when looking at the code? We were unsure whether performance would be a problem in practice.
https://github.com/google/guava/commit/e8959ed0f4f1617c22668e55a7f4989b751b776a
---
**Labels:** `Package-Concurrent`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1628#c2) posted by **gareth.o.collins** on 2014-01-04 at 05:04 PM_
---
I was running a yourkit CPU profile of my app and the "new CancellationException" call, whilst not defined as a hot spot, appeared high in the method list when ordered by "Own Time".
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1628#c3) posted by **gareth.o.collins** on 2014-01-04 at 05:11 PM_
---
Would it be possible to have, in a future release, an option on cancel to indicate whether to generate the Exception or not?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1628#c4) posted by **cpovirk@google.com** on 2014-01-06 at 05:32 PM_
---
This is tricky because we neither want to force users to configure exception creation on a per-Future basis nor force them to rely on mutable static configuration that would apply to all Future instances. But maybe mutable static configuration is the least bad option for a debugging aid....
---
**Status:** `Research`
**Labels:** `Type-Addition`
commit https://github.com/google/guava/commit/a8ed2f87e111ef6781b816d683c7e51946295805
added a new api to abstractfuture that allows specializing the cancellation cause.
my main idea for it would be for future subclasses to be able to add additional information, but we could maybe allow subclasses to return `null` and in that case they could eliminate the cancellation cause overhead.
this probably isn't satisfactory though since you probably don't own all the AbstractFuture subtypes you are interacting with.
I do wonder, however, if the recent set of changes to use the TrustedFuture subtype have eliminated most of the overhead here?  One of my goals of the TrustedFuture optimization in AbstractFuture was to eliminate the overhead of propagating cancellation/failure through long chains of transformed futures.
If I can write...
```
cancellationCauseThreadLocal.set(noCause());
future.cancel(false)
```
...then I can also write...
```
((AbstractFuture) future).cancel(false, noCause());
}
```
I guess that we might also lose the ability, in places where we currently catch `CancellationException`, to detect the currently active policy. It's possible that we could smuggle the information into the `CancellationException` (or underlying `Future.Cancellation`) itself. Hmm, but the `ThreadLocal` might not work here, anyway, since the `CancellationException` may be caught by a listener in a different thread. Maybe putting the information in the `CancellationException` or `Future` is actually better for this case?
What else can `ThreadLocal` help us with?
(I do have a bit of the usual bias against `ThreadLocal`, to the point that I initially lean toward the environment variable over `ThreadLocal`. But I'm not sure I have a clear picture here yet.)
Java 8 aside, I was going to say that we could do the right thing with `ForwardingFuture` either by making `ForwardingFuture` implement a `CancelableWithCause` interface or by making a static method that wraps all this logic include a special case for unpacking `ForwardingFuture`. But both of these are kind of evil: The second gives the user no way to override the new `cancel` overload. The first doesn't have that problem (assuming that the new method is `public`), but it may surprise users who discover that their `wrapper.cancel` is no longer being called during cancellation. They can always add the new overload, of course. I suppose that this is no different than what happens to most `Forwarding*` classes when interfaces introduce new methods. (For example, synchronized wrappers need to synchronize the new methods.) Still, it's a little concerning, as I see some `ForwardingFuture.cancel` implementations that really ought to be called (including among our own code -- which of course means that we can change those ones but also means that they're probably "legitimate" and that similar legitimate implementations may appear elsewhere).
One question about Java 8: How interested are people in this optimization on Android? I ask because I see that you CCed some "Android people" on the internal discussion. Maybe we'll need to not only add the Java 8 default method but also add a static method with an `instanceof` check for non-Java-8 users.
 I was thinking that this was an opportunity to reference #1905 and #2075, but we're talking about `ForwardingFuture`, not `AbstractFuture`. `ForwardingFuture` users need to really truly `cancel` or, I suppose, to add a listener to observe cancellation after it happens (which is probably all that the wrapper should be doing, anyway... though that would rule out `nonCancelPropagating`, which fortunately is implemented in a different way).
We're turning off cancellation causes by default in release 19.0:
https://github.com/google/guava/wiki/Release19#commonutilconcurrent
We might conceivably do something more with this later, but I'll close it for now.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1625) created by **electrum** on 2013-12-30 at 09:30 PM_
---
The documentation for CacheLoader.refreshAfterWrite() recommends overriding reload() with an asynchronous version. We use the following in many places and think it could be a good addition to Guava:
public abstract class BackgroundCacheLoader&lt;K, V>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extends CacheLoader&lt;K, V>
{
&nbsp;&nbsp;&nbsp;&nbsp;private final ListeningExecutorService executor;
```
protected BackgroundCacheLoader(ListeningExecutorService executor)
{
this.executor = checkNotNull(executor, "executor is null");
}
public final ListenableFuture<V> reload(final K key, V oldValue)
{
return executor.submit(new Callable<V>()
{
public V call()
{
return load(key);
}
});
}
```
}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1625#c1) posted by **cpovirk@google.com** on 2013-12-30 at 09:35 PM_
---
We have this internally as CacheLoaders.asyncReload. It has about 40 callers. Anyone object to releasing it? Perhaps we should move it to CacheLoader itself, since we've been avoiding creating "Foos" utility types when Foo is an abstract class?
---
**Status:** `Research`
**Labels:** `Type-Addition`, `Package-Cache`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1625#c2) posted by **cpovirk@google.com** on 2013-12-30 at 09:36 PM_
---
In the meantime:
&nbsp;&nbsp;public static &lt;K, V> CacheLoader&lt;K, V> asyncReload(final CacheLoader&lt;K, V> loader,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final Executor executor) {
&nbsp;&nbsp;&nbsp;&nbsp;checkNotNull(loader);
&nbsp;&nbsp;&nbsp;&nbsp;checkNotNull(executor);
&nbsp;&nbsp;&nbsp;&nbsp;return new CacheLoader&lt;K, V>() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public V load(K key) throws Exception {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return loader.load(key);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
```
public ListenableFuture<V> reload(final K key, final V oldValue) throws Exception {
ListenableFutureTask<V> task = ListenableFutureTask.create(new Callable<V>() {
public V call() throws Exception {
return loader.reload(key, oldValue).get();
}
});
executor.execute(task);
return task;
}
public Map<K, V> loadAll(Iterable<? extends K> keys) throws Exception {
return loader.loadAll(keys);
}
};
```
&nbsp;&nbsp;}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1625#c3) posted by **kak@google.com** on 2014-01-03 at 09:01 PM_
---
Thumbs up...it has seen good adoption internally.
---
**Status:** `Started`
**Owner:** kak@google.com
This happened in https://github.com/google/guava/commit/f18ec39405a76ee6c5ef68e4d9da2266f796a9a4
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1620) created by **cpovirk@google.com** on 2013-12-19 at 07:40 PM_
---
Tasks:
- Figure out the proper names for everything. (Internal bug 3102010, comment 10 has some principles for this.)
- Determine which of the escapers for each language we actually want. One possible decision is that we want _none_ of the current escapers. For example, does it make sense for our Java escaper to escape printable non-ASCII characters, as it currently does? At least inside Google, our .java files are UTF-8. Considerations: If it _does_ make sense to escape them, then the escaper should perhaps be named "javaAsciiCharEscaper." Also, is there any chance that the set of characters that we _would_ need to escape would change over time? (For example, aren't there some other "newline-like" characters?) Or might it make sense to escape any confusable characters? Is there a standard enough set of confusable characters (maybe for domain names? though of course it might change), or would it be best to avoid non-ASCII altogether? Maybe this is reason to have both javaAsciiCharEscaper and javaCharEscaper ("javaUnicodeCharEscaper?").
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1613) created by **Eric6iese** on 2013-12-17 at 01:52 PM_
---
I have used the new Bytesources and -sinks for great success in an IO-heavy Java6 project. They were used instead of files whenever simple IO-Resources were needed. What I felt is still missing in guava 15 are array-based Byte- and CharSinks which can be converted into Byte/CharSources afterwards.
As an example of what I mean you'll find two rather naive implementations  based on an internal ByteArrayOutputStream and CharArrayWriter in the attachement which I created for my project. The interface is rather rich since I used them mostly for testing.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1613#c1) posted by **cgdecker@google.com** on 2013-12-17 at 06:57 PM_
---
This is something that I like the idea of and have done some thinking about, but there are no immediate plans.
There are quite a few different ways the API could be designed and I haven't come to any conclusion on what's best. It makes sense to me for these to be general in-memory byte/char storage types (with methods on them for appending bytes/chars directly when you want to), but should they extend Byte/CharSink? Or should they extend Byte/CharSource? Or neither, and just have methods for viewing them as one or the other. Or neither, and they should be in base since they're more generally just byte and char related, and create methods in io that wrap them as a Source/Sink? For example, StringBuilder is similar to what we might want for an actual storage type, other than not having methods for viewing it as an I/O stream/source/sink.
---
**Labels:** `Package-IO`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1613#c3) posted by **Eric6iese** on 2013-12-17 at 08:12 PM_
---
Yep there's a lot of design questions to answer, I guess.
What I think is crucial is the possibility to use the written data directly with a ByteSource/CharSource-Wrapper, even if this could cause undefined results on later write-operations. This shouldn't really be a problem at all as long as you do not let the mutable Buffer but only the Source return from method scope. Always defensively copying the array can be much more risky in the face of OOME.
However, this would rule out the possibility to use wrappers around StringBuilder and the like, since you need the array under direct control.
You can use [jimfs](https://github.com/google/jimfs), which is another google project.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1608) created by **kofemann** on 2013-12-11 at 11:10 AM_
---
Hi,
With java 7 we got try-with-resource semantics.
still need to write
&nbsp;lock.lock();
&nbsp;try {
&nbsp;&nbsp;//do some staff
&nbsp;} finally {
&nbsp;&nbsp;&nbsp;&nbsp;lock.unlock();
&nbsp;}
and it's quite often, finally block is forgotten.
Lock lock = ...;
try (AutoLock l = withLock(lock)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// access the locked resource
}
The class including test attached.
---
OT: I am very curious about Guava team's response. According to links at http://stackoverflow.com/questions/16574353/any-risk-in-a-autocloseable-wrapper-for-java-util-concurrent-locks-lock , it seems the suggestion for adding this feature to Java was rejected.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1608#c2) posted by **cgdecker@google.com** on 2013-12-11 at 05:51 PM_
---
FYI, Guava is still a JDK6 library and can't use AutoCloseable yet.
There's been some debate about this internally, which I'll try to sum up here:
1. Try-with-resources was designed to solve resource management, for example opening and closing OutputStreams. This is actually VERY HARD (and verbose) to do correctly without try-with-resources. By comparison, acquiring and releasing locks is very, very simple. Releasing a lock cannot throw an exception, unlike closing an OutputStream.
2. Because of what try-with-resources was designed for, it's extremely awkward to use for things like locks and "scoping" blocks to certain contexts (for example, a database transaction), because you're required to assign something to a variable in the resource declaration part of the try-with-resources block, but in neither of those cases do you actually need to USE the variable you create. This leads to both unused variable warnings as well as special try-with-resources warnings for unused resources.
3. Despite that, people do seem to REALLY want to use try-with-resources with locks. And while it's unfortunately awkward to do, it does seem mostly harmless. Particularly since it's actually possible to do it in a way that doesn't create a new object each time you acquire a lock*.
Personally, while I would have been happy to recommend doing this had try-with-resources been designed in a way that intentionally supported this type of use, I don't really recommend it given the reality of the situation. I don't want to strongly discourage it either... that seems like a bit of a losing battle from what I can tell. I would suggest implementing it in a way that avoids object creation though.
- Something like this:
&nbsp;&nbsp;private final Lock delegate;
&nbsp;&nbsp;private final Unlocker unlocker; // implements AutoCloseable
&nbsp;&nbsp;FooLock(Lock delegate) {
&nbsp;&nbsp;&nbsp;&nbsp;this.delegate = delegate;
&nbsp;&nbsp;&nbsp;&nbsp;this.unlocker = new Unlocker(delegate);
&nbsp;&nbsp;}
&nbsp;&nbsp;public Unlocker acquireLock() {
&nbsp;&nbsp;&nbsp;&nbsp;lock.lock();
&nbsp;&nbsp;&nbsp;&nbsp;return unlocker;
&nbsp;&nbsp;}
&nbsp;&nbsp;// ... other methods
}
---
**Labels:** `Package-Concurrent`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1608#c3) posted by **kofemann** on 2013-12-11 at 07:41 PM_
---
Just want to comment on point 3.
I believe, the main motivation is simple syntax which we already have with synchronized:
synchronized(this){
&nbsp;&nbsp;...
}
It's natural, with the language which supports block to release resources allocated when leaving the block.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1608#c4) posted by **cgdecker@google.com** on 2013-12-11 at 08:05 PM_
---
I agree that it's natural to want to be able to something similar to a synchronized block with locks... the problem being try-with-resources just doesn't really support that, no matter how much one might want it to.
---
**Status:** `Research`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1605) created by **mindas** on 2013-12-09 at 12:35 PM_
---
In my object hierarchy I am conveniently using Objects.toStringHelper() so that extending object can reuse fields from its superclass, e.g.:
class A {
&nbsp;&nbsp;private X x;
&nbsp;&nbsp;protected Objects.ToStringHelper toStringHelper() {
&nbsp;&nbsp;&nbsp;&nbsp;return Objects.toStringHelper(this)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.add("x", x);
&nbsp;&nbsp;}
&nbsp;&nbsp;public String toString() {
&nbsp;&nbsp;&nbsp;&nbsp;return toStringHelper().toString();
&nbsp;&nbsp;}
}
class B extends A {
&nbsp;&nbsp;protected Objects.ToStringHelper toStringHelper() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return super.toStringHelper()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.add("y", y);
&nbsp;&nbsp;}
&nbsp;&nbsp;public String toString() {
&nbsp;&nbsp;&nbsp;&nbsp;return
&nbsp;&nbsp;}
}
This way, new B().toString() would nicely assemble all fields without knowing particulars of superclasses. Nice.
There's however a problem when some classes use composition, e.g.
class C extends A {
&nbsp;&nbsp;protected toStringHelper() {
&nbsp;&nbsp;&nbsp;&nbsp;return super.toStringHelper()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.add(???);   // there's no way to add all values from B
&nbsp;&nbsp;}
}
something like this would be very useful if existed in ToStringHelper (untested):
@Nonnull
public ToStringHelper addAll(@Nonnull ToStringHelper another) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (ValueHolder valueHolder = another.holderHead.next; valueHolder != null; valueHolder = valueHolder.next) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(valueHolder.name, valueHolder.value);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1605#c1) posted by **mindas** on 2013-12-09 at 12:36 PM_
---
Sorry, there should be no toString() in class B.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1605#c2) posted by **kak@google.com** on 2013-12-09 at 03:25 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1605#c3) posted by **mindas** on 2013-12-09 at 06:09 PM_
---
Correct me if I'm wrong, but #1239 speaks about ToStringHelper working in inherited hierarchies. My point is for it to work in composition.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1605#c4) posted by **cgdecker@google.com** on 2013-12-09 at 06:27 PM_
---
What I think I'd do in this situation is use methods like this:
&nbsp;&nbsp;protected ToStringHelper addToString(ToStringHelper helper);
Then in A, toString() is just
&nbsp;&nbsp;return addToString(Objects.toStringHelper(this));
and you override addToString in B and C.
When you have a field you want to add to your toString, you can just pass your ToStringHelper to its addToString method. Though generally I'd just want something like "b=..." in my toString rather than including B's fields as if they're part of C.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1605#c5) posted by **cgdecker@google.com** on 2013-12-09 at 06:27 PM_
---
Er, that should be "return addToString(Objects.toStringHelper(this)).toString();"
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1605#c6) posted by **mindas** on 2013-12-09 at 06:36 PM_
---
Yes, this is more or less how I do this right now - inverting the logic of TSH and passing it around so that composite classes (or those which use composite classes) could add their own data.
However, unlike typical TSH use case, this approach isn't as declarative nor clear, hence this report.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1597) created by **ian.springer** on 2013-11-30 at 02:25 AM_
---
Add a GWT RPC serializer/deserializer for Ranges.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1597#c1) posted by **ian.springer** on 2013-11-30 at 02:49 AM_
---
I have implemented this and would like to contribute the code. If members of the Guava team agree this would be a useful addition, please assign me a reviewer.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1597#c2) posted by **cpovirk@google.com** on 2013-12-02 at 09:19 PM_
---
Sounds good to me. Have you signed the CLA?
https://developers.google.com/open-source/cla/individual
---
**Status:** `Accepted`
**Labels:** `Type-Enhancement`, `Package-Collect`
We would still be interested in a patch.
@MyRealityCoding Are you still working on this?
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1593) created by **michael.gorski82** on 2013-11-27 at 10:00 PM_
---
I tried to use Guave 15.0 with GWT 2.5.1 but it fails to compile. I use the compiler parameter -strict. In my module gwt.xml I have:
&lt;inherits name="com.google.common.collect.Collect"/>
I my classpath I added:
When I try to compile I get the following error:
Compiling module test.Tttt
&nbsp;&nbsp;&nbsp;Validating units:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ERROR] Errors in 'com/google/common/base/super/com/google/common/base/CharMatcher.java'
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ERROR] Line 760: SmallCharMatcher cannot be resolved
&nbsp;&nbsp;&nbsp;[ERROR] Aborting compile due to errors in some input files
I used a blank gwt project to demonstrate this error.
The project can be found here: https://github.com/confile/gwt-guava-test
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1593#c1) posted by **cpovirk@google.com** on 2013-12-02 at 09:45 PM_
---
It's been a while since I tried to run a GWT project in Eclipse, so I'll need a little hand-holding. How can I launch the project? I see a Tttt.html run configuration, but that seems to launch dev mode, which works fine (perhaps because I can't see to turn -strict on for it). Do I need to launch prod mode? If so, how?
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1582) created by **Eric6iese** on 2013-11-17 at 06:05 AM_
---
The upcoming JDK-8 contains the new Stream-API, which is somewhat comparable to FluentIterable - expect that its core abstraction is the iterator, and not the Iterable. But its pattern to create new Collections after a stream chain is different than guava's:
list.stream().collect(Collectors.toList());
The collect-Method takes a Collector, a somewhat clunky yet powerful interface to build result collections both sequential (by adding single elements) and in parallel (by combining multiple elements via addAll).
The Collector-Interface requires at least the following:
- a Supplier: Builder::new
- an Accumulator: Builder::add
- a Combiner Builder::addAll
- a finisher: Builder::build
The problem is the addAll-Method: In Order to be compatible with the Combiner, it needs to take a Builder as its nput. However, the Builder.addAll methods currently only allows it to add Iterables, not another builder. So the accumulator-function would be something like builder.addAll(otherBuilder.build()), which is not very efficient, especially for Set-Builders.
---
- Make the Builder itself Iterable, so that it can be added to its own addAll-Method.
- Add another addAll-Method overload to ImmutableCollection.Builder which accepts any ImmutableCollection.Builder.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1582#c1) posted by **cgdecker@google.com** on 2013-11-18 at 05:53 PM_
---
A Java 8 version of Guava is a long ways off at this point, as Guava currently still targets Java 6. Java 8 will also require major changes to Guava given that many new things it provides are similar or equivalent to things in Guava.
This is definitely something that's on our radar for things we do want to add, though. It probably wouldn't be in the form of a change to any of the ImmutableCollection Builders, but just a new set of Collectors for creating ImmutableCollections.
---
**Status:** `Research`
**Labels:** `Package-Collect`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1582#c2) posted by **lowasser@google.com** on 2013-11-18 at 10:28 PM_
---
FWIW, even today you can use Collectors.collectingAndThen(Collectors.toList(), ImmutableList::copyOf), which is not at all an unreasonable implementation generally speaking.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1582#c3) posted by **sim.herter** on 2014-08-18 at 08:25 PM_
---
Is there any reason to favor stream.collect(Collectors.collectingAndThen(Collectors.toList(), ImmutableList::copyOf) ) over ImmutableList.copyOf(stream.iterator())?
The first one seems to be a more functional approach (and I looove programming in functional style with JDK8!), but since I see this a lot in my code I think I would prefer the shorter one if nothing technical speaks against it.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1582#c4) posted by **lowasser@google.com** on 2014-08-18 at 08:28 PM_
---
The former would probably work better if your stream is parallel, and I don't think it's any less efficient in general.
Both approaches are going to put the stream into a ArrayList-like structure, and then copy it into the ImmutableList.  ImmutableList.copyOf(Iterator) delegates to ImmutableList.Builder, which is built as approximately a specialized ArrayList.
We have a plan we're working on to use collectors w/ immutable collections and it'll be addresses in an upcoming version of Guava that supports Java8.
The immutable collections now have built-in collectors that will be included in the Guava 21 release.  I think we can actually call this closed?
(We haven't exposed collector-ness in the builders themselves, just collectors, but I think that's what we'd prefer unless we hear compelling reasons to add them into the builders.)  _[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1579) created by **jbel...@datastax.com** on 2013-11-13 at 05:29 PM_
---
Inserting into a binary tree in sorted order is the worst case scenario for a red-black tree like the one backing TreeMultimap, and that's exactly what happens when you call putAll on another TreeMultimap.
Prior art: TreeMap special cases new-from-SortedMap via buildFromSorted.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1579#c1) posted by **lowasser@google.com** on 2013-11-13 at 05:44 PM_
---
_(No comment entered for this change.)_
---
**Owner:** lowasser@google.com
**Labels:** `Type-Performance`, `Package-Collect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1579#c2) posted by **lowasser@google.com** on 2013-11-13 at 05:47 PM_
---
To be clear: is that actually quadratic time?  I understand that it's the worst case scenario, but I'm not sure I follow why that would lead to quadratic time instead of O(n log n).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1579#c3) posted by **jbel...@datastax.com** on 2013-11-13 at 05:56 PM_
---
My apologies, O(n log n) is correct.  I'm not sure if there is a way to edit the issue title.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1579#c4) posted by **lowasser@google.com** on 2013-11-13 at 06:03 PM_
---
_(No comment entered for this change.)_
Pull request welcome.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1578) created by **sj1981** on 2013-11-13 at 08:55 AM_
---
The ServiceExplained wiki page is out of date since it mentions the methods start(), startAndWait() for starting and stop(), stopAndWait() for stopping a service.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1578#c1) posted by **kurt.kluever** on 2013-11-13 at 11:59 AM_
---
Hey Luke,
Would you mind taking a look at this?
Thanks :-)
---
**Status:** `Accepted`
**Owner:** lukes@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1578#c2) posted by **lukes@google.com** on 2013-11-13 at 04:29 PM_
---
I did a quick pass and
&nbsp;\* added details about the new Service methods
&nbsp;\* filled in the section on AbstractService
&nbsp;\* added details about ServiceManager
I think a lot more work should probably be done though, in particular I think we need
&nbsp;\* better motivating examples
&nbsp;\* an AbstractService example
&nbsp;\* maybe mention something about Service + dependency injection, since the two always go together at google?
---
**Status:** `Started`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1574) created by **kevinb@google.com** on 2013-11-09 at 06:08 AM_
---
com.google.common.hash.Hashing.&lt;clinit> : 40-60ms on a Galaxy Nexus
com.google.common.common.base.CharMatcher.&lt;clinit> : 40-60ms on a Galaxy Nexus
This may or may not require deprecating all the constants in CharMatcher in favor of methods like Hashing already uses.  Fixing Hashing will be utterly trivial.
This is fixed for `Hashing`: we use the lazy initialization holder class idiom for all of the static fields. @cgdecker is working on the `CharMatcher` fields.
I've been meaning to make the pitch that we can eliminate most of the eager loading without moving away from fields. (Sorry for not doing so earlier.) We quite possibly should move away from the fields anyway, in part because my workaround is going to at least marginally harm performance, but:
```
private abstract static class ForwardingCharMatcher extends CharMatcher {
// ... obvious implementation goes here ...
}
public static final CharMatcher SINGLE_WIDTH = new ForwardingCharMatcher() {
@Override CharMatcher delegate() {
return singleWidth();
}
};
// etc.
```
Would that delay initialization enough? If so, is it worth doing, or should we just wait this one out?
That would likely be useful as a temporary measure until we can actually remove the fields, since the main issue seems to be with the initialization of classes, which would be delayed by this approach. The problem would be the additional overhead on all `matches()` calls, particularly in a case where JIT doesn't inline the indirection (such as, probably, on Android), since there are now two extra method calls before you get to the implementation. _Probably_ not a big deal, but who knows.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1569) created by **compulinkltd** on 2013-11-05 at 09:39 PM_
---
The Reflection.newProxy(Class, InvocationHandler) method works well as long the client is proxying a raw interface that does not involve generics.  Type erasure becomes a problem for the client when a Class object for a generic interface is supplied.
Would it be possible to supply another version of this method where the first argument is a TypeToken&lt;T> rather than a Class&lt;T> so the client can create proxy instances for an interface that involves generics without having to perform a cast?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1569#c1) posted by **cpovirk@google.com** on 2013-11-05 at 10:20 PM_
---
Ben, I thought that we must have discussed this before, but I couldn't find a record of it. What do you think? On the one hand, I get only a dozen hits in Google code when searching for `<.*[)].*newProxy(Instance)?[(] lang:java`. On the other hand, TypeToken support sounds logical, we don't require a lot of usages to justify most reflection utilities, and I like to make unchecked warnings go away. Of course, that's all assuming that this _is_ safe.... I can never convince myself for sure with TypeToken :) And I guess you could argue that, since proxies necessarily use reflection, you're doing something "unchecked," anyway....
---
**Labels:** `Type-Addition`, `Package-Reflect`
**CC:** benyu@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1569#c2) posted by **benyu@google.com** on 2013-11-05 at 11:32 PM_
---
It doesn't seem safe to me. For example:
static &lt;T> List&lt;T> sneakyCast(final List<?> list) {
&nbsp;&nbsp;return newProxy(new TypeToken&lt;List&lt;T>>() {}, new InvocationHandler() {
&nbsp;&nbsp;&nbsp;&nbsp;return method.invoke(list, args);
&nbsp;&nbsp;});
}
List&lt;String> stringList = new ArrayList<>();
List&lt;Integer> intList = sneakyCast(stringList);
intList.add(1);
If user has to provide a Class (IntList.class for example), the line of method.invoke(list, args) will fail with CCE.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1568) created by **sebastian.davids** on 2013-11-04 at 07:40 AM_
---
---
## &nbsp;T E S T S
Running com.google.common.cache.CacheReferencesTest
Tests run: 5, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 155.376 sec <<< FAILURE!
Results :
Failed tests:
&nbsp;&nbsp;testCleanupOnReferenceCollection(com.google.common.cache.CacheReferencesTest): expected:&lt;1> but was:&lt;2>
@@@@
$ git rev-parse HEAD
cff5df6b48b892574975dc045f6ed3552d4b3d1d
It fails with:
Apache Maven 3.0.5 (r01de14724cdef164cd33c7c8c2fe155faf9602da; 2013-02-19 14:51:28+0100)
Maven home: /opt/local/share/java/maven3
Java version: 1.7.0_40, vendor: Oracle Corporation
Java home: /Library/Java/JavaVirtualMachines/jdk1.7.0_40.jdk/Contents/Home/jre
Default locale: en_US, platform encoding: UTF-8
OS name: "mac os x", version: "10.8.5", arch: "x86_64", family: "mac"
and
Apache Maven 3.0.5 (r01de14724cdef164cd33c7c8c2fe155faf9602da; 2013-02-19 14:51:28+0100)
Maven home: /opt/local/share/java/maven3
Java version: 1.7.0_45, vendor: Oracle Corporation
Java home: /Library/Java/JavaVirtualMachines/jdk1.7.0_40.jdk/Contents/Home/jre
Default locale: en_US, platform encoding: UTF-8
OS name: "mac os x", version: "10.8.5", arch: "x86_64", family: "mac"
and
Apache Maven 3.0.5 (r01de14724cdef164cd33c7c8c2fe155faf9602da; 2013-02-19 14:51:28+0100)
Maven home: /opt/local/share/java/maven3
Java version: 1.8.0-ea, vendor: Oracle Corporation
Java home: /Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/Contents/Home/jre
Default locale: en_US, platform encoding: UTF-8
OS name: "mac os x", version: "10.8.5", arch: "x86_64", family: "mac"
But works with:
Apache Maven 3.0.5 (r01de14724cdef164cd33c7c8c2fe155faf9602da; 2013-02-19 14:51:28+0100)
Maven home: /opt/local/share/java/maven3
Java version: 1.6.0_65, vendor: Apple Inc.
Java home: /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home
Default locale: en_US, platform encoding: MacRoman
OS name: "mac os x", version: "10.8.5", arch: "x86_64", family: "mac"
Running the tests on JDK 1.7/1.8 takes very long compared to running them with JDK 1.6.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1568#c1) posted by **kevinb@google.com** on 2013-11-20 at 08:13 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
**Labels:** `Type-Dev`, `Package-Cache`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1568#c2) posted by **cpovirk@google.com** on 2013-12-09 at 09:24 PM_
---
This might be a 64-bit thing, whether a bug in the test or a 64-bit-specific JIT (or something) problem. I say that because I'm seeing failures and mysterious early terminations when running the test with a 64-bit Linux JDK7. (The mysterious early terminations might conceivably be caused by our internal build system, though I should note that the build system is reporting FAILED and not TIMEOUT.)
...
Running com.google.common.cache.CacheReferencesTest
Tests run: 5, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 1,535.714 sec <<< FAILURE!
Running com.google.common.cache.EmptyCachesTest
&lt;end of log>
...
Running com.google.common.cache.CacheReferencesTest
&lt;end of log>
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1568#c3) posted by **cpovirk@google.com** on 2013-12-09 at 09:54 PM_
---
Here's the failure that I'm getting when I run with a couple flags (-Dtest.include="**/CacheReferencesTest.java" -Dsurefire.useFile=false):
Running com.google.common.cache.CacheReferencesTest
Tests run: 5, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 279.781 sec <<< FAILURE!
testCleanupOnReferenceCollection(com.google.common.cache.CacheReferencesTest)  Time elapsed: 279.67 sec  <<< FAILURE!
junit.framework.AssertionFailedError: expected:&lt;1> but was:&lt;2>
&nbsp;&nbsp;at junit.framework.Assert.fail(Assert.java:47)
&nbsp;&nbsp;at junit.framework.Assert.failNotEquals(Assert.java:283)
&nbsp;&nbsp;at junit.framework.Assert.assertEquals(Assert.java:64)
&nbsp;&nbsp;at junit.framework.Assert.assertEquals(Assert.java:130)
&nbsp;&nbsp;at junit.framework.Assert.assertEquals(Assert.java:136)
&nbsp;&nbsp;at com.google.common.cache.CacheReferencesTest.assertCleanup(CacheReferencesTest.java:179)
&nbsp;&nbsp;at com.google.common.cache.CacheReferencesTest.testCleanupOnReferenceCollection(CacheReferencesTest.java:146)
&nbsp;&nbsp;at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
&nbsp;&nbsp;at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
&nbsp;&nbsp;at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
&nbsp;&nbsp;at java.lang.reflect.Method.invoke(Method.java:606)
&nbsp;&nbsp;at junit.framework.TestCase.runTest(TestCase.java:168)
&nbsp;&nbsp;at junit.framework.TestCase.runBare(TestCase.java:134)
&nbsp;&nbsp;at junit.framework.TestResult$1.protect(TestResult.java:110)
&nbsp;&nbsp;at junit.framework.TestResult.runProtected(TestResult.java:128)
&nbsp;&nbsp;at junit.framework.TestResult.run(TestResult.java:113)
&nbsp;&nbsp;at junit.framework.TestCase.run(TestCase.java:124)
&nbsp;&nbsp;at junit.framework.TestSuite.runTest(TestSuite.java:243)
&nbsp;&nbsp;at junit.framework.TestSuite.run(TestSuite.java:238)
&nbsp;&nbsp;at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:83)
&nbsp;&nbsp;at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:35)
&nbsp;&nbsp;at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:115)
&nbsp;&nbsp;at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:97)
&nbsp;&nbsp;at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
&nbsp;&nbsp;at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
&nbsp;&nbsp;at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
&nbsp;&nbsp;at java.lang.reflect.Method.invoke(Method.java:606)
&nbsp;&nbsp;at org.apache.maven.surefire.booter.ProviderFactory$ClassLoaderProxy.invoke(ProviderFactory.java:103)
&nbsp;&nbsp;at com.sun.proxy.$Proxy0.invoke(Unknown Source)
&nbsp;&nbsp;at org.apache.maven.surefire.booter.SurefireStarter.invokeProvider(SurefireStarter.java:150)
&nbsp;&nbsp;at org.apache.maven.surefire.booter.SurefireStarter.runSuitesInProcess(SurefireStarter.java:91)
&nbsp;&nbsp;at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:69)
Here's the failing assertion:
https://github.com/google/guava/blob/release15/guava-tests/test/com/google/common/cache/CacheReferencesTest.java#L179
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1568#c4) posted by **cpovirk@google.com** on 2013-12-09 at 10:23 PM_
---
Hmm, if the problem is the use of 64-bit JVMs, I have a theory: testCleanupOnReferenceCollection attempts to "fill up heap so soft references get cleared." If the 64-bit JVMs have a bigger heap, this would naturally take much longer, if it happens at all.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1568#c5) posted by **cgdecker@google.com** on 2013-12-09 at 10:36 PM_
---
And it looks like by "fill up heap" it means "create bigger and bigger byte arrays until the array is 1 GB and then just keep creating 1 GB arrays and garbage collecting them".
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1568#c6) posted by **cpovirk@google.com** on 2013-12-10 at 12:23 AM_
---
If that's the problem, then a possible solution is to limit the memory available to Maven's test runner. For now, though, I'm going to suppress the test.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1563) created by **Maaartinus** on 2013-10-28 at 05:41 AM_
---
As requested in
Note also that currently the fastest way to parse an Integer is via Longs.tryParse (this doesn't necessarily mean that accepting non-ASCII must cause a slowdown).
https://microbenchmarks.appspot.com/runs/f32a811c-aeb5-40ac-ae48-07b60256838f
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1563#c1) posted by **kevinb@google.com** on 2013-11-20 at 08:14 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
**Labels:** `Type-Defect`, `Package-Primitives`
This probably was broken back in 2013. We made some changes to at least one of these methods, probably within the past few years. It does seem to be fine now, as demonstrated by tests that we have:
assertNull(Ints.tryParse("\u0662\u06f3"))
assertNull(Longs.tryParse("\u0662\u06f3"))  _[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1562) created by **oleg.kha...@smddev.com** on 2013-10-24 at 10:48 PM_
---
According to the closed https://github.com/google/guava/issues/1264 ImmutableTable should implement Serializable interface like other immutable collections. But in r15 it doesn't. It seems that #1264 should be reopened.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1562#c1) posted by **cpovirk@google.com** on 2013-10-25 at 04:35 PM_
---
For whatever reason, I appear to have interpreted the earlier bug as being about GWT serialization. (And I'm surprised that even GWT serialization works without tagging the class as Serializable.) We should make it "normal Serializable," too.
---
**Status:** `Accepted`
**Labels:** `Type-Enhancement`, `Package-Collect`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1560) created by **Ash2kk** on 2013-10-21 at 10:25 AM_
---
Please, add media type for multipart/form-data MIME type.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1560#c1) posted by **Ash2kk** on 2013-10-21 at 10:28 AM_
---
Hm, constant with that name already exists, but it has application/x-www-form-urlencoded value. Probably name should be something different for newly added constant.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1560#c2) posted by **cgdecker@google.com** on 2013-10-21 at 01:55 PM_
---
This came up recently internally, and the issue with it was that multipart media types require a boundary parameter according to RFC 2046.
---
**Owner:** gak@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1560#c3) posted by **gak@google.com** on 2013-10-21 at 04:36 PM_
---
To elaborate a bit, the feature was requested so that somebody could use the constant in conjunction with is().  The issue, as cgdecker@ mentions, is that multipart/form-data isn't a valid media type by itself because it always requires the boundary parameter.  So, while the constant might make sense for matching, it would be bug-prone for serving content.  The suggested solution for matching in the meantime was to just make a one-off helper that checks the type and subtype specifically.
Given all of that background, can you elaborate on what you were hoping to use it for?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1560#c4) posted by **cpovirk@google.com** on 2013-10-21 at 04:40 PM_
---
(Aside: Is the ambiguity of "FORM_DATA" potentially confusing enough that we should rename it to "FORM_URLENCODED" or something?)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1560#c5) posted by **cgdecker@google.com** on 2013-10-21 at 05:07 PM_
---
I think this may be something that's been discussed before, but a separate type for matching media types vs. representing a complete media type seems like it might be useful. The wildcard MediaType constants feel kind of out of place to me.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1560#c6) posted by **Ash2kk** on 2013-10-22 at 03:27 AM_
---
I was hoping to use it for matching using is() in my code that extracts boundary from request. For now I created a constant using .create() method for that purpose.
p.s. from my point of view FORM_URLENCODED is better than FORM_DATA.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1560#c7) posted by **Ash2kk** on 2013-10-22 at 07:48 AM_
---
Also we use multipart/form-data as response type - in some cases it is convenient to provide multipart response. So multipart/form-data can be used WITHOUT boundary to specify HTTP Accept header, sent from client (that's what we do).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1560#c8) posted by **gak@google.com** on 2013-10-22 at 05:47 PM_
---
Yeah, that's a subtle distinction: multipart/form-data is a valid media _range_, but not a valid media type.  At one point I started the work of making MediaRange a proper type and this does seem like a good argument for finishing that up.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1557) created by **lothix** on 2013-10-16 at 08:57 PM_
---
Issue: InetAddresses.forString throws IllegalArgumentException when given IPv6 address with scope_id instead of returning the correct Inet6Address with scope_id, and scope_id_set populated.
Failing test case:
InetAddress ipv6AddressWithScopeId = InetAddresses.forString("fe80:0:0:0:c1e1:54cf:68bc:9d5e%12");
throws java.lang.IllegalArgumentException: 'fe80:0:0:0:c1e1:54cf:68bc:9d5e%12' is not an IP string literal.
InetAddresses.isInetAddress("fe80:0:0:0:c1e1:54cf:68bc:9d5e%12") return false.
Expected results:
InetAddresses.forString("fe80:0:0:0:c1e1:54cf:68bc:9d5e%12") returns Inet6Address(addr = "fe80:0:0:0:c1e1:54cf:68bc:9d5e", scope_id = 12);
InetAddresses.isInetAddress("fe80:0:0:0:c1e1:54cf:68bc:9d5e%12") returns true.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1557#c1) posted by **kevinb@google.com** on 2013-11-20 at 08:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
**Labels:** `Package-Net`, `Type-Defect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1557#c2) posted by **cgdecker@google.com** on 2014-09-11 at 03:40 PM_
---
_Issue #1844 has been merged into this issue._
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1551) created by **cow...@bbs.darktech.org** on 2013-10-07 at 06:25 AM_
---
I'd like to be able to convert a Range from one bound type to another. For example:
Range&lt;Integer> r = Range.open(5, 10) // (5, 10)
Range&lt;Integer> r2 = r.toClosedOpen(); // [6, 10)
Range&lt;Integer> r2 = r.toClosed(); // [6, 9]
and so on. This will help methods that accept Range with arbitrary bound types convert to formats they need internally (i.e. for loops require closedOpen).
On a side-note, please add @param &lt;C> to the Javadoc to formally define the meaning of C.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1551#c1) posted by **kevinb@google.com** on 2013-10-07 at 01:55 PM_
---
Note that you can convert to closedOpen already using canonical().
Is it necessary to "formally define" the meaning of C? Would it make the class easier to learn? I find 95% of type parameters easier to understand by simply seeing how they appear in the API.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1551#c2) posted by **cow...@bbs.darktech.org** on 2013-10-07 at 02:56 PM_
---
Kevin,
I personally prefer that all parameters be formally defined to prevent users from "reading between the lines" as is often the case when indirect definitions.
Regarding canonical(), I hadn't noticed that. Thank you.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1551#c3) posted by **cgdecker@google.com** on 2013-10-07 at 03:05 PM_
---
Also, converting to closed can be done with ContiguousSet.create(range, domain).range(). A bit awkward, but doesn't seem like something that would be needed that often. Also, consider that if you have a DiscreteDomain (which you must in order to convert any open bound to closed), rather than using a for loop over a closedOpen range, creating a ContiguousSet and doing a for-each loop over it is probably preferable.
---
**Labels:** `Type-Addition`, `Package-Collect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1551#c4) posted by **dimo414** on 2014-04-11 at 01:43 AM_
---
This is a feature I would appreciate.  I am specifically looking to get end-points of my ranges in order to interface with other APIs that expect an explicit start and end, which I have to manually work around now.  A Range.convert(Bound, Bound, DiscreteDomain) method seems useful to me generally.
canonical() isn't ideal since it essentially only gives me the lower element, I still have to call DiscreteDomain.previous() in order to get the last element in the Range.
ContiguousSet.create().range() works for bounded ranges (though it's kludgy), but if either end is unbounded we cannot create the set in the first place.  It seems reasonable to want to transform (5, inf) into [6, inf) but using ContiguousSet prevents that.
Apparently at some point we added ContiguousSet.range(BoundType, BoundType), and that's what you need here.
Sorry, sometimes we go through bug scrub a bit too fast.
Is there anything we *can *do in that case?  I suppose we might be able to
change the bound type of the bounded end, but that's it...
On Thu, Oct 8, 2015 at 4:06 PM kevinb9n notifications@github.com wrote:
> Sorry, sometimes we go through bug scrub a bit too fast.
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/1551#issuecomment-146712283.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1548) created by **cpovirk@google.com** on 2013-09-30 at 04:19 PM_
---
Earlier discussion:
> Where is it specified that Function implementations should wrap checked exceptions in UTE? UTE is from java.lang.reflect package, so it's surprising to me to see us special-casing UTE in Future utility.
> I think that this is the specification here :) Probably it applies only to this method and not to Function in general, and likely it was intended to be somewhere more... visible :)
People do appear to be taking advantage of the feature, as demonstrated by a search for files containing both "new UndeclaredThrowableException" and "com.google.common.util.concurrent.Futures."
It's an odd feature, though, and it might be wise to convert them to AsyncFunctions. Their computations won't necessarily be asynchronous, but AsyncFunction is allowed to throw any kind of exception, making UndeclaredThrowableException unnecessary.
It's something that I would like to see happen but never have been able to justify. I assume that you're interested because it lets you remove the GWT emulation of UndeclaredThrowableException? If nothing else, I can float this in front of future 20%ers (and add it to my ever-growing list of "quick tasks" for myself, but that probably won't accomplish much :)).
How much does removing the type buy you? I could try to bump it up if there's a big win.  _[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1547) created by **cpovirk@google.com** on 2013-09-30 at 02:09 PM_
---
We got a question here: http://stackoverflow.com/q/19074393/28465
https://google.github.io/guava/apidocs/com/google/common/base/CharMatcher.html#BREAKING_WHITESPACE
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1531) created by **bentler** on 2013-09-12 at 06:19 PM_
---
The method get(K, Callable<? extends V>) allow you to perform actions while the entry (segment, actually) is locked for modification, in addition to creating the cache entry.  For my use case, I add some registration for notifications that the cache entry is stale to a ConcurrentMap.  If an entry is stale, I do not necessarily need to reload it and so I only load entries on demand.
I request a similar method invalidate(Object, Runnable) wherein I can remove this registration.  This will allow me to reclaim memory in the ConcurrentMap and do less processing.
Better yet, please add a flag to allow RemovalListener to be executed under the segment lock during removal.  This is ultimately more useful to me since I would like to cleanup the registration regardless of whether the entry was manually evicted or explicitly removed.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1531#c1) posted by **wasserman.louis** on 2013-09-12 at 07:18 PM_
---
Can you explain what you're doing with the separate registration notifications, and why  you need them in the first place?
I don't believe we currently make any guarantees about some of the concurrency behavior you seem to be taking as a given.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1531#c4) posted by **bentler** on 2013-09-12 at 10:35 PM_
---
I'm converting an existing application-wide cache for our internal Java EE-based application framework that was implemented via ConcurrentHashMap, for which we never updated the entries.  When these items were requested, we either retrieved the existing item from the ConcurrentHashMap or built it by querying the database.
The application currently recieves notifications that data for e.g. a particular database table has been updated.  This cache is the sole outlier not reacting to these notifications, so I'm extending our cache to also be updated according to these notifications.  Being that all sessions are accessing the cache, I want to minimize synchronization as much as possible so as not to affect the scaleability of our framework.
The only additional guarantee that I require for concurrency is that when an item is added to the cache, it is already registered in the ConcurrentMap from events to cache keys.  To simplify things, I'll say there is a 1-to-1 or 0-to-1 relationship between events and cache items.
I suppose that if I never removed the registrations for events, I wouldn't even require anything beyond a simple ConcurrentMap, since I would only have to add the registration before loading the items in the cache.
Rather than implementing a ComputingCache, I chose to use get(K, Callable<? extends V>), primarily because I would like to avoid unnecessary queries from the database, but I prefer doing duplicate queries to locking any longer than absolutely necessary.  Therefore, if the entry is currently empty (checked with getIfPresent), I fetch the data and build the item and then I call get(K, Callable<? extends V>) and the only thing that my Callable does is register for the event and return the item that I just built.
In order to clear out the registrations for items that were no longer present, I initially had implemented a RemovalListener that removed the current registration.  However, I saw that the documention stated that they were executed synchronously, rather than concurrently with the removal, so delving into the code I saw that they were not executing under the lock and so if I use them, I do not have the guarantees that I require.
A possible workaround for me would be to have the RemovalListener call get(K, Callable<? extends V>) to add a NULL object to the Cache and remove the registration.  Afterward, the call to get(K, Callable<? extends V>), I would invalidate() the entry.  This should result in valid behavior in the sense I require but it is awkward, does a lot of extra work, makes rebuilding cache items more likely, and it could still leave the registration intact for invalidated Cache entries in some cases.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1531#c5) posted by **bentler** on 2013-09-13 at 05:16 AM_
---
The other concurrency guarantee required is to register for events before querying.
Instead of the convoluted workaround I described, I think that for now I'm going to use Striped&lt;Lock>.  If Striped&lt;Lock> hashed in the same way as LocalCache, I would have just used the same number of stripes as the concurrencyLevel that I set on my Cache, but I guess I'll instead used a factor of 4 times as many locks and see how that works.
Some much simplified, but still mostly representative code:
&nbsp;&nbsp;&nbsp;&nbsp;private static Cache&lt;String, Item> itemCache = CacheBuilder.newBuilder().concurrencyLevel(CACHE_CONCURRENCY_LEVEL).build();
```
private static ConcurrentMap<String, String> eventCache = new ConcurrentHashMap<String, String>();
```
...
public Item getItem(String cacheId) {
&nbsp;&nbsp;&nbsp;&nbsp;Item item = null;
&nbsp;&nbsp;&nbsp;&nbsp;String eventId = calculateEventId(cacheId);
&nbsp;&nbsp;&nbsp;&nbsp;Callable&lt;Item> itemQuerier = new Callable&lt;Item>() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eventCache.put(eventId, cacheId);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Item item = queryItem(cacheId);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return item;
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;Lock lock = stripedLock.get(cacheId);
&nbsp;&nbsp;&nbsp;&nbsp;lock.lock();
&nbsp;&nbsp;&nbsp;&nbsp;try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;item = itemCache.get(cacheId, itemQuerier);
&nbsp;&nbsp;&nbsp;&nbsp;} finally {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.unlock();
&nbsp;&nbsp;&nbsp;&nbsp;}
```
return item;
```
}
private void removeItem(String cacheId) {
&nbsp;&nbsp;&nbsp;&nbsp;Lock lock = stripedLock.get(cacheId);
&nbsp;&nbsp;&nbsp;&nbsp;lock.lock();
&nbsp;&nbsp;&nbsp;&nbsp;String eventId = calculateEventId(cacheId);
&nbsp;&nbsp;&nbsp;&nbsp;try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eventCache.remove(eventId);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;item = itemCache.invalidate(cacheId);
&nbsp;&nbsp;&nbsp;&nbsp;} finally {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.unlock();
&nbsp;&nbsp;&nbsp;&nbsp;}
}
No access to itemCache occurs outside these two methods and eventCache is only read elsewhere.
// run from a separate thread
public void processEvents(List&lt;String> eventIds) {
&nbsp;&nbsp;&nbsp;&nbsp;// clear out all items
&nbsp;&nbsp;&nbsp;&nbsp;for (String eventId : eventIds) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String cacheId = eventCache.get(eventId);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (cacheId != null) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;itemCache.invalidate(cacheId);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
```
// push out item updates to all widgets
for (Session session : getSessions()) {
for (String eventId : eventIds) {
ConcurrentMap<String, Widget> widgets = session.getWidgets();
Widget widget = widgets.get(eventId);
Item item = getItem(widget.getCacheId();
widget.update(item);
}
}
```
}
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1525) created by **xaerxess** on 2013-09-09 at 01:16 PM_
---
Please consider adding Strings.repeat(char character, int count) method similar to Strings.repeat(String, int). The new method could have simpler implementation and be little less verbose than Strings.repeat(String.valueOf(char), int).
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1519) created by **cpovirk@google.com** on 2013-08-29 at 09:11 PM_
---
1. Are there better names? (Do they deserve the _same_ name with disambiguating parameters? Do they at least deserve names that are near one another alphabetically?) Here's an internal-only doc with some discussion: https://docs.google.com/a/google.com/document/d/1Ry0Jx0tIJ8zFX9TnH6dbVCRGlYwrlkyiyekSYnay1VA/edit ("Possible rename of bulk Future methods")
2. Would successfulAsList be better if it returned a list containing only the successes rather than a list containing interleaves successes and nulls? (Previously, people might have wanted to match up indexes (though IIRC my survey showed that few if any users were doing this). Nowadays, they can use successfulAsMap, which makes it easier to associate values with keys (which is probably more natural than associating them with indexes, anyway.) (Less plausible advantage: A user might really want to distinguish between "returned null" and "failed." This would let him do that, as the "failed" entries would go away.) Another option is to add a third method with the failures stripped, but I doubt we'd want to bother.
3. When an allAsList input fails, should we cancel the other inputs? Should this be configurable? Here's an internal-only thread with some discussion: https://groups.google.com/a/google.com/d/topic/java-users/9utRs2xAafk/discussion
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1519#c1) posted by **cpovirk@google.com** on 2014-08-13 at 01:49 PM_
---
An internal user would like to be able to access the result as a Future&lt;ImmutableList&lt;V>> rather than a Future&lt;PlainListThatHappensToBeImpossibleToMutate&lt;V>>. He's using a framework that requires known immutable objects. He can transform(), of course, but if we make change (2), this would be an opportunity to switch to ImmutableList (at the cost of some verbosity to users who don't care).
An additional feature to consider is some kind of configuration of logging (or, more generally, of handling of failures). Our current policy can be a bit spammy, but we would fear dropping important messages if we turned logging off universally.
This still doesn't make the API clear. Future&lt;ImmutableList&lt;Foo>> f = Futures.collect(list).allMustSucceed(), etc.? There are many options.
---
In a paper from 2005[1], Pagh et al. proposed a bloom filter extension that is also capable of removing elements. Getting the number of items stored within is also possible through this extension. Do you see any possibility to extend Guava to also support these features?
[1] http://dl.acm.org/citation.cfm?id=1070548
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1506) created by **cpovirk@google.com** on 2013-08-14 at 07:10 PM_
---
Possibly not a big deal, since the caller of retainFrom is necessarily accepting that he may allocate a whole new String, but possibly easily avoidable. Here's an internal discussion, reposted externally with light editing.
---
https://github.com/google/guava/blob/1da5e0cf3f30aa1eeee8c0160977b00e0a9f58e6/guava/src/com/google/common/base/CharMatcher.java
Seems to imply that:
for (String s : input) {
&nbsp;&nbsp;CharMatcher.WHITESPACE.retainFrom(s);
}
Will allocate input.size() new instances of NegatingMatcher.
Is it worth lazily caching (no synchronization as it's idempotent) or even
high reuse?
---
I think it would be sensible for e.g.
CharMatcher.DIGIT.retainFrom(text) not to have to create a new
negation-of-digits matcher every time it's called, yes.
If the easiest way to achieve that is to have CharMatcher memoize the
result of negate(), then yes, that seems like a reasonable thing to
do; I don't think that anyone expects CharMatcher instances to be
particularly lightweight.  (I wouldn't bother creating the negation
ahead of time, though.)
It looks like doing that might help in a _few_ other areas, too; e.g.
common.net.MediaType.parse(), which has references to a few different
the point of use, every time.
Alternatively you could take a look at making CharMatcher.retainFrom()
not require a negated matcher.  From what I can see, most people who
call negate() are already keeping the reference anyway, sometimes
after calling precomputed() (which you wouldn't want to do in general,
I suspect.)
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1502) created by **ssaarela** on 2013-08-09 at 12:04 PM_
---
@AllowConcurrentEvents should probably have @Inherited meta-annotation so that AnnotatedHandlerFinder would see it even if a class gets proxied e.g. with a dynamic sub class using cglib. This happens for example when using declarative transaction handling (@Transactional).
A simple workaround is to have a separate listener object for the proxied class.
I would find it most intuitive NOT to have (Async)EventBus synchronize anything and just handle any required synchronizations on my own, but adding @Inherited is probably the simplest backwards compatible way to get async subscriptions on a proxied listener working.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1502#c1) posted by **cgdecker@google.com** on 2014-06-26 at 10:51 PM_
---
Yeah, @AllowedConcurrentEvents is weird. I'm feeling pretty convinced that users should just do synchronization themselves on subscriber methods that shouldn't be called concurrently. Not having @AllowConcurrentEvents doesn't even prevent multiple EventBuses from calling the method concurrently, much less other callers that aren't an EventBus.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1499) created by **j...@barop.de** on 2013-08-07 at 03:32 PM_
---
Would be nice/useful to add the following method to "com.google.common.base.Objects"?
/**
&nbsp;\* Helper to cast the given object to the given type.
&nbsp;*
&nbsp;\* The cast is to an exact same type. Casting to super-types is not supported.
&nbsp;*
&nbsp;\* @param targetType The type to cast to
&nbsp;\* @param object     The object which gets casted to the targetType
&nbsp;\* @return The given object casted to the given type or <code>null</code> if
&nbsp;\*         the given object is from another type.
&nbsp;*/
&lt;T> T exactCast(Class&lt;T> targetType, Object object)
My primary use-case to reduce the boilerplate code in equals() implementations:
/**
&nbsp;\* Version with exactCast()
&nbsp;*/
public boolean equals(Object o) {
&nbsp;&nbsp;&nbsp;&nbsp;if (o == null) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if (MyClass.class != o.getClass()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;&nbsp;}
```
return Objects.equal(this.fieldOne, other.fieldOne)
&& Objects.equal(this.fieldTwo, other.fieldTwo);
```
}
/**
&nbsp;\* Version with exactCast()
&nbsp;*/
public boolean equals(Object o) {
&nbsp;&nbsp;&nbsp;&nbsp;MyClass other = exactCast(MyClass.class, o);
```
return other != null
&& Objects.equal(this.fieldOne, other.fieldOne)
&& Objects.equal(this.fieldTwo, other.fieldTwo);
```
}
Not supporting super-types is because it's hard (impossible?) to do in GWT and the primary use-case for me is casting to the exact class.
If you find the feature useful I'd love to contribute the code for it.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1499#c1) posted by **SeanPFloyd** on 2013-08-08 at 03:19 PM_
---
it might make sense to return Optional&lt;T> instead
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1499#c3) posted by **cgdecker@google.com** on 2013-08-08 at 03:40 PM_
---
FYI, checking that "MyClass.class != o.getClass()" rather than "!(o instanceof MyClass)" is bad practice for equals, because it means that myClass.equals(mySubclass) == false while mySubclass.equals(myClass) == true, which breaks the equals() contract. For that matter, mySubclass.equals(mySubclass) == false unless you override equals() in the subclass, and again, that tends to break the equals contract.
In general, the best way to deal with ensuring the object passed to equals is both non-null and an instance of the correct type is just:
if (o instanceof MyClass) {
&nbsp;&nbsp;MyClass other = (MyClass) o;
&nbsp;&nbsp;// check stuff
}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1499#c4) posted by **j...@barop.de** on 2013-08-15 at 12:17 AM_
---
Thanks for your reply!
Checking for a `class`&nbsp;constant is indeed a bad idea because it causes touble in subclasses. But isn't the `instanceof`&nbsp;approach suffering from the same problem when `equals()`&nbsp;get's overridden?
Example:
static class A {
&nbsp;&nbsp;@Override
&nbsp;&nbsp;public boolean equals(Object obj) {
&nbsp;&nbsp;&nbsp;&nbsp;return obj instanceof A;
&nbsp;&nbsp;}
}
static class B extends A {
&nbsp;&nbsp;@Override
&nbsp;&nbsp;public boolean equals(Object obj) {
&nbsp;&nbsp;&nbsp;&nbsp;return obj instanceof B;
&nbsp;&nbsp;}
}
a.equals(b) => true
b.equals(a) => false
What about not checking for a `class`&nbsp;constant but for `this.getClass()`. This would guarantee symmetry with subclasses.
new proposal:
&lt;T> T sameTypeOrNull(T object, Object other)
Then `equals()`&nbsp;could be implemented like this:
public boolean equals(Object o) {
&nbsp;&nbsp;&nbsp;&nbsp;MyClass other = sameTypeOrNull(this, o);
```
return other != null
&& Objects.equal(this.fieldOne, other.fieldOne)
&& Objects.equal(this.fieldTwo, other.fieldTwo);
```
}
---
The `o instanceof MyClass`&nbsp;approach works with proxies, which is quite important. Overriding it in a subclass can't be done in a consistent way.
Testing `o.getClass() == getClass()`&nbsp;is symmetrical and allows sane overriding, but doesn't work with proxies. This is usually considered worse than the first approach.
Using `o.getClass() == MyClass.class`&nbsp;seem to be plain wrong, neither proxies nor overriding work.
There's no really good solution, as supporting both proxies and overriding correctly requires a helper method, see http://www.artima.com/lejava/articles/equality.html
---
I see that the article I linked is a bit too long for what I wanted to clarify. The point is that you sometimes want the subclass instances to be able to `equals`&nbsp;to a superclass class instance (proxies or different implementation of the same concept) and sometimes not (subclasses adding new properties like ColoredPoint). For this a `canEqual`&nbsp;method is needed.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1499#c7) posted by **piotr.findeisen** on 2013-11-13 at 12:49 PM_
---
> Testing `o.getClass() == getClass()`&nbsp;is symmetrical and allows sane overriding, but doesn't work with proxies.
For this, I have a "magic" getNonProxyClass() and test
`getNonProxyClass(o.getClass()) == getNonProxyClass(getClass())`
when I need to support proxies (like in JPA entities) but do not want `canEqual`&nbsp;stuff (which works unless someone forgets to override it).
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1497) created by **richard.rebhann** on 2013-08-06 at 08:39 AM_
---
Something like
ClassPath.addDir(File)
could be useful when working with JNI and its classloader mess.
Although not portable, there is some existing way to do that using reflection, see http://stackoverflow.com/a/7884406 or https://forums.oracle.com/message/4290936#4290936.
See also this closed bug report for history: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4280189
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1491) created by **ogregoire** on 2013-08-01 at 10:40 AM_
---
Sometimes when debugging from the logs it's useful to distinguish two identical but different objects.
I suggest an option for ToStringHelper (as a factory method, or as a ToStringHelper option method like omitNulls()) to insert the identity hashCode as returned by System.identityHashCode().
This way we can construct the following String:
"ClassName@1f2e3d4c{x=1}"
Currently, I usually do it like this:
&nbsp;&nbsp;return Objects.toStringHelper(getClass().getSimpleName() + '@' + Integer.toHexString(System.identityHashCode()))
&nbsp;&nbsp;&nbsp;&nbsp;.add("x", 1)
&nbsp;&nbsp;&nbsp;&nbsp;.toString();
or something like this:
&nbsp;&nbsp;return Objects.toStringHelper(this)
&nbsp;&nbsp;&nbsp;&nbsp;.add("@", System.identityHashCode(this))
&nbsp;&nbsp;&nbsp;&nbsp;.add("x", 1)
&nbsp;&nbsp;&nbsp;&nbsp;.toString();
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1491#c1) posted by **cgdecker@google.com** on 2013-08-02 at 09:21 PM_
---
Hmm... I don't feel like your current solutions are too bad, and this doesn't feel like a very common need to me. A quick search has shown 2 places in our codebase using the identity hash code with toStringHelper. Still, I don't have a very strong opinion on this.
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1489) created by **itaitai2...@yahoo.com** on 2013-07-30 at 11:06 PM_
---
More or less like this:
Futures.addCallback(future,
&nbsp;&nbsp;&nbsp;&nbsp;new FutureSuccessCallback&lt;Result>() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void onSuccess(Result result) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;new FutureFailureCallback&lt;MyFutureExceptionWrapper>() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void onFailure(MyFutureExceptionWrapper myFutureExceptionWrapper) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
}, MoreExecutors. ....);
public class FutureExceptionWrapper extends Throwable {
&nbsp;&nbsp;&nbsp;&nbsp;public FutureException() {
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;public FutureException(Throwable t) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(t);
&nbsp;&nbsp;&nbsp;&nbsp;}
}
public class MyFutureExceptionWrapper extends FutureExceptionWrapper {
&nbsp;&nbsp;&nbsp;&nbsp;private int errorCode
```
public     MyFutureException(Throwable t) {
this(t, -1);
}
public     MyFutureException(Throwable t, int errorCode) {
super(t);
this.errorCode = errorCode;
}
```
}
Internally the api should do the following before calling onFailure
if (throwable instanceof MyFutureExceptionWrapper)
&nbsp;&nbsp;&nbsp;&nbsp;ex = (MyFutureExceptionWrapper) throwable;
&nbsp;&nbsp;&nbsp;&nbsp;ex = new MyFutureExceptionWrapper(throwable);
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1489#c1) posted by **kevinb@google.com** on 2013-11-20 at 08:52 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
**Labels:** `Package-Concurrent`, `Type-Addition`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1487) created by **Ben.Manes** on 2013-07-24 at 09:35 AM_
---
## Background
Guava's Cache uses a ConcurrentLinkedQueue per segment as a buffer of the recently accessed entries, drained when the lock is held. This avoids contention by amortizing the lock acquisition, rather than banging against it on every operation to update the policy state.
A CLQ may suffer contention at the tail due to all threads spinning in a CAS loop to append their element. This is reduced by having one per segment, by default 4, though hot entries will hash to the same segment and accessing threads may contend. In ConcurrentLinkedHashMap this is reduced by having a global policy and best-effort simulating a CLQ per core, mapped by the thread id, and recombining in LRU order during the drain. Regardless, under simulated load CLQ does show up as a hotspot in a profiler.
Two proposals are provided. (A) provides closer semantics to the current behavior. (B) provides the fastest alternative (prefered).
## Proposal (A)
An elimination stack is useful in any scenario where messages need to be transferred quickly and FIFO ordering is not required, by allowing operations to cancel out. This is ideal in an object pool and fits the requirements for Guava's usage of the recencyQueue.
The stack works by allowing operations to cancel out, which is linearizable. When contention is detected by a failed CAS on a treiber stack, a thread backs off to an arena, selects a location, and attempts to transfer the element to/from another thread. This reduces contention on the stack's top by spreading the CAS operations across isolated references. In benchmarking an object pool, I see significant performance gains under contention and similar single-threaded performance.
An implementation is provided at,
https://github.com/ben-manes/multiway-pool/blob/8c55b8e03f84d97df964caf82cae456197762a7a/src/main/java/com/github/benmanes/multiway/EliminationStack.java
## Proposal (B)
In CLHM the buffers record both read and writes for replaying against the internal policy, whereas in Guava's cache only recording of reads is maintained. As a cache is best-effort bounding based on semi-intelligent logic, it may be argued that the recencyQueue could be lossy.
This could be done by using a ring buffer (padded AtomicReference array), retaining an index cursor for the reader and writers, and use lazySet to null out consumed slots. A read could be lost or processed out-of-order, definitely so under load. This approach has a significant benefit of not creating garbage and minimizing contention. An implementation is trivial enough to not be provided, though easy to sketch out if desired.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1487#c1) posted by **Ben.Manes** on 2013-07-29 at 01:58 AM_
---
I implemented (B) in CLHM by separating the read and write buffers. The result was a significant speedup as there is no more GC pressure, no CAS operations, and overall less contention.
In a synthetic test with 100% reads...
&nbsp;\- CacheBuilder: 14M/s
&nbsp;\- CLHM: 50M/s
&nbsp;\- CHM: 184M/s
&nbsp;\- CHMv8: 225M/s
&nbsp;\- CacheBuilder: 2-3M/s
&nbsp;\- CLHM: 95-109M/s
&nbsp;\- CHM: 220-240M/s
&nbsp;\- CHMv8: 318-330M/s
Because CLHM has a single LRU, the processor's cache invalidation on volatile fields has a noticeable impact. If there was a ProcessorLocal storage option the most egregious problems could be mitigated, and is currently simulated as much as possible using the thread's id.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1487#c2) posted by **cgdecker@google.com** on 2013-07-29 at 01:54 PM_
---
_(No comment entered for this change.)_
---
**Owner:** lowasser@google.com
**CC:** fry@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1487#c3) posted by **lowasser@google.com** on 2013-07-29 at 05:38 PM_
---
I would like to see an implementation sketch or reference implementation, please.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1487#c4) posted by **Ben.Manes** on 2013-07-29 at 05:42 PM_
---
CLHM has typically been the reference with code & tests ported.
http://code.google.com/p/concurrentlinkedhashmap/source/browse/src/main/java/com/googlecode/concurrentlinkedhashmap/ConcurrentLinkedHashMap.java
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1487#c5) posted by **Ben.Manes** on 2013-07-29 at 11:25 PM_
---
let me know if you need a trimmed down example if that's too much code to go trekking through.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1487#c6) posted by **lowasser@google.com** on 2013-07-30 at 09:19 PM_
---
I'm pursuing B), but question: could it not result in memory leaks?  Could an AtomicReference.lazySet result in an indefinitely held reference to an object?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1487#c7) posted by **Ben.Manes** on 2013-07-30 at 10:54 PM_
---
Technically, but only if the cache is inactivity for the remainder of the application. This is already possible with the CLQ, though. The difference is that since the lazily set buffer is racy and lossy, a linear read until a null slot doesn't mean that the buffer is empty. If that was assumed by #cleanUp, an inactive cache may retain stale references even if cleanUp is called periodically. I'd have the explicit cleanUp calls walk the entire array instead. I wouldn't do that on the amortized calls, just the explicit one through the Cache interface where the extra guarantee / performance hit is expected.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1487#c8) posted by **lowasser@google.com** on 2013-08-08 at 09:36 PM_
---
I've got an implementation.  (FWIW, one alternative might be to do the ring buffer of WeakReference objects; that wouldn't create any more garbage than the CLQ, but would have other advantages.)
I'm not sure where your benchmarks live, or how to port them to Caliper?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1487#c9) posted by **Ben.Manes** on 2013-08-08 at 10:32 PM_
---
I do have benchmarks, including Caliper. However Caliper doesn't handle multi-threading very well and this typically showed up on synthetic testing.
http://code.google.com/p/concurrentlinkedhashmap/source/browse/src/test/java/com/googlecode/concurrentlinkedhashmap/benchmark/
See the Profile class for a simple hook. I ran this independently for an ad hoc benchmark or through a profiler for allocation & cpu hotspots (Yourkit and JProfiler). Make sure to use -XX:+UseCondCardMark to avoid some JVM introduced contention.
http://code.google.com/p/concurrentlinkedhashmap/source/browse/src/test/java/com/googlecode/concurrentlinkedhashmap/Profile.java
Dominic's analysis tool is useful as an independent analysis,
https://github.com/tootedom/google-cache-builder-inv
WeakReference would require creating an object wrapper on every read. The removal of any heap allocation on a read was a nice feel good improvement, though minor, and WeakReferences have some GC implications. I decided against it as I didn't think it was necessary, but you're welcome to experiment and use them if you prefer to.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1487#c10) posted by **Ben.Manes** on 2013-08-15 at 09:27 AM_
---
One challenge, at least in CLHM, has been that minor changes can significantly impact the performance profile. The removal of some delay, e.g. a volatile read & write, will increase the rate of accessing the remaining volatile fields. This causes them to be more contested, leading to bus storms, that result is worse performance due to the lack of a backoff strategy. This makes it frustrating to tune at a micro-level.
In the past we've tried to hash to different shared queues to minimize threads colliding. The lack of processor-local is always frustrating because the shared state demolishes performance.
It may be worth revisiting the idea of using thread-local queues, which are added as weak references in a shared registry. The victim thread that drains could iterate the registry to apply pending tasks and remove a dead thread's queue. These queues would still be ring buffers, to keep them fast and lightweight. This approach might create enough isolation to see a substantial gain, so its worth prototyping.
Unfortunately that approach deviates from what Guava's Cache is structured around. It may be considered incompatible as per-segment hashing for selecting the queue is fundamental, so mixing that with thread locals may not be worth it. The structure was chosen to optimize soft reference caching when that was the encouraged strategy (prior to having efficient alternatives) to remove the object overhead when decorating with ReferenceMap, etc.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1485) created by **juancn** on 2013-07-19 at 09:48 PM_
---
The javadoc of ImmutableList states:
> Note: Although this class is not final, it cannot be subclassed as it has no public or protected constructors.
> Thus, instances of this type are guaranteed to be immutable.
You can create a subclass of ImmutableList as long as it resides on com.google.common.collect.
It would suffice to seal the Jar to prevent subclasses.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1485#c1) posted by **kevinb@google.com** on 2013-07-19 at 09:51 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1485#c2) posted by **kevinb@google.com** on 2013-11-20 at 08:53 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
**Labels:** `Package-General`, `Type-Dev`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1481) created by **rafael.wth** on 2013-07-18 at 03:16 PM_
---
I think, this would be a great addition to Guava caches because some expensive objects can be serialized and deserialized easily while only be constructed under quite some effort, for example if they require computation as in my use case.
A native solution could fix the problem with the RemovalListener not being synchronized on a cache entry's key which I mentioned in my blog entry.
I think this would really make a great feature!
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1481#c1) posted by **cgdecker@google.com** on 2013-07-18 at 03:25 PM_
---
_(No comment entered for this change.)_
---
**Owner:** lowasser@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1481#c2) posted by **kevinb@google.com** on 2013-07-18 at 04:47 PM_
---
imho, if you have to specify your marshalling logic anyway, then in many(most?) cases you would really want a memory-managed cache. Which would be ridiculously more GC-friendly, and let you actually configure the exact amount of memory your cache can use (which many people want), but would be a completely different implementation from what we have.
---
Well, I agree about the marshalling logic but only as long as we are speaking about abstract persisting caches and not about caches that fall back to the local file system which I believe is the most typical use case. (At least Ehcache is offering this feature.)
Also, such a file fallback cache would use the exact same amount of memory as any other Guava cache since the extra persisted entries are only stored on disk and not in memory. Of course, the interface contract would change slightly, since entries would not be removed from a cache but they would overflow to disk and get retrieved whenever they are required as long as someone implemented a logic that allows to specify other behavior. (Again, Ehcache allows such logic but brings other disadvantages.)
I wrote an implementation in form of a wrapper to a "normal" Guava caches: https://github.com/raphw/guava-cache-overflow-extension
At least for my use case where (de-)serialization is way cheaper than construction, this works really well.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1481#c4) posted by **bentler** on 2013-09-12 at 06:24 PM_
---
I have a different use case that would benefit from making the RemovalListener synchronized on a cache entry's key.  See https://github.com/google/guava/issues/1531
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1474) created by **hangcsapda** on 2013-07-11 at 09:36 AM_
---
If you read a text file with Files.toString(File, Charset) into a String, and your input file did not contain a newline at the end (blah-blahEOF), the resulting String will carry an extra (and I think redundant) newline char.
System: Linux amd64
java version "1.7.0_25"
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1474#c1) posted by **hangcsapda** on 2013-07-11 at 09:41 AM_
---
Forgot to mention: the extra newline gets put to the end.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1474#c2) posted by **hangcsapda** on 2013-07-11 at 10:36 AM_
---
I did further debug and if the file ends in a new line, .toString() keeps that and doesn't put an extra.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1474#c3) posted by **cgdecker@google.com** on 2013-07-11 at 02:52 PM_
---
I can't reproduce this. I just created a file with no newline, read it with Files.toString, and got a string with no newline. Also, take a look at the tests in FilesTest, specifically testToString (https://github.com/google/guava/blob/master/guava-tests/test/com/google/common/io/FilesTest.java#L111). Among other things, it reads the file ascii.txt (https://github.com/google/guava/blob/master/guava-tests/test/com/google/common/io/testdata/ascii.txt) which has no newline and asserts that it's equal to the constant String ASCII, which also has no newline.
Are you sure the file you're reading doesn't have a newline on the end? If it doesn't, could you give me a simple test case to reproduce this?
---
**Labels:** `Type-Defect`, `Package-IO`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1473) created by **benjamin.j.mccann** on 2013-07-10 at 06:52 PM_
---
It would be great to put test size annotations in guava-testlib (https://code.google.com/p/guava-libraries/source/browse/#git%2Fguava-testlib%2Fsrc%2Fcom%2Fgoogle%2Fcommon%2Ftesting)
These annotations allow splitting tests up by size (i.e. whether they have external dependencies, how long they take to run, etc.) For more information see the Google testing blog post (http://googletesting.blogspot.com/2010/12/test-sizes.html).
These annotations are already included in Android (see android.test.suitebuilder.annotation.SmallTest). It would be great to make them available to the rest of the Java world and very easy since the source is already there. I've attached the files I'd like to see added, which I took from the Android source simply changing the package name and copyright notice.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1473#c1) posted by **kak@google.com** on 2013-07-10 at 07:35 PM_
---
_(No comment entered for this change.)_
---
**Owner:** cgruber@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1473#c2) posted by **lowasser@google.com** on 2013-07-10 at 08:11 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1473#c3) posted by **benjamin.j.mccann** on 2013-07-10 at 08:16 PM_
---
I'm not sure why you say that? It seems like it'd fit well with guava-testlib (not the main guava project). There are lots of things there that are test oriented common code like https://github.com/google/guava/blob/master/guava-testlib/src/com/google/common/testing/TearDown.java
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1473#c4) posted by **benjamin.j.mccann** on 2014-07-16 at 08:48 AM_
---
Any thoughts on this one? This library class is used extensively within Google, so it's very sad to see it missing from Guava.
Maven and Gradle both have the ability to run Junit classes with category annotations. But right now each project has to create their own annotations. It'd be great to have a set of standard ones to rely on.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1472) created by **cpovirk@google.com** on 2013-07-10 at 12:01 AM_
---
Colin, have you ever looked at the class's users? I just went through them, and I don't feel great about most of them. Probably a majority of them are of the form:
flushQuietly(stream);
stream.close(); // or closeQuietly(stream)
And I think we're confident that this flush+close pattern is unnecessary or even harmful, as discussed on issue 1086.
Most of the other callers are otherwise sketchy -- usually just people who don't want to deal with exceptions, sadly often in methods called "flush" that a caller might naively expect to throw if there are problems. I wouldn't feel bad inlining the try-catch into them. The best caller I saw was someone who was wrapping a ByteArrayOutputStream in an OutputStreamWriter and who then wanted to flush the OutputStreamWriter without dealing with IOException. (I'm not even sure that IOException is impossible there: Might the process of character encoding throw it? I supposed I'd be willing to believe that that happens in this particular case only due to "programmer error," but that suggests some kind of unchecked exception rather than the "catch and log" flushQuietly. Hmm, and closeQuietly (about which I also have reservations, naturally) would function just as well there.)
We're talking &lt;30 callers total here.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1466) created by **itt...@wix.com** on 2013-07-03 at 06:20 AM_
---
Hi,
We have several places where we need to load an entire dictionary (Map&lt;K,V<) on startup and then reload that entire dictionary every 5 minutes.
The dictionary source is remote (RPC/Rest/DB) and the dictionary changes together at all times.
An example for this can be the running A/B tests or running feature toggles; These change relatively infrequently and it is ok to get a stale copy for a few minutes (hence the 5 minutes refresh).
I'd like to be able to do something like this:
LoadingCache&lt;Key, Graph> graphs = CacheBuilder.newBuilder()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.refreshAllAfterWrite(5, TimeUnit.MINUTES)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.build(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new CacheLoader&lt;Key, Graph>() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Graph load(Key key) { // no checked exception
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new UnsupportedOperationException ("single key loading is unsupported");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public ListenableFuture&lt;Graph> reload(final Key key, Graph prevGraph) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new UnsupportedOperationException ("single key loading is unsupported");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Map&lt;K,V> loadAll(Iterable<? extends K> keys){ // i ignore the keys
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return getAllGraphsFromDatabase();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public ListenableFuture&lt;Map&lt;Key,Graph>> reloadAll() { //i really don't need any keys here
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// asynchronous!
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListenableFutureTask&lt;Map&lt;Key,Graph>> task = ListenableFutureTask.create(new   Callable&lt;Map&lt;Key,Graph>>() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Graph call() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return getAllGraphsFromDatabase();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;executor.execute(task);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return task;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});
Additionally I'd like to be able to specify "refreshAllAfterWrite" which will trigger the call reloadAll.
Would be happy to specify more about our usecase if needed.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1466#c1) posted by **cgdecker@google.com** on 2013-07-03 at 03:03 PM_
---
It sounds to me like you could just create a Supplier&lt;Map&lt;K, V>> that loads your whole map, then wrap it with Suppliers.memoizeWithExpiration(supplier, 5, MINUTES). Then just have a method for getting the Map that calls memoizingSupplier.get().
---
**Owner:** lowasser@google.com
**Labels:** `Package-Cache`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1466#c2) posted by **itt...@wix.com** on 2013-07-03 at 04:40 PM_
---
So my code should call a method that does something like:
public V get(K key){ return supplier.get().get(key);}
instead of interacting with the cache?
that's possible, i don't know if this is really clean but possible.
Actually after reading a bit it seems that memoizeWithExpiration doesn't work async so is not relevant for us (i'm referring to this issue https://github.com/google/guava/issues/872 Am I wrong?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1466#c3) posted by **cgdecker@google.com** on 2013-07-03 at 05:36 PM_
---
Ah, yes, memoizeWithExpiration wouldn't reload asynchronously. This does feel a lot like a single-element cache, since you're really just dealing with loading a single Map rather than doing any of the key-level caching LoadingCache is designed for.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1466#c4) posted by **itt...@wix.com** on 2013-07-03 at 07:10 PM_
---
Yeah. Except for the need to hide the supplier.get call I really prefer the single element cache because that is what I need.
Do you happen to know what's the status of that issue?
wrote:
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1466#c5) posted by **cgdecker@google.com** on 2013-07-03 at 07:24 PM_
---
I'm gonna mark this as a duplicate of that issue. Maybe Louis knows more about the status of that issue, though I think there isn't much to report... it's in the Research bucket which means it needs more investigation when we have time (and more information and use cases from people who want it).
In the meantime you could just create a LoadingCache using a single dummy key and use the refreshAfterWrite() policy to handle refreshing for you.
---
**Status:** `Duplicate`
**Merged Into:** #872
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1466#c6) posted by **cgdecker@google.com** on 2013-07-03 at 07:30 PM_
---
(Or, I should say, I think you could do that. I'm not an expert on caching stuff.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1466#c7) posted by **itt...@wix.com** on 2013-07-04 at 03:46 AM_
---
We actually have our own homebrew single element cache we wrote so I'll avoid the hacks while I can but thanks.
wrote:
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1466#c8) posted by **iwalkalone7** on 2014-04-23 at 11:38 AM_
---
I need this too....is this already done?
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1464) created by **e...@technoparkcorp.com** on 2013-07-01 at 09:24 PM_
---
Would be nice to have a static method {{Iterators.unique(Iterator&lt;T>)}}, which filter out duplicates in a sorted iterator.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1464#c1) posted by **cgdecker@google.com** on 2013-07-02 at 03:49 PM_
---
I could have sworn there was another issue requesting something like this, but I couldn't find it.
---
**Labels:** `Type-Addition`, `Package-Collect`
**CC:** lowasser@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1464#c2) posted by **cpovirk@google.com** on 2013-07-02 at 04:06 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1464#c3) posted by **e...@technoparkcorp.com** on 2013-08-09 at 07:41 AM_
---
maybe this is related: https://github.com/google/guava/issues/524
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1464#c4) posted by **e...@technoparkcorp.com** on 2013-08-09 at 07:58 AM_
---
In my case an Iterable is of unlimited size. That's why I can't save it anywhere and then remove duplicates. I really need to filter them out on the fly. That's why iterables are for, right? To be optionally unlimited in size
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1464#c7) posted by **e...@technoparkcorp.com** on 2013-08-09 at 09:23 AM_
---
This is how I implemented it in my project:
public final class Distinct&lt;T> implements Iterator&lt;T> {
&nbsp;&nbsp;&nbsp;&nbsp;private final transient Iterator&lt;T> origin;
&nbsp;&nbsp;&nbsp;&nbsp;private final transient Set&lt;T> seen = new LinkedHashSet&lt;T>(0);
&nbsp;&nbsp;&nbsp;&nbsp;private final transient AtomicReference&lt;T> recent =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new AtomicReference&lt;T>();
&nbsp;&nbsp;&nbsp;&nbsp;public Distinct(final Iterator&lt;T> iterator) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.origin = iterator;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;&nbsp;public boolean hasNext() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (this.recent.get() == null && this.origin.hasNext()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final T next = this.origin.next();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!this.seen.contains(next)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.seen.add(next);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.recent.set(next);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this.recent.get() != null;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;&nbsp;public T next() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!this.hasNext()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new NoSuchElementException();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this.recent.getAndSet(null);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;&nbsp;public void remove() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new UnsupportedOperationException();
&nbsp;&nbsp;&nbsp;&nbsp;}
}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1464#c8) posted by **cpovirk@google.com** on 2013-08-09 at 07:15 PM_
---
I'm going to rename this bug to be specifically about sorted iterators, as the original post requested. Thanks for digging up issue 524 about unsorted inputs. I'll follow up more there about that case.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1464#c9) posted by **phil.h.smith** on 2014-04-26 at 06:46 PM_
---
My use case wants a way to take the union of several potentially large subsets of a common space, presented as sorted iterators.  mergeSorted and collapseDuplicates would do that nicely.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1461) created by **kak@google.com** on 2013-06-28 at 05:36 PM_
---
(Migrating this from an internal issue to an external issue...)
---
I'm seeing plenty of examples of hashBytes(foo.toByteArray()) where 'foo' is of a type that basically always wants to be hashed that way.  The ability to implement a constant Funnel doesn't really make this any slimmer.
What if we had the interface that is like "Comparable" to Funnel's Comparator?
public interface Hashable {
}
&nbsp;Hasher putObject(Hashable hashable);
## &nbsp;HashCode hashObject(Hashable hashable);
FWIW, I like this more and more each time I think of it.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1461#c1) posted by **cgdecker@google.com** on 2013-06-28 at 05:47 PM_
---
I like the sound of this.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1461#c2) posted by **kak@google.com** on 2013-06-28 at 06:19 PM_
---
Small issue: It would be nice if protobufs implemented Hashable, but unfortunately protobufs don't have a Guava dependency yet.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1461#c3) posted by **kevinb@google.com** on 2013-06-28 at 06:41 PM_
---
Well, that's their problem. :-)
---
**Status:** `Research`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1457) created by **kak@google.com** on 2013-06-26 at 07:42 PM_
---
We have a ConcatenatedHashFunction in Hashing that allows us to generate a HashFunction with arbitrary bit length (which we use for Hashing#goodFastHash).
Initially, we thought we might need to expose this in case we ever changed the #goodFastHash implementation and users need to be able to continue generating compatible hashes, but since we've intentionally randomized the seed for GFH, that reason doesn't exist anymore.
Dumping this into the research category in case anyone wants to contribute ideas.
@wfhartford Thanks - I'm going to try to push this through our API review process next week.
Do you have any suggestions for the name of the static factory method in Hashing? I'm not necessarily in love with the following API:
public static HashFunction concatenatedHashFunction(HashFunction... hashFuncs) { ... }
Thanks,
Thanks - I just submitted a CL to add Hashing.concatenating(), with both varargs and Iterable<HashFunction> versions. It should be mirrored out shortly (and will be in Guava 19.0).
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1450) created by **dale.wijnand** on 2013-06-17 at 10:52 AM_
---
I sometimes find myself with an optional that I want to transform, calling a method that returns an Optional.
It would be nice if there were a transformAndConcat for Optional as well, so my Optional&lt;A> is transformed into an Optional&lt;B> not an Optional&lt;Optional&lt;B>>.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1450#c1) posted by **kurt.kluever** on 2013-06-17 at 04:46 PM_
---
---
**Labels:** `Type-Addition`, `Package-Base`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1450#c2) posted by **kurt.kluever** on 2013-06-17 at 04:46 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1450#c3) posted by **dale.wijnand** on 2013-06-17 at 06:03 PM_
---
```
Iterables.tryFind(Optional.presentInstances(optional.transform(function).asSet()), Predicates.alwaysTrue())
```
Would be nice to just do:
```
optional.transformAndConcat(function)
```
(or flatmap, but that breaks the current convention :D)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1450#c4) posted by **dale.wijnand** on 2013-06-17 at 06:10 PM_
---
One take of the implementation is something like this: https://gist.github.com/dwijnand/5798899
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1450#c5) posted by **lowasser@google.com** on 2013-06-17 at 06:30 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1450#c6) posted by **dale.wijnand** on 2013-06-17 at 07:56 PM_
---
Yes
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1450#c7) posted by **kelseyfrancis** on 2013-08-28 at 11:15 PM_
---
This method would be very useful. It seems like a trivial implementation on Optional&lt;T> is:
```
<V> Optional<V> transformAndConcat(Function<? super T, Optional<V>> function) {
return transform(function).or(Optional.<V>absent());
}
```
On Android, wouldn't you want to avoid the allocations caused by the
On Thu, Mar 9, 2017, 8:37 AM Sergey <notifications@github.com> wrote:
> We need it on Android. Our minSdkVersion is 16 so we can't use
> java.util.Optional yet and won't be able to for several years.
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/1450#issuecomment-285352848>, or mute
> the thread
> .
>
(My teammates understand this better than I and may correct me.)
On Thu, Mar 9, 2017 at 12:48 PM, Adam Gent <notifications@github.com> wrote:
> v22 is going to backport to JDK6 with the JDK8 reference.
>
Such methods don't get added to the backport.
>
> that. If possible maybe make a new namespace or something? Maybe
> com.google.common8 or something.
>
Any library (i.e., a jar that will get used on classpaths outside its own
control) that depends on Guava and wants to serve both Java 8+ users and
Java 7- users will have to publish two parallel artifacts just as we do.
This is a little annoying, but the separate namespace would make things a
backport, they'll have to go further and fork their codebase (again, just
as we do). But such features should only be Java8-specific ones (we think),
which would have forced that fork anyway.
--
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
> Any library (i.e., a jar that will get used on classpaths outside its own
> control) that depends on Guava and wants to serve both Java 8+ users and
> Java 7- users will have to publish two parallel artifacts just as we do.
I'm not sure if we're decided yet whether to recommend that others release parallel artifacts or whether to recommend that they release a single version that depends on the backport, asking users to substitute the mainline if desired. @netdpb should know.  _[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1449) created by **jamie.spencer.86** on 2013-06-17 at 12:30 AM_
---
Three or four months back, I recall a few users of the library submitting issues concerning throwing exceptions when an object does not meet a condition.
Would an alternative method to Functions.forPredicate and an addition method to Optional not suffice the issue?
---
static enum Functions {
&nbsp;&nbsp;&nbsp;;
&nbsp;&nbsp;&nbsp;public static &lt;T> Function&lt;T, Optional&lt;T>> guard(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final Predicate<? super T> p) {
```
// more likely defined as a static class member
return new Function<>() {
public Optional<T> apply(T t) {
return p.apply(t) ? of(t) : absent();
}
};
```
&nbsp;&nbsp;&nbsp;}
}
static class Optional&lt;T> {
&nbsp;&nbsp;&nbsp;public abstract &lt;X extends Throwable> T
&nbsp;&nbsp;&nbsp;orElseThrow(Supplier<? extends X> factory) throws X;
}
final Class&lt;T> clas;
final Object o;
...
T t = guard(isInstanceOf(clas)).apply(o).transform(cast())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.orElseThrow(Exceptions.Suppliers.classCast("%s not of %s", o, clas));
Despite more flexibility, the above example was fairly function-oriented; here is the example without guard():
T t;
if (!clas.isInstance(clas))
&nbsp;&nbsp;&nbsp;throw Exceptions.classCast(format("%s not of %s", o, clas));
t = (T)o;
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1449#c1) posted by **wasserman.louis** on 2013-06-17 at 12:55 AM_
---
Why wouldn't you just write
T t = clas.cast(o);
...since the Class.cast method would throw the ClassCastException for you?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1449#c2) posted by **jamie.spencer.86** on 2013-06-17 at 01:08 AM_
---
Normally, you would, but for the sake of showing some example, I would write it the other way.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1449#c3) posted by **jamie.spencer.86** on 2013-06-17 at 01:12 AM_
---
Generally:
T t = guard(predicate).apply(o).transform(function)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.orElseThrow(throwableSupplier);
vs
T t;
if (!predicate.apply(o))
&nbsp;&nbsp;&nbsp;throw x;
t = function.apply(o);
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1449#c4) posted by **lowasser@google.com** on 2013-06-17 at 04:59 PM_
---
This seems like a duplicate of issue 856 in many ways...
As usual, I'm leery of adding lots more Function and Predicate sugar.  In all honesty, I find the second example you give more readable than the first -- except I wouldn't bother with the Predicate and the Function objects, I'd just make them normal method invocations:
if (!good(o)) {
&nbsp;&nbsp;throw new FooException();
}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1449#c5) posted by **jamie.spencer.86** on 2013-06-17 at 07:02 PM_
---
Honestly, I'm more concerned with the fact that I can do a lot more with an Optional, in general.  I'd just like to have a method for throwing an exception given that there are methods for providing default values from instances and Suppliers, and even passing other Optional.  I don't care as much for guava providing Functions.guard(); it's just the means in which to provide a test; just so long as the result yields an Optional.
I'd feel as if Optional.or(Supplier<? extends T> s) does just as much as Optional.orElseThrow(Supplier<? extends X> x) throws X would.
imperative:
return optional.isPresent() ? optional.get() : s.get();
if (!optional.isPresent())
&nbsp;&nbsp;&nbsp;throw x.get();
return optional.get();
functional:
optional.or(s);
optional.orElseThrow(x);
I feel as if I'd use it a lot, as I like using Suppliers when I can, and I like having objects around more so than static utilities.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1449#c6) posted by **xaerxess** on 2013-09-06 at 10:15 AM_
---
Optional.orElseThrow was rejected in issue #1121.
On the other hand it's part of [http://download.java.net/jdk8/docs/api/java/util/Optional.html#orElseThrow(java.util.function.Supplier) Java 8's Optional].
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_
---
Just as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.
And the doc says: "true if the class being tested is assignable from the given class"
https://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1444#c1) posted by **kevinb@google.com** on 2013-06-25 at 11:56 PM_
---
Holy crap. This is horrible, isn't it?
Btw, why doesn't everyone stick with isSupertypeOf / isSubtypeOf?  I don't know why, but 'assignable from' always makes me stop and painstakingly puzzle it out.  Apparently threw a ton of people for a loop here, too.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1444#c2) posted by **kevinb@google.com** on 2013-06-26 at 12:02 AM_
---
Solution A:
Just change the impl, doc and tests in-place to do what the method name advertises.
Solution B:
Create Predicates.supertypeOf(Class) and Predicates.subtypeOf(Class).  Deprecate assignableFrom() with the instruction "to do what this method name implies it is doing, call supertypeOf(); to continue doing what it is actually doing, call subtypeOf()".
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1444#c3) posted by **sameb@google.com** on 2013-06-26 at 12:10 AM_
---
supertypeOf & subtypeOf doesn't accurately capture interface usage to me.  Supertype/subtype sound like subclassing (or extending if all interfaces), not implementing.  assignableFrom/To doesn't seem to have that issue... so I vote solution (A).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1444#c4) posted by **christianedwardgruber** on 2013-06-26 at 12:13 AM_
---
Implementations are subtypes of the interface, by definition.
I vote B.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1444#c5) posted by **sameb@google.com** on 2013-06-26 at 12:20 AM_
---
Sure.  But my first thought is definitely thinking "InputStream is assignable to Closeable" and not "InputStream is a subtype of Closeable" (maybe because subtype is so close to subclass in my head, and subclass seems even further from the truth, even if it is also technically true)?
We haven't gotten around to doing anything about this :( That might be OK as Java 8 method references make simple `Predicate` instances easier to create. If we do do anything, we will follow the decision we recently made on `TypeToken` to use the `isSupertypeOf`/`isSubtypeOf` naming style.
Yeeeeeeah, so we're finally doing this. :-/  Guava 20 will have Predicates.subtypeOf() and deprecate assignableFrom() for it.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1441) created by **orionllmain** on 2013-06-07 at 08:17 PM_
---
The problem with FutureCallback that it requires to implement two methods: onComplete and onFailure. This means that we can not use lambdas to implement FutureCallback. It would be nice to write code like this:
ListenableFuture&lt;Integer> future = executor.submit(() -> getValue());
Futures.onComplete(future, (Integer result) -> {
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(result);
});
Futures.onFailure(future, (Throwable t) -> {
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(t);
});
To achieve this one can add two additional interfaces:
public interface FutureCompletionCallback&lt;V> {
&nbsp;&nbsp;&nbsp;&nbsp;public void onSuccess(V result);
}
public interface FutureFailureCallback {
&nbsp;&nbsp;&nbsp;&nbsp;void onFailure(Throwable t);
}
And the folling methods to Futures class:
public static &lt;V> void onComplete(ListenableFuture&lt;V> future, FutureCompletionCallback<? super V> callback)
public static &lt;V> void onFailure(ListenableFuture&lt;V> future, FutureFailureCallback callback)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1441#c1) posted by **cgdecker** on 2013-06-08 at 06:29 PM_
---
I'm not sure we want to get in to adding methods that are only useful because they work well with lambdas just yet. If you're using JDK 8, you could always just use your own helper methods like:
public void onFailure(ListenableFuture<?> future, Block<? super Throwable> block) {
&nbsp;&nbsp;Futures.addCallback(future, new FutureCallback&lt;Object>() {
&nbsp;&nbsp;&nbsp;&nbsp;@Override public void onSuccess(Object result) {}
```
@Override public void onFailure(Throwable throwable) {
block.accept(throwable);
}
```
&nbsp;&nbsp;});
}
---
**Labels:** `Package-Concurrent`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1441#c2) posted by **orionllmain** on 2014-04-09 at 12:41 PM_
---
Are you sure now? Java 8 is out and we definitely should have two distinct methods.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1441#c3) posted by **orionllmain** on 2014-04-10 at 03:21 PM_
---
Also, there is a problem with the current onFailure(Throwable) method. Can you tell how to handle different types of throwables? Use instanceof?
I think it is much better to have a method:
public static &lt;V> void onResult(ListenableFuture&lt;V> future, FutureResultCallback&lt;V> callback);
and two interfaces:
interface FutureResult&lt;V> {
&nbsp;&nbsp;&nbsp;&nbsp;V get() throws Exception;
}
interface FutureResultCallback&lt;V> {
&nbsp;&nbsp;&nbsp;&nbsp;void onResult(FutureResult&lt;V> result);
}
Usage:
ListenableFuture&lt;Integer> future = ...
Futures.onResult(future, new FutureResultCallback&lt;Integer>() {
&nbsp;&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;&nbsp;public void onResult(FutureResult&lt;Integer> result) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.get();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (NumberFormatException ex) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (CancellationException ex) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
});
This exception handling is more natural for Java programs.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1441#c4) posted by **lukes@google.com** on 2014-04-10 at 03:29 PM_
---
you can already do the futureresultcallback style thing using addListener.  the only difference is that you need to deal with InterruptedException and unwrapping the ExecutionException
final ListenableFuture&lt;Integer> future = ...;
future.addListener(new Runnable() {
&nbsp;&nbsp;@Override public void run() {
&nbsp;&nbsp;&nbsp;&nbsp;try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// get uninteruptibly to avoid InterruptedException since we know the future is done.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Uninterruptibles.getUninterruptibly(future);
&nbsp;&nbsp;&nbsp;&nbsp;} catch (ExecutionException e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (e.getCause() instanceof NumberFormatException) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;} catch (CancellationException e) {
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;}, executor);
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1441#c5) posted by **orionllmain** on 2014-04-10 at 03:39 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1441#c6) posted by **cgdecker@google.com** on 2014-04-10 at 03:48 PM_
---
Why are you trying to avoid instanceof? There's nothing particularly wrong with instanceof.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1439) created by **cow...@bbs.darktech.org** on 2013-06-02 at 05:02 PM_
---
The issue of trimming or skipping empty strings comes up a lot. For example, see issue #450 and #708. This RFE was rejected twice but I believe addressing it in the Javadoc would help.
Here is my own use-case and a workaround: I need join three arguments and skip any empty strings (notably classifier in this case):
Joiner.on('.').skipNulls().join(artifact.getGroupId(), artifact.getArtifactId(), artifact.getClassifier());
In any case, it turns out there is a simple workaround, passing in Strings.emptyToNull(artifact.getClassifier()) instead of artifact.getClassifier().
So, to recap. Please add Joiner.skipEmptyStrings() or document workarounds for this and other common use-cases.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1439#c1) posted by **lowasser@google.com** on 2013-09-25 at 09:52 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-ApiDocs`, `Package-Base`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1433) created by **AaronJWhiteside** on 2013-05-28 at 09:34 PM_
---
In JEE7 CDI (CDI 2.0) is enabled by default (without a beans.xml needing to be present), with no standardized way of disable it.
com.google.common.util.concurrent.ServiceManager is annotated with @Singleton and has a constructor...
&nbsp;&nbsp;@Inject ServiceManager(Set&lt;Service> services) {
&nbsp;&nbsp;&nbsp;&nbsp;this((Iterable&lt;Service>) services);
&nbsp;&nbsp;}
[2013-05-23T15:08:35.664-0700] [glassfish 4.0] [SEVERE] [] [javax.enterprise.system.core] [tid: _ThreadID=34 _ThreadName=admin-listener(2)] [timeMillis: 1369346915664] [levelValue: 1000] [[
&nbsp;&nbsp;Exception while loading the app : CDI deployment failure:WELD-001408 Unsatisfied dependencies for type [Set&lt;Service>] with qualifiers [@Default] at injection point [[BackedAnnotatedParameter] Parameter 1 of [BackedAnnotatedConstructor] @Inject com.google.common.util.concurrent.ServiceManager(Set&lt;Service>)]
org.jboss.weld.exceptions.DeploymentException: WELD-001408 Unsatisfied dependencies for type [Set&lt;Service>] with qualifiers [@Default] at injection point [[BackedAnnotatedParameter] Parameter 1 of [BackedAnnotatedConstructor] @Inject com.google.common.util.concurrent.ServiceManager(Set&lt;Service>)]
The same WAR also fails to deploy on Firefly 8.0 with a similar error.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c1) posted by **kurt.kluever** on 2013-05-28 at 09:36 PM_
---
_(No comment entered for this change.)_
---
**Owner:** lukes@google.com
**CC:** cgruber@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c2) posted by **cgruber@google.com** on 2013-05-28 at 09:56 PM_
---
Oi. The problem here is that (as I understood it) @Inject was added to make it an injectable class in both Guice and Dagger, to avoid having to manually create them in a module.  In both systems, this would not be created early (with some notable exceptions).  But certainly not just because it is in the classpath and annotated.
I don't know that much about CDI except from very ancient memory, but it seems to me that CDI is interpreting JSR-330 in a particular way that is not consistent with the intentions of the reference implementation that spawned it - guice.  It's making the (unwarranted) assumption that if it's annotated and on the classpath you want to create it up-front.
That is unfortunate, but I'm not sure we should un-annotate ServiceManager to cater to that assumption.  Doing so requires additional boilerplate modules for Dagger or Guice users in preference to the CDI users.
A simple workaround is to simply configure an empty Set&lt;Service>.  I don't know if there is a way to configure glassfish or others to exclude classes/packages from this assumption.  It's a bit of a mind-blowing assumption to make. :/
Another possibility is to proguard the ServiceManager away entirely.
Argh.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c3) posted by **cgruber@google.com** on 2013-05-28 at 10:10 PM_
---
Another workaround, have a relevant class implement
@Produces Set&lt;Service> dummyServices() {
&nbsp;&nbsp;&nbsp;&nbsp;throw new AssertionError();
}
This should pass validation (structurally satisfies the dependency), but if it's ever actually called, it will throw, so should ensure that you're not actually creating any ServiceManagers in production.   If you are, and this approach doesn't work, just return an empty Set&lt;Service> per above.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c4) posted by **AaronJWhiteside** on 2013-05-28 at 11:49 PM_
---
CDI 1.1 (not 2.0 my mistake) will scan all classes in the war and try and instantiate them at deployment time. So the dummyServices() method will be invoked and throw the AssertionError().
JSR-346 governs the behavior of CDI 1.1: http://www.jcp.org/en/jsr/detail?id=346
Perhaps you have more clout than a lot of other poeple/at least myself and could pursue someone on the expert group for JSR-346 with this matter?
I understand your frustration but if you include classes with any JSR-330 annotations they will be treated differently in JEE7 containers, currently Firefly 8 and Glassfish4, soon to follow Tomcat.. and various others..
On the other note what does it matter if it requires a little more boilerplate code to make it compatible with the next generation of application server containers? Right now the preference is with Guide and Dagger users to the exclusion of users of JEE7 containers (not specifically CDI - I don't use it myself). Shouldn't a library such as guava try to be compatible with the majority of technology it will be used in (hint hint JEE)?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c5) posted by **lukes@google.com** on 2013-05-29 at 01:59 AM_
---
What would be the 'little more boilerplate' that we could add to support CDI 1.1?
another solution would be to add a beans.xml that simply excludes this class from auto discovery, though as you have mentioned this will still be a stumbling block for anyone trying to use the class in a JEE 7 container.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c6) posted by **AaronJWhiteside** on 2013-05-29 at 02:21 AM_
---
A pre-made Guice Module? But I expect that will put a dependency directly on Guice which you probably don't want. I was thinking more alone the lines of a wiki page for users explaining how to bind what to where... _shrug_?
beans.xml does not officially support a method to exclude classes from auto discovery. Although WELD does support this via an extension it does not seem to work in Glassfish, only JBoss.. and is non-portable between CDI implementations, not that there are many.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c7) posted by **AaronJWhiteside** on 2013-05-29 at 02:25 AM_
---
Not sure if this applies, but you could annotate specific classes with @Alternative, this would make CDI treat the bean as "disabled" by default.
http://relation.to/Bloggers/WhyIsBeansxmlRequiredInCDI
But I suspect you'll then have a dependency on:
&lt;dependency>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupId>javax.enterprise&lt;/groupId>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;version>1.1&lt;/version>
&lt;/dependency>
But then you could always mark that dependency as optional, so you would need it for compile time but no one else will pick it up as a transitive dependency. And would still behave nicely in CDI.. or at least make it explicitly configure it.. ?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c8) posted by **AaronJWhiteside** on 2013-05-29 at 02:26 AM_
---
*or at least until you explicitly configure it...?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c9) posted by **lukes@google.com** on 2013-05-29 at 03:02 PM_
---
wouldn't this do it
<?xml version="1.0" encoding="UTF-8"?>
&lt;beans xmlns="http://xmlns.jcp.org/xml/ns/javaee">
&lt;scan>
&lt;exclude name="com.google.common.util.concurrent.ServiceManager" />
&lt;/scan>
this is based on reading section 12.4 of the CDI 1.1 spec
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c10) posted by **gak@google.com** on 2013-05-29 at 04:09 PM_
---
So, I poked around in the spec a bit and there's a interesting part of the spec for managed beans: "It is not annotated @Vetoed or in a package annotated @Vetoed."  If JEE7 is really going to be a concern, it might not be a bad idea to toss that annotation on all of our packages because we'll never want Guava classes to be managed beans.  Since annotations aren't runtime deps, it'll make no difference for most people.
That said, we lukes@ has created a ServiceModule for Guice that is often easier to use and has more configuration options than the @Inject constructor, so it might be worth just removing that annotation and open-sourcing the module (someplace else)
---
**CC:** gak@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c11) posted by **AaronJWhiteside** on 2013-05-29 at 04:24 PM_
---
I tried that it doesn't work.
I think you're right this isn't an issue with Guava, looks like an issue with CDI. Or the broken implementations that are currently bundled with the non-production ready releases of Glassfish 4 and Firefly 8..
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c12) posted by **AaronJWhiteside** on 2013-05-29 at 04:46 PM_
---
If you would be willing to do that, that would be wonderful. And would help until the various JEE7 implementations have sorted their bugs out..
Would it make sense for guava to have a guava-guice artifact/module (maven) too, that people could include for Guice support? Having it part of the Guava project would ensure it is maintained in line with the other changes to Guava.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c13) posted by **gak@google.com** on 2013-05-29 at 05:21 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c14) posted by **reuben.pasquini512** on 2013-06-14 at 05:29 PM_
---
I filed this ticket with the JIRA instance linked to by the CDI spec:
&nbsp;&nbsp;&nbsp;&nbsp;https://issues.jboss.org/browse/CDI-377
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c15) posted by **paul.brickell** on 2013-06-23 at 03:54 PM_
---
OK I'm using a guava cache in my JEE web application and am currently upgrading my deployments to GF 4.0.
I'm hosed by this one. Is there a workaround I can implement in my module that can get me over the hump?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c16) posted by **reuben.pasquini512** on 2013-06-23 at 06:08 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c17) posted by **reuben.pasquini512** on 2013-06-27 at 10:15 PM_
---
It turns out that CDI 1.1 supports a new "bean-discovery-mode" attribute in META-INF/beans.xml that can be set to "all", "none", or "annotated", so adding a META-INF/beans.xml file to the jar with "none" discovery mode prevents CDI from scanning the jar.
&nbsp;&nbsp;http://java.dzone.com/articles/java-ee-7-deployment
&nbsp;&nbsp;http://docs.oracle.com/javaee/7/tutorial/doc/cdi-adv001.htm#CACDCFDE
> <?xml version="1.0" encoding="UTF-8"?>
> &lt;beans xmlns="http://xmlns.jcp.org/xml/ns/javaee"
> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/beans_1_1.xsd"
> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bean-discovery-mode="none">
> &lt;/beans>
>
> ignoring entry META-INF/
> adding: META-INF/beans.xml(in = 312) (out= 179)(deflated 42%)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c18) posted by **reuben.pasquini512** on 2013-06-27 at 10:47 PM_
---
BTW - I pulled the test app in glassfish 3 just to verify that adding the beans.xml file to guava's jar didn't break things there, and it worked fine there too ...
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c20) posted by **cgdecker@google.com** on 2013-07-01 at 02:59 PM_
---
As a workaround, can you just do a variation of what comment #3 suggested? Have a relevant class implement:
@Produces Set&lt;Service> dummyServices() {
&nbsp;&nbsp;return ImmutableSet.of();
}
You might get a warning logged, but I'd think it should work.
---
**CC:** cgdecker@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c21) posted by **reuben.pasquini512** on 2013-07-01 at 03:31 PM_
---
&nbsp;&nbsp;&nbsp;http://stackoverflow.com/questions/3937195/maven-how-to-override-the-dependency-added-by-a-library
I wound up wiring up my webapp build process to add a beans.xml file
```
<target name="-post-compile" depends="ivy_build_rules.-post-compile">
<jar update="true" keepcompression="true"
destfile="${build.web.dir}/WEB-INF/lib/guava-14.0.1-bundle.jar"
>
<fileset dir="src/java" />
</jar>
</target>
```
where src/java just contains META-INF/beans.xml with
&nbsp;&nbsp;&nbsp;bean-discovery-mode="none"
Good luck!
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c22) posted by **cgdecker@google.com** on 2013-07-01 at 10:00 PM_
---
It looks like the specific issue here may not be that ServiceManager has @Inject on a constructor, but that the class is annotated with a scope (@Singleton). See this section of the CDI 1.1 spec: http://docs.jboss.org/cdi/spec/1.1/cdi-spec.html#bean_defining_annotations
Any scope annotation is a bean defining annotation, and any class with a bean defining annotation is treated as a bean. Section 12.1 (http://docs.jboss.org/cdi/spec/1.1/cdi-spec.html#bean_archive) goes on to define an "implicit bean archive" as one containing any class annotated with a bean definining annotation. So Guava is an implicit bean archive whether it likes it or not.
On the other hand, another part of the spec (http://docs.jboss.org/cdi/spec/1.1/cdi-spec.html#what_classes_are_beans) states that anything with @Inject on a constructor that meets a variety of other requirements is a "managed bean", so I don't know. Doesn't much matter either way.
One thing I can't tell from what I've read of the spec is whether a beans.xml file at the war level (in WEB-INF/ or WEB-INF/classes/META-INF/) can exclude packages from jars included in the war. It really seems like it should be able to, but from what AaronJWhiteside said in #11 it sounds like that doesn't work. Can anyone confirm? Or confirm if adding a method that @Produces an empty Set&lt;Service> works?
---
**Status:** `Accepted`
**Owner:** cgdecker@google.com
**Labels:** `Milestone-Release15`
**CC:** -cgdecker@google.com, lukes@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c23) posted by **cgdecker@google.com** on 2013-07-11 at 02:58 PM_
---
I've added a beans.xml with bean-discovery-mode="none" to the guava jar's META-INF/ (https://github.com/google/guava/commit/de8f4e8d1076b412a975f5ce940b49b1d1a45628 If someone having this issue could build the jar and verify that it fixes the issue for them, that would be great.
---
**Status:** `Fixed`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c24) posted by **reuben.pasquini512** on 2013-07-11 at 09:18 PM_
---
I just built and deployed the guava-15.0-SNAPSHOT.jar that now includes META-INF/beans.xml, and it works fine for me in glassfish 4.0.  Thanks!
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c26) posted by **sb.leszek** on 2013-09-01 at 10:27 AM_
---
I'm using Glassfish 4.0 and discovered that weld-osgi-bundle.jar contains Guava. So my application (using Guice also) is working without having it's own copy of Guava but I'm using a limited subset of Guava API.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c27) posted by **cody.lerum** on 2013-09-10 at 02:43 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c28) posted by **sebastian.davids** on 2013-09-12 at 08:59 AM_
---
https://java.net/jira/browse/GLASSFISH-20579
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c29) posted by **k...@appendium.com** on 2013-09-12 at 10:24 AM_
---
Caused by: org.jboss.weld.exceptions.DeploymentException: WELD-001408 Unsatisfied dependencies for type [Set&lt;Service>] with qualifiers [@Default] at injection point [[parameter 1] of [constructor] @Inject com.google.common.util.concurrent.ServiceManager(Set&lt;Service>)]
Anyone faced the same issue?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c30) posted by **s...@imsand.li** on 2013-09-12 at 11:04 AM_
---
We also facing issues with guava 15.0 deploying an application to an embedded tomee 1.5.1
Here the stacktrace.
Caused by: javax.enterprise.inject.UnsatisfiedResolutionException: Api type [java.util.Set] is not found with the qualifiers
Qualifiers: [@javax.enterprise.inject.Default()]
for injection into Constructor Injection Point, constructor name :  com.google.common.util.concurrent.ServiceManager, Bean Owner : [ServiceManager, Name:null, WebBeans Type:MANAGED, API Types:[java.lang.Object,com.google.common.util.concurrent.ServiceManager], Qualifiers:[javax.enterprise.inject.Any,javax.enterprise.inject.Default]]
&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.webbeans.util.InjectionExceptionUtils.throwUnsatisfiedResolutionException(InjectionExceptionUtils.java:77)
&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.webbeans.container.InjectionResolver.checkInjectionPoints(InjectionResolver.java:193)
&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.webbeans.container.BeanManagerImpl.validate(BeanManagerImpl.java:1034)
&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.openejb.cdi.BeansDeployer.validate(BeansDeployer.java:269)
&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.openejb.cdi.BeansDeployer.validateInjectionPoints(BeansDeployer.java:222)
&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.openejb.cdi.OpenEJBLifecycle.startApplication(OpenEJBLifecycle.java:280)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c31) posted by **k...@appendium.com** on 2013-09-12 at 11:27 AM_
---
Any help/pointers would be great.
Thanks
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c32) posted by **reuben.pasquini512** on 2013-09-12 at 08:59 PM_
---
Ugh.
It looks like JBoss-7 is javaee-6:
&nbsp;&nbsp;&nbsp;https://www.jboss.org/jbossas/
The new beans.xml file fixed a problem with javaee-7 (glassfish 4).
XML-schema:
&lt;beans xmlns="http://xmlns.jcp.org/xml/ns/javaee"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/beans_1_1.xsd"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bean-discovery-mode="none">
default behavior than JBoss7 when it runs into a beans.xml file for a newer
Anyway - I think we're kind of screwed.  Without beans.xml some CDI1.1 (javaee-7)
containers break, and with beans.xml some CDI1.0 (javaee-6) containers break.
Two possible solutions:
&nbsp;o. Is it too late to just remove the javax.inject.\* annotations from those
&nbsp;&nbsp;&nbsp;&nbsp;two guava classes ?  The client code can pull those classes into
&nbsp;&nbsp;&nbsp;&nbsp;an IOC setup without those annotations anyway by just setting up a
&nbsp;&nbsp;&nbsp;&nbsp;delegate class or via configuration files ...
&nbsp;o. Publish separate -cdi1.0- and -cdi1.1- jar artifacts (without and with beans.xml)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c33) posted by **cgdecker@google.com** on 2013-09-12 at 09:32 PM_
---
At a minimum, I think we're going to remove beans.xml from the Guava jar and create a 15.0.1 release for it. If it won't work for a subset of CDI users either way, better to be in a way that's explicitly CDI-agnostic (no beans.xml). We don't want to go creating "CDI 1.0" and "CDI 1.1" versions of Guava--Guava should be entirely orthogonal to CDI, and the whole problem here is that the CDI 1.1 spec is broken with respect to JSR-330. We did add beans.xml, but that was only because it seemed like a way to solve some users' problems without negatively impacting others--we now know that this was not the case.
Removing @Inject and @Singleton from ServiceManager is a possibility--it's not _that_ important that the annotations be there, though making that change internally would be some trouble. On the other hand, though, it seems wrong for us to be making changes that may break users taking advantage of the @Inject-ability of ServiceManager just because one JSR-330 implementation is broken.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c34) posted by **christianedwardgruber** on 2013-09-12 at 11:20 PM_
---
In fairness, CDI 1.1's use of JSR-330 is not "broken" - it's just stupid.  It is a matter of undefined behaviour... JSR-330 doesn't say how a container will behave in terms of when a how it is configured, or how eager it will be.  CDI just went with an incompatible change to their defaults between versions of the spec, and chose a default behaviour that is guaranteed to have unintended consequences.  It's totally valid JSR-330, it's just entirely the wrong behavioural default.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c35) posted by **reuben.pasquini512** on 2013-09-13 at 09:00 PM_
---
I don't know how likely it is that CDI-1.1 will change ?  CDI-1.1 is it's own JSR that was approved and integrated into java-ee7, so eventually (I assume) all the big EE container vendors (IBM-websphere, Oracle-weblogic, RedHat-Jboss, Oracle-glassfish) will implement that (glassfish 4 is the reference implementation).  I think the JBoss-weld guys are the CDI leads these days, but they don't seem to pay much attention to their bug database:
&nbsp;&nbsp;&nbsp;&nbsp;https://issues.jboss.org/browse/CDI-377
It might be one of those "feel good" bug systems - submit a bug, and feel good!  Turn the knob on the toaster that doesn't do anything, and feel good!
scripts, and publish a -CDI1.1- guava artifact just to make
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c36) posted by **zmircmircea** on 2013-09-17 at 09:35 AM_
---
Using 13.0.1 helped me getting it running with Java EE 6 in Apache Tomee 1.5.2. I needed it as a dependency for https://code.google.com/p/owasp-java-html-sanitizer/
Thank you for this tip.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c37) posted by **thomas.a...@ergon.ch** on 2013-10-03 at 04:15 PM_
---
When I replace the beans.xml with
<?xml version="1.0" encoding="UTF-8"?>
&lt;beans xmlns="http://java.sun.com/xml/ns/javaee"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmlns:weld="http://jboss.org/schema/weld/beans"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/beans_1_0.xsd
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://jboss.org/schema/weld/beans http://jboss.org/schema/weld/beans_1_1.xsd">
```
<weld:scan>
<weld:exclude name="com.google.**"/>
</weld:scan>
```
instead of the Version with bean-discovery-mode="none" it's shipped with, it will deploy on both glassfish versions.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c38) posted by **cgdecker@google.com** on 2013-10-03 at 04:27 PM_
---
@thomas.andres: It looks like that will only work for Weld, though, and not other CDI implementations.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c39) posted by **xaerxess** on 2013-10-04 at 07:51 AM_
---
@cgdecker: You've mentioned in comment 33 you'll release Guava 15.0.1 (or even 15.1) without beans.xml - is that still a plan? It would fix issue #1527 problem.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c40) posted by **hazendaz** on 2013-10-06 at 04:27 AM_
---
My two cents.  I'm not convinced this beans.xml is doing what it advertises.  Scanning still seems to occur.  We have successfully used guava 14.0.1 for quite some time without issue running essentially java EE7 inside of tomcat 7.0.x as well as weblogic 10.3.6.  We use weld 2.1.CR1 at the moment.  I'll spare the details but we have nearly the entire EE7 spec running in those environments aside with exception of jars requiring java 7.  In those cases, we are still back on EE6 (EL, ejb, servlet) - all reasons beyond my control and silly I know.  When we try to upgrade to guava 15, we run into two issues.  First, the issue noted here with WELD-001408.  The second is with richfaces.  The later of which is a show stopper and something richfaces team needs to resolve.  However, provided they solve their issue, we still cannot upgrade so long as this beans.xml is inside of guava.  However, I personally have no issue simply removing it to make it work and keeping a patched copy in our nexus repository for internal use.  That matter is trivial at best.  I prefer not to do so, so a better solution is much wanted.  My guess is that our specific setup is somehow causing some regression here.  So along with others, it does sound like removing it is better and/or simply releasing two copies to the repositories until this is properly resolved.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c41) posted by **dhumeniuk** on 2013-10-29 at 07:35 PM_
---
I'm using an OSGi web bundle which uses other OSGi services from other bundles.  This means I need to use CDI in my web bundle and need my classes in the bundle (JAR file) to be scanned.  Basically this means I can't use Guava as it doesn't work with CDI currently.  Whether the bean.xml is in the JAR doesn't really matter as I'm including the Guava code in my bundle so I don't have an extra dependency on Guava in case some other bundle is using a different version.
If the annotations are not really important for these classes, can they be removed?
I can manually remove these classes in my case.  However, I will not be able to access them in my web bundle (JAR) and seems a bit of a hack.  That is the only work around that I can think of right now.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c42) posted by **cgdecker@google.com** on 2013-10-30 at 10:09 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c43) posted by **xaerxess** on 2013-10-30 at 10:50 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c44) posted by **cgdecker** on 2013-10-31 at 12:40 AM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c45) posted by **xaerxess** on 2013-10-31 at 06:23 AM_
---
Correct me if I'm wrong, but if we use both Java EE 6 and 7 application servers, there's no way having project depending on Guava 14 or 15 deployed without POM juggling (i.e. change classifier and rebuild whole project), right? It's quite troubling because Guava should remain CDI agnostic and it will be true for version 16.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c46) posted by **cgdecker@google.com** on 2013-10-31 at 04:14 PM_
---
@xaerxess: Yes, that's probably correct (though using Maven profiles might help). You could also build Guava from source with the annotations removed.
We're removing the annotations in Guava 16.0 because we feel that A) it seems unlikely that CDI will fix its spec anytime soon, and B) the problems this causes for users in CDI environments (where there apparently isn't any good workaround) probably outweighs the benefits of the annotations to users who are taking advantage of them in other environments (because at least with other JSR-330 frameworks like Guice and Dagger, binding the ServiceManager yourself isn't hard). It's not because we believe it's wrong for Guava to use the annotations; quite the opposite.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c47) posted by **xaerxess** on 2013-10-31 at 06:16 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c48) posted by **cgdecker@google.com** on 2013-10-31 at 06:29 PM_
---
@xaerxess: Right. One of the big advantages (in my opinion) of a standard set of annotations for dependency injection like JSR-330 was that it would make it possible for libraries to make their classes easy to use with DI frameworks. It's really unfortunate that another Java standard simultaneously interprets those annotations in a way that makes that impossible.
---
CDI 1.2 will address this problem. At least at implementation level : https://issues.jboss.org/browse/CDI-377
It'll be released in 2014Q1
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c52) posted by **lukes@google.com** on 2014-02-14 at 07:22 AM_
---
Both the @Inject and @Singleton annotations were removed from
ServiceManager due to this issue, so I'm surprised there is still a problem.
am I missing?
---
The error message is: java.lang.NoSuchMethodError: com.google.common.base.Splitter.splitToList(Ljava/lang/CharSequence;)Ljava/util/List;
My mvn dependency:tree is showing exactly one guava 16.0 and I don't have google collections. This is the tree (minus our own packages):
[INFO] +- org.springframework:spring-core:jar:3.2.5.RELEASE:compile
[INFO] |  - commons-logging:commons-logging:jar:1.1.1:compile
[INFO] +- org.springframework:spring-web:jar:3.2.5.RELEASE:compile
[INFO] |  +- aopalliance:aopalliance:jar:1.0:compile
[INFO] |  +- org.springframework:spring-aop:jar:3.2.5.RELEASE:compile
[INFO] |  +- org.springframework:spring-beans:jar:3.2.5.RELEASE:compile
[INFO] |  - org.springframework:spring-context:jar:3.2.5.RELEASE:compile
[INFO] +- org.springframework:spring-webmvc:jar:3.2.5.RELEASE:compile
[INFO] |  - org.springframework:spring-expression:jar:3.2.5.RELEASE:compile
[INFO] +- org.springframework.data:spring-data-mongodb:jar:1.3.2.RELEASE:compile
[INFO] |  +- org.springframework:spring-tx:jar:3.1.4.RELEASE:compile
[INFO] |  +- org.springframework.data:spring-data-commons:jar:1.6.2.RELEASE:compile
[INFO] |  +- org.mongodb:mongo-java-driver:jar:2.10.1:compile
[INFO] |  - org.slf4j:jcl-over-slf4j:jar:1.7.1:runtime
[INFO] |  - org.hamcrest:hamcrest-core:jar:1.3:test
[INFO] +- org.springframework:spring-test:jar:3.2.5.RELEASE:compile
[INFO] +- org.easytesting:fest-assert-core:jar:2.0M10:compile
[INFO] |  - org.easytesting:fest-util:jar:1.2.5:compile
[INFO] +- org.apache.tomcat:tomcat-servlet-api:jar:7.0.47:provided
[INFO] +- javax.servlet.jsp:jsp-api:jar:2.2:provided
[INFO] +- javax.servlet.jsp.jstl:jstl-api:jar:1.2:compile
[INFO] +- org.glassfish.web:jstl-impl:jar:1.2:compile
[INFO] +- com.google.code.gson:gson:jar:2.2.4:compile
[INFO] +- com.google.guava:guava:jar:16.0:compile
[INFO] +- org.slf4j:slf4j-api:jar:1.7.5:compile
[INFO] +- org.slf4j:slf4j-log4j12:jar:1.7.5:compile
[INFO] |  - log4j:log4j:jar:1.2.17:compile
[INFO] +- commons-codec:commons-codec:jar:1.4:compile
[INFO] +- org.codehaus.jackson:jackson-mapper-asl:jar:1.9.13:compile
[INFO] |  - org.codehaus.jackson:jackson-core-asl:jar:1.9.13:compile
[INFO] +- javax.mail:mail:jar:1.4.5:compile
[INFO] |  - javax.activation:activation:jar:1.1:compile
[INFO] +- joda-time:joda-time:jar:2.3:compile
## [INFO] - org.ocpsoft.prettytime:prettytime:jar:3.2.4.Final:compile
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c54) posted by **pjpires** on 2014-02-14 at 07:38 AM_
---
---
Any idea how to remove it?
Thanks.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c56) posted by **lukes@google.com** on 2014-02-14 at 07:40 AM_
---
---
Done: https://github.com/google/guava/issues/1668
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1431) created by **ekuefler** on 2013-05-26 at 03:18 AM_
---
When a generic type is posted to the event bus, type erasure means that handlers for the same type with different parameters are invoked unexpectedly. The following test causes a ClassCastException:
&nbsp;&nbsp;@Test
&nbsp;&nbsp;public void test() {
&nbsp;&nbsp;&nbsp;&nbsp;EventBus eventBus = new EventBus();
&nbsp;&nbsp;&nbsp;&nbsp;eventBus.register(this);
&nbsp;&nbsp;&nbsp;&nbsp;eventBus.post(ImmutableList.of("one", "two"));
&nbsp;&nbsp;}
&nbsp;&nbsp;@Subscribe
&nbsp;&nbsp;public void handle(List&lt;Integer> e) {
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(e.get(0) + 1);
&nbsp;&nbsp;}
Language restrictions probably make it impossible to handle this case correctly, but maybe EventBus could do something like notice if two handlers are being registered for the same erased type (but different declared types) and display a warning?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1431#c1) posted by **Yuriy.Kulikov.87** on 2014-09-14 at 02:52 PM_
---
Hi,
you are right, you will not be able to distinguish between different types of generic lists after compilation because Java generics are erasure type. I think the issue can be closed as there is no way to fix it.
Besides, I think it makes little sense to post List&lt;Integer> to the event bus anyway. You will not be able to use this type for some other purpose and it contains no information on what kind of integers are inside. You will not be able to add a comment to it. You are much better of posting events containing the list. For example:
&nbsp;&nbsp;&nbsp;&nbsp;public final List&lt;Integer> numbers;
}
In this case you will be able to access the numbers as a generic list and at the same time you will be able to have different event types using List&lt;Integer>.
BR,
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1428) created by **adamilardi** on 2013-05-24 at 02:49 PM_
---
Sometimes you have a future that would be nice to have earlier in a workflow but NOT needed. You don't want to give up trying to get it so you want to try again later. This method would require the BaseSupplier to be optional so it won't mark the initialized value to true unless it returns a NON absent value.
I have the code for this and would like to contribute it. Your guidelines said to keep it secret until the ticket is approved.
Thanks!
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1428#c2) posted by **adamilardi** on 2013-05-24 at 02:52 PM_
---
I can't seem to edit my own issue. When I said the BaseSupplier needs to be optional I meant
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1421) created by **kristofer.karlsson** on 2013-05-22 at 03:01 PM_
---
Sometimes it would be useful to combine the result of multiple futures into a single result, basically transforming a set of futures into a single future.
This is already supported to some extent through Futures.allAsList, but that only works if all futures are of the same type. I would want something similar, but that works on tuples instead of lists.
Something like this:
ListenableFuture&lt;A> future1;
ListenableFuture&lt;B> future1;
Function2&lt;X, A, B> function = new Function2&lt;X, A, B>(){
&nbsp;&nbsp;@Override
&nbsp;&nbsp;public X apply(A first, B second) {
&nbsp;&nbsp;&nbsp;&nbsp;return merge(first, second);
&nbsp;&nbsp;}
};
ListenableFuture&lt;X> result = Futures.transform(future1, future2, function);
Attached is some sort of minimal implementation of this concept.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1421#c1) posted by **cpovirk@google.com** on 2013-05-22 at 03:09 PM_
---
Though we've stayed away from Function2 and friends (&lt;https://code.google.com/p/guava-libraries/wiki/IdeaGraveyard#Functions/Predicates_for_n_%3E=_2_inputs>), we can find other ways of merging Futures:
final ListenableFuture&lt;A> future1;
final ListenableFuture&lt;B> future2;
Callable&lt;X> function = new Callable&lt;X>() {
&nbsp;&nbsp;@Override
&nbsp;&nbsp;public X call() {
&nbsp;&nbsp;&nbsp;&nbsp;return merge(future1.get(), future2.get());
&nbsp;&nbsp;}
};
ListenableFuture&lt;X> result = Futures.combine(function, executor, future1, future2);
In fact, we have this method internally. It may yet make its way out.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1421#c2) posted by **kristofer.karlsson** on 2013-05-22 at 03:19 PM_
---
Thanks for quick response.
But if that's the route you're going for it, I could just wrap things as a list instead and do this:
final ListenableFuture&lt;A> future1;
final ListenableFuture&lt;B> future1;
Function&lt;X, ?> function = new Function&lt;X, ?>(){
&nbsp;&nbsp;@Override
&nbsp;&nbsp;public X apply(List<?> dummy) {
&nbsp;&nbsp;&nbsp;&nbsp;return merge(future1.get(), future2.get());
&nbsp;&nbsp;}
};
ListenableFuture&lt;X> result = Futures.transform(Futures.allAsList(future1, future2), function);
so you wouldn't actually need to expose your combine.
The tuple version is cute, since it gives somewhat nicer type information, and you don't need to invoke outer objects.
You could also do this, but I'm not sure it's any prettier:
ListenableFuture&lt;A> future1;
ListenableFuture&lt;B> future1;
Function&lt;X, ?> function = new Function&lt;X, ?>(){
&nbsp;&nbsp;@Override
&nbsp;&nbsp;public X apply(List<?> result) {
&nbsp;&nbsp;&nbsp;&nbsp;return merge((A) result.get(0), (B) result.get(0));
&nbsp;&nbsp;}
};
ListenableFuture&lt;X> result = Futures.transform(Futures.allAsList(future1, future2), function);
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1421#c3) posted by **cpovirk@google.com** on 2013-05-22 at 03:27 PM_
---
Yep, allAsList+transform is pretty much how ours is implemented. (As it turns out, ours (a) uses successfulAsList so that you can choose to handle exceptions manually (or just let them propagate) and (b) uses the AsyncFunction version of transform() so that the Function can throw any kind of Exception (important in part because we make you call get() but also sometimes convenient for other reasons.)
Part of what keeps us from going to tuple route is that, if we're going to address complex graphs of Futures, we probably want to go even further than an added method or two. There's at least one popular system available internally at Google, so we're kind of spoiled.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1421#c4) posted by **pettermahlen** on 2014-01-31 at 09:24 AM_
---
We've created a framework that aims to simplify the problem of working with non-trivial asynchronous call graphs: https://github.com/spotify/trickle. It may be of interest until the day when the Google-internal system is made available to the public.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1419) created by **ogregoire** on 2013-05-21 at 02:10 PM_
---
I often have these APIs that return a lot of elements. I want to cache the results. But at each request towards the cache, I need only one element.
It would be nice to have an option in CacheBuilder that forces loading all the elements and that knows that all the data have been fetched, so it doesn't need extra calls to the backend in order to get an error.
Typically, here's what I'd want:
The API I call has the following data: "foo" -> "a", "bar" -> "b"
LoadingCache cache = ...; // empty cache
String foo = cache.get("foo"); // calls loadAll(), puts "foo" and "bar" in cache, returns "a"
String bar = cache.get("bar"); // doesn't call loadAll(), returns "b"
String baz = cache.get("baz"); // doesn't call loadAll(), returns null or throws exception.
Thread.sleep(...); // expires all elements
baz = cache.get("baz"); // calls loadAll(), puts "foo" and "bar" in cache, returns null or throws exception
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1419#c1) posted by **cgdecker** on 2013-05-21 at 05:25 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Cache`, `Type-Addition`
(just going through some old bugs -- don't get your hopes up :-P)
This might be easiest served by a single-element cache (#872) where the "single element" is a Map.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1415) created by **slatemine** on 2013-05-16 at 09:55 AM_
---
Use case:
Base64 does not follow the ASCII code point sequence, this means the sorted numbers encoded with Base64 then resorted as strings will not be in the same order.
Exposing createEncoding enables changing the alphabet, eg.
BaseEncoding sort64 = BaseEncoding.createEncoding(
&nbsp;&nbsp;"sort64",
&nbsp;&nbsp;"+/0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
&nbsp;&nbsp;null);
Patch attached
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1415#c1) posted by **kurt.kluever** on 2013-05-16 at 01:41 PM_
---
_(No comment entered for this change.)_
---
**Owner:** lowasser@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1415#c2) posted by **lowasser@google.com** on 2013-05-16 at 05:46 PM_
---
This needs consideration for whether we want to support adding arbitrary alphabets, or whether or not specific support for the sorted alphabet is appropriate.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1415#c3) posted by **slatemine** on 2013-05-16 at 05:54 PM_
---
I can't see the downside of arbitrary alphabet the cost and resources are with the downstream developers app. That being said I can't think of another reason why I'd want to change the alphabet but it was very useful this time. p
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1415#c5) posted by **slatemine** on 2013-05-23 at 09:04 PM_
---
Thought I'd add the test case, note numeric / encoded ordering works for unsigned values only with the sort64 alphabet, see Math.abs(...) line below.
import org.apache.openjpa.lib.util.Bytes; // Happened to be on my classpath
...
```
@Test
public void testSort64()
{
final int size = 5000;
long[] lArray = new long[size];
String[] sArray = new String[size];
for(int i=0; i<size; i++)
{
long l = Math.abs(rng.nextLong());
lArray[i] = l;
sArray[i] = IPUtils.sort64.encode(Bytes.toBytes(l));
}
Arrays.sort(lArray);
Arrays.sort(sArray);
for(int i=0; i<size; i++)
{
long l = lArray[i];
String s = sArray[i];
byte[] b = IPUtils.sort64.decode(s);
Assert.assertEquals(l, Bytes.toLong(b));
}
}
```
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1415#c6) posted by **slatemine** on 2013-06-10 at 12:33 PM_
---
patch-v2
&nbsp;\- Adds BaseEncoding.createEncoding() as per patch-v1
&nbsp;\- Adds sort64() encoding as per base64()
&nbsp;\- Adds test, for numerical ordering to BaseEncodingTest
I bumped my local version to 15-snapshot, I've tested with millions of records but set the default test back to 5000 so test ran quickly. Hopefully this is pretty complete.
Many thanks
p
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1415#c7) posted by **slatemine** on 2013-06-10 at 12:44 PM_
---
Forgot to mention I decided to leave the padding character unchanged from base64 for sort64. It can be omitted via the API and the numeric sort property still works with padding.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1415#c8) posted by **slatemine** on 2013-08-14 at 10:11 PM_
---
I had another use case for Sort64, which is closely related to the long formatting.
Using time/host based UUID's, using Sort64 encoding of the 128 bit value should maintain the time/host ordering. A useful property in some column stores.
Also I was wondering what if anything was happening with these patches in the upcoming 15 release? Is there anything else needed to help get these into HEAD.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1413) created by **Eric6iese** on 2013-05-14 at 06:53 PM_
---
FluentIterable.transform delegates its internal iterable to the Iterables.transform method. This method has the disadvantage that it wraps any kind of collection as an iterable. So when the following is invoked:
FluentIterable.from(someList).transform(someFunction).toList()
ImmutableList.copyOf(iterable) falls back to less efficient creation by iteration - instead of creating a fixed-size array as it would do if the transformed internal iterable was still a collection.
This would easily be changed if FluentIterable.transform just checks if its a Collection first and then invokes FluentIterable.from(Collections2.transform(iterable, function).
This optimization applies only to FluentIterables which are just transformed and not filtered. But its a minimalistic change which should not have any real disadvantages except one more line of code and allows for more efficient creation of the resulting datastructures.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1413#c1) posted by **Eric6iese** on 2013-05-14 at 07:31 PM_
---
It might also be worthwhile to check for List and then use Lists.transform.
In the common case of a RandomAccess List, toArray will skip using the iterator.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1413#c2) posted by **Eric6iese** on 2013-05-15 at 09:01 AM_
---
"In the common case of a RandomAccess List, toArray will skip using the iterator."
Well, that one does not work out, since AbstractList does not optimize toArray in the case of RandomAcessLists. Therefore, just checking for collection should be sufficient.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1413#c3) posted by **schlosna** on 2013-10-12 at 06:13 AM_
---
I know there is API documentation for Iterables#transform and Iterables#partition, but I have run into several places where this optimization would be useful to avoid copying where I have an API that accepts Iterable and internally apply Iterables.transform, but is frequently given a collection (often an Immutable*).
It might also be beneficial to have Iterables.transform dynamically dispatch transform to the most appropriate and optimized implementation for the specified iterable:
```
public static <F, T> Iterable<T> transform(final Iterable<F> fromIterable,
final Function<? super F, ? extends T> function) {
checkNotNull(fromIterable);
checkNotNull(function);
if (fromIterable instanceof List) {
return Lists.transform((List<F>) fromIterable, function);
} else if (fromIterable instanceof Collection) {
return Iterables2.cast(Collections2.transform((Collection<F>) fromIterable, function));
} else {
return Iterables.transform(fromIterable, function);
}
};
```
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1413#c4) posted by **cpovirk@google.com** on 2013-10-16 at 07:05 PM_
---
There was some previous discussion of this in http://code.google.com/p/google-collections/issues/detail?id=207 ... but that focused on Iterables.size, not ImmutableList.copyOf and FluentIterable.toList, more commonly used methods that I find more compelling.
Note that this request is (I think) distinct from changing Iterables.transform itself (as described in comment #3), as the FluentIterable would remain a "plain" Iterable and not a Collection or List, so there is no change to its equals() behavior. Here's the (irrelevant here, again, I think) comment that Kevin once made about changing Iterables.transform (_not_ FluentIterable.transform) to delegate to Lists.transform when appropriate:
"""
So, right now every method of Iterables that returns an Iterable consistently returns a "plain Iterable", and every method of Collections2 returning a Collection returns a "plain Collection."  I would prefer not to step away from that without having a clearer picture of where the ultimate destination we want to end up at is... and clear evidence that this is all definitely worthwhile.
"""
Also, I've split the AbstractList.toArray issue off into https://github.com/google/guava/issues/1556
---
**Labels:** `Type-Performance`, `Package-Collect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1413#c5) posted by **Eric6iese** on 2013-10-17 at 10:41 AM_
---
I'd strongly agree to change only FluentIterable and NOT Iterables, as the latter clearly suggests to return an Iterable and nothing else. Type-Dispatch as a means of internal optimization should not pollute the expected result of a method.
FluentIterable, however, keeps the base collection on the inside (brilliant design choice!), so here a full dispatch for Collection and List can be done without changing anything on the outside.
Obviously I'm also in favor for the other ticket.
---
I'd say that the semantics should not change at all; the only user-visible change should be the speed in case the underlying Iterable happens to be a Collection. This seems to be doable for many methods including size, toArray, and toList. As Iterables uses FluentIterable internally, it should profit from this too. I've got some proof of concept already and will post it when tested well.
---
I added a method using the size of the underlying iterable to the result of Iterables.unmodifiable, .transform, .skip, and .limit. In case they're based on a Collection (or another such size-aware Iterable), `Iterables.size`&nbsp;is nearly as fast as `size`&nbsp;of the underlying collection. This also allows to avoid resizing in toArray and toList.
The speed up is nice:
https://microbenchmarks.appspot.com/runs/b0538106-18fa-46ea-a8b4-18424a4707b8,4849c48d-4403-46e0-b895-2b000d194f74#r:scenario.benchmarkSpec.parameters.iterableSetup,scenario.benchmarkSpec.parameters.baseSetup,scenario.benchmarkSpec.parameters.state&c:scenario.benchmarkSpec.methodName
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1413#c8) posted by **Eric6iese** on 2013-10-20 at 04:32 AM_
---
Wouldn't it be simpler to put the size implementation of Iterables into the FluentIterable and implement Iterables.size by
FluentIterable.from(iterable).size()?
That could be done with most of the iterables methods.
The advantage of re-routing most implementations through fluentiterable is that it automatically checks for fluentiterable and "unpacks" the target collection whenever needed by the next method. However, the additional class-checks might make this optimization slower in many usecases:
All optimizations are worthless as soon as the first filtering Predicate is used in the chain, which enforces the use of an iterable. And a filtering might be the most common operation of them all.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1412) created by **stephan202** on 2013-05-13 at 02:43 PM_
---
The methods Ordering#allEqual(), Ordering#usingToString() and Ordering#arbitrary() return an Ordering&lt;Object>, but they are safe for use as an Ordering&lt;T> for any T. It'd be nice to generalize the return types thusly, so that callers do not need to cast the return value (and suppress the resultant warning).
For a precedent, see e.g. java.util.Collections#reverseOrder().
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1412#c1) posted by **cpovirk@google.com** on 2013-05-13 at 03:05 PM_
---
The more flexible return type would probably make little difference either way: It would provide compatibility with methods that require an Ordering&lt;T>, but those methods should accept Ordering<? super T>, as discussed in similar issues:
https://github.com/google/guava/issues/439
https://github.com/google/guava/issues/611
https://github.com/google/guava/issues/630
https://github.com/google/guava/issues/933
---
**Status:** `WorkingAsIntended`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1412#c2) posted by **stephan202** on 2013-05-15 at 06:49 PM_
---
Ah yes, you're right. I guess it was because I was working with a class-internal Comparator that the super keyword didn't cross my mind (I knew precisely which type of objects would be compared, after all). One advantage of the current more "rigid" signature is that it is more likely to remind people that they should use "? super T" where possible. I know I won't forget next time ;)
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1410) created by **rakesh.pulipati** on 2013-05-13 at 09:06 AM_
---
I am using guava library 14.0.1 to implement caching service (a web application containing a servlet to put and get values). The web application is deployed on a machine containing 1GB RAM (google backend). The number of write and read operations is huge (50 queries per second).
The amount of RAM used on the machine keeps on increasing even after hitting the maximumSize limit. I suspect memory leak.
Following is the code I am using to create cache
```
Cache cache = CacheBuilder.newBuilder()
.expireAfterWrite(1, TimeUnit.DAYS)
.initialCapacity(2000000)
.maximumSize(3800000)
.concurrencyLevel(50)
.recordStats()
.build();
```
Retrieving the values using
```
Map result = cache.getAllPresent(keys);
```
Putting values in the cache using
```
cache.put(key, value);
```
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1409) created by **Ash2kk** on 2013-05-12 at 10:33 AM_
---
Currently Uninterruptibles have putUninterruptibly() and takeUninterruptibly() methods for BlockingQueue. Consider adding helper methods for other interruptible methods: offer(Object, long, TimeUnit) and poll(long, TimeUnit).
Also there is BlockingDeque interface with many more interruptible methods.
Related to issue #1212 and issue #1315.
I think we just haven't needed them yet. They seem fine to add as far as I can tell.
---
This becomes a slippery slope, because once we start special-casing one type (e.g., `Collection`), other folks will request other APIs on `ToStringHelper` (e.g., omitting an absent `Optional`). I'd suggest just writing a simple helper function:
```
@Nullable private static <T> Iterable<T> emptyToNull(Iterable<T> iterable) {
return Iterables.isEmpty(iterable) ? null : iterable;
}
```
And then wrapping your iterables with it when using `ToStringHelper`.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1402) created by **cpovirk@google.com** on 2013-05-08 at 03:29 PM_
---
We have this internally. It's a useful building block in implementing things like firstCompleted(Iterable&lt;ListenableFuture>). Eventually, we should get around to reviewing users, deciding whether to make any API changes, and possibly releasing it.
We ended up deleting the specific `CompletionTracker` class I teased here in favor of [`Futures.inCompletionOrder`](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/util/concurrent/Futures.html#inCompletionOrder%28java.lang.Iterable%29) (and, for some users, other methods like [`Futures.successfulAsList`](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/util/concurrent/Futures.html#inCompletionOrder%28java.lang.Iterable%29)). Would those work for your use case?
Declaring this as fixed with the release of Futures.inCompletionOrder in 17.0.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1401) created by **phwendler** on 2013-05-08 at 08:59 AM_
---
If you want to throw an exception with a cause, but the exception does not have a constructor that accepts a cause argument, you can use Throwable.initCause(), but this destroys method chaining because of the return type "Throwable".
So you have to write something like this:
try {
&nbsp;&nbsp;...
&nbsp;&nbsp;NumberFormatException nfe = new NumberFormatException("Invalid number");
&nbsp;&nbsp;nfe.initCause(e);
&nbsp;&nbsp;throw nfe;
}
With the following helper method this code could be shortened and made more readable:
&lt;X extends Throwable> X withCause(Throwable cause, X t) {
&nbsp;&nbsp;t.initCause(cause);
&nbsp;&nbsp;return t;
}
try {
&nbsp;&nbsp;...
&nbsp;&nbsp;throw withCause(e, new NumberFormatException("Invalid number"));
}
Name and order of arguments are debatable, of course.
There are several exceptions in the Java API that have no constructor with a cause argument, so there this method would be helpful. Examples are NumberFormatException, ArithmeticException, and IndexOutOfBoundsException.
In a comment to another issue (https://github.com/google/guava/issues/1382 it was also mentioned that the cause as the last constructor parameter (as is common for exceptions that do have such a parameter) is not well readable. The proposed method could also be make code more readable and emphasize the addition of a cause, even if the exception would already provide the necessary constructor.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1401#c1) posted by **kevinb@google.com** on 2013-05-09 at 08:23 PM_
---
When a Throwable doesn't accept a cause there are two possibilities:
1. It's very rare to have a cause exception, so the workaround is fine
2. It's common to have a cause exception and the creator of that Throwable class just messed up.
The examples you cite are solidly in case #1, and even for hypothetical examples in case #2 the proper solution is that the Throwable class itself should be fixed.
Methods like this exist only to paper over bad API decisions in other libraries and have no other discernible purpose. We decided long ago that it's not part of Guava's mission in life to try to address such cases.
---
**Status:** `WorkingAsIntended`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1400) created by **cgbeekman** on 2013-05-07 at 10:21 AM_
---
Futures.transform currently allows transforming a single ListenableFuture. It would be handy if we could pass in an Iterable&lt;ListenableFuture>, combining Iterables.transform and Futures.transform.
See attached file for a reference implementation. Methods that take an AsyncFunction instead of a regular Function could also be added.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1400#c1) posted by **cpovirk@google.com** on 2013-05-07 at 01:19 PM_
---
First, a quick acknowledgement: Your implementation uses Iterables.transform() with a heavyweight Function. As you've observed, every time that someone iterates over the resulting Iterable, the Function is applied anew.
I think that the right way to go for a Futures method would be to apply the transformations eagerly. But that's all a question of implementation.
As for the question of whether to add this, I'll do some poking around in Google code to see if it seems to be coming up for many users, and I'll report back.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1400#c2) posted by **cpovirk@google.com** on 2013-05-07 at 03:03 PM_
---
I found 30-odd Iterable&lt;ListenableFuture> references in the Google codebase. I found just one that was calling Futures.transform on each of its inputs, and it was (a) actually calling a custom variant of Futures.transform (b) also calling Futures.withFallback.
I'm kind of surprised that this isn't more common. Perhaps our internal CompletionTracker[*], which makes it easier to pull Futures off a list as they complete, is siphoning off some usage. We may get that promoted to Guava one day. Until then, you're probably best served with a for() loop. The Futures class is getting kind of big, so we like to see new methods do something hairier and more error-prone than that.
[*] similar to http://stackoverflow.com/questions/16309203/guava-listenablefuture-allaslist-returns-all-content-seen-so-far-from-get#comment23373302_16309203
---
**Status:** `WontFix`
**Labels:** `Type-Addition`, `Package-Concurrent`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1400#c3) posted by **cgbeekman** on 2013-05-08 at 11:19 AM_
---
Thanks for your extensive feedback, appreciated.
You are right about the eagerness of Future transformations, it makes much more sense to let Futures.transform behave the same for a single Future or multiple Futures in that respect.
Attached is a rather trivial implementation that simply bulk transforms the input Futures and returns them as a List. This prevents multiple transformations and fixes the eagerness "problem".
Even though it might be a trivial method, I still think inclusion in Futures is warranted, given that producing services are likely to return Iterable&lt;ListenableFuture>. Without the method you would have to loop the futures, apply transformations to each individually and then put them in a List which is then passed to Futures.allAsList for example.
Regardless, CompletionTracker seems to be a handy utility to have. Would such an implementation allow returning Futures in order when desired? I.e. to create an aggregate that is order-sensitive? Without turning CompletionTracker into a full-blown fork/join implementation of course ;)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1400#c4) posted by **cpovirk@google.com** on 2013-05-08 at 03:30 PM_
---
How about this: We revisit this whenever we finally add AsyncLoadingCache (issue 1350), which is likely to have a getAll() method that returns Map&lt;K, ListenableFuture&lt;V>>.
For CompletionTracker, I've filed issue 1402. Can you post there about why you'd like to retrieve the Futures in order? (And of course add any other requirements you might have.)
---
**Status:** `Research`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1392) created by **sven.linstaedt** on 2013-04-30 at 09:25 AM_
---
At the moment it is not possible to join a String over iterable elements by mapping the elements to String with a customized function like:
Joiner.on(String sep, Function&lt;Object, CharSequence> toStringFunction);
or even better a typed version like:
Joiner.&lt;T>on(String sep, Function<? super T, CharSequence> toStringFunction).join(Iterable<? extends T> elements);
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1392#c1) posted by **tomas.zalusky** on 2013-04-30 at 12:39 PM_
---
What about
Joiner.on(sep).join(Iterables.transform(elements,toStringFunction))
or
Joiner.on(sep).join(FluentIterable.from(elements).transform(toStringFunction))
?
BTW this would be cool (especially with static imports) although violating principle of orthogonality:
FluentIterable.from(elements).transform(toStringFunction).join(Joiner.on(sep))
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1392#c2) posted by **wasserman.louis** on 2013-04-30 at 03:19 PM_
---
We have come to the conclusion generally that we'd prefer for Joiner to remain strictly focused on the act of joining things, and this, too, would fall into the category of "If we add something to do this, we'd want it to be part of (or at least based on) a more full-featured API for producing parseable strings (e.g. writing CSV strings), which would include escaping and such."
---
**Status:** `Duplicate`
**Merged Into:** #1064
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1392#c3) posted by **sven.linstaedt** on 2013-05-01 at 08:03 AM_
---
Sounds reasonable. I was not aware of Iterables#transform.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1389) created by **jamie.spencer.86** on 2013-04-29 at 04:20 AM_
---
This issue derives from https://github.com/google/guava/issues/1382 .
Could Preconditions.format(String, Object...) become public as a member of the Strings helper class? That method doesn't seem particularly dependant on Preconditions and seems well suited for any set of (String, Object...) arguments.
Other than that, I feel that it would be useful outside of Preconditions.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1389#c1) posted by **wasserman.louis** on 2013-04-29 at 04:38 AM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1389#c2) posted by **jamie.spencer.86** on 2013-04-29 at 04:52 AM_
---
I wouldn't ask anyone to implement Strings.format with all of the function of String.format + Preconditions.format; if that is what it takes to have it public at Strings, then I'd rather not put anyone through the trouble. It only seemed convenient to have during the discussion in the alluded issue.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1389#c3) posted by **wasserman.louis** on 2013-04-29 at 04:59 AM_
---
The one and only advantage of Preconditions.format over Strings.format is GWT compatibility.
---
There's one more thing (good for Preconditions and bad in most other places):
https://github.com/google/guava/issues/1382
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1389#c5) posted by **j...@nwsnet.de** on 2013-05-15 at 02:44 PM_
---
What about performance? I remember `String.format`&nbsp;to be quite slow.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1388) created by **Petro.Semeniuk** on 2013-04-28 at 09:54 AM_
---
Very often on null reference there's need to throw custom exception instead of just standart NPE. It could be easy achieved by overloading checkNotNull method and adding exception as one more parameter. Code sample below covers my use case and adds a bit more explanation to proposed change in comments(as you could see it saves at least 2 lines of client code):
public final class Preconditions {
```
/**
* Proposed method to be introduced. Allows you to specify your own class of exception
*
* @param reference - reference to check
* @param exception - instance of exception to throw if null
* @return reference, if not null
*/
public static <T> T checkNotNull(T reference, RuntimeException exception) {
if (reference == null) {
}
return reference;
}
static class NotFoundException extends RuntimeException {
}
/**
* That's how we're doing check in our current project and how it usually looks in 3rd party libraries
*/
public void exampleOne(Object reference) {
if (reference == null) {
throw new NotFoundException();
}
// ...
}
/**
* That's an example which would be possible to have with new utility method
*/
public void exampleTwo(Object reference) {
checkNotNull(reference, new NotFoundException());
// ...
}
```
}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1388#c1) posted by **jamie.spencer.86** on 2013-04-28 at 12:32 PM_
---
```
// a template for some class Constraint
// think of Constraint as almost being an Object version of Preconditions.check[...]
public static abstract class SkeletalConstraint<T, X extends Throwable>
public T apply(T input) throws X {
if (accepts(input))
return input;
throw throwableWith(input);
}
protected abstract X throwableWith(T input);
public abstract boolean accepts(T input);
}
// Predicate to test
// Function<? super List<?>, ? extends X>: List<?> is [input, description of constraint]
// String to describe the constraint
static class ConstraintFromFunction<T, X extends Throwable>
final Predicate<? super T> predicate;
final Function<? super List<?>, ? extends X> function;
final String string;
ConstraintFromFunction(
Predicate<? super T> predicate,
Function<? super List<?>, ? extends X> function,
) {
(this.predicate = predicate).getClass(); // not null
(this.function = function).getClass(); // not null
this.string = string == null ? super.toString(): string;
}
protected X throwableWith(T input) {
return function.apply(asList(input, toString()));
}
public boolean accepts(T input) {
return predicate.apply(input);
}
public String toString() {
return string;
}
}
// static factory method
public static <T, X extends Throwable> Constraint<T, X> from(
Predicate<? super T> predicate,
Function<? super List<?>, ? extends X> function,
) {
return new ConstraintFromFunction<>(predicate, function, string);
}
// static factory helper
// just think of it as an simple function
public static <X extends Throwable> Function<List<?>, X> forThrowableOf(
Class<? extends X> clas
) {
return new ClassToInstanceFunction<>(clas); // some function
}
// the following throws a IllegalArgumentException if
// notNull() is false for input
from(
notNull(),
"Argument is non-null"
).apply(input);
```
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1388#c2) posted by **jamie.spencer.86** on 2013-04-29 at 03:03 AM_
---
Concerning above, if iffy about a function that consumes a List<?>, then either creating a parameter object or binding the input to the constraint would have to suffice:
// parameter object
public static class Constraint.Invocation&lt;T> {
&nbsp;&nbsp;&nbsp;public Constraint<? super T> getConstraint() {...} // mainly for toString()
&nbsp;&nbsp;&nbsp;public T getInput() {...}
}
public static interface Invariant&lt;T, X extends Throwable> {
&nbsp;&nbsp;&nbsp;boolean holds(); // analogous to accepts(input)
&nbsp;&nbsp;&nbsp;T hold() throws X; // analogous to apply(input)
}
static &lt;T, X extends Throwable> Invariant&lt;T, X> from(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constraint&lt;T, X> constraint,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T input) {
&nbsp;&nbsp;&nbsp;// ...
}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1388#c3) posted by **Petro.Semeniuk** on 2013-05-02 at 04:56 AM_
---
I totally love usage of Constraint and my only concern that it's marked as deprecated and original design of constraint (as it showed in example) was to throw exception. Having it boolean on accepts is not different from  supplying Predicate to Preconditions...
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1388#c4) posted by **jamie.spencer.86** on 2013-05-02 at 11:19 PM_
---
Yes, I just realized that I hadn't included everything that you may have needed to fully implement this.
```
public interface Constraint<T, X extends Throwable> {
T accept(T input) throws X;
// examines the input and throws an instance of X if
boolean accepts(T input);
// Determines whether the input satisfies this constraint
}
```
The skeletal implementation offers an additional protected method that requires that all subclasses:
- implement the accepting condition.
- provide an instance of X given the input.
SkeletalConstraint above suffices and does not need to be rewritten here. Just change the name of the method apply(T) to accept(T) for consistency.
```
// Predicate to test; toString is used for description
// Function to get Throwable instance of X from String
static class WithPredicateWithFunctionToConstraint<T, X extends Throwable>
final Predicate<? super T> predicate;
final Function<? super String, ? extends X> function;
WithPredicateWithFunctionToConstraint(
Predicate<? super T> predicate,
Function<? super String, ? extends X> function
) {
(this.predicate = predicate).getClass(); // not null
(this.function = function).getClass(); // not null
}
protected X throwableWith(T input) {
return function.apply(predicate+" does not accept "+input);
}
public boolean accepts(T input) {
return predicate.apply(input);
}
public String toString() {
return predicate + " must accept input";
}
}
```
Then have a static factory to clean it up; it could be "one-lined"; the thing about objects is that you can keep them around if they are going to be used frequently:
```
public static final Constraint<Integer, SomeThrowable> constraint =
Constraints.from(Range.greaterThan(0), forSomeThrowable());
...
```
or
```
Constraints.from(Range.greaterThan(0), forSomeThrowable()).accept(someArg);
```
forSomeThrowable() returns any such function from String to SomeThrowable. Having a utility class that works with creating standard Throwables and provides builders/suppliers and functions for them definitely eases the thought behind Constraints.from().
I hope I helped; I've just now found the time to properly work with writing a API for this.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1388#c5) posted by **jamie.spencer.86** on 2013-05-02 at 11:43 PM_
---
In the above example, I suppose your function (String) -> X may actually want to examine Predicate and T separately.  In this instance, you would likely want to pass some "bound predicate" object to function instead of a mere String:
```
public interface Proposition {
boolean holds();
}
public class BoundPredicate<T> implements Proposition {
...
public String toString() { return predicate+" ("+input+")";}
}
Propositions.from(predicate, input);
static class WithPredicateWithFunctionToConstraint<T, X extends Throwable>
...
WithPredicateWithFunctionToConstraint(
Predicate<? super T> predicate,
Function<? super Proposition, ? extends X> function
) {
...
}
protected X throwableWith(T input) {
return function.apply(Propositions.from(predicate, input));
}
...
}
```
The generic type of the function parameter of Constraints.from would change to <? super Proposition>.
That's a lot, but that should be strong.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1388#c6) posted by **wasserman.louis** on 2013-05-03 at 12:45 AM_
---
This all seems like an awful lot of complexity for something that isn't all _that_ bad as it stands, without any additional support?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1388#c7) posted by **jamie.spencer.86** on 2013-05-03 at 01:38 AM_
---
I just feel as if the the selling point of Preconditions is that it throws a standard exception best-suited for the precondition checked.  I'd be more comfortable with NullPointerException at least being the cause of the specified run-time exception:
```
public static <T> T checkNotNull(T reference, RuntimeException exception) {
if (reference == null) {
exception.initCause(Throwables.illegalNull());
}
return reference;
}
```
An exception is thrown if the specified exception has already initialized its cause.  At least then, checking for non-null values would have something to do with NullPointerExceptions. Otherwise, I'd see something general being the alternative.
I didn't want to get carried away.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1388#c8) posted by **jamie.spencer.86** on 2013-05-03 at 03:18 AM_
---
Or the specified exception could be the cause of the [NullPointer|IllegalArgument|etc.]Exception; although, the original post didn't ask for that.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1388#c9) posted by **lowasser@google.com** on 2013-05-03 at 09:29 PM_
---
> Very often on null reference there's need to throw custom exception instead of just standart NPE.
I have to admit I don't follow why this is true.
---
**Labels:** `Type-Addition`, `Package-Base`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1388#c10) posted by **Petro.Semeniuk** on 2013-05-06 at 03:18 AM_
---
Hi guys, just want to re-iterate on what exactly I'm proposing. From code patterns in my codebase and open source libraries I looked into null values usually need to result in custom exception. Example:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (reference == null) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new NotFoundException();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;>>>> I have to admit I don't follow why this is true
I have to admit I'm surprised by this :-))). If you check guava's own  codebase(https://code.google.com/p/guava-libraries/) using next grep:
&nbsp;&nbsp;&nbsp;&nbsp;grep -A 3 -r "== null" . | grep if -A 3 | grep throw -B 3
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1388#c11) posted by **cgdecker** on 2013-05-06 at 03:41 PM_
---
Preconditions is primarily for catching programmer errors in which the programmer fails to call a method correctly, for example not ensuring that an argument isn't null. When that happens, it's generally appropriate to throw a standard exception indicating the error (e.g. NPE). checkNotNull()'s role is basically to produce a NPE as early as possible since if it didn't, you'd end up getting a NPE later when you tried to do something else and it would be harder to find where the null came from.
When you want to throw a different type of exception, that indicates to me that you're doing something different... you aren't just trying to catch programmer errors, you're trying to use checkNotNull() for some other kind of validation or business logic. That's just not really what Preconditions is for.
Additionally, what you're proposing (passing an exception instance to the method) has really bad performance implications. Creating an exception is a fairly heavyweight operation since it involves creating a stack trace. Normally this isn't a big deal, since you only pay that cost when something goes wrong. But if you're creating an exception every time you use a method like this even though ~100% of the time you shouldn't be using that exception at all, that's just not good. The alternatives, using reflection or a Supplier to create the exception, aren't great either.
In short, if you want a method that throws a NotFoundException when a reference is null, I'd recommend just creating such a method yourself.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1388#c12) posted by **Petro.Semeniuk** on 2013-05-07 at 12:35 AM_
---
Hi Colin,  thanks for mentioning performance implications of exception creation. I haven't though about that.
This thing alone is enough not to have this functionality. Using reflection(ie passing exception class together with string arguments for message) would complicate things and will result in less readable code than on if/else statement.
If no other concerns I think it's ok to close this issue as `Won't Fix`.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1388#c13) posted by **cgdecker** on 2013-05-07 at 03:05 AM_
---
_(No comment entered for this change.)_
---
**Status:** `WontFix`
A few things:
1 We've wondered if it's worth changing the Google style guide to permit...
`if (!expression()) throw new MyCustomRuntimeException();`
...which is the same length as...
`check(expression, () -> new MyCustomRuntimeException());`
It's longer than...
`check(expression, MyCustomRuntimeException::new);`
...but at least some of the value of the proposed method would be the ability to provide a message, which you can't normally get with a method reference.
And if it's really coming up a lot, you might be better served by:
Anyway, if we might someday update the style guide, we probably don't want a helper.
2 A few months ago, we talked about providing `Supplier` instances for common exception types, with the goal of making it easier to provide informative messages for `Optional.orElseThrow`:
That might argue in favor of embracing a `Supplier<Throwable>` pattern.
All that said, this won't be a priority soon. It raises questions about which `Supplier` to use (ours? Java 8's?). Also, putting it in Guava doesn't provide a big benefit in comparison to putting it in your own project, given that it's simple to implement.  _[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1387) created by **beradrian** on 2013-04-26 at 01:59 PM_
---
Add methods to Files class to convert Predicate&lt;File> from/to FileFilter and FilenameFilter.
Add file comparators by name, full path, size, type, last modified date etc.
Add filters for size and last modified date similar to isFile/isDirectory.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1387#c1) posted by **beradrian** on 2013-04-26 at 02:00 PM_
---
I would like to implement it, if accepted.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1387#c2) posted by **kevinb@google.com** on 2013-11-20 at 10:21 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
**Labels:** `Package-IO`, `Type-Addition`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1383) created by **ogregoire** on 2013-04-24 at 03:30 PM_
---
When I start a new project and want to add Guava to the Maven dependencies by using the m2e interface, I end up with the following:
```
<dependency>
<groupId>com.google.guava</groupId>
<version>14.0.1</version>
<type>bundle</type>
</dependency>
```
And right after that m2e is complaining that it cannot find the artifact named "com.google.guava:guava:bundle:14.0.1". I have to manually remove "<type>bundle</type>" from the pom.xml to import Guava successfully. This is the default choice when importing from m2e since version 14.0-rc2 (see picture attached). Given that my eclipse version hasn't changed in a while but Guava's versions did, I suppose the issue has more to do with Guava than it has with m2e.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1383#c1) posted by **cgruber@google.com** on 2013-04-24 at 04:11 PM_
---
Given this, I"ll make it a point for 15 to find a better way to get the OSGI stuff in place without using a separate artifact type, or figure out what we can change otherwise to make this issue go away.
---
**Status:** `Accepted`
**Owner:** cgruber@google.com
**Labels:** `Type-Other`, `Package-General`, `Milestone-Release15`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1383#c2) posted by **cgdecker@google.com** on 2013-07-03 at 05:58 PM_
---
Any updates on this?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1383#c3) posted by **cgruber@google.com** on 2013-07-29 at 07:15 PM_
---
So after some digging, we're of the opinion that we need to mark this as will-not-fix.  The issue is that bundles output .jars, so the fact that M2E adds a <type>bundle<type> which looks for .bundle is an error in either M2E or the bundle type itself.  The workaround is trivial - remove <type>bundle<type> from your pom.xml.  We have changed how we package, but the way we are doing it isn't an error, the tools are simply not behaving reasonably.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1383#c4) posted by **cgruber@google.com** on 2013-07-29 at 07:15 PM_
---
_(No comment entered for this change.)_
---
**Status:** `WontFix`
---
Ok. Thanks!
I've reported the issue to m2e. https://bugs.eclipse.org/bugs/show_bug.cgi?id=414209
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1382) created by **electrum** on 2013-04-23 at 10:31 PM_
---
It's common to be in a situation where precondition is known to be violated, but the condition can't be checked for directly by a Precondition method. For example:
```
if (...) {
} else if (...) {
} else {
}
```
When this occurs, we want to throw an exception with a formatted message, so we have two options:
1) Use checkArgument() or checkState() with "false" as the condition
2) Throw the exception and use String.format()
The first option has the advantages of being shorter and providing safety in the case of a malformed format string. But it still looks a bit ugly and seems less than ideal.
It would be nice to have factories that take Precondition-like format strings for at least the following common exceptions:
- AssertionError
- RuntimeException
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1382#c1) posted by **electrum** on 2013-04-23 at 10:40 PM_
---
Another benefit of this over using checkArgument(false) is that the compiler knows it always throws, allowing use in more situations than checkArgument(false).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1382#c2) posted by **wasserman.louis** on 2013-04-23 at 10:44 PM_
---
Additional handy fact: the Preconditions.format implementation is GWT-compatible; String.format is not.
If we do decide to do this, it might also be worth supporting the case where you're wrapping another exception with a formatted error message -- e.g. just earlier today I saw some code
```
try {
...
"Invalid authority '" + authority + "' found in URI '" + uri + "'", e);
}
```
I kinda like this request, but like all features that make a single-line operation a shorter single line, it'd need method names that are both good and short to be convincingly worthwhile, I think?  Do you have method name suggestions?
(FWIW, I would never use checkArgument(false); I'd basically always prefer to either hardcode string concatenation, or use String.format.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1382#c3) posted by **jysjys1486** on 2013-04-23 at 11:23 PM_
---
-- assertionFailed(...)
-- failed(...)
-- unsupportedOperation(...)
-- unsupported(...)
//---------------------------------------------------------------------------
// Classes that have the basic constructors [(), (String), (Throwable), etc]
//---------------------------------------------------------------------------
&lt;X extends Exception, T> T raiseException(Class<? extends X>, ...) throws X
&lt;X extends Error, T> T raiseError(Class<? extends X>, ...) throws X
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1382#c4) posted by **electrum** on 2013-04-24 at 12:36 AM_
---
The names could be the same as the exception:
```
```
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1382#c5) posted by **electrum** on 2013-04-24 at 12:37 AM_
---
Related, having a public version of the Preconditions.format() method would be handy.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1382#c6) posted by **wasserman.louis** on 2013-04-24 at 01:04 AM_
---
> Related, having a public version of the Preconditions.format() method would be handy.
How would that be different from String.format, other than GWT compatibility?
> throw illegalArgumentException(e, "Invalid authority '%s' found in URI '%s', authority, uri);
If you're not using static imports, this seems to be only a few characters shorter than than the alternatives, depending on how you name the class:
> throw Exceptions.illegalArgumentException(e, "Invalid authority '%s' found in URI '%s', authority, uri);
versus
> throw new IllegalArgumentException(e, String.format("Invalid authority '%s' found in URI '%s', authority, uri));
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1382#c7) posted by **electrum** on 2013-04-24 at 02:38 AM_
---
The big difference is that it's safe if you mess up the format string, which is likely for unexpected conditions that aren't covered by unit tests.
---
Well, it adds readability. Because this is the real code that we use:
throw new IllegalArgumentException(String.format("Invalid authority '%s' found in URI '%s', authority, uri), e);
Also, to be honest, with the great work you have done with Guava over the past years, people use static imports _a lot_; if one library has really popularized those imports, it's Guava. So most of the time, it's not a few characters less: it's nearly half a line less verbose for the same outcome.
I would rather use names like "illegalArgument" than "illegalArgumentException", because with the "throw" before it, the context is already huge and we _know_ it's an exception. So yes, we remove a lot of characters to focus on the essential: that we throw, that it's an IllegalArgumentException and that we provide several parameters to the message.
[1] http://bugzilla.slf4j.org/show_bug.cgi?id=116
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1382#c9) posted by **phwendler** on 2013-04-26 at 08:48 AM_
---
I like the whole idea, and specifically I think removing the "Exception" from the method name is nice and keeps the line more readable. People who want to see the "Exception" part would not use a static import and have "throw Exceptions.illegalArgument" instead of "throw new IllegalArgumentException".
is really more readable than
throw new IllegalArgumentException(String.format("Invalid authority '%s' found in URI '%s', authority, uri), e);
The amount of saved characters might not be that much in total, but it removes all the irrelevant stuff from the beginning of the line.
Another nice use case can be
public void add(T obj) {
&nbsp;&nbsp;unsupportedOperation("Object '%s' added to immutable list", obj);
}
where you don't even need the "throw" if the factory method throws itself and the code becomes almost declarative.
---
No phwend, the factory method shouldn't throw the exception. Transform your method add to make it return a value and you'll see why.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1382#c11) posted by **phwendler** on 2013-04-26 at 09:07 AM_
---
I know that in cases where you need to tell the compiler that this will always throw, you need to put the "throw" in front of the method call, but if the factory method throws, you don't need to do this everywhere. Even more important, it is now not a problem if you forget the "throw".
The same principle is used by the methods in the Throwables class.
---
It shouldn't throw the exception because this is a factory method. We might still want to do things with the exception prior to throwing it.
1. we don't have a simple and elegant way to add variables in the message
2. the cause isn't the first parameter
Throwing it isn't really a problem.
This is not the same case as Throwables. Throwables solves a problem linked to the types of exception, where we propagate and stuff like that. Here it's a request to make the creation of the most common exceptions easier.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1382#c13) posted by **cgdecker** on 2013-04-26 at 06:33 PM_
---
So, the main reason for Preconditions taking a format string and args is so that it can avoid building a string when no exception needs to be thrown (the majority of the time). In this case, you're always going to be creating and throwing the exception so it's not that valuable. Certainly not worth adding new APIs for, in my opinion.
---
**Labels:** `Type-Addition`, `Package-Base`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1382#c14) posted by **jamie.spencer.86** on 2013-04-26 at 07:11 PM_
---
Is it also practical to include methods that can create any Throwable so long as the Throwable subclass provides the standard constructors?
&nbsp;&nbsp;&nbsp;public static &lt;X extends [Exception|Throwable]> X [exception|throwable](&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Class<? extends X> clas,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object errorMessage
&nbsp;&nbsp;&nbsp;) throws X {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// returns new X(String.valueof(errorMessage));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// throws IllegalArgument for classes that do not provide X(String)
&nbsp;&nbsp;&nbsp;}
}
This would seem to be a bit more flexible than Supplier<? extends Exception> or specific static factory methods.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1382#c16) posted by **jamie.spencer.86** on 2013-04-27 at 06:53 PM_
---
This is an example:
// clas must provide a (String, Throwable) constructor
static &lt;X extends Throwable> X throwable(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Class<? extends X> clas,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Throwable cause,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object... args
) {
```
MethodType methodType = MethodType.methodType(
void.class, String.class, Throwable.class);
MethodHandles.Lookup lookup = MethodHandles.lookup();
MethodHandle handle;
try {
handle = lookup.findConstructor(clas, methodType);
} catch (NoSuchMethodException | IllegalAccessException e) {
}
try {
return (X) handle.invoke(String.format(format, args), cause);
} catch (Throwable e) {
}
```
}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1382#c17) posted by **lowasser@google.com** on 2013-05-03 at 09:21 PM_
---
_Issue #1164 has been merged into this issue._
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1378) created by **anthony.musyoki** on 2013-04-23 at 01:28 PM_
---
It would be good if a splitter could be configured to retain the delimiter in the returned iterable
Thus
Splitter splitter = Splitter.on(CharMatcher.DIGIT).trimResults().retainDelimiter();
String input = "1 one 2 two 3 three 50 fifty";
Iterable&lt;String> output = splitter.split(input);
should yield
[1,one,2,two,3,three,50,fifty]
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1378#c1) posted by **lowasser@google.com** on 2013-05-03 at 09:20 PM_
---
So you're suggesting the delimiters should be their own groupings?  This particular example could equally well be written as Splitter.on(CharMatcher.WHITESPACE).omitEmptyStrings() and would get the same result.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1378#c2) posted by **anthony.musyoki** on 2013-05-06 at 08:13 PM_
---
In the above case that would work but am sure you are aware in many other cases it wouldn't be that simple.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1372) created by **electrum** on 2013-04-18 at 06:31 PM_
---
It's often useful to use a Callable instead of a Runnable when you don't have anything to return but need to allow throwing exceptions (for example, when submitting a job to an ExecutorService). Having a standard class for this would eliminate a bit of boilerplate and improve readability:
```
public abstract class VoidCallable
implements Callable<Void>
{
public final Void call()
{
run();
return null;
}
protected abstract void run()
}
```
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1372#c1) posted by **wasserman.louis** on 2013-04-26 at 05:10 AM_
---
Is VoidCallable really that much better than Callable&lt;Void>?  The difference seems to be only two characters and the "return null" line.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1372#c2) posted by **kevinb@google.com** on 2013-11-20 at 10:22 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Concurrent`, `Type-Addition`
---
VoidCallable is something like Runnable which can be wrapped by http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/Executors.html#callable%28java.lang.Runnable%29 .
//-----------VoidCallable version-----------
VoidCallable c = new VoidCallable() {
&nbsp;&nbsp;protected void run() throws Exception {
&nbsp;&nbsp;}
}
executor.submit(c);
//-----------Runnable version-----------
Runnable r = new Runnable() {
&nbsp;&nbsp;public void run() throws Exception {
&nbsp;&nbsp;}
}
executor.submit(Executors.callable(r));
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1371) created by **heuermh** on 2013-04-18 at 05:14 PM_
---
As of version 15.0-SNAPSHOT, RangeMap does not have an explicit size() method
https://google.github.io/guava/apidocs/com/google/common/collect/RangeMap.html
The size can be queried through the Map view
int size = rangeMap.asMapOfRanges().size();
In my use case I want the sizes of sub ranges, so I would be viewing a view just to get the size
int size = rangeMap.subRangeMap(Range.closed(1, 42)).asMapOfRanges().size();
I assume that views are implemented efficiently but it would be nice to have size() directly on RangeMap.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1371#c1) posted by **wasserman.louis** on 2013-04-18 at 05:31 PM_
---
---
**Labels:** `Package-Collect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1371#c2) posted by **stephan202** on 2013-04-18 at 07:06 PM_
---
> [..] I'm somewhat concerned that that's easily confused with some measure of the "size of the ranges," e.g. that a RangeMap with a Range from 1 to 42 would have size 42, or something along those lines.  Thoughts?
When I read the title of this ticket, i.e. before I clicked on it, that was the first semantics for RangeMap#size() I came up with. Admittedly I haven't yet used RangeMap extensively, but I guess it does show that your concern is warranted.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1371#c3) posted by **heuermh** on 2013-04-18 at 07:12 PM_
---
Thank you for the quick replies.
As I work more with RangeMap (in the context of storing features on genomic sequences, see e.g. http://www.sequenceontology.org/gff3.shtml), I am finding that most of my interaction will be through the asMapOfRanges() view.
I also think the concern about confusion with size() is valid; I would be ok marking this issue as WontFix, perhaps after being left a while for further comment.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1371#c4) posted by **jysjys1486** on 2013-04-20 at 05:57 AM_
---
{
&nbsp;&nbsp;&nbsp;[0,5)=A
&nbsp;&nbsp;&nbsp;[10,14)=B
&nbsp;&nbsp;&nbsp;[40,42)=C
}
size = rangeMap.size(integers());
// size = 5 + 4 + 2 = 11
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1371#c6) posted by **jysjys1486** on 2013-04-23 at 05:10 AM_
---
Also, to this effect, I suppose: is it practical to have a view of the comparable items to the associated values? I suppose it would be akin to a ContiguousSet.
i.e.
Range&lt;Integer> range;
Object o;
Map.Entry&lt;Range&lt;Integer>, Object> entry;
...
ContiguousMap.create(domain, range, o);
ContiguousMap.create(domain, entry);
...
RangeMap&lt;Integer, Object> rangeMap;
Map&lt;Range&lt;Integer>, Object> mapOfRanges;
...
PiecewiseMap.create(domain, rangeMap);
PiecewiseMap.create(domain, mapOfRanges);
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1371#c7) posted by **markus.schneider.sic** on 2013-09-02 at 06:22 AM_
---
If size() is not added to the interface is it possible to get isEmpty() analogous to RangeSet#isEmpty()?
I think it is probably best to leave size() off because of the ambiguity; asMapOfRanges().size() should be more clear.
isEmpty() is not ambiguous, though.  Should we add that?
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1370) created by **g...@maginatics.com** on 2013-04-16 at 05:54 PM_
---
This creates an infinite-length InputStream which returns zero bytes.  Combined with ByteStreams.limit this can create large input for tests without consuming large amounts of memory.
I created an example with tests here:
https://github.com/maginatics/guava-libraries/pull/1
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1370#c1) posted by **kak@google.com** on 2013-04-16 at 05:57 PM_
---
_(No comment entered for this change.)_
---
**Owner:** cgdecker@google.com
**Labels:** `Type-Addition`, `Package-IO`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1370#c2) posted by **g...@maginatics.com** on 2013-08-22 at 04:45 AM_
---
https://github.com/maginatics/guava-libraries/pull/2
One could also expose an infinite length non-zero stream which I use for testing as well.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1370#c3) posted by **g...@maginatics.com** on 2013-12-27 at 06:21 PM_
---
I made this utility method more generic and updated it for ByteSource:
```
/**
* @return an infinite-length ByteSource which repeats the contents of a
*         byte array
*/
public static ByteSource repeatingArrayByteSource(final byte[] input) {
return ByteSource.concat(Iterables.cycle(ByteSource.wrap(input)));
}
```
Callers can use ByteSource.slice to make make input the desired size.  The implementation was not obvious to me and perhaps this is useful to others.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1367) created by **phwendler** on 2013-04-10 at 11:43 AM_
---
I propose to add two methods "OutputStream closeProtect(OutputStream)" and "InputStream closeProtect(InputStream)" to the ByteStreams class. The methods would take the given stream and return a wrapper that simply forwards all method calls except for "close()", so that calling "close()" on the returned stream will have no effect.
Use cases for this are for example cases where you wrap a stream into another stream and want to close the wrapper stream, but not the wrapped stream. I have a concrete use case for this that is described in this StackOverflow question: http://stackoverflow.com/q/15907105/396730
The methods could of course also have different names, e.g., "preventClosingOf" or "uncloseableStream".
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1367#c1) posted by **kevinb@google.com** on 2013-11-20 at 10:23 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-IO`, `Type-Addition`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1366) created by **kevinb@google.com** on 2013-04-08 at 08:23 PM_
---
https://code.google.com/p/guava-libraries/wiki/ThrowablesExplained explains that Throwables.propagate() is not nearly as useful a method as we once thought it would be.
Yep, thanks.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1365) created by **se.solovyev** on 2013-04-08 at 07:40 PM_
---
Current implementation of com.google.common.util.concurrent.ListenableFutureTask doesn't provide method for removing FutureCallback added via com.google.common.util.concurrent.Futures#addCallback method.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1365#c1) posted by **cpovirk@google.com** on 2013-04-08 at 07:43 PM_
---
Now that you mention it, I'm kind of shocked that this hadn't even occurred to me before. As far as I know, it's never come up. Under what circumstances do you want to remove listeners?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1365#c2) posted by **se.solovyev** on 2013-04-08 at 07:57 PM_
---
Currently I'm working on a library which is mostly used in Android.
Here are the sources of the class which implements background task management (adding, running, cancelling and so on): https://github.com/serso/common/blob/master/tasks/src/main/java/org/solovyev/tasks/TaskServiceImpl.java
Usually, tasks which run in background do significant amount of work (e.g. they work for several seconds and even more). If tasks are run from Android UI (and the result of the task will update UI) I add FutureCallback in order to receive result. User can close-reopen app (or just rotate the phone - the main point that view is reconstructed) and I need to remove and reattach callbacks so the "current" view will receive the result (and not the closed one). I use WeakReference to prevent memory leaks of views but GC is not so fast and some references are still valid even after the views are destroyed, that's why I want to use 'remove' method - to be sure that callback will never be called for not active ("destroyed") view.
I looked through the code and found that the problem point us in com.google.common.util.concurrent.Futures#addCallback method - here we wrap FutureCallback with Runnable and forget equals/hashCode methods. After Runnable is fixed one can add removeListener method in com.google.common.util.concurrent.ListenableFuture interface.
It's really strange that I am the first person who face the problem as it seems to be quite common operation on a long background tasks.
Thank you for your quick answer, hope it will be fixed.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1365#c3) posted by **wasserman.louis** on 2013-04-08 at 08:09 PM_
---
I'd imagine the "traditional" way to address this issue is to move that logic into the callback itself somehow -- e.g. keep track of the callbacks yourself, and store a field in the callback tracking which view should receive its result.
I don't know how many people roll their own ListenableFuture implementation instead of extending one of Guava's, but wouldn't adding a method there break all those users?
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1362) created by **jysjys1486** on 2013-04-07 at 09:07 AM_
---
In case something other than TypeToInstanceMap wanted to disallow those unresolved type variables, would rejectTypeVariables cause any problems if it were public?
There doesn't seem to be any higher-level operation that provides this and it would seem to be useful to anyone trying to implement something (heterogeneous collections) around TypeToken.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1362#c1) posted by **jysjys1486** on 2013-04-07 at 10:21 AM_
---
I'll add that rejecting type variables could be done, ad-hoc:
class Example {
&nbsp;&nbsp;&nbsp;TypeToInstanceMap&lt;Object> map = new MutableTypeToInstanceMap<>();
&nbsp;&nbsp;&nbsp;TypeToken<?> token;
&nbsp;&nbsp;&nbsp;Object value;
&nbsp;&nbsp;&nbsp;&lt;T> void set(TypeToken&lt;T> token, T value) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.getInstance(token); // rejects type variables
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.token = token;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.value = value;
&nbsp;&nbsp;&nbsp;}
}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1362#c2) posted by **benyu@google.com** on 2013-04-11 at 05:45 PM_
---
Internally we only have this one use case so that's why it's not public.
Can you describe your use case?
My uncertainty has been that different use cases may need slightly different functionality. For example, in addition to type variable, maybe wildcards also need to be excluded. Or maybe generic array isn't supported either.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1362#c3) posted by **benyu@google.com** on 2013-04-11 at 05:46 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
**Owner:** benyu@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1362#c4) posted by **jysjys1486** on 2013-04-12 at 04:04 AM_
---
My use case was constructing some set of heterogeneous collections; the backing structure of these is a simple entry-like class (immutable) that composites a TypeToken and an associated value.
public interface Typable&lt;B> {
```
// is the value null?
boolean isNulled();
TypeToken<? extends B> getToken();
B get();
<T extends B> T get(TypeToken<T> type);
<T extends B> T get(Class<T> clas);
// Optional.fromNullable(get())
Optional<B> opt();
<T extends B> Optional<T> opt(TypeToken<T> type);
<T extends B> Optional<T> opt(Class<T> clas);
boolean equals(Object o);
int hashCode();
Map.Entry<TypeToken<? extends B>, B> toEntry();
```
}
Reasons for being able to reject type tokens are pretty much the same as TypeToInstanceMap. I suppose I'll attach sources of Typable; I may be doing some things incorrectly.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1362#c5) posted by **benyu@google.com** on 2013-04-12 at 04:36 AM_
---
I see. Sounds like a reasonable use case.
Still, two use cases don't make a strong case for a public API, especially one that feels a bit weird.
And then, some day another use case of rejecting wildcards might even come up. So whether we need a more generic/flexible API is still unclear to me.
So while you have a relatively simple work-around, I'd like to punt on this for a while and maybe revisit later when more use cases come up.
Thanks for sharing your use case!
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1362#c6) posted by **jysjys1486** on 2013-04-12 at 12:49 PM_
---
I'll add another thought, not of high priority necessarily; being able to, at least, assert that a TypeToken type is "concrete."
i.e.
is either a class with no type parameter (String, ExecutorService, and not T, ?), or is a concrete parameterized type (List&lt;Integer>, Comparable&lt;Complex>, and not Collection<?>, Class<? extends Object>, Future&lt;T>)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1362#c7) posted by **benyu@google.com** on 2013-04-12 at 01:06 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1362#c8) posted by **jysjys1486** on 2013-04-12 at 01:53 PM_
---
i.e.
boolean containsAnyOf(Class<? extends Type>... types)
boolean containsAnyOf(TypeToken<? extends Type>... types)
// This would be able to traverse type parameters to find any of the specified types
containsAnyOf(TypeVariable.class)
containsAnyOf(TypeVariable.class, Wildcard.class)
containsAnyOf(new TypeToken&lt;Class&lt;Object>>(){})
Map&lt;K, Collection<?>>
&nbsp;// true
&nbsp;// true
&nbsp;// false
Map&lt;String, Collection&lt;Future<?>>>
&nbsp;// false
&nbsp;// true
&nbsp;// false
Map&lt;Class<?>, Collection&lt;Object>>
&nbsp;// false
&nbsp;// true
&nbsp;// true
Map&lt;String, Collection&lt;Object>>
&nbsp;// false
&nbsp;// false
&nbsp;// true
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1362#c9) posted by **benyu@google.com** on 2013-04-12 at 02:21 PM_
---
I'm with you.
It's occurred to me a few times that there is a distinction between fully known types (Foo.class, List&lt;Foo>) and partially unknown types (List<?>, Map&lt;K, String> A[] etc).
I also searched but didn't find this concept being clearly defined anywhere. That's one reason a isConcrete() method doesn't exist today in TypeToken.
Another issue is, I find myself needing slight variants of the concept anyway. For example in TypeToInstanceMap I need rejectTypeVariable() while wildcards work fine for my purpose.
That strengthened the doubt that a isConcrete() method will be truly useful.
The containsAnyOf() is clearly more flexible. I thought about it and it's what I referred to as "a more generic/flexible API".
Though I wasn't sure if it's really the optimal API form. It feels a bit over flexible. Is this even meaningful?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1362#c11) posted by **jysjys1486** on 2013-04-12 at 02:51 PM_
---
From my understanding, Class would have to be parameterized to extend Type:
T // false
Object // true, Class.class.isInstance(Object)
LinkedList // true, Class.class.isInstance(LinkedList)
LinkedList&lt;T> // true, Class.class.isInstance(LinkedList)
LinkedList&lt;Object> // true, Class.class.isInstance(LinkedList)
LinkedList<?> // true, Class.class.isInstance(LinkedList)
The above would likely give a raw type warning. From my understanding, below would avoid raw type warning:
containsAnyOf(
&nbsp;&nbsp;&nbsp;new TypeToken&lt;Class<?>>() {},
&nbsp;&nbsp;&nbsp;TypeToken.of(Wildcard.class)
)
T // false
? // true, TypeToken.of(Wildcard.class).isInstance(LinkedList)
Object // true, new TypeToken&lt;Class<?>>() {}.isInstance(LinkedList)
LinkedList // true, new TypeToken&lt;Class<?>>() {}.isInstance(LinkedList)
LinkedList&lt;T> // true, new TypeToken&lt;Class<?>>() {}.isInstance(LinkedList)
LinkedList&lt;Object> // true, new TypeToken&lt;Class<?>>(){}.isInstance(LinkedList)
LinkedList<?> // true, new TypeToken&lt;Class<?>>() {}.isInstance(LinkedList)
And it has just occurred to me that handling GenericArrayType would have to be well enough defined:
containsAnyOf(
&nbsp;&nbsp;&nbsp;new TypeToken&lt;Class<?>>() {},
&nbsp;&nbsp;&nbsp;TypeToken.of(Wildcard.class)
)
LinkedList<?>[] // ?; possibly true?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1362#c12) posted by **jysjys1486** on 2013-04-12 at 03:13 PM_
---
ignore the spiel about raw type warning.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1362#c13) posted by **jysjys1486** on 2013-04-12 at 04:24 PM_
---
I would assume that adding methods (aside from TypeToken.getComponentType()) that allow for walking through specific types clutters API...
It could be done by introspecting the Type returned by TypeToken.getType(), but providing a few methods could ease having to check getType().
isParameterized()
getActualTypeArguments()
getOwnerTypes()
&nbsp;// from ParameterizedType
&nbsp;//// getActualTypeArguments
&nbsp;////// Class, WildcardType, TypeVariable return empty array
&nbsp;//// getOwnerType
&nbsp;////// Class.getEnclosingClass?
&nbsp;////// WildcardType and TypeVariable would return the "owner types" of
&nbsp;////// their upper bounds (possibly an empty array)
isArray()
getComponentType()
// they exist already. these covers a lot
isVariable()
getUpperBounds()
getLowerBounds()
&nbsp;//// [Class.this, GenericArrayType.this, TypeVariable.getBounds]
&nbsp;//// suffice for upper bound.
&nbsp;//// [Class.this, GenericArrayType.this, TypeVariable.this] suffice
&nbsp;//// for lower bound.
containsAnyActualTypeArgumentsOf(TypeToken<? extends Type>...)
containsAny[Upper|Lower]BoundsOf(TypeToken<? extends Type>...)
&nbsp;// 1-level checks, these wouldn't go deep into anything.
containsAnyOf(
&nbsp;&nbsp;&nbsp;&nbsp;Iterable<? extends TypeToken<? extends Type>,
&nbsp;&nbsp;&nbsp;&nbsp;WalkOption...)
enum WalkOption {WALK_COMPONENT_TYPE, WALK_ACTUAL_TYPE_ARGUMENTS, WALK_UPPER_BOUNDS};
&nbsp;// I doubt these would be implemented. These would deeply check
&nbsp;// a token for any of the specified types.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1362#c14) posted by **jysjys1486** on 2013-04-12 at 04:43 PM_
---
add to WalkOption: WALK_RAW_TYPE; this would be the default if no options are specified; essentially:
final Class<?> raw = getRawType();
for (TypeToken<? extends Type> token : tokens)
&nbsp;&nbsp;&nbsp;if (token.getType().isAssignableFrom(raw))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;
return false;
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1362#c15) posted by **benyu@google.com** on 2013-04-12 at 06:31 PM_
---
isParameterized() - equivalent to getType() instanceof ParameterizedType
isVariable() - getType() instanceof TypeVariable
So I don't feel their addition brings a lot of value.
getActualTypeArguments() - I'm afraid some users might expect different behavior for <? extends ImmutableLIst&lt;String>>. In other words, we are trying to extend the "actual type parameters" concept in a potentially ambiguous way.
getOwnerTypes()
getUpperBounds()
getLowerBounds()
---- these don't feel needed often enough to justify the API addition
containsAnyActualTypeArgumentsOf(TypeToken<? extends Type>...)
containsAny[Upper|Lower]BoundsOf(TypeToken<? extends Type>...)
---- From time to time, I needed to do some kind of type traversal. containsAny() may be one of them, but not necessarily the only one or the most common one. I haven't been able to think of a common API form that's simple and flexible enough to cover all of them, sadly.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1362#c16) posted by **jysjys1486** on 2013-04-12 at 07:01 PM_
---
Your getActualTypeArguments() <em>should</em> actually get String from <? extends ImmutableList&lt;String>> then; I typed everything above rather quickly.
getOwnerTypes was added trivially to show that it could be implemented over all types.
getLowerBounds is there for completeness, I suppose.
Do you feel anything towards:
containsAnyOf(
&nbsp;&nbsp;&nbsp;&nbsp;Iterable<? extends TypeToken<? extends Type>>,
&nbsp;&nbsp;&nbsp;&nbsp;WalkOption...)
and would:
containsAnyOf(
&nbsp;&nbsp;&nbsp;&nbsp;Predicate<? super TypeToken<?>>,
&nbsp;&nbsp;&nbsp;&nbsp;WalkOption...)
generalize it? Although, I hope I'm not contriving too much; adding WalkOptions may be a bit of a commitment.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1362#c17) posted by **benyu@google.com** on 2013-04-16 at 02:52 PM_
---
What do you think of a TypeVisitor class that you can use as:
new TypeVisitor() {
&nbsp;&nbsp;@Override void visitTypeVariable(TypeVariable<?> var) {
&nbsp;&nbsp;&nbsp;&nbsp;throw new IllegalArgumentException(...);
&nbsp;&nbsp;}
}).visit(type);
I think I might also be able to use it to get rid of some instanceof calls inside TypeToken.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1362#c18) posted by **jysjys1486** on 2013-04-17 at 11:15 PM_
---
Okay.
I assume that TypeVisitor.visit(TypeToken) exhaustively traverses through the specified token. If so, would there be some method of limiting how deep the search goes? Or do you think that it would be needed?
Is this the gist of the Visitor?
class TypeVisitor {
&nbsp;&nbsp;&nbsp;visit(TypeToken<?> type) { ... }
&nbsp;&nbsp;&nbsp;visitTypeVariable(TypeVariable<?> type) {}
&nbsp;&nbsp;&nbsp;visitGenericArrayType(GenericArrayType type) {}
&nbsp;&nbsp;&nbsp;visitParameterizedType(ParameterizedType type) {}
&nbsp;&nbsp;&nbsp;visitClass(Class<?> type) {}
}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1362#c19) posted by **benyu@google.com** on 2013-04-18 at 12:06 AM_
---
Yeah. I realized that while implementing an internal one too.
- Some visits bounds, owner types and type arguments.
- Some cares about about upper bounds, not lower bounds.
- Some visits generic super types of Class.
- Some visits component type of GenericArray.
The crude version can allow subclass control what it wants to traverse, such as:
new TypeVisitor() {
&nbsp;&nbsp;visitTypeVariable(type) {
&nbsp;&nbsp;&nbsp;&nbsp;visit(type.getUpperBounds());
&nbsp;&nbsp;&nbsp;&nbsp;visit(type.getLowerBounds()):
&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;visit(type.getBounds());
&nbsp;&nbsp;}
&nbsp;&nbsp;visitParameterizedType(type) {
&nbsp;&nbsp;&nbsp;&nbsp;visit(type.getActualTypeArguments());
&nbsp;&nbsp;&nbsp;&nbsp;visit(type.getOwnerType());
&nbsp;&nbsp;}
&nbsp;&nbsp;visitGenericArrayType(type) {
&nbsp;&nbsp;&nbsp;&nbsp;visit(type.getComponentType());
&nbsp;&nbsp;}
}
The catch is, user would need to know what he's doing and drive the traversal in the correct direction. For example, missing to visit getOwnerType() isn't sufficient for rejectTypeVariable() purpose.
There could be other ways to offer a higher level abstraction. But the right API hasn't revealed itself to me yet.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1362#c20) posted by **jysjys1486** on 2013-04-18 at 01:24 AM_
---
Okay.
Covering traversing of a type hierarchy (i.e. Class.getInterfaces()) vs traversal of the components of a type (i.e. upper/lower bounds or component types), and any other forms of traversal seem to cover a broad basis.  TypeVisitor seems to allow for that at a low level; as if to say, "once I know that type is a class, I could possibly traverse its hierarchy without much need for any other methods."
{
&nbsp;&nbsp;visitClass(type) {
&nbsp;&nbsp;&nbsp;&nbsp;// traverse hierarchy
&nbsp;&nbsp;&nbsp;&nbsp;classVisited(type);
&nbsp;&nbsp;&nbsp;&nbsp;visitClass(type.getSuperclass());
&nbsp;&nbsp;}
&nbsp;&nbsp;classVisited(type) {
&nbsp;&nbsp;&nbsp;&nbsp;// act on visited class
&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;visit(type.getBounds());
&nbsp;&nbsp;}
&nbsp;&nbsp;...
}
I feel as if finding an API would entail finding some things specific that you'd want a subclass of TypeVisitor to do (such as merely examining components of a type as mentioned early, or traversing a type hierarchy).
// This examines the type as mentioned in above comments
class TypeDeclarationVisitor() { (?)
&nbsp;&nbsp;visit(types) {
&nbsp;&nbsp;&nbsp;&nbsp;for (type : types)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visit(type);
&nbsp;&nbsp;}
&nbsp;&nbsp;visit(type) {
&nbsp;&nbsp;&nbsp;&nbsp;match (type, instanceof) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case Class<?>: visitClass(type)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case TypeVariable<?>: visitTypeVariable(type)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case ParameterizedType: visitParameterizedType(type)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;}
&nbsp;&nbsp;visitClass(type) {
&nbsp;&nbsp;&nbsp;&nbsp;classVisited(type)
&nbsp;&nbsp;}
&nbsp;&nbsp;visitTypeVariable(type) {
&nbsp;&nbsp;&nbsp;&nbsp;typeVariableVisited(type);
&nbsp;&nbsp;&nbsp;&nbsp;visit(type.getBounds());
&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;visit(type.getUpperBounds());
&nbsp;&nbsp;}
&nbsp;&nbsp;visitParameterizedType(type) {
&nbsp;&nbsp;&nbsp;&nbsp;parameterizedTypeVisited(type);
&nbsp;&nbsp;&nbsp;&nbsp;visit(type.getActualTypeArguments());
&nbsp;&nbsp;&nbsp;&nbsp;visit(type.getOwnerType());
&nbsp;&nbsp;}
&nbsp;&nbsp;visitGenericArrayType(type) {
&nbsp;&nbsp;&nbsp;&nbsp;genericArrayTypeVisited(type);
&nbsp;&nbsp;&nbsp;&nbsp;visit(type.getComponentType());
&nbsp;&nbsp;}
&nbsp;&nbsp;classVisited(type) {}
&nbsp;&nbsp;typeVariableVisited(type) {}
&nbsp;&nbsp;...
}
Subclasses use the [type]Visited(type) methods to do anything relevant (add a visited class to some referenced collection or to assert that a wildcard type has upper bounds, etc.).
At this point, I'm just jotting, but, it seem that, as a root to specialized subclasses, TypeVisitor may ease a good deal of traversal through Types.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1362#c21) posted by **benyu@google.com** on 2013-04-18 at 01:55 AM_
---
ClassVisited() doesn't feel necessary. Subclasses can just override visitClass(), and call super.visitClass() if it wants to follow through the traversal.
This is useful when subclass wants to stop the traversal if something is already found, or that the default traversal works mostly but not for a certain type.
For example, I may want to follow the default traversal except that the lower bounds of type variables are of no use. I could just do:
@Override visitTypeVariable(t) {
&nbsp;&nbsp;// do my thing
&nbsp;&nbsp;visit(t.getUpperBounds());
}
And keep everything else the same.
Regarding traversing over type components vs. type hierarchy. The distinction is still vague. You seem to suggest to use the TypeDeclarationVisitor to mean that we traverse through type bounds, not generic super types of Class.
From another perspective, both "&lt;K extends List> and "class ArrayList extends List" are type _definitions_ with super types defined. Traversing in the case of type variable definition but not Class definition is a bit hard to rationalize without concrete use cases.
So how about having the default implementation only traverse syntactical type components?
&nbsp;&nbsp;visit(t.getBounds());
}
visitGenericArrayType(t) {
&nbsp;&nbsp;visit(t.getComponentType());
}
visitParameterizedType(t) {
&nbsp;&nbsp;visit(t.getOwnerType());
&nbsp;&nbsp;visit(t.getActualTypeArguments());
}
visitClass(t) {}
visitTypeVariable(t) {}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1362#c22) posted by **benyu@google.com** on 2013-04-18 at 02:21 AM_
---
Well. Still, for a TypeVisitor or TypeDeclarationVisitor, it's not the most intuitive that the default implementation visits T of T[], but not String of String[].
And then the default implementation is quite trivial. For the few forwarding it does and the potential confusion it may cause, I can't help doubting whether we want the default implementation, as opposed to leaving every visit*Type() method empty and let subclasses drive.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1362#c23) posted by **jysjys1486** on 2013-04-18 at 02:54 AM_
---
The name was likely poorly conceived.
I want to make certain that I follow you.
Would wildcard types in both Map<?, ?> and <? extends List> invoke the same arguments that you proposed of atomic leaves for Map&lt;K, V> and type definition &lt;K extends List> respectively?  Would we (or not) check the wildcard upper bounds as well if we aren't checking TypeVariable bounds?
Otherwise, and besides that, generally, TypeVisitor could do anything in terms of type traversal; having a few typical subclasses that lean towards specialized traversal would be useful.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1362#c25) posted by **jysjys1486** on 2013-04-18 at 03:00 AM_
---
I don't think a default implementation for a root, TypeVisitor, is needed per se. It would only be help for subclasses that would assert how the implementation generally visits, i.e. a visitor that visits super-types to the root. That would be common, and other users could subclass that easily enough.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1362#c26) posted by **benyu@google.com** on 2013-04-18 at 03:06 AM_
---
Yeah. I was thinking that we follow bounds of wildcards because they syntactically appear in the type reference, while type variable bounds don't appear in the type reference. But then I realized that traversing T for T[] but not String for String[] creates another confusion.
I agree it's mostly about finding a good class name that makes the semantics easy to understand.
Another thought is to call it GenericTypeVisitor:
/*
&nbsp;\* Given a Type, calls corresponding visit_() method according to what kind of Type it is.
&nbsp;_ By default, all generic type components of the Type is visited, until either a raw class is reached,
&nbsp;\* or a type bound recursion is detected. This includes: <ul>
&nbsp;\* <li> T of T[] is visited.
&nbsp;\* <li> List and T of List&lt;T> are visited.
&nbsp;\* <li> T of <? extends T> is visited.
&nbsp;\* <li> Enum&lt;E> of &lt;E extends Enum&lt;E>> is visited.
&nbsp;\* </ul>
&nbsp;\* If a subclass needs to traverse through Class's generic super classes, it can override
&nbsp;\* visitClass() and call visit(clazz.getGenericSuperClass()) and visit(clazz.getGenericInterfaces()).
&nbsp;*/
public abstract GenericTypeVisitor {
&nbsp;&nbsp;...
}
It seems overkill to expose more than one public classes for the type visitor concept. If we are to add it to Guava, I feel we want at most one type and no more.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1362#c27) posted by **jysjys1486** on 2013-04-18 at 03:45 AM_
---
That's reasonable. Most importantly, just so long as the doc explains what's going on by default, there should not be as many problems concerning overriding methods.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1362#c28) posted by **benyu@google.com** on 2013-04-18 at 03:58 AM_
---
That might work.
Now we have a clearer picture of the API. It's still an open question whether such API is worth it. And we need use cases.
Use case 1: rejectTypeVariable().
Is there any other use cases for walking the type components that'd help us make the decision?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1362#c29) posted by **jysjys1486** on 2013-04-20 at 05:24 AM_
---
I'm terrible at finding specific use cases. A Visitor seems versatile; it could practically do anything just so long as its "visiting," and that does not even really even define how a subclass would go about "visiting..."
I suppose, vaguely and obviously, its uses would likely lean towards carrying out common reflection, or maybe, more specifically, traversing type hierarchies, perhaps in mass--selecting classes of a particular match, detecting attributes of classes, and/or collecting specific members of certain, or all, classes.
//----------
collectAllPublicAbstractMethodsInHierarchyVisitor.visit(AbstractSequentialList.class);
Set&lt;Method> methodSet = collectAllPublicAbstractMethodsInHierarchyVisitor.copySet();
// first in hierarchy such that visitor is assignable from the specified type
findTheFirstMatchVisitor.setRelation(assignableFrom(ArrayList.class));
findTheFirstMatchVisitor.visit(AbstractSequentialList.class, Collection.class, String.class);
Set&lt;Type> selection = collectAllPublicAbstractMethodsInHierarchyVisitor.selection();
// selection.isEmpty() == false
// selection -> { AbstractList.class, Collection.class, Object.class }
findTheFirstMatchVisitor.setRelation(hasMethod("setColor(Color?)"));
findTheFirstMatchVisitor.visit(listOfTypes);
// Note, you probably either just collect each setColor method, or even just invoke them during the visit.
//----------
I'd hope that those cases are relevant.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1362#c30) posted by **benyu@google.com** on 2013-04-20 at 02:26 PM_
---
Agreed that visitor is versatile. And it's the reason I'd prefer releasing it over the too-specific rejectTypeVariable() method.
It could be used to traverse super types, but we do have a higher-level abstraction for it: TypeToken.getTypes().
Still, I'm sure I won't convince the team to release it when I can only name one clear use case. Reflection utilities are niche utilities so we don't need a ton of use cases to justify, but ideally we'd want 3, or the single use case must be very commonly needed.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1361) created by **michael.hixson** on 2013-04-05 at 01:27 AM_
---
Occasionally I encounter the need for a utility to encrypt and decrypt strings.  Most (or all?) of those times it's been used to encode some information in a URL or cookies, where I don't want the information to be visible to users or the parameters to be guessable.  These are not passwords and it's not the end of the world if someone breaks the encryption.
It would be nice to have an API for generating secret keys and encryptors based on known, good security algorithms.  The API could save me from dealing with low-level, ugly APIs like Cipher.  Theoretical example:
&nbsp;&nbsp;StringEncryptor encryptor = CipherTransformations.aesCbcNoPadding_128()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.newEncryptor(secretKey) // maybe this is ByteEncryptor?
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.withEncoding(BaseEncoding.base64Url().omitPadding(), Charsets.UTF_8);
&nbsp;&nbsp;String originalMessage = ...
&nbsp;&nbsp;String encryptedMessage = encryptor.encrypt(originalMessage);
&nbsp;&nbsp;Optional&lt;String> decryptedMessage = encryptor.decrypt(encryptedMessage); // present
&nbsp;&nbsp;Optional&lt;String> decryptedGarbage = encryptor.decrypt("garbage"); // absent
Most of the value of this feature would be in the bytes-to-bytes encryption.  So if there was only a "ByteEncryptor" I could pretty easily build my own StringEncryptor on top of it.
For reference, the crypto documentation lists various algorithms that exist on every Java platform:
http://docs.oracle.com/javase/7/docs/api/javax/crypto/KeyGenerator.html
http://docs.oracle.com/javase/7/docs/api/java/security/KeyPairGenerator.html
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1361#c1) posted by **kevinb@google.com** on 2013-04-08 at 07:01 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-General`
---
Michael, OWASP ESAPI https://code.google.com/p/owasp-esapi-java/ seems to be what you need. It has a self-contained ESAPI.encryptor() class, sample usage here https://code.google.com/p/owasp-esapi-java/source/browse/trunk/src/examples/java/PersistedEncryptedData.java
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1358) created by **electrum** on 2013-04-03 at 02:20 AM_
---
It's often useful to have a functional version of shuffle:
```
private static <T> List<T> shuffle(Iterable<T> iterable)
{
List<T> list = Lists.newArrayList(iterable);
Collections.shuffle(list);
return list;
}
```
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1358#c1) posted by **cpovirk@google.com** on 2013-04-03 at 06:29 PM_
---
I looked at 20 Google callers to Collections.shuffle. The divide about evenly into people who are manually cloning the list, people who really ought to be manually cloning the list but aren't, and people who don't need to clone it.
I'd say that a functional version of shuffle is a good thing for us to have. The complication is going to be in whether it's worth adding plain Iterables.shuffle or whether we should opt for a more powerful API that can choose n items with or without replacement in a streaming fashion (but special cases for selecting one item from RandomAccess inputs) and whatever other features people might want. We do have such a chooser utility internally, and we should consider promoting it.
---
**Labels:** `Package-Collect`, `Type-Addition`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1350) created by **cpovirk@google.com** on 2013-03-21 at 03:23 PM_
---
TODO: fill in details from:
- 2012/08/20 internal thread "AsyncLoadingCache"
- some comments from issue 1122
A decision that we need to explain is "Why have an AsyncLoadingCache&lt;K, V> instead of just recommending a LoadingCache&lt;K, Future&lt;V>>?" Here a few reason I encountered while skimming the above resources:
"""
It means that Future&lt;V> gets added to the cache immediately, and that nobody
blocks waiting for it to compute. It means that cache stats no longer
accurately reflect computation time. It means that you can get removal
notifcations for stuff that hasn't even finished computing. And to do
anything sensible with the notification you might need to wait for it to
compute. It means that Cache.asMap().containsKey(key) returns true even if
the cache doesn't yet contain the cached value. It means that Cache.size()
counts values that haven't even been computed. It means that weighted
eviction has to way an entry before it's value has even computed. It means
that weak and soft values are completely broken. You get the point. It's a
"""
In a discussion about how weak and soft references are broken:
"""
> I don't think the failure mode is surprising except in the
> I'm not actually convinced getFuture() even solves this soft/weak references
The problem is that a user's reference to the "real" value doesn't
keep the Future alive and hence permits the cache entry to be garbage
collected.  The value stored directly by the cache (in whatever type
of reference is appropriate) needs to be the same value the user would
hold on to.
"""
"""
CacheBuilderSpec#refreshAfterWrite no longer works as expected - with a normal value cache, Cache#get returns immediately even for slow computations (and I would expect getFuture() to return an immediate future in this case), while a future cache will return a still-loading future.  Moreover, if a computation fails, it will still overwrite a previous successful computation, as opposed to being swallowed by a value cache.
"""
- AsyncLoadingCache can guarantee that get() won't block.
- getIfPresent() could return a V instead of a Future&lt;V>.
- LoadingCache.get() throws, but there's no reason for that in AsyncLoadingCache, so users would always want to use getUnchecked().
- Lots more to be figured out about what happens to failures.
- loadAll interface: Does it return Map&lt;Future>? Future&lt;Map>? (Future&lt;Map&lt;Future>???)
- We can improve interruption behavior as discussed on issue 1122.
- We could provide clever cancellation logic: If all users awaiting a Future call cancel(), we can cancel the cache loading.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1350#c1) posted by **fry@google.com** on 2013-03-22 at 11:08 AM_
---
_(No comment entered for this change.)_
---
**CC:** fry@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1350#c2) posted by **cgdecker@google.com** on 2013-08-02 at 09:19 PM_
---
_Issue #1490 has been merged into this issue._
---
Just my two cents, async caches are traps for (especially database related) deadlocks.
Let's say you use the cache for an expensive db object, and you want to retrieve that object while in another transaction. If you were using a regular cache, there will be only one thread and caller is responsible to pass the transaction to the cache-loading function. But, I guess, async cache will use seperate thread to retrieve the object and that thread will need its own transaction. Under stress, DB connection pool will be exhausted, and async cache's thread will wait forever for an available connection, which is being held by the caller's thread, which waits for the async cache to return, hence the deadlock. Which, by the way, cannot be detected by JConsole, at least with C3P0 as pool implementation.
ListenableFuture.addListener() might be the recommended way to use async cache but would hurt its practical use.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1349) created by **DeRijcke.Erik** on 2013-03-21 at 09:57 AM_
---
Currently AsyncEventBus simply calls listeners in the separate executor as provide in the constructer, yet there is no way for listeners to individually control what executor should be used to call them. Ideally we'd have something like 'addCallback', where a listener can provide a a specific executor. This gives the possibility for the listener to control what executor is calling and at the same time makes AsyncEventBus faster as the posting executor is not blocked by a listener.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1349#c1) posted by **cgdecker** on 2013-03-21 at 02:59 PM_
---
Seems related to issue 951.
---
**Status:** `Research`
**Labels:** `Package-EventBus`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1349#c2) posted by **DeRijcke.Erik** on 2013-03-21 at 07:43 PM_
---
Yes it seems issue 951 talks of the same functionality. However important for me is not that the event delivery happens asynchronously, but that I know which executor is delivering the event, this is needed to make sure that always the same executor/thread accesses the listening object, something which can not be guaranteed in the current AsyncEventBus.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1349#c3) posted by **cgdecker@google.com** on 2014-06-26 at 10:36 PM_
---
Would the ability to control what Executor is used to dispatch to a subscriber using annotations on the subscriber method work for this? For example, rather than specifying an Executor when you register an object, instead annotate each method in the class with some annotation of your choice. Then, when you create the EventBus you associate that annotation with a specific Executor. This gives more fine-grained control over which methods are dispatched with which Executors and saves you from having to deal with Executors when registering an object, but does mean that you can't register different instances of the same type to be handled by different Executors. I'd prefer keeping registration as simple as possible.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1349#c4) posted by **DeRijcke.Erik** on 2014-06-27 at 07:28 AM_
---
Sounds lovely!
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1348) created by **DeRijcke.Erik** on 2013-03-21 at 08:58 AM_
---
The current Eventbus implementation has all methods package-private with the exception of register, unregister & post. Ideally either all other methods should be protected, or if that's not desired, EventBus should be an interface (because currently you'd have to rewrite evertyhing anyway when subclassing EventBus as nothing is accessible from the subclass).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1348#c1) posted by **wasserman.louis** on 2013-03-21 at 03:43 PM_
---
Do you have a specific use case?  I am fairly certain this is working as intended.
---
**Labels:** `Package-EventBus`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1348#c2) posted by **DeRijcke.Erik** on 2013-03-21 at 07:40 PM_
---
Issue 1349 is a good example. Tthere is now way for me to implement this functionality without c/p EventBus internals. Currenlty I have to extend EventBus and c/p it's implementation. Not only is this impossible if I already extend another class, it's also bad practice to c/p code...
If for some reason it is needed that nothing of EventBus internals should be exposed outside its package, then EventBus should be an interface with register, unregister and post method to allow for maximum flexibility (ie multiple inheritance), as currently extending EventBus is exactly the same as implementing an interface (because nothing is accessible from the implementation).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1348#c3) posted by **wasserman.louis** on 2013-03-21 at 10:09 PM_
---
TBH, historical precedent is that you _should_ go ahead and fork EventBus.  There are several forks out there already.
IIRC, the reasoning, for what it's worth, is that
a) we might like to change EventBus semantics in the future, or add new methods, that would break all users of the interface
b) once we open up EventBus for extension, we now have to preserve backwards compatibility of the implementation for all those extensions
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1348#c4) posted by **DeRijcke.Erik** on 2013-03-24 at 05:28 PM_
---
a) Not if users can extend from a subclass friendly base implementation...
Users of the interface (clients), they will always brake if you do an api incompatible change, regardless if it's an interface or class. As for implementers of the interface, they will not brake at runtime if it's compatible api change (ie add a method), only when an api client actually calls the new method it will and should brake.
&nbsp;This brings me to a an extra argument to use an interface instead of a class. If somebody extends EventBus class, overrides all public methods and one day an extra method is added to EventBus, then users of the extended EventBus have no clue the extra added method is actually not implemented/overridden. The program just keeps on running without error. Try debugging that...
b) well you are building a software library... api compatability is always a concern.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1348#c5) posted by **wasserman.louis** on 2013-03-24 at 06:43 PM_
---
If you look through the other feature requests for EventBus, you'll see things like custom exception handling that we couldn't compatibly add if any subclassing was allowed, whether of an interface or a class.  (We could compatibly add it ourselves, by making sure the default was consistent with the current behavior.)
Disallowing subclasses entirely allows us the flexibility to add that sort of thing.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1348#c6) posted by **DeRijcke.Erik** on 2013-03-24 at 07:56 PM_
---
Could you explain? Subclassing EventBus is currently allowed, although only through class extension. Are there plans to make EventBus a final?
I agree, it's not unreasonable to do it all yourself, but that brings me back to the argument of extracting EventBus public methods as an interface (=add a "Bus" interface that is implemented by EventBus) as stated before:
"If somebody extends EventBus class, overrides all public methods and one day an extra method is added to EventBus, then users of the extended EventBus have no clue the extra added method is actually not implemented/overridden. The program just keeps on running without error. Try debugging that."
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1348#c7) posted by **wdro...@droste-usa.com** on 2013-11-20 at 10:02 PM_
---
Use Case:
- Developers forget to add @AllowConcurrent which leads to huge performance problems.
I wanted to change the default strategy but I could not because it was static final in the EventBus class. Overriding register and unregister didn't work because there's no access to handlersByType.. because its private and there's no protected to add handlers for it..
So I had to override pretty much the whole package..
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1348#c8) posted by **guterfluss** on 2013-12-04 at 12:08 PM_
---
Another use case:
We're using the eventBus synchronously to logically decouple our code. When an exception occurs in an event handler, we want the exception to be thrown back to the object posting the event.
In the current implementation, any exception is swallowed in eventBus.dispatch. A simple override of this method could do the trick, but the method is not protected.
---
In a nutshell, it's a map where can story any object as value under a key and get back the value without casting in a type-safe manner checked at compile time.
There are two possible implementations. One isn't 100% safe but extends the Map interface.
The other one doesn't support get(Object) and remove(Object) from Map, so the resulting type just has a similar API but not one that is 100% Map compatible.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1346#c1) posted by **wasserman.louis** on 2013-03-20 at 05:48 PM_
---
What are some specific use cases for this?  We already provide ClassToInstanceMap and friends, which cover some of these areas.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1346#c2) posted by **benyu@google.com** on 2013-03-24 at 12:04 AM_
---
The blogged API is not type safe.
map.get(new TypedMapKey&lt;String>("key")) internally does an unchecked cast, but the cast isn't safe.
It is no different than:
@SuppressWarnings("unchecked")
&lt;V> V get(Object key) {
&nbsp;&nbsp;return (V) rawGet(key);
}
because in both ways the type of the value isn't guaranteed to be the type that caller thinks it is.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1346#c3) posted by **jysjys1486** on 2013-03-24 at 11:14 AM_
---
In general, this seems to ask for a heterogeneous map in which having same-type type tokens doesn't imply that the type tokens are equal.
&nbsp;&nbsp;&nbsp;i.e. For TypeToInstanceMap, there can be no more than one value to a type.
Essentially, give some composite key from:
&nbsp;&nbsp;&nbsp;public static &lt;K, B> Key&lt;K, B> of(K key, Class<? extends B> clas) {...}
Above, key("1", String.class) would not be equal to key("2", String.class); all the while, the composite key would be a type token to whatever map uses it.
I'd assume this would be analogous to such a map: Map&lt;K, TypeToInstanceMap&lt;B>>; note that this could have multiple TypeToken<? extends B> to K, whereas care would be needed if you only wanted one token to a key.
For heterogeneous collections, say, lists, in general:
&nbsp;&nbsp;&nbsp;ArrayList&lt;TypeToInstanceMap&lt;Object>> formalsToActuals; // maps are singletons
&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;list.get(0).put(String.class, "str");
&nbsp;&nbsp;&nbsp;list.get(1).get(Double.class)
These approaches are work-arounds, mind you. But useable. Or, did I miss the point completely?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1346#c4) posted by **lowasser@google.com** on 2013-05-03 at 09:11 PM_
---
static final Key&lt;String> ADDRESS_KEY = new Key&lt;String>();
FWIW, the Java compiler uses essentially this idiom in the Context class (http://www.docjar.com/docs/api/com/sun/tools/javac/util/Context.html), though it binds factories instead of objects themselves in what I'd describe as a poor man's dependency injection.
---
> The blogged API is not type safe.
This is intentional. I needed my map to be a drop in replacement for java.util.Map.
For Guava, I suggest to implement it differently and maybe support a wrapper helper that converts between TypedMap and Map.
> the key should have no additional String parameter
I considered this but it makes debugging a nightmare since you can't tell anymore what each key was (there is no way to return to the Key instance from within the map).
If Java only had a hook for the part of the compiler that handles "enum" :-(
I also considered using enums for this but the API became too clumsy.
One last comment: Someone suggested to swap the API:
Key&lt;String> ADDRESS_KEY = new Key&lt;String>();
String value = ADDRESS_KEY.getFrom( map );
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1346#c6) posted by **jysjys1486** on 2013-08-22 at 12:26 PM_
---
Did not know that this had replies...
I'll add that I've worked with, what I'd call, a more general solution that, while a bit involved, does well enough with this problem.
Consider a structure:
```
class Actual<T> {
final T value;
final TypeToken<T> formalType;
TypeToken<T> getActualType() {
// memoize, since Actual is likely to be an immutable class
return value==null? formalType: formalType.getSubtype(value.getClass());
}
}
```
The above effectively types a value and may even preserve the generic type of an actual type given a generic formal type:
```
List<String> list = new LinkedList<String>();
Actual.of(list, Object.class).getActualType(); // LinkedList
Actual.of(list, new TypeToken<List<String>>(){}).getActualType(); // LinkedList<String>
```
Use actuals as values to maps (Map&lt;K, Actual<? extends V>>), and, if there is ever an interface or subclass of Actual, perhaps go the route of the Multimaps and provide a Supplier:
```
interface ActualMap<K, V> extends Map<K, V> {
...
Map<K, Actual<? extends V>> asMapOfActuals();
// Likely fully-operational if Actual is a final class
}
```
An implementation to ActualMap&lt;K, V> may find it advantageous to explicitly aggregate the V parameter type as a TypeToken; put(K, V) for maps with a generic value type parameter could possibly preserve generic-type values; otherwise, maps whose values are known to be generic would not be able to store put(K, V) values as generic values:
```
V put(K key, T value, TypeToken<T> typeToken) ...
V put(K key, V value) {
return put(key, value, preservedType.getSubType(value.getClass()));
// may deal with warnings
}
```
Lastly, concerning the ActualMap API, I had personally opted for Predicate/Function usage for contains/(get|remove) respectively:
contains(Object, TypeToken<?>, BiPredicate<? super TypeToken<?>, ? super Actual<? extends V>>)
contains(Object, Predicate<? super Actual<?>>)
[get|remove](Object, TypeToken&lt;T>, BiFunction<? super TypeToken&lt;T>, ? super Actual<? extends V>, ? extends T)
[get|remove](Object, Function<? super Actual<? extends V>, ? extends T)
I defined common predicates and functions in a Actuals utility class:
```
equalsFormalType()           : BiPredicate<TypeToken<?>, Actual<?>>
isAssignableFromFormalType() : BiPredicate<TypeToken<?>, Actual<?>>
equalsActualType()           : BiPredicate<TypeToken<?>, Actual<?>>
isAssignableFromActualType() : BiPredicate<TypeToken<?>, Actual<?>>
equalsFormalType(TypeToken<?>)           : Predicate<Actual<?>>
isAssignableFromFormalType(TypeToken<?>) : Predicate<Actual<?>>
equalsActualType(TypeToken<?>)           : Predicate<Actual<?>>
isAssignableFromActualType(TypeToken<?>) : Predicate<Actual<?>>
castActualValue()             : BiFunction<TypeToken<T>, Actual<? extends U>, T>
castActualValue(TypeToken<T>) : Function<Actual<? extends U>, T>
```
Finally, to support usage, I defined a key/type-token entry type, Option&lt;K, V> when defining static final keys:
```
public static final Option<String, Integer> ID = Option.of("id", Integer.class); //
public static final String MEASURES = "measures"; // could be one of [Iterable<Double>, double[]]
```
An operation in a utility class could be used to adapt maps to actual maps:
```
static ActualMap<K,V> of(Map<K, V> map) {
if (map instanceof ActualMap<?, ?>)
return (Actual<K, V>) map;
final Actual<K, V> m = new LossyActualMap<>();
m.putAll(map);
return m;
}
```
This was a bit involved in implementing, frankly, but I feel as if it works as intended, and gives a be of flexibility as to how the types of values are viewed before retrieving or removing them (TypeToInstanceMaps can't given that).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1346#c7) posted by **jysjys1486** on 2013-08-22 at 12:31 PM_
---
Of course, the aforementioned Context works as well if willing to sacrifice flexibility in key parameter type.
---
Actual/ActualMap looks interesting but IMO solves a different problem: Type preservation. My approach allows you to put Actuals into a typed map, so it's more flexible since it doesn't impose an artificial limit for the value type.
Places where I used this:
- data elements in models which allow to attach arbitrary data to an instance (SWT, Swing and ZK use this but without type safety).
The biggest advantage of the constant keys is that it's easy to find all places where a value is being used (as opposed to String constants).
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1338) created by **kurt.kluever** on 2013-03-14 at 07:53 PM_
---
This came up at a roundtable discussion a while ago...do we want to add this?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1338#c1) posted by **tomas.zalusky** on 2013-03-15 at 07:38 AM_
---
This issue is similar to https://github.com/google/guava/issues/1072 .
Personally, I haven't needed to use prepend but sometimes I need FluentIterable.append or concat.
Thanks for considering.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1334) created by **cpovirk@google.com** on 2013-03-14 at 02:11 PM_
---
It's on account of interruption and cancellation.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1329) created by **jjzazuet** on 2013-03-11 at 03:24 PM_
---
Hello everyone.
I apologize in advance if this has been previously mentioned.
My suggestion is simple.
In the spirit of code minimalism, split guava-XX.X.X.jar into atomic jars, at least when publishing to Maven central.
I can see an advantage in having a lower application size for example, with mobile applications.
However, I do not have solid facts to back up my suggestion. Therefore it remains only as such. But hopefully I got my point across.
Thank you for your time and help.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1329#c1) posted by **cpovirk@google.com** on 2013-03-11 at 03:34 PM_
---
We're kind of stuck the way we are: If we were to split the package at this point, Maven wouldn't recognize that guava-14.0 and guava-base-15.0 contain the same classes, so it would be more likely that people would end up with conflicting versions in their classpaths.
That said, we feel reasonably good about the choice we made. You mention some packages that are more rarely used -- math, eventbus, io. Users might benefit from excluding these, but there's likely to be even more value in stripping out whichever half of common.collect your particular application doesn't need, since common.collect is just so big. There's more discussion on issue 605.
---
**Status:** `Duplicate`
**Merged Into:** #605
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1329#c2) posted by **kak@google.com** on 2013-07-09 at 08:17 AM_
---
_Issue #1471 has been merged into this issue._
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1326) created by **lowasser@google.com** on 2013-03-09 at 10:49 PM_
---
By analogy to DigestInputStream.
I just encountered a user I wanted to migrate who was parsing and hashing data from a file at the same time.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1325) created by **sebastian.davids** on 2013-03-08 at 02:04 PM_
---
http://commons.apache.org/proper/commons-io/apidocs/org/apache/commons/io/IOUtils.html
You might want to add constants for "Classic" Mac OS.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1325#c1) posted by **kevinb@google.com** on 2013-11-20 at 10:29 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-IO`, `Type-Addition`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1315) created by **chriss.dev** on 2013-03-02 at 12:05 PM_
---
The interface ExecutorService provides the method awaitTermination(long,TimeUnit), it would be nice to have "uninterruptibly" pendats in the Uninterruptibles-class like:
boolean awaitTerminationUninterruptibly(ExecutorService executor,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long timeout,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TimeUnit unit)
//await the termination till the end of all days
void awaitTerminationUninterruptibly(ExecutorService executor)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1315#c1) posted by **wasserman.louis** on 2013-11-29 at 05:08 PM_
---
_Issue #1595 has been merged into this issue._
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1314) created by **lowasser@google.com** on 2013-03-01 at 06:50 PM_
---
I'm fairly certain there are some methods I would've expected to be obligatory but aren't implemented everywhere?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1314#c1) posted by **kevinb@google.com** on 2013-03-12 at 06:43 PM_
---
_(No comment entered for this change.)_
---
**CC:** fry@google.com
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1313) created by **matt.nathan** on 2013-03-01 at 04:29 PM_
---
In our code we find that we join on the same things all the time, it might be useful for Guava to provide some of these common joiners as constants on the Joiner or on a new Joiners class.
For example:
- SPACE = Joiners.on(' ');
- EMPTY = Joiners.on("");
- NEW_LINE = Joiners.on('\n'); // maybe CR or platform specific version too
I understand that the utility of this is very low but the ubiquity, at least in the things I've worked on, must be very high.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1313#c1) posted by **cpovirk@google.com** on 2013-03-01 at 04:37 PM_
---
This suggestion comes up every now and then. We'd want to name the Joiners something longer than just "SPACE," so it would probably be "SPACE_JOINER." That ends up being longer than "on(' ')."
---
**Status:** `WorkingAsIntended`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1313#c2) posted by **matt.nathan** on 2013-03-01 at 04:54 PM_
---
Actually in real world use I would expect to static import something like SPACE_JOINER but not for something like on(' ') which makes SPACE_JOINER two characters shorter:
SPACE_JOINER
I do get your point though, I guess it was just my inner coder freaking out at creating multiple instances of the same immutable object throughout my code.
This issue is marked as working as intended. We don't intend to add any Joiner constants.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1300) created by **benjamin.j.mccann** on 2013-02-25 at 11:50 PM_
---
The junit version in guava-testlib/pom.xml is a broken version in that it bundles Hamcrest within the jar. Upgrading the JUnit dependency to 4.11 fixes this issue because JUnit 4.11 properly just specifies Hamcrest as a dependency instead of bundling it within the same jar.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1300#c1) posted by **benjamin.j.mccann** on 2013-02-25 at 11:51 PM_
---
btw, i have signed google's CLA
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1300#c2) posted by **kak@google.com** on 2013-02-26 at 07:36 AM_
---
_(No comment entered for this change.)_
---
**Owner:** cgruber@google.com
**Labels:** `Package-General`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1300#c3) posted by **benjamin.j.mccann** on 2013-03-19 at 06:04 AM_
---
Any update on getting this patch in? It's a pretty minor change.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1300#c4) posted by **benjamin.j.mccann** on 2013-03-25 at 09:04 PM_
---
Any reason not to submit this?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1300#c5) posted by **benjamin.j.mccann** on 2013-04-04 at 12:40 AM_
---
ping
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1300#c6) posted by **neveue** on 2013-04-04 at 10:05 AM_
---
As a workaround, you can add an exclusion to the guava-testlib dependency in your pom.xml, and specify a more appropriate junit dependency for your project.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1300#c7) posted by **cgruber@google.com** on 2013-04-04 at 11:18 AM_
---
Sorry.  I'll look at this this week.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1300#c8) posted by **benjamin.j.mccann** on 2013-04-04 at 04:01 PM_
---
Thanks!
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1281) created by **mmastrac** on 2013-02-04 at 04:57 PM_
---
I'd love it if protobuf's immutable ByteString could make it into Guava. This is a useful class, even for users who aren't using protobuf and it seems like a shame to pull in the rest when I'm already importing Guava.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1281#c1) posted by **kak@google.com** on 2013-02-04 at 05:07 PM_
---
Agreed...this has been on our radar for quite some time.
---
**Status:** `Accepted`
**Labels:** `Type-Addition`, `Package-Base`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1281#c2) posted by **jus...@fathomdb.com** on 2014-01-11 at 02:44 PM_
---
It seems to me that the biggest problem is organizational - i.e. in which project does ByteString live?  If in Guava, protobuf would have to depend on it.  If in a new "Guava core", Guava would have to maintain that separation.  Merging Protobuf-java and Guava would be great, but is probably unacceptable.  Having Guava depend on Protobuf (or Protobuf core, containing ByteString) would be 80% good, but wouldn't allow e.g. ByteString to extend ByteSource. etc etc
Any thoughts on the preferred option?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1281#c3) posted by **kak@google.com** on 2014-01-12 at 02:41 AM_
---
_(No comment entered for this change.)_
---
**Owner:** cgdecker@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1281#c4) posted by **andreas.schildbach** on 2014-06-01 at 09:25 AM_
---
I think ultimately ByteString should go into the JDK itself.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1274) created by **jer...@gustie.com** on 2013-01-31 at 02:45 AM_
---
I don't know if this has come up before, but it would be nice to have a builder for executors which encompasses functionality from the existing Guava ThreadFactoryBuilder and MoreExecutors along with Java's ThreadPoolExecutor, for example:
ListeningExecutorService executor = ExecutorExecutorBuilder.newBuilder()
&nbsp;&nbsp;.threadNameFormat("foo-%d")
&nbsp;&nbsp;.corePoolSize(3)
&nbsp;&nbsp;.exitingWithApplication(120, TimeUnit.SECONDS)
&nbsp;&nbsp;.build();
Also, `buildScheduled()`&nbsp;for scheduled executors; maybe a `withCurrentThread()`&nbsp;for same thread execution and obviously more builder methods for controlling the final behavior of the built executor.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1274#c1) posted by **kevinb@google.com** on 2013-11-20 at 10:24 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Concurrent`, `Type-Addition`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1268) created by **travis.downs** on 2013-01-27 at 05:39 AM_
---
Unfortunately, the result is that when these subclasses mix at some call site, the call is megamorphic, and performance is awful compared to classes without these specializations (worse by a factor of 20 or more).
Here's a simple benchmark that shows ImmutableList vs ArrayList - given that ImmutableList is a simple ArrayList, without the need for double bounds checks on the upper bound, you'd expect it to at least be comparable:
```
benchmark minSize     ns linear runtime
ArrayList       0   60.9 =
ArrayList       1   60.6 =
ArrayList       2   60.6 =
ArrayList       3   60.7 =
```
ImmutableList       0 1169.0 ==============================
ImmutableList       1  107.4 ==
ImmutableList       2   90.7 ==
ImmutableList       3   90.7 ==
The benchmark just calls size() repeatedly on 100 ArrayLists or ImmutableLists.  The sizes of the lists are evenly distributed in [minSize, 4].
You can see that when all lists have at least 2 elements, performance is comparable (~91 ns vs ~61 ns) - with the difference here being attributed to CHA - in the ArrayList case the compiler can prove that ArrayList class is effectively final, and can avoid the inline type check (so even in the >= 2 element case, the specializations hurt).
With 1 element lists present, the call is bimorphic, so it can still be inlined and optimized, but the extra check costs a bit.
With 0 element lists, performance tanks.  The call is megamorphic and can't be well optimized.  The cost of the call is ~20 times worse than ArrayList.
The penalty applies every List<> call, not just size().
In the above benchmark, the type of the array of List was ArrayList[] and ImmutableList[] respectively.
If you change that to be List[] in both cases, the performance degrades even more:
```
benchmark minSize     ns linear runtime
ArrayList       0   90.6 =
ArrayList       1   90.8 =
ArrayList       2   90.7 =
ArrayList       3   90.8 =
```
ImmutableList       0 2061.3 ==============================
ImmutableList       1  115.2 =
ImmutableList       2   90.6 =
ImmutableList       3   90.7 =
CHA isn't in play now, because the type of the array is List, which has multiple implementations, so ArrayList degrades to ~91 ns, just like ImmutableList.
The worse case ImmutableList performance has been cut in half, however, since now the call is a megamorphic invokeinterface, rather than invokevirtual, ugh.
This kind of scenario is not at all far fetched in real world code - it is natural to have lists of 0 and 1 length (which is probably why these specializations were created in the first place), and it is not unusual to find them mixed at a single call site - often in a hot method that takes a List<> as input. Unlike something like branch prediction, the worst case behavior will occur permanently once the specializations have _ever_ been seen at the call site.  Even if 0 or 1 element arrays are very uncommon, once you see one of each, you are hosed until you restart the VM (at least in every JIT that I know of).
The benchmark doesn't even test the worst case - the pattern of lists sizes is totally regular, so the branches inherent in the bimorphic and megamorphic dispatch will be well predicted.  Randomize it and it will get worse (especially the bimorphic case because it is pretty fast so has a lot further to call).
The same issue could occur with SubList and perhaps ReverseImmutableList also, although probably less frequently, and there may be no good alternative there.
A reasonable compromise here would be to keep only the Singleton list implementation, and use a global static instance of that for the 0-element case also, with null element array, and special case all the methods to do the right thing for a null array.  This will get you most of the memory and GC benefit of the current implementation (only a slight increase for 0-element lists), while making the worse case bimorphic, which isn't too bad.
Alternately, you could keep only the 0-element case, and group 1-element lists into the general case.  This will increase memory use by 2.5x (16 bytes vs 40 bytes on hotspot bytes according to my back-of-napkin calcs), and probably have somewhat worse runtime performance for heavy use of 1-element lists.
Benchmark attached.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1268#c1) posted by **travis.downs** on 2013-01-27 at 05:45 AM_
---
Benchmark attached here...
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1268#c2) posted by **travis.downs** on 2013-01-27 at 05:46 AM_
---
You can uncomment the block above setUp(), and comment out the corresponding block right above that to try the List[] case (second set of results above).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1268#c3) posted by **cpovirk@google.com** on 2013-01-28 at 04:38 PM_
---
Wow, thanks. Coincidentally, we recently started some internal discussions about the value of methods like EmptyImmutableList.isEmpty(). Your benchmark numbers are beyond my worst fears (20x??). Further, your reasoning shows that a solution would have to do more than just remove method overrides: It would actually have to remove implementation classes. And, as you point out, there are more of these than Empty+Singleton+Regular. (See also _Immutable_AsList.) For this reason, List in particular may end up being a lost cause, but this deserves more thought. Maybe we can hide all the "weird" implementations behind a ForwardingImmutableList that delegates to non-ImmutableList-but-actually-immutable delegates? Or maybe we should focus our attention on immutable classes with fewer implementations (ImmutableMultimap)?
The distressing part of this is that the primary goal of the multiple "normal" ImmutableList implementations is to save memory, and there's only so much we can do to preserve the memory savings while eliminating subclasses. I like your suggestion of eliminating EmptyImmutableList (with the caveat that the existence of other ImmutableList implementations may still be a megamorphism problem). Another way of doing that is to use a RegularImmutableList for empty lists.
The overall size-space tradeoff is a hard one to evaluate, so I don't know exactly what we'll do here, but SingletonImmutableList, for one, looks tenuous. Thanks for supplying the numbers that have been lacking in our evaluation so far.
---
**Status:** `Research`
**CC:** lowasser@google.com, gak@google.com
---
Please try to @Param numLists with other values too. This show the same tendency, but higher numLists show less and less difference compared to 100. Also, the singleton list may be an actual gain of performance with higher values of numLists.
I actually don't know how to interpret that, so I'm just giving a lead here.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1268#c5) posted by **lowasser@google.com** on 2013-01-28 at 05:53 PM_
---
ImmutableList does seem likely to always have many subclasses -- mostly the ImmutableAsLists.
Chris, I'm not sure I follow how ForwardingImmutableList would work, or would save anything?
I think we could safely eliminate EmptyImmutableList and its brethren -- as long as we maintain a singleton holding the empty ImmutableList instance, it will only require a constant amount of memory for the whole VM.
That said, I'm not 100% convinced the benchmark is valid, if only because the List interface itself is likely to have more implementations used than just ArrayList and ImmutableList...?  Most implementations will be List references, not ArrayList-specific references, so I'd expect most operations on a basic List to be polymorphic calls.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1268#c6) posted by **cpovirk@google.com** on 2013-01-28 at 06:28 PM_
---
> Chris, I'm not sure I follow how ForwardingImmutableList would work, or
> would save anything?
We can sacrifice performance on uncommon implementations by making the common call bimorphic:
ImmutableList has two subclasses, RegularImmutableList and ForwardingImmutableList. RegularImmutableList is used for 0-, many-, and perhaps 1-element lists. ForwardingImmutableList is used for everything else, including ImmutableAsList. ForwardingImmutableList is a wrapper around a plain (though immutable) List. Any other "ImmutableList implementations" are actually List implementations that get wrapped in a ForwardingImmutableList.
> That said, I'm not 100% convinced the benchmark is valid, if only because
> the List interface itself is likely to have more implementations used than
> just ArrayList and ImmutableList...?  Most implementations will be List
> references, not ArrayList-specific references, so I'd expect most operations
> on a basic List to be polymorphic calls.
While we have been encouraging people to store references in fields of type ImmutableList, we can be sure that that advice isn't always followed. In any case, it would be nice if the people who did follow the advice could get a performance boost out of it.
But there may be only so much gain from any of these approaches. It may be that the right takeaway from all this is that our attempts to subclass ImmutableList for speed are fruitless because, even if we could eliminate the entire 90ns cost of "the method itself," the percent performance increase would be in the single digits. Despite years of advice that the immutable implementations are probably more efficient than the JDK classes, we've avoided writing these benchmarks. (Well, at least we have some for Set.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1268#c7) posted by **lowasser@google.com** on 2013-01-28 at 06:34 PM_
---
To be clear, I'm arguing that the benchmark _overestimates_ the speed of ArrayList.  I also have to admit that I'd've assumed that if the ForwardingImmutableList procedure you describe worked, then the JIT would already have implemented a similar technique to deal with polymorphic calls when certain implementations were much more common than others.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1268#c8) posted by **travis.downs** on 2013-01-30 at 06:17 AM_
---
Given the discussion so far, I think there is a bit of a misunderstanding about what makes things slow, so here's a quick summary based on the comments above, and then the gory details follow in the next post.
>  Most implementations will be List
> references, not ArrayList-specific references, so I'd expect most operations
> on a basic List to be polymorphic calls.
The important thing for performance isn't whether the "proven" type of the reference has subclasses, but whether multiple implementations have actually been seen in practice _at some call site_. In the language of my post to follow, CHA doesn't apply if List has multiple implementations, but "inline caching" does, as long as only one implementation is seen in practice, for each call site. That's why ArrayList is fast: one class returned by Lists.newArrayList(), and ImmutableList is slow: multiple implementations returned in practice (for minSize in [0, 1] - but the 2 implementation case is still optimized well).
This is shown clearly by the second benchmark - the type is now List<>, but ArrayList and ImmutableList (for length > 1) are still very fast (a 0.3 ns penalty per call, since CHA isn't in play).  The massive penalty incurred by the > 1 implementations of ImmList is still being paid, and the relative cost is even greater (20x now vs 10x) since interface types are being used).
Declaring fields as ImmutableList vs List actually does give a performance boost, but only because ImmutableList is a class, and not an interface, so it can use the faster vtable dispatch vs the interface dispatch. That's secondary to the issue here - even virtual dispatch is very slow compared to inlined & fully optimized access.
> Maybe we can hide all the "weird" implementations behind a ForwardingImmutableList
> that delegates to non-ImmutableList-but-actually-immutable delegates? Or maybe we
> should focus our attention on immutable classes with fewer implementations (ImmutableMultimap)?
As above, the issue isn't total implementations, but total implementations likely to be seen at one call side.  I focused on the types returned by ImmutableList.of() because three different implementations can be transparently returned by .of(), completely undocumented, so you can get different concrete classes even if you did your best to avoid it.  Such instances are very likely to end up at the same call site, and cause poor performance, compared to the other implementations, which will often never appear at any call site (see the next part, for an important clarification about "call site").
The other implementations, while common in some cases, only arise as the result of distinct java call sequences, so are likely to be limited to many fewer _effective_ call sites (the difference between java-level call sites and effective call sites after inlining is critical, so see the last part of the next post).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1268#c9) posted by **travis.downs** on 2013-01-30 at 06:54 AM_
---
Here are the gory details about JIT method inlining & optimization in general. When I say "JIT" here, I mean hotspot, but I don't think it is going to vary too much across other state-of-the-art JITs out there - or at least they'll usually be worse in specific cases, not better. This should help you when you are analyzing the tradeoffs to make.
Because inlining methods is so important and virtual methods are so important, a key optimization for the JIT is "devirtualization" - taking a method which is polymorphic in theory and compiling it as if the actual implementation was known, including inlining it. It does this through two very different mechanisms, with different behaviors and different implications for class hierarchy design, which I will describe below:
This is the trick that makes the final on methods keyword mostly useless for performance, despite lots of out of date advice to the contrary (still useful as a enforced restriction at compile time). If a method m() is declared final on class C, and the compiler _knows_ that for an object of type C or a subclass (but not a superclass), a call to m() will always resolve to the single final implementation, and it can be fully inlined and optimized.
Most methods, however, are not declared final, but are _effectively_ final since they have no overrides in the currently loaded set of classes.  Since the JVM knows, at all times, the complete set of loaded classes, it can perform this "is effectively final" analysis for each method.  If m() has no overrides in any loaded class, it can be optimized just as if it was final.
The set of loaded classes can change of course, so some CHA-based assumptions which where valid when some code was compiled may become invalid later.  This is handled through deoptimization when a class is loaded that violates earlier CHA assumptions. The deoptimization always occurs at a safepoint, so it piggy-backs on the existing safepoint polling mechanisms and basically means that CHA is "free" from the point of view of the compiled code - there is no trace of the fact that the CHA could become invalid in the generated assembly, other than safepoint polling which is required regardless.
1) It applies to the entire VM, per method - either some method can be devirtualized via CHA everywhere, or nowhere (actually it could be per-classloader, but the general idea that it's a global optimization is the same).
2) As a consequence of (1), if any class is loaded that overrides a method, CHA for that method is invalid everywhere a method is called, even if some call site never actually sees the overridden classes.
3) CHA works on a _method_ basis - if you have a class with M methods, and a subclass of that that overrides N methods (N < M), CHA is still applicable to the non-overridden methods.
CHA is great when it works, but it is pretty useless for this issue.  As Louis points out above, interfaces like List will _always_ have multiple loaded implementations, so CHA will almost never apply for List. It can still apply when the type of the object can be proven to be more specific than List, which is what occurs in the first benchmark, so a concrete List implementation, like ArrayList, may be subject to CHA if no class extends it (as in the benchmark), but in most large projects, you are probably doing to have someone who extends it (BTW, this is a good reason to make performance sensitive classes final).
The only time CHA shows up in the benchmarks above is the "fast case" in the first benchmark, with all lists of size 3 or 4.  ArrayList gets 60 ns, while ImmList gets 90 ns, the difference being because of CHA which works for ArrayList, but not for ImmList, which has multiple loaded (but not used, except perhaps internally in guava) implementations.  In the second benchmark, where the array type is List rather than ArrayList/ImmutableList, CHA doesn't apply (since the call is against List, which does have multiple implementations).  So CHA isn't big-picture important here because it is only comes in to play in the 60 ns vs 90 ns difference (which is 0.3 ns per call, since 100 lists are involved - 0.3 ns is exactly one cycle).
Next, on to the optimization that is important here: inline caching.
This optimization applies when CHA can't - that is, when a method has overrides in loaded classes.  So it applies all the time for things like List, which always have multiple implementations.  In this case, the JIT takes advantage of the fact that even though overrides may exist, at any particular call site (a call site being a possibly inlined method invocation in the JIT'd assembly) there is often exactly one implementing class in practice.  For ArrayList this is always true in my benchmark, and it is true for the minsize 3,4 case for ImmList.  Take a look at your codebase (not guava, though, since you don't know who is calling your methods!) for say 10 random calls of List.get() or List.size() and trace back all the possible origins of the List in question - you'll often find that they'll always be a certain type.
What the JIT does here is looks at the profiling information gathered during the interpreted phase, and if only 1 or 2 types of objects have been seen at that call site, optimistically assumes that the type of the object will be those 1 or 2 types (monomorphic and bimorphic cases). This allows it to inline/optimize the method pretty much in the same way as CHA, above.  The difference is that the assumption might be wrong, and there is no classsloading event & safepoint poll that can be hooked to guard this case, so they actually need to insert a check in the generated assembly to ensure the type of the object is one of the assumed type(s), immediately before the actual code of the method. If this checks fails, the method is de-optimized and recompiled with the new information. At most this can occur twice: mono -> bi, then bi -> mega.  In the benchmarks above, this is the reason for the 90 ns ImmList times vs the 60 ns ArrayList times - ArrayList was using CHA, while ImmList needed an inline cache, and the extra check & branch cost 1 cycle.  Still extremely fast.  It's also why the ImmList minsize=1 case takes 107 ns vs 90 ns for ImmList - we can still use inline caches, because we are bimorphic (the singleton ImmList and regular ImmList), but we need an extra check to cover the two cases (the branch is well predicted because the pattern of lists is completely regular, but if it wasn't this case would suck too).
When you have more than 2 implementation observed at a call site, however, the JIT gives up - it doesn't inline the method and must compile an expensive virtual method call.  If the underlying type is a class, this involves some indirection and parameter marshaling, and if it is an interface, involves that, plus a linear search through the implemented interfaces to find the right one (because the class hierarchy is a tree, but the interface + class hierarchy is a DAG).  This case is the ~1170 ns and ~2060 ns ImmList cases.  The call site has > 2 implementations of ImmList (or List in the second benchmark) so it is megamorphic not only in practice, but in theory.  The second benchmark is 2x as bad as the first because the proven type of the receiver (object on which the method is called) is List, an interface, not ImmutableList, an (abstract) class, so it has to pay the additional interface search cost.
The key points about inline caches:
1) It applies only when CHA doesn't - that is, when there are multiple implementations of a class/interface.  More precisely, when a method is called where there are multiple implementations of that particular method in subclasses of the _proven_ type of the receiver.
2) It applies on a per-call site basis.  Every call site is treated independently by the above.  So the optimization can apply in many cases for some method n(), while failing at some particular call sites of n() where it happens that multiple receivers are observered.  So global program behavior won't affect, in many cases, particular call sites.
3) It applies with 1 or 2 receiver types, not more (CHA applies with exactly 1 type).
4) It is based on the type of the object, not the specific method.
Of the points above, (2) and (4) are particularly important here.
(2) means that most of the discussion above about how many implementations of a class/interface exist is probably wrongly aimed - it's not how many exist, but how many actual instances of those implementations appear at a particular site.  In the benchmark, ArrayList is always actually an ArrayList because Lists.newArrayList always returns an ArrayList. The ImmutableList, however, even though they all originate from the same factory method, ImmutableList.of(), vary in their most-derived types! This is why I focused on the types returned by ImmutableList.of() - even though other specializations of ImmutableList exist, they are returned in specific cases, involve a different call path from a usual creation (sublist, reverse calls). On the other hand, 3 different implementations can be transparently returned by .of(), completely undocumented, so you can get different concrete classes even if you did you best to avoid it.  Such instances are very likely to end up at the same call site, even in high performance code, and cause poor performance, compared to the other implementations, which will often never appear at any call site (see the next part, for an important clarification about "call site").
The above makes clear that "call sites" are critically important.  What is a distinct call site? A sufficient condition is usually an actual call of a java method in the java code:
static &lt;E> boolean isInEither(List<? super E> list1, List<? super E> list2, E elem) {
&nbsp;&nbsp;&nbsp;return list1.contains(elem) || list2.contains(elem);
}
However, this isn't a necessary condition.  For example, the method above contains two java-level call sites for contains() on the same line.  This method is extremely simple, probably less than 35 bytecodes, and certainly less than 350 bytecodes, so it will in generally be inlined into any callers.  This means that the contains calls (which may or may not be inlined, but it doesn't matter here) will actually appear at each call site of the isInEither() method, meaning that different invocations of the method don't really interfere with each other.  If one method wants to use ArrayLists, and one method passes LinkedLists, no problem, they don't de-optimize each other's inline caches because due to inlining the "effective" call site is different - much more fine grained that the (single) call site in the java code. This type of thing is usually true for performance sensitive code: inlining means that the effective call site is moved up the call stack to a method that is too large to be inlined, which for hot code is around ~300 bytes . The exact behavior depends on JVM arguments and can probably only be exactly determined with +XX:PrintCompilation.
(4) means that unlike CHA, for inline caches to work it is only important if you have seen multiple subclasses at the call site, not whether those subclasses actually implement the called method.  For example imagine you have an override of ArrayList, which doesn't override any methods but implements the Comparable interface (it doesn't matter why you have a subclass, I'm just trying to come up with a realistic reason).  For your new class, every method in List is implemented by the ArrayList method, not your new method.  However, if you mix both at a call site, the call will be bimorphic, not monomorphic based on line caching.  Under CHA, a similar situation would be monomoprhic, because CHA can tell that even though there is a subclass, it doesn't override the method of interest.  The way the "inline cache" is implemented, however is as a simple single-word check of the expected class object versus the actual class object - this happens in once cycle, as above - there is no general way to efficiently implement the more complication question "does the receive override method x" and the non-general ways probably aren't interesting enough that the JIT has implemented them yet.
The key part of (4) is that unless CHA is in play you have to talk about types - whether they have subclasses or not, and not whether methods have overrides or not. This is a big downside of inline caches - even if you can design a memory-efficient subclass, which overrides very few methods, you'll pay the price on every method call of the superclass, not just on those that you override.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1268#c10) posted by **travis.downs** on 2013-01-30 at 07:09 AM_
---
All that said, if were building this myself, here are the choices I would make:
Two concrete implementations of ImmutableList:
RegularImmutableList (the current implementation)
ForwardingImmutableList (similar to the same thing above, but clarified below)
OrtherImmutableList can be be implemented exactly as a delegate, like:
class OtherImmutableList extends ImmutableList {
&nbsp;&nbsp;final OtherImmutableListDelegate delegate;
&nbsp;&nbsp;@Override
&nbsp;&nbsp;void size() {
&nbsp;&nbsp;&nbsp;&nbsp;delegate.size();
&nbsp;&nbsp;}
}
I would implement the size 0 and 1 cases of ImmutableList in terms of RegularImmutable list - size 1 not being special at all, and size 0 always returning an empty array version of RegularImmutableList (so being very fast and zero memory cost).
The benefit of this is that it keeps the common case case, of regular immutable lists, even of size 0 and 1.  You'll likely find this faster in the case of 0 mixed with non-zero lists than the current implementation, yet not using any more memory unless 1-element lists are common since the 0-element list is a singleton.  That is, I disagree with ogregoire's assertion that you'll find Empty faster for larger list sizes - this won't happen except in extreme cases where the entire working set can't fit in L3, and the Empty set avoids one cache miss (doesn't need to examine .length).
For the unusual case, things will be about as a fast as possible. As long as only 1 "other" implementation occurs at a call side, you'll end up with a bimorphic check + momomorphic check and branch.  I'm just guessing here (not online) but something like 150-200 ns vs 90 ns for the monomorphic case.  Branch prediction will help a lot here, in since unlike JIT it is dynamic for the life of the process and can recognize patterns.  If you have mostly Regular ImmLists mixed with a few "Other" lists (of any type) you'll get close to 90 ns, since the JIT will set up the branches right, and branch prediction will get it right most of the time.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1268#c11) posted by **travis.downs** on 2013-01-30 at 07:10 AM_
---
Sorry, above OtherImmutableList == RegularImmutableList, made a last second edit that I can't fix now.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1268#c12) posted by **cpovirk@google.com** on 2013-01-30 at 03:31 PM_
---
Thanks for all the details. I'm bookmarking this for future reference.
When it comes to other implementations, my concern is less with reverse() and other oddballs and more with RegularImmutable_As_List, which is what you get from calling ImmutableList.copyOf(immutableSetOfMultipleElements). I'm envisioning a constructor that accepts an Iterable and calls copyOf() on it. Some callers will pass an ImmutableSet and get RegularImmutableAsList; others will pass other types and get RegularImmutableList.
I have no idea how common this is. That's the source of my fears that ForwardingImmutableList may be common. (Even if it is, will the objects that end up holding RegularImmutableList and the objects that end up holding RegularImmutableAsList end up being the same "call sites," or will inlining separate them? That's even harder to say. It's plausible, though.)
Having two types is, of course, a problem addressed by your solution of RegularImmutableList+ForwardingImmutableList. And now, by eliminating SingletonImmutableList, we're making tradeoffs between memory and CPU. Hmm.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1268#c13) posted by **gak@google.com** on 2013-01-30 at 04:31 PM_
---
tl;dr
https://wikis.oracle.com/display/HotSpotInternals/PerformanceTechniques
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1268#c14) posted by **lowasser@google.com** on 2013-01-30 at 05:46 PM_
---
@cpovirk: I'm fairly convinced that making sure the "common case" -- a vanilla ImmutableList -- is monomorphic should be our primary priority?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1268#c15) posted by **travis.downs** on 2013-01-30 at 06:11 PM_
---
I see the behavior of ImmutableList.copyOf() as worse in the plain iterable case, however - you can pass in a series of identically typed Iterables, varying only by length, and get different implementations back.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1268#c16) posted by **gak@google.com** on 2013-01-30 at 07:06 PM_
---
Basically, I think this is a great discussion that draws the conclusion that "all things being equal, monomorphic calls produce faster code than megamorphic calls".  I agree.  The JDK developers agree.  We just need to make sure that we're keeping larger performance picture in mind.
Making ImmutableList monomorphic shouldn't be our "primary priority" as it is a means, not an end.  Making certain calls monomorphic that are likely to be invoked in certain patterns is as good of a strategy as any other provided informed decisions are made about the trade-offs.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1268#c17) posted by **travis.downs** on 2013-01-31 at 04:30 AM_
---
Well at least the case of EmptyImmutableList isn't a case of favoring memory use over CPU, sine it's a singleton. So at least there the intent must have been a faster specialization since all methods can be hardcoded.
That seems like a straightforward win to remove - no increase in memory use (ok, a few bytes process wide) and should be faster bit lower in practice, except in degenerate cases like a huge number of empty lists.
Size 1 case is definitely more subtle - I'd be curious if your internal profiling shows these make up a large amount of aggregate memory use.
We've been addressing this, and most immutable collection types are down to bimorphic now.  We'll continue paying attention to this, though.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1266) created by **dharkness** on 2013-01-23 at 08:50 PM_
---
This enhancement got lost in the debate over Ranges and Predicates in #1038, but I feel it's a worthwhile addition. The page about preconditions even lists returning the argument from checkNotNull() as a reason for rolling your own preconditions.
If you want to use checkArgument() on a constructor argument when calling another constructor, you're currently forced to create a private helper method.
```
public Book(int price) {
super(checkPrice(price));
}
private int checkPrice(int price) {
checkArgument(price > 0);
return price;
}
```
This isn't required with checkNotNull().
```
public Book(String title) {
super(checkNotNull(title));
}
```
Overloading checkArgument() to accept the argument in addition to the boolean expression and return the argument would make the above more readable.
```
public Book(int price) {
super(checkArgument(price, price > 0));
}
```
This would also make constructors with multiple preconditions read more clearly by putting the assignment and check on the same line, just as with checkNotNull().
This requires the same three methods with an additional (first) parameter.
```
public static <T> T checkArgument(T value, boolean expression) { ... }
... plus two more for passing a message ...
```
While that implementation would suffice and have the least surprise, it might be nice to alter the one that takes a message without any errorMessageArgs to pass the argument value to format() to avoid having to pass the argument twice.
```
public Book(int price) {
super(checkArgument(price, price > 0, "Price %s must be > 0"));
}
```
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1266#c1) posted by **ogregoire** on 2013-01-23 at 10:05 PM_
---
I think about examples like:
&nbsp;&nbsp;checkArgument(price, price > 0, "price (%s) must be strictly positive", price);
Here I use three times the variable "price" on the same line. Isn't that a bit too much? Especially when a variable name is like 12-15 chars.
What about setting the price afterwards? What about using the builder pattern? These two solutions will render the object much more flexible. I haven't encountered such a badly designed constructor in years.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1266#c2) posted by **dharkness** on 2013-01-23 at 11:35 PM_
---
While your first concern is addressed by the optional form that passes the value along to format() if no message arguments are passed, the full form is still shorter. Compare
```
this.price = checkArgument(price, price > 0, "price (%s) must be strictly positive", price);
```
to
```
checkArgument(price > 0, "price (%s) must be strictly positive", price);
this.price = price;
```
Keep in mind that these forms would be _in addition_ to the regular forms that don't accept the raw argument value. You'd be free to avoid them.
Where this would really pay off is when a constructor has multiple preconditions. The current situation is unreadable:
```
this.title = checkNotNull(title, "A title is required");
checkArgument(price > 0, "Price %s must be strictly positive", price);
this.price = price;
checkArgument(!authors.isEmpty(), "Must have at least one author");
this.authors = authors;
```
Compared to
```
this.title = checkNotNull(title, "A title is required");
this.price = checkArgument(price, price > 0, "Price %s must be strictly positive");
this.authors = checkArgument(authors, !authors.isEmpty(), "Must have at least one author");
```
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1266#c3) posted by **lowasser@google.com** on 2013-01-24 at 01:06 AM_
---
Hmmm. I have to admit I don't think the second example you give is more readable than the first.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1266#c4) posted by **wasserman.louis** on 2013-04-25 at 03:40 PM_
---
_Issue #1384 has been merged into this issue._
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1264) created by **dbemil...@ixl.com** on 2013-01-22 at 12:15 AM_
---
Hey,
I was wondering if there was any reason that ImmutableTables aren't Serializable. ImmutableCollections, ImmutableMaps, and ImmutableMultimaps are all Serializable... but ImmutableTables aren't?
Thanks,
Dave
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1264#c1) posted by **cpovirk@google.com** on 2013-01-22 at 04:32 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Accepted`
**Owner:** cpovirk@google.com
**Labels:** `Milestone-Release15`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1264#c2) posted by **wasserman.louis** on 2013-02-04 at 01:13 AM_
---
https://github.com/google/guava/commit/6addb1f214c02b8f1de65cc564f5fa1e29da59ea
---
**Status:** `Fixed`
This was marked fixed...but it doesn't actually look fixed?
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1259) created by **yurachud** on 2013-01-16 at 04:20 PM_
---
If we pass null to Ints.tryParse it throws NullPointerException.
Method uses AndroidInteger.tryParse(), but the first line there is checkNotNull() method.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1259#c1) posted by **SeanPFloyd** on 2013-01-16 at 04:25 PM_
---
I'm pretty sure that's intended behavior: http://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1259#c2) posted by **kak@google.com** on 2013-01-16 at 04:25 PM_
---
That's what it should do, right?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1259#c3) posted by **kak@google.com** on 2013-01-16 at 04:26 PM_
---
_(No comment entered for this change.)_
---
**Status:** `WorkingAsIntended`
**Labels:** `Package-Primitives`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1259#c4) posted by **yurachud** on 2013-01-16 at 06:56 PM_
---
So, I was confused by JavaDocs.
"<p>Unlike {@link Integer#parseInt(String)}, this method returns
&nbsp;&nbsp;&nbsp;\* {@code null} instead of throwing an exception if parsing fails."
As I understood it means that method doesn't throw any exception and return value or null.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1259#c5) posted by **cpovirk@google.com** on 2013-01-16 at 07:01 PM_
---
- Integer.parseInt threw NumberFormatException, rather than NullPointerException, for null inputs, despite the precedent elsewhere in the JDK.
https://google.github.io/guava/apidocs/com/google/common/primitives/package-summary.html
Given these subtleties, I think we should document this better. In fact, we had basically the same discussion about the less confusing UnsignedLongs.parseUnsignedLong, and we decided to make the documentation there clearer:
https://google.github.io/guava/apidocs/com/google/common/primitives/UnsignedLongs.html#parseUnsignedLong%28java.lang.String%29
---
**Status:** `Accepted`
**Labels:** `Type-ApiDocs`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1259#c6) posted by **kak@google.com** on 2013-01-16 at 07:14 PM_
---
However, the wording on that particular API could be improved (since we explicitly said it doesn't throw an exception if parsing fails).  Thanks for the report!
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1258) created by **adrian.f.cole** on 2013-01-14 at 03:37 AM_
---
Seems the following should be possible to include, and save a lot of people parsing on their own.  WDYT?
Range&lt;InetAddress> slash22 = InetAddresses.cidrRange("198.51.100.0/22");
or..
Range&lt;InetAddress> slash48 = InetAddresses.cidrRange("2001:db8::", 48);
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1239) created by **kevinb@google.com** on 2012-12-26 at 04:37 PM_
---
Reported internally:
ToStringHelper is fundamentally incompatible with inheritance; invoking super.toString() and complementing that with new fields doesn't work. I got used to this simple solution:
root class:
&nbsp;&nbsp;&nbsp;protected ToStringHelper toStringHelper() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Objects.toStringHelper(this).omitNullValues()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.add("foo", foo)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.add("bar", bar);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;public final String toString() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return toStringHelper().toString();
&nbsp;&nbsp;&nbsp;}
&nbsp;@Override
&nbsp;protected ToStringHelper toStringHelper() {
&nbsp;&nbsp;&nbsp;return super.toStringHelper()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.add("baz", baz)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.add("qux", qux);
&nbsp;}
It's a canonical Template Method pattern. The result is both simple and efficient, a single ToStringHelper object is used and a single product string is build, subclasses can just add new fields without duplicating code from superclasses.
I think we should document this pattern as a suggestion, in ToStringHelper's javadoc. I can do that we think it's a good idea (doesn't seem too obvious, etc.).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1239#c1) posted by **kevinb@google.com** on 2012-12-26 at 04:43 PM_
---
Greg and I suspect that the vast, vast majority of people using toStringHelper are using it without inheritance, so that seems like it'd add a lot of documentation for a relatively uncommon usage.
I would add that someone who does want to do this will more likely than not hit upon the "canonical Template Method pattern" (which it is) above without special help.
And there is also the fact that toStringHelper() is often used with value objects, and inheritance to add value components just plain doesn't work.
---
**Status:** `WorkingAsIntended`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1239#c2) posted by **amertum** on 2012-12-27 at 01:23 PM_
---
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1213) created by **cgruber@google.com** on 2012-11-28 at 07:00 PM_
---
One example:  Sun JDK 1.6 on what I must presume is a linux machine (Cloudbees) under Jenkins.
Failed
com.google.common.collect.testing.testers.MapPutTester.testPut_nullKeySupportedNotPresent[SafeTreeMap with null-friendly comparator [collection size: zero] subMap NO_BOUND-EXCLUSIVE [collection size: zero] descending [collection size: zero]](from com.google.common.collect.testing.SafeTreeMapTest)
Failing for the past 20 builds (Since #4 )
Took 5 ms.
add description
Error Message
did not contain expected element null=April, expected = [null=April], actual = []
Stacktrace
junit.framework.AssertionFailedError: did not contain expected element null=April, expected = [null=April], actual = []
&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.Assert.fail(Assert.java:47)
&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.testing.Helpers.assertEqualIgnoringOrder(Helpers.java:91)
&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.testing.AbstractContainerTester.expectContents(AbstractContainerTester.java:112)
&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.testing.AbstractMapTester.expectContents(AbstractMapTester.java:195)
&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.testing.AbstractContainerTester.expectAdded(AbstractContainerTester.java:144)
&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.collect.testing.testers.MapPutTester.testPut_nullKeySupportedNotPresent(MapPutTester.java:145)
&nbsp;&nbsp;&nbsp;&nbsp;at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
&nbsp;&nbsp;&nbsp;&nbsp;at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
&nbsp;&nbsp;&nbsp;&nbsp;at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
&nbsp;&nbsp;&nbsp;&nbsp;at java.lang.reflect.Method.invoke(Method.java:597)
&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestCase.runTest(TestCase.java:168)
&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestCase.runBare(TestCase.java:134)
&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestResult$1.protect(TestResult.java:110)
&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestResult.runProtected(TestResult.java:128)
&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestResult.run(TestResult.java:113)
&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestCase.run(TestCase.java:124)
&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.runTest(TestSuite.java:243)
&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.run(TestSuite.java:238)
&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.runTest(TestSuite.java:243)
&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.run(TestSuite.java:238)
&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.runTest(TestSuite.java:243)
&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.run(TestSuite.java:238)
&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.runTest(TestSuite.java:243)
&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.run(TestSuite.java:238)
&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.runTest(TestSuite.java:243)
&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.run(TestSuite.java:238)
&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.runTest(TestSuite.java:243)
&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.run(TestSuite.java:238)
&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.runTest(TestSuite.java:243)
&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.run(TestSuite.java:238)
&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.runTest(TestSuite.java:243)
&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.TestSuite.run(TestSuite.java:238)
&nbsp;&nbsp;&nbsp;&nbsp;at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:83)
&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:53)
&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:123)
&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:104)
&nbsp;&nbsp;&nbsp;&nbsp;at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
&nbsp;&nbsp;&nbsp;&nbsp;at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
&nbsp;&nbsp;&nbsp;&nbsp;at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
&nbsp;&nbsp;&nbsp;&nbsp;at java.lang.reflect.Method.invoke(Method.java:597)
&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:164)
&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:110)
&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.maven.surefire.booter.SurefireStarter.invokeProvider(SurefireStarter.java:175)
&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.maven.surefire.booter.SurefireStarter.runSuitesInProcessWhenForked(SurefireStarter.java:107)
&nbsp;&nbsp;&nbsp;&nbsp;at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:68)
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1212) created by **knut.wannheden** on 2012-11-26 at 08:17 AM_
---
The interface java.util.concurrent.locks.Condition has await() methods just like those of java.util.concurrent.CountDownLatch. It would be nice if the Uninterruptibles class had equivalent awaitUninterruptibly() methods for Condition.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1212#c1) posted by **cpovirk@google.com** on 2012-11-26 at 07:02 PM_
---
Condition provides a no-arg awaitUninterruptibly() to correspond to the no-arg await():
void await() => void awaitUninterruptibly()
So I guess you're asking about these two?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1212#c2) posted by **knut.wannheden** on 2012-11-26 at 08:40 PM_
---
Yes, sorry for not making that clear. I was referring to uninterruptible methods corresponding to Condition#await(long, TimeUnit) and Condition#awaitUntil(Date).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1212#c3) posted by **cpovirk@google.com** on 2012-11-26 at 08:57 PM_
---
Thanks.
My stance on Uninterruptibles methods for java.util.concurrent classes is pretty much that we'll add whatever people need. They're just a little bit of a pain to test, so they're not something we can bang out in 5 minutes, so I don't know exactly when we'll get to this.
---
**Status:** `Accepted`
**Labels:** `Type-Addition`, `Package-Concurrent`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1212#c4) posted by **kasperni** on 2012-12-05 at 11:18 AM_
---
awaitUntil(Date deadline) should not be added. All JUC classes relies on System.nanotime() not on System.currentTimeMillis()
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1212#c5) posted by **kak@google.com** on 2013-08-22 at 11:33 PM_
---
_(No comment entered for this change.)_
---
**Owner:** cpovirk@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1212#c6) posted by **lukes@google.com** on 2013-08-22 at 11:38 PM_
---
This isn't really what you are asking for, but I would suggest switching to use Monitor instead of Condition (https://google.github.io/guava/apidocs/com/google/common/util/concurrent/Monitor.html).
Monitor is easier to use (IMHO) and already supports a timed uninterruptible wait.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1204) created by **ogregoire** on 2012-11-14 at 02:05 PM_
---
I very much enjoyed the additions documented in issue 725, but they concern only doubles.
Unless I missed another issue with this question already, please consider adding fuzzy comparisons for floats. This was alrady asked as part of issue 864, but the whole issue was considered a duplicate, without consideration for the float part.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1204#c1) posted by **lowasser@google.com** on 2012-11-14 at 07:00 PM_
---
I'm not seeing how a theoretical FloatMath.fuzzyEquals(a, b, tolerance) wouldn't be fully equivalent to DoubleMath.fuzzyEquals((double) a, (double) b, (double) tolerance).
---
**Labels:** `Type-Addition`, `Package-Math`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1204#c2) posted by **lowasser@google.com** on 2012-11-14 at 07:07 PM_
---
Or is there some specific platform/performance reason why you would prefer to do the math only in floats for some particular application?
---
Check the code in the following file (and run it). On 2^32 comparisons between the current doubles version and a float-optimized version of the fuzzyEquals, I get 17.958.971 errors, which means roughly 0,42% errors.
I have no issue with the performances as Doubles.fuzzyEquals.
---
Why do you call it errors? I'd say, your tolerance is fairly intolerant as you're testing if
f1 + 0.001f + 0.001f ... (ten times) <= f1 + 0.01f
and
f1 + 0.001f + 0.001f ... (ten times) <= f1 + 0.01
agree (note the missing "f" suffix). These sometimes differ, more precisely it may happen that in double the LHS is slightly larger than the RHS, while in float they equal.
But that's actually what the tolerance is for. What you're doing is insisting on an exact behavior for your exact tolerance value. I fail to see what it could be good for.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1204#c5) posted by **ogregoire** on 2012-11-15 at 06:59 PM_
---
I encountered such a corner-case and couldn't find the issue until I wrote my own float-specific fuzzyEqual (see previous code), which fixed it. Hence this request.
Theoretically, it should be the same, but my code proves that practically it's not. That's what I expect to be fixed.
I know I'm not dealing with precise values (if I'd want that, I'd use BigDecimal), but I'd still want something that takes the specificities of float rather than having to fallback to doubles and therefore having unwanted/unexpected behavior.
---
I'm pretty sure that there's nothing to be fixed with DoubleMath.fuzzyEquals. There are always cases when double and float computations return different results. There's no case when anybody should depend on the results being the same.
There's no usage example in the Javadoc to fuzzyEquals, so maybe this one helps:
Assume you're computing some triangles which should be right-angled. Testing a_a+b_b==c*c is futile due to rounding errors, so you use
assertTrue(DoubleMath.fuzzyEquals(a_a+b_b, c*c, 1e-6));
instead. This is far from perfect (for many reasons), but it might be exactly what you need. You might need a different tolerance, maybe 2e-3, maybe 1.5e-7, but nobody needs to specify a tolerance of 1.000012345789e-6. And specifying that the test is to be performed using floats instead of doubles makes even much less sense!
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1204#c7) posted by **kak@google.com** on 2013-08-22 at 11:31 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
**Owner:** lowasser@google.com
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1203) created by **nikazim** on 2012-11-14 at 11:01 AM_
---
Allow per entry expiry time for caches built with expireAfterWrite / expireAfterAccess (something like put(K key, V value, long timeout).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1203#c1) posted by **wasserman.louis** on 2012-11-14 at 04:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Addition`, `Package-Cache`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1203#c2) posted by **lowasser@google.com** on 2012-12-20 at 08:18 PM_
---
Wait.  Wouldn't you want that only if the cache was _not_ built with expireAfterWrite/expireAfterAccess?
In any event, this seems really awkward from an API perspective, in addition to being problematic from an implementation point of view.  In particular, customized expiration times more or less require you to use an O(log n) priority queue, as opposed to the current O(1) implementation that is possible when you can just maintain a linked list of most recently written or most recently accessed.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1203#c3) posted by **kevinb@google.com** on 2013-03-12 at 06:43 PM_
---
_(No comment entered for this change.)_
---
**CC:** fry@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1203#c4) posted by **Ben.Manes** on 2013-08-21 at 05:01 AM_
---
You wouldn't use a priority queue w/ O(lg n) insertion and removal. Instead you'd require an expected range for expiration times and a resolution (e.g. 1..60 in minutes). This would allow you to a create an array of linked list (e.g. a bounded height priority queue) so that add/remove/reorder is O(1). The penalty would be O(r) of scanning the first element in every slot to see if an eviction is required.
The API would still be awkward, even more so than the O(lg n) version requested, but would be much cheaper to maintain.
(Not advocating, but mentioning as this feature is often requested)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1203#c5) posted by **kak@google.com** on 2013-08-22 at 11:29 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1199) created by **kevinb@google.com** on 2012-11-09 at 10:27 PM_
---
One could never reach the refresh time, really.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1199#c1) posted by **kevinb@google.com** on 2013-03-12 at 06:43 PM_
---
_(No comment entered for this change.)_
---
**CC:** fry@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1199#c2) posted by **kevinb@google.com** on 2013-03-12 at 06:47 PM_
---
(we would do this in the places we call checkWeightWithWeigher)
---
**Status:** `Accepted`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1199#c3) posted by **kak@google.com** on 2013-08-22 at 11:27 PM_
---
_(No comment entered for this change.)_
---
**Owner:** lowasser@google.com
**Labels:** `Type-Enhancement`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1198) created by **kevinb@google.com** on 2012-11-09 at 10:18 PM_
---
(It should of course continue to update the write time.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1198#c1) posted by **kevinb@google.com** on 2012-11-09 at 10:19 PM_
---
(split this out of bug 835)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1198#c2) posted by **wasserman.louis** on 2012-11-13 at 05:41 AM_
---
It's not clear to me -- though I'm certainly having trouble reading through the code -- that this actually happens, as it stands.
Certainly refreshes triggered by get() queries bump the access time, because a get() is indeed an access.  This is as it should be.  But I don't think that LoadingCache.refresh(key) calls actually end up bumping the access times either.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1198#c3) posted by **kevinb@google.com** on 2013-03-12 at 06:43 PM_
---
_(No comment entered for this change.)_
---
**CC:** fry@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1198#c4) posted by **kevinb@google.com** on 2013-03-12 at 06:44 PM_
---
_(No comment entered for this change.)_
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1193) created by **lowasser@google.com** on 2012-11-06 at 08:07 PM_
---
Among other things, switching to factory methods (which actually usually return static constants) -- along the lines of what Hashing does with hash functions -- would make it significantly easier to lazily initialize CharMatcher constants.
CharMatcher is technically still @Beta, so we could do it...
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1193#c1) posted by **kevinb@google.com** on 2012-11-07 at 01:38 AM_
---
I'm convinced the static accessors would have been the right way to go. Lesson learned. Cost of migration is the question for me now. Also note that not _every_ one of the constants even deserves to be kept at all.
---
It looks like public constants have hardly any use at all, as they're less flexible than static accessors.
I wonder if any changes are really needed here given that the culprit (`slowGetChars`) is gone in 464b0cf.
It's easy to both keep the constants and defer the initialization; see the patch. It costs two indirections at runtime (INVISIBLE -> InvisibleImpl -> INSTANCE), which will be inlined, so the only cost is some ugliness.
In case the migration cost is too high, you could simply rewrite the most expensive constants like in the patch.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1193#c3) posted by **kevinb@google.com** on 2013-04-08 at 06:58 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Base`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1193#c4) posted by **kak@google.com** on 2013-08-22 at 11:22 PM_
---
We tend to think this isn't really worth the effort to change all of the callers and go through the deprecation cycle.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1191) created by **chriss.dev** on 2012-11-05 at 03:17 PM_
---
Currently it is hard to find a URL-Validator that works properly. Java's  java.net.URL(String)-Constructor doesn't throw a MalformedUrlException in any case and org.apache.commons.validator.routines.UrlValidator ain't better (e.g. "http://usr:pwd@localhost" validates always to false).
I think validating URLs is a common task so it could find a home in guava? It would be nice to see a class that provides also methods to validate specific parts of a URL like username,password, query, fragment and so on, without a lookup or other network-operations.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1191#c1) posted by **cpovirk@google.com** on 2012-11-05 at 04:57 PM_
---
This is definitely something we want to do. It will just be a while. We have to sort through a number of issues with our existing classes (and maybe cut some dependencies).
---
**Status:** `Accepted`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1191#c2) posted by **cpovirk@google.com** on 2012-11-07 at 07:42 PM_
---
_(No comment entered for this change.)_
---
**Blocked On:** #1005
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1191#c3) posted by **kak@google.com** on 2013-08-22 at 11:19 PM_
---
_(No comment entered for this change.)_
---
**Owner:** cpovirk@google.com
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1190) created by **travis.downs** on 2012-11-04 at 10:17 AM_
---
If you split on a zero-width regex, the last element may be dropped.
String input = "foo";
Splitter splitter = Splitter.onPattern(regex);
System.out.println(Arrays.asList(input.split(regex)));
System.out.println(Arrays.asList(Iterables.toArray(splitter.split(input),String.class)));
This does zero-width lookaround for 'o', so the string will be split before and after any o, but the o characters will also be returned as individual items.
Examining the code, this was probably introduced in this fix (granted, it didn't work at all before that):
https://github.com/google/guava/issues/936
In particular, this bit of logic in Splitter.java:
```
if (offset == nextStart) {
/*
* (ommit comment)
*/
offset++;
if (offset >= toSplit.length()) {
offset = -1;
}
continue;
}
```
neglects to the the "last element" handling that the general logic above does (setting end to toSplit.lenth() if no more separators are found).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1190#c2) posted by **travis.downs** on 2012-11-04 at 10:27 AM_
---
In case anyone also runs into this, and is using trimResults() and omitEmptyStrings(), you can work around it by just appending a space to your input.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1190#c3) posted by **wasserman.louis** on 2012-11-04 at 05:26 PM_
---
Relevant: issue 936, which was our first attempt to make sensible behavior happen on zero-length regexes.
---
**Labels:** `Type-Defect`, `Package-Base`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1190#c4) posted by **travis.downs** on 2012-11-04 at 09:08 PM_
---
Right, mentioned above also, but I didn't know how to make the fancy link. It's worth noting that this issue only happens in the special case that the lookaround match is one character long.  That is, the example above, but just doubling the characters in the input and lookaround:
```
String input = "FfOoOo";
```
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1190#c5) posted by **cpovirk@google.com** on 2013-01-18 at 09:54 PM_
---
Louis did some work on this internally, but we got stuck on what to do in some odd cases. The perlfunc docs list a few:
"""
Note that splitting an EXPR that evaluates to the empty string
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;always returns the empty list, regardless of the LIMIT specified.
"""
"""
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A PATTERN of "/^/" is treated as if it were "/^/m", since it isn't much use otherwise.
"""
"""
Empty leading fields are produced when there are positive-width matches at the beginning of the string; a zero-width match at the beginning of the string does not
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;produce an empty field.
...
Empty trailing fields, on the other hand, are produced when there is a match at the end of the string (and when LIMIT is given
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and is not 0), regardless of the length of the match.
"""
We need to decide what Guava should do with zero-width matches at the beginning and end of string. An additional complication is that String.split does not completely follow Perl's precedent. We can see this from eagle.xiao's example on issue 936. In slightly simplified form:
&nbsp;&nbsp;System.out.println(Arrays.toString("a".split("(?<=a)|(?=a)", -1)));
[, a, ]
&nbsp;&nbsp;perl -e 'for (split(/(?<=a)|(?=a)/, "a", -1)) { print "$_\n"; }' | sed -e 's/^$/&lt;blank>/'
a
&lt;blank>
String.split produces a leading empty string; Perl does not.
But String.split usually avoids leading empty strings:
```
System.out.println(Arrays.toString("a".split("(?=a)", -1)));
```
[a]
```
System.out.println(Arrays.toString("a".split("^", -1)));
```
[a]
Both of these match Perl's behavior:
&nbsp;&nbsp;perl -e 'for (split(/(?=a)/, "a", -1)) { print "$_\n"; }' | sed -e 's/^$/&lt;blank>/'
a
&nbsp;&nbsp;perl -e 'for (split(/^/, "a", -1)) { print "$_\n"; }' | sed -e 's/^$/&lt;blank>/'
a
I wonder if there's a principled reason for the policy difference between trailing leading and trailing empty strings or whether it's an accident of historical implementation.
We'll have to decide one way or the other. If we're lucky, no one cares either way :) As for the rare differences between String.split and Perl, I'm not too concerned with what we do there. String.split doesn't appear to document its behavior for this case clearly, so if anything, I'd call its behavior a bug. But I wouldn't go to great lengths to behave like Perl if the problem lies in Pattern and Matcher themselves and thus affects Splitter. (I assume that it does.)
Here's a bonus difference between Perl and String.split:
&nbsp;&nbsp;perl -e 'for (split(/(?<=b)|x/, "fobxx", -1)) { print "$_\n"; }' | sed -e 's/^$/&lt;blank>/'
&lt;blank>
&lt;blank>
&lt;blank>
&nbsp;&nbsp;System.out.println(Arrays.toString("fobxx".split("(?<=b)|x", -1)));
[fob, x, ]
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1190#c6) posted by **cpovirk@google.com** on 2013-01-18 at 09:57 PM_
---
Here's a justification for Perl's "empty string always returns the empty list" behavior:
http://grokbase.com/t/perl/perl5-porters/0152aed0vc/docs-on-split#20010503im3myfqpcr36yeb5ixjk5dmkly
My read on that is that the caller should replace...
next unless @f;
...with...
next unless $_;
...at which point the special case is no longer necessary. But perhaps I'm misinterpreting some Perl conversion rule.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1190#c7) posted by **cpovirk@google.com** on 2013-01-18 at 11:04 PM_
---
_Issue #1262 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1190#c8) posted by **cpovirk@google.com** on 2013-01-18 at 11:06 PM_
---
1) I just posted to a Perl list asking about the behavior of zero-width matches at the beginning and end of string:
http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2013-01/msg00473.html
2) I should look at Louis's CL, which was intended to fix the original issue report but was derailed by my additional questions. I know we decided that some of it was hopeless, but I'm hoping it wasn't _all_ hopeless... really hoping....
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1190#c9) posted by **kevinb@google.com** on 2013-01-18 at 11:37 PM_
---
If splitting ",a" on /,/ yields ["", "a"] then splitting it on /(?=,)/ should yield ["", ",a"], should it not? If the separator pattern occurs N times in the input, the returned iterable should always be of size N+1.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1190#c10) posted by **cpovirk@google.com** on 2013-01-18 at 11:51 PM_
---
In a vacuum, I think I agree, though there is at least one minor downside: It's arguably nice to be able to split on // in order to extract its characters. On the other hand, we have Lists.charactersOf for this, and Lists.charactersOf actually gives you Characters, rather than Strings.
Splitting on zero-width matches is just kind of odd to begin with, and aside from //, I'm not familiar with the use cases. I wonder if some of them would be better served by high-level interfaces for "extract all matches of this regex" or similar.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1190#c11) posted by **cpovirk@google.com** on 2013-02-02 at 08:41 PM_
---
I went looking for split() implementations in RE2 (no split method?) and Chrome (stringProtoFuncSplit). Chrome cites the ECMAScript spec, which says to ignore both leading _and_ trailing empty string created by zero-width matches:
"The value of separator may be an empty String, an empty regular expression, or a regular expression that can match an empty String. In this case, separator does not match the empty substring at the beginning or end of the input String, nor does it match the empty substring at the end of the previous separator match. (For example, if separator is the empty String, the String is split up into individual characters; the length of the result array equals the length of the String, and each substring contains one character.)"
http://www.ecma-international.org/ecma-262/5.1/#sec-15.5.4.14
Finally, I thought a bit more about Kevin's comment #9. In one respect, we have four options:
1. ignore both empty leading and trailing strings created by zero-width matches
2. preserve both ...
3. ignore trailing ... but not leading
4. ignore leading ... but not trailing
(1) is what ECMAScript does. I think I prefer this, too.
(2) is what nothing does, at least from what I've seen (Perl+Java+ECMAScript).
(1) has a precedent, and it avoids a leading/trailing inconsistency. I say we do that.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1190#c12) posted by **cpovirk@google.com** on 2013-02-02 at 08:46 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1190#c13) posted by **travis.downs** on 2013-02-02 at 09:19 PM_
---
Not that it matters from a general perspective, but for a single data point from the original reporter...
My usage assumes (1) and it would definitely be preferred in that case. My specific use case is splitting a string, without dropping the delimiters - for example, splitting on arithmentic operators in a string like abc_(1+2) would return ["abc","_","(","+",")"].  The canonical (only?) way to achieve this kind of split which preserves all the characters using regex is apparently these zero width matches.
So there is a real-world use case as cpov wondered about above.  In this case, leading and trailing empty strings are useless (but I'm trimming whitespace and dropping empty strings anyway, so it isn't a huge burden if they appear).
A split of "" will always produce [""], even with (1) and zero-width matches, right?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1190#c14) posted by **travis.downs** on 2013-02-02 at 09:20 PM_
---
Sorry, the correct split should be:
["abc", "*", "(", "1", "+", "2", ")"]
dropping the #s was not intentional
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1190#c15) posted by **cpovirk@google.com** on 2013-02-02 at 09:48 PM_
---
Thanks for the use case. The example of preserving delimiters is a good reason for preferring (1) or (2) over (3) and (4):
$ perl -e 'for (split(/(?=,)|(?<=,)/, ",a,b,c,", -1)) { print "$_\n"; }' | sed -e 's/^$/&lt;blank>/'
,
a
,
b
,
c
,
&lt;blank>
Surely nobody wants that, right? Either they want empties at both ends or empties at neither. (Obviously the example is dumb as I've written it, but imagine that comma is replaced with comma/semicolon/colon/....)
As you point out, the difference between (1) and (2) goes away in the case of omitting empty strings, so maybe it's no big deal either way. In the absence of other use cases, I kind of like following the ECMAScript precedent, but I wouldn't be shocked if the leading and trailing empties were significant to someone.
> A split of "" will always produce [""], even with (1) and zero-width
> matches, right?
Yes. I think the way we would look at it, regardless of the (1)/(2)/(3)/(4) choice, is similar to what Kevin said above: If the separator occurs n times, we produce an output with n+1 items. The difference between the policies would be in whether we consider a separator to ever occur before the first character or after the last.
Now that you mention it, that's a fun question for the other policies. If we allow a zero-width match to create empty strings at the beginning but not the end, then I would say that we would likewise have to return a single string when asked to split "" on //, since that match would be occurring both at the beginning and at the end, and matches at the end are forbidden. The same would go for the reverse policy. This ensures the following pattern: If you split "foo" on //, you get 4 results. If you split "fo" on //, you get 3. "f" gives 2, and "" gives 1. Now suppose that we permit zero-width matches at both beginning and end. "foo" gives 5 results, "fo" 4," "f" 3, and "" 2. I guess that that's reasonable, too. By contrast, if we permit zero-width matches at neither beginning nor end, we get "foo" 3, "fo" 2, "f" 1, "" 1. That's arguably "worse," but it's more consistent with how normal delimiters work: Splitting "f,o,o" on "," produces 3 results, "f,o" 2, "f" 1, and "" 1 again. That's maybe too much of an edge case to base a position on, but I'll offer it as support, anyway, since it agrees with the way I'm already leaning :)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1190#c16) posted by **cpovirk@google.com** on 2013-02-12 at 01:46 AM_
---
Python doesn't allow splitting on empty matches:
http://docs.python.org/2/library/re.html#re.split
For example:
python -c "import re; print re.split(r'$', 'foo')"
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1190#c17) posted by **cpovirk@google.com** on 2013-03-11 at 02:38 PM_
---
I just got a very helpful response on the Perl list:
http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2013-03/msg00390.html
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1190#c18) posted by **cpovirk@google.com** on 2014-05-13 at 07:15 PM_
---
If we follow the ECMAScript implementation, we should keep in mind that, according to a post I just saw:
TIL:
We've just learned that this is particularly bad when the input string is only one character:
```
public void testPatternSplitWordBoundary_singleCharInput() {
String string = "f";
Iterable<String> words = Splitter.on(Pattern.compile("\\b")).split(string);
assertThat(words).containsExactly("f").inOrder();
}
```
This test fails: `words` is completely empty.
It would still be good to fix eventually. It's just never the top priority.
Thanks. Will have a look, hopefully next week.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1187) created by **cgdecker@google.com** on 2012-11-02 at 04:43 PM_
---
We're considering an incompatible change to ByteProcessor and LineProcessor and the methods that use them. They currently have generics and a getResult() method, but in practice, most usages have a field that is accumulated to in the process method and returned by the getResult() method. Instead, a final variable in the calling method could be accumulated to in the process method, with no need for getResult() at all.
Is anyone using ByteProcessor or LineProcessor in a way that would make this change a problem for them?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1187#c1) posted by **joe.j.kearney** on 2012-11-02 at 07:02 PM_
---
This sounds a lot like the difference between the following in Spring's JDBC result set handling, which covers most of the possibilities. Worth seeing that for prior art of line-by-line processing?
- RowCallbackHandler - void processRow(ResultSet) - you get a callback for each row and do whatever you want with accumulating, you implement getResult() if you want it. Someone else controls looping. [1]
- RowMapper - T mapRow(ResultSet, int rowNum) - you get a callback for each row and return an object for that row. Effectively getResult() returns a List&lt;T> of the mapped objects. [2]
- ResultSetExtractor - T extractData(ResultSet) - generalised version of the others. Your implementation does everything: controls looping, gathers and returns results. [3]
The other very general option is for the row callback to be provided with a clientObject/accumulator, which maybe was created in the processor as well. (This is very foldLeft.) You start needing a few generic types for the type of the accumulator, maybe something else for the ultimately returned type (think ImmutableList.Builder accumulator -> ImmutableList, for example) and a few methods like createAccumulator, postProcess(Accumulator) (to build the ImmutableList, for example). This provides a lot of flexibility but is likely much more of a change than is warranted.
Are you talking about just removing getResult()? For my part I'd be happy to take the change, but in such a small interface it seems not likely to be that big a deal to fix.
[1] - http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/jdbc/core/RowCallbackHandler.html
[2] - http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/jdbc/core/RowMapper.html
[3] - http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/jdbc/core/ResultSetExtractor.html
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1187#c2) posted by **cgdecker@google.com** on 2012-11-02 at 07:13 PM_
---
> Are you talking about just removing getResult()? For my part I'd be happy to take the change, but in such a small interface it seems not likely to be that big a deal to fix.
Yep, basically just changing the interfaces to:
interface ByteProcessor {
&nbsp;&nbsp;boolean processBytes(byte[] buf, int off, int len) throws IOException;
}
interface LineProcessor {
&nbsp;&nbsp;boolean processLine(String line) throws IOException;
}
Anything else can be built on top of those pretty easily, so I don't think I'd want to go down the road of providing narrower functionality like RowMapper unless it was clear that mapping individual lines to objects was the most common use case.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1187#c3) posted by **xaerxess** on 2012-11-12 at 12:51 PM_
---
Proposed change is quite clean when accumulator T is of type Iterable&lt;E> but we use LineProcessor with Files.readLines(File file, Charset charset, LineProcessor&lt;T> callback) method which will be harder to implement for you (if possible) and for use if you change the interface.
I mean, in our case, getResult method builds some more complex object based on few private instance variables some of which change state and, since they're implementation detail of concrete LineProcessor subclass, they should not leak outside as suggested in this issue. This code:
```
CacheBuilder.newBuilder().build(new CacheLoader<String, AnnouncementsData>() {
public AnnouncementsData load(final String indexVersion) throws Exception {
return Files.readLines(new File(getAnnouncementsPath(indexVersion)),
Charsets.UTF_8, new AnnouncementsLineProcessor());
}
```
plus AnnouncementsLineProcessor class definition with ImmutableList.Builder&lt;String>, String and SomeObj private variables (plus boolean flag which is used for some optimization and is enteirly an implementation detail) would turn into this:
```
CacheBuilder.newBuilder().build(new CacheLoader<String, AnnouncementsData>() {
public AnnouncementsData load(final String indexVersion) throws Exception {
// these were AnnouncementsLineProcessor instance variables
final ImmutableList.Builder<String> a = ImmutableList.builder();
final StringBuilder b = new StringBuilder();
// assignment won't work - c is final, so I have to use some wrapper here
final SomeObjWrapper c;
// this flag leaks out of LineProcessor impl and can't be simple boolean since is final
final AtomicBoolean checked = AtomicBoolean(false);
Files.readLines(new File(getAnnouncementsPath(indexVersion)),
Charsets.UTF_8, new LineProcessor() {
public boolean processLine(final String input) throws IOException {
/* must be inline */
} });
return new AnnouncementsData(a.build(), b.toString(), c.get());
}
```
I am not saying it's not possible for me to change my LineProcessor class, but having getResult method has pros - like hiding implementation concrete LineProcessor details and Filles.readLines method - in exchange for one more method in API. Correct me if I'm wrong but I guess it's a discussion of advantages and disadvantages of few different line-by-line processing philosophies just as joe.j.kearney wrote.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1187#c4) posted by **cgdecker** on 2012-11-12 at 01:57 PM_
---
@xaerxess: Keep in mind that you could keep your AnnouncementsLineProcessor pretty much as it is now, just with getResult() not being part of the interface. You'd just need to declare it as a variable before calling readLines, then call getResult() on it yourself afterwards.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1187#c5) posted by **xaerxess** on 2012-11-12 at 07:18 PM_
---
Yeah, I guess I've overlooked this solution... Then it would be cleaner API but slightly more dirty usage:
```
CacheBuilder.newBuilder().build(new CacheLoader<String, AnnouncementsData>() {
public AnnouncementsData load(final String indexVersion) throws Exception {
final AnnouncementsLineProcessor processor = new AnnouncementsLineProcessor(); // cannot use LineProcessor here
Files.readLines(new File(getAnnouncementsPath(indexVersion)), Charsets.UTF_8, processor);
return processor.getResult();
}
```
but seems reasonable for me now.
Probably it's not the best place to ask but would it be a good idea (just for my code) to create marker interface extending LineProcessor with getResult method (or also extending Supplier&lt;T> maybe?) if you changed the API and I wanted to program to an interface instead of class?
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1172) created by **thomas.tom.mueller** on 2012-10-17 at 06:23 AM_
---
I have implemented a concurrent LIRS cache. It is actually only an approximation by default, as the cache is segmented (each segment is synchronized - same as the concurrent hash map), and because re-ordering (move-to-front) only occurs if a number of other entries have been moved to the front first. Both parameters are configurable, so it is possible to tune it for speed (which might somewhat affect the hit ratio) or maximum hit ratio.
I have submitted the code to the concurrentlinkedhashmap project, see https://code.google.com/p/concurrentlinkedhashmap/issues/detail?id=36
I create an issue here because this might be an interesting addition for the Guava library, as Ben Manes from the concurrentlinkedhashmap project suggested.
The implementation is somewhat tested, but not completely - tests are available at http://code.google.com/p/h2database/
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1172#c1) posted by **kevinb@google.com** on 2012-11-09 at 09:41 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Cache`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1172#c2) posted by **kevinb@google.com** on 2012-11-09 at 11:44 PM_
---
As noted in other issue reports, we like the idea of improved eviction algorithms in the future, but we have a lot of work to do toward effectively measuring the impact of alternative algorithms and tuning parameters so that we have a good basis for the decisions. So this may be a little while.
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1172#c3) posted by **kevinb@google.com** on 2013-03-12 at 06:43 PM_
---
_(No comment entered for this change.)_
---
**CC:** fry@google.com
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1171) created by **tomas.zalusky** on 2012-10-16 at 02:03 PM_
---
I have an instance which is to be passed through chain of Optional.transform methods. But functions may return null and hence cannot be used in Optional.transform:
Optional.of(obj).transform(function1).transform(function2).orNull();
As Optional provides method fromNullable for construction from null, it could similarly wrap null-returning legacy functions:
&nbsp;&nbsp;class Present
&nbsp;&nbsp;...
&nbsp;&nbsp;@Override public &lt;V> Optional&lt;V> transformToNullable(Function<? super T, V> function) {
&nbsp;&nbsp;&nbsp;&nbsp;V functionResult = function.apply(reference);
&nbsp;&nbsp;&nbsp;&nbsp;return functionResult == null ? Absent.INSTANCE : new Present&lt;V>(functionResult);
&nbsp;&nbsp;}
Until now, following 2 workarounds can be used but first one scales source text badly for long chains and second one is awful abuse of iterables.
V result = null;
V1 result1 = function1.apply(obj);
if (result1 != null) {
&nbsp;&nbsp;&nbsp;&nbsp;result = function2.apply(result1);
}
V result = from(singleton(obj))
&nbsp;&nbsp;&nbsp;&nbsp;.transform(function1).filter(notNull())
&nbsp;&nbsp;&nbsp;&nbsp;.transform(function2).filter(notNull())
&nbsp;&nbsp;&nbsp;&nbsp;.first().orNull();
Thanks!
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1171#c1) posted by **lowasser@google.com** on 2012-10-16 at 03:51 PM_
---
More workarounds potentially worth mentioning:
Optional.fromNullable(function.apply(value.orNull());
Alternately, users could just write a simple transformNullable(Optional, Function) method themselves.
Should we maybe try to search within Google for potential users?
---
**Labels:** `Type-Addition`, `Package-Base`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1171#c2) posted by **kak@google.com** on 2013-08-22 at 10:50 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
**CC:** cgdecker@google.com
---
Just note: in JDK8's Optional.map the transformation of null result into empty() is automatic.
See http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/43386cc9a017/src/share/classes/java/util/Optional.java line 215
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1171#c4) posted by **jens.ran...@tink.se** on 2014-07-09 at 12:36 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1171#c5) posted by **lowasser@google.com** on 2014-07-09 at 04:19 PM_
---
In what way?  The above implementation (properly) just throws an NPE.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1160) created by **adrian.wilkins** on 2012-10-05 at 04:06 PM_
---
This patch addresses two problems ;
Firstly, version 2.4 of the maven-jar-plugin isn't compatible with m2eclipse ; see https://github.com/sonatype/m2eclipse-extras/issues/10
The patch downgrades the version to 2.3.2 as recommended in the linked issue ; this appears to have no adverse effect on the build.
Secondly, it places the manifest generated by the Felix maven-bundle-plugin into the standard META-INF folder in the root of the project. We also add this folder to the .gitignore list to prevent it being added to the tree.
This means that Eclipse can see the MANIFEST.MF file and correctly assess the OSGi metadata for the project.
This means you can now clone and import the guava project into Eclipse and use it to support debugging other OSGi bundles which depend upon it.
Without these changes, the POM file will have an error marker in Eclipse, and run configurations with the guava bundle in their plug-ins list will also have an error marker, listing it as "out of sync". Error markers are bad because they cause people to wonder what is wrong :-)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1160#c1) posted by **kevinb@google.com** on 2013-04-08 at 07:02 PM_
---
_(No comment entered for this change.)_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1160#c2) posted by **kak@google.com** on 2013-08-22 at 10:27 PM_
---
---
**Owner:** cgruber@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1160#c3) posted by **kevinb@google.com** on 2013-11-20 at 10:29 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-General`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1149) created by **alex.panchenko** on 2012-09-14 at 08:33 AM_
---
Based on the one from Scala http://www.scala-lang.org/api/current/scala/Either.html
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1149#c1) posted by **alex.panchenko** on 2012-09-14 at 08:34 AM_
---
Implementation:
public abstract class Either&lt;LEFT, RIGHT> {
```
public static <LEFT, RIGHT> Either<LEFT, RIGHT> left(LEFT value) {
return new Left<LEFT, RIGHT>(checkNotNull(value));
}
public static <LEFT, RIGHT> Either<LEFT, RIGHT> right(RIGHT value) {
return new Right<LEFT, RIGHT>(checkNotNull(value));
}
// accessed from enclosed class
Either() {
}
public abstract boolean isLeft();
public abstract boolean isRight();
public abstract LEFT left();
public abstract RIGHT right();
public abstract boolean equals(Object object);
/**
* Returns a hash code for this instance.
*/
public abstract int hashCode();
/**
* Returns a string representation for this instance. The form of this string representation is unspecified.
*/
public abstract String toString();
private static class Left<LEFT, RIGHT> extends Either<LEFT, RIGHT> {
final LEFT value;
public Left(LEFT value) {
this.value = value;
}
public boolean isLeft() {
return true;
}
public boolean isRight() {
return false;
}
public LEFT left() {
return value;
}
public RIGHT right() {
}
public boolean equals(Object object) {
if (object instanceof Left<?, ?>) {
final Left<?, ?> other = (Left<?, ?>) object;
return value.equals(other.value);
}
return false;
}
public int hashCode() {
return value.hashCode();
}
public String toString() {
return "Either.left(" + value + ")";
}
}
private static class Right<LEFT, RIGHT> extends Either<LEFT, RIGHT> {
final RIGHT value;
public Right(RIGHT value) {
this.value = value;
}
public boolean isLeft() {
return false;
}
public boolean isRight() {
return true;
}
public LEFT left() {
}
public RIGHT right() {
return value;
}
public boolean equals(Object object) {
if (object instanceof Right<?, ?>) {
final Right<?, ?> other = (Right<?, ?>) object;
return value.equals(other.value);
}
return false;
}
public int hashCode() {
return value.hashCode();
}
public String toString() {
return "Either.right(" + value + ")";
}
}
```
}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1149#c2) posted by **wasserman.louis** on 2012-09-14 at 03:05 PM_
---
This has already been discussed somewhat: https://groups.google.com/d/msg/guava-discuss/rsVLDmTtrYM/gdAr00gkpRYJ
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1149#c3) posted by **lowasser@google.com** on 2012-10-12 at 04:36 PM_
---
Can you give us an example use case, and a demonstration of what the code would look like with and without this feature?
---
**Labels:** `Package-Base`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1149#c4) posted by **alex.panchenko** on 2012-10-12 at 06:00 PM_
---
Most of the time I use it to return a success value or some error status when exceptions are not appropriate.
There are different ways to work without this feature:
a) return Object and use instanceof checks
b) return Object[2]
c) define 3 classes like here with more specific names
From one point of view it is similar to Optional, but absent() variant also has associated value. From the other point of view, it could be rejected with the same argumentation as Pair&lt;A,B> :-)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1149#c5) posted by **kevinb@google.com** on 2013-01-09 at 02:08 AM_
---
Note: Either&lt;A,B> seems to come up in this "result or failure" context way more often than anything else. One possibility is that we should address that specific use case (which somewhat resembles Future, but without the completion state or waiting thereon). Or it's possible that "Either" per se really is more generally useful, I'm just not really seeing it yet.
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1149#c6) posted by **jem.mawson** on 2013-01-17 at 08:29 PM_
---
This guy needs an Either&lt;Exception, Option&lt;T>> (he just doesn't know it): http://stackoverflow.com/questions/14387434/how-to-handle-exception-or-null-cases-uniformally-in-java
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1149#c7) posted by **alexander.kjeldaas** on 2013-01-30 at 03:53 AM_
---
I don't think this can be rejected with the same argumentation as Pair&lt;A,B> (although I am not too familiar with the argumentation).
Either&lt;Left, Right> has a precise use-case.  It is an extended Optional, where the error condition can contain some information.
It is used to convey exactly the same information as an exception would do, but it is meant to force the the immediate caller to handle the issue, unlike an exception.
Note that the names 'left' and 'right' are important, they should not be A and B.  There is _one_ right/correct value, and the other is left/error.
Wrt use-cases, my use-case looks something like this:
public interface MyFooParser {
&nbsp;&nbsp;&nbsp;&nbsp;enum PacketError { WRONG_PROTOCOL, TOO_SHORT, ALREADY_RECEIVED };
&nbsp;&nbsp;&nbsp;&nbsp;Either&lt;PacketError, Result> parsePacket(ByteBuffer packet);
}
So the last point is that a "correct" Either should force the user to use pattern matching when examining the result.
So if Left and Right were subclasses of Either, and the inheritance hierarchy closed (not open), then
http://stackoverflow.com/questions/5579309/switch-instanceof
switch (instanceof foo.parsePacket(packet)) {
&nbsp;&nbsp;&nbsp;case Left: ...
&nbsp;&nbsp;&nbsp;case Right: ...
}
would be close.
But that isn't possible, so another variant would be to make Either somehow hold an enum, like so:
Either&lt;PacketError, Result> res = foo.parsePacket(packet);
switch (res.get()) {
&nbsp;&nbsp;&nbsp;&nbsp;case LEFT : ...(..., res.left(), ...);
&nbsp;&nbsp;&nbsp;&nbsp;case RIGHT: ...(..., res.right(), ...);
}
What we want is something more like this:
switch (foo.parsePacket(packet).get()) {
&nbsp;&nbsp;&nbsp;&nbsp;case LEFT x: ...(..., x, ...);
&nbsp;&nbsp;&nbsp;&nbsp;case RIGHT x: ...(..., x, ...);
}
I don't have a solution to this, except not implementing Either until we can use lambda.
All the solutions on stackoverflow are less than ideal, because making the user actually call res.isLeft() or res.isRight() is fragile.
With lambda, we can do this:
foo.parsePacket(packet).fold(
&nbsp;&nbsp;left -> error(left),  // left is of type PacketError
&nbsp;&nbsp;right -> doSomeMoreProcessing.callBar(..., right, ...).fold(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left -> someError(left),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right -> doEvenMoreProcessing...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
The above can be done more concise by using the monad bind function:
static &lt;L,RIN, ROUT> Either&lt;L, ROUT> transform(Either&lt;L, RIN> value, {RIN => Either&lt;L, ROUT>} func) {
&nbsp;&nbsp;&nbsp;&nbsp;value.fold(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left -> return left,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right -> return func.invoke(right));
&nbsp;&nbsp;&nbsp;&nbsp;// or if (value.isLeft()) {
&nbsp;&nbsp;&nbsp;&nbsp;//       return value.left;
&nbsp;&nbsp;&nbsp;&nbsp;//    } else {
&nbsp;&nbsp;&nbsp;&nbsp;//       return func.invoke(value.right);
&nbsp;&nbsp;&nbsp;&nbsp;//    }
}
so we then write, assuming we need to do a chain of operations on something
&nbsp;&nbsp;&nbsp;&nbsp;enum Error { WRONG_PROTOCOL, TOO_SHORT, ALREADY_RECEIVED };
&nbsp;&nbsp;&nbsp;&nbsp;Either&lt;Error, Result1> parsePacket(ByteBuffer packet);
&nbsp;&nbsp;&nbsp;&nbsp;Either&lt;Error, Result2> processResult1(Result1 arg);
&nbsp;&nbsp;&nbsp;&nbsp;Either&lt;Error, Result3> processResult2(Result2 arg);
&nbsp;&nbsp;&nbsp;&nbsp;Either&lt;Error, Result> processResult3(Result3 arg);
}
Either&lt;Error, Result> res = transform(transform(transform(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foo.parsePacket(packet),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;step1 -> foo.processResult1(step1)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;step2 -> foo.processResult2(step2)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;step3 -> foo.processResult3(step3));
since Optional already has a transform method, this is equivalent to:
Optional&lt;Result> res = transform(transform(transform(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foo.parsePacket(packet),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;step1 -> foo.processResult1(step1)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;step2 -> foo.processResult2(step2)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;step3 -> foo.processResult3(step3));
but where the 'foo' interface only supports a crude error reporting.
Notice how the intermediate types do not have to match, as 'transform' composes the functions.
Some utility functions like transform2, transform3, transforms where the intermediate type is the same etc. could be created.  Bonus points if 'transform' could be made into an interface (called Monad) so that generic utilities can be written.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1149#c8) posted by **cpovirk@google.com** on 2013-01-30 at 03:54 PM_
---
Implementations of Either have appeared in three projects in Google. One copy is unused. The others are used once each, both to return either of two different types of successful results, rather than either an error or a success. The one is returning either a Widget to be inserted or a text string to be inserted with setInnerText. (At a glance, I'd say that it would be better off making the setWidget/setText call itself, rather than returning the Either instance, but maybe there's something more going on. Another option is to return a Widget in either case. There are performance implications, but if the Widget is acceptable in half of cases, it's likely acceptable in the other.) The other user is returning an Either&lt;Pair&lt;String, String>, String> with a 15-line Javadoc comment explaining the 3 possible result variants.
An Either class that supports only a value/exception choice is still something to consider. Without pattern matching, though, it has a hard time competing with plain exceptions. Maybe things will change with JDK8.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1149#c9) posted by **ferncam1** on 2013-01-31 at 12:16 AM_
---
I'm in a similar bind (no pun intended) with dns, particularly route53.
a record there can either have a target of a host list, or an alias to another record in a different zone.  subclassing is possible, but would be annoying imho.  Any ideas?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1149#c10) posted by **ferncam1** on 2013-01-31 at 01:40 AM_
---
currently sidestepping this by javadoc instructions.
&nbsp;&nbsp;&nbsp;/**
&nbsp;&nbsp;&nbsp;&nbsp;\* Type-specific data that differentiates the RRs in this set. Empty if
&nbsp;&nbsp;&nbsp;&nbsp;\* {@link #getType()} is {@link Type#A} or {@link Type#AAAA} and
&nbsp;&nbsp;&nbsp;&nbsp;\* {@link Type#getPointer} is present.
&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;public Set&lt;String> getData() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return data;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;/**
&nbsp;&nbsp;&nbsp;&nbsp;\* When present, {@link #getType()} is {@link Type#A} or {@link Type#AAAA}.
&nbsp;&nbsp;&nbsp;&nbsp;\* Instead of {@link #getData()} containing the corresponding IP addresses,
&nbsp;&nbsp;&nbsp;&nbsp;\* the server will follow this link and resolve one on-demand.
&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;public Optional&lt;Pointer> getPointer() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return pointer;
&nbsp;&nbsp;&nbsp;}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1149#c11) posted by **harshad.rj** on 2013-09-20 at 07:23 AM_
---
For those who can't wait:
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1149#c12) posted by **ceefour666** on 2013-09-20 at 07:56 AM_
---
- 1 to #11. Thanks Atlassian ! :)
Do you have foldLeft() and friends too?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1149#c13) posted by **orionllmain** on 2013-10-03 at 03:16 PM_
---
Bravo, Atlassian! It looks like Guava is in crisis now. Nothing really new was added since 10.0.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1146) created by **n...@doapps.com** on 2012-09-13 at 02:43 AM_
---
http://stackoverflow.com/questions/12380726/listenablefuture-futurecallback-and-timeouts/12396653#12396653
I was looking for a solution to solve an issue where I want to put a callback on a future but also want to impose a timeout on the future. The optimal solution would be to have the timeoutexception fire through the onFailure callback.
The SO question has a lot more context and a great answer from Chris Povirk. I think it'd be pretty useful.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1146#c1) posted by **cpovirk@google.com** on 2012-09-13 at 04:17 PM_
---
At SO, I called this "addCallback(ListenableFuture, FutureCallback, long, TimeUnit, SchededuledExecutorService)."  It's a bit of a mouthful, but it's worth considering.  To find potential users, I just reviewed the ~30 internal users of addCallback who also use TimeUnit somewhere in their code.  None of them are implementing this themselves as I thought they might be.  Still, it's possible that some of them (or some of the other callers) _should_ be using something like this.
---
**Labels:** `Type-Addition`, `Package-Concurrent`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1146#c2) posted by **cbeust** on 2012-09-30 at 01:56 AM_
---
Count me as a +1 for this feature. Because it's not supported, I am (sadly) falling back to the old way of submitting the future and calling get(with a time out) approach, which I wish I could avoid in favor of ListenableFuture.
Thanks for considering it!
##
---
I also need to do something like that. Please count me as a +1!
---
Ditto on the +1
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1146#c6) posted by **kak@google.com** on 2013-08-22 at 10:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Accepted`
**Owner:** cpovirk@google.com
---
I actually need to combine this feature with successfulAsList() so that only successful and timely futures are in the resulted list.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1146#c8) posted by **dennisyee** on 2014-01-29 at 05:03 PM_
---
Would like the feature as well, need timeout to be set. +1
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1146#c9) posted by **anrask** on 2014-02-05 at 11:13 AM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1146#c10) posted by **andrewbanks83** on 2014-04-20 at 12:24 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1146#c11) posted by **miss.mignonette** on 2014-04-25 at 01:29 PM_
---
+1 for this feature, we are still to implement a solution for this.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1146#c12) posted by **jens.ran...@tink.se** on 2014-06-23 at 02:42 PM_
---
+1 Currently using a Future to work around this.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1146#c13) posted by **karthik.moc** on 2014-08-12 at 08:15 AM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1146#c14) posted by **gentilipaolo** on 2014-09-10 at 04:06 PM_
---
due to this missing feature i switched to javarx and Observables
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1146#c15) posted by **magnus.dep** on 2014-09-30 at 07:55 AM_
---
Any updates on this?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1146#c16) posted by **cpovirk@google.com** on 2014-09-30 at 02:28 PM_
---
The makeTimeoutFuture method described at the StackOverflow link has gotten some traction inside Google. We should probably add it to Guava.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1146#c17) posted by **deepan.majmudar** on 2014-10-22 at 01:38 AM_
---
+1 for this feature. Any update on when this will be available?
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1123) created by **sheldonreedwhite** on 2012-08-28 at 07:38 PM_
---
There are valid domains that can't really be manipulated with InternetDomainName because their TLD isn't in the hard-coded TldPatterns.java class, but it's not reasonable to have to rebuild the Guava library every time a new TLD is encountered. There should be methods along the lines of addExactTld(), addUnderTld(), addExcludedTld() which would allow the user to augment (or perhaps completely override) the library's TLD set with values specific to the user's application.
Thanks in advance.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1123#c1) posted by **neveue** on 2012-08-29 at 01:21 PM_
---
I wonder if Google Chrome uses Guava to parse domain names. When I type "miele.pm" in the Chrome address bar (on an empty cache), and hit enter, it does a Google search for "miele.pm". But when I do the same for "miele.fr", Chrome detects that it's a domain name, and directly sends me to "miele.fr".
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1123#c2) posted by **kevinb@google.com** on 2012-08-29 at 03:03 PM_
---
It does not use Guava, but might use the same Public Suffix List we do.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1123#c3) posted by **wasserman.louis** on 2012-08-29 at 03:54 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1123#c4) posted by **kevinb@google.com** on 2012-10-23 at 04:50 PM_
---
Would issue 475 solve your needs?
---
**Labels:** `Package-Net`, `Type-Addition`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1115) created by **Ash2kk** on 2012-08-20 at 11:22 AM_
---
A decorator for ExecutorService that submits tasks only when their results are requested (via Future.get()).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1115#c1) posted by **Ash2kk** on 2012-08-20 at 11:33 AM_
---
My usecase: a Result object is constructed based on received Request. It consists of multiple parts - each can be calculated asynchronously so it's represented as Future&lt;PartType>. Not all parts are always required so i want to perform calculations lazily. Results objects can be reused for equal or similar requests so they are cached. But on the next request some previously unrequested parts can be needed so i cannot determine if the part is required or not when constructing Result.
---
In some cases lazy evaluation for submitted futures would be useful. Pity, there's no standard lazy executor services available.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1115#c3) posted by **cgdecker@google.com** on 2012-08-20 at 04:07 PM_
---
I'm kind of confused about this request. If you don't begin calculation until calling Future.get(), it isn't really asynchronous at all is it? It sounds like LoadingCache might be useful to you in some way, but it's not clear to me what you're doing.
---
**Labels:** `Type-Addition`, `Package-Concurrent`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1115#c4) posted by **wasserman.louis** on 2012-08-20 at 04:09 PM_
---
It's not asynchronous, but it looks like it is lazy.  That said, I'm not seeing the advantage to using any backing Executor other than MoreExecutors.sameThreadExecutor().
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1115#c5) posted by **cgdecker@google.com** on 2012-08-20 at 04:12 PM_
---
I feel like if it's not going to be asynchronous, it might as well just be something that returns Supplier&lt;PartType> or some such.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1115#c6) posted by **cpovirk@google.com** on 2012-08-20 at 05:08 PM_
---
Oops, I failed to publish this:
We've got one of these internally.  It's got a handful of uses.  We ought to review them and see whether it's the best solution for them.  I notice that about half of them are in tests.  I wonder what that's about -- in particular, whether they'd be fine with sameThreadExecutor() or a ManualExecutorService that allows them to run the tasks easily at an arbitrary time, or whether Colin's suggestion of Supplier (or maybe Callable) is more suitable.
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1115#c7) posted by **Ash2kk** on 2012-08-20 at 07:03 PM_
---
Those calculations are actually asynchronous for other threads, waiting on the same Future.
We use ExecutorService with fixed maximum number of threads to limit the concurrency - those calculations are heavy. We may use sameThreadExecutor() but should limit the maximum number of threads in that case by a Semaphore. This will lead to a broken abstraction - this limit is an implementation detail for the code. To avoid that we'll have to put that limit in some subclass/decorator of the sameThreadExecutor(). (Another feature - sameThreadExecutor(int concurrency)?).
Also we need Future's interruption semantics - we interrupt waiting threads when the Result (or a part of it) becomes irrelevant to avoid the unnecessary calculation. In out usecase it's better to free the resources and start calculations from scratch later if needed.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1115#c8) posted by **wasserman.louis** on 2012-08-20 at 07:23 PM_
---
Okay, I think I'm convinced that it's asynchronous, but I still don't think there's any point to using anything but sameThreadExecutor().
In particular, the first thread to call Future.get() for some specific future is going to be blocking for exactly as long as it takes some other thread to compute the value...so I don't see the point to a second thread, when all you're doing is doubling the number of threads that are busy for that same interval.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1115#c9) posted by **Ash2kk** on 2012-08-21 at 03:22 AM_
---
I think for our usecase sameThreadExecutor()+Semaphore would be fine, i'm not arguing about that.
I'm not sure but maybe this is a usecase of some other ExecutorService implementation: in servlet environment someone might want to interrupt all waiters (including the first one) of Future.get() but do not interrupt the calculations i.e. do not call Future.cancel(true). So the code will be able to return some result from servlet (error or some result parts that are ready) instantly and also finish the calculations.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1115#c10) posted by **Ash2kk** on 2012-10-25 at 06:15 AM_
---
Any updates on this?
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1114) created by **cemalettin.koc** on 2012-08-18 at 09:26 PM_
---
Guava is simply great. But could not find any support for annotations. The most useful example for me is Spring's AnnotationUtils [1] class.
Thanks
[1] : http://static.springsource.org/spring/docs/3.1.x/javadoc-api/org/springframework/core/annotation/AnnotationUtils.html
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1114#c1) posted by **wasserman.louis** on 2012-08-18 at 10:21 PM_
---
Are there specific things you want to do with annotations, or is this just "in general"?
---
**Labels:** -`annotation`, -`Package-Base`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1114#c2) posted by **cemalettin.koc** on 2012-08-19 at 08:54 AM_
---
Actually my intention was general but what I am finding these quite useful.
static &lt;A extends Annotation> A findAnnotation(Class<?> clazz, Class&lt;A> annotationType)
static &lt;A extends Annotation> A findAnnotation(Method method, Class&lt;A> annotationType)
static Map&lt;String,Object> getAnnotationAttributes(Annotation annotation)
It would be great to discuss the way in google how you are doing these operations too.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1114#c3) posted by **wasserman.louis** on 2012-08-20 at 08:44 PM_
---
I mean, I'm not sure what annotations we "consider inherited" or not.  That said, if we did anything along these lines...well, we already have a convenient com.google.common.annotations package.  At the moment, it only provides annotations, but doesn't consume them.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1114#c4) posted by **cpovirk@google.com** on 2012-08-20 at 08:50 PM_
---
There is the @Inherited meta-annotation, but it explicitly specifies that it applies only to superclasses, not to interfaces.  (Spring's findAnnotation method looks at implemented interfaces, too.  It doesn't appear that it takes @Inherited into account.)  @Inherited also appears to apply only to classes, not methods.  When it comes to methods, javax.inject.Inject says: "A method with no @Inject annotation that overrides a method annotated with @Inject will not be injected."
We do have very early plans for "Reflection 2.0," which would provide a nicer interface to annotations.  That should supplement our existing TypeToken.getTypes(), which already makes the supertype traversal a lot easier.
---
**Status:** `Research`
**Labels:** `Package-Reflect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1114#c5) posted by **cemalettin.koc** on 2012-08-20 at 10:04 PM_
---
You are right. It seems that creating a wide accepted library is impossible. There are some examples which are taking @Inherited into consideration optionally. But I am not not sure which way is better.
By the way, What is "Reflection 2.0". Another library or I am missing something?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1114#c6) posted by **cpovirk@google.com** on 2012-08-20 at 10:08 PM_
---
By "Reflection 2.0," I just mean a hypothetical future addition to Guava that would make reflection less clumsy.  TypeToken is a first step in this direction.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1114#c7) posted by **wasserman.louis** on 2012-08-20 at 10:10 PM_
---
"Reflection 2.0" is mostly just "the Guava team's project to update the reflection tools," if anything.
But part of the issue here is that how "annotations should be inherited" just isn't obvious -- indeed, I suspect several conflicting approaches to inheritance annotation exist, and deciding between them will be nontrivial.  Bleah.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1114#c8) posted by **cemalettin.koc** on 2012-08-20 at 10:13 PM_
---
I am sure that you will have a great job one more time.
Thanks for clarification guys. Looking forward to Reflection 2.0 :)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1114#c9) posted by **kak@google.com** on 2012-10-23 at 04:39 PM_
---
If you have a specific need for a specific use case, please let us know.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1112) created by **kostov.andrey** on 2012-08-17 at 09:05 PM_
---
Hello,
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1112#c1) posted by **wasserman.louis** on 2012-08-17 at 09:07 PM_
---
Makes sense to me; +1.  (I'm willing to do the work.)
---
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1112#c2) posted by **kevinb@google.com** on 2012-08-18 at 06:25 AM_
---
Does stats on/off really represent a tuning parameter?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1112#c3) posted by **kostov.andrey** on 2012-08-18 at 08:50 AM_
---
Well it makes sense to turn it on when changing cache parameters. After tuning a cache, you would want to observe its performance.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1112#c4) posted by **kevinb@google.com** on 2012-08-21 at 04:47 AM_
---
Well, you have to make some code change anyway so as to actually call stats() and _do something_ with those stats, so why not call recordStats() too and then just leave it all that way?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1112#c5) posted by **wasserman.louis** on 2012-08-21 at 05:18 AM_
---
That's...not necessarily true.  You could leave the stats() call whether you use recordStats() or not, and store the cache configuration in a file somewhere; if you don't use recordStats(), you'll still _get_ a CacheStats object -- it'll just be all zeros.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1112#c6) posted by **kostov.andrey** on 2012-08-21 at 05:25 AM_
---
No, I don't have to make any more changes. I just allow users to re-build a cache via a string and view the stats of that cache. However, allowing them to view the stats is useless if they can't actually ask the cache to record stats. Also asking me why I do not always enable recordStats() is equivalent to me asking why are they not always enabled for all guava caches in general.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1112#c7) posted by **kostov.andrey** on 2012-08-21 at 05:26 AM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1112#c8) posted by **kak@google.com** on 2012-10-23 at 04:36 PM_
---
We would not be willing to do this unless disabled CacheStats are distinguishable from enabled CacheStats (currently disabled CacheStats return all 0's).
---
**Blocked On:** #1054
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1112#c9) posted by **kevinb@google.com** on 2012-10-23 at 04:39 PM_
---
We would also like to hear how many users have this need.  How many caches do you have where the cost of recording stats is prohibitive but you need the ability to turn it on with a code change?
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1112#c10) posted by **kevinb@google.com** on 2013-03-12 at 06:43 PM_
---
_(No comment entered for this change.)_
---
**CC:** fry@google.com
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1111) created by **brianfromoregon** on 2012-08-16 at 05:07 PM_
---
Consider having ByteStreams#readFully overloads throw a specialized EOFException which contains the #bytes read before EOF.
My use case:
I'm reading messages of known length. If I can only read a partial message before EOF I want to debug-level log the partial message as a UTF8 string. I cannot do this today using the readFully overloads because they don't tell me how many bytes were actually read.
The workaround is simple; use the #read method instead. But I wanted to suggest it anyway because if I could use #readFully methods I would.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1111#c1) posted by **brianfromoregon** on 2012-08-16 at 05:20 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1111#c2) posted by **brianfromoregon** on 2012-08-16 at 05:23 PM_
---
That said, there's no denying that I'm on my way.
2. ???
3. World domination!
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1111#c3) posted by **cpovirk@google.com** on 2012-08-16 at 05:39 PM_
---
Is this an accurate before-and-after picture?
int read = in.read(bytes);
if (read != bytes.length) {
&nbsp;&nbsp;throw new CorruptedFileException(copyOrRange(bytes, 0, read));
}
try {
&nbsp;&nbsp;ByteStreams.readFully(in, bytes);
} catch (InsufficientDataRemainingException e) {
}
Attaching data to exceptions is probably an underused technique in general, so I kind of like that aspect.  It will be tough to justify a new public class just for this, though.
---
**Labels:** `Package-IO`, `Type-Addition`
---
Note that the aforementioned simple workaround is wrong: There's no guarantee that the read method doesn't give up before filling the buffer without hitting EOF. At least that's my understanding of `InputStream.read(byte[])`.
I had a similar problem and wrote an int-returning method "readAsMuchAsPossible". Note that using it, `readFully`&nbsp;(and also `InsufficientDataRemainingException`) can trivially be implemented, but not the other way round.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1111#c5) posted by **cpovirk@google.com** on 2012-08-17 at 09:37 PM_
---
Yeah, I had been worried about that.  But then I saw that the implementation of ByteStreams.readFully is:
```
if (read(in, b, off, len) != len) {
}
```
I expected to see something more like skipFully's loop.
I'm not sure how to interpret the documentation of InputStream.read, but it certainly seems open to your interpretation: http://docs.oracle.com/javase/6/docs/api/java/io/InputStream.html#read%28byte[]%29
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1111#c6) posted by **wasserman.louis** on 2012-08-17 at 09:49 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1111#c7) posted by **brianfromoregon** on 2012-08-17 at 11:27 PM_
---
No bugs here, both the workaround I mentioned and the readFully impl are referencing ByteStreams#read not InputStream#read. ByteStreams#read calls InputStream#read in a loop.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1111#c8) posted by **cpovirk@google.com** on 2012-08-18 at 03:51 AM_
---
Oops.  Thanks for the correction.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1111#c9) posted by **lowasser@google.com** on 2012-10-23 at 04:28 PM_
---
We're going to add some more detail to the error message, but if you care about this, you should really be using read, not readFully.
The reasoning is that if your application is supposed to do something reasonable in the presence of partial results -- if you can tolerate input that doesn't fill up the byte array -- then you really shouldn't be using readFully in the first place; you should be using read.
---
**Status:** `Accepted`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1110) created by **chirino** on 2012-08-15 at 09:27 PM_
---
LFU based evictions are sometimes a better option than LRU evictions.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1110#c1) posted by **wasserman.louis** on 2012-08-15 at 09:46 PM_
---
I'm having difficulty thinking of an actually efficient way to support that?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1110#c2) posted by **chirino** on 2012-08-16 at 12:58 AM_
---
Perhaps this paper can supply some inspiration:
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1110#c3) posted by **wasserman.louis** on 2012-08-20 at 08:42 PM_
---
...We may investigate this.  That said, CacheBuilder does not specify its eviction ordering, and leaves it open for implementations to decide: "As the cache size grows close to the maximum, the cache evicts entries that are less likely to be used again. For example, the cache may evict an entry because it hasn't been used recently or very often."
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1110#c4) posted by **kak@google.com** on 2012-10-23 at 04:16 PM_
---
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1110#c5) posted by **kevinb@google.com** on 2012-10-23 at 04:19 PM_
---
(That note is just to explain why we won't be getting to this for a little while.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1110#c6) posted by **anthony.musyoki** on 2012-10-24 at 07:01 AM_
---
Maybe the below would speed up the research.
https://tech.dropbox.com/2012/10/caching-in-theory-and-practice/
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1110#c7) posted by **kevinb@google.com** on 2012-10-24 at 09:06 PM_
---
Awesome, thank you.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1110#c8) posted by **kevinb@google.com** on 2013-03-12 at 06:43 PM_
---
_(No comment entered for this change.)_
---
**CC:** fry@google.com
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1095) created by **gerd.riesselmann** on 2012-08-03 at 08:46 PM_
---
I get the following error when using the 13.0 jar from Maven repositories against Scala 2.9.2:
error while loading Cache, Missing dependency 'class javax.annotation.Nullable', required by ..../scala_2.9.2/compile/guava-13.0.jar(com/google/common/cache/Cache.class)
It works with 12.0.1
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1095#c1) posted by **cpovirk@google.com** on 2012-08-03 at 08:52 PM_
---
See this thread for some discussion:
Scala requires annotation classes to be present, contrary to the way they were designed.
"This is due to the Scala compiler, which needs all of the artifacts left in the byte-code."
"I was able to work around the problem by adding "com.google.code.findbugs" % "jsr305" % "1.3.+" in my list of dependencies."
---
**Status:** `WorkingAsIntended`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1093) created by **ogregoire** on 2012-08-02 at 10:46 PM_
---
My CacheLoader calls a ResourceLoader which is provided by my API users. That ResourceLoader may throw a ResourceException. If such an exception occurs, it's wrapped into an ExecutionException by the LoadingCache. However my ResourceCache should only throw a ResourceException.
So I would like to catch the ExecutionException that LoadingCache may throw and reuse the ResourceException in order to not wrap it again (so avoiding "ResourceException caused by ExecutionException caused by ResourceException").
What specific use case does this fill? Well, it's when:
- I _know_ that I use an API
- I _know_ that API may throw a specific Exception under specific circumstances
- I _know_ that the caught Exception is only wrapper exception and that my actual exception is somewhere in the cause list.
- I want to unwrap the cause to hide my implementation
So typically, I would like to remove the responsibility of this code:
try {
&nbsp;&nbsp;...
} catch (ExecutionException e) {
&nbsp;&nbsp;for (Throwable t = e; t != null; t = t.getCause()) {
&nbsp;&nbsp;&nbsp;&nbsp;Throwables.propagateIfInstanceOf(t, ResourceException.class);
&nbsp;&nbsp;}
&nbsp;&nbsp;// Handle cases where ExecutionException contains another type of exception.
}
And ideally, I would have to write this code:
try {
&nbsp;&nbsp;...
} catch (ExecutionException e) {
&nbsp;&nbsp;Throwables.propagateFirstCauseInstanceOf(e, ResourceException.class);
&nbsp;&nbsp;// Handle cases where ExecutionException contains another type of exception.
}
In my specific use case, why not using Throwables.propagateIfInstanceOf(e.getCause(), ResourceException.class)?
Well actually I am using this piece of code and I don't plan to change it, but I thought of a more wide use case than the one I'm currently facing: when an Exception is double- or triple-wrapped.
Thanks for considering.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1093#c1) posted by **cpovirk@google.com** on 2012-08-02 at 11:09 PM_
---
There's one other relevant point that I like to harp on: When you rethrow a wrapped exception, you may be rethrowing an exception from another thread.  Its stack trace will no longer match the stack trace of the current thread.  This can be confusing.  (This I _have_ seen cause real problems.)
In the particular case of LoadingCache, the exception is _probably_ from the same thread but not necessarily, since concurrent requests for the same key will be "merged," with one thread performing the work and the others blocking.  Arguably this is the worst possible case for a a misleading stack trace, since the trace will _look_ right.
For this reason, I've been pushing for an approach like Futures.get, where you create a new wrapper exception of the appropriate type.  I know that a lot of people dislike deep exception chains, and I've seen some terribly unnecessarily deep chains before, and of course I've already admitted that the unwrapping is often unnecessary in this case.  But I think that, overall, exception chaining is a pretty useful thing, particularly when crossing threads, and I'm hesitant to add utilities that discourage it.
At that point, we're looking at a try-catch with the same code as your snippet except that...
Throwables.propagateIfInstanceOf(e.getCause(), ResourceException.class)
...becomes...
&nbsp;&nbsp;throw new ResourceException(e.getCause());
}
...or sometimes just...
throw new ResourceException(e.getCause());
That's getting to be kind of a pain, and it's partly for this reason that I think it would be nice to have better exception transparency in LoadingCache (as you noted).  It would probably look somewhat like your suggestion and somewhat like Futures.get.  This hasn't been a priority for our cache work yet, but it's at least something we have in mind.  One possibility is that the future AsyncLoadingCache will "solve" the problem by returning a Future to you, at which point you can use Futures.get, assuming that it's appropriate.
Sorry for the disorganized brain dump.
https://google.github.io/guava/apidocs/com/google/common/util/concurrent/Futures.html#get(java.util.concurrent.Future,%20java.lang.Class)
---
**Status:** `Research`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1090) created by **ishaaq** on 2012-07-31 at 02:57 AM_
---
Is it possible to create a Concurrent version of BloomFilter?
1. Ability for multiple threads to call put() simultaneously without blocking
2. A put(x) will ensure that all mightContain(x) calls that occur _after_ it will return true
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1090#c1) posted by **wasserman.louis** on 2012-07-31 at 10:45 AM_
---
I was thinking that an AtomicLongArray-based variant should work pretty smoothly here, but I'm not positive I've thought through all the issues. (Also, this seems like another instance in which a ProbabilisticSet interface might be appropriate.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1090#c2) posted by **kurt.kluever** on 2012-08-07 at 05:32 PM_
---
Can you describe your use-case a bit more? This sounds like a reasonable request.
---
**Status:** `Research`
**Owner:** andreou@google.com
**Labels:** `Package-Hash`, `Type-Enhancement`
**CC:** kak@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1090#c3) posted by **ishaaq** on 2012-08-08 at 06:56 AM_
---
Hmm, not sure how much more to elaborate than what I initially suggested.
Point 2 in my requirements above is no different from what is expected from a bloom filter anyway, so nothing new there.
Point 1 is basically allowing multiple threads to do simultaneous non-blocking put calls - ideally using atomic CAS (Compare And Swap) operations and not resorting to lock synchronisation.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1090#c4) posted by **wasserman.louis** on 2012-08-09 at 04:31 PM_
---
By "describe your use case," we mean "tell us _why_ you need a concurrent Bloom filter in the first place."
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1090#c5) posted by **ishaaq** on 2012-08-10 at 09:34 AM_
---
Right, sorry about the confusion.
I have a resource that multiple threads simultaneously read from and write records to. Writes are inexpensive but reads are not.
The most expensive use-case for this resource is for a reader to ask for a record that does not exist. I can reduce this load significantly by protecting the resource with a bloom filter, i.e. the readers only go on to retrieve the record if the bloom filter indicates that the record probably exists. Obviously, for this to work, the writers need to write to the bloom filter before writing to the resource.
Implementing synchronized locking around the bloom filter would lead to to excessive contention, a CAS-based solution would be perfect - allowing both readers and writers to access the bloom-filter simultaneously.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1090#c6) posted by **nto...@maginatics.com** on 2012-08-10 at 04:37 PM_
---
FWIW, we also have a use case that is similar to the one described above. We have a number of threads that insert new data into an underlying database but work very hard to prevent duplicate entries. Currently, this involves an expensive round-trip to the database to lookup if entries exist but we would like to abort early in case we know the entry is not present. Of course, all worker threads would want to update the bloom filter once they have insert a new entry.
As a side note, in this proposed use of a ConcurrentBloomFilter, it could be possible for a duplicate to occur but, as long as it is not common, a few duplicates would be fine and would be handled by other means in our system.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1090#c7) posted by **andreou@google.com** on 2012-08-10 at 05:44 PM_
---
I'd suggest to try synchronization first, and see what kind of contention you get.
Worst case, you can stripe the bloomfilter and reduce contention accordingly: List&lt;BloomFilter&lt;E>>, and do:
BloomFilter&lt;E> bf = list.get(IntMath.mod(e.getHashCode(), bfs.size());
synchronized (bf) {
&nbsp;&nbsp;bf.put(e);
}
This could also be modeled as a Striped&lt;BloomFilter&lt;E>>, if we ever opened Striped up, accepting an arbitrary Supplier&lt;L>, instead of just the three types it supports now.
(I say this because implementing special concurrent versions of each structure as needed is too much work!)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1090#c8) posted by **mjohns...@capsaicin.ca** on 2013-01-10 at 02:29 PM_
---
I'm also interested in a version supporting concurrent puts. My use case is one where I have a bunch of threads processing inputs and updating a single bloom filter. Alternatively if multiple blooms could be merged, that would allow me to update ThreadLocal blooms and merge each of them in a batch.
My use case does not require feedback as to whether or not the put modified the filter, in case that simplifies things.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1090#c9) posted by **argaul** on 2013-01-10 at 05:10 PM_
---
Issue #1134 tracks merging Bloom filters of the same size:
https://github.com/google/guava/issues/1134
Dupe of #2761 that we've now done.  _[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1089) created by **eric.dalquist** on 2012-07-29 at 09:08 PM_
---
The attached class is useful to track a rate over time. Client code calls count() each time the tracked event occurs. The class uses a bucket based approach to reduce memory overhead. Any time span (1 second, 33 minutes, etc) can be used. The class is thread safe and minimizes locking to only the point in time when a new bucket needs to be created.
I'm more than willing to refactor the class based on feedback if that would be required before consideration.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1089#c1) posted by **wasserman.louis** on 2012-07-30 at 09:48 AM_
---
As a general rule, we'd like to discuss the API before looking at code.  With that in mind, did you have a specific use case that made you want this feature?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1089#c2) posted by **eric.dalquist** on 2012-07-30 at 12:23 PM_
---
The high level requirement is a utility class to track the rate of some event happening over a short time window for statistics purposes. For example being able to track messages per second and retrieve that information for use in monitoring tools.
The API side requirements are:
1. The ability to create a rate tracking class that covers a specific period of time. EG: (1, TimeUnit.SECOND) or (3, TimeUnit.MINUTE)
2. The ability to count occurrences of the tracked event as they happen
3. The ability to query the current rate at any point in time.
4. The class must be thread-safe and preferably block as little as possible.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1089#c3) posted by **toellrich** on 2012-07-30 at 12:31 PM_
---
This seems to overlap with Coda Hale's excellent metrics library:
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1089#c4) posted by **eric.dalquist** on 2012-07-30 at 12:35 PM_
---
I would say that meets my requirements. Thanks for the pointer to the great library and feel free to close this feature request. :)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1089#c5) posted by **wasserman.louis** on 2012-07-30 at 12:40 PM_
---
I like it!  Though I'm a little bit surprised that it doesn't use something like Doug Lea's LongAdder (http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/LongAdder.html) rather than AtomicLong.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1089#c6) posted by **kurt.kluever** on 2012-08-07 at 05:35 PM_
---
We have something similar to this called RateObserver which may suit your needs.
---
**Labels:** `Package-Concurrent`
**CC:** andreou@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1089#c7) posted by **andreou@google.com** on 2012-08-07 at 05:50 PM_
---
So RateObserver is about the best we can do with O(1) memory, compared to moving windows which have to keep a queue of events around, but it does have the drawback that it is harder to explain. That uses exponential averaging; past events are exponentially discounted towards reporting the current average (rate), with some exponent in [0..1]. This has only recently ported to the internal common libs so it's not really tried out yet
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1081) created by **gak@google.com** on 2012-07-24 at 06:01 PM_
---
See summary.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1081#c1) posted by **kurt.kluever** on 2012-07-24 at 06:12 PM_
---
Or have an asPredicate() instance method.
---
**CC:** andreou@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1081#c2) posted by **kurt.kluever** on 2012-07-24 at 06:41 PM_
---
_Issue #1058 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1081#c3) posted by **kurt.kluever** on 2012-07-24 at 06:46 PM_
---
Now that I think about it, I have a slight prefer to asPredicate instead of implementing Predicate. The OP wanted an immutable BloomFilter...passing around a BloomFilter instance (and having people only call apply()) won't prevent them from calling put(), so really we should let them view the BloomFilter as a Predicate. Then they can safely pass/expose a Predicate&lt;E> and maintain immutability.
Let me know if you disagree.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1081#c4) posted by **cpovirk@google.com** on 2012-07-24 at 06:56 PM_
---
---------- Forwarded message ----------
From: Kevin Bourrillion &lt;kevinb@google.com>
Date: Fri, Jun 24, 2011 at 5:58 PM
On Thu, Jun 23, 2011 at 12:23 PM, Dimitris Andreou &lt;andreou@google.com> wrote:
> sure I can get used to that. I suspect you are not very sure about this either,
> right?
>
> I guess the reason that I'm not sure about it is that a BloomFilter, if someone
> good name, users can quickly get what this means even without having seen a
> Bloom filter before.
Glad you bring this up; we should discuss it.  We don't want something to implement Predicate if it's sufficiently ambiguous what it means when used as a Predicate. I thought "this case is not ambiguous because there's only one boolean operation a bloom filter does."  But yeah, that operation itself has such subtlety to it, so there's that.
What prompted me to do it: I made a "BloomFilters.screen(Predicate, BloomFilter)" utility method, that takes a (presumably expensive) predicate and a bloom filter to which every "matching" element has been added; it would return a very fast predicate that's functionality equivalent to the input predicate. Then, I realized I was reimplementing exactly Predicates.and().  Upon reflection, if this is the only advantage of having BF implement Predicate, it's not enough.  And we probably ought to have such a screen() method anyway, because "Predicates.and(filter, expensivePredicate)" is not very intention-revealing.
I'll just back this out.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1081#c5) posted by **wasserman.louis** on 2012-07-25 at 07:59 AM_
---
Hrrrrm. I'm sort of liking the approach of just a BloomFilter.screen(Predicate) method?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1081#c6) posted by **kak@google.com** on 2012-07-25 at 08:08 AM_
---
Unless I'm misunderstanding, screen() doesn't help us get an unmodifiable view or immutable BF (which is what the OP wanted). If BF implemented Predicate (which is another option we're discussing), then screen() would be an additional, unrelated operation we might consider adding (but I'm not sure how common that operation would be).
I'm still +1 on the asPredicate() view, but we'll discuss this at API review on Thursday.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1081#c7) posted by **em...@soldal.org** on 2012-07-25 at 08:09 AM_
---
I would like a predicate view of BloomFilter so I can take a collection of elements and use a filter method to get the candidates worth looking up in the database.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1081#c8) posted by **gak@google.com** on 2012-07-25 at 04:29 PM_
---
As I stated offline, if we want an unmodifiable view of a BF, we should just make an unmodifiable view of a BF.  I don't think that an unmodifiable view of a _single_ method which retains none of the BF context is sufficient.
Side note: BF.copy() makes defensive copying really easy.
I think that the predicate view should be judged more on the merits of the use cases that Louis and Emily describe.
IMO, I'd rather write:
ImmutableSet&lt;Element> possibleElements = someFluentIterable.filter(bloomFilter).toImmutableSet();
ImmutableSet&lt;Element> possibleElements = someFluentIterable.filter(bloomFilter.asPredicate()).toImmutableSet();
But obviously there's not a huge difference here.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1081#c9) posted by **argaul** on 2012-07-25 at 04:34 PM_
---
Either BloomFilter implementing Predicate or having an asPredicate view works for me.  I have several of these filters which I ultimately combine using Predicates.or().
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1081#c10) posted by **wasserman.louis** on 2012-07-26 at 09:33 AM_
---
Hmmmmm.  I argue the following: screen is usually what you want to do with a BloomFilter, just because it's usually used as a "first pass."  But in the rarer case that you want an asPredicate view, that's equivalent to screen(Predicates.alwaysTrue()).
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1075) created by **wasserman.louis** on 2012-07-19 at 10:20 AM_
---
I'm making an issue for this to be discussed, though I don't expect it to happen particularly soon.
In particular, I'm curious if users have encountered a need for this that can't be satisfied with CharMatcher alone.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1075#c1) posted by **kurt.kluever** on 2012-07-24 at 05:17 PM_
---
We've got a bunch of advice from the i18n team internally to take into consideration too.
---
**Status:** `Accepted`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1073) created by **electrum** on 2012-07-19 at 12:27 AM_
---
Please add @ SafeVarargs to things like ImmutableSet.of().
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1073#c1) posted by **kevinb@google.com** on 2012-07-19 at 05:49 AM_
---
You can be sure we've been eager to do so, but AFAIK we can't until we are ready to _require_ JDK 1.7.  Given all the trouble that it's caused when we recently started requiring 1.6, I expect this will be at least Guava 19.0 or so.
---
**Status:** `Accepted`
**Labels:** `Package-General`, `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1073#c2) posted by **electrum** on 2012-07-19 at 06:47 AM_
---
Wouldn't this only require 1.7 for compiling? The annotation should be ignored if the annotation definition is not available.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1073#c3) posted by **em...@soldal.org** on 2012-07-19 at 06:50 AM_
---
Unfortunately (or fortunately depending on how you look at it), the annotation is itself annotated with
@Retention(value=RUNTIME)
So it will be required at run time; you will get a ClassNotFound exception.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1073#c4) posted by **wasserman.louis** on 2012-07-19 at 09:58 AM_
---
Ew.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1073#c5) posted by **kevinb@google.com** on 2012-07-19 at 03:15 PM_
---
That was just a testing technique.
And re #2, if you can come up with some hackery that allows building with 1.7 yet being deployable on 1.6, while having those same .class files actually _work_ for @SafeVarargsness, and also properly fails if any _other_ 1.7isms  get used.... let us know, but this is seeming farfetched to me.
The Java folks could have decided to support safe-varargs with something like @SuppressWarnings("SafeVarargs"), an _existing_ annotation, but they did not, so here we are.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1071) created by **drothmaler** on 2012-07-17 at 03:10 PM_
---
It would be nice to have a FluentIterable equivalent to the Iterables.getOnlyElement methods...
I recognized that there once was a "getOnlyElement" method in FluentIterable, but it has been removed in rev 323b48157718 - but i couldn't find any reason why.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1071#c1) posted by **kurt.kluever** on 2012-07-24 at 05:27 PM_
---
Also bringing this up at API review this week. Most likely will get renamed to "onlyElement()".
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1071#c2) posted by **wasserman.louis** on 2012-08-16 at 09:02 PM_
---
Any results from that discussion, Kurt?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1071#c3) posted by **kurt.kluever** on 2012-08-16 at 09:09 PM_
---
Ahh, yep...here were some concerns about it:
-Currently named getOnlyElement
-Currently throws an IAE when theres >1 element; should be ISE? UOE?  Kurt + Greg voted for ISE
-Kevin seems to be the source of 80% of the worry here so its on him to write up the status of the problem - one thing hell do is some deep analysis on existing users
Based on that last bullet, kicking this over to Kevin :-)
---
**Owner:** kevinb@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1071#c4) posted by **kevinb@google.com** on 2012-08-16 at 10:40 PM_
---
I have angst over this method and its Iterables cousin because they fundamentally want to be the combination of getFirst plus an _assertion._
If you run with assertions disabled you'd expect to not waste time doing extra checks like this.  So, what then: do we just implement it with assert?  But then that assert can only be turned on and off globally, not based on client package.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1071#c5) posted by **wasserman.louis** on 2012-08-17 at 12:49 AM_
---
I'm morally comfortable with treating these as a precondition to validate, not just an assertion?  Eh.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1071#c6) posted by **lowasser@google.com** on 2013-09-25 at 07:46 PM_
---
_Issue #1544 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1071#c7) posted by **lowasser@google.com** on 2013-09-25 at 07:46 PM_
---
_Issue #1544 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1071#c8) posted by **phwendler** on 2014-04-07 at 06:02 AM_
---
I see no problem having the cost of this extra check in this method. Users that do not want to pay the extra cost can still use first() instead. In fact, I in my opinion the whole point of onlyElement() is to have this check, and I would use this method precisely because of this check, so I would never want it off.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1070) created by **drothmaler** on 2012-07-17 at 03:04 PM_
---
I think it would be nice to be able to create a FluentIterable from an array directly, with a factory method like this:
FluentIterable.from(E... elements) or FluentIterable.from(E[] elements)
This could simply call Arrays.asList(elements) internally, as I am doing now explicitly on the outside.
It is very usefull for working with legacy code or other APIs returning arrays.
Also it feels to be consistent, as there is a "toArray" method; so it would be a logical consequence to provide a from(Array) factory method also.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1070#c1) posted by **kurt.kluever** on 2012-07-24 at 05:29 PM_
---
Again, will put on the API review this week.
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1070#c2) posted by **j...@nwsnet.de** on 2012-07-31 at 10:35 AM_
---
Yes, I'd like to see such an overload, too.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1070#c3) posted by **drothmaler** on 2012-08-21 at 08:52 PM_
---
Are there any news on this, kurt?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1070#c4) posted by **kurt.kluever** on 2012-08-21 at 08:56 PM_
---
FluentIterable.from(E...) or (E[])
Issues:
Why not just use asList(E...)?  Thats been our go-to pushback argument for varargs and array-accepting overloads
Lots of users are using from(Enum.values())
Punting over to Greg...
---
**Owner:** gak@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1070#c5) posted by **gak@google.com** on 2012-08-21 at 09:06 PM_
---
I'm ambivalent.  I'll put it on the docket for our weekly discussion.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1070#c6) posted by **gak@google.com** on 2012-08-21 at 09:17 PM_
---
Oh, wait.  No.  I'm not.  :-)
I occasionally get lured into thinking that varargs makes sense here, but it really doesn't.  It's rare that you have a fixed set of elements that start a fluent chain of invocation since it's much more likely that the properties of those elements are known.  Immutable*.of() are great for tests, but it'd be pretty strange to define test data as a FI.
As for the "working with legacy code" side of it, the clarity that comes from explicitly creating an immutable copy or a list view is quite valuable and encouraging callers to perform that operation as early as possible seems like a good thing too.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1070#c7) posted by **j...@nwsnet.de** on 2013-07-10 at 08:32 AM_
---
Aside from `Enum.values()`, the reflection-related methods on class (`getMethods()`, `getAnnotations()`&nbsp;etc.) return arrays, and using `FluentIterable`&nbsp;to filter for specific elements helps here. Thus, `FluentIterable.from(E...)`&nbsp;would make things more concise.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1070#c8) posted by **gak@google.com** on 2013-07-10 at 05:39 PM_
---
I don't think that there's any disagreement that a method that accepts an array would be more concise for callers that are holding a reference to an array.  Whether that is a sufficient benefit over forcing callers to explicitly copy or wrap that array is the question.
FluentIterable.from(Arrays.asList(clazz.getDeclaredMethods()))
vs
FluentIterable.from(clazz.getDeclaredMethods())
or
FluentIterable.from(EnumSet.allOf(SomeEnum.class))
vs
FluentIterable.from(SomeEnum.values())
The second versions are definitely more concise, but the cost is pretty minimal considering that the available adapters are pretty succinct.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1070#c9) posted by **lowasser@google.com** on 2014-04-30 at 04:58 PM_
---
_Issue #1741 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1070#c10) posted by **lhun...@lyndir.com** on 2014-04-30 at 05:14 PM_
---
I understand there are alternative methods of achieving the same thing; though this change implies only a very minimal addition, is there a downside that is holding up this bug?  Perhaps some form of discouraging array usage? (though it is not always a choice and varargs do have their benefits)
It seems only natural to me for this type of utility to accept both Iterables and Arrays as its purpose is mainly to iterate, and thus seems very in-line with the for construct.  For arrays to not be supported almost feels like an inconsistency.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1070#c11) posted by **cgdecker@google.com** on 2014-10-06 at 02:21 AM_
---
FluentIterable.of(E[]) was added in 18.0.
---
**Status:** `Fixed`
**Labels:** `Milestone-Release18`
Reopening and retitling this to reflect where the discussion has gone.
No, wait. We already have an issue for varargs: #2136.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1067) created by **tomaszpancho** on 2012-07-14 at 11:58 AM_
---
By changing signatures of BloomFilter.create methods (and few others), and by modifying constructor of BitArray, we can easily extend maximum BF's capacity . I.e. for BF with 0.01 false positives probability, maximum expected insertions grows from Integer.MAX_VALUE to 137438953404 (about 6.5 times).
I proposed changes at (tests included):
and
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1067#c1) posted by **wasserman.louis** on 2012-07-14 at 12:07 PM_
---
Is there a particular reason you want to do this?  Do you actually expect more than 2 billion insertions?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1067#c2) posted by **wasserman.louis** on 2012-07-14 at 12:39 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Milestone-Release13`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1067#c5) posted by **tomaszpancho** on 2012-07-14 at 01:10 PM_
---
I've already used it with 6.5 billion insertions, to compare 2 huge lists of files.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1067#c6) posted by **wasserman.louis** on 2012-07-14 at 01:30 PM_
---
Huh, okay.  ...Cool.  Dimitri, how do you feel about this change?
---
**Owner:** andreou@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1067#c7) posted by **kurt.kluever** on 2012-07-24 at 05:36 PM_
---
This would be a significant change to the underlying data structures of the existing bloom filter.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1067#c8) posted by **andreou@google.com** on 2012-07-24 at 06:02 PM_
---
I very much agree with this. I wondered a couple of weeks back how come nobody complains that we reduce the maximum size by a factor of 64, and assumed that this is too large for anyone to care.
(I would probably use more compact algorithms to compare such huge lists though, perhaps a big simhash? But anyway)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1067#c9) posted by **tomaszpancho** on 2012-07-24 at 09:13 PM_
---
Thanks for the simhash, but my task was rather simple : to find files names from one list that weren't on the other.
As to the significant change to the underlying data structures, it could be done  without touching underlying long[](in BitArray), so that modification is really small. You can check changes at my repo.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1067#c10) posted by **andreou@google.com** on 2012-07-24 at 09:24 PM_
---
Yes, I understand that, I guess Kurt thought this would go beyond the limits of our long[](but we'll be throwing an exception).
There _will_ be some subtle change though, hopefully for good: previously, when you ask for impossible requirements, BF would just limit itself to Integer.MAX_VALUE bits, giving you back something with worse fpr expectations. Now exceeding the limit would throw an exception.
My concern is whether this will reduce users who hit such large use cases, to trial-and-error, in order to find parameters that don't throw the exception (or we would need to expose more api to compute such parameters, meh, dunno, will get some feedback from the rest of the team)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1067#c11) posted by **tomaszpancho** on 2012-10-15 at 06:28 PM_
---
I'm sorry but the modified version of BF is not working. It gives far more false positives than it should when expected insertions are greater than Integer.MAX_VALUE. It looks like there's more to be done.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1067#c12) posted by **andreou@google.com** on 2012-10-15 at 07:30 PM_
---
Yes, we know, have a look at https://github.com/google/guava/issues/1119 sorry about that
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1067#c13) posted by **jim.andreou** on 2012-10-25 at 01:54 AM_
---
Oops, seems I totally, totally misunderstood the problem here.
What happens here is that you provide, when invoking create(), an expectedInsertions which is still an int.
So, while Kurt is doing some internal work to allow for huge BFs that could deal with, say, 6.5 billions insertions, the current API doesn't allow stating expectations as high. You can still only specify up to Integer.MAX_VALUE, and that's what the BF prepares for, so when you exceed it by 3x, of course you'll get a terrible fpp (not even 3x the fpp, but much higher).
Kevin, is it a problem if we widen the expectedInsertions parameter to a long? It's still @Beta, so the minor recompilation issue shouldn't be a problem...
---
**CC:** kevinb@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1067#c14) posted by **andreou@google.com** on 2012-10-25 at 02:02 AM_
---
By the way, there is a poor-man's workaround while we're dealing with this. When you reach Integer.MAX_VALUE, introduce another BF, and again. You would need about 4 BFs in total...
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1067#c15) posted by **kevinb@google.com** on 2012-10-25 at 03:51 AM_
---
I have no particular objection to going long with that parameter.  How
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1067#c16) posted by **stephan202** on 2012-10-25 at 07:25 AM_
---
int-sighted ;)
727f62163b685f720a8c001532271f648e250fa2
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1064) created by **adam.g...@evocatus.com** on 2012-07-12 at 01:55 PM_
---
I would love to have a Joiner have the ability to prefix and suffix elements.
IE something like: Joiner.on(",").prefix("'").suffix("'").join(1,2,3);
Would make:
'1','2','3'
I have needed this for IN clauses for SQL and various other things.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c1) posted by **adam.g...@evocatus.com** on 2012-07-12 at 01:56 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c2) posted by **cpovirk@google.com** on 2012-07-12 at 02:04 PM_
---
Prefix and suffix seem to be mostly about quoting, whether in SQL, CSV, or something else.  Since proper quoting requires escaping, we'd probably go a step further than this to something like issue 412 or issue 813.  For the moment, you may want to use Iterables.transform() on the input elements.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c3) posted by **wasserman.louis** on 2012-07-12 at 02:17 PM_
---
@cpovirk: I'm not entirely convinced by that argument, just because...most Guava-internal uses of Joiner are for toString() implementations, and those add varying brackets and the like.  No escaping required.
This isn't a +1, mind...but the idea is kind of tempting.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c4) posted by **wasserman.louis** on 2012-07-12 at 02:17 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Enhancement`, `Package-Base`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c5) posted by **adam.g...@evocatus.com** on 2012-07-12 at 03:04 PM_
---
@cpovirk ... Truthfully I am using it for a crappy SQL prototype of which I know the values are safe but I have needed it some times for just messaging.
Maybe what I really need is an AbstractJoiner that I can extend.
public abstract class AbstractJoiner&lt;J> {
&nbsp;&nbsp;....
&nbsp;&nbsp;//for fluent
&nbsp;&nbsp;protected abstract J getSelf();
}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c6) posted by **wasserman.louis** on 2012-07-12 at 03:07 PM_
---
At the moment, we have thread-safety and immutability guarantees for Joiner that are really nice.  You can _always_ put a Joiner in a static final constant field.
All that goes away if we let Joiner be extended.
That said...at the moment, there are workarounds for this that are effective, if a bit awkward.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.appendTo(new StringBuilder("{"), elements)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.append("}")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.toString();
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c7) posted by **adam.g...@evocatus.com** on 2012-07-12 at 04:03 PM_
---
You can make the Abstract class and the derived OOTB Joiner thread safe.
The custom extended class would just have to make their own "public static MyJoiner on(String separator) { }" and call the Abstract classes super constructors.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c8) posted by **wasserman.louis** on 2012-07-12 at 04:09 PM_
---
Eh?  We can't control users making unsafe subclasses, and then dropping them in for use as Joiners in places that expect thread safety.
Or...I guess you're suggesting introducing a superclass in between?  I'm not sure what advantage that provides over just letting users write their own classes that aren't "related" to Joiner.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c9) posted by **adam.g...@evocatus.com** on 2012-07-12 at 04:30 PM_
---
The benefit is not having to rewrite the dozen of methods that depend on "appendTo" that are useful. The inheritance is for code reuse and not contractual drop-in replacement support.
I suppose I can just open up the source code for Joiner and copy'n paste it into my own custom class so that I can make my own "JoinerAndMore" (most of my customization would be in the appendTo method).
I'll probably do that for now.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c10) posted by **wasserman.louis** on 2012-07-12 at 04:34 PM_
---
Eh.  I mean, when we address figuring out an API that lets us deal with the escaping needs (as discussed in the issues Chris linked to earlier), I'm sure something like this will be considered.
And for specific needs, it's probably simpler to maintain a static utility method in your project that does X and Y on top of your Joiner.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c11) posted by **adam.g...@evocatus.com** on 2012-07-12 at 05:24 PM_
---
I hate to belabor the issue but just for doc purposes/clarification:
Maybe I'm missing something but there is no way to write a static method on top that will be as efficient (in general) because I don't have access to the Appendable.
I can transform collection/iterable/iterator and wrap the elements by creating new strings but that's not the same.
As for the escaping route proposed in issue 412 has the same problem in that you don't have access to the appendable.
Joiner.wrap(new SomeInterface() {
&nbsp;&nbsp;public wrap(Appendable a, @Nullable String string) {
&nbsp;&nbsp;&nbsp;&nbsp;return doescape(string);
&nbsp;&nbsp;}
}).join("blah>><<<");
But that is god awful, requires another interface, exposes the appendable while its in process, and is less declarative then .prefix(String s) and .suffix(String s).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c12) posted by **cpovirk@google.com** on 2012-07-12 at 05:31 PM_
---
Hmm, I agree that, for full efficiency, you need to be able to get at the Appendable (unless Louis has any clever ideas...?).  I'll make a note about that (as well as the SQL use case) on issue 412.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c13) posted by **wasserman.louis** on 2012-07-12 at 05:33 PM_
---
Eh?  I'm suggesting a static method joinBracketed(Joiner, String leftBracket, String rightBracket, Iterable&lt;Object> elements), for your personal utilties.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c14) posted by **adam.g...@evocatus.com** on 2012-07-12 at 06:00 PM_
---
@wassermain.louis I want to prefix and suffix each element in the "Iterable&lt;Object> elements" and not the end result.
For example if I want to turn Iterable&lt;Integer> into a String of "'1','2', and '3'" (that is I want to prefix and suffix the numbers with "'" and have the last one have an "and".
I believe there is no way with static methods operating on the joiner to do that efficiently. Do it I would have to do something like transform(Iterable&lt;Object> input, Interable&lt;String>) and then hand off the Iterable&lt;String> to the joiner.
The to ability to handle the ", and" at the end... is basically the same logic as the joiner.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c15) posted by **wasserman.louis** on 2012-07-12 at 06:09 PM_
---
Ah.  I've totally misunderstood the whole time.  Yep, you'd need the transform.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c16) posted by **cgdecker@google.com** on 2012-07-12 at 06:57 PM_
---
Personally, I've been feeling somewhat sympathetic to the idea of adding an option to Joiner for wrapping elements with a prefix/suffix recently. It's a request that seems to have come up a number of times now, and Joiner certainly doesn't provide a decent way of doing it currently (not that either of those are necessarily a good reason to add it).
However, I don't feel like escaping is necessarily something that Joiner should have at all... it just feels too heavyweight somehow. To me, Joiner has always been about joining for relatively simple things, like toString() or other output, not for creating a string intended to be parsed later. For something like that, I feel like a CSV writing/parsing library is called for, and I don't want to see Joiner try to become that.
As far as the idea of an option that allows for inserting a different separator before the last element... I'm not too sure how I feel about that right now.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c17) posted by **wasserman.louis** on 2012-07-12 at 07:00 PM_
---
I mean, I can also imagine in THE FUTURE that we might have some kind of heavy-duty formatting utility with lots of bells and whistles that supports all kinds of these fancy options, and one of its components might be a Joiner.  In that case, we might leave Joiner as-is, and add all the other stuff to this MagicFormatter utility...
I really don't know, but I'm not sure we should be ruling anything out at this point.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c18) posted by **adam.g...@evocatus.com** on 2012-07-12 at 07:16 PM_
---
One sort of crappy option is making an Appendable decorator.
BetterAppendable implements Appendable and extends it with methods like .appendSeparator()
This is what Commons StrBuilder does http://commons.apache.org/lang/api-2.4/org/apache/commons/lang/text/StrBuilder.html#appendSeparator(char) ... except it doesn't wrap appendable.
Basically Commons StrBuilder as all sorts of methods including padding methods and what not.
... but bye bye thread safety.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c19) posted by **cgdecker@google.com** on 2012-07-12 at 07:22 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c20) posted by **adam.g...@evocatus.com** on 2012-07-12 at 10:31 PM_
---
I went ahead and wrote my BetterAppendable which is for the most part thread safe except for the fact that most Appendables are not.
I put the code in a gist:
https://gist.github.com/3101471
Here is an example:
&nbsp;&nbsp;&nbsp;@Test
&nbsp;&nbsp;&nbsp;public void testSeparator() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String results = new BetterAppendable&lt;Appendable>(new StringBuilder())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.separator(",").suffix("'").prefix("'")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.append("Hello there lets count to 5")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.appendLine()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.nullText("hmm cookies...")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.appendParts(1,2,3, null)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.toString(); // can also do .getAppendable().getBuffer().toString()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assertEquals("Hello there lets count to 5\n" +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"1,'2','3','hmm cookies...'", results);
&nbsp;&nbsp;&nbsp;}
If the Joiner only operated on Strings then it would be idempotent and truly threadsafe (any time you operate on a mutable object like Appendable your IMHO not really threadsafe).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c21) posted by **cgdecker@google.com** on 2012-07-12 at 10:43 PM_
---
Idempotency is orthogonal to thread safety, and Joiner is thread safe (by virtue of being immutable). The Appendable input to join not being thread safe doesn't make the Joiner itself not thread safe. For example, 100 different threads could pass 100 different Appendables to a Joiner at the same time and there would be no problem as long as those Appendables were each kept on only one thread. If you were to mutate an Appendable from another thread at the same time a Joiner is appending to it there could certainly be a problem, but that's because the Appendable isn't thread safe, not because of Joiner.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c22) posted by **adam.g...@evocatus.com** on 2012-07-12 at 11:27 PM_
---
Hence the IMHO. Yes I agree by the Java definition of threadsafe Joiner is threadsafe. And the Appendable implementation I submitted is threadsafe also (because all the fields are final and immutable).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c23) posted by **cgdecker@google.com** on 2012-07-13 at 05:46 PM_
---
Well, your BetterAppendable (like any Appendable) is definitely stateful because it has to maintain state (what's been appended to it so far) from one append call to the next. It could be technically thread safe if, say, its methods were all synchronized, but it's not generally something you'd want to use from multiple threads. Joiner is totally different from that in that it is truly stateless and there's no reason at all not to use it from multiple threads at once.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c24) posted by **adam.g...@evocatus.com** on 2012-07-13 at 06:03 PM_
---
Sorry I meant AppendableDecorator class is ThreadSafe (it doesn't store the config) in: https://gist.github.com/3101471
I got confused with my renaming of the classes. I think some of the constructors need be made "friendly" and what not to keep users from extending but AppendableDecorator is threadsafe.
I'm basically tired of the plethora of String libraries out there. I blogged about it here: http://tmblr.co/ZJrhVxPGp1Gu
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c25) posted by **adam.g...@evocatus.com** on 2012-07-13 at 06:11 PM_
---
I forgot in the AppendableDecorator I need to switch it back from CharSequence to String in the configuration its still not threadsafe... but its an easy fix.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c26) posted by **j...@nwsnet.de** on 2012-07-16 at 08:37 AM_
---
I personally prefer the `Joiner`&nbsp;to join. Transforming the values before joining them is the cleanest solution to me, whether it's about prefixing, postfixing, infixing, escaping the values or combinations of that.
Instead, what about a simple builder for such functions? `StringTransformer.prefix('<').suffix('>').build()`, something like that. Returns `Function<String, String>`.
The joiner could then be extended to accept such a function: `Joiner.on(", ").transformValues(ENCLOSE_IN_ANGLE_BRACKETS).join(someValues)`
This should be doable regarding imports as both `Joiner`&nbsp;and `Function`&nbsp;are in the `base`&nbsp;package (as opposed to earlier issues with other, non-join-related classes in the `base`&nbsp;package that couldn't use immutable collections, for example).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c27) posted by **cgdecker** on 2012-07-16 at 01:24 PM_
---
The main issue with just transforming with a Function to do this is that you have to use string concatenation for each element when ideally you'd like to just be appending to the Appendable.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c28) posted by **adam.g...@evocatus.com** on 2012-07-16 at 02:45 PM_
---
One solution is to do something like:
Add a method and interface to Joiner:
public &lt;A extends Appendable> A appendTo(A appendable, Joiner.PartAppender&lt;A> partAppender, Iterator<?> parts);
public static interface PartAppender&lt;A extends Appendable> {
&nbsp;&nbsp;&nbsp;public void append(A appendable, Object part, int index);
}
Obviously this is not ideal (adding another interface and method) but would fit most of my use cases.
Thoughts?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c29) posted by **wasserman.louis** on 2012-07-16 at 02:59 PM_
---
Eh.  I'm still on the side of the Function crowd, which handles more general cases, including escaping, etc. that can't just be done with directly appending.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c30) posted by **adam.g...@evocatus.com** on 2012-07-16 at 03:13 PM_
---
In my method you could append gigabytes of text together. Not to mention you now have control over how the object is transformed to a string.
So with the proper Joiner.appender you could do something like:
<code>
Iterator&lt;File> files = ...;
Joiner.PartAppender&lt;FileWriter> myFileAppender = // casts the object parts to Files and reads them
Joiner.on(',').appendTo(fw, myFileAppender, parts);
</code>
The code above will join files of any size together.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c31) posted by **wasserman.louis** on 2012-07-16 at 03:24 PM_
---
Eh?  As I understand it, the proposals are fully equivalent in terms of what you can do with them.  You could implement a Function&lt;T, String> with a PartAppender by appending to an empty builder, and you can implement a PartAppender with a Function&lt;T, String> in the obvious way.
Eh.  I don't think there's any need to rush into any decisions, just because the alternative workarounds aren't especially difficult or confusing, and the long-term plan for e.g. Joiner is likely to be critically dependent on how e.g. the escaper API ends up looking whenever it comes out.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c32) posted by **adam.g...@evocatus.com** on 2012-07-16 at 03:52 PM_
---
I completely agree. No rush on decision and I agree more discussion (it was the intent of my previous post).
I don't think anything should be added to the Joiner. And I am completly happy with the code I stole from it to use for my AppendableDecorator.
As far as implementing with Function&lt;T,String> I think you  forgot that you don't have access to the Appendable. Immutable String concatenation is not efficient for giant strings.
The only way to do this efficiently is for the Joiner to delegate writing the parts to the appendable to something else because right now the Joiner will do a #toString() on the parts object. That means no matter what you will have the part converted to a string in memory by the joiner.
do something like:
<code>
String escape(String pre);
</code>
It will need to be something like:
<code>
void escape(Appendable a, Object o);
</code>
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c33) posted by **adam.g...@evocatus.com** on 2012-07-16 at 03:58 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c34) posted by **wasserman.louis** on 2012-07-16 at 04:01 PM_
---
No, I wasn't suggesting a Function that internally appends to an Appendable; I was suggesting the solution you thought I was -- but I wasn't worrying so much about the performance. ;)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c35) posted by **kurt.kluever** on 2012-07-24 at 05:41 PM_
---
Let's discuss this at API review.
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c36) posted by **cgdecker@google.com** on 2012-07-26 at 10:44 PM_
---
I think we've decided that we aren't going to add this functionality to Joiner. It will stay focused on simple joining. If we add something to do this, we'd want it to be part of (or at least based on) a more full-featured API for producing parseable strings (e.g. writing CSV strings), which would include escaping and such.
---
**Status:** `WontFix`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1064#c37) posted by **wasserman.louis** on 2013-04-30 at 03:19 PM_
---
_Issue #1392 has been merged into this issue._
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1059) created by **adam.g...@evocatus.com** on 2012-07-06 at 12:55 PM_
---
Java does not have an immutable BitSet. It would be nice if there was an ImmutableBitSetBuilder.
I and many others often use BitSets for URI encoding purposes or for complicated flag configuration. Thus the BitSets are often saved configuration (as a static final) that you don't want people to mutate.
http://stackoverflow.com/questions/7023936/is-there-an-immutablebitset-n-java
I hate requesting stuff with out writing the code so I will look into doing that today if people are interested.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1059#c1) posted by **wasserman.louis** on 2012-07-06 at 02:13 PM_
---
How would this differ from e.g. BigInteger?
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1059#c2) posted by **wasserman.louis** on 2012-07-06 at 02:17 PM_
---
(Also, I'm not certain I understand your use cases -- where would you use a BitSet for flag configuration that e.g. an EnumSet is less appropriate?)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1059#c3) posted by **adam.g...@evocatus.com** on 2012-07-06 at 02:57 PM_
---
EnumSet could be used but is pain if you have lets say 256 flags as is the case with URI encoding: http://grepcode.com/file/repo1.maven.org/maven2/commons-httpclient/commons-httpclient/3.1/org/apache/commons/httpclient/util/URIUtil.java#URIUtil.encode%28java.lang.String%2Cjava.util.BitSet%29
The flags indicate which character should be encoded or not.
As for BigInteger besides the semantics (BigInteger doesn't make me think of bit arrays) I was unclear of the performance of getting a specific bit or how to effectively to get a specific bit easily.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1059#c4) posted by **adam.g...@evocatus.com** on 2012-07-06 at 03:03 PM_
---
https://google.github.io/guava/apidocs/com/google/common/primitives/Booleans.html#contains(boolean[], boolean)
"Note: consider representing the array as a BitSet instead, replacing Booleans.contains(array, true) with !bitSet.isEmpty() and Booleans.contains(array, false) with bitSet.nextClearBit(0) == sizeOfBitSet."
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1059#c5) posted by **wasserman.louis** on 2012-07-06 at 08:17 PM_
---
Eh?  BigInteger.testBit is O(1).
Also, are you suggesting that ImmutableBitSet would extend BitSet, if you want it to be used in that URIUtil implementation?  I'm a bit uncomfortable with extending JDK classes that seem like they ought to be final.
(Effective Java mentions: "Arguably, BitSet plays the role of mutable
companion to BigInteger under certain circumstances." in item 15.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1059#c6) posted by **adam.g...@evocatus.com** on 2012-07-07 at 12:40 AM_
---
> Eh?  BigInteger.testBit is O(1).
> Also, are you suggesting that ImmutableBitSet would extend BitSet,
You got me on that I forgot that BitSet is not an interface.
> (Effective Java mentions: "Arguably, BitSet plays the role of mutable
> companion to BigInteger under certain circumstances." in item 15.)
I just don't like using BigInteger for BitSets when clearly even according to the Guava doc (which while not Joshua Bloch but still good stuff) says use BitSets for Boolean array. BigInteger seems to be a lucky fit. Compare this to Scala where there is an Immutable Bit Set: http://www.scala-lang.org/api/current/scala/collection/BitSet.html
I wish I could go change all the old code to accept BigInteger instead of BitSet but I'm stuck with BitSet.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1059#c7) posted by **wasserman.louis** on 2012-07-07 at 10:03 AM_
---
Let me be clear: if I could rewrite the JDK, I would absolutely ensure that BitSet had an obvious immutable implementation and everything.
Scala, of course, can get away with rewriting the core libraries.  But I'm not sure there's any good solution here for Guava to provide. =/
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1059#c8) posted by **kurt.kluever** on 2012-07-24 at 05:54 PM_
---
BigInteger is the right implementation but the wrong abstraction.
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1059#c9) posted by **kevinb@google.com** on 2013-04-08 at 06:58 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Base`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1059#c10) posted by **heuermh** on 2013-04-18 at 05:06 PM_
---
I have implemented such based on org.apache.lucene.util.OpenBitSet from the Apache Lucene project here
I can relicense as Apache version 2 if there is any interest.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1038) created by **majaesch** on 2012-06-21 at 04:37 PM_
---
Hi,
it would be great if Precondition get a method to check a value whether it's in a given range.
The way to do this, up to now:
class MyClass {
&nbsp;final static int MIN = 1, MAX = 4;
&nbsp;final int field;
&nbsp;MyClass (int field) {
&nbsp;&nbsp;Precondition.checkAgrument(field>=MIN&&field<=MAX);
&nbsp;&nbsp;this.field=field;
&nbsp;}
}
MyClass (Object field1,Date field2,int field3) {
&nbsp;&nbsp;this.field1 = checkNotNull(field1);
&nbsp;&nbsp;this.field2 = checkNotNull(field2);
&nbsp;&nbsp;checkAgrument(field3>=MIN&&field3<=MAX); // this line disturb the reading flow!
&nbsp;&nbsp;this.field3 = field3;
}
I would like to use Precondition like this:
class MyClass {
&nbsp;final static RANGE&lt;Integer> RANGE = Ranges.closed(1, 4);
&nbsp;final int field;
&nbsp;MyClass (int field) {
&nbsp;&nbsp;this.field= Precondition.checkRange(RANGE, field);
&nbsp;}
}
Here is a possible checkRange implementation.
static &lt;T extends Comparable&lt;T>> T checkRange(@Nonnull final Range&lt;T> range, @Nonnull final T value)
&nbsp;&nbsp;&nbsp;&nbsp;throws IllegalArgumentException {
&nbsp;&nbsp;&nbsp;&nbsp;checkArgument(range.apply(value));
&nbsp;&nbsp;&nbsp;&nbsp;return value;
}
static &lt;T> T checkAgrument(@Nonnull final Predicate&lt;T> predicate, @Nonnull final T value)
&nbsp;&nbsp;&nbsp;&nbsp;throws IllegalArgumentException {
&nbsp;&nbsp;&nbsp;&nbsp;checkArgument(predicate.apply(value));
&nbsp;&nbsp;&nbsp;&nbsp;return value;
}
static &lt;T extends Comparable&lt;T>> T checkAgrument(@Nonnull final Range&lt;T> range, @Nonnull final T value)
&nbsp;&nbsp;&nbsp;&nbsp;throws IllegalArgumentException {
&nbsp;&nbsp;&nbsp;&nbsp;return checkArgument(Ranges.asPredicate(range), value); // or maybe range extends predicate
}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c1) posted by **stephan202** on 2012-06-21 at 04:50 PM_
---
This cannot be done without introducing a cyclic package dependency: Range is in c.g.c.collect whereas Preconditions is in c.g.c.base.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c2) posted by **majaesch** on 2012-06-21 at 04:56 PM_
---
Okay...
static &lt;T extends Comparable&lt;T>> T checkRange(T min, T value, T max);
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c3) posted by **wasserman.louis** on 2012-06-21 at 05:43 PM_
---
How much value does that really add, though?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c4) posted by **stephan202** on 2012-06-21 at 05:59 PM_
---
I'd say the following is more general and in line with the original request:
&nbsp;&nbsp;&nbsp;static &lt;T> isSatisfied(Predicate<? super T> predicate, T value);
This works because Predicate is in c.g.c.base.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c5) posted by **wasserman.louis** on 2012-06-21 at 06:15 PM_
---
But that doesn't really add anything over checkArgument(predicate.apply(value)).  (Even worse, it doesn't suggest what exception it throws.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c6) posted by **majaesch** on 2012-06-21 at 06:16 PM_
---
@wasserman.louis
Alot, because I (and all my Co-Workers) expect that functionality in a precondition utility class.
And I guess checkRange is the second most common used precondition (at least in my maintained code base).
@stephen
ok but I think it should start with "check". Maybe checkSatisfaction()?
isXXX implies a boolean as returning value.
OT: Can Range extends Predicate or can Range at least get a "asPredicate" method? Just to kept a the functionality with Range, if users like me to use a range instead of a predicate.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c7) posted by **wasserman.louis** on 2012-06-21 at 06:21 PM_
---
Range already implements Predicate.
That said -- really, though?  I almost always see checkArgument(a >= 0) or another one-argument version, and that's not satisfied by this.  When I do see a two-bounded version, it almost always works like checkElementIndex or checkPositionIndex, which are already provided.
I also rarely see comparisons with anything but integers, though.  Do you have any specific examples?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c8) posted by **majaesch** on 2012-06-21 at 06:41 PM_
---
Ups I must checked Ranges not Range. My bad!
Examples:
Range&lt;Double> LATITUDE_RANGE = Ranges.closed(-180d, 180d);
GeoPoint( double lat, double lng ) { // yes with int its faster/better but it's just an example
&nbsp;&nbsp;latitude = checkArgument(LATITUDE_RANGE, lat);
}
// the most common case are based on numbers like int or double.
NonFutureQuery(Date date) {
&nbsp;&nbsp;until= checkArgument(Ranges.lessThan(Date.now), lat);
}
check*Index throws IndexOutOfBoundsException! That's suitable if the value is a index "of some sort (such as to an array, to a string, or to a vector)"
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c9) posted by **majaesch** on 2012-06-21 at 07:02 PM_
---
Another possible use case, which is not possible with the current checkArgument!
```
private final static Range<Double> POSITIVE = Ranges.atLeast(0d);
class Point {
final Number a,b;
public Point(Number a, Number b) {
this.a = a;
this.b = b;
}
}
class PositivePoint extends Point {
public PositivePoint(Double a, Double b) {
super(checkArgument(POSITIVE,a),checkArgument(POSITIVE,b));
}
}
```
BTW Predicate is much better.
```
class UniqueList<T> extends List<T> {
private final static Predicate<T> IS_NEW = ...
add(T value) {
super(checkArgument(IS_NEW,value));
}
}
```
Sorry for the double post.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c10) posted by **wasserman.louis** on 2012-06-21 at 07:30 PM_
---
But do these really read better than
checkArgunment(lat >= -180 && lat <= 180, "Latitude must be from -180 to 180, but was %s");
or
checkArguemnt(date.compareTo(Date.now()) <= 0, "Date must not be in the future");
The current setup leaves much more flexibility to control the exact error message than the proposed method could, just because there's generally a _meaning_ to the comparison that is more specific than anything you can get by saying "Value was out of range: [-180.0, 180.0]".
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c11) posted by **majaesch** on 2012-06-21 at 07:41 PM_
---
Of course there should be 3 methods.
static &lt;T> T checkAgrument(Predicate&lt;T> predicate, T value);
static &lt;T> T checkAgrument(Predicate&lt;T> predicate, T value, Object errorMessage);
static &lt;T> T checkAgrument(Predicate&lt;T> predicate, T value, String errorMessageTemplate, Object... errorMessageArgs);
e.g.:
checkArgunment(LATITUDE_RANGE, lat, "Latitude must be from -180 to 180, but was %s", lat);lowerEndpoint()
checkArgunment(MUST_BEFORE_DATE, date,  "Date must before %s", MUST_BEFORE_DATE.upperEndpoint());
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c12) posted by **wasserman.louis** on 2012-06-21 at 08:20 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c13) posted by **majaesch** on 2012-06-21 at 08:32 PM_
---
checkArgument, checkNotNull and checkState are overloaded in the same way. It's logical to do so.
But my point is really just that the passed value will be returned.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c14) posted by **wasserman.louis** on 2012-06-21 at 08:48 PM_
---
No, what I'm saying is that
static final Range&lt;Double> LATITUDE_RANGE = Ranges.closed(-180.0, 180.0);
checkArgunment(LATITUDE_RANGE, lat, "Latitude must be from -180 to 180, but was %s", lat);
checkArgument(lat >= -180 && lat <= 180, "Latitude must be from -180 to 180, but was %s");
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c15) posted by **majaesch** on 2012-06-22 at 07:35 AM_
---
Yes, but only if you don't use Predicate/Range already for this purpose.
I don't suggest to replace the existing checkAgrument.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c16) posted by **xaerxess** on 2012-06-22 at 08:38 AM_
---
-1 I use Preconditions.check\* extensively and I never had to combine them with Predicate.
Moreover,
checkArgunment(Ranges.closed(-180.0, 180.0), lat, "Latitude must be from -180 to 180, but was %s", lat);
is not as obvious as
checkArgument(lat >= -180 && lat <= 180, "Latitude must be from -180 to 180, but was %s");
and I really don't want to see wtfs in code... (Until now I haven't noticed Range implements Predicate.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c17) posted by **SeanPFloyd** on 2012-06-22 at 08:46 AM_
---
> This cannot be done without introducing a cyclic package dependency: Range is in c.g.c.collect whereas Preconditions is in c.g.c.base.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c18) posted by **majaesch** on 2012-06-22 at 10:00 AM_
---
I think you don't get my point.
If you have only one line like "checkArgument(v >= min && v <= max)" there is indeed no need for a "checkArgument(predicate, v)".
BUT if you have a range (predicate) constant in your class it makes sense to have such a method.
You don't see the point in this? Well, here is an example:
You have a REGEX to validate a given alias. This check will be done in several places (classes). Now you would like to change the regex.  This situation is like editing magic numbers.
To avoid this you can use an utility class with RegEx, own check Method or a predicate.
Can you all this archive with the existing checkArgument method? Of course!
checkArgument(Util.ALIAS.matches(alias), "bad alias %s", alias)
checkArgument(Util.isValidAlias(alias), "bad alias %s", alias)
checkArgument(Util.VALID_ALIAS.apply(alias), "bad alias %s", alias)
BUT non of this calls will return the passed alias!
class USER {
&nbsp;&nbsp;final String alias;
&nbsp;&nbsp;public USER (String alias) {
&nbsp;&nbsp;&nbsp;&nbsp;// checkArgument(Util.VALID_ALIAS.apply(alias), "bad alias %s", alias);
&nbsp;&nbsp;&nbsp;&nbsp;// this.alias = alias;
```
this.alias = checkArgument(VALID_ALIAS ,alias, "bad alias %s", alias);
```
&nbsp;&nbsp;}
}
I use precondition extensively too. At the beginning of every constructor I have my "precondition block".
&nbsp;&nbsp;this.field2 = checkNotNull(field2);
&nbsp;&nbsp;checkAgrument(field3>=MIN&&field3<=MAX);
&nbsp;&nbsp;this.field3 = field3;
You mentioned that you never combine Preconditions with Predicate. The truth is I do not ether (up to now). But I do it with Range. And that was my origin idea. But to use Predicate for such a method is more powerful. And I think not returning the checked value is the special case.
BTW: I don't not use Optional, because I have no need for it.
PS: What is more readable: "Ranges.closed(lower, upper)" or "value > MIN && value <= MAX"? It's pretty easy to miss a "="!
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c19) posted by **wasserman.louis** on 2012-06-22 at 11:00 AM_
---
I would say "value > MIN && value <= MAX" is more readable.  Who wants to figure out the meaning of "closed" each time?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c20) posted by **majaesch** on 2012-06-22 at 11:22 AM_
---
I guess you don't use Range. Otherwise you would be familiar with the methods. That's OK. Nobody is forced to use all guava classes and methods.
It seems that I was not able to convinced you. And I don't want to repeat myself. So all I have left to say is: The idea is not a theoretical thing. Before I discovered guava (0.9), I had my own utility class. The most functionality are covered by guava. Only checkRange is missing. I still use this method of this class. But I would like to get rid of a utility class with only one used - overloaded - method. And I thought it would be useful for other users too.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c21) posted by **wasserman.louis** on 2012-06-22 at 12:17 PM_
---
To be clear: I love Range.  I regularly hold it up as a shining example of API design, of not trying to do too much, but doing as much as it needs to extremely well.
I build a lot of things around it; specifically including RangeSet and RangeMap, which will probably come out in a future version of Guava.  (You can see early versions of those in the repository already, I think.)
Leaving aside the package dependency issue, which is probably not avoidable, what I like about the preexisting checkArgument version is that it's absolutely readable without having any preexisting background with Guava.  Sure, I have that background, but not everybody who's reading all this code will.  People have been code-reviewing code with -180 <= lat && lat <= 180 for years, and the status quo isn't _that_ unacceptable.
In addition, there are a couple alternatives that I know have been discussed in the past: fluent comparison predicates so you can use the words "less" or "atMost" (e.g. issue 834).  Alternatively, to sidestep the dependency issue, add a method to the Range class itself: Ranges.closed(-180, 180).checkContains(argument, errorMessage).  (I don't endorse any of these alternatives; I merely mention them.)
I have to wonder, though, if anybody has actually been using Predicates and Ranges in their precondition checks at the moment.  http://code.google.com/p/guava-libraries/wiki/FunctionalExplained#Caveats discusses some of the issues with that, although Ranges aren't quite as bad, and have much nicer syntax.  But honestly, I look at
static final Predicate&lt;T> IS_VALID = new Predicate&lt;T>() {
&nbsp;&nbsp;&nbsp;public boolean apply(T t) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;}
};
....
checkArgument(IS_VALID.apply(t), "must be valid or something", t);
and I compare it to, at the _worst_,
private static boolean isValid(T t) {
&nbsp;&nbsp;&nbsp;...
}
checkArgument(isValid(t), "must be valid or something", t);
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c22) posted by **kevinb@google.com** on 2012-06-22 at 06:42 PM_
---
So this amounts to a request to support
&nbsp;&nbsp;this.value = checkArgument(value, predicate);
&nbsp;&nbsp;checkArgument(predicate.apply(value));
&nbsp;&nbsp;this.value = value;
... correct?
---
**Status:** `Research`
**Labels:** `Type-Addition`, `Package-Base`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c23) posted by **wasserman.louis** on 2012-06-22 at 06:46 PM_
---
That's my understanding.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c24) posted by **majaesch** on 2012-06-22 at 07:08 PM_
---
@kevin
_brainstorming_
There is "checkState". I never used it, but it's pretty equal to checkArgument. It only throws another exception.
To be strait forward, there should be a checkState(predicate) too. Or to be more general check(predicate, value, Class<? extends Exception). But that is too complicated and error prone. Not every exception has a constructor for a message or/and cause.
And thanks for the link. Made you opinion much clearer to me!
According to the dependency issue: Why? Both classes are in base.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c25) posted by **wasserman.louis** on 2012-06-22 at 07:13 PM_
---
Sorry, I mixed up Range and Predicate.  I concede that there's no issue with checking a Predicate.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c26) posted by **wasserman.louis** on 2012-06-22 at 07:16 PM_
---
(That is, no dependency issue.  I'm also fond of the checkArgument/checkState dichotomy instead some sort of reflective technique.)
---
> But do these really read better than
>
> checkArgunment(lat >= -180 && lat <= 180, "Latitude must be from -180 to 180, but was %s");
IMHO, yes, although not much. Having something like
Range&lt;Double> LATITUDE_RANGE = Ranges.closed(-180d, 180d);
&nbsp;&nbsp;&nbsp;&nbsp;latitude = checkArgument(LATITUDE_RANGE, lat, "latitude");
}
could report "latitude must be in [-180..180], but was 1000".
- It's more precise (I understand "from-to" as closed range, but there might be people thinking differently).
- It's more compact in case of "closedOpen" etc.
- It's non-repetitive, which is good in case the range changes.
- It's less error-prone (forgetting "=" is much easier than misspelling "closed" as "closedOpen").
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c28) posted by **amertum** on 2012-06-24 at 01:14 PM_
---
If you want preconditions on steroid, it will quickly become something like hamcrest matchers (https://github.com/hamcrest/JavaHamcrest) or FEST assert (http://docs.codehaus.org/display/FEST/Fluent+Assertions+Module).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c29) posted by **j...@nwsnet.de** on 2012-06-25 at 09:39 AM_
---
&nbsp;&nbsp;checkAgrument(field3>=MIN&&field3<=MAX); // this line disturb the reading flow!
It would be a lot less disturbing with the appropriate spaces around the operators in place. (No offense, just my personal suggestion to take code formatting seriously for the sake of improved readability and easier bug spotting.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c30) posted by **j...@nwsnet.de** on 2012-06-25 at 10:08 AM_
---
While I personally use predicates a lot and ranges every now and then, I found it to be acceptable to add a `.apply()`&nbsp;in my `checkArgument`&nbsp;calls whenever I wanted to use a predicate to check against.
Regarding clarity, a predicate with a good name makes things clear:
&nbsp;&nbsp;checkArgument(IS_USER_LOGGED_IN, "User must be logged in, but isn't.");
But for ranges, this gets trickier:
&nbsp;&nbsp;checkArgument(VALID_STATES, state, "Invalid state.");
Instead, this would be a lot cleaner (and already works with what we have):
&nbsp;&nbsp;checkArgument(VALID_STATES.contains(state), "Invalid state.");
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c31) posted by **em...@soldal.org** on 2012-06-25 at 11:21 AM_
---
checkArgument(LATITUDE.apply(myLat),"Latitude %s not contained within range %s",myLat,LATITUDE); ?
if you wish to write something like this, here is some code I drafted a while back for a fluent precondition API, it is not complete but perhaps it will give you some inspiration: https://gist.github.com/2988020
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c32) posted by **wasserman.louis** on 2012-07-01 at 01:53 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c33) posted by **j...@nwsnet.de** on 2012-07-02 at 12:11 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c34) posted by **kurt.kluever** on 2012-07-24 at 05:06 PM_
---
If we're going to deal with predicates or anything more complicated than booleans, then it should live in a more robust precondition checking library and not here.
The predicate.apply(value) suggestion sounds reasonable.
---
**Status:** `WontFix`
I'm probably overlooking something here, but... is the method reference typically better than calling the method directly?
```
String value = checkArgument(list::contains, parameter, "%s is not registered", parameter);
String value = checkArgument(list.contains(parameter), "%s is not registered", parameter);
```
Additionally, I think we'd be limiting ourselves to one-argument methods -- which is sort of already true, of course, since that's how `Predicate` works, but it means that we're missing out on some of the power of lambdas / method references.
Oh, the inline thing. Thanks.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1037) created by **speciman** on 2012-06-21 at 04:32 PM_
---
Collections2.permutations() and Collections2.orderedPermutations() currently return all size n permutations within a size n list.
I think adding a way to retrieve size k permutations in a list of n elements would be a valuable addition.
See also : http://stackoverflow.com/questions/11120985/guava-collections-limit-permutation-size
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1037#c1) posted by **wasserman.louis** on 2012-06-21 at 05:43 PM_
---
You didn't mention in your SO question any real-world use case.  What are you really trying to do?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1037#c2) posted by **wasserman.louis** on 2012-06-22 at 12:35 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Addition`, `Package-Collect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1037#c3) posted by **kurt.kluever** on 2012-07-24 at 05:02 PM_
---
Still waiting on a specific use-case from the OP.
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1037#c4) posted by **jheinnic** on 2014-08-14 at 02:09 AM_
---
Consider whatever engine generates crosswords for the California lottery.  It is given a list of lists where each inner list contains 22 words that have been chosen for printing and its task is to supply each ticket with a set of "Your Letters" such that the published prize distribution is accurately maintained.
To do that, it has to select a certain number of tickets at each prize level and find a k-permutation of the alphabet such that the exacy number of words from the set of 22 are completely covered, no more, no less.  Word lists can be presumed to have a healthy distribution of letters across words, and if a given ticket somehow lacks a solution for the desired prize level, it's always possible to swap it for another candidate that does.
Since each ticket gives its player 18 out of 26 letters, it would be useful to have a way to iterate through the 18-permutations of A-Z.  Mind you, this problem is better addressed by tracking the pair substitutions along a Hamiltonian cycle through all the nodes representing unique 18-permutations.  There is an algorithm for generating such a pair sequence to be found in Knuth and I've frequently used the attached implementaiton of it in my own work...
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1034) created by **f.vanlan...@1hippo.com** on 2012-06-18 at 03:21 PM_
---
The handler finding strategy in the event bus implementation has the potential to be very useful, but it cannot be overridden at the moment.  (even the interface class is internal to the package)
My particular use case is that I want to implement an event bus across different web applications running in the same container.  I do want to keep the shared classpath as clean as possible, ideally only containing a small number of interfaces.  Putting guava on the shared classpath is considered too invasive as one particular version is then pushed onto all applications.
At the moment, I'm achieving this goal by setting a custom handlerfindingstrategy (implemented in a split package) into the eventbus 'finder' field with reflection.  It's ugly and it will break when a security manager is configured.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1034#c1) posted by **wasserman.louis** on 2012-06-18 at 04:38 PM_
---
FYI, we're being pretty cautious with EventBus API changes at the moment, as there are a pretty large number of not necessarily compatible changes being discussed.  At the moment, it's deliberately not overridable.
---
**Labels:** `Type-Enhancement`, `Package-EventBus`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1034#c2) posted by **kevinb@google.com** on 2012-06-19 at 05:57 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1034#c3) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1034#c4) posted by **toutcon** on 2012-06-27 at 01:43 PM_
---
In duplicate issue https://github.com/google/guava/issues/803 it is said that:
" kevinb@google.com, Jan 31, 2012
Our annotations are a key part of our simple API, so if you don't want to use them, you want to opt out of using our API, basically.  You can wrap it, implement your own, fork it, etc.
"
So is this feature being finally reconsidered?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1034#c5) posted by **wasserman.louis** on 2012-06-27 at 04:20 PM_
---
I definitely want to think about this issue, but I'd be surprised if it made it into 13.0.  (What I really need to do is to spend about a month experimenting with a dozen or so EventBus forks, and see which of the many feature requests conflict with each other, and identify which changes won't block off future feature requests...)
I'll try to start on that soonish.
That said, I'm not sure what about that quote suggests reconsideration for this feature request...?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1034#c6) posted by **f.vanlan...@1hippo.com** on 2012-06-27 at 04:32 PM_
---
Great!  Thanks Louis!
Any issues in mind that could conflict?  Those might also lead to alternative solutions for this issue.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1034#c7) posted by **toutcon** on 2012-06-27 at 04:47 PM_
---
Thanks in advance.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1034#c8) posted by **wasserman.louis** on 2012-06-27 at 04:51 PM_
---
Eh?  I'm saying that I need to go and do that research.
But to answer f...'s question: What if later we want handler finders to do different things -- pass back some kind of reference or ticket or something (issue 784)?  What if we have to mandate some particular ordering of searching through methods (issue 838)?
Exposing control over the handler finders locks us into a particular API, and that API has to allow for future growth in an unobtrusive way.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1029) created by **wasserman.louis** on 2012-06-12 at 07:51 PM_
---
The proposal is Lists.concat(List, List), to return an unmodifiable view of the concatenation of two lists.  (As with Sets.union, it probably doesn't make sense to provide methods to concatenate arbitrarily many lists because the overhead grows linearly with the number of concatenated lists.)
The thing that specifically brought this to mind was issue 912, which suggested adding support for unioning SetMultimaps and concatenating ListMultimaps.
(While we're at it, we might consider Collections2.concat(Collection, Collection), but that is probably a rarer need.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1029#c1) posted by **kevinb@google.com** on 2012-06-13 at 12:28 AM_
---
We do have it internally, with a few dozen usages, but we haven't reviewed those usages to understand whether this is really what they want to do.
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1029#c2) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1029#c3) posted by **ray.j.greenwell** on 2012-06-23 at 02:14 AM_
---
I have wanted something like this, usually for the case of "add 1 value to the beginning or end of an existing immutable list". But every time I've thought about writing an implementation I also think about the horrible mis-use and in the end I've just copied to a new List.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1029#c4) posted by **matt.nathan** on 2013-11-15 at 03:48 PM_
---
I just ran into this use case.
We have the equivalent of this:
interface Db {
&nbsp;&nbsp;List&lt;Model> listChildren(String parentId)
}
class Service {
&nbsp;&nbsp;@Inject Db db;
&nbsp;&nbsp;public List&lt;Model> getChildren(String... parentIds) {
&nbsp;&nbsp;&nbsp;&nbsp;List&lt;Model> response = Lists.newArrayList();
&nbsp;&nbsp;&nbsp;&nbsp;for (String id : parentIds) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.addAll(db.listChildren(id));
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return response;
&nbsp;&nbsp;}
}
Having a concat style method would fit perfectly for us as (assuming it's a view) we wouldn't need to copy all the items into the target list.
For reference here is what out code would look like with a concat method.
class Service {
&nbsp;&nbsp;@Inject Db db;
&nbsp;&nbsp;public List&lt;Model> getChildren(String... parentIds) {
&nbsp;&nbsp;&nbsp;&nbsp;List&lt;List&lt;Model>> response = Lists.newArrayListWithCapacity(parentIds.length);
&nbsp;&nbsp;&nbsp;&nbsp;for (String id : parentIds) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.add(db.listChildren(id));
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return Lists.concat(response);
&nbsp;&nbsp;}
}
I'm more than happy if there is a different approach that I should be using in this case :)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1029#c5) posted by **matt.nathan** on 2013-11-15 at 04:11 PM_
---
As an update I have managed to change our code to use Iterable instead of List for this functionality so I get to use the Iterables.concat method.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1029#c6) posted by **jake.cobb** on 2014-02-05 at 04:49 PM_
---
I would like to see this.  A use case that I find commonly is merging Lists (or other collections) to pass to a library API, where the library is going to make a defensive copy anyway.  Consider the following:
void api(List&lt;T> input); // makes a defensive copy of input
// client code
List&lt;T> input1 = ...;
List&lt;T> input2 = ...;
api(Lists.concat(input1, input2));
Without this, I first have to copy the input lists into an intermediate list, which is wasteful.  I don't necessarily have the freedom to modify the API as Matt did when it comes from a library.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1029#c7) posted by **julianhyde** on 2014-02-06 at 10:01 PM_
---
I too would like to see this.
About 30% of the time I am able to make do with Iterables.concat(), but the rest of the time I need a list. Obviously an Iterable doesn't have size(), but less obviously it doesn't have the guarantee that its equals() and hashCode() will match another Iterable with the same contents.
Meantime I'm using my own https://github.com/julianhyde/optiq/blob/master/core/src/main/java/org/eigenbase/util/CompositeList.java.
---
This would be a nice addition---not just for Lists but for Collections in general, too.
I looked into our internal usages of this API. There are roughly 40 people using it, but 10 of those people are "misusing" it (i.e., they should have been using `Iterables.concat()` or `FluentIterable` instead).
On a cursory glance, the other ~30 usages seemed legitimate.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1020) created by **aklitzing** on 2012-05-31 at 10:18 AM_
---
I like to request that the static methods of com.google.common.io.Closeables will be extended to accept an AutoCloseable [1], too. I'm using ResultSet and Connection for JDBC a lot and I miss the simple Closeables.closeQuietly() in my finally block.
[1] http://docs.oracle.com/javase/7/docs/api/java/lang/AutoCloseable.html
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1020#c1) posted by **em...@soldal.org** on 2012-05-31 at 10:25 AM_
---
---
Well, AutoCloseable exists since Java 1.7 ...... then it would be nice if ResultSet, Connection and Statement would be supported by com.google.common.io.Closeables.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1020#c3) posted by **wasserman.louis** on 2012-05-31 at 10:27 AM_
---
The point is that Guava depends on only Java 6, so it can't use AutoCloseable.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1020#c4) posted by **wasserman.louis** on 2012-05-31 at 10:28 AM_
---
I think that we're all in agreement that much of common.io is made obsolete by Java 7, but we're a ways away from identifying what gaps exist in Java 7, how we might go about filling them, and rewriting or redoing common.io to address those concerns.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1020#c5) posted by **em...@soldal.org** on 2012-05-31 at 10:45 AM_
---
I don't see anything wrong with adding support for ResultSet, Connection & Statement, although you risk adding .close() support to damn near every class in existance :P
In Java 7, all the aformentioned classes extend AutoClosable so it should be trivial to phase out those methods for 1.7.
+0.5 maybe?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1020#c7) posted by **wasserman.louis** on 2012-05-31 at 10:53 AM_
---
Here is the complete list of classes that implement AutoCloseable in Java 7 that don't implement Closeable in Java 6 (just obtained by a simple diff):
AbstractSelector, AsynchronousFileChannel, AsynchronousServerSocketChannel, AsynchronousSocketChannel, DatagramSocket, FileCacheImageInputStream, FileCacheImageOutputStream, FileImageInputStream, FileImageOutputStream, FileLock, FileSystem, ImageInputStreamImpl, ImageOutputStreamImpl, JarFile, MemoryCacheImageInputStream, MemoryCacheImageOutputStream, MLet, MulticastSocket, PrivateMLet, Scanner, Selector, ServerSocket, Socket, SSLServerSocket, SSLSocket, URLClassLoader, XMLDecoder, XMLEncoder, ZipFile
I'm not sure how many of these are _new_ classes in Java 6, but...I think that most of them were in Java 6, but not implementing Closeable.
However...hmmmm.  Observation: if you use Java 7 with Guava (even though Guava is built for JDK 6), almost all of the classes in the above list have been retrofitted to implement Closeable, which means that the Closeables utilities from Guava should work on them, no?  So are you on Java 7?  If so, what's the problem?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1020#c8) posted by **wasserman.louis** on 2012-05-31 at 10:58 AM_
---
Okay, I see.  AutoCloseable is a new superinterface of Closeable.
That said, a quick diff suggests that in JDK 7, there are only three types implementing AutoCloseable without implementing Closeable: FileLock, XMLDecoder, XMLEncoder.  So as long as you know the specific type of the closeable thing, and you're not just passing it around, you can still use the Closeables utilities.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1020#c9) posted by **kevinb@google.com** on 2012-06-01 at 12:07 AM_
---
I don't quite understand why anyone would want to use Closeables at all in JDK 7 in the first place. Isn't the new try syntax a lot easier?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1020#c10) posted by **em...@soldal.org** on 2012-06-01 at 07:40 AM_
---
@Kevin I think in some instances you might have to hold the resource open for an unknown period of time and then Closables would come in handy for cleaning up the resources.
---
I don't want to use Closeables in JDK7 I saw to late that AutoCloseable is JDK7. I just want to use Closeables for JDBC classes like ResultSet, Statement and Connection.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1020#c12) posted by **kevinb@google.com** on 2012-06-19 at 05:46 PM_
---
Since all these things should just work in the JDK 1.7 future, I don't think it makes sense for us to add special one-off support for things like ResultSet now.  I see nothing for Guava to do in this area at the moment.
---
**Status:** `WontFix`
**Labels:** `Type-Enhancement`, `Package-IO`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1018) created by **diwakergupta** on 2012-05-29 at 08:14 PM_
---
"Anyone currently using FindBugs 1.3.9 should find FindBugs 2.0 to largely be a drop-in replacement that offers better accuracy and performance."
Furthermore, projects using FindBugs 2.0.0 with Guava 12 will run into warnings about duplicate class files when generating packages using Maven. This is because in FindBugs 2.0.0, the JSR305 annotations are part of the core annotations.jar and a separate artifact is not required.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1018#c1) posted by **kevinb@google.com** on 2012-05-30 at 07:49 PM_
---
_(No comment entered for this change.)_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1018#c2) posted by **kevinb@google.com** on 2012-06-19 at 05:44 PM_
---
We'll investigate upgrading the external build to use the new findbugs jar.  Also, should we have declared this as a compile-time-only dependency?  That might prevent this from being a problem that affects anyone.
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1018#c3) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1018#c4) posted by **kevinb@google.com** on 2012-06-22 at 06:57 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-General`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1018#c5) posted by **mfu...@us.ibm.com** on 2012-08-03 at 06:39 PM_
---
Hi Kevin,
I noticed that Chris set the "provided" scope on the jsr305 artifact.  Judging from the way the annotations are used, the scope should actually be "compile" and you should add the &lt;optional>true&lt;/optional> tag. (That way, if someone wants to compile and perform static analysis on guava, he or she would have the option of adding the dependency. However, people who using the guava jar don't need the artifact.)
Regards,
-Matt
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1018#c6) posted by **kevinb@google.com** on 2012-08-03 at 07:49 PM_
---
Christian, what do you think of this?
---
**Owner:** cgruber@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1018#c7) posted by **cgruber@google.com** on 2012-08-07 at 08:04 PM_
---
Optional is intended to be used by code that may have several sets of bytecode needed to compile, but only one of which might be used at run-time, so optional lets you cut the transitivity off, so that the down-stream projects can (and must) declare the one of their choosing).  Key use-cases of this would include compiling a framework against several back-end database drivers, but only needing whichever one is actually used at runtime, or several caching backends, etc.
Provided is intended to be used by projects that need dependencies at compile-time, but at run-time these will be provided by some other means, most notably by the JDK or by a container, etc.  Key use-cases of this would be javax.servlet, etc.
In practice, they both behave identically.
I chose "provides" scope because I knew precisely what behaviour would result (down-stream dependents would have to declare it if they need it), and it was sort of a 50/50 decision on which way to go.  And in our case, we don't even need any bytecode for @Nullable to exist at runtime because it's an annotation.  So... meh?
I don't see a problem in changing this to compile/optional, but I also don't see a payoff.  The dependency resolution mechanism will perform exactly the same way - it'll be present at compile/test time, and not present in the transitive closure of down-stream dependents.
I'm closing this on the basis of inertia, unless anyone cares enough to make an impassioned plea for optional that shows substantial superiority.
---
**Status:** `WorkingAsIntended`
---
In ref to https://groups.google.com/d/topic/guava-discuss/NfE09gFfPjU/discussion
This issue discusses the addition of the following three methods to Iterables:
Iterable&lt;List&lt;T>> partition(Iterable&lt;T> iterable, Comparator&lt;T> comparator)
Iterable&lt;List&lt;T>> parition(Iterable&lt;T> iterable, Equivalence&lt;T> equivalence)
Iterable&lt;List&lt;T>> parition(Iterable&lt;T extends Comparable<? super T>> iterable)
The proposed function of these methods would be to group or chunk like items together without disrupting the order of the elements or their occurrence in the underlying iterable or boundaries in the underlying iterable.
As a side-effect of this it would also be prudent to add something to Equivalences like Equivalence&lt;T> from(Comparator&lt;T> comparator) for completeness.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1010#c1) posted by **stephan202** on 2012-05-23 at 10:11 PM_
---
This sounds very similar to Python's itertools.groupby [1]. +1 from me :)
[1] http://docs.python.org/library/itertools.html#itertools.groupby
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1010#c2) posted by **em...@soldal.org** on 2012-05-26 at 01:04 AM_
---
Jet-lagged brainwave:
These signatures would also naturally fit into FluentIterable, but in that instance groupBy() would seem to give more meaning.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1010#c3) posted by **tomas.zalusky** on 2012-05-29 at 10:29 AM_
---
1. Multimaps.index is pretty close to aggregation method. Kevin's first entry in discussion perfectly fits to my usecases, however it always returns new multimap. Sometimes, for example when streaming large file, lightweight approach is more desirable. E.g. pass through iterable once and generate events like "open group" and "close group" to some builder, like for example during SAX xml parsing.
2. To use Equivalence for group boundary recognition is unnecessarily restrictive. The problem to be solved is just to decide if two neighboring elements are in the same group. The aggregation method would then be usable e.g. for finding continuous subsequences in list of integers [1,2,3,4,7,10,11] -> 1-4,7,10-11 or for some simple analysis. Hence Equivalence would be abused here since symmetry and transitivity would be violated. Predicate&lt;Pair&lt;T>> (if Guava had Pair) would IMHO be more appropriate.
3. Aggregation is often multilevel and the function on which data is aggregated is usually the same as the function on which data is sorted. The API should facilitate both in some convenient way.
Example of my API (real use case, original entities from telco domain):
class Person {String surname; String name; int number; ...}
List&lt;Person> persons = Lists.newArrayList(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Person("Doe","Jack",1),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Person("Doe","Jack",2),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Person("Doe","Joe" ,1),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Person("Doe","Joe" ,2),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Person("Doe","Joe" ,3),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Person("Doe","Joe" ,5),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Person("Doe","Joe" ,6),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Person("Doe","Joe" ,7),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Person("Doe","Joe" ,8),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Person("Roe","Jane",1),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Person("Roe","Jane",2),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Person("Roe","Jane",3),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Person("Roe","Jane",5)
);
Builder&lt;Person,String> bySurname = new Builder&lt;Person,String>() {
&nbsp;&nbsp;&nbsp;&nbsp;public String key(Person current) {return current.surname;}
&nbsp;&nbsp;&nbsp;&nbsp;public void openGroup(Person first) {System.out.println(first.surname);}
};
Builder&lt;Person,String> byName = new Builder&lt;Person,String>() {
&nbsp;&nbsp;&nbsp;&nbsp;public String key(Person current) {return current.name;}
&nbsp;&nbsp;&nbsp;&nbsp;public void openGroup(Person first) {System.out.println("+" + first.name);}
};
Builder&lt;Person,Integer> byNumber = new Builder&lt;Person,Integer>() {
&nbsp;&nbsp;&nbsp;&nbsp;private int firstNumber;
&nbsp;&nbsp;&nbsp;&nbsp;public Integer key(Person current) {return current.number;}
&nbsp;&nbsp;&nbsp;&nbsp;public boolean isSameGroup(Integer previousExpression, Integer currentExpression) {return previousExpression + 1 == currentExpression;}
&nbsp;&nbsp;&nbsp;&nbsp;public void openGroup(Person first) {System.out.print("++" + (firstNumber = first.number));}
&nbsp;&nbsp;&nbsp;&nbsp;public void closeGroup(Person last) {System.out.println(firstNumber == last.number ? "" : "-" + last.number);}
};
Grouping.group(persons).by(bySurname,byName,byNumber);
result:
+Jack
++1-2
++1-3
++5-8
++1-3
++5
FluentIterable
&nbsp;&nbsp;&nbsp;&nbsp;.from(persons)
&nbsp;&nbsp;&nbsp;&nbsp;.groupBy(Person.GET_SURNAME)
&nbsp;&nbsp;&nbsp;&nbsp;.groupBy(Person.GET_NAME)
&nbsp;&nbsp;&nbsp;&nbsp;.groupBy(Person.GET_NUMBER,EQUIVALENCE_FOR_DIFFERENCE_1)
(Just a shot, I didn't researched it deeply yet.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1010#c4) posted by **wasserman.louis** on 2012-05-29 at 10:43 AM_
---
"Group boundary recognition" is a totally different problem than the one I think Emily's addressing -- in particular, there's the case when we want to group _contiguous_ elements, and the case when we want to group not-necessarily-contiguous elements together (e.g. by an Equivalence).
It's not clear to me that a "One True Aggregation API" could even exist, but I think there are definite possibilities for improvement.
The idea playing around in my head at the moment is some sort of fluent "Grouping" API that takes an Iterable&lt;E> and returns an Iterable&lt;Iterable&lt;E>>.  Groupings might be contiguous, they might be non-contiguous, they might be based on a function or an ordering or an equivalence...am I making sense?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1010#c5) posted by **wasserman.louis** on 2012-05-29 at 10:44 AM_
---
That is, let me clarify: I think groupings are too complicated to just get tacked on to e.g. FluentIterable; I think there are too many different ways to "group" to just have a couple of heavily overloaded methods.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1010#c6) posted by **em...@soldal.org** on 2012-05-29 at 10:47 AM_
---
A full API built as opposed to a single method on FluentIterable? Me gusta.
Now that you mention it Louis, this does seem to make more sense. Since nested grouping using FluentIterable would result in Iterable&lt;Iterable&lt;Iterable...ad nausium, or at least it would risk it. Perhaps it could be solved by being able to combine Equivalences, when using a Comparator you could use Ordering.compound() to do this nesting for you.
Sorting the data is actually not a prerequisit for grouping, even though the two are often together.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1010#c7) posted by **wasserman.louis** on 2012-05-29 at 11:14 AM_
---
+1 for Equivalences.intersect (if not the name, at least the functionality).
My concern with "aggregation" has always been that it's such an open-ended, complicated thing that encompasses so many different ideas that designing an API to deal with them all is _difficult._  Just from this issue and off the top of my head, we have
- grouping by Equivalence (contiguous or not)
- grouping into chunks of K
- grouping into K chunks
There are a lot of different ways to take these ideas, and I'm still not sure we can fit them all into one unified API, but I think that a fluent "Grouping" API is the only way to even get close.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1010#c8) posted by **em...@soldal.org** on 2012-05-29 at 11:30 AM_
---
- grouping by Equivalence (contiguous or not) / grouping by Comparator (contiguous or not)
&nbsp;&nbsp;&nbsp;&nbsp;\- I feel like we should only concern outselves with contiguous variants (and I hope I am using that word correctly...), any preliminary grouping of elements should be done by the user and it would feel presumptious to simply assume that the data should be structured. We could sort it beforehand but then you loose a lot of performance if you present yourself as a view and then the user iterates multiple times.
&nbsp;&nbsp;&nbsp;&nbsp;\- Isn't this the same as a equivalence with a hashing function infront of it? Interesting idea though
&nbsp;&nbsp;&nbsp;&nbsp;\- K chunks in N is tricky as you will have to judge the size of the iterable before figuring out how big a chunk should be
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1010#c9) posted by **wasserman.louis** on 2012-05-29 at 11:38 AM_
---
"I feel like we should only concern outselves with contiguous variants (and I hope I am using that word correctly...), any preliminary grouping of elements should be done by the user"
I'm not sure I buy this?  I would say that Multimaps.index does "aggregation," but it simply doesn't care what order the values come in, and I feel like that's a use case worth addressing -- especially for e.g. Equivalences where there isn't an obvious way to "sort."
That is, I think it's totally legit for a user to say, "I have these totally arbitrarily ordered values, and I want them grouped according to an Equivalence."
"grouping by HashFunction (?)
&nbsp;&nbsp;&nbsp;&nbsp;\- Isn't this the same as a equivalence with a hashing function infront of it? Interesting idea though"
Mostly I think of this as being like Multimaps.index, except using a custom hash function that might be more efficient/effective/have fewer collisions
Indeed, that version would be strict -- and if we want to deal with noncontiguous groupings, those would be strict too.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1010#c10) posted by **em...@soldal.org** on 2012-05-29 at 11:45 AM_
---
You'd have to do some sort of intelligent sorting algorithm though, since you don't know if A is above or below B only that it is different. How would you sort a list where no elements are equal? Wouldn't it go into a loop?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1010#c11) posted by **em...@soldal.org** on 2012-05-30 at 08:38 AM_
---
Most of what we've discussed so far seems to be related to the way you define a grouping rather than the operation of grouping itself. Even if we wish to do ordering, it occurs outside of the actual operation of grouping.
What if instead of a Grouping API we define a builder pattern for a grouping rule:
FluentIterable&lt;List&lt;Person>> groupedPeople = FluentIterable.from(people).grouping().by(Person.GET_SURNAME).by(Person.GET_NAME).group();
or
FluentIterable&lt;List&lt;Person>> groupedPeople = FluentIterable.from(people).grouping().by(Person.GET_SURNAME).by(Person.GET_NAME).sortedBy(Person.GET_SURNAME).group();
where sortedBy takes either a Comparator&lt;T> or a Function&lt;T,Comparable> which we can use with Ordering.natural().onResultOf()
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1010#c12) posted by **wasserman.louis** on 2012-05-30 at 08:44 AM_
---
Hmmmm.  I guess my thinking is that having actual Grouping objects would be nice -- like, a static final constant Grouping that you reuse.
"Sorting by equivalence feels iffy to me, although I guess theres nothing strictly speaking wrong with it if its made strict?"
I'm not suggesting sorting at all -- the ordering would be by "first seen," so the first element in a new equivalence class would determine the position of that equivalence class in the ordering.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1010#c13) posted by **wasserman.louis** on 2012-05-30 at 08:45 AM_
---
Or, heck, ordering by Equivalence could just give you an arbitrary ordering of the equivalence classes.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1010#c14) posted by **em...@soldal.org** on 2012-05-30 at 08:59 AM_
---
So Iterable&lt;T> -> Iterable&lt;Grouping&lt;T>> where Grouping holds a Predicate&lt;T> composed of the Equivalence.equivalentTo(T) for the first instance of T now in another Grouping ?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1010#c15) posted by **wasserman.louis** on 2012-05-30 at 09:10 AM_
---
Wait, what?
I was thinking that Grouping would represent more of a "grouping _rule_," and then you'd call Grouping.group(iterable) and get back an Iterable&lt;Iterable&lt;T>>.  So, something like
Grouping&lt;PhoneBookRecord> SAME_PHONE_NUMBERS =
&nbsp;&nbsp;Grouping.onEquivalence(Equivalences.equals()
&nbsp;&nbsp;&nbsp;&nbsp;.onResultOf(GET_PHONE_NUMBER_FUNCTION));
Iterable&lt;Iterable&lt;PhoneBookRecord>>
&nbsp;&nbsp;peopleUsingSamePhone = SAME_PHONE_NUMBERS.group(phoneBook);
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1010#c16) posted by **em...@soldal.org** on 2012-05-30 at 09:16 AM_
---
Ah ok, gotcha.
Is the idea in the above example that Groupiing.group(Iterable&lt;T>) produces a copy? Can we work this into FluentIterable somehow?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1010#c17) posted by **wasserman.louis** on 2012-05-30 at 09:19 AM_
---
Hmmmm.  I'm not sure how I really want to deal with the strict/lazy thing; we could leave that issue as "dependent on the precise grouping," or perhaps we could split it up into different classes?  I'm not sure. =/
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1010#c18) posted by **kevinb@google.com** on 2012-06-19 at 05:34 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
**Labels:** `Package-Collect`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1010#c19) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1010#c20) posted by **cpovirk@google.com** on 2012-08-29 at 12:26 AM_
---
I think we can get 95% of the way there by handling two cases:
1) unsorted data with a key (already supported by Multimaps.index)
2) sorted data with a Comparator (to be supported)
I'm tempted to view (2) as related to issue 477, the head/tail / skip/limit / drop/take method.  Both operate on sorted data, and that data is quite possibly keyed by some field.  Building off some ideas by Tomas and Louis, a List version might look something like this:
&nbsp;&nbsp;class KeySortedList&lt;E, K> {
&nbsp;&nbsp;&nbsp;&nbsp;static &lt;E, K> KeySortedList&lt;E, K> createFromSorted(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&lt;E> elements, Function&lt;E, K> indexer, Comparator&lt;K> comparator);
&nbsp;&nbsp;&nbsp;&nbsp;static &lt;E, K> KeySortedList&lt;E, K> sortAndCreate(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterable&lt;E> elements, Function&lt;E, K> indexer, Comparator&lt;K> comparator);
```
KeySortedList<E, K> head(K toKey, BoundType boundType);
KeySortedList<E, K> tail(K fromKey, BoundType boundType);
KeySortedList<E, K> sub(
K fromKey, BoundType fromBoundType, K toKey, BoundType toBoundType);
ImmutableMultimap<K, E> index(); // unnecessary given Multimaps.index?
// access to underlying List
// potentially insertion and removal
// potentially containsKey
```
&nbsp;&nbsp;}
Iterator is basically the same except that the input must be pre-sorted and that the grouping operation is a little stranger:
&nbsp;&nbsp;class KeySortedIterator&lt;E, K> {
&nbsp;&nbsp;&nbsp;&nbsp;static &lt;E, K> KeySortedIterator&lt;E, K> createFromSorted(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterator&lt;E> elements, Function&lt;E, K> indexer, Comparator&lt;K> comparator);
```
KeySortedIterator<E, K> head(K toKey, BoundType boundType);
KeySortedIterator<E, K> tail(K fromKey, BoundType boundType);
KeySortedIterator<E, K> sub(
K fromKey, BoundType fromBoundType, K toKey, BoundType toBoundType);
UnmodifiableIterator<ImmutableList<E>> asGroupIterator();
// access to underlying Iterator
```
&nbsp;&nbsp;}
Prior art:
- We have a package-private SortedLists class that performs some operations like KeySortedList's, including its use of key-based access.
- As I noted on issue 477, we had an "OrderedIterator" class before inside Google, and it was barely used.  However, it offered none of these methods, nor did it have key-based access.
- Do these interfaces look useful?
- Do we need both List and Iterator versions?  If so, would a generic KeySorted&lt;C, K> type, where C is List&lt;E> or Iterator&lt;E>, be better or worse than two separate types?
- Is the Iterator version useful only for the heavyweight kind of iterator I don't like, the kind that's pulling data from a RPC or something?  Someone mentioned XML somewhere; I could at least pretend that the whole input string has been read and that we're merely generating nodes/events on the fly, though the argument that we need to avoid allocating O(n) memory when we're already using O(n) is less compelling.  Someone mentioned the example of infinite iterators; that's more appealing but probably not the most common case.  I can probably set my reservations here aside, but if someone has a slam-dunk example of a "normal" Iterator that benefits significantly from partitioning on the fly, it would make me feel better.
- Louis, do you think that KeySortedList would cover most of use cases provided by SortedLists's KeyAbsentBehavior and KeyPresentBehavior?  Well, obviously I've left important things out, like insertion and removal, so a fairer question is "How much more would we need to add?" or "Are there use cases that KeySortedList could never cover?"  It's not really fair to ask you to do this when I'm the one with access to the internal SortedLists users, but since you introduced the Behavior enums, you probably had a better idea than I did of where they would be used.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1010#c21) posted by **emis@google.com** on 2012-08-29 at 10:55 AM_
---
I think we should move away from the idea of grouping, grouping implies greedyness which is what we don't want. We want to retain the order of the underlying Iterable and simply partition it into chunks based on some condition, sorted or not.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1010#c22) posted by **cpovirk@google.com** on 2012-08-29 at 01:17 PM_
---
Do we have evidence that anyone is interested in an unsorted version?  As for "grouping" vs. "partition," is this exclusively a naming question, or does it go deeper than that?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1010#c23) posted by **emis@google.com** on 2012-08-30 at 07:58 AM_
---
I feel that partitioning is essentially separate from ordering. To impose an ordering would seem presumptuous to me, even though there are legitimate cases for when you wish to partition over sorted data. The problem is the ordering of elements might be difficult to represent in a meaningful way with an ordering. While its origin might understand how the data is ordered, we might not, nor should we be required to know it.
Perhaps a bit of a contrived example but its one that captures the idea pretty well; Say you have a stream of genetic base pairs, its ordering is sort of arbitrary but relevant to the functioning of the genes. You know that in many cases you will have repeated entries (stuff like; AAAAAAAAAATTTTTTTT) and you want to handle these in a single operation, partitioning on when you go from one base pair to another would be the simplest way.
I know of some legitimate use-cases for this that are less contrived, most of the time it boils down to; "The order of these elements is magical, I can process them one at a time, but I'd rather do it in bulk."
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1010#c24) posted by **cpovirk@google.com** on 2012-08-30 at 03:28 PM_
---
My fear with the package-private SortedLists class before and with the proposed methods now is the same -- that we're encouraging people to store their data in the "wrong" data structures.  Sorted data often belongs in a SortedSet; grouped data often belongs in a Multimap.  When possible, I'd prefer to provide utilities that make it easy to convert data into the more natural form (for those examples, ImmutableSortedSet.copyOf and Multimaps.index).
The question in my mind is "When is it impractical to store data in the 'right' data structure?"  I'm still trying to pin down the answer.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1010#c25) posted by **cpovirk@google.com** on 2012-09-06 at 09:40 PM_
---
To elaborate on my last comment: So far, we haven't added Iterators.head(Comparator, T), Iterators.uniqueKeys(Function), or Iterators.lastIndexOf(T).  Why?  Usually, the easiest way to handle sorted/grouped/indexed data is to put it in a sorted/grouped/indexed data structure.  The alternative is to add one-off methods with non-obvious preconditions (or to name the methods "partitionAlreadyPartitionedButNotTHATKindOfPartitioned").
To solve the preconditions problem, I'm proposing to segregate the methods that operate on sorted iterators into a separate type.  (I'm still kind of down on the iterator support in general, but I can probably live with it.)  Another advantage is that we can more easily support "keyed" data, which still sounds like the most common case.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1005) created by **jessewilson@google.com** on 2012-05-16 at 07:51 PM_
---
The problem with Java is it lacks a URI class that can manipulate query parameters properly.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1005#c1) posted by **jessewilson@google.com** on 2012-05-16 at 07:51 PM_
---
cgdecker: "I have wished that there were a better way of building URIs."
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1005#c2) posted by **ullenboom** on 2012-05-18 at 02:11 PM_
---
Enterprise developers can use the new Jersey 2.0 API. Take a look at http://jax-rs-spec.java.net/nonav/2.0-SNAPSHOT/apidocs/javax/ws/rs/core/UriBuilder.html. Jersey is the JAX-RS 2.0 RI and JAX-RS will be part of Java EE 7. Then there will be some kind of URI-manipulating API.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1005#c3) posted by **kevinb@google.com** on 2012-06-19 at 05:28 PM_
---
---
**Status:** `Accepted`
**Labels:** `Type-Addition`, `Package-Net`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1005#c4) posted by **cpovirk@google.com** on 2012-11-07 at 07:42 PM_
---
_(No comment entered for this change.)_
---
**Blocking:** #1191
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1005#c5) posted by **amertum** on 2013-01-24 at 12:24 PM_
---
Maybe you can provide different tools which integrate easily with different apps.
For example, we need a query param handler to do something like :
QueryParams.from(Map&lt;String, String[]>).get("param").firstOr("defaultValue");
QueryParams.from(Map&lt;String, String[]>).get("param").firstAsIntOr(5);
QueryParams.from(Map&lt;String, String[]>).get("param").allOr("value1", "value2");
QueryParams.from(Map&lt;String, String[]>).get("param").allAsIntOr(1, 2);
(While I'm replying to URL threads....)
I'm pretty confident that the WHATWG spec is the only spec worth following nowadays. (One of the serious problems with common.net.Uri is that it follows RFC 3986.) And while I've only skimmed over OkHttp's HttpUrl, I predict that we're now more likely to migrate Google to it (or to [some](https://github.com/smola/galimatias/blob/master/src/main/java/io/mola/galimatias/URLParser.java) [other](https://github.com/bwross/java-url-parser/blob/master/URL.java) WHATWG-based implementation, should one catch on) than to introduce our own open-source URL class. (But to throw some water on that: We're now talking a very, very small chance rather than a very, very, very small chance.)
@swankjesse , have you spoken to the people behind the spec? From what I understand, it's still a work in progress. They'd probably be happy to hear about discrepancies, or if they're aware of them, they might be able to tell us why they exist (where there are security reasons, whether browsers have committed to change their behavior, whatever).
That's the big thing (and the one that makes migrating Google's own code very difficult). Aside from giving general advice like "immutability" and "builders," I glanced over our open issues. They seem to be mostly things that Jesse has covered -- for example, better accessors like `pathSegments`. Unless we're able to investigate a bunch of time into this (which would happen late this year at best), my plan will be "assume Jesse is right about everything" :) Sorry that I don't have anything more specific for you.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1004) created by **SeanPFloyd** on 2012-05-16 at 04:34 PM_
---
The use case I have in mind is parsing HTTP query Strings.
I am using this e.g. in log file analysis tools like this:
Map&lt;String, String> queryParameters =
Splitter.on('&').withKeyValueSeparator('=').split(queryString);
However, HTTP Requests can have multiple values to the same key, so it would be even nicer to have something like this:
Multimap&lt;String, String> queryParameters =
Splitter.on('&').someMethodNameHere('=').split(queryString);
(And since there are many different types of multimaps, there should probably also be an overloaded version that takes a Supplier&lt;Multimap&lt;String, String>>)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1004#c1) posted by **wasserman.louis** on 2012-05-16 at 06:33 PM_
---
We couldn't do this if we wanted to, because it would require common.base to depend on common.collect.
---
**Status:** `WontFix`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1004#c2) posted by **SeanPFloyd** on 2012-05-18 at 07:22 AM_
---
Is that because of OSGI?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1004#c3) posted by **wasserman.louis** on 2012-05-18 at 10:54 PM_
---
No, it's Google's internal build system.
Regardless, it could produce an iterable of Map.Entrys, which could then be turned into a multimap.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=986) created by **JeffreyDamick** on 2012-05-01 at 06:39 PM_
---
Since InetAddress.getAddress produces an Inet4Address when passed a ipv4-mapped address in ipv6, it would be useful for various reasons to be able to generate an Inet6Address from that address string.  There is no clear way to do this currently in either guava or the jdk, but the building blocks are available in guava.  Attached is a patch to create an Inet6Address for this situation.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=986#c1) posted by **wasserman.louis** on 2012-05-01 at 07:36 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Enhancement`, `Package-Net`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=986#c2) posted by **pmarks@google.com** on 2012-05-02 at 02:42 AM_
---
Note that it is possible (albeit ugly) do this externally without double-parsing the string.  The pseudocode is:
"If the string contains a colon, but forString() yields an Inet4Address, then create a 16-byte array with ffff in the right spot, copy 4 bytes from the parsed address, and pass the whole thing to Inet6Address.getByAddress()."
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=986#c3) posted by **JeffreyDamick** on 2012-05-02 at 03:44 AM_
---
My usage of this is mainly due to the fact that we deal with many DNS AAAA records that hold ipv4-mapped addresses.  Converting to inet6address's provides normalization and easier comparison for manipulation, storage, etc, and then we are connecting to these addresses.  This may be a bit of a special case, however none of the formatting / normalizing methods are accessible either, so the options are ugly and limited as you point out..
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=986#c4) posted by **gak@google.com** on 2012-05-10 at 06:44 PM_
---
Paul, any thoughts on Jeffrey's response?
---
**CC:** pmarks@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=986#c5) posted by **pmarks@google.com** on 2012-05-10 at 07:36 PM_
---
Once you create the frankenstInet6Address externally, most of the existing Inet6Addresses operations should work on it, although increment() will behave oddly.
So there's not really a need for this to be in-tree, unless there's significant demand for it.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=986#c6) posted by **JeffreyDamick** on 2012-05-11 at 01:24 PM_
---
Well, if you could expose some of the underlying methods (creating the byte array) as at least protected or expose some other methods to normalize the inet6 addresses that would be useful, but at least in Inet6Address it is in consistent form.  Otherwise i suppose i can copy & paste, though that seems non-optimal..
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=982) created by **hielke.hoeve** on 2012-05-01 at 01:16 PM_
---
For our Wicket webapp we have to subclass some of guavas classes in order to make them serializable. Until so far we have had no problems, unfortunately the Joiner class is a bit of a pickle.
Because most of Joiners functions are final and its constructors are private it only allows subclasses which supplement the Joiner. I actually need the Joiner to (be able to) return a serializable Joiner.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=982#c1) posted by **wasserman.louis** on 2012-05-01 at 03:44 PM_
---
Does Wicket require everything to be serializable, or are you actually trying to send Joiners between a server and a client?
---
**Labels:** `Type-Enhancement`, `Package-Base`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=982#c2) posted by **hielke.hoeve** on 2012-05-01 at 04:36 PM_
---
Not everything, just al lot. :-)  Anything which is a local variable of a page or something down that hierarchical chain.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=982#c3) posted by **wasserman.louis** on 2012-05-01 at 04:39 PM_
---
Most users don't save Joiners at all -- they just use them inline, as in
&nbsp;&nbsp;&nbsp;return Joiner.on(", ").join(collection);
Any particular reason that's not applicable here?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=982#c4) posted by **kevinb@google.com** on 2012-05-01 at 09:47 PM_
---
FYI, there's not a specific reason it would be _bad_ for Joiners to be serializable, we've just taken a wait-and-see approach. Most joiners that aren't just in-line as Louis shows are static constants, so those don't need serialization either.
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=982#c5) posted by **hielke.hoeve** on 2012-05-02 at 05:37 AM_
---
I will add an example to show our case, if there is an alternative approach then i'm all ears.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=982#c6) posted by **hielke.hoeve** on 2012-05-02 at 08:17 AM_
---
In case you don't know how Wicket works: Wicket is a component based framework and it serializes the visited pages, meaning it also serializes all components and its fields. Components can have a Model set, which contains a suitable value for the component.
In our case we have a model which applies a function to the value of another model:
```
FunctionModel.of(employee, Employee.EmployeeOfficialFullName));
```
In a class we have defined a Function which contains a Joiner and a list of Functions which together generate an official full name of an employee:
&nbsp;&nbsp;&nbsp;public static final Function&lt;Employee, String> EmployeeOfficialFullName = new ConcatenationFunction(Joiner.on(" "), TITLE, INITIALS, MIDDLENAME, LASTNAME, MAIDENNAME);
This model is given to a Label component.
Once the page has been rendered it is serialized and of course so are its components and so is the FunctionModel. I think you where this is going, the Joiner is serialized as well. Wicket does not crash however it does give an warning. I agree that in a lot of cases a Joiner is a static constant, but in some cases it might not be desirable.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=982#c7) posted by **hielke.hoeve** on 2012-05-02 at 08:18 AM_
---
```
public static final Joiner JOINER_SPACE = Joiner.on(" ");
public static final Function<Employee, String> EmployeeOfficialFullName = new ConcatenationFunction(JOINER_SPACE, TITLE, INITIALS, MIDDLENAME, LASTNAME, MAIDENNAME);
```
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=982#c8) posted by **wasserman.louis** on 2012-05-02 at 02:11 PM_
---
...That seems odd.  Why would Wicket be sending static final constants across the wire, when they should be available on both sides?  I would only expect instance variables to be getting serialized.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=982#c11) posted by **neveue** on 2012-05-03 at 10:12 PM_
---
It's a static final constant, not an enum. I don't think Java serialization cares that the object it is going to serialize is referenced somewhere by a static final variable. That's why we have to implement readResolve() when we want to preserve the singleton-ness of a static final constant (e.g. https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/UsingToStringOrdering.java ).
That's also why I love the enum singleton pattern, which gets you singleton-ness and serialization for free. Sadly, Joiner being an abstract class, we cannot implement it using an enum :/
IIRC, Wicket does not serialize data to send it _across the wire_. The components are saved _server side_ (in session), and re-used when the next request comes in. It's a "stateful" web framework. The use of stateful components is debatable, especially when you want to scale... But it's also quite useful when developping applications (like small enterprise apps).
Serialization comes into play for clustering, and to avoid storing everything in memory (Wicket serializes the component graph, and de-serializes it when the next request comes in).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=982#c12) posted by **SeanPFloyd** on 2012-05-04 at 07:27 AM_
---
My solution would be to have an enum that supplies a Joiner
enum Delimiter{
&nbsp;&nbsp;&nbsp;&nbsp;SPACE(' ');
&nbsp;&nbsp;&nbsp;&nbsp;private final Joiner joiner;
&nbsp;&nbsp;&nbsp;&nbsp;public Joiner getJoiner(){ return joiner; }
&nbsp;&nbsp;&nbsp;&nbsp;private Delimiter(char joinerCharacter){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.joiner = Joiner.on(joinerCharacter);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;// add more overloaded constructors if you want
}
Now change the function's signature to accept the enum, not the joiner, and the serialization issues are gone.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=982#c13) posted by **gak@google.com** on 2012-05-10 at 06:41 PM_
---
We haven't been convinced that there's a good reason to make Joiner serializable quite yet.  In the meantime, the proposed workaround seems like a good way to solve the problem for Wicket.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=982#c14) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=973) created by **pettermahlen** on 2012-04-16 at 05:56 PM_
---
I have a use case where we're iterating over large files, and want to be able to (sometimes) continue processing the file in spite of errors for single entries. In that regard, there are two problems with the current AbstractIterator implementation:
1. Any exception (from, for instance, being unable to parse the next entry in the file) will be thrown from the hasNext() method, making it impossible to write
while (iterator.hasNext()) {
&nbsp;&nbsp;try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterator.next();
&nbsp;&nbsp;}
}
1. Once an exception has been thrown, the AbstractIterator will be in State.FAILED, meaning that no further processing can happen.
I've modified (and renamed) the AbstractIterator class as shown here: https://gist.github.com/2400295. Does this seem like a useful feature?
In implementation terms, I'm not sure that the mechanism of storing exception to wrap+rethrow later is that great, but it's the best I could think of.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=973#c1) posted by **kevinb@google.com** on 2012-04-16 at 06:36 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
**Labels:** `Type-Enhancement`, `Package-Collect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=973#c2) posted by **cpovirk@google.com** on 2012-05-10 at 07:45 PM_
---
Iterators generally aren't expected to throw exceptions except in the case of programmer error, after which it's typically not possible to forge ahead with the remaining elements.  Deviating from this may be useful on occasion, but I'd be nervous "endorsing" it by providing library support, particularly when our other Iterator utilities are likely to interact poorly with such an Iterator.
That said, I'm sympathetic to the idea of a nice, common interface to "heavier" streams than what Iterator is used with, and we've had various internal discussions about a "CheckedIterator."  It could solve a number of problems:
- hasNext()/next(), as check-then-act API, is poor for multiple client threads.
- The methods could be made into proper blocking methods, with optional support for interruption and timeouts.
- The interface might be parameterized on an exception type as well as on a value type so that the methods can declared "throws X" instead of a generic "throws Exception."
- The underlying operation may require a close() call at the end, and we could provide separate utility methods that make this harder to forget (and that know what to do in the case of an exception, as I described earlier, and in the case of an interruption/timeout).
- The type won't look like an Iterator (as described above), and there will be less temptation to make the producer look like an Iterable, as initializing the stream may be expensive (and perhaps initializing it multiple times is outright impossible).
We may one day add such a type, but it's far off.  As far as this issue goes, I would suggest any of:
1. Wait for us.  (But we're talking months to years of waiting, so I recommend against it.)
As for this issue, I could generalize it to be about CheckedIterator, or you could make a renewed pitch for your class, or we could close it.  Any preferences?  In any case, thanks for the submission.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=973#c3) posted by **pettermahlen** on 2012-05-11 at 07:27 AM_
---
I agree completely with your comments. I never felt really comfortable that the Iterator implementation I submitted doesn't properly support foreach(), for one thing. So the fit isn't ideal and I don't really want to make a pitch for that class.
As for the issue, I have no preferences, feel free to close it or generalise it. Thanks for the thoughtful evaluation!
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=973#c4) posted by **cpovirk@google.com** on 2012-05-11 at 01:47 PM_
---
I think I got most of it, but here are a few other things that people have pointed out:
- Probably we don't need remove().
- The close() method should be part of implementing Closeable so that, under JDK7, the iterator can be used with "try with resources."
- The interface might look a lot like Queue (but without the insertion methods) if we want full generality.  (Possibly it would also benefit from methods like those in Uninterruptibles.)
Now that I've dumped all that here, I might as well repurpose this bug for anything that you or others have to add.  (We still probably won't get to it any time soon, but we might someday, and even if we don't, any discoveries might be useful to others writing their own.)
---
**Labels:** -`Package-Collect`, `Package-Concurrent`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=973#c5) posted by **pettermahlen** on 2012-05-14 at 12:47 PM_
---
Your description - as well as my own use case - makes me wonder about the name of the type/s. If it's not an iterator, it should probably not be called anything to do with Iterator as that is a very specific and strong concept in Java.  I was thinking about alternatives that are closer to Queue, such as Sequence/Succession/Series, when it struck me that what I want it for is a producer/consumer scenario, and it sounds like that's what you're describing too. So maybe Producer is a better name? It feels like it will be something that will be able to give you some undetermined/undeterminable number of things until it runs out, and then it should be closeable, which matches a Producer pretty well. I was also thinking about Generator (as it sounds a little like Iterator), but when I came up with Producer, I liked that better.
With the above reasoning, the main differences between a Producer and a Queue would be:
- No visibility of the producer side - no methods for adding things.
- The ability to explicitly close it, so it would have a lifecycle.
- Less ability to manipulate the queue - no checking of anything but the head, no removal (but then remove would be the same as next + discard).
It would be more limited and more focused. I think I would rather use an interface like that than a regular Queue in the case I've got, but I'm not sure if it's different enough.
Regarding the exception handling, I was wondering if it might be a good idea to have different versions of the interface, something like:
public interface ThrowingProducer&lt;T, E> extends Closeable {
&nbsp;&nbsp;&nbsp;T next(long timeout, TimeUnit timeUnit) throws InterruptedException, E; // etc.
}
public interface UninterruptibleThrowingProducer&lt;T, E> extends ThrowingProducer&lt;T, E> {
&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;T next(long timeout, TimeUnit timeUnit) throws E; // removes InterruptedException from the method signature.
}
public interface Producer&lt;T> extends ThrowingProducer&lt;T, Exception> {
&nbsp;&nbsp;// no E, meaning you get one less checked exception to deal with.
&nbsp;&nbsp;&nbsp;@Override
&nbsp;&nbsp;&nbsp;T next(long timeout, TimeUnit timeUnit) throws InterruptedException;
}
For the uninterruptible version, it would be easy to wrap an interruptible Producer with something that forwards the call like the methods in Uninterruptibles do:
public class Producers {
&nbsp;&nbsp;&lt;T> UninterruptibleProducer&lt;T> uninterruptible(Producer&lt;T> toWrap) {
&nbsp;&nbsp;&nbsp;&nbsp;return new UninterruptiblyForwardingProducer(toWrap);
&nbsp;&nbsp;}
}
I don't like the combinatorial explosion of interfaces, but I also don't particularly like the idea of having four versions of each method in the API: no timeout, explicit timeout, uninterruptible without timeout and uninterruptible with timeout. And I somehow would prefer not to keep adding methods to the Uninterruptibles class as well.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=973#c6) posted by **cpovirk@google.com** on 2012-05-14 at 06:59 PM_
---
You may be right about distancing this from the "Iterator" name.  "Producer" happens to have some Google-internal baggage, but maybe "Generator" is the way to go.
Exception-handling: Hmm.  We've tried to stay out of the business of UninterruptibleFoo after a mildly bad experience with UninterruptibleFuture, preferring instead the Uninterruptibles.fooUninterruptibly methods (or, on occasion, foo and fooUninterruptibly methods both on the interface itself).  That's partially because of the combinatorial explosion that you mention.
- Throw ExecutionException, as in Future and Cache.  Maybe provide wrappers along the lines of Futures.get(Cache, Class<? extends Exception>).
- Throw a generic type (as we've discussed so far).
If we go with the latter, I'm inclined to give the short name ("Generator" or whatever, rather than "ThrowingGenerator") to the parameterized type, and I'd probably skip a subtype for &lt;RuntimeException>, both because users probably don't have to write it more than once and because this "typedef" pattern isn't as seamless as a real typedef (notably, you can't assign a ThrowingGenerator&lt;E, RuntimeException> to a NonThrowingGenerator&lt;E>).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=973#c7) posted by **kevinb@google.com** on 2012-05-15 at 03:08 PM_
---
Agree to avoid "iterator" in the name.  Consider Source&lt;T> (or Source&lt;T, X>).
Null shouldn't be supported. Null return from next() should definitively mean end of stream.
Let's consider only the throwing case. (e.g. call ThrowingProducer just Producer, or whatever).
Should we consider adding the same goodies we have on FluentIterable directly to this?
---
**Status:** `Accepted`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=973#c8) posted by **em...@soldal.org** on 2012-05-15 at 09:18 PM_
---
Source makes me think it will be related to Sink from the hashing package...
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=973#c9) posted by **kevinb@google.com** on 2012-05-16 at 06:42 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=973#c10) posted by **pettermahlen** on 2012-05-30 at 03:13 PM_
---
I haven't been able to find any contiguous time to work on this yet, but I've been thinking a little about it every now and then. One thing that I'm struggling with is clearly defining the rationale for the Producer - the discussion has been very much in terms of what features and behaviours are desirable, but not so much yet about why and what use cases to support, or why those use cases can't be handled by existing abstractions.
Here's our use case (which repeats with some variation in a couple of different services) with a little more detail than in the original issue:
1. We need to parse and process files that are too large to fit in memory.
2. The data in the files is unreliable, but we want to be able to use all the data we can parse, and report on the rest.
3. We want to be able to report syntactical and semantic errors (detected during processing) using the same logic.
4. Processing may be slow and may require external service calls, hence concurrent processing of parsed entries would be useful to reduce total processing latency.
So, a Producer (I personally like that name best, and not being a Google employee, I'm happy to disregard Google-internal baggage ;) - if that's unrealistic, my second choice would be Source, I think) as discussed up to this point would be a perfect fit. The Producer could do the parsing, and would simply throw a ParseException for bad entries. Later validation can also report errors, and something at the top can collect the information and aggregate and report it.
It would be interesting to get some input about other use cases.
- It doesn't define how things are produced, unlike a BlockingQueue.
- It can throw exceptions, unlike BlockingQueue and Iterator.
- It is intended for concurrent usage, unlike Iterator.
- It defines a lifecycle (implements Closeable), unlike BlockingQueue and Iterator. I think there's another lifecycle aspect in that if null is used to signal 'end of stream', then once a Producer has returned null, it should return null for all subsequent requests.
- The 'remove' operation as defined in Iterator doesn't make sense: I think the Producer should define about three ways to interact with it: next(), peek() and hasData(), where the first two are blocking and would have versions with timeouts, and the last is non-blocking. next() removes the next entry, whereas peek() just inspects it. Another option for peek() is to make it throw a NoSuchElementException, like BlockingQueue.element(), if there is no data. The point of the hasData() call would be to give consumers some approximate idea about whether they will have to wait or not for new data, which might be useful for instrumentation of an application.
In terms of our use case, the desire to collect statistics about individual entries using a single mechanism is what drives the need to throw exceptions, and is the main thing that makes it less than ideal to use a queue or iterator. There are adequate ways around the concurrent consumers and lifecycle management aspects, I think, although it would be somewhat nicer to have that baked into the abstraction.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=973#c11) posted by **wasserman.louis** on 2012-05-30 at 03:34 PM_
---
I guess I must admit that I'm not sure how generally applicable this kind of thing would be.  It feels to me more like it might be better modeled as a stream processing sort of thing than an iteration thing?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=973#c12) posted by **kevinb@google.com** on 2012-05-30 at 07:45 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=973#c13) posted by **pettermahlen** on 2012-05-31 at 08:10 AM_
---
Obviously, I also have doubts about general applicability - but I don't quite understand what you mean by stream processing as opposed to iteration. How would that look?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=973#c14) posted by **wasserman.louis** on 2012-05-31 at 08:45 AM_
---
I'm not...quite sure yet, but the description of your application reminds me _extremely_ strongly of Haskell stream processing abstractions and iteratees.   Honestly, I don't understand that abstraction especially well myself at the moment, but...what I do know is that it's a very powerful abstraction for incremental, composable, and parallel parsing and processing operations, which sounds very much like your use case.
I don't know how much of it could be translated over to Java, but if we're hunting for abstractions to match this use case, there may be some ideas worth stealing there.
After this morning, I'll have the free time to do some more research, but if you're interested, the best sources I've located are probably
http://themonadreader.wordpress.com/2010/05/12/issue-16/ pages 19-36 (from the Monad.Reader, a sort-of-journal; this is a gentler introduction than Oleg's page)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=973#c15) posted by **wasserman.louis** on 2012-05-31 at 08:55 AM_
---
Other things that immediately pop out of those pages that seem appropriate to this discussion:
&nbsp;&nbsp;\* "all iteratee errors are hence potentially restartable"
&nbsp;&nbsp;\* "incremental processing of a single stream by several consumers in parallel" -- this doesn't refer to parallelism per se, but doing several independent operations over the same stream, but I nevertheless suspect that "parallelism" in the sense of multiple asynchronous operations could be worked in there.
Anyway, I'm going to play around with this some after this morning, even if it's entirely possible I'm on crack, and overkilling the problem.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=973#c16) posted by **pettermahlen** on 2012-08-24 at 01:49 PM_
---
I've had a further look at this problem now, and I have some more opinions. First, I've changed my mind about the use of the name Producer - Producer/Consumer is about having (possibly) multiple producers that hand over work to multiple consumers. This discussion has been more about making it possible for multiple things to read from a single source (there you go), and process the contents they read. I don't think there's much generic value to be added on the producer side of things in that scenario, but there might be on the processing side. The producer side is, I think, very problem-specific. I also think that (at least in our case), the preferred solution in a multi-threaded application would be to have the processing-side threads pull stuff out of the producer; that is, consumer-side threads executing code on the producer side of the API. If so, there would be no need for InterruptedException, timeouts, etc. It seems like producers pushing things means you have to have a queue, and there's already a perfectly good API for that in the JDK.
On the processing side of things, there might be some more generally applicable things to do. Maybe having something like a reversed Callable (Invokable? Processor?) whose single method would be 'void invoke(T parameter)', and some code for fluently wiring up a source and some processors with specified amounts of parallelism, etc.
I played around with adapting our code based on those insights, but I don't think there's enough payoff in changing it, so I'll have to keep squirming a little in my seat every time I look at the iterator-based code that shouldn't have been iterator-based... At least it works, and I think I learned something in the process. :)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=973#c17) posted by **cpovirk@google.com** on 2013-08-20 at 06:56 PM_
---
_Issue #1511 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=973#c18) posted by **michael.deardeuff** on 2014-02-28 at 03:06 AM_
---
I think this issue would probably duplicate the work of the RxJava, though the contract of RxJava is push-based instead of pull-based like an Iterator.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=971) created by **wasserman.louis** on 2012-04-15 at 02:31 PM_
---
http://stackoverflow.com/questions/10153724/google-guavas-cacheloader-loadall-vs-reload-semantics motivated the question of how one could do efficient bulk refreshes, if LoadingCache.getAll discovered many entries eligible for refresh.
There's clearly a sensible default implementation -- just do the asynchronous refreshes concurrently, as it's done now -- but I'm curious if it might merit its own method that can be overridden, and if that'd overly complicate the already-rather-complex Cache semantics.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=971#c1) posted by **fry@google.com** on 2012-04-18 at 07:19 AM_
---
This raises the interesting point that currently getAll/loadAll doesn't trigger refresh if a custom loadAll implementation is provided.
I agree that with a custom loadAll method it would be somewhat tragic to trigger hundreds of independent refreshes. So maybe this is arguing for CacheLoader.reloadAll.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=971#c2) posted by **wasserman.louis** on 2012-04-22 at 05:42 PM_
---
I have to admit that I find it surprising that getAll doesn't trigger refreshes -- and I suspect users would, too...
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=971#c3) posted by **kevinb@google.com** on 2012-05-30 at 07:45 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=971#c4) posted by **outdooricon** on 2012-09-11 at 03:27 PM_
---
"getAll/loadAll doesn't trigger refresh if a custom loadAll implementation is provided."
Really glad that I read this... I haven't seen this documented anywhere. As a user, I definitely expected a refresh. I'm using loadAll to populate multiple entries in the cache using only a single db call. This is my use-case for needing a reloadAll as well...
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=971#c5) posted by **kevinb@google.com** on 2012-11-09 at 11:21 PM_
---
_Issue #1201 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=971#c6) posted by **kevinb@google.com** on 2012-11-09 at 11:23 PM_
---
Charles and I like this plan now: After getAll() determines which keys we already have in the cache, it could check which of those are already stale, and include those in the set it queries.  If any of those don't happen to come back, we still use the stale values for those.
---
**Status:** `Accepted`
**Labels:** -`Type-Addition`, `Type-Defect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=971#c7) posted by **kevinb@google.com** on 2013-03-12 at 06:43 PM_
---
_(No comment entered for this change.)_
---
**CC:** fry@google.com
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=964) created by **xaerxess** on 2012-04-06 at 07:12 AM_
---
Can CharMatcher be taken out of @Beta? Table interface is in Guava since r07 and is out of @Beta; CharMatcher on the other hand is here from version 1.0 and major changes were only JAVA_WHITESPACE removal in v11.0 and matchesAnyOf addition in r08.
I use it extensively in my production code and I believe it's widely used by other people as a replacement for Apache Commons StringUtils etc. Could it be officially announced as non-@Beta in v12.0 / v13.0?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=964#c1) posted by **wasserman.louis** on 2012-04-09 at 03:49 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Task`, `Package-Base`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=964#c2) posted by **wasserman.louis** on 2012-04-20 at 04:32 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=964#c3) posted by **cpovirk@google.com** on 2012-04-23 at 03:09 PM_
---
We're likely to remove more constants, but we could compromise by leaving the constants as @Beta while graduating the rest of the class.  As for Unicode changes, we'll continue to make them as the standard evolves, but I don't think we'll consider this an "API change" that would block graduation from @Beta.
---
**CC:** kevinb@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=964#c4) posted by **kevinb@google.com** on 2012-05-02 at 02:48 PM_
---
We have an internal document describing what's needed to make CharMatcher unicode-sane.  I don't want to make any de-betafication that would prevent those things from happening, but if there's some portion of the debetafication we can do now anyway, that would be swell.
---
**Status:** `Accepted`
**Labels:** -`Type-Task`, `Type-Enhancement`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=960) created by **glenviewjeff** on 2012-04-04 at 04:12 PM_
---
From my tests (later below), EventBus cannot notify default access or private @Subscribe methods, and doesn't throw an exception if one exists.  According to the lone example in the wiki documentation, default access is acceptable for @Subscribe methods.
If you have reasons for not doing either of the above, I think Guava should throw a runtime exception if it encounters a private/default @Subscribe method.
&nbsp;&nbsp;&nbsp;EventBus eventBus;
&nbsp;&nbsp;&nbsp;@Before public void setUp() throws Exception {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eventBus = new EventBus();
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;class OnNotification {}
&nbsp;&nbsp;&nbsp;static class Notified {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public boolean notified = false;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Notified(EventBus eventBus) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eventBus.register(this);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
```
@Subscribe public void onNotification(OnNotification onNotification) {
notified = true;
}
```
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;@Test public void test() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Notified notified = new Notified(eventBus);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assertFalse(notified.notified);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eventBus.post(new OnNotification());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assertTrue(notified.notified);
&nbsp;&nbsp;&nbsp;}
}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=960#c1) posted by **glenviewjeff** on 2012-04-04 at 04:13 PM_
---
If it's not already obvious, to see the bug, change onNotification's access to default or private to see the failures.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=960#c2) posted by **glenviewjeff** on 2012-04-04 at 04:28 PM_
---
Also, if it's not already obvious, the wiki code with the apparent bug is the recordCustomerChange method below, from http://code.google.com/p/guava-libraries/wiki/EventBusExplained.  This cost me an hour or two because I was debugging on Android.
class EventBusChangeRecorder {
&nbsp;&nbsp;@Subscribe void recordCustomerChange(ChangeEvent e) {
&nbsp;&nbsp;&nbsp;&nbsp;recordChange(e.getChange());
&nbsp;&nbsp;}
}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=960#c3) posted by **wasserman.louis** on 2012-04-25 at 06:05 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Enhancement`, `Package-EventBus`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=960#c4) posted by **george.h...@beta-engine.net** on 2012-08-15 at 04:27 PM_
---
I don't have a strong opinion on the visibility rules. If the Guava team feels that only methods that are returned by Class.getMethods() should be subscribable that's fine.
But I do think it should be flagged as an error if you attempt to register something for which no subscribable methods could be found.
Maybe some kind of tooling that wants to do some automated scan and register operation at the startup of an application might like this feature (I'm thinking of the kind of stuff that typically happens on startup of an application that's wired up with Spring).
At the very least register could return the boolean value that is returned by the handlersByType.putAll(Multimap) call it makes. Seeing the false value returned when you tried to register something without subscribable methods would be a start.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=960#c5) posted by **cgdecker** on 2012-08-15 at 04:43 PM_
---
There are lots of reasons you might do that. For one example, in my previous job we had a UI with tabs that could be opened and closed. All tabs were automatically registered with the EventBus on opening and unregistered on closing, even though only a couple types of tabs might have had handler methods on them. Because of that, adding handling for an event to a tab was just a matter of adding an @Subscribe method to it, regardless of whether it had one previously or not. I know that there are people using Guice who automatically register objects with an EventBus, allowing them to easily subscribe to events in any class in their system. Anyway, I think this is a very important usage pattern to support and pretty core to the design of the event bus.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=960#c6) posted by **wasserman.louis** on 2012-08-15 at 05:27 PM_
---
+1 for that use case.  The idea to use injection frameworks to register _everything_ with an EventBus, subscriber or not, seems to me to be a really cool bonus to an elegant API.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=960#c7) posted by **george.h...@beta-engine.net** on 2012-08-16 at 08:07 AM_
---
Umm... I would point out that the question "why would you pass random objects with no subscribable methods to register?" was in some way rhetorical. I do, on the next line, suggest an example of where this feature might be useful - in some kind of IOC setup.
At the very least people should be given some mechanism to see whether anything was registered or not. Personally I'd prefer a method that threw an exception if the object passed in had no subscribable methods.
But returning a boolean might be an OK compromise - people who wanted could check it while everyone else could continue to use register(Object) as they do today - without any real impact on the "elegance" of the API.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=960#c9) posted by **ClovisSeragiotto** on 2014-09-03 at 12:19 PM_
---
According to the documentation
@Subscribe private void method() {}
"Immediately upon invoking register(Object) , the listener being registered is checked for the well-formedness of its handler methods. Specifically, any methods marked with @Subscribe must take only a single argument."
So at least the documentation should be fixed.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=960#c10) posted by **cgdecker@google.com** on 2014-09-03 at 06:34 PM_
---
As it stands right now, in Guava 19 EventBus _will_ be able to register non-public @Subscribe methods. That could change between now and the release, but if it does we'll make sure that it at least throws an exception.
---
**Labels:** `Milestone-Release19`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=960#c11) posted by **cgdecker@google.com** on 2014-09-03 at 06:36 PM_
---
_Issue #1766 has been merged into this issue._
This is fixed. Private and package-private methods can be subscribed, and you'll get an error if you try to register a private `@Subscribe` method that isn't a valid subscriber method (e.g. not exactly 1 parameter).
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=956) created by **wasserman.louis** on 2012-04-02 at 04:07 PM_
---
I think we must have discussed this method when I was building common.math, but I can't remember why/if we decided against it.
In either event, if people are interested in it or want to discuss it, here's an issue to do so in.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=956#c1) posted by **kevinb@google.com** on 2012-04-03 at 05:47 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=956#c2) posted by **kevinb@google.com** on 2012-05-30 at 07:45 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=956#c3) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
I'm a bit confused by this request?  The intent of this bug was rounding to integer-valued doubles, just as with the other rounding methods.
---
I'm really not sure how to offer this criticism, but it seems like the decision of if a handler should execute synchronously or asynchronously is better known by the handler itself than the event bus.
For example, if I am updating an audit system and an index based on a change, I might want the former synchronous and the latter asynchronous.  In the current design, I could (1) have two event busses, and post the  event to each, or (2)  queue the event onto a thread inside the index's handler.
Although both approaches are workable, neither seems ideal.  Taking inspiration from the AllowConcurrentEvents annotation, how do you feel about an AsynchronousEvents annotation?  It does seem consistent with the rest of your API.
As an implementation aside, you can see how AnnotatedHandlerFinder#newHandler() might be enhanced to return an AsynchronousEventHandler -- although that might require Executor be pushed down.  Another way to think about is is to consider AsyncEventBus as nothing more than a custom HandlerFindingStrategy that returned AsynchronousEventHandlers be default.
If this enhancement request does not fit your vision for the package, perhaps you'd consider allowing the HandlerFindingStrategy to be configured publicly?  Since I'm offering my opinion, I'll say this is the less exciting option to me.
I fully expect that this has already been much discussed internally.  A discussion of your rationale would still benefit the community.
Thanks very much for your work releasing this library.
-dg
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=951#c1) posted by **kevinb@google.com** on 2012-03-30 at 03:56 PM_
---
My opinion does not reign supreme on eventbus questions, but:
I agree that your alternatives are workable, and that when you're in the case you happen to be in, they seem un-ideal.  But what we like about them is that they preserve the simplicity and clarity of how EventBuses operate.  This package is one where we think it's very important to strike the right compromise between power and simplicity, and I'm personally pretty happy with how we've got it.  The last thing I ever want to see is for a series of well-intentioned changes to wind up making it start seeming more like a "framework" than a library.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=951#c2) posted by **wasserman.louis** on 2012-04-03 at 04:25 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Enhancement`, `Package-EventBus`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=951#c4) posted by **em...@soldal.org** on 2012-05-05 at 12:19 AM_
---
I had a post on here earlier which I retracted because I think it was false. As I understand it (and I'd love some feedback on this). AsyncEventBus handles the individual event handlers in seperate threads, but each handler (that is, each subscribing method) will be called synchronously, if you wish for the methods themselves to also be calles async then you must annotate them with @AllowConcurrentEvents
If we could get this clarified that'd be great.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=951#c5) posted by **kevinb@google.com** on 2012-05-30 at 07:45 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=951#c6) posted by **dstovall** on 2014-02-28 at 04:23 PM_
---
Besides Sync v. Async, the handler may also like to request a specific thread (or thread group or executor or ...).
To extend the use case above, I would like to support three handlers:
Handler 1) A synchronous handler to update the audit record
Handler 2) An asynchronous handler to reindex
Handler 3) An EDT handler to update a Swing component
This seems to be very parallel to AllowConcurrentEvents.  If you allow a handler to denote that it is thread-safe, wouldn't it be similar for a handler to say "I'm not thread-safe, actually I need to be called from _this_ thread".
Handlers 2 & 3 can certainly re-dispatch the event, but that results in a lot of boilerplate code.  Exactly the "tiny anonymous classes" that the EventBus documentation refers to, and code is very similar to the behavior provided by EventBus.
Since I know it will come up, there are suggestions out on the internet to create multiple EventBuses for listeners to register with.  The EventBuses are then chained together or hidden behind a proxy. There are three issues that are immediately apparent to me:
1) This (always?) ends up disabling DeadEvents or duplicating DeadEvents (depending on implementation).
2) Whomever is registering the listeners has to know which Bus to register with.
3) All handlers on the listener will be dispatched the same way.
Now, all that said... I really like the simplicity of the current API.  Since documentation specifically cites the Swing pattern, I anticipate that the EventBus authors have a recommended approach/solution for using EventBus with Swing.  Whatever that approach is may be generalizable...
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=951#c7) posted by **cgdecker@google.com** on 2014-06-26 at 09:53 PM_
---
_Issue #1536 has been merged into this issue._
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=938) created by **drewmark** on 2012-03-15 at 06:30 PM_
---
Please make AbstractStreamingHashFunction and AbstractNonStreamingHashFunction more visible (like protected or public) so that they can be extended by guava users.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=938#c1) posted by **kak@google.com** on 2012-03-15 at 06:36 PM_
---
Any thoughts Dimitri?
---
**Status:** `Acknowledged`
**Owner:** andreou@google.com
**Labels:** `Type-Enhancement`, `Package-Hash`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=938#c2) posted by **andreou@google.com** on 2012-03-15 at 07:52 PM_
---
The practical reason was that designing for inheritance is just hard, and we (or I) were a bit lazy to properly do it. This may me amended in the future, of course
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=938#c3) posted by **drewmark** on 2012-03-15 at 08:56 PM_
---
I was thinking of implementing one or more locality-sensitive-hashing algorithms.  Either way, it seems like you should allow others to easily extend what you've done.  Doing so will encourage others to use your framework and will allow them to implement algorithms that may not be general-purpose enough to warrant inclusion.  Thanks!
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=938#c4) posted by **wasserman.louis** on 2012-03-15 at 09:08 PM_
---
The question, I suppose, is whether or not extensibility of the hashing utilities is a sufficiently common need or desire to merit the nonnegligible effort involved in redesigning and maintaining the package for inheritance.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=938#c5) posted by **andreou@google.com** on 2012-03-15 at 09:19 PM_
---
I rather disagreed with even exposing HashCode's constructors, at least at this stage. I mean, right now, HashCode means that it was produced by one of the high-quality algorithms we expose. When it is a free for all (and one can say, e.g., HashCodes.forInt(5)), this meaning will be dilluted. But perhaps it doesn't matter much
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=938#c6) posted by **drewmark** on 2012-03-15 at 09:40 PM_
---
What I'm suggesting doesn't require redesigning the package (read API) for inheritance.  I'm suggesting that implementors be given the _option_ of extending these abstract classes.  Nothing about the code would force anyone to use them if they preferred to implement the entire interface themselves (or needed to do so for some reason).  This avoids much of what people deem "bad" about inheritance.  If you disagree, please spell out what's hard and/or concerning about this.
As for making it a free for all, it goes without saying that if you implement your own anything in a dumb way you're going to get dumb results (even if you use it with a high-quality library).  I don't think that argument has much merit.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=938#c7) posted by **wasserman.louis** on 2012-03-15 at 09:48 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=938#c8) posted by **kevinb@google.com** on 2012-03-16 at 01:47 AM_
---
"It's much more important to make it _easy_ to do the _right_ thing, than to make it _hard_ to do the _wrong_ thing."
and
"Don't get into the business of manufacturing kevlar boots."
Extendable classes are just fragile and pain to document, and become harder to change.  It'll take some thought.  I'm inclined to do it though.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=938#c9) posted by **andreou@google.com** on 2012-03-16 at 02:18 AM_
---
The big task here is AbstractStreamingHashFunction#AbstractStreamingHasher. And that relies on ByteBuffer, so exposing these classes, would either mean committing to it, or warning users with big bold font that we may break their implementations in the future (or keep this as dead code, if we ever move away from it).
I don't think anyone of us is very confident to relying on ByteBuffer forever. The only thing going on for it is that it was (relatively) easy to implement. And let's not forget we still have some performance work to do there, which is not entirely clear whether it can be done without breaking subclasses or not (we might be able to get away with it, but someone has to work the details out to know for sure).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=938#c10) posted by **kevinb@google.com** on 2012-04-03 at 05:13 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Accepted`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=938#c11) posted by **kevinb@google.com** on 2012-05-30 at 07:45 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=934) created by **electrum** on 2012-03-12 at 11:08 PM_
---
It would be useful to have a version of readFully that returns a byte array, rather than forcing me to manually allocate it first:
```
public static byte[] readFully(InputStream in, int size) throws IOException {
byte[] bytes = new byte[size];
readFully(in, bytes);
return bytes;
}
```
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=934#c1) posted by **wasserman.louis** on 2012-03-12 at 11:12 PM_
---
Counterproposal: just make the current readFully(byte[]) return the byte[], so you can do
byte[] array = readFully(new byte[size]);
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=934#c2) posted by **fry@google.com** on 2012-03-13 at 07:13 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=934#c3) posted by **fry@google.com** on 2012-03-13 at 07:13 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Accepted`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=934#c4) posted by **kevinb@google.com** on 2012-03-16 at 09:19 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=934#c5) posted by **kevinb@google.com** on 2012-06-22 at 06:57 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-IO`
Sadly, adding a return type to a previously void method is not binary compatible:
"confirmed that it's binary incompatible because the bytecode descriptor of a method includes its return type: http://stackoverflow.com/questions/3589946/retrofitting-void-methods-to-return-its-argument-to-facilitate-fluency-breaking "
That's a lot of churn just to avoid 2 extra lines of code IMHO.
IIRC, we're planning to still delete classes only under our usual deprecation policy (waiting 2 years for non-`@Beta`, etc.).
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=932) created by **j...@nwsnet.de** on 2012-03-12 at 07:40 PM_
---
Said function uses the value of the system variable "java.io.tmpdir" as base path. It would be handy, however, if one could supply a custom, application- and even functionality-specific base path without modifying the system variable (on which other parts of an application might depend, but whose temporary data should stay separated).
By specifying a custom base path, one could isolate data an application part writes and. Reasons to do this include the suitability of the underlying hardware and file system (available disk space, file system choice/flags/parameters, I/O throughput), access control, and simplified debugging as only the files related to that functionality are in that path.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=932#c1) posted by **cpovirk@google.com** on 2012-03-12 at 09:30 PM_
---
File.createTempFile has this (though it also supports a prefix and suffix, which we don't support).  Seems reasonable enough to me...?
---
**Labels:** `Package-IO`, `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=932#c2) posted by **j...@nwsnet.de** on 2012-03-13 at 09:43 AM_
---
To explain the background of the reasons I mentioned above: I am of course referring to multiple available mount points (Unix environment)/"drives" (Windows) which use different file systems on different virtual or physical volumes. Some may be better suited for, say, big, mostly static, write-once/read-many files while others might be better suited for tiny files that are overridden/data is appended to often etc. (you get the idea).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=932#c3) posted by **fry@google.com** on 2012-03-13 at 07:10 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=932#c4) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
---
I think Files.createTempDir should be parallel to java's File.createTempFile, allowing both prefix, suffix and baseDir override.
The purpose of createTempDir is to provide a safe way to avoid the createTempFile-delete-recreateDir pitfall, but it's a shame it's limited as it is.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=927) created by **electrum** on 2012-03-09 at 07:58 PM_
---
The new HttpHeaders and MediaType classes are great!  Can we get a similar HttpStatusCodes class?  The JAX-RS Response.Status class could be a good starting point.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=927#c1) posted by **kak@google.com** on 2012-03-09 at 08:02 PM_
---
We have something like this internally, but it'll need quite a bit of API-lovin' before we can even consider releasing it.
---
**Status:** `Acknowledged`
**Owner:** kurt.kluever
**Labels:** `Package-Net`, `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=927#c2) posted by **kevinb@google.com** on 2012-05-30 at 07:45 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=927#c3) posted by **trejkaz** on 2012-06-13 at 02:14 AM_
---
I was just thinking that this would be nice and it looks like I'm not the only one. :)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=927#c4) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=927#c5) posted by **alexande...@teamdev.com** on 2013-08-25 at 09:09 AM_
---
Yes, something like http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/http/HttpStatus.html
would be nice.
The only issue is that we're not sure what the best design is:
a file with a bunch of static int's?
a full fledged class with static instances?
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=913) created by **mirko.teran** on 2012-02-29 at 06:54 PM_
---
Is there a chance you could add a method into Cache to invalidate keys/entries based on given Predicate&lt;Key>?
I usually use compound objects as keys and it would be great if there was a way to remove all entries based on some criteria. I believe Predicate&lt;Key> suits this role perfectly.
For now I've made a workaround to use asMap().keySet() but its just to crude.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=913#c1) posted by **fry@google.com** on 2012-02-29 at 06:58 PM_
---
That's exactly what our code would look like too. I don't see a problem with that. :-)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=913#c2) posted by **wasserman.louis** on 2012-02-29 at 07:07 PM_
---
cache.invalidateAll(Sets.filter(cache.asMap().keySet(), keyPredicate));
Seems perfectly good to me.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=913#c3) posted by **mirko.teran** on 2012-03-01 at 06:35 AM_
---
OK - I'll just keep my code as it is.
You can close/remove the issue.
Thank you!
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=913#c4) posted by **fry@google.com** on 2012-03-01 at 02:36 PM_
---
_(No comment entered for this change.)_
---
**Status:** `WorkingAsIntended`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=912) created by **jor...@knewton.com** on 2012-02-29 at 06:40 PM_
---
The Sets class has static utility methods that create immutable views of the result of set operations on multiple sets.
It would be nice if there were similar methods for Maps. There already exists a map difference method.
For example, there could be a map union method that returns a new map whose entry set is the union of the entry sets of the input maps. Something would have to be done if the input key sets had a non-null intersection: the method could fail, or it could return a Multimap that contains multiple values for a key if the key was repeated across the input key sets.
This functionality is something that I use fairly commonly. I imagine it would be useful for others as well.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=912#c1) posted by **wasserman.louis** on 2012-02-29 at 07:06 PM_
---
Jordan, could you give us some more details on where exactly you've found yourself using this method -- an actual use case, with context and details?  That'd really help us get a better sense for when this method would actually get used.
Should this be strict -- making an explicit copy -- or a view?  (Sets.union and Sets.difference are SetViews, which are views with a built-in fluent "copy-into" syntax; Maps.difference constructs an explicit copy.)
Explicit copies have the advantage that they're much more difficult to shoot yourself in the foot with -- the performance costs are all up front, and obvious, whereas if you pass a Maps.union view to some other method, you can quickly build up lots of hidden costs.  (For example, imagine someone doing Maps.union(map1, Maps.union(map2,..)) for a hundred iterations, if Maps.union was implemented as a view.  Queries to the resulting map are now slowed down by a factor of 100, but that fact might not be obvious to the programmer!)
What the return type should look like is...also tricky.  I might be willing to get behind a Maps.disjointUnion that throws up when you pass it maps with intersecting key sets, but it feels like that addresses a much narrower use case.
One option that occurs to me -- that I _really_ like -- is to provide
&nbsp;&lt;K, V> SetMultimap&lt;K, V> Multimaps.union(SetMultimap&lt;K, V>, SetMultimap&lt;K, V>)
by doing a Set.union on the value sets; the semantics of that method would be pretty immediately intuitive -- and then you implement
&nbsp;&lt;K, V> SetMultimap&lt;K, V> Maps.union(Map&lt;K, V> map1, Map&lt;K, V> map2) {
&nbsp;&nbsp;&nbsp;return Multimaps.union(Multimaps.forMap(map1), Multimaps.forMap(map2));
&nbsp;}
which seems to have the advantage of unambiguity: if they had different values, the Set contains two elements, if they had the same values or only one of them had a value, the Set contains one element, and that just follows inevitably from the Set contract.
(If we can hear about your particular use cases, that'll help us get a sense of what sort of semantics would actually be most useful to you -- I have no idea if this SetMultimap approach would actually do what you want.)
---
**Labels:** `Type-Enhancement`, `Package-Collect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=912#c2) posted by **jor...@knewton.com** on 2012-02-29 at 08:01 PM_
---
The multimap-based approach you suggest sounds good to me. Personally I'd get most use out of the functionality if it were a view, but that might not be true for everyone.
Example use case:
I'm writing some code to merge two versions of a graph together. I start with two maps, from node id to node, one for each of the graph versions.
I perform some work to determine whether the node sets can be happily merged together, and if they can, I merge them. One of the methods for doing this involves simply overwriting a node that's present but different in both maps with the version that exists on one of the sides (c.f. git merge-recursive with the --ours or --their option). At the end of this work, I create another node id -> node map that contains the post-merge state of the graph. I still need to hold on to the original two copies of the maps for a while, for other reasons.
To prevent having to create a whole new map, I wrote some other code that implements the read-only portions of the Map interface by delegating to one of the two underlying maps, depending on which copy we're favoring in the case of conflicts.
Your proposed SetMultimap union would fit this use case, except I don't think that sets' iterators preserve insertion order, so you'd really want a ListMultimap union.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=912#c3) posted by **wasserman.louis** on 2012-02-29 at 11:18 PM_
---
Sidestepping the insertion order specification was, in fact, part of what I had in mind.  ;)
We could preserve iteration order -- Sets.union specifies its iteration order relative to the iteration order of the input sets, for example.  You wouldn't be able to do get(0) and get(1), but you could use Iterables.get(Iterable, int).
I observe, however, than Multimaps.forMap returns a SetMultimap, and that isn't something we can change right now.
Perhaps you might implement a Map that delegates to the SetMultimap, but if the underlying set has two elements, then you pick out the default again?  I'm not sure I like that solution.
I also feel uncomfortable with unioning ListMultimaps -- or specifically, implementing "a view of the concatenation of two lists," which would be a prerequisite -- but I'm having trouble rationalizing why.  Mostly, I think it has to do with "people will use it as cons and snoc when they really shouldn't."  I'd like to get other Guava team members' read on that, though.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=912#c4) posted by **wasserman.louis** on 2012-03-04 at 08:58 PM_
---
For reference, I've written a draft implementation for both Multimaps.concat(ListMultimap, ListMultimap) and Multimaps.union(SetMultimap, SetMultimap) at https://github.com/lowasser/guava-experimental/commits/combine-multimap .  I haven't added adequate tests or documentation, though.
I think the use cases are relatively solid, but I'm not positive that this change would be worth the code and maintenance cost.  I'd really like to hear other people's opinions on this change.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=912#c5) posted by **fry@google.com** on 2012-03-13 at 06:52 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=912#c6) posted by **kevinb@google.com** on 2012-05-30 at 07:45 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=912#c7) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=912#c8) posted by **MrChrisPSimmons** on 2013-07-23 at 09:23 AM_
---
I could have used a union map view just now (or to put it another way I wrote one myself), but with one map taking precedence over than the other rather than returning a Map rather than a multi-foo.  My use case is as follows.
We have items in a sparse table and each entry is identified by a map from dimension-> value.  However, each dimension may have default value and sometimes we want a map with defaults included.  Building all these maps up front was taking 56M of memory up but switching to a union map of reported + defaulted dimensions takes it down to 4.6M.  In this case any performance loss was negligible and clearly worth the saving in RAM.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=910) created by **jmkristian** on 2012-02-27 at 08:15 PM_
---
Please add a method to generate the Cartesian product of an ordered collection of ordered collections, iteratively.
I could use this to develop automated tests that iterate over a large number of test cases. Sets.cartesianProduct is close to what I need, but dealing in Sets is a problem. I need each axis to be an ordered collection that may contain duplicate values, so I can generate the right sequence of inputs to test a stateful module. (Technically I guess this isn't a Cartesian product, but people seem to know what you mean when you call it that.)
It would be nice to have something that can conveniently produce an Iterator&lt;Object[]>, which I would use to implement a TestNG DataProvider &lt;http://testng.org/doc/documentation-main.html#parameters-dataproviders>.
It would be least surprising to generate results in which the last element varies most quickly; e.g. [[a, 1], [a, 2], [a, 3], [b, 1], [b, 2] ...].
The same code might resolve issue 908.
I tentatively suggest adding two public methods to Iterables:
static &lt;B, A extends B> Iterable&lt;B[]> product(Class&lt;B> resultType, Iterable<? extends Iterable<? extends A>> axes);
static &lt;B, A extends B> Iterable&lt;B[]> product(Class&lt;B> resultType, Iterable<? extends A>... axes);
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=910#c1) posted by **wasserman.louis** on 2012-02-27 at 08:21 PM_
---
I think if we implemented this feature, we wouldn't be returning `Iterable<B[]>`&nbsp;but rather an `Iterable<Iterable<A>>`.  Generics and arrays are sufficiently complicated that I think we'd rather that users who need arrays do the array conversion with Iterables.toArray themselves.
Not sure how I feel about the feature as a whole, though.  I might feel a little happier about list products, rather than general iterable products, and that seems like it would address your use case, correct?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=910#c2) posted by **jmkristian** on 2012-02-28 at 06:01 AM_
---
Yes, a method that returns Iterable&lt;List&lt;B>> or List&lt;List&lt;B>> would meet my needs. It would be a nuisance if each axis passed to the method is a List, since some of my axes are the results of a database query. I could make an adapter.
By the way, someone pointed out that the type parameter A is unnecessary. These declarations would be simpler and no worse, I think:
static &lt;B> Iterable&lt;B[]> product(Class&lt;B> resultType, Iterable<? extends Iterable<? extends B>> axes);
static &lt;B> Iterable&lt;B[]> product(Class&lt;B> resultType, Iterable<? extends B>... axes);
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=910#c3) posted by **kevinb@google.com** on 2012-03-01 at 05:49 PM_
---
Yeah, the List equivalent of our current set cartesian product has forever been filed away in the "if it becomes clear that enough people need it" bucket. This is the first time anyone's asked for it that I know of.
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=910#c4) posted by **kevinb@google.com** on 2012-03-16 at 09:19 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=910#c5) posted by **phwendler** on 2012-05-01 at 06:13 PM_
---
I have a usecase for a cartesian product, too. We have already implemented it ourselves, but would use a Guava version if available.
In our case, the input is a List&lt;Collection<? extends A>>. Using Lists for the inner collections doesn't really fit our semantics, and it doesn't seem to be necessary for the cartesian product, but we could live with it.
While building the List&lt;Collection<? extends A>> we currently pre-calculate the size of the cartesian product and use it for short-cutting the 0 and 1 cases (which are by far our most common cases), but that would seem a little bit weird for a generic method?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=910#c6) posted by **wasserman.louis** on 2012-05-03 at 03:32 PM_
---
Given the people appearing who want to use this, I think I'm inclined to +1 it myself.  But if phwendler desires, perhaps it should be List&lt;List&lt;E>> Collections2.cartesianProduct(List<? extends Collection<? extends E>>), which would address both lists and general collections.
---
**Labels:** `Package-Collect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=910#c7) posted by **tomas.zalusky** on 2012-05-07 at 07:29 AM_
---
If the feature will be implemented, will it address the most-significant-to-least-significant issue? ( https://github.com/google/guava/issues/908 )
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=910#c8) posted by **kevinb@google.com** on 2012-05-07 at 05:18 PM_
---
The only connection is that if we add a new cartesianProduct method then that issue should be interpreted as applying equally to both of them.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=910#c9) posted by **kevinb@google.com** on 2012-05-30 at 07:45 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=910#c10) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=910#c11) posted by **wasserman.louis** on 2012-12-25 at 05:54 PM_
---
It's implemented; do we want to expose it?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=910#c12) posted by **hartmetz** on 2013-02-25 at 09:06 PM_
---
yes please expose it!
one more upvote for order preserving Cartesian Product
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=910#c13) posted by **hartmetz** on 2013-02-25 at 10:33 PM_
---
A more refined statement of what I'm looking for is just a cartesian product iterator.
Iterators.cartesianIterator&lt;List&lt;E>> (List<? extends List&lt;E>> columns)
P.S. Sorry for spamming with the upvote.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=910#c14) posted by **guznik** on 2014-06-19 at 09:12 AM_
---
Thanks for pointing that out.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=909) created by **daniel.yokomizo** on 2012-02-24 at 09:50 PM_
---
First I want to say how much I appreciate the design of Range and DiscreteDomain. I'm using it a lot recently, to express valid intervals and ended up using it for enum ranges. This led to some code trying to iterate such ranges, which led me to write this function:
&nbsp;&lt;E extends Enum&lt;E>> DiscreteDomain&lt;E> enumDomain(Class&lt;E> enumClass)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=909#c1) posted by **wasserman.louis** on 2012-02-24 at 09:55 PM_
---
Can you give some more detail about your use case, specifically what your enums look like in your use cases?
---
**Labels:** `Type-Enhancement`, `Package-Collect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=909#c2) posted by **cpovirk@google.com** on 2012-02-24 at 10:16 PM_
---
Effective Java quotes Enum.ordinal's Javadoc: "Most programmers will have no use for this method. It is designed for use by sophisticated enum-based data structures, such as EnumSet and EnumMap."  It discourages use of ordinals for any sort of property about the values themselves.
enum Frequency { NEVER, OCCASIONALLY, FREQUENTLY, ALWAYS }
...with the understanding that the order is significant, at least for display purposes.  (In fact, I have a Swing EnumSlider class in one of my projects.)  It wouldn't be a huge jump to look for a percentage of respondents whose answers were in the range [NEVER, OCCASIONALLY].
---
1. I have an enum representing HTTP status code (declared in the code order) and I use ranges to represent classes:
Range&lt;StatusCode> CLIENT_ERROR = closedOpen(BAD_REQUEST, INTERNAL_SERVER_ERROR);
In a place I had to iterate over one of such classes.
1. In an older project I had enums for things like weekdays, months, and such. We had our own Range class (it was before Guava Range) and these static utility methods:
&lt;E extends Enum&lt;E>> Function&lt;E,E> next(Class&lt;E> c);
&lt;E extends Enum&lt;E>> Function&lt;E,E> prev(Class&lt;E> c);
&lt;E extends Comparable&lt;E>> Iterable&lt;E> upwards(Range&lt;E> range, Function&lt;E,E>step);
&lt;E extends Comparable&lt;E>> Iterable&lt;E> downwards(Range&lt;E> range, Function&lt;E,E>step);
We used these very often together, create a range including some enums, iterate over it.
1. It's essentially functionally equivalent to Haskell's "deriving Enum" which is quite useful, instead of rolling your own Enum every time.
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=909#c4) posted by **wasserman.louis** on 2012-02-24 at 11:52 PM_
---
For your first use case, I think we'd be hesitant to endorse using a DiscreteDomain for that.  I'm not comfortable with the ordering of HTTP status codes having a semantic meaning, I guess.  I'd strongly prefer EnumSet for that use case.
I guess my biggest concern about this feature would be that it's too easily misused for types that really aren't "naturally" Comparable, even if the Enum class makes it automatic.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=909#c5) posted by **cgdecker** on 2012-02-25 at 03:03 PM_
---
The HTTP status codes in the range [400, 500) are "client error" status codes by definition. Each other range has a specific category as well, so that doesn't seem so unreasonable to me.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=909#c6) posted by **wasserman.louis** on 2012-02-26 at 03:06 AM_
---
Hrrrrrrrrrmkay.  I can concede that that's a judgement call.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=909#c7) posted by **fry@google.com** on 2012-03-13 at 06:51 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=909#c8) posted by **kevinb@google.com** on 2012-05-30 at 07:45 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=909#c9) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=902) created by **mar...@alum.mit.edu** on 2012-02-17 at 05:19 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=902#c1) posted by **wasserman.louis** on 2012-02-17 at 05:27 PM_
---
Because there's not enough demand for them.  Multimaps have decent demand and moderate complexity; Tables have some demand and slightly greater complexity, but I think the cost/benefit ratio drops off pretty quickly after that point.
Do you have a use case?
---
**Labels:** `Type-Enhancement`, `Package-Collect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=902#c2) posted by **mar...@alum.mit.edu** on 2012-02-17 at 05:38 PM_
---
My just-encountered use case:  Searching a set of objects that each have three fields for instances that share the first two fields but not the last.  Of course there are many ways of solving this problem (and I just solved it using a regular table).  But in the analogous one- and two-field cases I use a Multiset and Multimap, respectively.
I would think that, for conceptual consistency, one would want a Multitable in the API. And, personally, often use Multisets and Multimaps as a builder object to construct sets or maps that satisfy certain properties.  The same would be extremely helpful for Tables.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=902#c3) posted by **wasserman.louis** on 2012-02-17 at 06:38 PM_
---
"Conceptual consistency" is not nearly as relevant to us as the metric of "utility times ubiquity."  We can't put in the kind of investment that Multitable would require for the sake of a comparatively tiny number of users.  For the same reason, we don't include a "three-keyed map," either.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=902#c4) posted by **wasserman.louis** on 2012-02-20 at 05:09 PM_
---
Additionally, the composite-key approach generalizes to arbitrary numbers of fields, in contrast to your proposed Multitable interface, which only get you one extra field.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=902#c5) posted by **mar...@alum.mit.edu** on 2012-02-20 at 10:42 PM_
---
#4 is a reasonable answer.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=902#c6) posted by **wasserman.louis** on 2012-03-01 at 07:52 PM_
---
I'm marking this as Acknowledged for the moment, unless we find another compelling use case.
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=902#c7) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=902#c8) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=902#c10) posted by **letallecy** on 2013-01-28 at 09:50 PM_
---
Hi Louis, one use case I have is the following:
I would like to store financial instruments tick data in a Table&lt;DateTime, String, Object> where the row is the timestamp, the column is the field retrieved (bid, ask, last, size etc.) and the Object is the value.
However, multiple ticks can occur within the same millisecond (and some exchanges report the ticks with a precision of 1 second, which increases the likelihood of having more than one tick per "cell").
For that specific use case, I would love to have a MultiTable where table.row() and table.column() return MultiMaps instead of Maps.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=902#c11) posted by **lowasser@google.com** on 2013-01-28 at 10:01 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=902#c12) posted by **letallecy** on 2013-01-28 at 11:41 PM_
---
Point taken. FYI, I use another workaround: when there is more than one value in a cell, I store a list in that cell instead. And when querying a particular column or row, I return a MultiMap, instead of a Map, which is created by iterating in the cells and checking which contains single data and which contains multiple data.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=902#c13) posted by **gak@google.com** on 2013-02-26 at 06:14 PM_
---
I've mentioned it before, but I've always been highly skeptical of the argument that a Multitable does not have enough utility as it is exactly the model for one of Google's most popular storage abstractions.  I'm pretty sure that Bigtable has proven its utility.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=902#c14) posted by **kak@google.com** on 2013-08-22 at 11:47 PM_
---
_Issue #1227 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=902#c15) posted by **kak@google.com** on 2013-08-22 at 11:48 PM_
---
_(No comment entered for this change.)_
---
**Owner:** gak@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=902#c16) posted by **roxton** on 2013-09-05 at 09:11 PM_
---
Use Case:
I have two parameterized fields, with relations. The first field is concrete, and the elements of the second field are being inferred based on valid relations.
I want a table:
Multitable&lt;sourceParameterIndex, targetParameterIndex, CandidateParameters>
That way, based on the relation between each permutation of source and target parameter index, I can add candidate parameters, then take the intersection across sets for each source parameter, instantiate field elements for each permutation of filtered parameters, then filter those permutations based on constraints.
I searched through Google's codebase for instances of `Table<R, C, List>` and similar.
```
'\b(Immutable)?Table<.*, .*, (List|Set|Collection|Iterable)<.*>>'
```
This gave 192 results. That's actually pretty surprisingly small for the Google codebase. But of course there are surely other users who reinvented this themselves with different combinations of collections. (And sometimes that's fine: Louis's suggestion of a `Multimap` with a composite key is often sufficient.)
Still, the complexity of this type would be large, as previously discussed. This led me to file #2170 for `Tables.computeIfAbsent`, which is basically the primitive that the JDK added to `Map` in lieu of adding a full `Multimap` and `Multiset`. It may be enough for many users here.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=900) created by **andreas.karlsson.se** on 2012-02-14 at 11:47 PM_
---
I have several threads that might read from a shared CountingInputStream, but only If their internal counter is equal to the count of the stream. To actually read from the stream will of course require locking. However, if the count of the stream had volatile semantics I could avoid contention by utilising the double-checked locking pattern.
This might not be such a big an issue, but neither is adding volatile and some documentation?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=900#c1) posted by **wasserman.louis** on 2012-02-16 at 06:28 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-IO`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=900#c2) posted by **fry@google.com** on 2012-03-13 at 06:40 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=900#c3) posted by **fry@google.com** on 2012-03-13 at 06:40 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=900#c4) posted by **cpovirk@google.com** on 2012-03-13 at 07:31 PM_
---
Arguably we should do this just to follow the precedent that streams are thread-safe, but I'm not sure that that's a precedent worth following.  (We'd have to go all the way to atomics.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=900#c5) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=900#c6) posted by **wasserman.louis** on 2013-01-13 at 09:35 PM_
---
_Issue #1256 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=900#c7) posted by **kasperni** on 2013-01-23 at 04:16 PM_
---
If this issue is going to be resolved with a AtomicLong counter.
It would be really useful to have an addition constructor that takes the actual AtomicLong to call add on.
CountingOutputStream(AtomicLong counter, OutputStream);
Sometimes I need to count the totals across of a number of files.
Having to sum all the counting output stream are a bit annoying.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=899) created by **MGHawksworth** on 2012-02-14 at 01:24 PM_
---
As they are not flagged they are not included in the gwt jar build however there appears to be no information that says they are excluded deliberately.
Either they should be flagged or some notification needs to be made on the package description to show it is not included.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=899#c1) posted by **cpovirk@google.com** on 2012-02-14 at 04:01 PM_
---
Our policy of annotating only GWT-compatible classes made more sense when few classes were GWT-compatible.  (And even then it was a little confusing.)  Maybe it's time to consider annotating every class one way or the other?
---
**Labels:** `Type-Documentation`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=899#c2) posted by **fry@google.com** on 2012-03-13 at 06:38 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=899#c3) posted by **kevinb@google.com** on 2012-05-30 at 07:51 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Documentation`, `Type-ApiDocs`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=899#c4) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=899#c5) posted by **kevinb@google.com** on 2012-06-22 at 06:57 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-General`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=888) created by **greg.steffensen** on 2012-01-29 at 03:54 PM_
---
I've recently run into the need for an ExecutorService that prioritizes certain tasks over others using a PriorityQueue.  This seems like a common need, and I thought it might be something worth considering for Guava.  Unfortunately, it seems like it might be hard to implement for JDK 5, for the reasons described here
http://stackoverflow.com/questions/807223/how-do-i-implement-task-prioritization-using-an-executorservice-in-java-5
Essentially, even if you explicitly use ThreadPoolExecutorService and pass in a custom BlockingQueue to its constructor, the Runnable instances you submit to the service get wrapped in a FutureTask before they're given to the queue, and FutureTask provides no way to inspect the object it's wrapping, which makes it difficult for the queue to find the information it would use to compare the new task to existing ones.  JDK 6, however, adds a new protected newTaskFor method to AbstractExecutorService that seem to me to be specifically intended for this use case- it allows you to control the wrapping of the submitted Runnable/Callable in a FutureTask.  And even in JDK 5, I can imagine hacky solutions that are still based on ThreadPoolExecutor, such as using a ThreadLocal to store the priority information that was passed along during submit, and letting the queue retrieve it from there.
So, in Guava 11, the JDK 5/JDK 6 difference might have made this problematic, but I wonder if the switch to two different releases in Guava 12 might make a feature like this practical, assuming that it's appropriate for the project at all.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=888#c1) posted by **wasserman.louis** on 2012-01-29 at 05:43 PM_
---
How would you expect the API for such a thing to look?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=888#c2) posted by **wasserman.louis** on 2012-01-29 at 05:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Enhancement`, `Package-Concurrent`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=888#c3) posted by **greg.steffensen** on 2012-01-29 at 07:19 PM_
---
To me, the interface would depend on whether we wanted to provide protection against potential starvation of lower priority tasks, which would be a can of worms.  If you're willing to omit that functionality, the interface might look like this:
public interface PriorityExecutorService extends ExecutorService {
&nbsp;&nbsp;&nbsp;&nbsp;public &lt;T> Future&lt;T> submit(Callable&lt;T> task, int priority);
&nbsp;&nbsp;&nbsp;&nbsp;public Future<?> submit(Runnable task, int priority);
&nbsp;&nbsp;&nbsp;&nbsp;public &lt;T> Future&lt;T> submit(Runnable task, T result, int priority);
}
If, instead we wanted to protect the ability to protect against starvation, my first inclination would be to pass in objects that have priorities that can potentially change over time.  In that case, I'd imagine two classes- PrioritizedTask and PriorityExecutorService.  PriorityExecutorService would look something like this:
public interface PriorityExecutorService extends ExecutorService {
&nbsp;&nbsp;&nbsp;&nbsp;public &lt;T> Future&lt;T> submit(PrioritizedTask&lt;T> task);
}
And PrioritizedTask would be an abstract class with a handful of public factory methods that return instances of private inner classes.  If none of the given priority calculations met the user's needs, they could also write their own implementation, overriding the getPriority method.  A quick sketch of that interface is attached.
There would be implementation decisions to be made regarding how often are priorities within the queue recalculated.  The two most obvious answer to me would be every time a task is popped, and at a regular interval.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=888#c4) posted by **wasserman.louis** on 2012-01-29 at 07:26 PM_
---
The implementation of PrioritizedTask, FYI, might be quite difficult, in terms of the priority queue implementation.  But wrt the first API, there might be other ways to avoid starvation, if we're smart about it...
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=888#c5) posted by **greg.steffensen** on 2012-01-29 at 08:30 PM_
---
Regarding the queue for mutable priorities, I can see how it would potentially be unscalable in at least two ways- you'd need to lock the whole thing while it was being reordered, and the amount of work required to resort it would grow with the size of the queue, creating the theoretical possibility of a positive feedback loop that kills performance.  But on the other hand, if you just treat the queue as a List to be locked, resorted, and unlocked, you'd benefit from the fact that the common case would be for the list to be already almost-sorted... something like insertion sort would work in nearly linear time on a nearly sorted input.  I'd think that if you're willing to bound the queue size, the performance consequences of a naive implementation would be fine, at least for the use case of modest numbers of relatively expensive tasks.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=888#c7) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=888#c8) posted by **akshay.jain.7983** on 2013-11-17 at 06:20 AM_
---
try this: http://funofprograming.blogspot.com/2013/11/priorityexecutorservice-for-java.html
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=886) created by **ogregoire** on 2012-01-27 at 12:30 PM_
---
Please add a Iterables/Iterators.repeat(E element, int count) method.
At the moment, it can be emulated by several ways:
- for loop and add to a list   <= good, but better can be done
- using a Multiset             <= performance reasons (see use case below)
Multisets.immutableEntry(element, count) is not good as well because it's not iterable.
My use case is the building of lists similar to this one:
[a, a, a, b, b, a, a, a, a, c, c, c, c, a]
Iterables.repeat really helps with building this. The iteration order is important, that's why I discarded the idea of using a Multiset.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=886#c1) posted by **cgdecker** on 2012-01-27 at 02:04 PM_
---
Sounds like you want Collections.nCopies: http://docs.oracle.com/javase/6/docs/api/java/util/Collections.html#nCopies(int, T)
---
**Status:** `Invalid`
---
Correct: that's exactly what I want!
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=878) created by **s...@st.informatik.tu-darmstadt.de** on 2012-01-20 at 10:28 AM_
---
Currently, a ReferenceEntry like a WeakEntry in a Cache is quite heavy-weight (in terms of memory-consumption), even if it strongly refers to its value. (I expect weak keys/strong values to be a very common pattern.) This is because the (on my machine) 40 bytes WeakEntry refers to another 16 byte StrongValueReference instead of just storing the reference "unboxed" in the WeakEntry.
One way to address this, without breaking the interface of ReferenceEntry, would be to add a specialized WeakEntryWithStrongValue (name could arguably be improved ;-) which implements the ValueReference interface itself. Its getValueReference() method would then simply return "this".
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=878#c1) posted by **wasserman.louis** on 2012-01-20 at 04:04 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Performance`, `Package-Cache`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=878#c2) posted by **wasserman.louis** on 2012-02-20 at 05:15 PM_
---
I'd be interested in doing this, though I might request some help from Dmitris and the memory analysis on Cache that he's already done.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=878#c3) posted by **jim.andreou** on 2012-02-20 at 11:05 PM_
---
Sounds about right, 40 + 16 + a reference (aligned) holding this structure = 64 bytes that I've been measuring. Without looking the code, I vaguely recall a TODO note calling out this possibility, is that right?
But the important detail is whether the cost can drop to 48 bytes, rather than 56. One would represent a 25% reduction for these caches, the other 'just' 12.5%, which would be able to justify less extra code complexity than the former.
This is a case where an external patch would help. If I'm given a patch, I can easily tell which is the case, or one can use an external memory measuring tool, or other cruder means to measure the space reduction. And Charles would be able, at a glance, to see what kind of complexity we're talking.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=878#c4) posted by **wasserman.louis** on 2012-02-20 at 11:07 PM_
---
I will attempt a patch, and let y'all know if I encounter any particular difficulties.
---
**Status:** `Accepted`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=878#c5) posted by **wasserman.louis** on 2012-02-23 at 09:25 PM_
---
This is somewhat more complex than I'd hoped.  I will continue working on it, but it'll require a fair amount of refactoring.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=878#c6) posted by **kevinb@google.com** on 2013-03-12 at 06:43 PM_
---
_(No comment entered for this change.)_
---
**CC:** fry@google.com
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=877) created by **thomas.andreas.jung** on 2012-01-20 at 08:28 AM_
---
I would be nice to have a substring count method. It can implemented now with Splitter and Iterables:
int count(String a, String s) {
&nbsp;&nbsp;&nbsp;return Iterables.size(Splitter.on(s).split(a)) - 1;
}
or using String.indexOf
int count(String a, String s) {
&nbsp;&nbsp;&nbsp;&nbsp;int i = 0, count = 0;
&nbsp;&nbsp;&nbsp;&nbsp;while((i = a.indexOf(s, i++)) != -1) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i += s.length();
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return count;
}
assert 0 == count("", "xx");
assert 1 == count("xx", "xx");
assert 1 == count("xxa", "xx");
assert 3 == count("xxxxxx", "xx");
assert 3 == count("axxaxxaxxa", "xx");
assert 1 == count("xxx", "xx");
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=877#c1) posted by **cpovirk@google.com** on 2012-01-20 at 02:10 PM_
---
There was some discussion of a countMatches method here:
---
**Status:** `Triaged`
**Labels:** `Type-Enhancement`, `Package-Base`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=877#c2) posted by **thomas.andreas.jung** on 2012-01-21 at 05:08 AM_
---
Okay, the count method is quite limited. An Iterator of substring start indices could be more useful.
class IndexOfIterator extends AbstractIterator&lt;Integer> {
&nbsp;&nbsp;&nbsp;static Iterator&lt;Integer> indexOf(String string, String substring) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new IndexOfIterator(string, substring);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;private int i = 0;
&nbsp;&nbsp;&nbsp;private String a;
&nbsp;&nbsp;&nbsp;IndexOfIterator(String a, String s) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.a = a;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.s = s;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;@Override protected Integer computeNext() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i = a.indexOf(s, i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(i == -1) endOfData();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int next = i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i += s.length();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return next;
&nbsp;&nbsp;&nbsp;}
}
For example the HostAndPort.fromString method:
int colonPos = hostPortString.indexOf(':');
if (colonPos >= 0 && hostPortString.indexOf(':', colonPos + 1) == -1) {
&nbsp;&nbsp;&nbsp;&nbsp;// Exactly 1 colon.  Split into host:port.
&nbsp;&nbsp;&nbsp;&nbsp;host = hostPortString.substring(0, colonPos);
&nbsp;&nbsp;&nbsp;&nbsp;portString = hostPortString.substring(colonPos + 1);
} else {
&nbsp;&nbsp;&nbsp;&nbsp;// 0 or 2+ colons.  Bare hostname or IPv6 literal.
&nbsp;&nbsp;&nbsp;&nbsp;host = hostPortString;
&nbsp;&nbsp;&nbsp;&nbsp;hasBracketlessColons = (colonPos >= 0);
}
could be rewritten as:
Iterator&lt;Integer> indexOf = IndexOfIterator.indexOf(hostPortString, ":");
host = hostPortString;
if (indexOf.hasNext()) {
&nbsp;&nbsp;&nbsp;&nbsp;int colonPos = indexOf.next();
&nbsp;&nbsp;&nbsp;&nbsp;hasBracketlessColons = indexOf.hasNext();
&nbsp;&nbsp;&nbsp;&nbsp;if (!hasBracketlessColons) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Exactly 1 colon. Split into host:port.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;host = hostPortString.substring(0, colonPos);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;portString = hostPortString.substring(colonPos + 1);
&nbsp;&nbsp;&nbsp;&nbsp;}
}
and count as Iterators.size(IndexOfIterator.indexOf("axx","xx")).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=877#c3) posted by **kevinb@google.com** on 2012-01-30 at 06:30 PM_
---
Before doing anything we need to find evidence that this is actually a common need  -- common enough that the usual indexOf-loop pattern is a problem.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=877#c4) posted by **thomas.andreas.jung** on 2012-01-31 at 07:20 AM_
---
That's obvious.
A more powerful/complex solution would be to iterate over the matches of a regular expression (like Matcher.find):
public static Iterator&lt;Range> spans(String string, String regex)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=877#c5) posted by **fry@google.com** on 2012-02-16 at 07:18 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=877#c6) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=877#c7) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
It hasn't been rejected, but we haven't done the necessary research to prove that it should be added.  _[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=872) created by **raymond.rishty** on 2012-01-18 at 02:55 AM_
---
First off, Guava's caching API is great stuff. It's made my code more clean, more efficient, and more robust.
I do, however, have a confession... I sometimes abuse it.
Clearly, the cache is intended for key-based lookup, but occasionally, I have a single item I need to cache. It's something that is too expensive to fetch all the time, and the "memoizeWithExpiration" Supplier is a little thin (for example, I can't force eviction/invalidation).
So, what I've done is have some dummy key that I used to look up this single item. I'm sure you're cringing as your read this.
It would be nice to have a way of supporting this functionality that doesn't feel quite so dirty. Whether it would be some extension to the Cache API (don't know how...) or perhaps a beefed-up supplier that pulls in some functionality from Cache.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=872#c1) posted by **wasserman.louis** on 2012-01-18 at 06:43 PM_
---
I'm...in favor of this, and tentatively endorse a beefed-up Supplier.
---
**Labels:** `Package-Cache`, `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=872#c2) posted by **raymond.rishty** on 2012-01-18 at 08:42 PM_
---
A proposed interface:
&nbsp;&nbsp;&nbsp;&nbsp;void invalidate(); // or, perhaps, clear()
&nbsp;&nbsp;&nbsp;&nbsp;void refresh();
&nbsp;&nbsp;&nbsp;&nbsp;void put(T object);
}
It would also be nice if the "memoizeWithExpiration" static factory could become a builder, so I could do something like:
BeefySupplier&lt;Steer> steerSupplier = Suppliers.builder()
&nbsp;&nbsp;&nbsp;&nbsp;.memoize()
&nbsp;&nbsp;&nbsp;&nbsp;.expireAfterAccess(100)
&nbsp;&nbsp;&nbsp;&nbsp;.refreshAfterWrite(200)
&nbsp;&nbsp;&nbsp;&nbsp;.build(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Supplier&lt;Steer>() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Steer get() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return raiseASteer(); // it takes a long time to raise one, hence why I want to cache it
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;);
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=872#c3) posted by **raymond.rishty** on 2012-01-19 at 01:27 AM_
---
Hmm, so I just noticed that there is a CacheLoader.from(Supplier&lt;V> supplier). Is this intended to be the way to go about making a single-element cache? If so, this issue can be closed.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=872#c4) posted by **wasserman.louis** on 2012-01-19 at 01:30 AM_
---
I'm not satisfied with that, exactly?  I'd like to eliminate the key from the picture, for the single-element cache.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=872#c5) posted by **kevinb@google.com** on 2012-01-19 at 03:30 AM_
---
Raymond, that's actually completely unrelated.  It's just like any other cache, just that the CacheLoader doesn't actually depend on the key.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=872#c6) posted by **kevinb@google.com** on 2012-01-19 at 03:32 AM_
---
In general, I think it's probably a good idea to explore the idea of a singleton-cache type that's the no-key,one-value analogue of CacheBuilder/LoadingCache, then whittle the set of methods suggested by that analogy down to the ones we know we have use cases for Out There, and see what we arrive at.
To me, the fact it'll implement Supplier is just incidental, as with the case of LoadingCache implementing Function, and so I don't think Supplier would feature in the name.
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=872#c7) posted by **joe.j.kearney** on 2012-01-19 at 09:54 AM_
---
I have an implementation of this that I called ReferenceMaker, with options similar to MapMaker/CacheLoader for expiry etc, but only storing the single reference. There are plenty of things this could support that aren't applicable to or done in CacheLoader, in particular timed async refresh as opposed to expiry with on-demand reinitialisation.
I considered this to be more like a Reference with some extra options (e.g. self-refreshable) than like a cache, though maybe these are close to the same thing.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=872#c8) posted by **fry@google.com** on 2012-02-16 at 07:18 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=872#c9) posted by **mindas** on 2012-04-26 at 03:21 PM_
---
Not sure if OP had a similar scenario in mind, but I needed a memoizing supplier which is calculated from non-static context (pseudo code):
if ((t = not_calculated_yet) != null) {
&nbsp;&nbsp;block_all_other_threads();
&nbsp;&nbsp;t = calculate(f);
&nbsp;&nbsp;memoize(t);
}
return t;
My initial response to this was to use Guava's cache (like OP) but I think having an abstract class with double check idiom (to hide the inglorious bits) is a better solution.
There are numerous implementations on the web, and this is one of them: http://weblogs.java.net/blog/mason/archive/2006/09/rechecking_doub.html
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=872#c10) posted by **cpovirk@google.com** on 2012-04-26 at 03:34 PM_
---
https://google.github.io/guava/apidocs/com/google/common/base/Suppliers.html#memoize%28com.google.common.base.Supplier%29
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=872#c11) posted by **mindas** on 2012-04-26 at 03:50 PM_
---
Don't think Suppliers.memoize would be applicable for cases where supplier is static and the data to build the supplier from ("f" in pseudo code) is coming, say, from a method parameter. Consider something like
class Foo {
&nbsp;&nbsp;private static final Supplier&lt;Bar> BAR_SUPPLIER = Suppliers.memoize(...);
&nbsp;&nbsp;private Foo() {}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BAR_SUPPLIER.get(baz);  // there's no .get(key, Callable) like in Cache
&nbsp;&nbsp;}
}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=872#c12) posted by **cpovirk@google.com** on 2012-04-26 at 09:01 PM_
---
Ah, so you know that get(Baz) will be called with the same Baz every time, but you don't know the value ahead of time?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=872#c13) posted by **mindas** on 2012-04-27 at 08:29 AM_
---
Yes, exactly.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=872#c14) posted by **shiber** on 2012-05-25 at 05:08 PM_
---
+1
I had the exact same experience as the OP.
I like the pattern that Raymond proposed (the Supplier builder). However we could start smaller by offering a supplier that behaves exactly like memoizeWithExpiration, except that it loads the value asynchronously (using an Executor passed at construction, for instance) automatically upon expiration or upon the first request that follows expiration, and continues to supply the old value until the new value is returned.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=872#c15) posted by **yoavtz@google.com** on 2012-05-28 at 05:49 PM_
---
I must admit that my recent abuse of the glorious CacheLoader is even dirtier:
not only do I need just one value, so I use a dummy key,
but I also want my data to be set under a lock, so I also use a dummy value, and just implement the get() method as:
public Object get(Object ignoredKey) {
&nbsp;&nbsp;mutex.lock();
&nbsp;&nbsp;try {
&nbsp;&nbsp;&nbsp;&nbsp;outerClass.this.value = calculateValue();
&nbsp;&nbsp;} finally {
&nbsp;&nbsp;&nbsp;&nbsp;mutex.unlock();
&nbsp;&nbsp;}
}
If memoizeWithExpiration is adapted to allow all the above, can it also please accept an optional lock to make writes under?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=872#c17) posted by **yoavtz@google.com** on 2012-05-28 at 05:51 PM_
---
(sorry, OuterClass should be capitalized... and this is the load() method...)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=872#c18) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=872#c19) posted by **em...@soldal.org** on 2012-06-01 at 02:16 PM_
---
I feel like this would be solved by just adding a reset method to the memoizing suppliers available today. At least thats what I've done in my code.
I found a need to memoize values for a long period of time, but every once in a while, usually triggered by users, I had to flush the value stored in the supplier.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=872#c20) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=872#c21) posted by **cky944** on 2012-07-01 at 06:13 PM_
---
Another useful feature (that I have an immediate use for) that this singleton cache could provide is memoise-with-soft-reference. Just to add to kevinb's list for Comment 6.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=872#c22) posted by **em...@soldal.org** on 2012-07-03 at 01:22 PM_
---
The reason was simpy because we had a config object which rarely changed, so holding it in a Memoizing supplier once it had been loaded was a good idea.... until it changed... then you had to reboot the server to get the changed to propogate.
Perhaps cache is the wrong idea here, just adding an interface like Resettable or Clearable akin to (Auto)Closable and attaching that to a tertiary interface which joins both Supplier and Resettable and returning that so that we can expose the reset method and supplier method but not the implementations.
Arguably these should be added to the current memoizing suppliers.
just my 2 cents
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=872#c23) posted by **christoph.hoesler** on 2012-07-30 at 02:57 PM_
---
I had a similar need. My solution was to ask an extended Predicate if the memoized value should get updated. The memoizing Supplier calls a done() method on the 'UpdateRequest' after the value is updated, so that it can change it's state.
public interface UpdateRequest&lt;T> extends Predicate&lt;T> {
&nbsp;&nbsp;&nbsp;&nbsp;void done();
}
public static &lt;T> Supplier&lt;T> memoize(Supplier&lt;T> delegate, UpdateRequest<? super T> updateRequest) {...}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=872#c24) posted by **kevinb@google.com** on 2012-08-24 at 03:57 AM_
---
Louis, if you're looking for work, this would be good to look into, at least as far as converging on an API/feature set we can all feel good about.
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=872#c25) posted by **wasserman.louis** on 2012-08-24 at 07:21 PM_
---
I can do that; I'll do some experimentation over the next week or two.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=872#c26) posted by **mindas** on 2012-10-31 at 10:56 AM_
---
There's another functionality aspect which can possibly be considered for this feature.
Let's say there's some expensiveFunction() which takes a long time to calculate. Data that makes the input of this function may change and might be a need for an idiom which would invalidate the current process of expensive calculation and start anew, making all waiting threads to wait for longer until the calculation is complete and no more invalidations are done in the due course.
Current LoadingCache does not support this feature (this is not too obvious from the javadoc). In other words, call to cache.refresh(key) or cache.invalidate(key) or cache.invalidateAll() is ignored if the calculation is in process and only makes any difference if invalidation happens _after_ the calculation.
I needed this feature and wrote a quick hack myself. The source code is available at http://codereview.stackexchange.com/questions/18056/ability-to-forget-the-memoized-supplier-value -- I'd be more than happy to hear any suggestions/improvements.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=872#c27) posted by **kevinb@google.com** on 2012-11-09 at 11:07 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=872#c28) posted by **kevinb@google.com** on 2013-03-12 at 06:43 PM_
---
_(No comment entered for this change.)_
---
**CC:** fry@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=872#c29) posted by **perneto@google.com** on 2013-06-18 at 12:55 PM_
---
I'm also using a LoadingCache the same way as the OP; my own reasons are:
- expireAfterWrite
- thread-safe loading.
In general I can see most of the other features of CacheBuilder being useful for a singleton holder (various expiration policies, etc).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=872#c30) posted by **cgdecker@google.com** on 2013-07-03 at 07:24 PM_
---
_Issue #1466 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=872#c31) posted by **cgdecker@google.com** on 2013-07-03 at 07:30 PM_
---
_Issue #1466 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=872#c32) posted by **lowasser@google.com** on 2014-06-02 at 07:24 PM_
---
_Issue #1773 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=872#c33) posted by **cpovirk@google.com** on 2014-08-19 at 01:41 PM_
---
_Issue #1834 has been merged into this issue._
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=870) created by **nik9000** on 2012-01-17 at 09:04 PM_
---
A test like this should pass:
&nbsp;&nbsp;&nbsp;&nbsp;@Test
&nbsp;&nbsp;&nbsp;&nbsp;public void mapSplitter() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Map&lt;String, String> map = Splitter.on(",").omitEmptyStrings().trimResults().withKeyValueSeparator("->").split("cows-> big, sheep -> annoying, geese -> welcome");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assertEquals("welcome", map.get("geese"));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assertEquals("big", map.get("cows"));
&nbsp;&nbsp;&nbsp;&nbsp;}
Right now the map is from "geese " to " welcome" rather than "geese" to "welcome"
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=870#c1) posted by **nik9000** on 2012-01-17 at 09:17 PM_
---
The omitEmptyStrings part of the above is sort of meaningless and can be removed.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=870#c2) posted by **kak@google.com** on 2012-01-17 at 09:19 PM_
---
The first #trimResults only applies to the key splitter. You can get what you want with:
&nbsp;&nbsp;&nbsp;&nbsp;Map&lt;String, String> map = Splitter
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.on(",")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.omitEmptyStrings()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.trimResults()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.withKeyValueSeparator(Splitter.on("->").trimResults())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.split("cows-> big, sheep -> annoying, geese -> welcome");
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=870#c3) posted by **kak@google.com** on 2012-01-17 at 09:19 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
**Labels:** `Type-Documentation`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=870#c4) posted by **nik9000** on 2012-01-17 at 09:27 PM_
---
Its more like the trim works on the splitter that splits the entries - the one that uses the ",".  Would it be ok to provide the trim behavior to the keyvalue splitter?  Something like:
&nbsp;&nbsp;&nbsp;@CheckReturnValue
&nbsp;&nbsp;&nbsp;public MapSplitter withKeyValueSeparator(String separator) {
-    return withKeyValueSeparator(on(separator));
-    return withKeyValueSeparator(on(separator).trimResults(trimmer));
&nbsp;&nbsp;&nbsp;}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=870#c5) posted by **kevinb@google.com** on 2012-01-18 at 03:06 PM_
---
Unfortunately, this would leave the user no apparent way to specify when they _don't_ want that trimming. I don't know if there's going to be a good solution to this problem. :-(
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=870#c6) posted by **nik9000** on 2012-01-18 at 03:30 PM_
---
Wouldn't the withKeyValueSeparator(Splitter) syntax do that?  Those that want the current behavior I'm seeing could do
Splitter.on(",").trimResults().withKeyValueSerarator(Splitter.on("->")).split("")
Something like that'd still require a note in the javadoc for the String version of withKeyValueSeparator, but I think it'd be overall more intuitive.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=870#c7) posted by **wasserman.louis** on 2012-02-16 at 06:27 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Base`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=870#c8) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=870#c9) posted by **kevinb@google.com** on 2012-02-16 at 09:52 PM_
---
We are starting to wonder if it was a mistake to implement MapSplitter in the way we did (start with a Splitter, then get a MapSplitter from it).  A parallel API probably would have been a lot less confusing.  I am not sure we how feasible it is to fix this behavior now.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=870#c10) posted by **kevinb@google.com** on 2012-05-30 at 07:51 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Documentation`, `Type-ApiDocs`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=870#c11) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=867) created by **Arend.von.Reinersdorff** on 2012-01-14 at 09:19 AM_
---
Multiset.size() returns the total number of occurrences of all elements in the Multiset. As described in the wiki
http://code.google.com/p/guava-libraries/wiki/NewCollectionTypesExplained#Multiset
But this is not documented in the Multiset interface itself.
I think this should be documented because:
- If you think about a multiset in terms of a Map&lt;E, Integer> you might guess wrongly that size() behaves like Map.size().
- If the behavior of size() is not specified in the interface, implementations could implement it in different ways.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=867#c1) posted by **cgdecker** on 2012-01-14 at 03:35 PM_
---
It seems to me that this shouldn't be necessary because the definition of Multiset itself implies this behavior. The interface Javadoc makes it clear that a Multiset is a Collection that can have multiple copies of each element (like a List). A collection's size() is the number of elements in it. The Javadoc also mentions that the elementSet() method is used to get the set of _distinct_ elements in the collection. I also think it's important for users to understand that a Multiset is not a Map&lt;E, Integer> at the level of the whole interface.
All that said, maybe it wouldn't hurt to add a mention to the size() method. The iterator() method already mentions that elements that occur multiple times in the multiset appear multiple times in the iterator.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=867#c2) posted by **wasserman.louis** on 2012-01-14 at 07:23 PM_
---
I added a lot of discussion on the wiki on the differences between Multiset and Map, as well as Multimap and Map.  I'm not sure whether or not it makes sense to add more discussion to the Javadoc, though.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=867#c3) posted by **wasserman.louis** on 2012-01-16 at 07:02 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
**Labels:** `Type-Documentation`, `Package-Collect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=867#c4) posted by **kevinb@google.com** on 2012-01-30 at 06:15 PM_
---
It _might_ be worth pointing out in the Multiset classdocs something to the effect that you can sometimes _think_ of a Multiset like a map to counts, but that operations like size() don't behave as expected in that model.  I lean against spending more text on this, but at some point we might do some rewriting and we'll take this into account.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=867#c5) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=867#c6) posted by **kevinb@google.com** on 2012-05-30 at 07:51 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Documentation`, `Type-ApiDocs`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=867#c7) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=867#c8) posted by **kevinb@google.com** on 2012-08-18 at 06:31 AM_
---
I notice now that the type of clarification I suggested in comment 4 is in fact _exactly_ analogous to a recent round of clarifications I made to multimap.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=857) created by **aled.sage** on 2012-01-05 at 10:29 AM_
---
In jclouds we use the ExpiringMemoizingSupplier (via Suppliers.memoizeWithExpiration). However, there are two (very separate) problems we've seen with this.
Our call to delegate.get() is very expensive - it sometimes takes over 60 seconds on a slow network. When we also configure the duration to 60 seconds, then instead of having 60 seconds between the call returning and the next call, we have 60 seconds between the start of each call. So the returned value is immediately expired. We'd like it to use the returned value for the full duration before calling delegate.get() again. Or at least for that to be a configurable option, if there are conflicting use-cases.
---
Second, when calling delegate.get() it keeps a reference to the old and new values at the same time. Our value can take up a lot of memory, so peak memory consumption is twice as much as required for this (which can cause OOMEs). Perhaps it could set the value to null before calling delegate.get() - depending on the cost of the additional volatile write inside the synchronized block?!
Note: there's some discussion about this at http://groups.google.com/group/jclouds-dev/browse_thread/thread/1aec2817aea53967/1b054f6cc2dfa850
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=857#c1) posted by **kevinb@google.com** on 2012-01-11 at 12:14 AM_
---
1. Interesting. I don't think I see a problem with just starting the clock ticking _after_ the element is loaded. Does anyone?
2. Likewise I don't see a particular problem with nulling out the reference. One more volatile write is not likely to be a deal-breaker.
---
**Status:** `Accepted`
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=857#c2) posted by **aled.sage** on 2012-01-11 at 12:53 AM_
---
Excellent, thanks.
For now in jclouds we've copied and patched the ExpiringMemoizingSupplier code - see https://github.com/jclouds/jclouds/blob/master/core/src/main/java/org/jclouds/util/Suppliers2.java
The two-line change is pretty trivial; it'll be great if we can delete this from our code with the next guava release.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=857#c3) posted by **cpovirk@google.com** on 2012-01-17 at 08:26 PM_
---
Some internally commentary:
"""
resetting the expiration time to after the delegate has returned a value
involves an extra call to nanoTime which we would like to avoid.  It also
seems semantically more correct to start the expiration countdown before
the call to delegate.get rather than after - the data may have started
going stale near the beginning of that call, and may have been merely
delayed "in transit".  Most users will have expiration times that are much
larger than the time to recompute.
---
Nulling out the old value while computing the new one is more appealing,
value which has already expired - return a stale one or wait for a fresh
one to be computed?  One would have to be careful not to introduce a race
that accidentally returns a null (that would be possible if we naively
nulled out value before calling delegate.get()).  I would also avoid
depending on the monotonicity of nanoTime, which is hard for the JDK/OS to
provide reliably, and which we Googlers are known to willingly abandon.
&nbsp;Most obviously we could introduce a NOT_PRESENT sentinel value, but that
---
I think the current behavior of ExpiringMemoizingSupplier is pretty good
for most users.  Those who have enormous or expensive caches should either
make their caches more fine-grained (as jclouds is doing, I think) or
create their own version of ExpiringMemoizingSupplier or use a more
full-featured cache, e.g. one that will actively clear the cache when the
expiration time elapses without any activity.  Which may already exist?
"""
Me:
"""
That seems reasonable, and I don't have a strong opinion here.
Arguably the difference is in whether values expire (a) because they
are out of date (~become invalid) or (b) because we want to save
memory.  (a) seems to be a better fit here, as (b) would suggest that
the expiration time be bumped every time the value is read.  I wonder
if our documentation adequately expresses this.  In particular, the
link to the Wikipedia memoization article feels wrong, as I think of
memoization as being about values that would always be the same if
they were recomputed.  Whatever we can do to improve the documentation
Cache.  [We are also considering changing Cache's behavior to match.]
"""
Responses welcome.
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=857#c4) posted by **wasserman.louis** on 2012-01-20 at 04:52 PM_
---
I think that issue 872 is the way to solve this problem: by having a CacheBuilder-like, super-general approach with lots of control over exact expiration semantics.  (The refresh-versus-expire distinction in Cache would address this difficulty, no?)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=857#c5) posted by **kevinb@google.com** on 2012-02-16 at 06:29 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Base`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=857#c6) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=857#c7) posted by **kevinb@google.com** on 2012-02-16 at 09:50 PM_
---
Personally I would prefer to just document the existing method's behavior rather than try to change it now.  I agree with Martin's point that the current behavior is probably fine for the vast majority of users.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=857#c8) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=856) created by **ogregoire** on 2012-01-04 at 04:54 PM_
---
Similarly to the issue 669, I'd like to see a method Optional.filter(Predicate).
If this optional is absent, it returns itself (absent).
If this optional is present, its value is tested against Predicate. If the test is true, then it returns itself else it returns absent.
Right now it is possible to do this this way, which I find quite unelegant:
Optional&lt;X> optional = ...;
Predicate<? super X> predicate = ...;
if (optional.isPresent() && !predicate.apply(optional.get())) {
&nbsp;&nbsp;optional = Optional.absent();
}
Thanks!
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=856#c1) posted by **wasserman.louis** on 2012-01-04 at 05:50 PM_
---
I'd like to propose an alternative: when FluentPredicate comes around (Issue 11), add this as an overload of FluentPredicate.filter?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=856#c2) posted by **wasserman.louis** on 2012-01-05 at 08:53 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Base`, `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=856#c3) posted by **ogregoire** on 2012-01-06 at 10:23 AM_
---
After pondering on your suggestion, I think it's a good idea: it's quite logical if you think about how FluentPredicate will likely act. But I fear the functionality would then be too hidden in the Guava API.
My point here is that people already have Predicates in their code for a long time now, not FluentPredicates. I think it's useful to have this functionality in some other place than FluentPredicates, even if it is temporary to allow people switch to FluentIterables.
I'm not saying the functionality should be on the class Optional itself, but that would make it more visible.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=856#c4) posted by **wasserman.louis** on 2012-01-06 at 04:43 PM_
---
I think the biggest reason we're hesitant about this and 816 is because there's the huge risk of abuse of functional idioms.  As it stands, the approach we're taking is if you're _absolutely_ sure it's the right thing to do, then write your own helper method along these lines.
I think making these decisions is probably something we'll be doing before release 12: whether or not these are a good idea.
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=856#c5) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=856#c6) posted by **kevinb@google.com** on 2012-02-16 at 09:47 PM_
---
At this point it is a lot less clear to us why this would be useful than the case of Optional.transform().  If anyone can provide compelling examples that would help.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=856#c7) posted by **ogregoire** on 2012-03-12 at 01:38 PM_
---
Sorry for the long interval. I was taking time to make sure my point of view was complete. This reflects all I think about this enhancement. I might want to refine things, but the essence of my thought is here.
Optional is a wrapper, an artificial structure. It's doing stuff about an object and not on an object. I claim that filtering a unique object is also working about that object and not on the object. I'd also think that it doesn't feel really natural to get() the object until I'm quite sure I really want it. I think that therefore filtering it makes sense.
An other part is lazyness. I love lazyness. And making my if-statement as small as possible. I figure that since you already the object is already wrapped, why not have that wrapper perform some basic actions about the object rather than on the object. When I'd want to perform action on the object, then I'll get it, if there is still a point in it.
Although "filter" is certainly not the best word, in my limited English vocabulary, it's the best and it's consistent with what we use in other components of Guava. If you want an analogy for a better word think about the children game where they have to put shapes in holes. I really wish I could help further here. I often think about "reduce" or "cut" but these lack the positive context that a predicate induces (basically they say: "if not x then y" instead of "if x then y").
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=856#c8) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=856#c9) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=856#c10) posted by **tomas.zalusky** on 2012-11-09 at 04:44 PM_
---
I agree with ogregoire and vote for this issue too. (I was going to fill issue if I would not find this one.)
In my use case I need to return a property of an object at the end of a chain if objects in chain satisfy some condition.
If I understand correctly the FluentPredicate.filter(Optional) method,
the predicate-centric approach would disrupt chain manner and establish start-reading-in-middle-and-continue-to-both-sides manner instead, which would be no worth using Optional at all in comparsion with plain old imperative style.
// proposed form via Optional.filter
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter(compose(in(allowedFooNames),Foo.NAME_FUNCTION))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.transform(Foo.BAR_FUNCTION)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter(compose(in(allowedBarNames),Bar.NAME_FUNCTION))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.transform(Bar.BAZ_FUNCTION);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FluentPredicate.from(compose(in(allowedFooNames),Foo.NAME_FUNCTION))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter(Optional.of(foo))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.transform(Foo.BAR_FUNCTION)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.transform(Bar.BAZ_FUNCTION);
// roughly equivalent imperative code
if (allowedFooNames.contains(foo.getName())) {
&nbsp;&nbsp;&nbsp;&nbsp;Bar bar = obj.getBar();
&nbsp;&nbsp;&nbsp;&nbsp;if (allowedBarNames.contains(bar.getName())) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Baz baz = bar.getBaz();
&nbsp;&nbsp;&nbsp;&nbsp;}
}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=856#c11) posted by **cpovirk@google.com** on 2012-11-09 at 04:49 PM_
---
That makes sense, but I think that your example shows why filtering is less of a win for a single element. I think we can further simplify the imperative code to:
if (allowedFooNames.contains(foo.getName())
&nbsp;&nbsp;&nbsp;&nbsp;&& allowedBarNames.contains(foo.getBar().getName())) {
&nbsp;&nbsp;Baz baz = bar.getBaz();
}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=856#c12) posted by **wasserman.louis** on 2012-11-09 at 05:04 PM_
---
Yup.  The imperative code here looks great.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=856#c13) posted by **tomas.zalusky** on 2012-11-09 at 08:02 PM_
---
I agree (except bar should be foo.getBar() in Chris' example and if multiple call of getBar() is not suitable, one must split && condition and store getBar() result into variable). Fluent code outweighs after certain length of chain.
I wouldn't use fluent version after sole addition of Optional.filter method but if transformToNullable were added too, I would at least consider fluent version for its readability.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=856#c15) posted by **ogregoire** on 2013-05-17 at 03:06 PM_
---
Another example I just encountered:
public Optional&lt;User> login(String email, char[] password) {
&nbsp;&nbsp;if (!user.isPresent()) {
&nbsp;&nbsp;&nbsp;&nbsp;return Optional.absent();
&nbsp;&nbsp;}
&nbsp;&nbsp;User u = user.get();
&nbsp;&nbsp;if (!u.isActive()) {
&nbsp;&nbsp;&nbsp;&nbsp;return Optional.absent();
&nbsp;&nbsp;}
&nbsp;&nbsp;if (!passwordService.isPasswordValid(u.getPasswordHash(), password) {
&nbsp;&nbsp;&nbsp;&nbsp;return Optional.absent();
&nbsp;&nbsp;}
&nbsp;&nbsp;doLogin(u);
&nbsp;&nbsp;return user;
}
I refactored to this:
public Optional&lt;User> login(String email, char[] password) {
&nbsp;&nbsp;if (user.isPresent()) {
&nbsp;&nbsp;&nbsp;&nbsp;User u = user.get();
&nbsp;&nbsp;&nbsp;&nbsp;if (u.isActive()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&& passwordService.validatePassword(u.getHash(), password)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doLogin(u);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;}
&nbsp;&nbsp;return user;
}
It could still be much more readable if it looked like this:
public Optional&lt;User> login(String email, char[] password) {
&nbsp;&nbsp;user = user.filter(Users.isActivePredicate())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter(passwordService.isPasswordValidPredicate(password));
&nbsp;&nbsp;if (user.isPresent()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doLogin(user.get());
&nbsp;&nbsp;}
&nbsp;&nbsp;return user;
}
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=838) created by **adrianwkirk** on 2011-12-24 at 03:04 PM_
---
It would be extremely to be able to assign a priority to listeners so that high priority listeners get served before the lower priority listeners. Why is this useful? An example would be a trading engine. Market data comes in, you would want to serve your calculators first before feeding your trade decision object before feeding your publishers.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=838#c1) posted by **wasserman.louis** on 2011-12-25 at 11:16 AM_
---
I'm going to classify this under the general heading of "make EventBus extensible."  Then you could e.g. add your own annotation specifying a priority, or something.
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=838#c2) posted by **wasserman.louis** on 2012-01-05 at 08:46 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Enhancement`, `Package-EventBus`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=838#c3) posted by **kevinb@google.com** on 2012-01-31 at 07:49 PM_
---
Are you suggesting that "feeding your publishers" is dependent on data that's generated by "your calculators?"  If so, have the calculators post a new event and have the other party subscribe to that?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=838#c4) posted by **adrianwkirk** on 2012-02-02 at 01:57 PM_
---
Hi,
No not dependent on the data. Most of the high performance trading systems I have worked on have a similar concept to the event bus (hence my interest) with added the added feature of high to low priority listeners. Listeners are given the event in order of their priority.
Filtering is also another feature on the in house versions of this concept, but I think you already have this on your to do list.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=838#c5) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=838#c6) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=838#c7) posted by **b.diedrichsen** on 2012-11-17 at 11:32 AM_
---
I recently added support for handler ordering by priority to my own event bus implementation (MBassador). It also uses weak references and supports event filtering, synchronous and asynchronous dispatch and more.
It is also quite fast. I created a performance and feature comparison for a selection of available event bus implementations including Guava, MBassador and some more. The results are quite interesting. Check it out here
http://codeblock.engio.net/?p=37
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=831) created by **toellrich** on 2011-12-22 at 05:59 AM_
---
Once issue 830 is fixed, I intend to use Guavas Hashing API for creating password hashes. At the moment, the code would look something like this:
public static String encodePassword(String password, String salt) {
&nbsp;&nbsp;HashFunction func = Hashing.sha256();
&nbsp;&nbsp;HashCode result = func.hashString(password + salt, UTF_8);
&nbsp;&nbsp;for (int i = 0; i < ITERATION_COUNT; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;result = func.hashBytes(result.asBytes());
&nbsp;&nbsp;}
&nbsp;&nbsp;return salt + result.toString();
}
I was wondering if the possibility of hashing a hash n times could be added to the API? Also, a salt generator that generates random hexadecimal values of a given length would be very useful.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=831#c1) posted by **wasserman.louis** on 2011-12-22 at 05:59 PM_
---
I suspect that your "salt generator" would be adequately implemented by SecureRandom...no?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=831#c2) posted by **toellrich** on 2011-12-22 at 06:10 PM_
---
Absolutely. I currently use the following code to generate salts that are 10 chars long, but the length should probably be configurable.
private static final SecureRandom random = new SecureRandom();
private static final int SALT_LENGTH = 10;
public static String getRandomSalt() {
&nbsp;&nbsp;String randomHexString = new BigInteger(40, random).toString(16);
&nbsp;&nbsp;String result = Strings.padStart(randomHexString, SALT_LENGTH, '0');
&nbsp;&nbsp;assert result.length() == SALT_LENGTH;
&nbsp;&nbsp;return result;
}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=831#c3) posted by **wasserman.louis** on 2011-12-22 at 06:20 PM_
---
I was assuming you'd be interested in salt as a byte[], which is the form I'd expect you to actually end up using?  And a SecureRandom lets you just do nextBytes(byte[]).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=831#c4) posted by **toellrich** on 2011-12-22 at 08:43 PM_
---
I have to store the salt as well as the password hash at some point in the database and the last time I checked, Hibernate's/Oracle's support for byte arrays was a bit iffy. Therefore, i decided to simply convert everything to String.
By the way, I've created a utility class for creating secure password hashes:
http://pastebin.com/T8yUi72S
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=831#c5) posted by **neveue** on 2011-12-22 at 11:13 PM_
---
Semi off-topic, but I'd use bcrypt instead of salted / stretched SHA-256 for password hashing:
It's more secure, and it's also simpler to use, since it handles salting / stretching for you.
There is a java implementation at
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=831#c6) posted by **toellrich** on 2011-12-23 at 03:02 AM_
---
bcrypt looks like a great library. It's "only" version 0.3, though, which might be a dealbreaker for the guys at my company who are in charge of deciding about using a 3rd party library like that. It was tough getting them to allow Guava.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=831#c8) posted by **neveue** on 2011-12-23 at 06:46 AM_
---
The java implementation (jBCrypt) is indeed in version 0.3, and I guess that might be a problem to get it accepted as a 3d party library...
bcrypt itself is 12 years old, though, and the java implementation is only one of many implementations. I think the version 0.3 thing is just a version naming scheme problem, since the Java implementation is quite old (version 0.1 was released in May 2006, 0.2 in April 2008, and 0.3 in February 2010).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=831#c9) posted by **toellrich** on 2011-12-23 at 01:00 PM_
---
Yeah, sorry, that's what I meant: jbcrypt. I also wanted to add that the passwords I want to hash are for users that are all employees of our company and they are for an application that drives our business, but which is not accessible from the outside. I'm just looking for a simple, but fairly secure encoding that is better than storing the passwords as plain texts (which is how they are stored at the moment!). A hacker wouldn't really have much to gain by cracking the passwords, except for disrupting our business processes (which might be all they want to do).
Nevertheless, using a 3rd party library at version 0.3 might not be justifiable in this case.
After reading the blog by Coda Hale, I've updated the above code to hide the salt inside the hash at an offset based on the password's length. A hacker should not be able to discern what the salt is which should make cracking the encoding all the more difficult:
http://pastebin.com/t2PwAZHY
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=831#c10) posted by **wasserman.louis** on 2011-12-24 at 04:15 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=831#c11) posted by **wasserman.louis** on 2012-01-05 at 08:53 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Enhancement`, `Package-Hash`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=831#c12) posted by **kevinb@google.com** on 2012-01-10 at 11:53 PM_
---
It doesn't seem clear that Guava needs to add anything. I think a user could pretty easily create a HashFunction implementation that delegates to another HashFunction and feeds the result through itself N times; if not, please let us know.
---
**Status:** `WontFix`
via https://crackstation.net/hashing-security.htm
To Store a Password
1. Generate a long random salt using a CSPRNG (for Java, they recommend SecureRandom).
2. Prepend the salt to the password and hash it with a standard cryptographic hash function such as SHA256.
3. Save both the salt and the hash in the user's database record.
So I think you've overcomplicating the problem. Just use SecureRandom and Hashing.sha256().
I think the most relevant part of that page is this:
Don't try to invent your ownsimply iteratively hashing the hash of the
password isn't enough as it can be parallelized in hardware and executed as
fast as a normal hash. Use a standard algorithm like PBKDF2
On Tue, Feb 17, 2015 at 8:46 AM, Kurt Alfred Kluever <
notifications@github.com> wrote:
> "It's easy to get carried away and try to combine different hash
> functions, hoping that the result will be more secure. In practice, though,
> there is very little benefit to doing it"
> via https://crackstation.net/hashing-security.htm
>
> To Store a Password
> 1. Generate a long random salt using a CSPRNG (for Java, they recommend
> SecureRandom).
> 2. Prepend the salt to the password and hash it with a standard
> 3. Save both the salt and the hash in the user's database record.
>
> So I think you've overcomplicating the problem. Just use SecureRandom and
> Hashing.sha256().
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/831#issuecomment-74701416.
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=828) created by **tomerb** on 2011-12-16 at 08:43 PM_
---
It seems that because all fields in AbstractMultimap are transient, the GWT exposure computer decides that the the map values are not exposed, and omits the value type from the serialization policy.
Please see the attached file. I've modified the GWT demo project to show this error.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=828#c1) posted by **cpovirk@google.com** on 2011-12-16 at 09:39 PM_
---
We worked around this for (most of?) the immutable classes a long time ago, but we haven't done so for all other classes.  The reasoning was that users would declare an RPC interface parameter as Multimap or else Immutable{,Set,List}Multimap but not some non-immutable, non-interface type like ArrayListMultimap.  If you do that, I think the problem will go away.
There are two directions we could go from here:
1) Document this somewhere.
2) Make it work.
I've been slightly resistant to (2) because it requires us to make some classes that "should" be final non-final and to introduce some more weird code, but maybe we just should.  Is it useful for your project to declare a parameter of type ArrayListMultimap instead of Multimap or an immutable type?
(I'll be on vacation shortly, so I may not see your response, but I'll check this bug when I return.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=828#c3) posted by **tomerb** on 2011-12-18 at 04:47 AM_
---
Thanks for the quick response.
Unfortunately, your suggestion didn't work. Both ListMultimap and ImmutableListMultimap cause the same exception as before:
Caused by: com.google.gwt.user.client.rpc.SerializationException: Type 'test.shared.DemoObj' was not included in the set of types which can be serialized by this SerializationPolicy or its Class object could not be loaded. For security purposes, this type will not be serialized.: instance = test.shared.DemoObj@608d5908
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=828#c4) posted by **neveue** on 2011-12-18 at 10:33 PM_
---
Seems like the problem is that your "DemoObj" is not included in the serialization policy whitelist. I guess that's because your method signature returns a collection of DemoObj, and GWT fails to resolve the DemoObj type from the generic method signature. You need to add a "dummy" method that takes "DemoObj" as a parameter, to force GWT to add it to the whitelist.
More info:
http://stackoverflow.com/questions/4202964/serializationpolicy-error-when-performing-rpc-from-within-gwt-application
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=828#c5) posted by **tomerb** on 2011-12-19 at 04:43 AM_
---
I'm aware of this workaround, thanks.
However, messing up the interface is hardly the correct solution.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=828#c6) posted by **wasserman.louis** on 2011-12-21 at 12:05 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Collect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=828#c7) posted by **cpovirk@google.com** on 2012-01-04 at 08:10 PM_
---
We broke serialization of a bunch of collection types in r10 (but only in the public release, so our internal tests didn't see the problem): https://github.com/google/guava/issues/791
It's fixed in r11.  Please let me know whether that solves the problem for ListMultimap and ImmutableListMultimap.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=828#c8) posted by **kevinb@google.com** on 2012-01-10 at 11:48 PM_
---
If someone can list all our collection types that can't currently be gwt-serialized, we can evaluate those.
---
**Status:** `Triaged`
**Labels:** -`Type-Defect`, -`Priority-Medium`, `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=828#c9) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=828#c10) posted by **tomerb** on 2012-04-19 at 04:22 AM_
---
I can verify that version 11.0.2 works with ListMultimap.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=828#c11) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=828#c12) posted by **cpovirk@google.com** on 2013-01-08 at 04:56 PM_
---
(adding more to this bug because I'm about to direct a StackOverflow questioner here)
You can find the classes that _are_ GWT serializable here:
http://code.google.com/p/guava-libraries/source/browse/#git%2Fguava-gwt%2Fsrc%2Fcom%2Fgoogle%2Fcommon%2Fcollect
In short, that consists of:
- most of the immutable collections implementations (often with separate Empty, Regular, and Singleton serializers, as required)
- most of the Table implementations (as we didn't use to have ImmutableTable, so they were the best available choice)
- most of the Ordering implementations
We could add more, but there is a downside: Consider an application containing an GWT RPC interface that returns Multimap&lt;Foo, Bar>. Because the client side might receive any serializable Multimap&lt;Foo, Bar>, the GWT compiler must generate client-side code for all such implementations. If only a couple implementations are serializable, that's not so bad. But if every implementation is serializable, that's a lot of bloat in an environment where bloat is a big concern.
Another small concern is that we may want to switch our serializer implementations to implement CustomFieldSerializer: http://google-web-toolkit.googlecode.com/svn/javadoc/latest/com/google/gwt/user/client/rpc/CustomFieldSerializer.html The more implementations we have, the more effort to switch. But this is a minor concern, and it's more of a reason to delay than a reason to never make the change.
One final note: The problem runs deeper than |transient|: GWT, for reasons I'm not familiar with, can't serialize |final| fields, and it requires no-arg constructors. We have plenty of |final| fields and few no-arg constructors, so we need to manually support every class's serialization.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=828#c13) posted by **cpovirk@google.com** on 2013-01-08 at 05:16 PM_
---
More on the requirements for GWT serialization: https://developers.google.com/web-toolkit/doc/latest/DevGuideServerCommunication#DevGuideSerializableTypes
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=828#c14) posted by **lowasser@google.com** on 2013-01-08 at 05:24 PM_
---
StackOverflow had a report that HashBiMap wasn't GWT-serializable...?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=828#c15) posted by **cpovirk@google.com** on 2013-01-08 at 05:26 PM_
---
Yes, and I just now told him to consider ImmutableBiMap or, if that's not an option, to post here.
http://stackoverflow.com/questions/14137042/hashbimap-serializationexception-or-how-to-serialize-classes-where-isserializabl
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=828#c16) posted by **alex.waters** on 2013-02-02 at 02:17 AM_
---
Just thought I'd confirm the problem with HashBiMap - Google brought me here - and from link in #c15 I was able to get it working (implementing a HashBiMap_CustomFieldSerializer).
GWT RPC was throwing a fit about no non-private no-args constructors (using 13.0.1 if that matters).
With regards to the non-serialized final fields mentioned end of #c12, that is thankfully - finally! - fixed (either GWT 2.5.1 or post release):
http://code.google.com/p/google-web-toolkit/issues/detail?id=1054
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=818) created by **em...@soldal.org** on 2011-12-09 at 08:15 AM_
---
The only drawback we're seeing is that the code becomes increasingly difficult to follow, so I want to propose the following class.
If we could add this method to Functions.java:
public static &lt;A,B> FunctionComposer&lt;A,B> composer(Function&lt;A,B> delegate) {
&nbsp;&nbsp;&nbsp;return new FunctionComposer&lt;A,B>(delegate);
}
we could use the following code to provide a better composition API:
https://gist.github.com/1450697
Thanks,
&nbsp;Emily
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=818#c2) posted by **drothmaler** on 2011-12-09 at 01:58 PM_
---
See Issue 11
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=818#c3) posted by **em...@soldal.org** on 2011-12-09 at 02:00 PM_
---
Ah, I wasn't aware that Issue 11 was more than FluentIterables :)
Someone feel free to merge these then.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=818#c4) posted by **wasserman.louis** on 2011-12-09 at 07:08 PM_
---
Done.
---
**Status:** `Duplicate`
**Merged Into:** #11
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=818#c5) posted by **piotr.findeisen** on 2012-05-21 at 09:09 AM_
---
Issue 11 is already resolved in guava 12, but the need to something like "FluentFunction" remains -- an implementation of Function with batteries included, like Ordering for Comparator interface.
Or, am i missing some class in the API?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=818#c6) posted by **cpovirk@google.com** on 2012-08-03 at 01:28 PM_
---
Reopening now that issue 11 was closed specifically for FluentIterable.
---
**Status:** `Accepted`
**Merged Into:**
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=818#c7) posted by **cpovirk@google.com** on 2012-08-03 at 01:28 PM_
---
_Issue #1094 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=818#c8) posted by **kevinb@google.com** on 2013-04-08 at 06:58 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Base`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=807) created by **goo...@sa.me.uk** on 2011-11-29 at 10:27 PM_
---
EventBus maintains a strong reference to registered objects, and objects can't easily be wrapped in a WeakReference because that would need to @Subscribe to the same events.
WeakEventBus would use a WeakReference to refer to registered objects and unregister them automatically using a ReferenceQueue.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=807#c1) posted by **wasserman.louis** on 2011-11-30 at 05:03 AM_
---
Could you explain an actual real-world use case?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=807#c2) posted by **goo...@sa.me.uk** on 2011-11-30 at 07:35 AM_
---
I'm using an EventBus to handle locale changes at runtime. If I subscribe every new Action object (so that its name can be changed automatically) then they stay referenced by the EventBus forever.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=807#c3) posted by **wasserman.louis** on 2011-11-30 at 08:49 PM_
---
Is there a point where you can explicitly use the unregister() method of EventBus?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=807#c4) posted by **goo...@sa.me.uk** on 2011-11-30 at 09:04 PM_
---
They're added to a temporary JPopupMenu. Every Action has a strong reference to JPopupItem via the PropertyChangeListener so it never calls removePropertyChangeListener(). I could try having the Action use FinalizableWeakReferences to its listeners.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=807#c5) posted by **goo...@sa.me.uk** on 2011-11-30 at 09:38 PM_
---
This isn't very practical as PropertyChangeSupport makes a distinction between PropertyChangeListener and PropertyChangeListenerProxy. I'd need to have two versions of the weak references as the implementation of PropertyChangeListenerProxy relies on PropertyChangeSupport filtering the events.
I've tried implementing a WeakEventBus but it's not currently working (although a proxy listening object with a WeakReference to the original listening object worked).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=807#c6) posted by **goo...@sa.me.uk** on 2011-11-30 at 09:48 PM_
---
The implementation of AbstractButton is careful not to maintain a strong reference to the Action when adding itself as a PropertyChangeListener of the Action.
It uses a proxy object that only has a strong reference to the AbstractButton (JMenuItem). If I weakly reference that object from the Action then nothing will have a strong reference to it and it could disappear while it should still exist.
GC Root -> EventBus -> Action -> ButtonActionPropertyChangeListener -> JMenuItem
GC Root -> JPopupMenu -> JMenuItem -> Action
If I use a weak reference for Action -> ButtonActionPropertyChangeListener then it could drop the ButtonActionPropertyChangeListener while the JPopupMenu still exists:
GC Root -> EventBus -> Action
GC Root -> JPopupMenu -> JMenuItem -> Action
There's then no way for the Action to call the JMenuItem when its properties are changed and it would mistakenly assume it has no listeners so unregister itself from the EventBus.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=807#c7) posted by **goo...@sa.me.uk** on 2011-11-30 at 09:55 PM_
---
(My WeakEventBus is working, I just didn't have the right log level to see it doing the cleanup)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=807#c8) posted by **goo...@sa.me.uk** on 2011-11-30 at 10:26 PM_
---
Actually, ButtonActionPropertyChangeListener doesn't do what its comments imply it is supposed to do because AbstractButton maintains a reference to it. There's a lot of "don't use an anonymous subclass" comments in the source but then it stores a reference to "this".
For AbstractButton (JMenuItem) <-> Action they need strong references to each other in order to be able to call their respective listener events.
JPopupMenu doesn't clear out its items when the menu is hidden because it's reusable, so the reference from the EventBus becomes a problem as it keeps these two components alive.
I can't use PopupMenuListener from the Action to detect when the menu is visible/invisible because it never sees the JPopupMenu, only the proxy object for JMenuItem.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=807#c9) posted by **goo...@sa.me.uk** on 2011-11-30 at 11:33 PM_
---
If I handle PopupMenuListener.popupMenuWillBecomeInvisible() I can set the Action to null on all the AbstractButtons and then have the Action detect when there are no PropertyChangeListeners, but that's very messy and it relies on the JPopupMenu clearing out the references from all its components when it's hidden.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=807#c10) posted by **wasserman.louis** on 2011-12-02 at 06:20 PM_
---
I agree that this is not a use case that EventBus currently handles, but I'm not yet sure that weak references are the only way, or the best way, to address this use case.
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=807#c11) posted by **fry@google.com** on 2011-12-05 at 07:00 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=807#c12) posted by **cbiffle@google.com** on 2011-12-09 at 06:14 PM_
---
This reminds me of NSNotificationCenter in Cocoa, which has always used weak references (and recently switched to proper zeroing weak references, rather than crashing weak references).  NSNotificationCenter influenced the design of EventBus from my previous experience in Objective-C.  EventBus probably would have used weak references from the start, except that the application I built it for wound up with data processing objects that were _only_ retained by the bus.
I'm not sure a bus-wide weak reference policy is the right approach, though it would work.  Perhaps the right thing would be to have object-by-object control at the register level?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=807#c13) posted by **fry@google.com** on 2011-12-10 at 04:24 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-EventBus`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=807#c14) posted by **limpbizkit** on 2012-01-31 at 07:58 PM_
---
One solution is to create your own subscriber class that takes care of the weak reference:
public class WeakExample {
&nbsp;&nbsp;&nbsp;&nbsp;public static class HeavyListener {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void receiveEvent(Object event) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(event);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
```
public static class WeakEventDispatcher {
private final WeakReference<HeavyListener> ref;
private final EventBus eventBus;
WeakEventDispatcher(HeavyListener listener, EventBus eventBus) {
this.ref = new WeakReference<HeavyListener>(listener);
this.eventBus = eventBus;
}
@Subscribe public void subscribe(Object event) {
HeavyListener l = ref.get();
if (l == null) {
eventBus.unregister(this);
} else {
l.receiveEvent(event);
}
}
}
public static void main(String[] args) {
HeavyListener heavyListener = new HeavyListener();
EventBus eventBus = new EventBus();
eventBus.register(new WeakEventDispatcher(heavyListener, eventBus));
eventBus.post("hello");
}
```
}
This is simple and predictable. And if you're willing, it allows you to use a ReferenceQueue to deregister the listener eagerly.
---
**Status:** `Fixed`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=807#c15) posted by **goo...@sa.me.uk** on 2012-01-31 at 08:04 PM_
---
I don't see how this fixes the issue because you're assuming that I want to subscribe to Object and not arbitrary event types (for which I'd need a separate dispatcher).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=807#c16) posted by **kevinb@google.com** on 2012-02-01 at 06:29 AM_
---
I actually agree it was a misfire to mark it "fixed", Jesse.
I really want to know if this is something that a _lot_ of users would find themselves wanting to do, and am still receptive to adding something like an EventBus.weakRegister() if so.
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=807#c17) posted by **b.diedrichsen** on 2012-02-09 at 01:06 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=807#c18) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=807#c19) posted by **jborden** on 2012-04-04 at 07:00 PM_
---
The issue I'm facing is a case I have an instance of a Cache that is Session Scoped using Guice that needs to handle events fired by a Singleton Scoped mechanism.
It seems that Guice does not provide a mechanism through which I can handle the event of the Session Scoped instance becoming unbound ( http://code.google.com/p/google-guice/issues/detail?id=62 ).  Consequentially, I cannot explicitly unregister my Session Scoped listener from the event bus.
It seems that I should be able to get by using the workaround presented in Comment 14 but it seems that adding something like an EventBus.weakRegister(...) method would be ideal for this scenario.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=807#c20) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=807#c21) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
---
Is any work is being done for this feature?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=807#c23) posted by **b.diedrichsen** on 2012-10-23 at 08:50 AM_
---
It has been a while since nothing happened here regarding that feature. Since I was in desperate need for a solution that uses weak references I created my own. We have been using it in production for half a year now and it works perfectly. It is well documented and works very similar to guavas event bus (although its a bit faster).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=807#c24) posted by **vojtek44** on 2012-12-10 at 04:07 PM_
---
Well, I find myself to need this feature too - I register new beans from Spring IoC automatically in event bus and it would be great if EventBus would not consider them when they are out of their scope. In my case the solution from #14 is good enough, however a weakRegister() method would be much better.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=807#c25) posted by **r...@bogocorp.com** on 2013-03-02 at 12:05 AM_
---
The solution in #14 is interesting, but to truly be awesome the WeakEventDispatcher class would take a plain Object as the heavy listener, inspect it for @Subscribe methods and dispatch events as appropriate. And yes, a ReferenceQueue for quicker cleanup would be nice.
But, having the WeakEventDispatcher @Subscribe to Object events and then potentially ignore them means that DeadEvents won't work.
That, I think, can only be solved by building weak subscriptions directly into EventBus.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=807#c26) posted by **progoth** on 2013-08-28 at 04:28 PM_
---
I'm using Guice to register all my injections with the eventbus, and using Providers to create (swing) dialogs that communicate with a database controller using guava eventbus. For dialogs to not need eventbus cleanup I'd have to write and maintain reset methods for each to go back to their default state, and every dialog (or opened dialog, if using lazy vals with Providers) would stay in memory for the life of the application.
def using[T](prov: Provider[T])(f: T => Unit) {
&nbsp;&nbsp;&nbsp;&nbsp;val t = prov.get
&nbsp;&nbsp;&nbsp;&nbsp;ultimately(eventBus.unregister(t))(f(t))
}
which I may do. I'll probably take a look at MBassador, at least for some projects where there are few classes that need strong references and those can be specified with class annotations (adding weakRegister to eventbus would require guice to register everything weakly and then I'd have to maintain references to some classes manually).
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=806) created by **ogregoire** on 2011-11-28 at 08:16 PM_
---
I recently modified all of my reader method to accept InputSupplier as parameter instead of the usual InputStream or the Reader and I started doing the same for my OutputStreams and Writers.
I would be nice to add the following to the API:
- NullWriter;
- Null{OutputStream/Writer} suppliers as factory methods;
- ByteArrayOutputStream/CharArrayWriter suppliers or suppliers that allow writing to a given byte/char array.
I know I can easily make a NullWriter (by making new OutputStreamWriter(new NullOutputStream())), but this is so unnatural since, with java.io, we expect to see the mirror classes when possible.
I had to write all this code today, but I'm quite sure everybody can benefit from it (even if this is now quite old and no one suggested it before).
If accepted, can this still make it for release 11?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=806#c1) posted by **wasserman.louis** on 2011-11-29 at 04:04 PM_
---
This is not particularly my area, but...it's not clear to me how a ByteArrayOutputStream supplier would work.
Presumably this would be built as a wrapper around java.io.ByteArrayOutputStream, but how would the supplier let you get out the resulting byte array?  The point of using a supplier is that the stream gets initialized, written, and closed without the programmer being able to mess it up or see the stream at all, and without access to the stream, how would the programmer request the result byte array?
(And while I think a few of these suggestions might be useful, I feel obligated to add a reminder that Guava does _not_ add utilities just for the sake of being "parallel" to the JDK, for the sake of being "complete," or anything of the sort.  Feature requests must stand on their own merits for consideration.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=806#c2) posted by **ogregoire** on 2011-11-29 at 04:55 PM_
---
@Test public void testWriteObjectToStream() throws IndexOutOfBoundException {
&nbsp;&nbsp;MyObject myObject = ...;
&nbsp;&nbsp;byte[] expected = ...;
&nbsp;&nbsp;byte[] buffer = new byte[];
&nbsp;&nbsp;writeObjectToStream(myObject, ByteStreams.newBufferOutputSupplier(buffer));
&nbsp;&nbsp;assertTrue(Arrays.equals(expected, buffer));
}
By the way, I completely understand that Guava doesn't feel to be as parallel as JDK is. This has been demonstrated in several cases and that's precisely why I added the fact that I know how to quickly make a NullWriter. Anyways, in no way I'm forcing Guava's development team to make these as 1. it's not my code: I'm just giving ideas (that I would really like to see in there) and 2. I've already added all these utilities in my own ByteStream2 class. Here I'm just sharing my experience: these are useful methods/classes (ok, maybe not the BAOS and CAW suppliers) and I think people should use them.
If I knew how to use git, I would already have provided the code in a clone for these so it would just be a question of usefulness and code-checking.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=806#c3) posted by **wasserman.louis** on 2011-11-30 at 05:05 AM_
---
Suggestions, feedback from real users, requests, etc. are always appreciated.  =)
My concern with ByteStreams.newBufferOutputSupplier(buffer) is that it can't handle buffer overflow or resizings.  Suggestions?
---
Well, that buffer is used for tests as shown in my use case. So it should meet certain requirements at some points. One of them is the size. So if it throws an IndexOutOfBoundException, I don't really care as my test fails anyways.
In my case, if I need an on-the-fly resizing, there is still the BAOS and the CAW and a dynamic one-time supplier around them. This is really not a big deal. Again, I'm speaking about my use case, so I might miss something in the big picture.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=806#c5) posted by **fry@google.com** on 2011-12-05 at 07:00 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=806#c6) posted by **fry@google.com** on 2011-12-10 at 04:23 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-IO`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=806#c7) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=806#c8) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=806#c9) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=806#c10) posted by **phwendler** on 2013-03-04 at 11:31 AM_
---
I also would like to see CharStream.nullWriter() being added to Guava.
Actually I only use nullOutputStream() for cases where I need a null writer. Writing "new OutputStreamWriter(ByteStreams.nullOutputStream())" hides the important part of this line (the "null") quite deeply in boiler-plate code. Furthermore, using an OutputStreamWriter without an explicitly specified encoding is a smell, but here it's ok, so it blurs the line between bad code and good code (just flagging all usages of this OutputStreamWriter automatically would give false positives). Last but not least, it does useless work at runtime (encoding the output which will be immediately discarded), and I should not use an OutputStreamWriter in a constant field because the StreamEncoder it uses is synchronized and thus this might lead to unnecessary thread contention.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=799) created by **g.j.bowyer** on 2011-11-21 at 07:36 PM_
---
Hi guys
specifically the code that is hidden in gdata here http://code.google.com/p/gdata-java-client/source/browse/#svn%2Ftrunk%2Fjava%2Fsrc%2Fcom%2Fgoogle%2Fgdata%2Futil%2Fcommon%2Fbase
These are about the best format escapers I have come across in a long time and have allowed us to replace a huge number of in house hack jobs.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=799#c1) posted by **cgdecker** on 2011-11-21 at 08:05 PM_
---
This is already in for 11.0!
https://google.github.io/guava/apidocs/com/google/common/escape/package-summary.html
---
**Status:** `Fixed`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=799#c2) posted by **g.j.bowyer** on 2011-11-21 at 08:37 PM_
---
Sweet !!
Thanks that is awesome
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=799#c3) posted by **kevinb@google.com** on 2011-11-21 at 11:04 PM_
---
Well, this made my day. :)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=799#c4) posted by **cgdecker** on 2011-11-22 at 03:17 AM_
---
_(No comment entered for this change.)_
---
**Labels:** `Milestone-Release11`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=799#c5) posted by **wasserman.louis** on 2011-12-17 at 05:17 PM_
---
I observe that this has been "removed for the moment."  ??
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=799#c6) posted by **xaerxess** on 2012-01-03 at 04:00 PM_
---
Escape library didn't make its way to release 11, as far as I can see...
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=799#c7) posted by **cgdecker** on 2012-01-03 at 04:16 PM_
---
Well, I'm not sure what the plan is for this now. I'll just reopen this and let someone else update it if there's more information.
---
**Status:** `Triaged`
**Labels:** -`Milestone-Release11`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=799#c8) posted by **wasserman.louis** on 2012-01-03 at 06:10 PM_
---
I think it's fair to mark this as "started," since it was briefly in Git?
---
**Status:** `Started`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=799#c9) posted by **garretdwilson** on 2012-04-27 at 04:52 PM_
---
Darn, I was looking for a common escaping library, and I got all happy when I read this. I got less happy when I tried to access it in guava 11.02 in my IDE... :(
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=799#c10) posted by **wasserman.louis** on 2012-04-27 at 05:11 PM_
---
---
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=799#c11) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=799#c12) posted by **kevinb@google.com** on 2012-06-22 at 06:57 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-General`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=799#c13) posted by **ori.schwartz** on 2012-08-29 at 08:53 PM_
---
Closure templates has a very thorough implementation of this in package com.google.template.soy.internal.base .
The API is clean, it has been used in production for a long time, it performs well, and it's already open source:
http://code.google.com/p/closure-templates/source/browse/#svn%2Ftrunk%2Fjava%2Fsrc%2Fcom%2Fgoogle%2Ftemplate%2Fsoy%2Finternal%2Fbase
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=799#c14) posted by **cpovirk@google.com** on 2012-08-29 at 08:58 PM_
---
Indeed, that's our implementation, temporarily clone into Closure's codebase until we get our act together :)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=799#c15) posted by **wasserman.louis** on 2012-08-29 at 09:22 PM_
---
If the guys working on this think the API can be improved still further, I'm inclined to wait.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=799#c16) posted by **shaki6a** on 2013-03-01 at 03:20 AM_
---
Is there any update on this issue?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=799#c17) posted by **kak@google.com** on 2013-03-01 at 03:36 AM_
---
---
**Labels:** `Milestone-Release15`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=799#c18) posted by **cpovirk@google.com** on 2013-04-22 at 06:09 PM_
---
They're out -- for good this time:
https://github.com/google/guava/commit/0beafad032035936df0898c71229d63acd57a0ac
https://google.github.io/guava/apidocs/com/google/common/escape/package-summary.html
https://google.github.io/guava/apidocs/com/google/common/net/PercentEscaper.html
They'll be in release 15.
---
**Status:** `Fixed`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=799#c19) posted by **ipremraj11** on 2013-04-22 at 06:11 PM_
---
Awesome! Thanks.
For `SourceCodeEscapers`, see #1620.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=786) created by **kofemann** on 2011-11-10 at 07:56 PM_
---
Hi,
sometimes you need to to match IP addresses with netmask, e.g.:
192.168.2.2 in the allowed range 192.168.2.0/24.
As I am probably not only the user who needs it I added such functionality to com.google.common.net.InetAddresses with IPv4 and IPv6 support.
You can check changes at
https://code.google.com/r/kofemann-ipmatcher/source/detail?r=628bbd3dc9cf2c52baeafd00502adf6b628bcf89
Some unit tests included as well.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=786#c1) posted by **kevinb@google.com** on 2011-11-15 at 09:53 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=786#c2) posted by **kofemann** on 2011-11-18 at 08:25 PM_
---
rebased clone to current HEAD:
https://code.google.com/r/kofemann-ipmatcher/source/list
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=786#c3) posted by **fry@google.com** on 2011-12-10 at 04:23 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Net`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=786#c4) posted by **kofemann** on 2012-01-17 at 09:32 PM_
---
rebased clone to the current HEAD:
https://code.google.com/r/kofemann-ipmatcher/source/list
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=786#c5) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=786#c6) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=786#c7) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=784) created by **eiden84** on 2011-11-07 at 12:30 PM_
---
When I register an object calling EventBus#register, I have no way of knowing if the object was registered in the eventbus.
One possible solution is to have the register-method returns somthing else than void, like boolean or int, or provide some way of inspecting the event handlers that are registered in the eventbus.
EventBus#register accepts any object, while EventBus#unregister throws IllegalArgumentException if I pass an object that have handler methods, but was not previously registered in the eventbus.
If I wish to unregister a collection of objects, where some might have event handlers, I would have try-catch every call to unregister, or duplicate the logic in 'AnnotatedHandlerFinder' prior to calling unregister.
Related discussion:
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=784#c1) posted by **cgdecker** on 2011-11-07 at 01:06 PM_
---
No, you don't need to try-catch calls to unregister. If an object has @Subscribe methods and you pass it to register, it will be registered. If it does not have @Subscribe methods and you pass it to register, it will not be registered. As long as you ensure that you never pass any object to unregister that you did not previously pass to register, you won't get any issues. The only way you can get an exception is if you try to unregister an object that you had never tried to register previously, which seems like a programming error.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=784#c2) posted by **cbiffle@google.com** on 2011-12-09 at 06:21 PM_
---
First, there's telling whether an object has been registered when EventBus#register returns.  When I originally implemented the method, I deliberately didn't return any indication, because I was essentially throwing every object in the program at EventBus#register to see what stuck.  As you know, registering a non-@Subscribed object is a nop, so this is essentially free.
Can you give me an example of what you would use this facility for?  Since whether an object gets registered or not depends only on static characteristics of the object's class (annotations etc.), there's no dynamic behavior here, and it seems like it might be better done with a test or annotation processor than runtime checks.
As for the second aspect, I agree with comment 1 that passing a not-previously-registered object to EventBus#unregister constitutes a programming error.  I would be open to adding a second variation on the method, with a name like EventBus#unregisterIfRegistered (but less horrible :-) ), but not loosening the semantics of EventBus#unregister, since it risks exposing or introducing bugs in existing code.
(I'm willing to be talked out of that last bit.  To be perfectly honest, I only ever use EventBus#unregister in tests!  Most of my Java code is server-side code designed after the crash-only philosophy, and thus has no concept of shutting itself down.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=784#c3) posted by **fry@google.com** on 2011-12-10 at 04:23 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-EventBus`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=784#c4) posted by **raymond.rishty** on 2012-01-19 at 06:43 PM_
---
I like to have a lot of control over things, which means a lot of my web apps have web interfaces for maintenance by a system administrator, including shutting things down and turning them back on. For example, I have a page that lets me suspend and restart message handlers for JMS queues.
Similarly, I want to have this control over the subscribers to my EventBuses. I would like to be able to stop events from flowing to certain subscribers at will. I'm implementing interfaces to register and unregister, but the only way for me to know the current state is to keep track myself. Being that there are disparate ways that registration and unregistration can occur, this is slightly complicated.
At least, that's my use case.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=784#c5) posted by **em...@soldal.org** on 2012-02-17 at 12:24 AM_
---
I'd like to see the registration process return a ticket object which could be used to deregister or know registration status. If a registration fails you should get a ticket which informs you. This would also be a logic place to publish exceptions etc.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=784#c6) posted by **wasserman.louis** on 2012-02-17 at 01:01 AM_
---
...I sort of like the idea, but I'm not convinced that it'd be a good place to deal with exceptions.  (Unless you register an exception handler on the ticket, but that's just adding another level of complexity.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=784#c7) posted by **em...@soldal.org** on 2012-02-17 at 09:23 AM_
---
True, if you don't register a handler then exceptions would just pile up. I do feel that the ticket approach gives you a lot more control over the way the event bus interacts with listeners.
Another thing I'd actually like to see is an EventBridge which would let you couple two or more EventBus objects together, this would allow for easy modularization
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=784#c8) posted by **wasserman.louis** on 2012-02-17 at 05:02 PM_
---
I've still got little idea what the things you're discussing would look like.  Can you suggest some method signatures?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=784#c9) posted by **em...@soldal.org** on 2012-02-20 at 10:18 AM_
---
I was thinking something simple like:
public interface Ticket {
```
interface ExceptionHandler {
void recieve(Throwable e);
Iterable<Throwable> ofInterest();
}
boolean registerExceptionHandler(ExceptionHandler handler);
boolean registerWithEventBus();
boolean deregisterWithEventBus();
boolean isRecievingEvents();
```
}
That way I could use the ticket later without having a direct reference to the event bus.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=784#c10) posted by **wasserman.louis** on 2012-02-20 at 05:17 PM_
---
Should the register/deregister methods take an EventBus argument?
Hrrrrrm.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=784#c11) posted by **em...@soldal.org** on 2012-02-20 at 08:23 PM_
---
Hold a soft reference to the bus and verify against that? _shrug_
registered in the EventBus
GC'd?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=784#c12) posted by **rikardherlitz** on 2012-04-05 at 02:09 PM_
---
Similarily, a problem is that an object can be registered multiple times. I don't want to be forced to keep track on the outside whether I've already registered the object. Seems easier to re-create the eventbus code and change that. Just add a simple contains method?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=784#c13) posted by **kevinb@google.com** on 2012-06-22 at 06:30 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=784#c14) posted by **gus.heck** on 2012-08-15 at 09:35 PM_
---
isRegistered(Object) ensureRegistered(Object) and ensureUnregistered(Object) seem like good methods to add. The existing behavior is useful when one can reasonably keep track of the objects being registered, but I don't see why you need to force people into this position. Sometimes keeping track might be more expensive than the risk of funky registration/unregistration code.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=784#c15) posted by **rc.poison** on 2012-10-04 at 10:20 AM_
---
Well, I was surprised that the EventBus uses Object identity for the event handlers instead of following the Set contract usually employed so isRegistered(Object) would use equals().
#12 - No need to rewrite, this is the silly and ugly hack I currently use so I don't have to manage event handler instances from the outside and EventBus behaves like a Set:
public class ManagedEventBus {
```
private final EventBus eventBus;
private final Map<Object, Object> events=new HashMap<Object, Object>();
public ManagedEventBus() {
eventBus=new EventBus();
}
public ManagedEventBus(String identifier) {
eventBus=new EventBus(identifier);
}
public synchronized void register(Object object) {
if (events.containsKey(object)) {
eventBus.unregister(events.get(object));
}
events.put(object, object);
eventBus.register(object);
}
public synchronized void unregister(Object object) {
events.remove(object);
eventBus.unregister(object);
}
public synchronized boolean isRegistered(Object object) {
return events.containsKey(object);
}
public synchronized Set<Object> getRegistered() {
return new HashSet<Object>(events.keySet());
}
public synchronized void unregisterAll() {
for (Object o : events.keySet()) {
eventBus.unregister(o);
}
events.clear();
}
public void post(Object event) {
eventBus.post(event);
}
```
}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=784#c16) posted by **rc.poison** on 2012-10-04 at 11:14 AM_
---
oops, register must not leak instances:
public synchronized void register(Object object) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (events.containsKey(object)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eventBus.unregister(events.get(object));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;events.remove(object); // don't leak instance
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;events.put(object, object);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eventBus.register(object);
&nbsp;&nbsp;&nbsp;&nbsp;}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=784#c17) posted by **wasserman.louis** on 2012-10-04 at 03:38 PM_
---
We're actually in the middle of an internal discussion on which is appropriate here, or if EventBus should reject duplicates in the first place.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=784#c18) posted by **cgdecker** on 2012-10-04 at 03:52 PM_
---
@rc.poison: I'd be very curious to hear why you want EventBus to not allow registration of two different objects that are equal according to equals(). What's your use case? My view on this has been that it makes sense for EventBus to strictly deals with objects by identity... you can't register the same exact object twice, but ANY object that is passed to EventBus.register will receive any events that it subscribes to.
---
> Well, I was surprised that the EventBus uses Object identity for the event handlers
That's quite common and logical for listeners: When `a.equals(b)`&nbsp;holds and `a`&nbsp;gets registered, `b`&nbsp;can hardly hope to get notified as well. So using `equals`&nbsp;instead of `==`&nbsp;makes no sense to me.
Normally, listeners inherit `equals`&nbsp;from `Object`, so it doesn't matter, but you'd better use `IdentityHashMap`&nbsp;in case they do.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=784#c20) posted by **rc.poison** on 2012-10-05 at 09:11 AM_
---
@#18 I have parametrized listeners, I don't want to have multiple instances with the same parameters registered.
But whats the point in having the same listeners registered multiple times? I can't think of any use case, but if you wanted object identity simply not overriding equals()/hashCode() will give you that behavior.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=784#c21) posted by **neveue** on 2012-10-14 at 02:18 PM_
---
In your workaround, why not replace the Map&lt;Object, Object> with a Set&lt;Object>?
Map&lt;Object, Object> events=new HashMap&lt;Object, Object>()
==>
Set&lt;Object> eventListeners = Sets.newHashSet();
or
Set&lt;Object> eventListeners = Sets.newIdentityHashSet(); (if you want to compare event listeners using object identity)
It would make sense, since the Map keys and values are similar.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=776) created by **pondruska+o...@csas.cz** on 2011-10-28 at 09:22 PM_
---
<b>What steps will reproduce the problem?</b>
1. Add guava-10.0.1.jar, guava-gwt-10.0.1.jar to build path
2. Compile GWT module
<b>What is the expected output? What do you see instead?</b>
Compiling module ***
&nbsp;&nbsp;&nbsp;Validating newly compiled units
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ERROR] Errors in 'jar:file:/***/guava/guava-gwt-10.0.1.jar!/com/google/common/base/CharMatcher.java'
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ERROR] Line 29: The import javax.annotation.CheckReturnValue cannot be resolved
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ERROR] Line 871: CheckReturnValue cannot be resolved to a type
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ERROR] Line 908: CheckReturnValue cannot be resolved to a type
<b>What version of the product are you using? On what operating system?</b>
<b>Please provide any additional information below.</b>
There are "fixed" issues against guava r09 but clearly referring to javax.annotation.Nullable and CheckReturnValue in guava which does not provide them (and not docs mention where to get those).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c1) posted by **pondruska+o...@csas.cz** on 2011-10-28 at 09:27 PM_
---
deprecated guava-r09.zip:guava-r09/guava-r09-gwt.jar containst javax.annotation package. Please fix it in guava 10
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c2) posted by **wasserman.louis** on 2011-11-07 at 07:29 PM_
---
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupId>com.google.code.findbugs&lt;/groupId>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;artifactId>jsr305&lt;/artifactId>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;version>1.3.9&lt;/version>
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c3) posted by **pondruska+o...@csas.cz** on 2011-11-08 at 05:22 AM_
---
Thanks Louis, I do not use Maven (and do not know how to use it either). So if that is the only way to go(?) I have to do some homework and learn new stuff :-)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c4) posted by **pondruska+o...@csas.cz** on 2011-11-08 at 10:06 AM_
---
OK, just get jsr305-1.3.9.jar from http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22jsr305%22 and place onto build path and everything is fine. Thanks.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c5) posted by **raymond.rishty** on 2011-11-08 at 10:52 AM_
---
So what happened to this note Kevin had posted on SO a few months back?
"You are absolutely positively 100% NOT supposed to need to go off hunting for a jsr305 jar yourself! guava-gwt.jar is supposed to just work for you out of the box..."
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c6) posted by **kevinb@google.com** on 2011-11-09 at 03:16 PM_
---
I agree with that.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c7) posted by **andy.dennie** on 2011-11-10 at 04:14 PM_
---
I've added jsr305-1.3.9.jar to my classpath and it hasn't resolved the issue for me.  I'm stumped as to why not.  FWIW, my symptom is
[ERROR] [newsbotserver] - Errors in 'jar:file:/C:/Users/Andy/Dev/Eclipse%20Workspace/NewsBotServer/war/WEB-INF/lib/guava-gwt-10.0.1.jar!/com/google/common/base/Equivalence.java'
[ERROR] [newsbotserver] - Line 26: The import javax.annotation.Nullable cannot be resolved
[ERROR] [newsbotserver] - Line 65: Nullable cannot be resolved to a type
I am able to eliminate the problem by downgrading to v09 of guava and guava-gwt jars, and changing my code to account for the fact that in v09, Equivalence was an interface rather than a class.  But I'd like to make this work with v10 if possible.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c8) posted by **andy.dennie** on 2011-11-10 at 04:29 PM_
---
apparently I'm not the only one for whom adding jsr305 has not fixed the issue.  See this SO question:
http://stackoverflow.com/questions/7817156/using-guava-10s-predicate-and-function-interfaces-with-gwt-2-4-0
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c9) posted by **kevinb@google.com** on 2011-11-15 at 10:04 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Accepted`
**Labels:** `Milestone-Release11`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c10) posted by **cpovirk@google.com** on 2011-12-02 at 10:42 PM_
---
_Issue #765 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c11) posted by **cpovirk@google.com** on 2011-12-02 at 11:26 PM_
---
Can anyone upload a project demonstrating this problem?  My attempts to reproduce it have failed.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c12) posted by **yrfselrahc** on 2011-12-05 at 06:35 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Milestone-Release11`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c14) posted by **trupanka** on 2012-01-09 at 09:58 PM_
---
This code compiles:
List&lt;String> location = ImmutableList.copyOf(new String[] {"s", "s"});
But in DevMode it doesn't work with Exception
00:31:37.320 [ERROR] [com.example.list] Line 32: The import javax.annotation.Nullable cannot be resolved
This code doen't compile without adding &lt;super-source path="path/to/JSR-305/source"> or &lt;source path="path/to/JSR-305/source">:
ImmutableList&lt;String> location = ImmutableList.copyOf(new String[] {"s", "s"});
I think the issue is about how GWT Compiler resolves and ignores unrecognized annotation types.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c15) posted by **bdleitner80** on 2012-01-22 at 08:00 AM_
---
I'm also having this issue.  I have guava-11.0.1/jar, guava-gwt-11.0.1.jar AND jsr305-1.3.9.jar in my classpath, but I get:
[ERROR] Errors in 'jar:file:/D:/Projects/Java/appengine/jnddb/war/WEB-INF/lib/guava-gwt-11.0.1.jar!/com/google/common/base/CharMatcher.java'
[ERROR] Line 864: CheckReturnValue cannot be resolved to a type
and later
[ERROR] Errors in 'jar:file:/D:/Projects/Java/appengine/jnddb/war/WEB-INF/lib/guava-gwt-11.0.1.jar!/com/google/common/base/Enums.java'
[ERROR] Line 26: The import javax.annotation.Nullable cannot be resolved
[ERROR] Line 75: Nullable cannot be resolved to a type
etc.
My module has:
&nbsp;&nbsp;&lt;inherits name="com.google.common.collect.Collect"/>
&nbsp;&nbsp;&lt;inherits name="com.google.common.base.Base"/>
in it.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c16) posted by **wasserman.louis** on 2012-01-22 at 08:07 AM_
---
I'll repeat cpovirk's plea: "Can anyone upload a project demonstrating this problem?  My attempts to reproduce it have failed."
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c17) posted by **victor.ott** on 2012-01-24 at 11:22 AM_
---
I'm also having this issue, and am pretty disappointed.
Attached you'll find the requested demo project:
- freshly created Eclipse GWT project with default demo code, GWT 2.4.0, JDK 6;
- converted project to use Facets ("Dynamic Web Module" and "Java");
- reconfigured Google web app "project WAR directory" [sic!] to be "WebContent";
- added guava-11.0.1.jar and guava-gwt-11.0.1.jar to WebContent/WEB-INF/lib;
- added dependency to module definition
&nbsp;&nbsp;&nbsp;&nbsp;&lt;inherits name="com.google.common.collect.Collect"/>
- added lines 61-66 and corresponding imports to
&nbsp;&nbsp;/GwtGuava/src/com/test/gwtguava/client/GwtGuava.java:
&nbsp;&nbsp;&nbsp;&nbsp;// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
&nbsp;&nbsp;&nbsp;&nbsp;TreeMultimap&lt;String, String> tmMap = TreeMultimap.create();
&nbsp;&nbsp;&nbsp;&nbsp;tmMap.put("one", "something");
&nbsp;&nbsp;&nbsp;&nbsp;tmMap.put("one", "something else");
&nbsp;&nbsp;&nbsp;&nbsp;tmMap.put("two", "another");
&nbsp;&nbsp;&nbsp;&nbsp;// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
- "GWT Compile Project..." gives:
Compiling module com.test.gwtguava.GwtGuava
&nbsp;&nbsp;&nbsp;Validating newly compiled units
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ignored 113 units with compilation errors in first pass.
Compile with -strict or with -logLevel set to TRACE or DEBUG to see all errors.
&nbsp;&nbsp;&nbsp;[ERROR] Errors in 'jar:file:/D:/workspace/ZZZ/GwtGuava/WebContent/WEB-INF/lib/guava-gwt-11.0.1.jar!/com/google/common/collect/AbstractSortedSetMultimap.java'
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ERROR] Line 25:  The import javax.annotation.Nullable cannot be resolved
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ERROR] Line 64:  Nullable cannot be resolved to a type
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ERROR] Line 76:  Nullable cannot be resolved to a type
[...etc...]
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c18) posted by **victor.ott** on 2012-01-24 at 12:33 PM_
---
PS
Forgot to mention: manually adding jsr305-2.0.0.jar to WEB-INF/lib solved the GWT compiler errors, but as comments #5 and #6 already mentioned, that shouldn't be necessary, imho.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c19) posted by **cpovirk@google.com** on 2012-01-24 at 05:25 PM_
---
victor.ott,
Thanks very much for the sample project.
andy.dennie, bdleitner80,
Does adding the jsr305 jar to your WEB-INF/lib solve the problem, or is this what you already did when you said that you added it to your CLASSPATH?
All,
Our goal is to keep our dependencies minimal, but we have allowed JSR 305 in, and we may pick up JSR 330 soon.  We switched from Ant to Maven in order to minimize the hassle of adding dependencies.  It sounds like Eclipse GWT support and Maven aren't closely integrated, which dumps dependency management back in the laps of users.  Does anyone know whether there's a way for us to supply enough metadata with guava-gwt (ideally in the pom.xml) to tell Eclipse "Please also include these jars?"  Is there some additional Eclipse plugin that users could install to make this possible?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c20) posted by **pondruska+o...@csas.cz** on 2012-01-24 at 05:44 PM_
---
I did not add jsr305 jar to WEB-INF/lib as it is only needed to be available on classpath (Eclipse's build path) during GWT compile. That works, actually I have modified my guava-gwt library to include jsr305jar in addition to guava-gwt-..jar and that fixes the problem.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c21) posted by **raymond.rishty** on 2012-01-24 at 05:46 PM_
---
Chris,
I believe that there are Eclipse plugins to integrate with Maven, but it's not what everybody is using.
Personally, I don't think it's a problem to have to get and include JSR 305, if that's the solution. I've gone out and found the jar myself, included it in my projects, and everything worked great. I've also found it very useful to use those annotations myself and reap the benefits from FindBugs.
Thanks
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c22) posted by **victor.ott** on 2012-01-24 at 06:34 PM_
---
More information: I've now spent good 1+ hour to find out why our Ant build script still doesn't GWT compile, although jsr305-2.0.0.jar is included. The difference is: "-strict".
Try adding the "-strict" parameter to the GWT compiler in the sample project (see attached screenshot), and the issue is back.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c23) posted by **cpovirk@google.com** on 2012-02-08 at 09:35 PM_
---
Thanks for bailing me out again.  I can reproduce the problem with -strict.
My current understanding is that we need to provide a javax/annotation/Annotation.gwt.xml.  This will inform GWT that it should look for source files under that path in the jar.  We don't see this problem internally because our build system generates the .gwt.xml automatically.
Currently I'm here:
Compiling module com.test.gwtguava.GwtGuava
&nbsp;&nbsp;&nbsp;Validating newly compiled units
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ERROR] Errors in 'jar:file:/usr/local/google/home/cpovirk/workspace/GwtGuava/WebContent/WEB-INF/lib/jsr305.jar!/javax/annotation/MatchesPattern.java'
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ERROR] Line 23: No source code is available for type java.util.regex.Pattern; did you forget to inherit a required module?
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ERROR] Errors in 'jar:file:/usr/local/google/home/cpovirk/workspace/GwtGuava/WebContent/WEB-INF/lib/jsr305.jar!/javax/annotation/RegEx.java'
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ERROR] Line 32: No source code is available for type java.util.regex.Pattern; did you forget to inherit a required module?
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ERROR] Line 33: No source code is available for type java.util.regex.PatternSyntaxException; did you forget to inherit a required module?
&nbsp;&nbsp;&nbsp;[ERROR] Aborting compile due to errors in some input files
I'm not yet sure why we aren't seeing _that_ error internally.
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c24) posted by **cpovirk@google.com** on 2012-02-08 at 09:53 PM_
---
Setting aside the question of why we don't get the error internally, I can at least eliminate it:
&lt;module>
&nbsp;&nbsp;&lt;source path="" excludes="MatchesPattern.java,RegEx.java"/>
&lt;/module>
This is slightly more than we need to exclude, since it's only the nested Checker classes in those files that cause a problem, but it's probably good enough to get Guava working.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c25) posted by **cpovirk@google.com** on 2012-02-27 at 10:59 PM_
---
I've spoken to someone from the GWT team, and he thinks that the problem is with the Google Plugin for Eclipse -- specifically, that it's not setting up the classpath for the compiler correctly, so the compiler can't find the annotation types.  (In the end, it shouldn't need the sources at all.)
He's going to try to verify with someone more familiar with the plugin.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c26) posted by **victor.ott** on 2012-02-27 at 11:16 PM_
---
In comment #22 I wrote that I was analyzing why our ANT script did not
GWT compile. Then I was able to reproduce the issue with the Eclipse
plugin. Therefore imho the issue in NOT specific only to the Eclipse
plugin.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c27) posted by **cpovirk@google.com** on 2012-02-27 at 11:21 PM_
---
Sorry, I forgot about that part.  I'll make sure that I get instructions for the proper Ant compile to go along with whatever we recommend for the Eclipse compile.  My guess is that the fix will be the same -- "include jsr305.jar in the compiler's classpath" -- but I'll report back.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c28) posted by **cpovirk@google.com** on 2012-02-27 at 11:22 PM_
---
(The GWT guy got it running by setting up a manual gwtc configuration, rather than relying on the plugin's or Ant's.)
---
Adding jsr305.jar did not solve it for me. I'm running dev mode from IDEA. Before adding JSR305, the symptom was:
The import javax.annotation.Nullable cannot be resolved
After adding it, it changed to:
The type new Predicate&lt;String>(){} must implement the inherited abstract method Predicate&lt;String>.apply(Object)
The method apply(String) of type new Predicate&lt;String>(){} must override or implement a supertype method.
---
And the workaround was to create javax/annotation/Annotation.gwt.xml (with source path="") and inherit it.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c33) posted by **cpovirk@google.com** on 2012-03-07 at 01:08 PM_
---
> And the workaround was to create javax/annotation/Annotation.gwt.xml (with
> source path="") and inherit it.
Interesting.  In my tests, that hasn't been good enough, at least with -strict.  Are you using -strict?
(And thanks for the information.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c34) posted by **cpovirk@google.com** on 2012-03-23 at 06:00 PM_
---
RE: Eclipse: We're getting some attention from the GWT team now, so I'm hoping that they'll be able to fix up the Eclipse plugin to avoid this.
RE: Ant: I haven't been able to reproduce this problem with Ant, even with -strict, at least once I include jsr305.jar in my classpath.  I've attached a project (based on Victor's Eclipse project) that works for me, which you can run with something like `ant -Dgwt.home=/path/to/gwt/jar/directory`.  Can anyone share an Ant project with jsr305.jar in the classpath that fails?  Thanks.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c35) posted by **HendrikU...@nexgo.de** on 2012-05-17 at 12:19 PM_
---
> And the workaround was to create javax/annotation/Annotation.gwt.xml
> (with source path="") and inherit it.
This worked for me in Eclipse
---
Help, I just Incorporated Guava 12.0 into my GWT project and I am getting the error where Nullable can not be resolved.
I added guava-12.0.jar, guava-gwt-12.0.jar, and jsr305-2.0.0.jar in my war/WEB-INF/lib and included the jars in the build properties / libs
I also created a javax.annotations package in my source tree and created Annotations.gwt.xml with source path="" and inherited it in my gwt project file.
I even upgraded to Jdk1.7 from Oracle in case this is a System Mac JDK issue.
All == No Luck..
Dev environment =
Eclipse Helios SR2
The latest GWT Eclipse plugin..
---
I got it to compile by copying the source of jsr305 into my project and creating a gmt.xml file for it..  Although when it compiles now, I get an error on one of the custom serializers. I don't use that function so I don't think it's causing an issue, just wanted to point it out.. I expect my extreme fix may be part of the cause somehow..
Validating newly compiled units
&nbsp;&nbsp;Errors in 'generated://1DCFAC23BE2D8C9BC205377978109764/com/google/common/collect/ForwardingImmutableList_FieldSerializer.java'
&nbsp;See snapshot: /var/folders/pn/rtgx2jks7_j1cq5h8cl9ldsr0000gn/T/com.google.common.collect.ForwardingImmutableList_FieldSerializer4785162401512167816.java
Ignored 1 unit with compilation errors in first pass.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c38) posted by **kevinb@google.com** on 2012-05-30 at 07:49 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Defect`, `Type-Dev`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c39) posted by **kevinb@google.com** on 2012-06-22 at 06:57 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-General`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c40) posted by **ljw1001** on 2012-09-18 at 11:57 AM_
---
Also having this problem with Guava-gwt-13.  Is this likely to see a resolution soon or should I punt on Guava in my GWT code?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c41) posted by **cbonami** on 2012-09-18 at 12:24 PM_
---
I cannot make decisions in your place, but :
> And the workaround was to create javax/annotation/Annotation.gwt.xml
> (with source path="") and inherit it.
This worked for me in Eclipse, IntelliJ and in our ANT builds (GWT compiler).
We've not upgraded since, but I'm planning to.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c42) posted by **cgruber@google.com** on 2013-02-20 at 02:22 PM_
---
So here's the question.  Is the listed workaround sufficient to resolve this issue?  Looking at this whole thread, is this even rightly a Guava issue?  It seems like it's an upstream dependency issue which is resolvable by the listed workaround... which seems not like a workaround, but the actually correct solution to a dependency issue.
That is, if you're going to use Guava, in GWT, you need to have a javax/annotation/Annotation.gwt.xml that pulls in the correct source.  Is there anything further Guava needs to do in terms of what we supply or how our builds are configured?  Or is this a documentation issue at this point ("using Guava with GWT" etc.)?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c43) posted by **cgruber@google.com** on 2013-07-29 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Obsolete`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c44) posted by **RogerMHand** on 2014-07-17 at 07:51 PM_
---
Not sure why this was marked obsolete ... I just spent over an hour getting Guava version 17 to work in GWT, and I had to do the Annotation.gwt.xml trick.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=775) created by **richarddowsett** on 2011-10-27 at 12:14 PM_
---
It would be ideal to create an interface that can pre-load all static data from the database and add it to the Cache at start-up, such as:
CacheBuilder.newBuilder().populate(new CachePopulator&lt;String, Element>(){
```
public Map<String, Element> populate() throws Exception {
return getAllElements();
}
```
}).build(new CacheLoader&lt;String, Element>(){
```
public Element load(String key) throws Exception {
return getElement(key);
}
```
});
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=775#c1) posted by **kevinb@google.com** on 2011-10-27 at 09:17 PM_
---
When we add CacheLoader.loadAll and Cache.getAll in 11.0, that would seem like a cleaner way to do this. First create the empty cache, then just call getAll to fill it up.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=775#c2) posted by **raymond.rishty** on 2011-10-28 at 11:47 AM_
---
I suppose the objection to that would be that if I have, say, 100 keys, I would prefer to get the 100 corresponding values via a single DAO call that via 100 DAO calls.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=775#c3) posted by **richarddowsett** on 2011-10-28 at 12:07 PM_
---
I'm assuming this would be the interface for the new feature (or something similar): Cache.getAll(List&lt;K> keys).
As Raymond has pointed out, this would result in keys.size() calls to the database where my solution would allow you to get all values in a single DAO call. This would surely be a better solution where the cache needs to be pre-populated with a large number of elements.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=775#c4) posted by **raymond.rishty** on 2011-10-28 at 01:26 PM_
---
CacheLoader has loadAll
public Map&lt;K, V> loadAll(Iterable<? extends K> keys) throws Exception
ImmutableMap&lt;K, V> getAll(Iterable<? extends K> keys)
According to the Javadoc for CacheLoader, that default implementation of loadAll delegates to individual calls to get. However, the method is not final, and as the Javadoc offers, you are free to override with a bulk lookup in your own CacheLoader.
You might familiarize yourself with the interface: https://github.com/google/guava/blob/master/guava/src/com/google/common/cache/CacheLoader.java
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=775#c5) posted by **richarddowsett** on 2011-10-28 at 02:57 PM_
---
This interface would allow the bulk loading of keys so it would seem to satisfy the requirement.
My only comment would be that if the full set of keys is not known at runtime, you can still override the method and bulk load all data (with one DAO call) but you are breaking the interface because you are not using the parameter keys to load the data. But it would still work the way I expect it to, I'm just trying to get a precise interface out of an API used by many other people :)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=775#c6) posted by **kevinb@google.com** on 2011-10-29 at 04:41 PM_
---
It's not a _perfect_ fit for this request, but I think that it will do.  Note that loadAll() is permitted to return extra entries even whose keys were not asked for, so you could do some hack like just asking for a "magic key" if you don't know what the keys to load are.  That said, it's probably cleaner to just create the cache, do your initial population load externally and use asMap().putAll().
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=775#c7) posted by **kevinb@google.com** on 2011-11-15 at 10:06 PM_
---
If the keys are known, loadAll may be the answer; if they aren't, you can still just get the data externally to the cache and put it all in.  I don't think there's anything we need to do here, but if I'm missing something big let me know.
---
**Status:** `WontFix`
**Labels:** `Type-Enhancement`
---
Well, Kevin, of course both of your use cases meet the functional requirements BUT neither is clean. With the asMap() solution you make the _client_ control the cache. Therefore the cache isn't self contained and responsibility bleeds out to outer classes.
And to answer your question. What you're missing is that the solution to this common use case (of populating the whole cache in one go) is still not present in guava-cache.
And now, my own problem:
In my work place I have an enum-like dictionaries in remote systems I need to cache at startup. That's because fine-grained web service operations return their IDs instead of names, symbols or descriptions. Of course I don't have any control over the services provided to me; and, unfortunately, these provide only one operation to get the whole dictionary at once. So what am I supposed to do?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=775#c9) posted by **wasserman.louis** on 2012-01-04 at 03:58 PM_
---
Why does the putAll force you to bleed responsibility to outer classes?  Do the putAll immediately upon cache creation, right there, so no other classes have to worry about it.
---
May I ask for the example code? Keeping in mind only CacheLoader instance holds a reference to RemoteRepository.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=775#c11) posted by **wasserman.louis** on 2012-01-04 at 04:47 PM_
---
Rearrange that a bit, is the point.  I'm suggesting something like
Cache&lt;Key, Value> constructCache(RemoteRepository repo) {
&nbsp;&nbsp;Cache&lt;Key, Value> cache = CacheBuilder.newBuilder()
&nbsp;&nbsp;&nbsp;&nbsp;.......
&nbsp;&nbsp;&nbsp;&nbsp;.build(new CacheLoader&lt;Key, Value>(){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;....
&nbsp;&nbsp;&nbsp;&nbsp;});
&nbsp;&nbsp;cache.asMap().putAll(getInitialEntriesFromRepo(repo));
&nbsp;&nbsp;return cache;
}
---
But that's exactly the case - the Cache LOADER isn't loading the entries now. Outer class does, doesn't it? And it puts the entires into the cache. From outside, via public interface. That's this little minor detail which makes guava cache shine when compared to the standard bunch (ehcache, treecache, etc).
And what if the remote repo changes? I mean, what if remote system adds an entry after the cache is populated? Then the call to get(key) should retrive this new value (or simply refresh the whole set again). Now, you can't do that because you have initialized it from outside, so you need to duplicate the loading parts inside the cache. Ugly.
I know it's hard to implement this with current CacheLoader interface and Cache loading internals. But maybe it could be split into two interfaces? And then people could decide which one to use? Like CacheLoader for single items and FullCacheLoader (or any other fitting name) for the whole set? Just thinking aloud. I'm sure you, guys, are capable of coming up with something even better. Just trying to help.
Anyways, this is a great library. Thank you!
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=775#c13) posted by **fry@google.com** on 2012-04-06 at 03:10 PM_
---
Let's keep this open for now. It's also come up at:
http://stackoverflow.com/questions/7915016/pre-load-values-for-a-guava-cache
and
---
**Status:** `Acknowledged`
**Labels:** `Package-Cache`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=775#c14) posted by **wasserman.louis** on 2012-04-25 at 06:31 PM_
---
I guess my thinking is as follows:
I sort of assume that in most cases, the cache loader is defined inline, as an anonymous class.  In this case, you really don't lose anything by moving the initial population code outside the loader, because it's exactly as exposed as it always was.
But let's assume that's not the case -- that the cache loader is a top-level class.  In most cases, a cache loader is used with only one cache configuration.  So add a (possibly static) method to your CacheLoader,  public LoadingCache&lt;K, V> buildCache().  If you add the population code in that method, then you're set: it looks like
public class MyLoader extends CacheLoader&lt;K, V> {
&nbsp;&nbsp;&nbsp;public V load(K key) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;private static void populate(LoadingCache&lt;K, V> cache) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;public static LoadingCache&lt;K, V> buildCache() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LoadingCache&lt;K, V> cache = CacheBuilder.newBuilder()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...configuration options...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.build(new MyLoader());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;populate(cache); // uses putAll
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return cache;
&nbsp;&nbsp;&nbsp;}
}
If you use your cache loader with multiple different configurations, then you can either make your method take a pre-configured CacheLoader, or you can even pass in a CacheBuilderSpec (with release 12) that takes care of all the other details.
All of this manages to keep the encapsulation we want without messing with an already excellent abstraction.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=775#c15) posted by **kevinb@google.com** on 2012-05-30 at 07:41 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Enhancement-Temp`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=775#c16) posted by **kevinb@google.com** on 2012-05-30 at 07:45 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement-Temp`, `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=775#c17) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=775#c18) posted by **wasserman.louis** on 2012-08-18 at 04:22 PM_
---
_Issue #1099 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=775#c19) posted by **kevinb@google.com** on 2012-11-09 at 10:15 PM_
---
Martel, Have you tried the idea outlined on the stack overflow post linked in #13?
If you have a strong need that really isn't being addressed by anything we offer now, please make a new attempt to describe the whole problem (not intended solution) in clear terms. (ie, file a new issue)
---
**Status:** `WontFix`
---
First of all, Kevin, thanks. Secondly, if you mean the "feature request" from actual Stack Overflow question then it's exactly what I had in mind.
Actually I haven't looked into this issue since I wrote my last message so I'm not sure where we stand now. I simply wanted to encapsulate whole loading logic inside the CacheLoader interface which just seems more in line with what is already there. I don't have any strong feelings for or against it, though.
I can make another issue but I don't see the point if you're not sharing my point of view. It's still a decent API even if I can't pre-populate the cache.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=766) created by **toellrich** on 2011-10-20 at 12:05 PM_
---
Cheers
Thomas
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c1) posted by **ray.j.greenwell** on 2011-11-01 at 12:34 AM_
---
What happens when an Exception is thrown? Are subsequent handlers not notified of the event object? That seems unacceptable because there's no way to configure the order of handling.
Or would you want a "public Set&lt;Exception> postAll (Object event)" ?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c2) posted by **toellrich** on 2011-11-01 at 04:12 AM_
---
In our case they would all be transactional and therefore wouldn't need to be notified explicitly because of the rollback.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c3) posted by **wasserman.louis** on 2011-11-15 at 04:49 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c4) posted by **toellrich** on 2011-11-15 at 08:24 PM_
---
I would have the dispatching stop similar to the way SimpleEventBus of the CQRS-Framework Axon works (http://www.axonframework.org/docs/1.2/event-processing.html)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c5) posted by **wasserman.louis** on 2011-11-15 at 08:43 PM_
---
I think that framework have stronger ordering constraints for its handlers, however, and I'm not sure that behavior satisfies the principle of least astonishment.
For example, I don't think the JDK defines what order methods are iterated over with reflection, in which case there's no way to impose any ordering on several handlers in the same class.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c6) posted by **toellrich** on 2011-11-15 at 08:57 PM_
---
If you guys feel my request doesn't "gel" with your idea of an EventBus please feel free to ignore it ;)
I can always continue to use our own implementation or start using Axon framework. Thanks for your interest!
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c7) posted by **wasserman.louis** on 2011-11-17 at 01:47 AM_
---
I didn't say that -- I think it's possible (likely?) that someone smarter than I am could figure out a sensible way of doing this.  I'm just trying to figure out if there's any approach I can think of that would meet Guava's typical standards for "clear and well-defined semantics."
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c8) posted by **kevinb@google.com** on 2011-11-21 at 10:51 PM_
---
Re: "I don't think the JDK defines what order methods are iterated over with reflection", not only does it not define it, but the order even changes between JDK 6 and 7.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c9) posted by **wasserman.louis** on 2011-11-21 at 10:56 PM_
---
Indeed.  I think that's a pretty conclusive argument that there could never be a consistent, well-defined ordering on the handler order, assuming we're using the reflection-based register(Object) approach.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c10) posted by **cpovirk@google.com** on 2011-12-05 at 11:25 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c11) posted by **cbiffle@google.com** on 2011-12-09 at 06:28 PM_
---
Firewalling event producers from any failure in subscribers was quite deliberate.  It was based on the notion of events being exchanged by separate components or library code, where a failure in one errant consumer shouldn't destroy all the other parts.  Propagating exceptions across EventBus also allows producers to (perhaps deliberately and maliciously) discover aspects of consumer code shape and operation by inspecting stack traces, which makes me uncomfortable.
For your application, it sounds like something like this might suffice:
2. Take note of whether any subscribers failed.  Skip any failed subscribers, as we do today.
3. Notify the event producer somehow (return value?) that one or more subscribers failed.
I would be hesitant to furnish the producer with a list of failed consumers, or to return a count (simply because I can't imagine how one would reasonably respond to a count).  A boolean, though, seems reasonable.
Would a feature like this help?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c12) posted by **fry@google.com** on 2011-12-10 at 04:22 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-EventBus`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c13) posted by **toellrich** on 2011-12-11 at 01:32 PM_
---
A boolean return value from EventBus.post(Object event) that indicates
false the event producer can throw a RuntimeException which would lead to a
rollback of the transaction.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c14) posted by **cgdecker** on 2011-12-11 at 02:08 PM_
---
How would returning a boolean from post work with an AsyncEventBus? It would have to wait for all handlers to finish, which doesn't seem acceptable. I suppose post could return a ListenableFuture&lt;Boolean> instead of just boolean, though that would create some overhead that seems unnecessary for most uses of EventBus.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c15) posted by **toellrich** on 2011-12-12 at 02:45 AM_
---
As I said, it's probably for the best if I stick to another event bus implementation.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c16) posted by **toellrich** on 2011-12-16 at 09:20 PM_
---
After your objections I've rethought the design of the application and changed it to no longer use an event bus (it was just a prototype). You may close the feature request.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c17) posted by **wasserman.louis** on 2012-01-25 at 09:43 PM_
---
_Issue #868 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c18) posted by **wasserman.louis** on 2012-01-25 at 09:46 PM_
---
Issue 868 suggested a much nicer way of doing this: when a handler fails, post a new event wrapping the exception, instead of doing a return value or something.  Then, you can optionally log such events.
Thoughts?
---
**CC:** cbiffle@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c19) posted by **ewjmulder** on 2012-01-26 at 08:28 AM_
---
I see these issues are merged, makes sense indeed.
About your last scenario: I mentioned this already in the first post of Issue 686:
"Only downside might be some extra semantics about the exception event. Namely that any exceptions for listeners to exception events are not re-posted. But this is not any different from the fact that there is no new event if no-one listens to the DeadEvent. :)"
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c20) posted by **wasserman.louis** on 2012-01-27 at 01:34 AM_
---
Sorry, I didn't parse that correctly originally.  It's totally accurate.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c21) posted by **kevinb@google.com** on 2012-01-31 at 07:21 PM_
---
Thanks for articulating this problem to us, everyone!
We are considering introducing an "ExceptionEvent" and having the event bus post these events to itself upon subscriber failures.
But, any Throwable resulting from publishing an ExceptionEvent itself will probably just be dropped. (Or some anti-recursion policy.)
If you see any problems with this idea, let us know soon.
---
**Status:** `Accepted`
**Owner:** cbiffle@google.com
**Labels:** `Milestone-Release12`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c22) posted by **wasserman.louis** on 2012-01-31 at 07:28 PM_
---
Query: why ExceptionEvent vs. ThrowableEvent?  Or is it just more readable that way?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c23) posted by **kevinb@google.com** on 2012-02-01 at 06:27 AM_
---
Just jotted that quickly without thinking.
Though, "ThrowableEvent" does kind of sound like the event itself can be thrown.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c24) posted by **wasserman.louis** on 2012-02-01 at 06:55 AM_
---
HandlerThrewEvent?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c26) posted by **cbiffle@google.com** on 2012-02-06 at 07:18 PM_
---
Louis is right that the event class name should reflect the context, not the contents.  For example, DeadEvent is not called EventEvent. :-)  (In fact, this is a good general design tip for EventBus-based systems.)
I'd suggest HandlerMethodThrew.  It's long, but not by Java standards. :-)  The term "handler method" is the one used in the API reference for a method annotated with @Subscribe.  "Threw" is more correct than the obvious alternatives, like "failed," because it doesn't imply whether an operation was successful that's up to the handler method's contract.  Finally, you'll note I left off "event;" it seems redundant.  DeadEvent is not named that because it is an event  it's because an event (other than it) is dead.
My concern about this is still the one I described above: it lets components see into each other's state.  Java throwables contain a lot of state, including a complete stack trace and (depending on the class) application-specific information.  EventBus currently tries hard not to leak information between subscribers (beyond things that can be derived through a side-channel anyway, like timing).  Allowing a subscriber to see other subscribers' throwables would violate this principle.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c27) posted by **wasserman.louis** on 2012-02-06 at 07:23 PM_
---
I note that in a pinch, the exception handler you propose could be repurposed to more or less act the same as HandlerMethodThrew: you just pass a handler that posts the exception to the event bus.  I like it, and the increased API surface is minimal.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c28) posted by **cbiffle@google.com** on 2012-02-06 at 07:23 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c29) posted by **wasserman.louis** on 2012-02-08 at 09:15 PM_
---
Hrrrrrrm.  I'm not sure what interface for the exception handler is most appropriate.
When we're handling an exception, do we pass in the handler object that threw the exception on one of its methods?  Do we tell it which handler method threw the exception?  Do we pass the handler object as an Object, damaging some of the nice type safety guarantees we had?
I'm not sure this is a solved problem yet.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c30) posted by **fabian.zeindl** on 2012-02-11 at 10:32 AM_
---
Just another input: I often use EventBus for stuff like CSP / threaded-programming, where i have one queue to input commands into the Thread. The reason i use EventBus there, is because it saves me from endless if (nstanceof) then constructs. I could refactor that to use a proper Interface, of course, but more often than not make the the code more complicated that it needs to be.
The reason i'm adding this is that in all my EventBus scenarios I have exactly one handler that's fired for an Event, which eliminates the "should other handlers be fired" as well problem. Dunno, if you can make something out of that.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c31) posted by **cbiffle@google.com** on 2012-02-11 at 08:31 PM_
---
Fabian, it sounds like what you want is runtime overload resolution (aka pattern matching).  I agree that this is a missing feature in Java.  It's not really EventBus's target use case, though.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c32) posted by **wasserman.louis** on 2012-02-12 at 05:32 PM_
---
Just to be clear: you're saying that if we wanted to tell the exception handler which method threw the exception, we'd add that data to HandlerMethodThrew?
I think I like this, I'm just trying to think if there's anything better.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c33) posted by **cbiffle@google.com** on 2012-02-13 at 04:28 AM_
---
Yes, precisely.  As for whether the exception handler is an EventBus handler (with @Subscribe), or a single-method interface that accepts the event, I haven't decided.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c34) posted by **fabian.zeindl** on 2012-02-15 at 10:05 AM_
---
How do you do the logging, is there some way to get these into my default-logger, at least?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c35) posted by **cbiffle@google.com** on 2012-02-15 at 02:31 PM_
---
EventBus wouldn't do the logging for you.  To get the exceptions into the logger of your choice, you'd provide your own exception handler that would forward them.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c36) posted by **fabian.zeindl** on 2012-02-15 at 02:34 PM_
---
Sure, but how is it done now?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c37) posted by **cbiffle@google.com** on 2012-02-15 at 02:38 PM_
---
https://github.com/google/guava/blob/master/guava/src/com/google/common/eventbus/EventBus.java#L319
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c38) posted by **wasserman.louis** on 2012-02-15 at 03:38 PM_
---
(So, answer: no, there's no way to change the default logging behavior at the moment, not unless you can do it using one of the j.u.logging wrappers.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c39) posted by **wasserman.louis** on 2012-03-02 at 07:08 PM_
---
Are we sure we'll have worked out these details to our satisfaction by release 12?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c40) posted by **cpovirk@google.com** on 2012-03-23 at 09:27 PM_
---
Rolling EventBus issues over to r13.
---
**Labels:** -`Milestone-Release12`, `Milestone-Release13`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c41) posted by **wasserman.louis** on 2012-05-02 at 04:57 PM_
---
FYI, cbiffle, Emily Soldal's "return a Ticket when a listener is registered" suggestion from issue 784 also addresses your suggestion of "register exception handlers on a per-listener basis."
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c42) posted by **kevinb@google.com** on 2012-05-30 at 07:41 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Enhancement-Temp`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c43) posted by **kevinb@google.com** on 2012-05-30 at 07:45 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement-Temp`, `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c44) posted by **wasserman.louis** on 2012-06-28 at 09:49 AM_
---
Deleting the milestone from this and marking as Research like the rest of `EventBus`, since I don't think this'll make it out in 13.  (I'm going to start putting in some research on the `EventBus`&nbsp;issues shortly, though.)
---
**Status:** `Research`
**Labels:** -`Milestone-Release13`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c45) posted by **ashwin.jayaprakash** on 2012-07-01 at 06:50 PM_
---
At the very least, please make EventHandler "public and final" so that we can subclass Eventbus and override the "dispatch(Object event, EventHandler wrapper)" method. We can write our own code try-catch block and call "wrapper.handleEvent(event)" instead of just logging exceptions.
Right now EventHandler is package-private and we cannot even override the protected method. Seems weird that the method is protected but the parameter is package-protected.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c46) posted by **ashwin.jayaprakash** on 2012-07-02 at 05:34 PM_
---
Oh I see that in R13 the "EventBus.dispatch" method is package-private (https://github.com/google/guava/blob/master/guava/src/com/google/common/eventbus/EventBus.java#L300)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c47) posted by **wasserman.louis** on 2012-09-05 at 02:07 PM_
---
_(No comment entered for this change.)_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c48) posted by **wasserman.louis** on 2012-09-05 at 02:08 PM_
---
_Issue #1132 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c49) posted by **sudarshan89** on 2012-09-07 at 08:19 PM_
---
We plan to use the event bus in production, for which we need to have some clarity on the exception handling mechanism. Any timelines by which this could be decided ?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c50) posted by **adam.g...@evocatus.com** on 2012-09-07 at 08:35 PM_
---
@sudarshan If you can't wait just copy the code from the eventbus package and put it into your own package. I had to do this because of JULI.
&nbsp;&nbsp;protected void dispatch(Object event, EventHandler wrapper) {
&nbsp;&nbsp;&nbsp;&nbsp;try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wrapper.handleEvent(event);
&nbsp;&nbsp;&nbsp;&nbsp;} catch (InvocationTargetException e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// My logger
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.error(fatal, "Could not dispatch event: " + event + " to handler " + wrapper, e);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// My own custom runtime exception
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new EventBusException(e);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c51) posted by **dro...@solveitsoftware.com** on 2013-03-07 at 02:08 PM_
---
Do you guys have any update regarding this issue? Any ETAs?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c52) posted by **cgdecker** on 2013-03-18 at 03:49 AM_
---
Sorry, no ETAs at this time, but I will try to get back to these EventBus issues and see what can be done when I get a chance.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c53) posted by **b.k.oxley** on 2013-07-23 at 03:05 AM_
---
Something as simple as this would be appreciated:
public class XEventBus extends EventBus {
&nbsp;&nbsp;&nbsp;&nbsp;public static final class ExceptionEvent {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public final Object event;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public final InvocationTargetException exception;
```
public ExceptionEvent(final Object event, final InvocationTargetException exception) {
this.event = event;
this.exception = exception;
}
}
void dispatch(final Object event, final EventHandler wrapper) {
try {
wrapper.handleEvent(event);
} catch (final InvocationTargetException e) {
post(new ExceptionEvent(event, e));
}
}
```
}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c54) posted by **b.k.oxley** on 2013-07-23 at 03:10 AM_
---
Left out a detail - need an initial dead event handler to avoid looping when there is not exception event handler.  Could either be special cased in the ITE catch clause, or provide EB with a default dead event handler that similar to the current ITE catch clause.
---
It's not a problem to extend EventBus and make it throw exceptions. I did that a year ago. I remember that there were a few obstacles because the class was not designed for being extended, but it worked... There are disadvantages though...
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c56) posted by **peter.prikryl** on 2013-11-07 at 08:42 AM_
---
easy WORKAROUND to re-throw exception:
package com.google.common.eventbus;
import java.lang.reflect.InvocationTargetException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
&nbsp;&nbsp;&nbsp;&nbsp;private static final Logger LOG = LoggerFactory.getLogger(RDSEventBus.class);
```
void dispatch(Object event, EventHandler wrapper) {
try {
wrapper.handleEvent(event);
} catch (InvocationTargetException e) {
LOG.error("Could not dispatch event: {} to handler {}", event, wrapper, e);
}
}
```
}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c57) posted by **cgdecker@google.com** on 2013-11-07 at 06:59 PM_
---
In Guava 16.0, you'll be able to register a SubscriberExceptionHandler to provide custom handling for exceptions thrown by subscribers: https://github.com/google/guava/blob/master/guava/src/com/google/common/eventbus/EventBus.java#L190
Note that you _cannot_ use this handler to make post() throw an exception when a subscriber throws an exception... that still goes against the fundamental design of the event bus.
Other than that, you can do pretty much whatever you want. The SubscriberExceptionHandler is given all the information on the context of the exception. You can even use it to post an exception event of some type back to the EventBus if that's what you want (you'll want to make sure that your subscriber methods that handle the exception event don't throw exceptions themselves though).
---
**Status:** `Fixed`
**Owner:** cgdecker@google.com
**Labels:** `Milestone-Release16`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c58) posted by **cgdecker@google.com** on 2013-11-07 at 07:01 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c59) posted by **sebastian.davids** on 2014-01-06 at 10:42 PM_
---
Please update the package documentation and the wiki with an usage example.
https://code.google.com/p/guava-libraries/wiki/EventBusExplained
https://google.github.io/guava/apidocs/com/google/common/eventbus/package-summary.html
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c60) posted by **mehmetsen80** on 2014-08-16 at 07:01 PM_
---
Well, I have still same issues but in a different scenario
When I run in spring sts, there is no issue but when I run in the server with java -jar project.jar  it gives the same SEVERE: Could not dispatch event: error
The below didn't work for me..
package edu.uams.event;
import java.awt.EventQueue;
import java.lang.reflect.InvocationTargetException;
import java.util.concurrent.Executor;
import org.apache.log4j.Logger;
import com.google.common.eventbus.AsyncEventBus;
import com.google.common.eventbus.EventHandler;
import com.google.common.eventbus.SubscriberExceptionHandler;
import edu.uams.pacs.IncomingFileMonitor;
```
private final static Logger logger = Logger.getLogger(AysncTraumaEventBus.class);
private String name = null;
public AysncTraumaEventBus(Executor executor,
SubscriberExceptionHandler subscriberExceptionHandler) {
super(executor, subscriberExceptionHandler);
logger.info("AysncTraumaEventBus created.");
}
public AysncTraumaEventBus(String name, Executor executor) {
super(name,executor);
this.name=name;
logger.info("AysncTraumaEventBus created. Name:"+this.name);
}
public void register(Object object) {
super.register(object);
}
public void unregister(Object object) {
super.unregister(object);
}
public void dispatch(Object event, EventHandler wrapper) {
try {
wrapper.handleEvent(event);
} catch (InvocationTargetException e) {
// My logger
logger.error("Could not dispatch event: " + event + " to handler " + wrapper+"  e:"+e.getMessage());
logger.info("Lets try to disptach again!");
super.post(new ExceptionEvent(event, e));
}
}
public static final class ExceptionEvent {
public final Object event;
public final InvocationTargetException exception;
public ExceptionEvent(final Object event, final InvocationTargetException exception) {
this.event = event;
this.exception = exception;
}
}
```
}
Somehow the EventHandler can't invoke the target event..
wrapper.handleEvent(event);
When you look the wrapper (EventHandler):
public void handleEvent(Object event) throws InvocationTargetException {
&nbsp;&nbsp;&nbsp;&nbsp;checkNotNull(event);
&nbsp;&nbsp;&nbsp;&nbsp;try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;method.invoke(target, new Object[] { event });
&nbsp;&nbsp;&nbsp;&nbsp;} catch (IllegalArgumentException e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error("Method rejected target/argument: " + event, e);
&nbsp;&nbsp;&nbsp;&nbsp;} catch (IllegalAccessException e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error("Method became inaccessible: " + event, e);
&nbsp;&nbsp;&nbsp;&nbsp;} catch (InvocationTargetException e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (e.getCause() instanceof Error) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw (Error) e.getCause();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw e;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;}
You see that method.invoke(target, new Object[] { event });  throws the InvocationTargetException from the Method.class
&nbsp;public Object invoke(Object obj, Object... args)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InvocationTargetException
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!override) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Class<?> caller = Reflection.getCallerClass(1);
```
checkAccess(caller, clazz, obj, modifiers);
}
}
if (ma == null) {
}
return ma.invoke(obj, args);
}
```
If it doesn't know the target doesn't it mean that @Subscribe does not work as expected? So it means then it can't find the subscribed method?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c61) posted by **mehmetsen80** on 2014-08-16 at 07:48 PM_
---
What the interesting part is that the same jar file along with EventBus can run fine in STS Run but when I run java from commandline as java -jar project.jar it doesn't dispatch the event.. still confused
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=753) created by **finnw1** on 2011-10-13 at 01:46 AM_
---
The various saturatedCast methods allow saturated addition of bytes/shorts/ints, e.g.
byte x = 99, y = 99;
// ...
byte z = SignedBytes.saturatedCast((long) x + (long) y); // => 127
This does not work for longs however, because there is no primitive type large enough to hold the intermediate result.
So it would be nice to have methods to perform saturated adds directly.
I have not included saturatedMultiply because I don't know whether it is feasible or whether there is any demand for it.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=753#c1) posted by **wasserman.louis** on 2011-10-16 at 11:23 PM_
---
We considered this, but came to the conclusion that saturatedAdd, etc. wasn't nearly as common a use case as checkedAdd.  Do you have an actual use case?
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=753#c2) posted by **finnw1** on 2011-10-17 at 01:08 AM_
---
I use it to implement longValue() in a subclass of Number.  I don't know how common that is though.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=753#c3) posted by **wasserman.louis** on 2011-10-18 at 05:59 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=753#c4) posted by **kevinb@google.com** on 2011-11-15 at 10:15 PM_
---
I'd like to have more evidence of actual user demand for this.
---
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=753#c5) posted by **wasserman.louis** on 2011-11-15 at 10:31 PM_
---
Ditto that.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=753#c6) posted by **fry@google.com** on 2011-12-10 at 04:21 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Primitives`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=753#c7) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=753#c8) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=753#c9) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=753#c10) posted by **kasperni** on 2013-01-07 at 03:05 PM_
---
FWIW I use a saturated long add to calculate deadlines in the form of
void await(long timeout, TimeUnit unit) {
&nbsp;&nbsp;long deadline=saturatedAdd(System.nanoTime(), unit.toNanos(timeout))
&nbsp;&nbsp;for(;;) {
&nbsp;&nbsp;&nbsp;sleep(deadline-System.nanoTime();
&nbsp;&nbsp;}
}
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=741) created by **dancerjohn** on 2011-10-06 at 06:21 PM_
---
There are times when firstNonNull is called but where it would be helpful if the second argument was not evaluated unless the first was actually null. I found this to be the case when reading a file and I only wanted the line read if the first was null.
I propose a version of firstNonNull that takes a Supplier as the second argument.
static &lt;T> T firstNonNull(@Nullable T first, @Nonnull Supplier&lt;T> second);
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=741#c1) posted by **cgdecker** on 2011-10-06 at 07:30 PM_
---
You can already use Optional for this and the Javadoc for firstNonNull points that out.
&nbsp;&nbsp;Supplier&lt;T> second = ...
&nbsp;&nbsp;T foo = Optional.fromNullable(first).or(second);
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=741#c2) posted by **kevinb@google.com** on 2011-10-06 at 07:54 PM_
---
---
**Status:** `WorkingAsIntended`
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=741#c3) posted by **dancerjohn** on 2011-10-06 at 08:17 PM_
---
Cool. I was using v9 and didn't see it.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=733) created by **ra...@kubacki.cz** on 2011-10-03 at 08:01 AM_
---
http://guava-libraries.googlecode.com/svn/trunk/javadoc/com/google/common/base/Optional.html mentions mutable holder class Holder though it is missing at the moment. Can this be added in the future?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=733#c1) posted by **j...@nwsnet.de** on 2011-10-04 at 12:54 PM_
---
IIRC the mutable holder has been left out due to somewhat limited utility.
Also, the base class of both the mutable and immutable holder (the latter being `Optional`) has been dissolved due to issue #704.
After all, I guess it is not planned to provide a mutable holder in future releases.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=733#c2) posted by **ra...@kubacki.cz** on 2011-10-04 at 01:23 PM_
---
Re limited usability: Swing desktop application can find it useful when you want to run code in event dispatch thread and get some result (think about displaying a dialog to confirm an operation or do more complex action). While executor libraries have possibility to run Callable returning a typed value Swing only support execution of a Runnable and thus there is a code like:
final MyResult[] resultHolder = new MyResult[1];
SwingUtilities.invokeLater(new Runnable() {... resultHolder[0] = result; });
...
// do something with the result
Depends on your decision. If you do not plan it then it can be enough just to clean up the documentation.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=733#c3) posted by **cgdecker** on 2011-10-04 at 03:08 PM_
---
That code is a good example of why Holder _shouldn't_ be added, if anything. Rather than a Holder&lt;MyResult> or a MyResult[], you should be using an AtomicReference&lt;MyResult> to capture that result. Or better yet, submitting a FutureTask&lt;MyResult> to invokeLater and calling get() on it to get the result (FutureTask implements Runnable and can wrap a Callable so you don't need to have an actual ExecutorService).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=733#c4) posted by **cpovirk@google.com** on 2011-10-04 at 04:16 PM_
---
We introduced such a class (actually, with a bunch more functionality, none of which is widely used), and we found it was largely used in places where it was expedient but not a good long-term solutions.  For example:
public String getUser(long id, Holder&lt;String> emailAddressHolder)
...instead of...
public User getUser(long id)
public final class User { ... String username; ... String emailAddress; ... }
Or:
public void lookupAsync(long key, Holder&lt;Data> holder, Closure closure)
...instead of...
public void lookupAsync(long key, Callback&lt;Data> callback)
All that said, there remain good uses for Holder, and I encourage private helper classes where appropriate:
private static final class Holder&lt;T> {
&nbsp;&nbsp;T value;
}
---
**Status:** `WontFix`
Again, use either AtomicReference<Thread> or a private helper class.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=719) created by **young.jiandong** on 2011-09-22 at 04:10 PM_
---
example:
String testString = "WB,QY,1,N,04, , ,1,Y,,";
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Iterable&lt;String> s = Splitter.on(",").split(testString);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterable&lt;String> s = Splitter.on(",").omitEmptyStrings().trimResults().split(testString);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (String string : s) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("[" + string);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
java.lang.NoSuchMethodError: com.google.common.base.Platform.precomputeCharMatcher(Lcom/google/common/base/CharMatcher;)Lcom/google/common/base/CharMatcher;
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=719#c1) posted by **cgdecker** on 2011-09-22 at 04:27 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=719#c2) posted by **young.jiandong** on 2011-09-23 at 02:19 PM_
---
how to remove google-collection.I use mvn,pom.xml,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;dependency>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupId>com.google.guava&lt;/groupId>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;version>r09&lt;/version>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/dependency>
run mvn eclipse:eclipse,it auto create google-collecion-1.0.jar
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=719#c3) posted by **neveue** on 2011-09-23 at 03:09 PM_
---
google-collections might come from a transitive Maven dependency...
You should use the Maven dependency tree plugin to list all dependencies and find out which dependency transitively includes google-collection ( http://stackoverflow.com/questions/34144/in-maven-2-how-do-i-know-from-which-dependency-comes-a-transitive-dependency ).
Once found, you can exclude this dependency using the "exclusions" tag. You may find an example in the following StackOverflow _question_ (not answer!): http://stackoverflow.com/questions/547805/how-to-exclude-all-transitive-dependencies-of-a-maven-dependency
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=719#c4) posted by **young.jiandong** on 2011-09-24 at 01:19 AM_
---
think you
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=719#c5) posted by **young.jiandong** on 2011-09-24 at 01:20 AM_
---
thank you :-)
2011/9/24 yangjiandong &lt;young.jiandong@gmail.com>
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=719#c6) posted by **cpovirk@google.com** on 2011-09-27 at 04:26 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Invalid`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=719#c7) posted by **zz...@nyu.edu** on 2014-04-23 at 07:17 PM_
---
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=708) created by **b.michael.web** on 2011-09-14 at 09:17 AM_
---
Hi,
I feel the need for skipping empty string values in Joiner class like it already exists in Splitter.
Joiner.on(" ").skipNulls().omitEmptyStrings().join(strings);
Even if you use
Joiner.on(" ").join(Iterables.filter(strings, StringPredicates.notEmpty()));
the first version is much more expressive and intuitive.
Thanks in advance
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=708#c1) posted by **kevinb@google.com** on 2011-12-05 at 07:04 PM_
---
The reason Joiner has skipNulls and useForNull is that there's no obvious way to handle null if we aren't told what to do. But in the case of empty strings, it is obvious what the logical default way to handle them is.
---
**Status:** `WorkingAsIntended`
**Labels:** `Type-Enhancement`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=700) created by **typrase** on 2011-08-31 at 05:28 PM_
---
Reported downstream as: https://github.com/sonatype/sisu/pull/2
diff --git a/guava/src/com/google/common/collect/MapMaker.java b/guava/src/com/google/common/collect/MapMaker.java
index a3b6b76..660f540 100644
@@ -27,6 +27,7 @@ import com.google.common.base.Equivalence;
&nbsp;import com.google.common.base.Equivalences;
&nbsp;import com.google.common.base.Function;
&nbsp;import com.google.common.base.Objects;
+import com.google.common.base.Throwables;
&nbsp;import com.google.common.base.Ticker;
&nbsp;import com.google.common.collect.ComputingConcurrentHashMap.ComputingMapAdapter;
&nbsp;import com.google.common.collect.CustomConcurrentHashMap.Strength;
@@ -995,6 +996,7 @@ public final class MapMaker extends GenericMapMaker&lt;Object, Object> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (ComputationException e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw e;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (Throwable t) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new ComputationException(t);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=700#c1) posted by **kevinb9n** on 2011-08-31 at 06:28 PM_
---
Is it ever correct to use Thread.stop()?
http://download.oracle.com/javase/1.4.2/docs/guide/misc/threadPrimitiveDeprecation.html
Given the severity of the problems with it, does it really change much if this represents one additional problem?
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=700#c2) posted by **typrase** on 2011-08-31 at 06:48 PM_
---
Anyway the places in Guava that are catching Throwable will also be catching OutOfMemoryError, StackOverflowError, and all sorts of other things that would be better propagated as is rather than wrapped. Probably catching Exception (or RuntimeException) is all you need in these cases. In some limited cases relating to the implementation of containers or extensibility systems, catching LinkageError is useful as well.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=700#c3) posted by **kevinb9n** on 2011-09-01 at 02:21 PM_
---
The link states that code that is unresponsive to Thread.interrupt() will be just as unresponsive to Thread.stop; is that not true?
---
**Status:** `Accepted`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=700#c4) posted by **typrase** on 2011-09-01 at 07:57 PM_
---
"...is that not true?" - not relevant here unless the thread happens to be waiting on a socket. A thread which is running plain old code can be stopped but not (generally) interrupted.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=700#c5) posted by **kevinb@google.com** on 2012-03-02 at 06:51 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-General`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=696) created by **uklance** on 2011-08-24 at 04:16 PM_
---
Any object that implements java.io.Serializable can be cloned as follows:
public static Serializable clone(final Serializable obj) throws Exception {
&nbsp;&nbsp;&nbsp;ByteArrayOutputStream out = new ByteArrayOutputStream();
&nbsp;&nbsp;&nbsp;ObjectOutputStream oout = new ObjectOutputStream(out);
&nbsp;&nbsp;&nbsp;oout.writeObject(obj);
&nbsp;&nbsp;&nbsp;ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));
&nbsp;&nbsp;&nbsp;return Serializable.class.cast(in.readObject());
}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=696#c1) posted by **cgdecker** on 2011-08-24 at 06:52 PM_
---
What would you need this for? If it's for testing, guava-testlib has SerializableTester (https://github.com/google/guava/blob/master/guava-testlib/src/com/google/common/testing/SerializableTester.java) for this.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=696#c2) posted by **uklance** on 2011-08-25 at 07:59 AM_
---
I have a production use case where I want to create a bean by cloning a template bean. I will then configure additional properties on the clone and don't want to affect original template.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=696#c3) posted by **cgdecker** on 2011-08-25 at 02:49 PM_
---
It seems to me that you should create a method that creates a copy of your bean and call that directly. Abusing the serialization mechanism just to get a copy of an object doesn't seem like a good idea.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=696#c4) posted by **uklance** on 2011-08-25 at 03:48 PM_
---
The bean in question is in a separate module that is not maintained by my team. We could obviously create a clone() method ourselves but as fields get added to the bean in future, we may miss some properties. To avoid this we could create a clone by reflectively iterating the bean's properties but this is slow.
I have seen the serialize/deserialize used a few times and don't see it as an abuse of serialization. With this technique, I can guarantee that I have a deep clone of an object. Other techniques rely on developers to correctly implement a deep clone.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=696#c5) posted by **uklance** on 2011-08-25 at 04:18 PM_
---
I have attached a test case highlighting the problems with Cloneable
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=696#c6) posted by **kevinb@google.com** on 2011-08-29 at 06:12 PM_
---
---
**Status:** `WorkingAsIntended`
**Labels:** `Type-Enhancement`
>  I should caution that this technique is not to be used lightly. First of all, serialization is hugely expensive. It could easily be a hundred times more expensive than the clone() method. Secondly, not all objects are serializable. Thirdly, making a class serializable is tricky and not all classes can be relied on to get it right. (You can assume that system classes are correct, though.)
---
I've a use-case where where I pool Sockets (SocketChannels) and ByteBuffers and I've managed to hack-up a simple Pool / BlockingPool interface for myself with an implementation which uses Suppliers to supply objects for a pool on-demand. I'd like to propose to add something similar to Guava.
Basically the interface(s) goes like this: http://pastebin.com/QJ6v7MxD
When poll() / take() is called the Pool would use a Supplier to create a new object for the pool. A Pool could be initialized like this:
Pools.&lt;O>create(int capacity, Supplier&lt;O> supplier);
`supplier`&nbsp;here could create a new object every time its get() method is called (in my case it creates a new unconnected SocketChannel).
As I searched for `pooling`&nbsp;on SO the only thing I learned was that nobody likes to use commons-pool, so I thought maybe Guava would extend its rich set of features to cover this, as everybody seems to like Guava. So, is this idea any good? (Btw. here: http://pastebin.com/fwYtKNg2 is my implementation, not tested extensively.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=683#c1) posted by **kevinb@google.com** on 2011-08-29 at 06:31 PM_
---
I believe pooling to be a bona fide Hard Problem.  But we have some initial thoughts about it which we may get around to posting.
The API should be the easier part. There are two basic approaches,
passive (note, simpler in JDK 7):
&nbsp;&nbsp;Pool&lt;Expensive> pool = ...
&nbsp;&nbsp;Lease&lt;Expensive> lease = pool.leaseObject();
&nbsp;&nbsp;try {
&nbsp;&nbsp;&nbsp;&nbsp;Expensive o = lease.leasedObject();
&nbsp;&nbsp;&nbsp;&nbsp;doSomethingWith(o);
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;} finally {
&nbsp;&nbsp;&nbsp;&nbsp;lease.close();
&nbsp;&nbsp;}
or active:
&nbsp;&nbsp;Pool&lt;Expensive> pool = ...
&nbsp;&nbsp;pool.nameThisMethod(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Receiver&lt;Expensive>() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void receive(Expensive o) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doSomethingWith(o);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});
And yes, it'd need something like a Supplier to generate instances as needed. There are endless possibilities for how something like might need to be configured though.
---
**Status:** `Accepted`
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=683#c2) posted by **fry@google.com** on 2011-12-10 at 04:14 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Concurrent`
---
Any plans or progress for the timeline on this feature?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=683#c4) posted by **fry@google.com** on 2012-03-20 at 02:27 PM_
---
We have no plans to work on this at this time. Sorry. :-(
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=683#c5) posted by **kevinb@google.com** on 2012-03-30 at 03:45 PM_
---
Here's a question:  there's an occasional use case that is similar to a Pool in some ways -- you want pre-created instances on hand ready to hand out, if you dip below a certain # in stock you want to create a new batch of them, etc. -- but the difference is that users only take() the objects, they don't lease() and then return them.
At a glance, that's not a "pool" at all, but something like a Supply&lt;T> or Stockpile&lt;T>.  But if the only difference between them is whether you call take() or lease(), it doesn't necessarily seem worth forcing them into separate utilities.  Any ideas?
---
So, if the actual question was "Should there be separate Pool and Stockpile interfaces?" then my opinion is that a single Pool interface could suffice.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=683#c7) posted by **wasserman.louis** on 2012-04-10 at 10:40 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=683#c9) posted by **em...@soldal.org** on 2012-05-11 at 07:45 AM_
---
I just encountered a usecase for this with selenium. I want to have a pool of selenium drivers to take from. I'd say +1 for the ACTIVE approach, I'm going to be implementing something akin to that internally.
Edit/Re-post: I derp'd and +1'd the wrong approach.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=683#c10) posted by **em...@soldal.org** on 2012-05-11 at 02:28 PM_
---
Some information about what I ran into when implementing this:
Pools should have a configurable object acquisition policy, be it thread blocking or simply spawning a new object when one becomes available or throwing an exception and perhaps more that I haven't thought of yet.
Pools should handle GC gracefully, in our implementation when an object is being leased, the pool doesn't hold a reference to it, should it be GC'd we have a disposer strategy akin to a removal listener from the caching API which handles any odd cases.
My Pool interface right now only has:
void lease(Reciever&lt;T>)
void empty()
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=683#c11) posted by **ogregoire** on 2012-05-11 at 03:30 PM_
---
Unlike Emily, I prefer the passive approach as it is more like all we handle everyday. The try-with-resource has become quite popular within our team - some even chase the old trys to replace them with the new one. Encapsulation of bracket squares makes the code less readable and leads to the creation of unnecessary temporary objects and the management of final variables, which is quite noisy. The passive approach on the contrary uses a known code structure that is quite explicit and understandable to everyone, though the structure itself needs to be learned by the user of the API.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=683#c12) posted by **em...@soldal.org** on 2012-05-14 at 10:30 AM_
---
I think that if the structure of active vs. passive needs to be learnt then there are more fundamental issues to address.
The active approach means that you have to add a lot of boiler plate to your code, if this is something you access regularly then the code can quickly become cluttered.
The managment of final variables isn't hard and is only a concern for anon classes, its entierly possible to do this without.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=683#c13) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
---
I'd like to withdraw my comment of May 11. We've been experimenting with embedded for the last month and we find the active method not as bad as we did. We still prefer the passive way, but we don't see any objections to the active one anymore.
---
After using this kind of pattern for the last few months, we consider that the active way is useful when the code doesn't throw any checked exception and the passive way is good when the code does actually throw checked exception.
So what we do with our pool implementation is that we offer the two ways. Some might say it's redundant, but it leaves the choice to use the best option when programmers are faced to various cases. All that for "only" one more method and one more interface.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=683#c16) posted by **zolyfar...@yahoo.com** on 2013-04-28 at 03:49 PM_
---
Since no open source object pool implementation out there is to my liking,
I have been working on implementing a object pool.
Currently it is still in experimental phase.
Template.doOnPooledObject(new ObjectPool.Handler&lt;PooledObject, SomeException>() {
&nbsp;&nbsp;@Override
&nbsp;&nbsp;public void handle( PooledObject object) throws SomeException {
&nbsp;&nbsp;&nbsp;&nbsp;object.doStuff();
&nbsp;&nbsp;}
}, pool, IOException.class);  // will throw a IOException
or a more "classic" approach:
PooledObject object = pool.borrowObject();
try {
&nbsp;&nbsp;object.doStuff();
&nbsp;&nbsp;pool.returnObject(object,null);
} catch (Exception e) {
&nbsp;&nbsp;pool.returnObject(object,e);
&nbsp;&nbsp;throw e;
}
A key feature of my API, is to allow the pool user to provide exception feedback, to allow the pool to retire defective objects...
If you want to take a look, maybe you find some worthwhile ideas:
http://code.google.com/p/spf4j/source
implementation is in org.spf4j.pool package.
let me know what you think.
cheers.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=683#c17) posted by **Ben.Manes** on 2013-07-09 at 09:15 AM_
---
I guess I'll throw my hat into the ring...
I was asked by the Cassandra folks if I could implement a class mixing CLHM (predecessor to Guava's Cache), an object pool, and a multimap. The use-case is for maintaining a bound (size, ttl, or idle) on the total number of SSTable random access file readers, with the ability to pool multiple readers per SSTable. As this could impact latencies, a goal was to make it highly concurrent.
The interface is classic and not very interesting.
Internally the resources are denormalized into a cache of synthetic keys to resources. A weak value cache of key to transfer queue acts as a view layer to manage the available resources that category type. A transfer queue is used to provide a fast exchange between producers (release) and consumers (borrow), as elimination helps alleviate contention. The resource's synthetic key retains a hard reference to its queue, allowing unused queues to be aggressively garbage collected by weak references.
Each resource operates within a simple state machine: IDLE, IN_FLIGHT, RETIRED, and DEAD. The idle and in-flight states are self explanatory, indicating only if the resource is in the transfer queue. The retired state is transitioned to when the cache evicts a resource currently being used, thereby requiring the release() to transition it to the dead state. The lifecycle listeners allows the resource to be reset, closed, etc. as needed.
The time-to-idle is a bit naive, as I didn't want to complicate it early on. A secondary cache is used so that the idle time is counted as the time the resource is not in-flight. This could be optimized by using the lock amortization technique directly and not be bang against the hash table's locks. When the idle cache evicts, it transitions the resource to the retired state and invalidates it in the primary cache.
This was written over the July 4th holiday for a specific use-case, so I am sure there's more that could be flushed out. That also means that while it has unit tests, it has not been benchmarked.
https://github.com/ben-manes/multiway-pool
Cheers,
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=683#c18) posted by **Ben.Manes** on 2013-08-10 at 06:19 AM_
---
Switched to an elimination backoff stack. This is probably the best structure to design a pool around.
EBS - 28M/s
LTQ - 15M/s
CLQ - 16.5M/s
LBQ - 9M/s
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=683#c19) posted by **zolyfar...@yahoo.com** on 2013-09-24 at 09:17 PM_
---
Hi Ben,
I wrote a while ago implementation, global_pool <--> thread_local_pool which should perform in my opiniion better than EBS in high load cases.
implementtaion is at:
http://code.google.com/p/spf4j/source/browse/#svn%2Ftrunk%2Fspf4j-core%2Fsrc%2Fmain%2Fjava%2Forg%2Fspf4j%2Fpool
I have a simple benchmark against apache commons pool (which is not hard to beat):
http://code.google.com/p/spf4j/source/browse/trunk/spf4j-core/src/test/java/org/spf4j/pool/impl/ObjectPoolVsApache.java
Could run your test against this implementation to see how it performans against EBS?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=683#c20) posted by **Ben.Manes** on 2013-09-25 at 02:00 AM_
---
Probably what you implemented, and something I thought of after posting the above, is a global list of handles that a thread retains a thread-local reference to one of. That way a thread will likely claim and release the same resource without contending with another thread. The slight complexity is stealing idle resources when necessary. If that is what you implemented, I agree it should be fundamentally faster than an EBS.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=683#c21) posted by **zolyfar...@yahoo.com** on 2013-09-26 at 11:29 PM_
---
Yup, that is pretty much it. This implementation will "bias" the pooled objects to threads and will not steal a object from other threads if another object can be created or one is available in the "global" bag. Objects can be unbiased from a thread also by a "maintenance" thread.
I was not aware Louis had gotten that much of a start on it!
Note that for it to work most pleasantly, Lease should implement AutoCloseable, meaning the whole thing needs to live in a library that depends on JDK 7, which Guava currently doesn't....
To be perfectly honest, I had completely forgotten about the existence of that.
This discussion belongs elsewhere, but I believe the expected outcome is that a Guava for Java 8 is likely, but the difference between 6 and 7 is small enough that maintaining yet another fork is not obviously a worthwhile tradeoff.
Sorry, unfortunately this has never seemed to inch its way up the priority list at all.  _[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=680) created by **pjulien** on 2011-08-09 at 01:55 PM_
---
That we can feed elements, via Iterable<?>, to tree sets that also have a custom comparator
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=680#c1) posted by **neveue** on 2011-08-09 at 09:02 PM_
---
This was discussed in the past, and I believe Guava won't add this:
https://github.com/google/guava/issues/618
http://code.google.com/p/google-collections/issues/detail?id=304
Set&lt;E> set = Sets.newTreeSet(comparator);
Iterables.addAll(set, iterable);
or, if you really want a one-liner, and an immutable set is acceptable:
SortedSet&lt;E> set = ImmutableSortedSet.&lt;E>orderedBy(comparator).addAll(elements).build();
Anyway, most of Guava's com.google.common.collect.Xxxs.newXxx() methods will become pointless with Java 7's diamond operator. Except maybe Lists.newArrayListWithCapacity() and Lists.newArrayListWithExpectedSize() where the static factory's name is useful.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=680#c2) posted by **pjulien** on 2011-08-09 at 09:07 PM_
---
ah, of course, it's because of the varargs already present.  As for the Java 7 part, I still think this way looks better and is less typing than the diamond operator
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=680#c3) posted by **j...@nwsnet.de** on 2011-08-16 at 07:54 AM_
---
> will become pointless with Java 7's diamond operator.
> Why would that be the case? It would require the JDK's collections to accept both varargs and `Iterable`&nbsp;in addition to `Collection`. And varargs conflict with the current implementation which accepts a single integer as capacity total, which is why Guava has `*WithExpected[Capacity|Size]()`.
IMHO, the diamond operator is just a supposedly (rather) easily implemented way to make a problematic collections API less verbose than necessary. For the various ways to create collections, factory methods seem to be a clearer and more extensible approach to me.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=680#c4) posted by **kevinb@google.com** on 2011-08-16 at 03:43 PM_
---
Correct, it's just the parameterless ones that will become useless.
Closing this request as already decided against long ago.
---
**Status:** `WorkingAsIntended`
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=680#c5) posted by **neveue** on 2011-08-16 at 06:15 PM_
---
That's a good point. I didn't consider the varargs and Iterable versions of Lists.newArrayList().
For the record, I 100% agree that factory methods are useful for naming purposes (as I wrote at the end of comment #1).
"Simpler" factory methods (such as Lists.newArrayList()) will become less interesting with Java 7, but I guess it's good to keep them for consistency.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=680#c6) posted by **cpovirk@google.com** on 2014-06-13 at 01:29 PM_
---
_Issue #1780 has been merged into this issue._
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=679) created by **dancerjohn** on 2011-08-08 at 01:20 PM_
---
This request is similar to the following two issues, but more generic. These two issues request a new version of Maps.uniqueIndex that takes in keys instead of values. A more generic version would be a map method that would take an iterator of any type and use a function to determine both the key and value.
Similar Issue:
https://github.com/google/guava/issues/56
https://github.com/google/guava/issues/460
Suggested generalized version signatures (implementation attached):
// First version with a separate function for key and value which would allow for the use of the identity function.
public static &lt;I, K, V> Map&lt;K, V> map(Iterable&lt;I> input, Function&lt;I, K> keyFunction, Function&lt;I, V> valueFunction);
public static &lt;I, K, V> void addToMap(Iterable&lt;I> input, Map&lt;K, V> map, Function&lt;I, K> keyFunction, Function&lt;I, V> valueFunction);
// Second version which uses a single function to retrieve both key and value
public static &lt;I, K, V> Map&lt;K, V> map(Iterable&lt;I> input, Function&lt;I, Map.Entry&lt;K, V>> transform);
public static &lt;I, K, V> void addToMap(Iterable&lt;I> input, Map&lt;K, V> map, Function&lt;I, Map.Entry&lt;K, V>> transform);
There are two versions of each of the method to allow for the passing of a specific Map type rather than being locking into getting a HashMap.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=679#c1) posted by **kevinb9n** on 2011-09-01 at 05:38 PM_
---
Not convinced of the widespread need for these yet, but we'll see.
---
**Status:** `Triaged`
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=679#c2) posted by **andresrc** on 2011-09-01 at 06:17 PM_
---
I've felt the need for this kind of method many times when loading maps using results from a database query.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=679#c3) posted by **dancerjohn** on 2011-09-01 at 06:44 PM_
---
My point is that rather than moving forward with the other issues listed above, this would be a more generic solution and should be used instead. The identity function in combination with this version would produce the effect requested in the other issues.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=679#c4) posted by **christoph.hoesler** on 2011-10-08 at 08:04 AM_
---
I would rather love to see such a function in ImmutableMap.Builder&lt;K,V>.
public &lt;E> ImmutableMap.Builder&lt;K,V> putAll(Iterable<? extends E> iterable, Function<? super E,K> keyFunction, Function<? super E,V> valueFunction);
I think this makes you even more flexible in map creation. In that way it would also replace uniqueIndex and add the requested uniqueValue if one passes the identity function as either the keyFunction or valueFunction.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=679#c5) posted by **fry@google.com** on 2011-12-10 at 04:14 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Collect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=679#c6) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=679#c7) posted by **wasserman.louis** on 2012-02-23 at 07:28 PM_
---
What parts of this issue aren't covered by the Idea Graveyard nix on "create a map from an Iterable&lt;Pair>, Iterable&lt;Map.Entry>, Object[](alternating keys and values), or from List&lt;K> + List&lt;V>"?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=679#c8) posted by **dancerjohn** on 2012-02-23 at 08:41 PM_
---
There has been a deemed need to have the following:
1. Map&lt;K, V> uniqueIndex(Iterable&lt;V>, Function&lt;V,K>) (already exists)
2. Map&lt;K, V> uniqueIndex(Iterable&lt;K>, Function&lt;K,V>) (issue 56 & 460)
However, what if the input is neither the key nor the value? Hence the need for:
3. Map&lt;K,V> uniqueIndex(Iterable&lt;T>, Function&lt;T,K>, Function&lt;T,V>)
It seems that the above single function (3) covers both case 1 & 2 above (with use of the Identity function) and allows for an additional case where the input is neither the key nor value.
The case could be made that you could convert the input to either the key or value and use one of the methods 1 or 2 above, but what if the key cannot be calculated from the value of vise versa.
It seems odd to me to have two methods where one would work especially considering the focus of reducing API bloat.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=679#c9) posted by **wasserman.louis** on 2012-02-23 at 09:46 PM_
---
Do you have an actual use case in mind?  We're having some trouble coming up with anything realistic.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=679#c10) posted by **acooke.org** on 2012-02-24 at 03:59 PM_
---
For what it's worth, I just arrived at this issue while trying to find a way to generate a lookup table for "named" objects.  I thought it would be a common case: I have an iterable of objects that have names, and wanted to construct a map from each name to the associated instance.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=679#c11) posted by **cpovirk@google.com** on 2012-02-24 at 04:04 PM_
---
Is the method you need the existing Maps.uniqueIndex?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=679#c12) posted by **wasserman.louis** on 2012-02-24 at 04:07 PM_
---
It sure sounds like it.  Maps.uniqueIndex(namedObjects, nameFunction) is exactly the right solution for that use case.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=679#c13) posted by **dancerjohn** on 2012-03-07 at 04:10 PM_
---
What about a case where there is a list of Files (say the files in a directory) and there is a need to create a Map&lt;String, Object> where the key is the file name and the Object is some data that is parsed from the file.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=679#c14) posted by **wasserman.louis** on 2012-03-07 at 04:33 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=679#c15) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=679#c16) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=679#c18) posted by **sebastian.davids** on 2012-10-31 at 01:01 PM_
---
Our use case is similar to this:
class Option { String id; String valueId; }
Locale locale = ...;
Iterable&lt;Option> it = ...;
Map&lt;String, String> m = Maps.newLinkedHashMap();
for (Option o : it) {
&nbsp;&nbsp;&nbsp;&nbsp;m.put(o.id, translate(locale, o.valueId));
}
ImmutableMap&lt;String, String> result = ImmutableMap.copyOf(m);
Which would be used to generate:
&lt;input type="radio" name="id1" value="translatedValue1">
&lt;input type="radio" name="id2" value="translatedValue2">
...
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=679#c19) posted by **advoretsky** on 2012-12-16 at 04:49 PM_
---
I need such method to convert org.w3c.dom.NamedNodeMap to Map&lt;String, String>
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=679#c20) posted by **SeanPFloyd** on 2012-12-17 at 08:56 AM_
---
A NamedNodeMap doesn't fit in here at all, as it doesn't implement any of the standard java.util interfaces, such as Collection, Iterable or Map.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=679#c21) posted by **advoretsky** on 2012-12-17 at 09:15 AM_
---
Yeah, I am ready to wrap it to Iterable, but after that I would like to use guava for producing comfortable (for asserts in test) Map&lt;String, String>
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=679#c23) posted by **yuri.panchenko** on 2013-08-05 at 04:50 AM_
---
For what it's worth, just came across a need to generate a map from a list of objects.  It would be nice if Map.values were allowed to be transformations of the objects in the list, while the keys were allowed to be computed via the supplied function, all in one method call.  If anyone is interested in the use case, it is the zadd operation on Redis that accepts multiple members:
zadd(final byte key, final Map&lt;Double, byte[]> scoreMembers)
The Double parameter is a score or priority of any given member that should be computed from the object on the fly.
I think you could do this with:
``` java
Map<K, V> map = Maps.transformEntries(
Maps.uniqueIndex(iterable, new Function<I, K>() { ... }),
new EntryTransformer<K, I, V>() { ... });
```
or something similar.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=677) created by **chris.winters** on 2011-08-05 at 07:24 PM_
---
First reported in guava-discuss list: http://groups.google.com/group/guava-discuss/browse_frm/thread/da433e0b7db8c8ae
Be able to combine iterators but instead of moving through elements one at a time, pull from each iterator in turn until all are exhausted. Iterators should not have to be the same size. Sample code + output of how it might work:
Code:
List&lt;String> a = [ "one", "two", "three", "four" ];
List&lt;String> c = [ "broccoli", "tomato", "potato" ];
List&lt;String> d = [ "purple" ];
Iterator&lt;String> interleaved = Iterators.interleave(
&nbsp;&nbsp;&nbsp;&nbsp;a.iterator(), b.iterator(),
&nbsp;&nbsp;&nbsp;&nbsp;c.iterator(), d.iterator() );
int count = 1;
while ( interleaved.hasNext() ) {
&nbsp;&nbsp;&nbsp;System.out.println( count++ + ": " + interleaved.next() );
}
Output:
1: one
2: fee
3: broccoli
4: purple
5: two
6: fi
7: tomato
8: three
9: potato
10: four
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=677#c1) posted by **amertum** on 2011-08-05 at 09:58 PM_
---
We can also see this like that :
Iterator&lt;List&lt;String>> interleaved = Iterators.interleave(
&nbsp;&nbsp;&nbsp;&nbsp;a.iterator(), b.iterator(),
&nbsp;&nbsp;&nbsp;&nbsp;c.iterator(), d.iterator());
Output:
["one",   "fee",    "broccoli", "purple"]
["two",   "fi",     "tomato"]
["three", "potato"]
["four"]
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=677#c2) posted by **chris.winters** on 2011-08-06 at 04:16 PM_
---
I think that output would be fine since it can be sent to a separate Iterators.concat() method to flatten it to a single list.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=677#c3) posted by **j...@nwsnet.de** on 2011-08-16 at 08:04 AM_
---
Looks interesting to me. Can you supply a use case or two?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=677#c4) posted by **amertum** on 2011-08-16 at 12:06 PM_
---
A use case is when you retrieve some data from a third party which come in many list of single element which are related to each other. And then you need to process these data and you find yourself iterate over many collection which is not very logic and readable. The thing you really need is to interleave these data to have them close to each other.
Example :
names = ["robert", "paul", "mike"]
ages = [25, 32, 45]
interleave(names, ages) produces :
[
["robert", 25],
["paul", 32],
["mike", 45]
]
so now you can use a predicate to filter people which age is under 30.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=677#c5) posted by **j...@nwsnet.de** on 2011-08-16 at 01:20 PM_
---
> A use case is when you retrieve some data from a third party
> which come in many list of single element which are related to each other.
> An iterable of single-element iterables is easily pre-processed via `Itera[tor|ble]s.concat`.
>
> names = ["robert", "paul", "mike"]
> ages = [25, 32, 45]
> interleave(names, ages) produces :
> [
> ["robert", 25],
> ["paul", 32],
> ["mike", 45]
> ]
> This is exactly what `zip`&nbsp;commonly does.
I agree that the output example in comment #1 is a useful intermediate step to return before serializing the elements of all result tuples.
Also, what is the preferred result type? Guava still has no implementation of a n-tuple or even pair and triple concept. Immutable lists would be ok, but they'd work only for immutable elements. Iterators might also work (like returned by `itertools.groupby`&nbsp;in Python), but are not that comfortable to work with for direct/indexed element access.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=677#c6) posted by **gscerbak** on 2011-08-16 at 01:44 PM_
---
This is classic example of Java failing at tuples. Interleave makes sense only for compatible types - e.g. same type as in the example with String above. I am not sure a reasonable use case for this exists. If Iterables contain related data, you should combine them in an entity. If the interleaved order is important, that should be handled by Ordering, but I cannot imagine when such an Ordering would be useful.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=677#c7) posted by **gscerbak** on 2011-08-16 at 02:12 PM_
---
Pair in JDK 1.6 - java.util.AbstractMap.SimpleEntry&lt;K,V> and java.util.AbstractMap.SimpleImmutableEntry&lt;K,V>
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=677#c8) posted by **j...@nwsnet.de** on 2011-08-16 at 03:32 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=677#c9) posted by **gscerbak** on 2011-08-16 at 05:29 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=677#c10) posted by **amertum** on 2011-08-16 at 05:41 PM_
---
@gscerbak : OK, this is not very pretty to mix types but right now, I'm doing presentation using JSP with expression language which does not really care about type.
But I like the way you see it with Ordering. I'll think about it.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=677#c11) posted by **kevinb9n** on 2011-09-01 at 05:43 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=677#c13) posted by **han...@eyealike.com** on 2011-10-28 at 07:07 PM_
---
May I suggest these signatures:
class Iterators {
&nbsp;&nbsp;&nbsp;&nbsp;public static &lt;T> Iterator&lt;T> interleave( Iterable&lt;Iterator&lt;T> ) { ... }
&nbsp;&nbsp;&nbsp;&nbsp;public static &lt;T> Iterator&lt;Iterator&lt;T>> transpose( Iterable&lt;Iterator&lt;T> ) { ... }
}
I think 'transpose' would be a better name for the functionality originally asked for in this issue. An Iterable&lt;Iterator&lt;T> can be seen as a jagged, sparse matrix and the name 'transpose' suggests that the result is another matrix, just with rows and columns swapped.
That leaves the name 'interleave' free for the equivalent of Iterators.concat( Iterators.transpose( x ) ). Note that I am not sure that interleave should be implemented that way (I have an implementation and think that it shouldn't) it just illustrates the relationship between the two methods.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=677#c14) posted by **j...@nwsnet.de** on 2011-10-29 at 06:40 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=677#c15) posted by **fry@google.com** on 2011-12-10 at 04:14 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Collect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=677#c16) posted by **wasserman.louis** on 2012-02-12 at 05:39 PM_
---
Related: http://stackoverflow.com/q/9200080/869736 .
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=677#c17) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=677#c18) posted by **wasserman.louis** on 2012-02-23 at 07:27 PM_
---
Do I understand correctly that this issue is now basically about transpose?  Issue 203 pretty conclusively eliminated the possibility of Pair.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=677#c19) posted by **wasserman.louis** on 2012-03-07 at 12:17 AM_
---
How do we feel about interleave?  I'm not sure how I feel about transpose, but interleave is simple and has broader utility.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=677#c20) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=677#c21) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=677#c22) posted by **car...@medallia.com** on 2012-12-26 at 08:55 PM_
---
We needed this functionality for creating test data
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=677#c23) posted by **kgilmer** on 2014-01-26 at 01:28 AM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=677#c24) posted by **kgilmer** on 2014-03-06 at 10:32 PM_
---
FWIW my implementation is available here under the MIT-style license: https://github.com/iheartradio/interleaver
Note that it's possible to get this functionality using ArrayTable and Tables.transpose() (and then filtering out nulls); it's just a little awkward as you may need to invent row and column keys you don't care about.
I think we had gotten about 70% of the way through discussing `forEachPair`. Maybe @kevinb9n remembers the status. Thanks for the reminder on `forEachPair`... it should be coming soon.
Did I close this issue?  It's not clear why I would have done that.  Must have been accidental. This issue is covering ~3 different things now:
- `interleave`
- `zip` ([coming](http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/Streams.html#zip-java.util.stream.Stream-java.util.stream.Stream-java.util.function.BiFunction-) in 22.0)
- `forEachPair` (also [coming](http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/Streams.html#forEachPair-java.util.stream.Stream-java.util.stream.Stream-java.util.function.BiConsumer-) in 22.0)  _[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=675) created by **jerome.lacoste** on 2011-08-05 at 01:05 PM_
---
E.g. for Iterables:
```
private static <T> boolean none(Iterable<T> iterable, Predicate<T> predicate) {
return ! any(iterable, predicate);
}
```
It's purely cosmetic.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=675#c1) posted by **kevinb@google.com** on 2011-08-16 at 03:48 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=675#c2) posted by **wasserman.louis** on 2011-11-07 at 07:37 PM_
---
Personally, I don't think the added method/Javadoc clutter is worth the zero characters saved (!) and the negligible readability increase (!any, read as "not any," is fairly intuitive).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=675#c3) posted by **fry@google.com** on 2011-12-10 at 04:13 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Collect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=675#c4) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=675#c5) posted by **wasserman.louis** on 2012-05-01 at 02:47 PM_
---
_Issue #983 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=675#c6) posted by **phwendler** on 2012-05-01 at 02:52 PM_
---
Is Iterables.none going to be added?
If not, please consider the case for FluentIterable.noneMatch separately, as I think there are valid reasons to add the latter even if the former addition is rejected (that's why I added a new issue).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=675#c7) posted by **cpovirk@google.com** on 2012-05-01 at 02:55 PM_
---
I agree that the merged issue 983 has the stronger case -- partially because the standard for readability is higher for FluentIterable (being fluent and all) but also because the "!" may be separated very far from the "noneMatch" by other chained calls.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=675#c8) posted by **kevinb@google.com** on 2012-05-01 at 09:51 PM_
---
Ha: with CharMatcher it was the exact opposite! We had matchesNoneOf() from the start, but only realized the readability gains of matchesAnyOf() around 8.0.
I believe the same arguments apply here and I would vote for adding it to FluentIterable at least.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=675#c9) posted by **wasserman.louis** on 2012-05-01 at 10:16 PM_
---
I think I'm convinced that it's a good idea for FluentIterable, and that the arguments against it for Iterables are trumped by the intended fluent-ness of FluentIterable.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=675#c10) posted by **jerome.lacoste** on 2012-05-02 at 08:13 AM_
---
(original reporter)
> zero characters saved
not for "! any" :)
> !any, read as "not any," is fairly intuitive
not necessarily as intuitive as none for all non native English speakers or less mathematical inclined people.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=675#c11) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=675#c12) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=672) created by **fry@google.com** on 2011-07-28 at 05:30 PM_
---
The Primitives class itself could use
&nbsp;static int bits(Class clazz)
&nbsp;static int bytes(Class clazz)
which would throw on a class that isn't a JDK primitive wrapper.
FWIW, see http://stackoverflow.com/questions/6766343/best-practice-for-getting-datatype-sizesizeof-in-java/6772163#6772163 for what motivated me to write.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=672#c1) posted by **kevinb@google.com** on 2011-07-28 at 08:35 PM_
---
The question is who would use it and why?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=672#c2) posted by **esta...@comcast.net** on 2011-07-28 at 11:02 PM_
---
> > who would use it and why?
It might be used by anyone who needs to rapidly hard-allocate space for primitives and needs to do it in a generic way - possibly driven by reflection, for instance.  While nio makes this less frequently needed, with Byte/Char/...*Buffer, et al, it's still sometimes necessary - for instance, when byte-ordering is important.  It's possible that this kind of low-level code is either too rare or outside the Guava "sweet spot" - it was just a thought!
If it does seem worth doing, I'd extend the original suggestion to handle the "dummy" classes returned by reflection for unwrapped primitives, as well as the wrappers - both "long.class" and "Long.class".
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=672#c3) posted by **fry@google.com** on 2011-12-10 at 04:13 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Primitives`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=672#c4) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=672#c5) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=672#c6) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=670) created by **cow...@bbs.darktech.org** on 2011-07-26 at 02:32 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=670#c1) posted by **fry@google.com** on 2011-07-28 at 05:36 PM_
---
How much mileage could you get out of simply using int? What are the edge cases this would leave uncovered?
---
**Status:** `Triaged`
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=670#c2) posted by **cow...@bbs.darktech.org** on 2011-08-08 at 06:34 PM_
---
You can't always use an int. In my case, I'm given a ByteBuffer full of bytes read from a serial port. I need to read a 16-bit unsigned short from the buffer. The only two methods available to me are ByteBuffer.getShort() and ByteBuffer.get(byte[]).
If I had UnsignedShorts I'd simply invoke: UnsignedShorts.toInt(ByteBuffer.getShort())
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=670#c3) posted by **cow...@bbs.darktech.org** on 2011-08-08 at 07:13 PM_
---
Here is a quick attempt at transforming UnsignedBytes to UnsignedShorts. I replaced "byte" by "short" and 127 with 65535, etc.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=670#c4) posted by **cow...@bbs.darktech.org** on 2011-09-09 at 02:16 PM_
---
I've been using the proposed patch for over a month now without any problems. My only complaint is that there doesn't seem to be a way to suppress this compiler error:
com/google/common/primitives/UnsignedShorts.java:[24,15] Unsafe is internal proprietary API and may be removed in a future release
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=670#c5) posted by **wasserman.louis** on 2011-09-29 at 10:08 PM_
---
We're providing support for unsigned ints and longs, but shorts...I'm not sure they're used enough to be worth it.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=670#c6) posted by **cow...@bbs.darktech.org** on 2011-09-30 at 03:51 AM_
---
Our company uses CRC-16 for embedded devices we develop. If you Google "CRC-16" you will find that it brings up marginally less hits than "CRC-32" so I think it's fair to say that it's a fairly common use-case (at least in the embedded world). Besides, if you're already adding unsigned byte, int, and long support you might as well add unsigned short support for completeness sake. And there's also the fact that I've already provided a patch ;)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=670#c7) posted by **wasserman.louis** on 2011-10-17 at 05:30 AM_
---
That said, I think Kevin supports this, which is good enough for me.
I wrote my own patch (I totally forgot yours was there, I'm afraid) and sent it for Kevin's review (at http://codereview.appspot.com/5271042/), which is consistent with UnsignedInteger, etc.  (In particular, it respects the wrapper type/view primitives as unsigned distinction.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=670#c8) posted by **wasserman.louis** on 2011-10-20 at 08:36 PM_
---
_Issue #717 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=670#c9) posted by **fry@google.com** on 2011-12-10 at 04:12 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Primitives`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=670#c10) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=670#c11) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=670#c12) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
Sounds like this hasn't gotten any love from @lowasser et al. I'm going to close it since it doesn't seem like we have enough expected usage.  _[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=660) created by **bald2b** on 2011-07-13 at 12:32 PM_
---
May be necessary to add some static methods for parsing numbers from string without catching NumberFormatException like
bool Int32.TryParse(String, out int) in C#?
Like so:
&nbsp;&nbsp;&nbsp;&nbsp;public static int tryParse(String s, int defaultValue) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int result = defaultValue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(s==null) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return result;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
```
try {
result = Integer.parseInt(s);
} catch (NumberFormatException ex) {}
return result;
}
```
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=660#c1) posted by **kevinb@google.com** on 2011-07-13 at 06:20 PM_
---
Provisionally I think this will be a good idea; I have to dig up some old benchmarks that showed the try-catch to be really, really bad.
---
**Status:** `Accepted`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=660#c2) posted by **kevinb@google.com** on 2011-07-13 at 07:00 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=660#c3) posted by **cpovirk@google.com** on 2011-07-13 at 07:42 PM_
---
_(No comment entered for this change.)_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=660#c4) posted by **kevinb@google.com** on 2011-10-05 at 05:02 AM_
---
_(No comment entered for this change.)_
---
**Labels:** `Milestone-Release11`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=660#c5) posted by **wasserman.louis** on 2011-11-15 at 03:52 PM_
---
_(No comment entered for this change.)_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=660#c6) posted by **kak@google.com** on 2011-11-15 at 07:09 PM_
---
@Louis: Before you spend too much time on this, we've already got this done internally (and are just working out licensing issues).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=660#c7) posted by **wasserman.louis** on 2011-11-15 at 07:36 PM_
---
Excellent!  (I had not actually started, so thanks for letting me know.)
---
**Status:** `Started`
**Owner:** ---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=660#c8) posted by **fry@google.com** on 2011-11-16 at 07:38 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Milestone-Release11`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=660#c9) posted by **fry@google.com** on 2011-12-10 at 04:12 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Primitives`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=660#c10) posted by **amertum** on 2012-01-11 at 11:57 AM_
---
I am surprised that this method returns null as you clearly don't like null. Should this method takes a default fallback value instead ?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=660#c11) posted by **wasserman.louis** on 2012-01-11 at 05:17 PM_
---
I think the point of tryParse is that you use it instead of Integer.parseInt when you _don't_ want an exception?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=660#c12) posted by **amertum** on 2012-01-11 at 07:10 PM_
---
I think it is closer to Integer.valueOf(String) which return an Integer and not an int.
If I summarize, we have :
- java Integer.valueOf(String) returns Integer may throws NumberFormatException
- java Integer.parseInt(String) returns int may throws NumberFormatException
We are missing :
Or should we use Objects.firstNonNull(Ints.tryParse(String), Integer.valueOf(5)).intValue() ? Which I think is less readable than Ints.tryValueOf(String, 5)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=660#c13) posted by **wasserman.louis** on 2012-01-11 at 07:27 PM_
---
Well, with auto-boxing and unboxing, that becomes int x = Objects.firstNonNull(Ints.tryParse(String), 5), which isn't that bad.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=660#c14) posted by **bald2b** on 2012-01-11 at 10:01 PM_
---
&nbsp;int Ints.tryParse(String, defaultValue) is very good idea!
Because:
- clearly and simple
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=660#c15) posted by **amertum** on 2012-01-11 at 11:29 PM_
---
Well, I don't really like auto-boxing. It hides to much things even NPE and outside the int autobox cache, the performance are not very good. If people use tryParse to avoid NumberFormatException, it is outside IHM. In IHM I can understand that it is difficult to replace the bad number with some default. It is better to ignore or ask again the user. But outside this case, we just don't want or cannot re-ask for an input, so the must fall to default. It is then a pretty common case when using 3rd party services. Maybe you can check your code base to verify the recurrence of this.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=660#c17) posted by **ipremraj11** on 2012-01-12 at 09:48 AM_
---
int Ints.tryParse(String, defaultValue) makes more sense than returning null.
I'm pretty sure that this option must have considered before and got rejected, right?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=660#c18) posted by **j...@nwsnet.de** on 2012-01-12 at 10:20 AM_
---
I think `Optional`&nbsp;is way better than providing an overload with a default argument. It is meant as a replacement for `null`, so let's use it for that.
```
int value = Ints.tryParse(someStringToParse).or(42);
```
One method to use and document. And it's clear what the default value is (compared to a second argument that requires a look into the docs; it could be the radix!).
Sadly, the "try" prefix was used here, which I connected with a return type of `Optional`&nbsp;after seeing `Iterables.tryFind`&nbsp;(whereas `Iterables.find`&nbsp;is the ["legacy"] non-optional version).
As `Ints.tryParse`&nbsp;is @Beta, I _strongly_ suggest changing the return type to `Optional<Integer>`&nbsp;ASAP.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=660#c19) posted by **amertum** on 2012-01-12 at 10:59 AM_
---
@yo...: good point to optional use here, but I still don't like the auto-boxing :-/
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=660#c20) posted by **cpovirk@google.com** on 2012-01-12 at 08:53 PM_
---
- If I type "10000p," I should probably get a failure, rather than a default of 0 or -1 or whatever.  (If 0 and -1 are invalid inputs, of course, this would be fine, but there are also cases in which any integer is a valid input.)
We couldn't quite stomach the extra wrapping of Optional&lt;Integer> (especially when boxing ints in the range [-128, 127] is likely to be cheap), though it would be a good conceptual fit.  We're still feeling our way around when it comes to the use of Optional.
If it is any consolation, tryParse, boxing and all, is significantly faster than a try-catch block in our microbenchmarks, and once some pending changes land, it will be even better.  (We considered returning a |long| instead of an |Integer| in order to make things faster still, but this seemed error prone.)
---
**Status:** `Fixed`
**Labels:** `Milestone-Release11`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=660#c21) posted by **theaspect** on 2013-09-17 at 03:53 AM_
---
I don't see this tryParse with default value. Did it lost during commit?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=660#c22) posted by **cgdecker@google.com** on 2013-09-17 at 04:03 AM_
---
We didn't provide a method taking a default value for reasons Chris outlines in #20 above. Ints.tryParse(String) accomplishes the goal of avoiding an exception while not introducing ambiguity between a specific integer value and a result indicating that the string couldn't be parsed.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=651) created by **pholser** on 2011-07-07 at 01:52 AM_
---
A possible implementation:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new UnsupportedOperationException();
&nbsp;&nbsp;&nbsp;&nbsp;}
```
public static String replaceAll(String target, String regex, Function<MatchResult, String> operation) {
StringBuffer result = new StringBuffer(target.length() * 3 / 2);
Pattern pattern = Pattern.compile(regex);
Matcher matcher = pattern.matcher(target);
while (matcher.find()) {
MatchResult match = matcher.toMatchResult();
String replacement = operation.apply(match);
if (!replacement.equals(match.group()))
matcher.appendReplacement(result, replacement);
}
matcher.appendTail(result);
return result.toString();
}
```
}
I'm ambivalent about whether to make the type of 'regex' a Pattern or leave it as a String for the method to compile().
Motivation: To allow global replacement of matches with the result of a function of the match result, a la C#'s Regex.Replace(string, MatchEvaluator). PITA to roll the appendReplacement/appendTail bit by hand.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=651#c1) posted by **kevinb@google.com** on 2011-07-13 at 06:32 PM_
---
Something almost exactly like this exists in the internal Google codebase; it was one of the first libraries I contributed ~5 years ago and almost no one has ever used it. :)
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=651#c2) posted by **kevinb@google.com** on 2011-07-13 at 07:00 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=651#c3) posted by **cpovirk@google.com** on 2011-07-13 at 07:42 PM_
---
_(No comment entered for this change.)_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=651#c4) posted by **fry@google.com** on 2011-12-10 at 04:12 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Base`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=651#c5) posted by **cpovirk@google.com** on 2012-02-16 at 07:17 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=651#c6) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=651#c7) posted by **wasserman.louis** on 2012-02-16 at 07:19 PM_
---
_Issue #383 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=651#c8) posted by **kevinb@google.com** on 2012-02-16 at 07:20 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=651#c9) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=651#c10) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=643) created by **evohunz** on 2011-06-10 at 06:17 PM_
---
Could you please add some utility functions for ranged primitives?
Something in the form:
// Ints#bounded(int min, int value, int max) -> int
Ints.bounded(10, 15, 20); // = 15
Ints.bounded(10, 5, 20); // = 10
Ints.bounded(10, 25, 20); // = 20
// Ints#inRange(int min, int value, int max) -> boolean
Precondition.assertArgument(Ints.inRange(0, percentageArg, 100));
// Precondition#assertInRange(int min, int value, int max) -> int, throws IllegalArgument...
percentageField = Precondition.assertInRange(0, percentageArg, 100);
Thanks in advance,
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=643#c1) posted by **cpovirk@google.com** on 2011-06-22 at 06:17 PM_
---
- Release 10 will have a Range class with a contains(e) method to handle your inRange use case.
- Range doesn't have a bounded(e) method, but when we look at converting some of our internal code to use Range, we'll see whether this comes up often.
- We're not sure what's going to happen with additional Preconditions methods, but if we expand our offerings there, we'll consider this one.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=643#c2) posted by **j...@nwsnet.de** on 2011-06-22 at 10:48 PM_
---
AFAIR, the new Range class doesn't even provide a convenient way to create (primitive) number ranges at all. Am I mistaken/did that change?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=643#c3) posted by **kevinb@google.com** on 2011-06-27 at 02:28 PM_
---
That's right, you use the wrapper types.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=643#c4) posted by **kevinb@google.com** on 2011-07-13 at 06:46 PM_
---
Original requester: while we won't have specific support for _primitives_, your ideas may be sensible for Ranges of any kind; would you kindly file them separately for us, then close this?
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=643#c5) posted by **kevinb@google.com** on 2011-07-13 at 07:00 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=643#c6) posted by **fry@google.com** on 2011-12-10 at 04:11 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Primitives`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=643#c7) posted by **wasserman.louis** on 2011-12-25 at 04:44 PM_
---
This issue now basically becomes:
1) range.bounded(x) // returns the closest value in the range, to the specified input.  Probably requires a DiscreteDomain.
2) and 3) are answered by Preconditions.checkArgument(Ranges.closed(0, 100).contains(argument)).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=643#c8) posted by **wasserman.louis** on 2012-01-10 at 04:18 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Package-Primitives`, `Package-Collect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=643#c9) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=643#c10) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=643#c11) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=643#c12) posted by **andreou@google.com** on 2013-01-02 at 10:49 PM_
---
My team also has needed this, like 3 times the last couple of weeks. But for doubles :-/
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=643#c13) posted by **jysjys1486** on 2014-02-09 at 01:25 AM_
---
ah; this is the clamp problem: Math.max(minValue, Math.min(a, maxValue))
class Ordering {
&nbsp;&nbsp;// rearranges cmpr to fit order, origin <= limit
&nbsp;&nbsp;public static &lt;A> Comparator&lt;A> rearrange(Comparator<? super A> cmpr, A origin, A limit) {
&nbsp;&nbsp;&nbsp;&nbsp;return rearrange(cmpr,cmpr.compare(origin,limit));
&nbsp;&nbsp;}
&nbsp;&nbsp;// rearranges cmpr to fit order with respect to compare value
&nbsp;&nbsp;public static &lt;A> Comparator&lt;A> rearrange(Comparator<? super A> cmpr, int cmp) {
&nbsp;&nbsp;&nbsp;&nbsp;return (Comparator&lt;A>)(cmp <= 0 ? cmpr : reverseRder(cmpr));
&nbsp;&nbsp;}
&nbsp;&nbsp;public static &lt;A> A clamp(A origin, A limit, A value, Comparator<? super A> cmpr) {
&nbsp;&nbsp;&nbsp;&nbsp;final Comparator<? super A> rearranged = rearrange(cmpr, origin, limit);
&nbsp;&nbsp;&nbsp;&nbsp;// cmpr is fit to order, origin <= limit
```
return rearranged.compare(origin, value) >= 0 ? origin :
rearranged.compare(limit,value) <= 0 ? limit : value;
```
&nbsp;&nbsp;}
}
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=642) created by **bfreis** on 2011-06-06 at 07:25 PM_
---
It would be great to have a class implementing InputStream that would read it's data from a String, obviously without instantiating a byte[] from the String, as discussed in http://stackoverflow.com/questions/837703/how-can-i-get-a-java-io-inputstream-from-a-java-lang-string
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=642#c1) posted by **kevinb@google.com** on 2011-07-13 at 06:49 PM_
---
I think there are a variety of use cases for "streaming" charset encoding/decoding and we will think more on the best way to handle these in the libraries, thanks.
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=642#c2) posted by **kevinb@google.com** on 2011-07-13 at 07:00 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=642#c3) posted by **fry@google.com** on 2011-12-10 at 04:11 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-IO`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=642#c4) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=642#c5) posted by **wasserman.louis** on 2012-04-18 at 02:52 PM_
---
I am experimenting on a Reader-to-InputStream tool based on streaming Charset encoding.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=642#c6) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=642#c7) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=631) created by **morten.hattesen** on 2011-05-22 at 09:34 PM_
---
Quite frequently, I have to add a duration as parameter to a method, and feel forced to add two parameters: java.util.concurrent.TimeUnit  as well as an int/long to hold the duration. And every time it makes me cringe, and consider whether to just add the int, and name it durationMillis (or such).
Firstly, a duration should not be broken into two discrete components, secondly the API shouldn't force a time unit upon the API user.
What Im looking for is an immutable TimeUnit and and long all rolled into one Duration class, that would have suitable:
- equals()
- Comparable.compareTo()
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c1) posted by **gscerbak** on 2011-05-22 at 09:41 PM_
---
Isn't there something like that in JodaTime or in the JSR for Time aimed for JDK 8?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c2) posted by **kurt.kluever** on 2011-05-22 at 10:22 PM_
---
+1 for using JodaTime's Duration class: http://joda-time.sourceforge.net/apidocs/org/joda/time/Duration.html
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c3) posted by **morten.hattesen** on 2011-05-23 at 07:13 AM_
---
-1 for Joda Time Duration class.
The Joda Time is aligned with ISO-8601 as part of a complete set of APIs to
support time and calendar.
TimeUnit, on the other hand, being part of java.util.concurrent, is aimed at
thread/processor/timer related APIs.
What I'm looking for is a way of avoiding a split-up of duration and unit
when calling java.util.concurrent API, and Joda Time provides none of that:
&nbsp;&nbsp;&nbsp;1. Joda Time Duration does NOT contain/convert to TimeUnit based units.
&nbsp;&nbsp;&nbsp;2. Joda Time Duration does not support sub-milliseconds granularity
A TimeUnit/long wrapper would be lightweight and general purpose, which fits
/Morten
---
I would agree with Morten, especially since I saw the classes like Stopwatch making their first steps in the trunk of Guava. This Stopwatch would be the first class to benefit directly from this wrapper.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c5) posted by **kevinb@google.com** on 2011-05-24 at 04:23 AM_
---
I agree with this need. I call this ShortDuration. My current incarnation can only handle durations of up to 100 days, but has picosecond precision. I need it for caliper.
---
**Status:** `Accepted`
**Labels:** -`Type-Defect`, `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c6) posted by **kevinb@google.com** on 2011-07-13 at 06:18 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c7) posted by **kevinb@google.com** on 2011-07-13 at 06:57 PM_
---
This is reasonably likely for release 11 (since I selfishly need it in caliper.) :)
---
**Status:** `Accepted`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c8) posted by **cgdecker** on 2011-11-22 at 03:33 AM_
---
Is this still likely for 11? It would definitely be nice to have.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c9) posted by **kevinb9n** on 2011-11-29 at 03:47 PM_
---
Sadly, no, it's gotten terribly delayed.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c10) posted by **wasserman.louis** on 2011-12-06 at 04:16 PM_
---
I would be happy to take this on...is there any particular complicating factor?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c11) posted by **jim.andreou** on 2011-12-07 at 01:59 AM_
---
Hmm. Surely we want this? It would have been nice if this was in java.util.concurrent from day 1, but now there is a sea of signatures accepting this pair.
And it's not too clear to me that there is a usability win here, (5L, SECONDS) compared to (ShortDuration.of(5L, SECONDS)). The former is "convention" by now anyway.
Nor does this help with the implementation of time-related classes; we canonicalize any user-supplied duration to the same unit, and a long is enough for that. No idea why caliper needs pico precision - perhaps expecting to invoking a trial and finishing... in under 3 machine cycles? :-)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c12) posted by **morten.hattesen** on 2011-12-07 at 08:30 AM_
---
The one use case that probably is the most convincing would be the situation where you would like to add a duration as a constant.
Examples:
Current Example 1 (split unit and value):
&nbsp;&nbsp;private static final long TIMEOUT_VALUE = 2L; // you need to consult the TIMEOUT_UNIT before determining value
&nbsp;&nbsp;private static final TimeUnit TIMEOUT_UNIT = TimeUnit.MINUTES;
&nbsp;&nbsp;...
&nbsp;&nbsp;logger.debug("Waiting for " + TIMEOUT_VALUE + " " + TIMEOUT_UNIT); // tedious
&nbsp;&nbsp;future.get(TIMEOUT_VALUE, TIMEOUT_UNIT);
Current Example 2 (split unit and value):
&nbsp;&nbsp;private static final TIMEOUT_MILLISECONDS = 120000L; // difficult to decipher as 2 minutes, what if someone needs sub-millisecond value
&nbsp;&nbsp;...
&nbsp;&nbsp;logger.debug("Waiting for " + TIMEOUT_MILLISECONDS + " milliseconds");
&nbsp;&nbsp;future.get(TIMEOUT_MILLISECONDS, TimeUnit.MILLISECONDS);
Current Example 3 (split unit and value):
&nbsp;&nbsp;private static final TIMEOUT_NANOSECONDS = TimeUnit.NANOSECONDS.convert(2, TimeUnit.MINUTES); // Semantically clearer
&nbsp;&nbsp;...
&nbsp;&nbsp;logger.debug("Waiting for " + TIMEOUT_NANOSECONDS + " nanoseconds"); // difficult to decipher value in log
&nbsp;&nbsp;future.get(TIMEOUT_NANOSECONDS, TimeUnit.NANOSECONDS);
ShortDuration Example 3 (using ShortDuration):
&nbsp;&nbsp;private static final ShortDuration TIMEOUT = ShortDuration.minutes(2); // would look good with static import, too
&nbsp;&nbsp;...
&nbsp;&nbsp;logger.debug("Waiting for " + TIMEOUT);
&nbsp;&nbsp;future.get(TIMEOUT);
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c13) posted by **kevinb@google.com** on 2011-12-09 at 11:32 PM_
---
Here's what it needs:
1. Instead of having a hard limit of 100 days and picosecond granularity, can't it just return a different, BigDecimal-based class when it's outside that range? For some reason I didn't think of that.  If we do this it needs another name though, and I'm a little queasy about using Duration which Joda-Time already has.
2. I never wrote tests unless you count the supercrappy ones that you can find in the caliper source tree right now.
I'll email you the code I left off with.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c14) posted by **kevinb@google.com** on 2011-12-09 at 11:40 PM_
---
"Jim" :-) -- Caliper just wants to be able to compute and report a value like "13.17 ns" -- so there's sub-nanosecond precision there.
Many of the good uses for this object have to do with its ability to display as and parse from a String, e.g. check out CacheBuilderSpec.
I do _not_ propose that we should automatically start replacing (long, TimeUnit) signatures with (ShortDuration) ones as general practice. Sometimes that might be useful, sometimes not.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c15) posted by **fry@google.com** on 2011-12-10 at 04:11 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Concurrent`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c16) posted by **morten.hattesen** on 2011-12-16 at 09:55 PM_
---
Kevin: "I do _not_ propose that we should automatically start replacing (long, TimeUnit) signatures with (ShortDuration) ones as general practice."
May I ask, why not?
I cannot think of a single case where a split duration (long, TimeUnit)...
doSomething(2, TimeUnit.SECONDS);
... would would be preferable to a single ShortDuration ...
doSomething(ShortDuration.seconds(2));
Except, of course, where java.util.concurrent interfaces mandates the split duration parameters.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c17) posted by **kevinb@google.com** on 2012-01-28 at 07:24 AM_
---
I just mean that I don't personally advocate going and doing all that. That's not my intent in introducing this new class -- that it should become "the new way to do (long,TimeUnit) everywhere."
That doesn't mean I'm arguing _against_ it though.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c18) posted by **kevinb@google.com** on 2012-03-02 at 08:38 PM_
---
---
**Labels:** -`Package-Concurrent`, `Package-Base`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c19) posted by **wasserman.louis** on 2012-03-02 at 08:45 PM_
---
WaitDuration?  It's typically used for "how long do you wait"...
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c20) posted by **stephan202** on 2012-03-02 at 08:54 PM_
---
TimeSpan?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c21) posted by **cgdecker** on 2012-03-02 at 08:55 PM_
---
I think both ElapsedTime and WaitDuration are too specific to possible uses of the class rather than describing just what it is. "ElapsedTime" implies that it's an amount of time that has already elapsed and was measured, while "WaitDuration" implies that the duration is an amount of time to wait. While each of those is applicable to some use cases for such a class, the class encompasses both use cases and more and should probably have a name that reflects that.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c22) posted by **michael.hixson** on 2012-03-06 at 10:40 PM_
---
I'm curious about a couple things.  Sorry if these are dumb questions.
1. Will this type have methods like get(TimeUnit) or get[Nanos/Micros/etc]() and if so, what would their return types be?  long, Number, BigInteger, or BigDecimal?
2. I think I understand why/how producers of this type would use it, but how would consumers typically use it?  Say you've been passed one of these and it represents a timeout.  Would you periodically construct a new one based on the current time and compare it to the timeout?  e.g.
&nbsp;&nbsp;if (ShortDuration.seconds(elapsedSeconds).isGreaterThan(timeout)) {
&nbsp;&nbsp;&nbsp;&nbsp;// fail
&nbsp;&nbsp;}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c23) posted by **jmsignup** on 2012-05-04 at 09:19 PM_
---
How about TimeInterval or TimeSpan as given in Comment 20 as a name?  I agree with Comment 21 that WaitDuration and ElapsedTime both hint at how the class is used while TimeInterval or TimeSpan describe the class without implying its use.
Also, may I suggest a fromString method?  I know strings are overused, but a fromString method could make reading in a time interval from say a config file very convenient.  The format of accepted strings could be something like a long followed by any whitespace followed by a TimeUnit (supporting either singular or plural units).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c24) posted by **kevinb@google.com** on 2012-05-06 at 03:29 PM_
---
Yup, TimeSpan is the current choice, and one of the best things about the code we have so far is its fromString() functionality (which we can drop into, for example, CacheBuilderSpec).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c25) posted by **kevinb@google.com** on 2012-05-17 at 11:16 AM_
---
_(No comment entered for this change.)_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c26) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c27) posted by **brianfromoregon** on 2012-08-07 at 08:20 PM_
---
I'd be interested to hear folks' requirements for this class that aren't satisfied by the current rev of JSR-310's Duration.
https://github.com/ThreeTen/threeten/blob/master/src/main/java/javax/time/Duration.java
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c28) posted by **brianfromoregon** on 2012-08-07 at 08:28 PM_
---
Oh well there's one in #14, representing sub-nano precision.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c29) posted by **morten.hattesen** on 2012-08-08 at 11:26 AM_
---
I guess the design would include:
- Immutable implementation
- Static factory methods for creating instance of common TimeUnits, e.g. TimeSpan.minute(2).
- Static factory methods for creating instance from TimeUnit/long combination, e.g. of(Timeunit unit, long duration)
- Static factory methods for creating instance from a readable String representation, as in CacheBuilderSpec
- Conversions to long: asLong(TimeUnit unit)
- implements Comparable&lt;TimeSpan>
- Possible convenience instance methods isGreaterThan(TimeSpan timeSpan) (... etc), providing more readable client code than using Comparable.compareTo()
- Instance method toString(TimeUnit unit) providing string representation using unit (integer?)
- Should toString() normalize the reported TimeUnit, or should the TimeSpan retain information about which time unit was used to create it, and use that unit when using toString.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c30) posted by **ogregoire** on 2012-08-08 at 11:42 AM_
---
I suggest putting the addition in the implementation. Maybe in a TimeSpans class?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c31) posted by **cpovirk@google.com** on 2012-08-08 at 05:48 PM_
---
> Is anyone actively working on this issue.
Kevin, is this still on your plate?
Here's the existing Caliper ShortDuration class:
http://code.google.com/p/caliper/source/browse/caliper/src/main/java/com/google/caliper/util/ShortDuration.java
---
**Labels:** -`Priority-Medium`
**CC:** kevinb@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c32) posted by **kevinb@google.com** on 2012-08-08 at 06:22 PM_
---
Well, it would be a cause for celebration if it gets onto someone else's plate.  I could give a 5-minute rundown of what aspects of ShortDuration I do and don't think are actually worthy to carry over.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c33) posted by **argaul** on 2012-09-26 at 12:21 AM_
---
As a data point, my employer makes good use of a simplified interface (100+ call sites):
public final class TimeValue {
&nbsp;&nbsp;&nbsp;&nbsp;private final long time;
&nbsp;&nbsp;&nbsp;&nbsp;private final TimeUnit timeUnit;
```
private TimeValue(final long time, final TimeUnit timeUnit);
public long getTime();
public TimeUnit getTimeUnit();
public String toString();
public static TimeValue nanoseconds(final long value);
public static TimeValue microseconds(final long value);
public static TimeValue milliseconds(final long value);
public static TimeValue seconds(final long value);
public static TimeValue minutes(final long value);
public static TimeValue hours(final long value);
public static TimeValue days(final long value);
public long toMillis();
public long toSeconds();
public long toMinutes();
public long toHours();
```
}
I tried implementing arithmetic and comparison but these did not simplify call sites much.  Note that there is not enough precision to represent all values, e.g., TimeValue.days(1000).toNanos() > Long.MAX_VALUE, although this has not been an issue in practice.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c34) posted by **ogregoire** on 2014-03-31 at 01:28 PM_
---
Any news on this? Or should we stick to the new Java 8 java.time.Duration class?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c35) posted by **electrum** on 2014-04-25 at 10:42 PM_
---
We have a Duration class: https://github.com/airlift/airlift/blob/master/units/src/main/java/io/airlift/units/Duration.java
It is very useful for human-readable config files: Duration.valueOf("5m")
And a related class, DataSize: https://github.com/airlift/airlift/blob/master/units/src/main/java/io/airlift/units/DataSize.java
Sounds like we might want to provide a `Converter<TimeUnit, ChronoUnit>` in a future Java8-compatible Guava release. Filed that as https://github.com/google/guava/issues/2443
The picosecond argument is possibly useful for things like caliper, but in general, it's way more precision then anybody needs (or anybody can really measure).
I think it's unlikely that we'll add this anytime soon given `java.time.Duration`.  _[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=626) created by **darthtrevino** on 2011-05-17 at 09:22 PM_
---
public void iDontDeclareCheckedExceptions() {
&nbsp;&nbsp;&nbsp;&nbsp;try
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;object.doSomethingThatThrows();
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;catch(IOException ex)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Throwables.propagateSneakily(ex);
&nbsp;&nbsp;&nbsp;&nbsp;}
}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=626#c1) posted by **finnw1** on 2011-05-18 at 03:04 AM_
---
I must admit I sometimes do this myself.
There are four fairly well-known ways to achieve this:
1. Wrap it in a constructor and invoke it using reflection (this works on all Oracle VMs but might be considered a bug and not replicated on other VMs)
2. Use a library method not built with javac but with another tool such as jasmin (it's only javac that enforces checked exceptions, not the VM.)
3. Thread.stop()
4. An unchecked generic cast from &lt;X extends Throwable> to RuntimeException (this is nearly equivalent to #2 but can be done with only javac.)
```
Thread.currentThread().stop(ex);
```
This generates a warning, but that's a good thing, right?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=626#c2) posted by **finnw1** on 2011-05-18 at 03:09 AM_
---
The generic way (in case you are worried that Thread.stop() will be removed from the classpath in future:)
public static RuntimeException propagateSneakily(Throwable ex) {
&nbsp;&nbsp;&nbsp;&nbsp;return unsafeCastAndRethrow(ex);
}
@SuppressWarnings("Unchecked")
private static &lt;X extends Throwable>X unsafeCastAndRethrow(Throwable ex) throws X {
&nbsp;&nbsp;&nbsp;&nbsp;throw (X) ex;
}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=626#c3) posted by **kevinb9n** on 2011-05-18 at 03:14 AM_
---
Why in the world would you want to do this?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=626#c4) posted by **darthtrevino** on 2011-05-18 at 05:00 PM_
---
Checked exceptions were an interesting idea when Java was getting on its feet, but APIs don't often use them well.  Wrapping exceptions in RuntimeException just obscures the exception, and in the case of multithreading specific code, it can bypass important cancellation signals.  Most checked exceptions just clutter APIs and client code needlessly, and it simplifies design greatly to just propagate them to a general exception handler.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=626#c5) posted by **kevinb@google.com** on 2011-05-19 at 02:00 AM_
---
It's a fact that _many_ APIs use them very poorly, but it doesn't diminish their value when used properly (which many also do). Guava definitely doesn't wish to support such an anti-Java feature.
---
**Status:** `WorkingAsIntended`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=626#c6) posted by **cgdecker** on 2012-02-21 at 04:11 PM_
---
_Issue #903 has been merged into this issue._
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=592) created by **t...@duh.org** on 2011-04-05 at 05:34 PM_
---
NIO already provides a way to convert {Readable,Writable}ByteChannel instances to {Input,Output}Stream, respectively. It does not provide that sort of interface for a ByteBuffer, however.
The attached classes provide a way to view a ByteBuffer as an InputStream or OutputStream, including an implementation of the DataInput and DataOutput interfaces respectively (which make use of the ByteBuffer's own endianness setting). This makes it possible to link legacy code using any of these interfaces to a NIO ByteBuffer.
This becomes even more useful in the context of a MappedByteBuffer, which functions as a ByteBuffer rather than a Channel. Via the classes contributed here, it's possible for the same java.io-compatible code to work on "plain" streams or memory-mapped files regardless of backing implementation. To add to this capability, ByteBufferDataOutputStream.flush() will call MappedByteBuffer.force() if the buffer is mapped.
Technical note: The weird-looking convertException() bit exists to make these classes function more like the java.io equivalents. It catches the (unchecked) Buffer*Exception instances, and throws a checked EOFException instead. For simplicity, and to avoid synchronization overhead, NullPointerException -- which should only happen when the internal "buf" has been nulled out by close() -- is also caught and converted to a ClosedChannelException, a subclass of IOException.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=592#c1) posted by **t...@duh.org** on 2011-04-05 at 05:39 PM_
---
Revision: added Preconditions.checkNotNull() at the top of all methods accepting a reference argument, so that those don't get converted to ClosedChannelException.
I did not add this to the ctors, as that's arguably a valid use case (the stream is closed already at constructor time). That check could be added if desired, though.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=592#c2) posted by **kevinb@google.com** on 2011-07-13 at 07:43 PM_
---
I don't know if the ByteBufferDataInputStream is the way we want to address the problem or not, but we do want to make sure that _something_ is covering this use case properly.
---
**Status:** `Accepted`
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=592#c3) posted by **cpovirk@google.com** on 2011-07-13 at 07:43 PM_
---
_(No comment entered for this change.)_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=592#c4) posted by **t...@duh.org** on 2011-07-13 at 07:50 PM_
---
It seemed to be the natural place to offer this conversion. Channels are already convertible to stream via the static methods in java.nio.channel.Channels, but there's no prefab way to convert a buffer (such as would be obtained when mmap'ing a file).
Nobody is required to use the DataInput/DataOutput interfaces; I added them as a logical-to-me extension, because a ByteBuffer already has notions of endianness and data conversion built-in. They function fine as bare {Input,Output}Stream instances too.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=592#c5) posted by **fry@google.com** on 2011-12-10 at 04:04 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-IO`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=592#c6) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=592#c7) posted by **michael.deardeuff** on 2012-12-24 at 11:48 AM_
---
A few things about the implementation of the InputStream as given.
First, it is trivial to support the mark/reset/markSupported operations. Might as well throw them in.
Also, it might be nice to have the classes extend Buffered{Input,Output}Stream. Because they are in fact buffered.
There is an issue with those pesky superclass fields, though. If you don't mind extra ints/null references hanging around, then you can use this constructor:
```
ByteBufferInputStream(ByteBuffer buffer) {
super(null, 1);
this.buf = buffer;
super.buf = null;
}
```
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=592#c8) posted by **t...@duh.org** on 2012-12-24 at 09:17 PM_
---
As for mark/reset, I actually have no idea why I didn't implement those. Probably an oversight. Yes, they can be implemented.
On subclassing: I chose Data{Input,Output}Stream as those classes are well-known to a lot of third party code, and are actually used in the method signatures of some methods. (Sure, in theory they should use generics, e.g. <? extends DataInput & Flushable & Closeable>, but that's still not commonplace. Plenty of code directly requests a Data*Stream.)
I've yet to see any code that actually cares about seeing a BufferedInputStream or BufferedOutputStream -- these seem only useful as add-in layers to implement buffering under the hood, not as a capability-marking class. I think it would be a bit of a mistake to extend those, since the superclass's buffering isn't going to be used anyway.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=592#c9) posted by **michael.deardeuff** on 2012-12-24 at 10:07 PM_
---
I'm not sold on the BufferedInputStream either, I was just implementing a ByteSource based on an array of ByteBuffers and had just coded up BufferInputStream when I noticed ByteSource has openBufferedStream(). I was just throwing the idea out there.
I think good use would check for markSupported() instead of instanceof BufferedInputStream; but then again, ByteSource doesn't.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=592#c10) posted by **pjulien** on 2013-02-02 at 04:54 PM_
---
I find it strange that these classes don't do more to manager the mark, e.g., I would have expected the byte buffer to be exactly as it was, mark and all, after closing the input stream
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=583) created by **ogregoire** on 2011-03-29 at 05:30 PM_
---
As shortcut for the following code:
&nbsp;&nbsp;List&lt;String> tmp = [Arrays.]asList("b","a","c");
&nbsp;&nbsp;[Collections.]sort(tmp);
&nbsp;&nbsp;String result = tmp.get(0);
Please add the following methods in the class Lists:
&nbsp;&nbsp;&lt;T extends Comparable<? super T>> List&lt;T> Lists.sorted(List&lt;T>);
&nbsp;&nbsp;&lt;T> List&lt;T> Lists.sorted(List&lt;T>, Comparator<? super T>);
So the code can be called like this:
&nbsp;&nbsp;String result = [Lists.]sorted([Arrays.]asList("b","a","c")).get(0);
The use case is the same as for Lists.reverse(List&lt;T>). The implementation shouldn't return a view but rather a new List object for obvious reasons of performances and contract with the List#add methods.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=583#c2) posted by **cgdecker** on 2011-03-29 at 06:34 PM_
---
Ordering already provides methods that do what you want: Ordering.sortedCopy(Iterable) and Ordering.immutableSortedCopy(Iterable).
---
Nice! I wasn't aware at all of this. Thanks.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=583#c4) posted by **cgdecker** on 2011-03-29 at 07:13 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Invalid`
---
Hi all,
Thought' that I could suggest it as an enhancement !
Cheers,
JB
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=578#c1) posted by **SeanPFloyd** on 2011-03-22 at 04:38 PM_
---
I agree to this need, but it should be handled by a dedicated class (like MapMaker, Joiner, Splitter etc.)
Attached is my own quick attempt at implementing one.
Usage:
Iterable&lt;File> files =
&nbsp;&nbsp;&nbsp;&nbsp;DirectoryScanner
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.forDirectory(baseDir)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.maxScanDepth(3)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.restrictDirectories(directoryPredicate)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.restrictFiles(directoryPredicate)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.getFiles();
---
Very good proposal.
---
i'm also interested in such a feature
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=578#c4) posted by **jim.andreou** on 2011-03-23 at 02:30 AM_
---
+1 on having the functionality, -1 on providing this directly. If someones wants to implement this, do chat with me first, or ping after a couple of months to handle this in a more general way (the curious can see the tiny 'object explorer' thing in my memory measuring tool for what I think the right abstraction is)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=578#c5) posted by **SeanPFloyd** on 2011-03-23 at 08:11 AM_
---
Jim, I wasn't suggest for you to _use_ this implementation. It was a quick hack I put together in 20 minutes. But it might serve as a reference of what the API looks like.
What I thought of when I heard this proposal is this Commons / IO method:
FileUtils.listFiles(directory, fileFilter, dirFilter)
http://commons.apache.org/io/apidocs/org/apache/commons/io/FileUtils.html#listFiles%28java.io.File%2C%20org.apache.commons.io.filefilter.IOFileFilter%2C%20org.apache.commons.io.filefilter.IOFileFilter%29
And I just wanted to make clear that we can do better than that.
---
Please don't limit the filtering to predicates. The interfaces FileFilter and FilenameFilter should be used prior to predicates since they are part of the Java Standard Edition.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=578#c7) posted by **SeanPFloyd** on 2011-03-23 at 08:51 AM_
---
I agree, but the solution I'd see is converting these to Predicates through Helper methods:
public static Predicate&lt;File> Predicates.forFileFilter(FileFilter filter)
public static Predicate&lt;File> Predicates.forFileNameFilter(FileNameFilter filter)
---
I agree with that: I just don't want these two interfaces be left over.
But I'm a bit concerned about the fact that Predicate would be the main interface here. Since the class File has already three methods (list(FilenameFilter), listFiles(FileFilter) and listFiles(FilenameFilter)) that are potentially already optimal for this usage. It will surely depend on the implementation of the JVM people use. These methods already exist and I think it should be overkill to reimplement the filtering with Predicates.
In short, I would to the opposite: create a FileFilter from a Predicate instead of the opposite.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=578#c9) posted by **jim.andreou** on 2011-03-23 at 04:53 PM_
---
Just to be clear, Sean, I hadn't looked your actual code, I was just opposed to offering traversal support /specifically/ for file systems.
There are many things to tweak so as to control a traversal, so I'm fairly confident that such functionality can be nicely captured as a just a particular case of something more general and useful, that's all.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=578#c10) posted by **kevinb@google.com** on 2011-03-24 at 06:22 AM_
---
There may be some relationship between the generalization you have in mind and what will satisfy https://github.com/google/guava/issues/174
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=578#c11) posted by **cpovirk@google.com** on 2011-07-13 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=578#c12) posted by **kevinb@google.com** on 2011-07-16 at 07:53 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=578#c13) posted by **fry@google.com** on 2011-12-10 at 04:03 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-IO`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=578#c14) posted by **wasserman.louis** on 2011-12-22 at 06:14 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=578#c15) posted by **SeanPFloyd** on 2011-12-25 at 01:29 PM_
---
I agree that symlinks make results unpredictable, but I don't agree with your conclusion (just as I don't agree with the scheduled removal of the Files.deleteRecursively and Files.deleteDirectoryContents methods.
I'd suggest to either: add proper documentation saying that the use of symlinks makes results unpredictable or add an ignoreSymLinks() preference and implement it seperately for the different platforms.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=578#c16) posted by **wasserman.louis** on 2011-12-25 at 04:29 PM_
---
I don't think there's anything in Guava that's platform-specific, and I continue to believe that the correct place to implement methods with platform-specific implementations is in some other library.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=578#c17) posted by **SeanPFloyd** on 2011-12-27 at 08:08 AM_
---
Fair enough, but I guess it would also suffice to leave a hook that another library (or individual developer) good plug into. I just don't think symlinks are a show-stopper. I don't think they are likely to occur in the folders this type of method would be used upon. It's not like I'm going to walk over /usr/bin .
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=578#c18) posted by **wasserman.louis** on 2011-12-28 at 06:13 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=578#c19) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=578#c20) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=578#c21) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=578#c22) posted by **pierre.labatut** on 2013-02-19 at 07:35 PM_
---
Since 1.7, the method walkFileTree of java.nio.file.Files ease the file & directory recursion.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=538) created by **kuaw26** on 2011-02-01 at 09:07 AM_
---
Would it be useful to add method:
public static &lt;T> T checkInstanceOf(Object reference, Class&lt;T> clazz) ?
a draft implementation:
public static &lt;T> T checkInstanceOf(Object reference, Class&lt;T> clazz){
&nbsp;if (!clazz.isInstance(reference)){
&nbsp;&nbsp;&nbsp;throw new ClassCastException();
&nbsp;}
&nbsp;return (T) reference;
}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=538#c1) posted by **neveue** on 2011-02-01 at 09:35 AM_
---
This is an interesting idea, but I think I never encountered the need for this. I'm interested to see an example use-case.
If a method only accepts "Foo" instances, I'd rather specify "Foo" in the signature, than accept a superclass and then check it. For example, I'd do:
void doSomething(List&lt;String> names) {
&nbsp;&nbsp;&nbsp;&nbsp;...
}
instead of
void doSomething(Collection&lt;String> names) {
&nbsp;&nbsp;&nbsp;checkInstanceOf(names, List.class);
&nbsp;&nbsp;&nbsp;...
}
Moreover, what about simply casting your object to T?
T referenceAsT = (T) reference;
It should automatically throw a ClassCastException if reference is not a T.
Maybe this could be useful when using reflection, though, when you are playing with "Methods", "Fields", and "Objects" directly, and want to check the type of such an object?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=538#c2) posted by **SeanPFloyd** on 2011-02-01 at 09:44 AM_
---
a) Casting is not equivalent. Casting will succeed when reference is null, Class.isInstance(reference) won't
b) It would be nicer to have a way to create formatted messages (as in the other Preconditions.x methods) than just throw a plain ClassCastException
c) because of type erasure, you sometimes don't know what you are dealing with when iterating over a data structure that's beyond your reach. I'd say this method would be very useful
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=538#c3) posted by **kuaw26** on 2011-02-01 at 09:54 AM_
---
For comment 1:
&nbsp;T referenceAsT = (T) reference;
but without annoying compiler warnings.
For comment 2:
as for a) b) and c) I completely agree.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=538#c4) posted by **neveue** on 2011-02-01 at 10:27 AM_
---
Good points. About b), it indeed would be nice to have nicely formatted messages.
By the way, my previous comment wasn't meant as a critic of the idea, I merely wanted to poke at it to understand it better. I'm happy I did, because you both gave insightful arguments / explanations :)
---
Class.cast() does the same thing (except it accepts null instances):
http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Class.html#cast(java.lang.Object)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=538#c6) posted by **bill.claypool** on 2011-02-01 at 05:28 PM_
---
As the annoying compiler warnings point out, casting to T is really only casting to the erasure of T.
Class.cast() mostly does the job.  But, it would be nice to have options to format an error message for the ClassCasException
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=538#c7) posted by **kevinb@google.com** on 2011-02-01 at 08:02 PM_
---
I don't like this idea.  An type-based precondition is already relative uncommon, then by the time you peel off the ones where the signature can be changed, or where a plain cast or Class.cast() is sufficient. there's not enough left.  This is an example of a method that would be used poorly far more often than used well.
---
**Status:** `WontFix`
**Labels:** `Type-Enhancement`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=521) created by **ogregoire** on 2011-01-12 at 11:58 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c1) posted by **kevinb@google.com** on 2011-01-13 at 01:25 AM_
---
We have a few uses for such a thing ourselves.  I started work on it once upon a time...
The name has always bugged me, though; "PartitionedSet" would seem to make more sense, but perhaps it's not worth going against the grain.
---
**Status:** `Accepted`
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c2) posted by **kevinb@google.com** on 2011-01-13 at 01:26 AM_
---
for the general interest: http://en.wikipedia.org/wiki/Disjoint-set_data_structure
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c3) posted by **wasserman.louis** on 2011-02-02 at 06:05 PM_
---
Any thoughts on what the API would look like?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c4) posted by **kevinb@google.com** on 2011-02-03 at 03:07 AM_
---
Disturbingly, I can't find my work on it anywhere.
Rough thoughts were:  DisjointSet&lt;E> interface containing the read-only methods.  One to view as a Set&lt;Set&lt;E>>, one to view the union Set&lt;E>, one to get the Set&lt;E> for a given E, one to view the entire thing as an Equivalence&lt;E>.
Mutable implementation, with or without specialized mutable interface. Method to declare e1 and e2 to be equivalent.  This is where the traditional union-find algorithm ends up.  Method to remove an E?
Immutable implementation.  Presumably backed by an ImmutableMap&lt;E, ImmutableSet&lt;E>>.
Various other methods I forgot.
Louis, if you are up for taking a crack at this, this is something I feel we could push through.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c5) posted by **wasserman.louis** on 2011-02-03 at 03:45 AM_
---
Absolutely up for it -- after my paper due Friday. ;)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c9) posted by **jim.andreou** on 2011-02-03 at 06:20 AM_
---
The key thing in this structure is that the _elements_ point to the set, instead of the opposite way which is what we typically mean when we say "a Set". So, please, don't subtype Set, don't try to shoehorn an iterator or a remove operation. The result would be negating the strengths of the structure; the quintessential union/find is best.
After some digging, here's an implementation of my own, some 4-5 years old.
http://code.google.com/p/flexigraph/source/browse/trunk/src/gr/forth/ics/util/Partition.java
(It seems I took the time to implement the best find() version, instead of the easiest, which is nice; single-pass, instead of two-pass or recursive).
Let me make a concrete recommendation now though. I'll call the structure "Partition", below:
&nbsp;\* Don't make Partition point to a user value. This is completely unnecessary; the user will associate each value to its Partition even if Partition offers the other direction. (I made this mistake)
&nbsp;\* Following from the above: don't introduce a type parameter. This artificially makes it difficult to merge Partition&lt;S> and Partition&lt;T>. (I made this mistake too).
&nbsp;\* No "iterator" or anything that requires the set to point to the elements, which defeats the purpose of the structure.
&nbsp;\* Expose the equivalence relation only. A singleton Equivalence&lt;Partition> is a fine way to do it. Having Equivalence&lt;Partition<?>> would look ugly, for a reason (because the type parameter isn't needed!). Don't expose the representative of an element (btw, remember to do the self-loop trick to denote the root). Other than the equivalence, just singleton() and merge() need to be offered.
&nbsp;\* Finally, consider offering this method:
public static &lt;E> Equivalence&lt;E> partition(Function&lt;E, Partition> partitioner);
Which maps the equivalence relation of Partition to an equivalence relation of referrers of Partition.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c10) posted by **kevinb@google.com** on 2011-02-03 at 02:02 PM_
---
Ok, let's make sure we sort out what to do before you dig into this, Louis.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c11) posted by **wasserman.louis** on 2011-02-05 at 12:32 AM_
---
I like some ideas from your approach, Jim, but I think it can be made considerably simpler.  Specifically, I think the attached is pretty much your approach taken to its logical conclusion -- to remove the elements from the picture entirely, and treat the partitions as objects in their own right.  The effect of p1.combine(p2) is to guarantee that p1.equals(p2) is true for all time, while maintaining that equals() is an equivalence relation.  Elements don't come into it at all.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c12) posted by **jim.andreou** on 2011-02-05 at 01:01 AM_
---
I like the simplicity of equals(), heck, that's supposed to model an equivalence class, and Equivalences already play nice with it, so it's fine.
About find(), I see you implemented the recursive one for simplicity (or laziness :)) - but we ought to provide the fastest.
Now, about the rank... I'm on the fence. I think without the rank optimization, one gets polylogarithmic complexity, instead of the inverse Ackerman (together with path compression). The rank itself "ought" to increase the memory overhead (I'm certain that some people more knowledgeable than me asserted that), but I'm not so sure, it must be VM dependant. On the VMs I'm usually on, there would be no observable difference to me, due to aligning effects (the existence of the Partition pointer would bump the cost of the object from 8 bytes to 16 bytes, so in this case, the second field is free).
But without that field, it would be possible to pull off a concurrent, non-blocking implementation (just via compare-and-swap on the pointer), which would be nice, because this structure does play well with partitioning things to parallelize, then merge the sets to compute some global result.
So, how about having an interface for this, making an sequential implementation w/ the rank, and leave the door open for a non-blocking one without the rank.
(PS: I'm _not_ going to argue with you about who is more addicted to graph algorithms :P )
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c13) posted by **wasserman.louis** on 2011-02-05 at 01:08 AM_
---
Well, yes, I was going for a quick-and-dirty implementation, so I was somewhat lazy.
I'm inclined to do the sequential implementation for the moment, with the lovely inverse-Ackermann complexity.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c14) posted by **kevinb@google.com** on 2011-02-05 at 02:07 AM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c15) posted by **wasserman.louis** on 2011-02-05 at 05:06 AM_
---
Oh, yeah.  I went through several drafts of my first response that were along the lines of "You're on crack!  What a ridiculous data structure!"  Then it was like, oh man, that's actually not half bad.  Then it was like, but this could be so much simpler!  Bam!  Bam!  .equals()!
So yeah.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c16) posted by **jim.andreou** on 2011-02-05 at 05:19 AM_
---
Oh boy. How old is this guy? :)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c17) posted by **jim.andreou** on 2011-02-05 at 05:24 AM_
---
More seriously, let me back off that interface idea. Rethinking it, that would create ugly problems, like sequential.{merge,equals}(nonSequential); // oops
So lets just have a single concrete class; if we need the other, we create a second, unrelated class.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c18) posted by **wasserman.louis** on 2011-02-05 at 05:50 AM_
---
I think that's definitely the way to go, and I think a sequential version is the right default.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c19) posted by **jim.andreou** on 2011-02-14 at 06:31 PM_
---
Just so I don't have this in my mind: Louis? Is this something we should expect you give a full contribution of? (I mean, the final product, optimized, documented -especially hashCode() and equals()-, some tests). Is it something you're already working on?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c20) posted by **wasserman.louis** on 2011-02-14 at 06:39 PM_
---
Yeah, I'm doing the whole shebang.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c21) posted by **jim.andreou** on 2011-02-14 at 06:43 PM_
---
Ok, great, thanks!
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c22) posted by **wasserman.louis** on 2011-02-14 at 09:44 PM_
---
Observation: I think this should go in base, not collect, since it's really not a collection in any way.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c23) posted by **ray.a.conner** on 2011-05-04 at 12:10 AM_
---
I'm late to this discussion, so please forgive me. If I'm grokking the gist of the approach (referring to Wasserman's posted impl):
- the user is responsible for associating user-provided objects with Partition instances
- Partitions never disappear, but are merged as "flatly" as possible
I really like the simplicity, but I have some questions about how one would use it.
Wouldn't algorithms which start with a state of one object per partition be somewhat inefficient? By that, I mean that the user of the library will be keeping around a HashMap< E, Partition >, and there will permanently be just as many Partitions as there are elements. Although I suppose if the user didn't do it, then the Partition impl would have to. So maybe this is just shifting the burden, with the possibility that the user won't care and it wouldn't be needed at all.
Having run a connected components algorithm, I can easily determine whether any two vertices are in the same connected component (via the Equivalence). But how can I determine how many components there are? Or, how can I list the vertices in each component? Do you need to expose the find() method to allow answering questions like this, or is the intent that the user should be keeping track of this kind of information? Decrementing the number of components every time a combine() is successful is easy enough, and Sets.union() or similar handles the latter question (with the user keeping track of all the Sets), but this does seem like exactly the kind of thing someone might want to use Partition for.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c24) posted by **jim.andreou** on 2011-05-04 at 12:28 AM_
---
"- the user is responsible for associating user-provided objects with Partition instances"
Yes. Note that a more efficient alternative to Map&lt;E, Partition>, is a Partition field in E itself.
"- Partitions never disappear, but are merged as "flatly" as possible"
One object per partition is the minimum you can get.
"But how can I determine how many components there are?"
A good start would be Multimaps#index(Iterable&lt;E>, Function&lt;E, Partition>), which gives a Multimap&lt;Partition, E>. But to turn it into a more useful Multimap&lt;E, E>, one would require the inverse relation, Map&lt;Partition, E>, which leads to rather verbose code (trust me, I tried it).
My original (internal) proposal included a "classify" method which for the same arguments returned Multimap&lt;E, E> instead, directly. It's still up in the air (seconds ago I re-suggested that, with the return type being Map&lt;E, Set&lt;E>>, lets see what happens to that). That would answer all your following questions; exposing find() is still unnecessary.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c25) posted by **ray.a.conner** on 2011-05-04 at 06:31 PM_
---
Maybe a contrived example would help, and you can tell me where my thinking has gone wrong. I start out with a big graph...
&nbsp;&nbsp;Map< Node, Partition > map = Maps.newHashMap();
&nbsp;&nbsp;for( node : nodes ) {
&nbsp;&nbsp;&nbsp;&nbsp;map.put( node, Partition.newPartition() );
&nbsp;&nbsp;}
&nbsp;&nbsp;int size = nodes.size();
&nbsp;&nbsp;for( edge : edges ) {
&nbsp;&nbsp;&nbsp;&nbsp;Partition pTail = map.get( edge.tail );
&nbsp;&nbsp;&nbsp;&nbsp;Partition pHead = map.get( edge.head );
&nbsp;&nbsp;&nbsp;&nbsp;if( pTail.combine( pHead ) ) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size--;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if( size == 1 ) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;}
The calculation is done, and the Partition Equivalence would work. However, there are still 1M Partition instances, one per node. From the information I have, I cannot construct a Function&lt;E, Partition> that is "normalized". So Multimaps.index() wouldn't be useful.
This edit reduces the number of Partitions in use by one allowing pHead to be gc'd, but only if pHead happens to only contain the one node.
```
if( pTail.combine( pHead ) ) {
map.put( edge.head, pTail );
size--;
}
```
As near as I can tell, the only way to keep track of this information is to maintain an actual Map&lt;Partition, Set&lt;E>> during the algorithm, in addition to the existing Map. A single graph data structure would be simpler, and then I would effectively be performing the exact same function as Partition, and I don't need the class at all.
What am I missing?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c26) posted by **jim.andreou** on 2011-05-04 at 06:59 PM_
---
#index you would get a Multimap&lt;Partition, E>. Just iterate over the
&lt;Partition, E> entries, and nominate the key Partition as the "canonical"
one for the value E. Seems good enough.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c27) posted by **wasserman.louis** on 2011-05-04 at 08:33 PM_
---
Not true!  After a combine() is performed, the only way to tell the
Partition instances apart is object identity, which Multimaps.index()
equal as far as Object.equals() and Object.hashCode() are concerned, which
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c28) posted by **jim.andreou** on 2011-05-04 at 08:53 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c29) posted by **wasserman.louis** on 2011-05-04 at 09:45 PM_
---
Sorry, I tried to respond in an email instead of in the comment interface.
> The calculation is done, and the Partition Equivalence would work. However, there
> are still 1M Partition instances, one per node. From the information I have, I
> cannot construct a Function&lt;E, Partition> that is "normalized". So Multimaps.index()
> wouldn't be useful.
Not true!  After a combine() is performed, the only way to tell the
Partition instances apart is object identity, which Multimaps.index()
equal as far as Object.equals() and Object.hashCode() are concerned, which
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c30) posted by **ray.a.conner** on 2011-05-06 at 09:57 PM_
---
[slaps forehead, utters "Doh!", reaches for beer...]
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c31) posted by **finnw1** on 2011-05-21 at 12:03 PM_
---
@jim.andreou, does it matter if there is a race between two threads comparing/updating a rank?  If I understand the code correctly this would result in a suboptimal tree, but still a valid one.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c32) posted by **jim.andreou** on 2011-05-21 at 06:20 PM_
---
Yes, it matters, eg two threads might try to link a partition to different partitions, and one would overwrite the other. I think the only way this could be used in a multithreaded environment would be grabbing a common lock. (Even locking the partitions themselves, say in Ordering.arbitrary() order, wouldn't help).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c35) posted by **finnw1** on 2011-05-22 at 12:14 PM_
---
As far as I can see the only way to get a _corrupted_ tree (as opposed to a suboptimal one) is that two nodes should have a common ancestor but do not (e.g. because thread1 sets a.parent = b and thread2 (not seeing thread1's change) sets a.parent = c.
There is no danger of spurious merges, because if two partitions are _not_ meant to be merged then the merge method never sees pointers to both at once.
All you need to ensure is that before a.merge(b) returns, a and b have a common ancestor (and that all threads agree on the fact.)  Anything else is just optimization.  I cannot see any way in which this constraint could be violated that would not be solved by a compareAndSet() loop.
E.g. this should work:
```
public ConcurrentPartition merge(ConcurrentPartition other) {
ConcurrentPartition root1, root2;
while ((root1 = other.find()) != (root2 = find())) {
if (root1.rank < root2.rank) {
if (root1.parentRef.compareAndSet(root1, root2)) {
return root2;
}
} else if (root1.rank > root2.rank) {
if (root2.parentRef.compareAndSet(root2, root1)) {
return root1;
}
} else {
if (root2.parentRef.compareAndSet(root2, root1)) {
root1.rank++;
return root1;
}
}
}
return root2;
}
```
The worst that could happen is that each thread only performs only one call to merge() and no thread sees any other thread's updates to rank (easily simulated by making rank ThreadLocal).  Then you end up with a singly-linked list, but that would still give you the right answers for equals() and hashCode() and the path compression would still get a chance to reduce the depth.
You might need global synchronization at a higher level, to ensure that all merge()s have completed before you start performing comparisons with equals() and hashCode(), but that does not affect the implementation of merge().
Feel free to prove me wrong.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c36) posted by **jim.andreou** on 2011-05-22 at 02:54 PM_
---
A.rank is 1
B.rank is 0
C.rank is 1
Thread1:
merge(A, B) - computes that B.parent should point to A
Thread2:
merge(B, C) - computes that B.parent should point to C
If these ran concurrently, each thread is free to write its own opinion,  ignoring (perhaps without even seeing, due to lack of visibility guarantees) the other thread's update. Eg the 'second' thread would update B thinking it the root, instead of updating the new root.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c37) posted by **finnw1** on 2011-05-22 at 03:19 PM_
---
No problem there with the compareAndSet implementation:
Thread1 computes that B.parent should point to A (and the previous root is B)
Thread2 computes that B.parent should point to C (and the previous root is B)
Now the following are executed in some order:
Thread1: B.parentRef.compareAndSet(B, A)
Thread2: B.parentRef.compareAndSet(B, C)
At least one will fail, and will go round the loop again & find the new root
e.g. if Thread2 was attempting merge(B, C) it will now attempt merge(A, C) instead.
The result will be
&nbsp;&nbsp;A
&nbsp;/ \
B   C
which is correct.
A.rank == B.rank
Thread1: merge(A, B)
Thread2: merge(B, A)
Thread 1 determines that A.parent should point to B, while thread 2 determines that B.parent should point to A.
Now both threads perform their updates, creating a cycle (compareAndSet does not prevent this, since the pointers are not synchronized with each other.)
But even then, the find() loop terminates (thanks to the compression step.)  I have tested this with random interleaving (i.e. inserting sleeps with random delays) and still always got the right answer so far.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c38) posted by **finnw1** on 2011-05-22 at 09:22 PM_
---
OK I found a way to break that method.
First create a cycle [A->B->C->D->A], e.g. by calling {A.merge(B); B.merge(C); C.merge(D); D.merge(A)} in parallel.
Now call A.find() in thread1 and D.find() in thread2.
Here is one possible execution order:
- thread1 observes A->B->C
- thread2 observes D->A->B
- thread1 sets A.parent = C
- thread1 observes B->C->D
- thread1 sets B.parent = D
- thread1 observes C->D->A
- thread1 sets C.parent = A
- thread2 sets D.parent = B
- thread2 observes A->C->A
- thread2 sets A.parent = A and returns A
- thread1 observes D->B->D
- thread1 sets D.parent = D and returns D
Now the cycle has been split into two (C->A and B->D)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c39) posted by **jim.andreou** on 2011-05-22 at 09:38 PM_
---
By the way, I'd like to share a curious usability issue of this class (well, not exactly of _this_ class, as you'll see, but a wart nevertheless).
If a user object doesn't share the same lifecycle as its Partition object, then the user has to fallback into using a Map&lt;E, Partition>. Now, if the user can iterate over all the elements beforehand, he can eagerly initialize that Map with Partition objects. But it is seems common to have a list of edges (element pairs) instead to be merged, so the user that ends up with Map&lt;E, Partition>, will probably end up with lazily initializing that map too. The problem is we don't have a concise way to have a default-value'd map - MapMaker#makeComputingMap easily takes 5-6 lines. And the return type is not that satisfying: ConcurrentMap&lt;E, Partition>. I played with the idea of adding a method "newPartitionMap()", returning a (computing) Map&lt;E, Partition>, internally using the MapMaker with concurrencyLevel==1. But Map&lt;E, Partition> is a poor type for a computing map. Function&lt;E, Partition> (Kevin's suggestion) is more correct, in that it doesn't expose a surprizing Map, but then if you want to iterate in the end your E's (e.g. to see which partition they ended up into), code using a Function&lt;E, Partition> would also be quite verbose, since an extra Set&lt;E> would be needed.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c40) posted by **wasserman.louis** on 2011-05-22 at 11:56 PM_
---
I'm leaning towards being conservative here: I think almost all of this discussion is getting ahead of itself.  I think the current version of Partition fulfills most users' needs -- I've actually used this version for several things myself without any further changes -- and I'm very strongly inclined to wait until actual use cases occur in the wild for concurrency support, lazy initialization, etc.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c41) posted by **jim.andreou** on 2011-05-23 at 12:21 AM_
---
Completely agreed about concurrency. Regarding lazy initialization, well, I've seen it in three cases "in the wild" (of googleland), and at least two really required it (think an incoming stream of edges, of an unknown set of nodes - you don't want to buffer/iterate the edges twice to discover/initialize the nodes).
Some people don't like the verbosity of user code doing a lazy initializing Map&lt;E, Partition> either manually or by a computing map. Hard to satisfy this crowd. In my opinion, judging Partition negatively on this respect is rather unfair, since it isn't its job to offer a proper lazy-initializing map (imagine if any class that might be used together with a lazy-initializing map, was hard-coding one of these internally to shave few lines of user code - that would be solving the same problem again and again, all over the place, instead of once). Yet, there is some other internal union/find implementation that does just that (basically something like a Partition&lt;E> together with a lazy initializing LinkedHashMap&lt;E, Partition&lt;E>>), and people prefer the resulting user code, effectively rewarding a bad data structure design choice :) such is life some times...
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c42) posted by **kevinb@google.com** on 2011-07-13 at 06:18 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c43) posted by **kevinb@google.com** on 2011-07-16 at 08:32 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Accepted`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c44) posted by **wasserman.louis** on 2011-09-20 at 06:50 PM_
---
We never got around to this.  Should it be revived?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c45) posted by **andreou@google.com** on 2011-09-20 at 06:57 PM_
---
Oh. I had a dormant change list, forgot about it. The main problem in user code is not related to Partition - it's that it's just Too Hard (TM) to make a default value map in java (even with guava, unless that default value happens to be a collection).
To take some verbosity out, basically, I meant to introduce a Partition#newPartitionMap(), returning a Map&lt;E, Partition>, where the user wouldn't do the little "is the key in the map? if not, add this entry" dance.
Kevin had proposed a Function&lt;E, Partition> instead of default-valued map, but this wouldn't do since a common operation turned out to be accessing the keySet() of said map.
It was a complicated discussion, taking more time than it was worth it, so I put it in the backburner.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c46) posted by **kevinb@google.com** on 2011-09-21 at 01:35 AM_
---
I actually have some thoughts on this I will try to pull together soon.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c47) posted by **fry@google.com** on 2011-12-10 at 04:01 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Collect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c48) posted by **wasserman.louis** on 2012-01-17 at 03:54 AM_
---
Proposal:
Introduce a Partitioning&lt;E> class that manages the "default-valued map" details internally.  If we want to support key-set iteration, we can do that, but manage it internally.
Partitioning&lt;E> supports Partition getPartition(E e), which returns an object of the Partition type we'd been playing with earlier.  Additionally supports inSamePart(E, e), and all of that.
For the moment, Partitioning locks the whole thing when doing any mutations.  If we design a more effective concurrent version of the structure later, then that's great, but we guarantee thread-safety now (with a qualifier about performance) and try to optimize later.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c49) posted by **wasserman.louis** on 2012-01-17 at 04:34 AM_
---
For reference: Wikipedia links to http://citeseer.ist.psu.edu/anderson94waitfree.html, "Wait-free Parallel Algorithms for the Union Find Problem."  It sounds, well, pretty much exactly like what we wanted?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c50) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c51) posted by **wasserman.louis** on 2012-06-14 at 10:21 PM_
---
To summarize: UnionFindEquivalence is an Equivalence&lt;Object> implementation that starts out equivalent to Equivalence.equals(), but allows you to merge equivalence classes.  Internally, it holds a Map&lt;Object, Partition> for objects that are in equivalence classes of size > 1.
No, it doesn't let you get the objects back out for the moment, but I've written a couple of algorithms using disjoint-set data structures and it's satisfied my needs there.  In a pinch, it could get retrofitted later for some of those operations, but this feels relatively neat and tidy, and addresses the use cases I'm aware of.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c52) posted by **thomas.andreas.jung** on 2012-06-15 at 07:07 AM_
---
Personally, I would prefer an immutable Equivalence created with a builder:
UnionFind equiv = UnionFindBuilder.builder().merge(a, b).merge(c, d).build();
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c53) posted by **wasserman.louis** on 2012-06-15 at 02:54 PM_
---
@thomas: For all of the applications I came across, such an equivalence would be of little use.  Union-find data structures need to be dynamic to serve their traditional applications.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c54) posted by **wasserman.louis** on 2012-06-15 at 02:55 PM_
---
Specific examples: Kruskal's algorithm is utterly pointless without a dynamic union-find structure, and several variations on it are equally pointless.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c55) posted by **thomas.andreas.jung** on 2012-06-16 at 07:30 PM_
---
Wouldn't
equiv = UnionFindEquivalence.create()
equiv.merge(a, b);
w = equiv.wrapp(a);
w.equals(equiv.wrapp(c)) -> false
equiv.merge(b, c);
w.equals(equiv.wrapp(c)) -> true
break the equals contract?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c56) posted by **wasserman.louis** on 2012-06-16 at 09:50 PM_
---
Well, the Object.equals() contract specifies
"It is consistent: for any non-null reference values x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified."
Of course, the last part is crucial: "provided no information used in equals comparisons on the objects is modified."
The doc for Equivalence isn't quite so specific, although it has allusions along the same lines, e.g. for hash: "...as long as x remains unchanged according to the definition of the equivalence."
Essentially, I'm suggesting that that exception apply here.  It remains the case that a non-dynamic version is _useless_ for the traditional applications of this data structure...and that it makes a lot of sense to model this as an equivalence relation rather than a Map&lt;E, Partition> or something along those lines.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=521#c57) posted by **thomas.andreas.jung** on 2012-06-18 at 06:46 AM_
---
Okay, I remembered a more strict version of the contract, i.e. I'd always implement equals in this way. One effect with a weaker implementation is that objects disappear from collections:
UnionFindEquivalence equiv = UnionFindEquivalence.create();
Wrapper&lt;Integer> wrap = equiv.wrap(1);
HashSet&lt;Wrapper&lt;Integer>> set = new HashSet&lt;Wrapper&lt;Integer>>();
set.add(wrap);
System.out.println(set.contains(wrap));  //true
equiv.merge(1, 2);
System.out.println(set.contains(wrap));  //false
You're right that an immutable version of a UnionFindEquivalence is useless (unless you find a practical persistent Union-find data structure).
We've been having some internal discussions on this topic recently, and with common.graph having been making a lot of progress recently, there's been more interest in sorting out graph-related things like this.
My two cents:
- The right name for this thing is "Partition": a partition of S is the correct mathematical term for a spanning set of disjoint subsets of S.
- "Union-Find" is the name of an algorithm that one can use to generate a partition;
- This object should provide the following capabilities:
- return the Set in the Partition that a specified element [in S] belongs to
- return a Collection of these (disjoint) Sets
Reference: https://en.wikipedia.org/wiki/Partition_of_a_set
I don't know that this is the API that we're going to end up with, but that's my current opinion for what it should look like.
@mozinrat Not yet, I'm afraid.  I still have this issue on my plate, but I haven't had the cycles to push it yet.  I'd like to get it resolved myself, as it would make it easier for us to release a couple of internal graph algorithm implementations.  _[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=508) created by **koppernickus** on 2010-12-28 at 09:36 AM_
---
When I checkout the source code (rev. 144) mvn clean install fails due to test compilation errors.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=508#c1) posted by **kevinb@google.com** on 2011-01-12 at 09:03 PM_
---
Is this something that someone out there could set up for us?
---
**Status:** `Accepted`
**Labels:** `Type-Task`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=508#c2) posted by **chris.shellenbarger** on 2011-02-08 at 09:29 PM_
---
I could set it up on TeamCity or Hudson if someone provides the box to run it on.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=508#c3) posted by **kevinb@google.com** on 2011-07-13 at 06:18 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=508#c4) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=508#c5) posted by **kevinb@google.com** on 2012-05-30 at 07:49 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Task`, `Type-Dev`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=508#c6) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=508#c7) posted by **kevinb@google.com** on 2012-06-22 at 06:57 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-General`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=508#c8) posted by **pradeepg26** on 2012-12-25 at 08:30 PM_
---
Any progress on this? I set up a build on travis-ci. It's not ideal since it's been set up with a fork of guava on github. But, you can track it at https://travis-ci.org/pradeepg26/guava
I think Travis is enough for this bug.  _[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=490) created by **Nerther** on 2010-12-03 at 02:00 AM_
---
Hello
I implement a retry tool which can retry task(wrapped in Callable) easily, whether it's valuable to be added in guava library?
Only 2 classes: Retry, RetryBuilder.
Example:
Retryer retryer = new RetryerBuilder()
&nbsp;&nbsp;&nbsp;.times(3)
&nbsp;&nbsp;&nbsp;.interval(10, SECONDS)
&nbsp;&nbsp;&nbsp;.when(timeout())
&nbsp;&nbsp;&nbsp;.build();
Response response = retryer.callWithRetry(new Callable&lt;Response>() {
&nbsp;&nbsp;&nbsp;public Response call() throws Exception {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return removeService.upload(request);
&nbsp;&nbsp;&nbsp;}
});
response.doSomething();
Retry condition:
private static Predicate&lt;Exception> timeout() {
&nbsp;&nbsp;&nbsp;return new Predicate&lt;Exception>() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public boolean apply(Exception exception) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (exception instanceof TimeoutException) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return exception.getMessage().startsWith("Retryable");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;};
}
Project url : http://code.google.com/p/google-guava-retryer/
All java sources & test has been attached.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=490#c1) posted by **Java2Enterprise** on 2010-12-03 at 02:14 AM_
---
retryer.retry is more concise than retryer.callWithRetry :)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=490#c2) posted by **Nerther** on 2010-12-03 at 02:28 AM_
---
I refer to the interface TimeLimiter of guava when design the signature, the usage and structure of which is similar to Retryer, the method is named callWithTimeout, it is simple and clear.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=490#c3) posted by **kevinb@google.com** on 2011-01-12 at 10:37 PM_
---
FYI, we are experimenting with one or two approaches internally at the moment.
---
**Status:** `Accepted`
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=490#c4) posted by **kevinb@google.com** on 2011-07-13 at 06:18 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=490#c5) posted by **kevinb@google.com** on 2011-07-16 at 08:32 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Accepted`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=490#c6) posted by **Nerther** on 2011-08-18 at 09:09 AM_
---
Update sources!
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=490#c7) posted by **cgdecker** on 2011-11-20 at 04:30 PM_
---
_Issue #797 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=490#c8) posted by **fry@google.com** on 2011-12-10 at 03:58 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Concurrent`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=490#c11) posted by **jnizet** on 2011-12-25 at 08:42 AM_
---
Sorry for the successive posts. My earlier design had serious issues, so I'm reposting it.
I had the same idea, and built a solution which is a bit more complex, but also more configurable. The differences are:
&nbsp;\- configurable stop strategy (number of times, delay, or custom)
&nbsp;\- configurable wait strategy (fixed delay, random delay, incrementing delay, or custom)
Usage example:
```
Retryer<Response> retryer =
RetryerBuilder.<Response>newBuilder()
.withStopStrategy(StopStrategies.stopAfterAttempt(4))
.withWaitStrategy(WaitStrategies.fixedWait(1L, TimeUnit.SECONDS))
.retryIfRuntimeException()
.retryIfExceptionOfType(IOException.class)
.retryIfResult(Predicates.<Response>isNull())
.build();
try {
return retryer.call(callable);
}
catch (ExecutionException e) {
// the call threw a checked exception which didn't cause a retry
// encapsulated in the execution exception
Throwables.propagateIfPossible(e.getCause(), SomeCheckedException.class);
throw new RuntimeException("unexpected", e.getCause());
}
catch (RetryException e) {
// the retry was aborted because the call didn't succeed
// it's also possible to get the last attempt result or exception
throw new RuntimeException("Call never succeeded", e);
}
```
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=490#c12) posted by **wasserman.louis** on 2011-12-25 at 12:42 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=490#c13) posted by **adrian.f.cole** on 2012-01-04 at 10:09 PM_
---
We are currently using this for years:
https://github.com/jclouds/jclouds/blob/master/core/src/main/java/org/jclouds/predicates/RetryablePredicate.java
https://github.com/jclouds/jclouds/blob/master/core/src/test/java/org/jclouds/predicates/RetryablePredicateTest.java
It has limitations including no support for non-trivial shapes (ex. wait initially 10 seconds, then increase period over time), and sometimes you want to receive both the boolean result as well the last result tested.  The latter functionality is sketched here:
https://github.com/jclouds/jclouds/blob/master/core/src/main/java/org/jclouds/predicates/Retryables.java
https://github.com/jclouds/jclouds/blob/master/core/src/test/java/org/jclouds/predicates/RetryablesTest.java
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=490#c14) posted by **adrian.f.cole** on 2012-01-04 at 10:11 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=490#c15) posted by **raymond.rishty** on 2012-01-18 at 09:09 PM_
---
It might be nice if the "Retryer" were a RetryingExecutorService and the response a ListenableFuture
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=490#c16) posted by **cpovirk@google.com** on 2012-01-18 at 09:19 PM_
---
FYI, internally, we have:
- RetryingCallable (similar to the original suggestion and comment 11)
- RetryingFuture (repeated calls to a Supplier&lt;Future>)
- Retry (bytecode magic to turn an object into a retrying proxy; unlikely to be open-sourced due to its dependencies)
- RetryingExecutor (still under review; similar to comment 15)
There is clearly demand, but there are a lot of possible approaches and a lot of work left to do, so I recommend using one of the existing solutions in the meantime.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=490#c17) posted by **adrian.f.cole** on 2012-05-15 at 06:33 AM_
---
Here's an addition to add the list, resulting from jclouds proliferation of LoadingCache :)
```
// deal with eventual consistency delay between bucket resources and their acls
CacheLoader<String, AccessControlList> loader = RetryingCacheLoaderDecorator.newDecorator()
.on(ResourceNotFoundException.class).exponentiallyBackoff()
.decorate(
new CacheLoader<String, AccessControlList>() {
public AccessControlList load(String bucketName) {
}
public String toString() {
}
});
```
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=490#c18) posted by **em...@soldal.org** on 2012-05-15 at 07:02 AM_
---
+1 for comment 11 and 17's approach. I'm not sure I like the particulars of the builder pattern though, I'd like to save/serialize the builder so I could use it later.
.withStopStrategy() and .withWaitStrategy() could probably have variants directly in the builder, although having the ability to wire in your own strategies is very useful.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=490#c19) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=490#c20) posted by **schnitzi** on 2013-02-04 at 05:15 AM_
---
http://grepcode.com/file/repo1.maven.org/maven2/org.springframework.batch/spring-batch-infrastructure/1.0.0.FINAL/org/springframework/batch/retry/ - one from the Spring framework
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=490#c21) posted by **toellrich** on 2013-05-03 at 06:15 AM_
---
There's also a .Net API called the transient fault handling application block which does the same thing:
http://msdn.microsoft.com/en-us/library/hh680905(v=pandp.50).aspx
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=490#c22) posted by **zolyfar...@yahoo.com** on 2013-05-11 at 12:43 AM_
---
I have implemented both approaches:
1) simple: http://code.google.com/p/spf4j/source/browse/trunk/src/main/java/org/spf4j/base/Callables.java
this implementation allows you to retry a callable based on Exception or returned result, and execute a callable before retry.
```
public static <T> T executeWithRetry(final Callable<T> what, final Callable<Boolean> doBeforeRetry,
final Predicate<? super T> retryOnReturnVal, final Predicate<Exception> retryOnException)
```
2) sophisticated:http://code.google.com/p/spf4j/source/browse/trunk/src/main/java/org/spf4j/concurrent/RetryExecutor.java
this is a executor based implementation that allows you to use your threads more efficiently.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=490#c23) posted by **loisel.jerome** on 2013-06-05 at 07:14 AM_
---
I have tried an implementation too, trying to keep it simple:
https://github.com/jloisel/retrying-callable
I like the approach in #11 but i felt the need to separate concerns between retry on exception and retry on returned result.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=477) created by **ogregoire** on 2010-11-12 at 02:26 PM_
---
Please add
- Iterables.limit(Iterable&lt;T>, Predicate<? super T>)
- Iterables.skip(Iterable&lt;T>, Predicate<? super T>)
Use case is linked to values generated on the fly and the hasNext() method of the base iterator will never return false:
- limit: hasNext() returns false once at least one element doesn't apply for a predicate
- skip: elements are discarded until at least one satisfy the predicate.
I can't use the filter method because I use open-ended iterable and therefore the filter method might not end.
Basic example:
static Predicate&lt;Integer> lessThan(int x); // Obvious predicate
static Iterable&lt;Integer> primes(); // All prime numbers, open-ended so hasNext() will never return false. (for the sake of the test, let's say there is no bound for int values.)
for (int i: limit(primes(), lessThan(3000))) {
&nbsp;&nbsp;assert i < 3000;
&nbsp;&nbsp;// Do anything.
}
for (int i: skip(primes(), lessThan(3000))) {
&nbsp;&nbsp;assert i >= 3000;
&nbsp;&nbsp;// Do anything.
}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=477#c1) posted by **kevinb@google.com** on 2011-01-12 at 10:58 PM_
---
Understood.  May need more motivation.  More use cases out there?
---
**Status:** `Accepted`
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=477#c2) posted by **finnw1** on 2011-01-12 at 11:53 PM_
---
In LINQ (and also Haskell, which I assume is where the names came from) these methods are called Enumerable.TakeWhile and Enumerable.DropWhile (the latter has the predicate inverted)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=477#c3) posted by **j...@nwsnet.de** on 2011-01-13 at 09:17 AM_
---
Having `takeWhile`&nbsp;and `dropWhile`&nbsp;would be great.
However, note that both in Haskell and Python the first argument is the predicate while the iterable comes second. This is contrary to almost all methods of `Iterables`. I guess following Guava's style is preferred here, though, to keep things consistent here.
) http://learnyouahaskell.com/higher-order-functions#maps-and-filters (search for "takeWhile")
) http://docs.python.org/library/itertools.html#itertools.takewhile
P.S.: The resource at ) contains the aforementioned motivation, too:
"We use takeWhile here instead of filter because filter doesn't work on infinite lists."
---
Actually the documentation there is factually incorrect, what it was supposed to say was "We use takeWhile here instead of filter because we want it to stop searching when it finds a non satisfying element". Both filter and takeWhile will fail to produce all elements of an infinite list (aka stream) but takeWhile will break early if it finds an element that doesn't match anymore. For example, both have the same behavior here:
takeWhile (< 2) (repeat 1) === filter (< 2) (repeat 1)
Also both work on infinite lists, you just can't fold it entirely:
take 100 (takeWhile (< 2) (repeat 1)) === take 100 (filter (< 2) (repeat 1))
The usefulness of take/dropWhile is when we use want to combine basic generators given some restrictions:
takeWhile(filter(isSquare(), aSequence), lessThan(1000))
It'll give us all square numbers less than 1000 from aSequence.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=477#c5) posted by **j...@nwsnet.de** on 2011-01-14 at 09:32 AM_
---
Thanks for the clarification.
This makes me wonder if there is a way (that makes sense) to protect using e.g. `filter`&nbsp;or `find`&nbsp;with infinite iterables in Java. I'm still looking forward for the `Range`&nbsp;class in Guava, and I assume that it can be open-ended. Is that a common problem to tackle or is leaving getting things right to the developer sufficient?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=477#c6) posted by **j...@nwsnet.de** on 2011-05-11 at 07:25 PM_
---
Here's another use case for your motivation:
From an iterable of items sorted(!) by their date attribute, I'm looking for those before/after a certain date. Hence, e.g.
```
final long someTimestamp = 4815162342L;
Iterables.takeWhile(items, new Predicate<Item>() {
public boolean apply(Item item) {
return item.getCreatedAt().getTime() == someTimestamp;
}
}
```
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=477#c7) posted by **j...@nwsnet.de** on 2011-05-11 at 07:28 PM_
---
(Sorry, but I don't get that syntax thing here. Might only work for actual wiki pages. A link to the docs as well as an on-the-fly preview [not that uncommon these days] might help here.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=477#c8) posted by **j...@nwsnet.de** on 2011-05-11 at 07:29 PM_
---
Argh, of course it would be `item.getCreatedAt().getTime() > someTimestamp;`&nbsp;or similar.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=477#c9) posted by **cgdecker** on 2011-05-11 at 08:18 PM_
---
_Issue #619 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=477#c10) posted by **j...@nwsnet.de** on 2011-06-06 at 02:32 PM_
---
kevinb: Is there a chance `limitWhile`&nbsp;and `skipWhile`&nbsp;(or whatever suits best) will appear in r10? Do you need more use cases for these methods I'd consider common?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=477#c11) posted by **kevinb@google.com** on 2011-07-13 at 06:18 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=477#c12) posted by **cpovirk@google.com** on 2011-07-13 at 08:33 PM_
---
_(No comment entered for this change.)_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=477#c13) posted by **fry@google.com** on 2011-12-10 at 03:54 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Collect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=477#c14) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=477#c15) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=477#c16) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=477#c17) posted by **wasserman.louis** on 2012-07-02 at 08:49 PM_
---
_Issue #1048 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=477#c18) posted by **j...@nwsnet.de** on 2012-07-30 at 07:52 AM_
---
Any news on this?
I can't provide a _new_ use case, just the one again I've already shown above.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=477#c19) posted by **cpovirk@google.com** on 2012-08-02 at 09:08 PM_
---
The given examples here seem to fall under the umbrella of "ordered data," for which we can optimize Iterator operations.  ("Optimize" might be an understatement in the case of infinite inputs.... :))  If that's typical, then perhaps Comparator makes more sense than Predicate:
Iterables.head(Iterable, Comparator&lt;T>, T)
Iterables.tail(Iterable, Comparator&lt;T>, T)
Internally, we once had an OrderedIterator type that exposed operations like these (though not these two in particular, IIRC).  It never really caught on, though it was part of the motivation for Iterables.mergeSorted.
I see a handful of results for 'hasNext[(][)] && ._compareTo' on a regex search over the Google codebase, plus others that look promising for 'hasNext[(][)] && ._[.]._<' and 'hasNext[(][)] && ._peek.*<'.
Am I right to focus on the Comparator case?  (Maybe we'll need to revisit the idea of OrderedIterator....)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=477#c20) posted by **cpovirk@google.com** on 2012-08-02 at 09:12 PM_
---
Ugh, that's going to have a problem.  You'll have to write:
head(records, timeComparator(), newDummyRecordWithTime(time))
But you want to write:
head(records, timeOfRecord(), time)
In full generality, that's:
head(records, timeOfRecord(), Ordering.natural(), time)
But perhaps no one will require a non-natural ordering... until someone needs Ordering.natural().reverse()....
A plain Predicate doesn't have this problem -- though it's also less likely that someone will have an appropriate Predicate sitting around than an appropriate Comparator or even Function.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=477#c21) posted by **stephan202** on 2012-08-02 at 09:44 PM_
---
The use case of comment #19 can _almost_ be handled using the Ordering class, except that the #min and #max methods that take an Iterable do not accept a default value. I.e., it seems to me one would want to write the following:
Ordering.from(Comparable&lt;T>).min(Iterable&lt;T>, T);
Ordering.from(Comparable&lt;T>).max(Iterable&lt;T>, T);
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=477#c22) posted by **markpeters.mail** on 2013-05-09 at 08:50 PM_
---
I found myself wanting this today, where it had nothing to do with ordering.  I have a case where a Version is backed by a List&lt;Integer> (highest significance first).  I need to consider [1, 2, 0] as the same as [1, 2].  This is easy enough for comparisons, but I also want those two Versions to be equal(), which is still easy as it's a comparison.  But then I need to implement hashCode and it gets difficult.  At that point, I need to be able to normalize.
So I want to be able to say "take until the remaining elements are all 0".  In Scala, that would be idiomatically
segments.reverse.dropWhile(_ == 0).reverse
Obviously if this were a Stream-like structure, or a cons list, this wouldn't be efficient.  But with LinkedList and ArrayList this is actually really efficient as reverse can be implemented as a live view.
If limit/skip or takeWhile/dropWhile were added to Iterables, this could be done in a similar way.  I think the current closest alternative would be something like "reverse, get the first index of the inverse predicate, translate it into a last index of the unreversed list, and then do a subList on the unreversed list."
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=477#c23) posted by **j...@nwsnet.de** on 2013-07-26 at 04:39 PM_
---
I come across uses for `limit`&nbsp;and `skip`&nbsp;every once in a while (and ordering doesn't help there).
---
> But then I need to implement hashCode and it gets difficult.  At that point, I need to be able to normalize.
You don't.
int hash = 0; for (int i : reverse(list)) hash = 43 \* hash + i;
> I think the current closest alternative...
IMHO currently anything but a simple loop makes no sense.
while (!list.isEmpty() && list.get(list.size() - 1 == 0) list.remove(list.size() - 1);
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=475) created by **f.daniel.cuervo** on 2010-11-09 at 04:58 PM_
---
Hi,
For a project I am developing, I wanted to use the up-to-date publicsuffix.org list in a similar manner to your TldPatterns.java.  So I have written my own generator that you can download here or from the attachment to this issue:
http://wiki.magnolia-cms.com/display/WIKI/TldPatterns+%28public+suffix+list%29+generator
It is plain Java (5) without external dependencies.  Run the _Guava_ class from your console, pipe the output wherever you like, and enjoy :)
I verified the output to be identical to the existing TldPatterns.java, besides a few differences that may come from updates to the publicsuffix.org list.
Kind regards,
Magnolia
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=475#c1) posted by **f.daniel.cuervo** on 2010-11-24 at 09:03 AM_
---
I have 'mavenized' the package, now called magnolia-domainnameutils-1.0, and added my newest developments to it.  See attachment.
Kind regards,
Magnolia
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=475#c2) posted by **f.daniel.cuervo** on 2010-11-24 at 09:47 AM_
---
Small update 1.2:
- Removed java folder (contained duplicate code with wrong header)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=475#c3) posted by **kevinb@google.com** on 2011-01-12 at 11:06 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Accepted`
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=475#c4) posted by **kevinb@google.com** on 2011-07-13 at 06:18 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=475#c5) posted by **kevinb@google.com** on 2011-07-16 at 08:32 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Accepted`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=475#c6) posted by **fry@google.com** on 2011-12-10 at 03:54 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Net`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=475#c7) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=475#c8) posted by **kevinb@google.com** on 2012-05-30 at 07:46 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Addition`, `Type-Dev`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=451) created by **Hannes.Schmidt** on 2010-10-16 at 10:44 PM_
---
The current List.partition() guarantees that all but the last partition are of the specified size and that the last one may be smaller but not empty. It would be nice to have a version of List.partition that guarantees that it returns a specified number of roughly equally sized partitions (their sizes may  differ by 1 but no more).
The attached class does exactly that. It's lacking proper argument checking. I also attached a minimal  test case to illustrate the invariant.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c1) posted by **kevinb@google.com** on 2011-07-18 at 03:41 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Accepted`
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c2) posted by **wasserman.louis** on 2011-10-16 at 11:04 PM_
---
Any ideas for how we'd disambiguate this from Lists.partition?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c3) posted by **Hannes.Schmidt** on 2011-10-17 at 12:12 AM_
---
Good question. Come to think of it, I typically use this functionality for distributing work loads equally over n workers. So I would probably call it Lists.distribute(). Since the strings 'partition' and 'distribute' are alphanumerically far from each other (think auto-complete in IDE's), I'd also prominently cross-link their Javadocs.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c4) posted by **fry@google.com** on 2011-12-10 at 03:51 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Collect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c5) posted by **wasserman.louis** on 2011-12-31 at 05:24 PM_
---
For reference, this would basically be implemented as a one-liner:
List&lt;List&lt;E>> distribute(List&lt;E> list, int partitions) {
&nbsp;&nbsp;return partition(list, IntMath.divide(list.size(), partitions, RoundingMode.CEILING));
}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c6) posted by **Hannes.Schmidt** on 2012-01-03 at 06:37 PM_
---
Sure? With your implementation (pseudo-code):
distribute( [1, 2, 3, 4] ), 3 )
I get
[ [1,2], [3,4] ]
whereas it should give
[ [ 1, 2 ], [ 3 ], [ 4 ] ]
Note that distribute() should be guaranteed to return the specified number of sublists and that the sublists should be sized equally with a tolerance of 1. Ceiling division is simply too greedy for this application.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c7) posted by **wasserman.louis** on 2012-01-03 at 07:41 PM_
---
Hrrrrrrm.  I see what you're driving at, but how would you go about documenting those semantics exactly?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c8) posted by **Hannes.Schmidt** on 2012-01-04 at 02:38 AM_
---
The pre- and post-conditions on Lists.distribute() are of similar complexity as those of Lists.partition(). The distribute() method is not just some sugar on top of partition(), it complements partition() by letting the user constrain the number of partitions rather than their size. A good Javadoc preamble with a few examples would sufficiently explain this.
There is one edge case that isn't covered by the patch. If the size of the input list is less than the requested number of partitions, distribute() should probably return empty sublists in order to satisfy distribute(l,n).size() == n.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c9) posted by **wasserman.louis** on 2012-01-04 at 03:57 AM_
---
Wait.  Describe how you would document the semantics for which partitions are of what size.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c10) posted by **Hannes.Schmidt** on 2012-01-04 at 05:04 AM_
---
The partition() Javadocs do not explicitly mention the number of returned sublists. Similarly, distribute() shouldn't go into detail about what exact size they are. It is simply not necessary to document this aspect because it is irrelevant for the use case. Only two constraints are of concern here: the number of sublists always matches the requested number and the sublists are of approximately equal size. Your proposed implementation doesn't satisfy the former constraint and is thus not applicable to the use case.
Maybe I should elaborate on the use case. Say, you have a list of 100 tasks and you want to process them with
three worker (threads, cluster nodes, etc.). If you use partition( tasks, 100/3 ) you get four sublists (three of size 33 one of size 1) which is inconvenient for this case because you need to handle the last list specially. If you  'round' the quotient to the ceiling as you suggest you get three lists which is fine. Now, let's say you have 99 workers. This is where the ceiling method fails because it yields only 50 sublists, not enough to utilize all workers. The correct implementation for the use case should return a fixed number of sublists (such that each worker is utilized) of roughly the same size (such that all workers get similar load). HTH
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c11) posted by **jim.andreou** on 2012-01-04 at 05:47 AM_
---
Lucky you. You are given all the tasks upfront, their count, and can do random access on them (you could be missing any and all of those). Isn't this simple enough already? :-)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c12) posted by **wasserman.louis** on 2012-01-04 at 03:52 PM_
---
"Returns consecutive sublists of a list, each of the same size (the final list may be smaller)."
This does give me enough information to deduce the size of each sublist.  I still don't have enough information to do it in your use case.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c13) posted by **Hannes.Schmidt** on 2012-01-04 at 07:02 PM_
---
As I said, a user of distribute() simply does not need to know the size of each sublist. It is irrelevant. Not every pre- and post-condition of a library method needs to or even should be specified. Sometimes it is better to leave certain aspects unspecified such that you are free to change them in a later release. I think that the sublist exact sizes are such an aspect.
"This method will always return the requested number of sublists. The sizes of the returned sublists differ by at most 1." That's all one needs to know.
Also, remember that partition() lets the user request the sublist size. Because of that, it is safe to assume that the user cares about their sizes and it is important to mention that at most one sublist may deviate from the specified size. With distribute() the user cares about the number of sublists, not their sizes so it is OK to leave that unspecified, just like partition() doesn't mention the number of sublists.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c14) posted by **wasserman.louis** on 2012-01-04 at 07:20 PM_
---
If you want to leave it unspecified in the documentation, that's fine, but the source code needs to have exact semantics, which I still don't understand.
I'm leaning towards jim.andreou's perspective.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c15) posted by **wasserman.louis** on 2012-01-04 at 07:53 PM_
---
Hmmmm.  I think I'm okay with this now.  Let me double-check that these semantics as are you expect, even if they're undocumented: the first (list.size() % parts) partitions will have length (list.size() / parts + 1), and the rest will all have list.size() / parts.  Fair?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c16) posted by **Hannes.Schmidt** on 2012-01-04 at 08:14 PM_
---
I didn't get what jim.andreou was trying to say so I don't know what his perspective is. Wasn't he just making a joke? Can you elaborate on where you're leaning towards?
I have implemented similar functionality for Iterables (if that's what Jim is getting at) but haven't gotten around to sharing it. The pace at which this issue has been progressing wasn't exactly encouraging to share more.
To answer your question, it's actually quite simple: In
ls = distribute(l,n)
q = l.size() / n
r = l.size() % n
The first r sublists of ls are of size q + 1, the rest (that is n - r sublists) are of size q. Basically, the division remainder is distributed over the first r sublists.
As mentioned earlier, the attached patch still violates the post-condition ls.size() == n if l.size() < n. Unlike partition(), the patch also fails to propagate the RandomAccess marker interface to the result. So there is a little more work to do.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c17) posted by **Hannes.Schmidt** on 2012-01-04 at 08:16 PM_
---
Also, the patch isn't really a patch, just code. Sorry about that.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c18) posted by **Hannes.Schmidt** on 2012-01-04 at 08:18 PM_
---
Our posts overlapped, and you got it right.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c19) posted by **wasserman.louis** on 2012-01-04 at 08:54 PM_
---
How does this patch look to you? http://code.google.com/r/wassermanlouis-guava/source/detail?r=f04d62ee1bfb547edd1aca267dc20b1937396b51&name=lists-distribute
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c20) posted by **jim.andreou** on 2012-01-04 at 09:35 PM_
---
I was trying to say, just commenting on the use case, that this is the simplest possible version of the problem, so simple that you even consider using List (or even Iterable/Iterator) to do concurrent programming. Not common.
For example, consider that list. Why do you add the tasks to the list, instead off handing them to your threads to start working immediately? You could be using a {,Blocking}Queue instead, or, typically, submitting to a ExecutorService, or even doing an #invokeAll if you really do get all your tasks in one big, undivisible step.
There are so many ways to express solutions to similar concurrency problems, and we should be very, very selective about the repertoire of constructs we build (the state of affairs is already bad enough)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c21) posted by **han...@eyealike.com** on 2012-01-04 at 09:53 PM_
---
Looks great. More readable than what I did.
Two minor things: In the JavaDocs I would explicitly mention that the result is always of the requested size.
The other thing is that there might be a case for optionally omitting empty sublists in the result. In fact, whenever I needed distribute() functionality I never wanted the empty sublists at the end. But this is of course anecdotal evidence.  What I did was equivalent to
public static &lt;T> List&lt;List&lt;T>> distributeStrictly(List&lt;T> list, int parts) {
&nbsp;&nbsp;checkNotNull(list);
&nbsp;&nbsp;checkArgument(parts > 0);
&nbsp;&nbsp;return (list instanceof RandomAccess)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;? new RandomAccessDistribution&lt;T>(list, parts)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: new Distribution&lt;T>(list, parts);
}
public static &lt;T> List&lt;List&lt;T>> distribute(List&lt;T> list, int parts) {
&nbsp;&nbsp;checkNotNull(list);
&nbsp;&nbsp;checkArgument(parts > 0);
&nbsp;&nbsp;parts = Math.min( parts, list.size() );
&nbsp;&nbsp;return (list instanceof RandomAccess)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;? new RandomAccessDistribution&lt;T>(list, parts)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: new Distribution&lt;T>(list, parts);
}
but you'd probably would want to factor the return statement into a separate method.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c22) posted by **cpovirk@google.com** on 2012-02-02 at 08:43 PM_
---
Kevin, what do you think of comment #20?  I was surprised to see that this bug was accepted, but maybe you have some uses in mind that this utility would be especially good for...?
---
**CC:** kevinb@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c23) posted by **wasserman.louis** on 2012-02-02 at 08:50 PM_
---
I'm going to throw in my +1 argument: the code is right about the same level of complexity as Lists.partition, and the first application that I can think of is "breaking up tasks to parallelize."
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c24) posted by **kevinb@google.com** on 2012-02-02 at 09:20 PM_
---
Huh.  I did seem to mark it Accepted with no explanation.  I suppose that happened just because this issue has always bothered me.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c25) posted by **wasserman.louis** on 2012-02-02 at 09:26 PM_
---
The implementation is nontrivial enough that I'm dubious of comment 20 (that it's already super easy), but easy enough that it's not a significant burden for us.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c26) posted by **cpovirk@google.com** on 2012-02-02 at 09:29 PM_
---
I didn't think that comment 20 was "it's already easy" so much as "you probably don't want to divide the tasks all up front": Either you don't know how many tasks you have, or the tasks are subdivided at multiple levels, or the tasks may be of different sizes, or whatever.  If you put them in a queue/executor and let the workers claim them as they finish their previous tasks, then you're done.  Plus, you may naturally get a handle on the results in a way that you don't here.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c27) posted by **wasserman.louis** on 2012-02-02 at 09:58 PM_
---
Hrrrrrmkay.  I might claim that in an environment where communication is expensive -- a distributed application, not multiprocessor-concurrent -- that it might still be preferable to divide the tasks up front, rather than pay the expense of waiting for each worker to communicate, "Hey, I'm done with that task, feed me another."  But Kevin's point is also well-taken.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c28) posted by **jim.andreou** on 2012-02-03 at 12:23 AM_
---
Adding few more examples for the broader problem:
An example of distributed programming: map/reduce. A mapper doesn't create a huge list of "tasks" (the entries), then divides it to send a piece to each reducer. It immediately divides the entries (by hashing, typically), and it doesn't know how many entries it will produce.
An example of parallel programming: fork/join
In particular, if a user already has all the tasks upfront, going with ParallelArray is better:
http://gee.cs.oswego.edu/dl/jsr166/dist/extra166ydocs/extra166y/ParallelArray.html
e.g. a withMapping(...).all() would produce the results of all tasks, and do so in parallel.
The latter also works great with _irregular_ tasks. Note that the suggested partition() assumes that all tasks are created equal, though in practice, some tasks are more equal than others, making its niche even smaller.
I didn't quite get the row/column comment - clarification?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c29) posted by **kevinb9n** on 2012-02-03 at 12:32 AM_
---
My understanding of the proposed method is that it would group items into a certain number of "rows" (# of sublists) in the same way that Lists.partition() groups them into a specific number of "columns" (items per sublist).  The two seem pretty equally valid in _concept_.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c30) posted by **jim.andreou** on 2012-02-03 at 01:21 AM_
---
Well, if you embed a 2D array into a 1D list, if you use a row-major order, then the current partition() would divide rows, and if you use a column-major order, then partition() would divide columns, which is fair.
True, one can't get a row partitioning if he uses a column-major ordering, or vice versa. To see if this is important, we would need examples where the user is forced to use the wrong ordering, or examples where the user is forced to partition in both orderings (ensuring that one of the two is inconvenient)...
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c31) posted by **kevinb@google.com** on 2012-02-03 at 01:54 AM_
---
No, you are missing what I (and the OP) are trying to say.
We let you group into groups of 3:
&nbsp;DEF
&nbsp;J
We let you group into groups of 2:
&nbsp;CD
&nbsp;EF
&nbsp;IJ
But if what you care about is not the _size_ of each group but the _number_ of groups -- for example, you want four of them -- you're out of luck.
Worse than being out of luck, when I was faced with this problem, I thought "ah, I'll just do this simple math and then call partition and voila!"  Someone else had to point out to me that my simple math was completely wrong and there is just no way to get this behavior.
The proposed method would do it.
&nbsp;&nbsp;DEF
Simple as that.  You have (n % k) of size ceil(n/k), then the rest of size floor(n/k).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c32) posted by **wasserman.louis** on 2012-02-03 at 01:56 AM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c33) posted by **kevinb@google.com** on 2012-02-03 at 01:57 AM_
---
(This is not to comment on whether we do or don't have enough evidence that this is widely-needed to actually add it.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c34) posted by **Hannes.Schmidt** on 2012-02-03 at 03:12 AM_
---
Let's forget about my concurrency example for a while, it was just that, an example of a possible use case.
My case is that distribute() is symmetric to partition(). If you provide one you should provide the other. The existence of both (with cross-linked Javadocs) will alert the library user of the two post-conditions that affect the result: the sublist size and the sublist count. Without distribute(), a library user wanting a fixed number of sublists is likely to make the innocent mistake of using partition( list, list.size / numSubLists ) which does not what they intend.
This happend to me and in a milder form to Louis (see comment https://github.com/google/guava/issues/451
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c35) posted by **jim.andreou** on 2012-02-03 at 03:48 AM_
---
Ah, I see, I had completely misunderstood the point of Kevin's comment.
Btw, one could think distribute(list, groups) as partition(list, ceil(|list| / groups) and transposing the result of the latter, if viewed as a matrix. (Of course, a List&lt;List&lt;T>> would be a poor type to represent a matrix, to begin with).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c36) posted by **wasserman.louis** on 2012-02-03 at 04:07 AM_
---
I'm not sure that's correct, though.  The rounding doesn't really work out, even with ceil.  Unless I misunderstand the point of the transpose?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c37) posted by **jim.andreou** on 2012-02-03 at 04:08 AM_
---
Hannes, it is the concurrency angle for which I really disagree with suggesting this addition to Lists as the proper solution. If we take the concurrency use case off the table, I don't have any opinion on this in either direction. (I couldn't, I can hardly recall ever using partition() itself - any user of that is already more experienced in the matter).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c38) posted by **jim.andreou** on 2012-02-03 at 04:16 AM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c39) posted by **wasserman.louis** on 2012-02-03 at 06:24 AM_
---
I think that transpose(partition(list, groups)) is correct...since, after all, it corresponds exactly to Kevin's rows/columns description.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c40) posted by **jim.andreou** on 2012-02-03 at 07:57 AM_
---
If it is correct, of course it matches Kevin's, yours, Hannes', and all other equivalent descriptions of this request, while adding the virtue of conciseness. Why say a long story when 4 words are enough? :)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c41) posted by **Hannes.Schmidt** on 2012-02-03 at 09:14 AM_
---
after partition(4):
IJ
DE
2) I didn't look at how transpose() is implemented but I don't think it returns sublist views like distribute() would.
3) It may be significantly more expensive. Why would we want to arbitrarily penalize one one out of two equally symmetric points of view? But this is the least of my headaches with the proposed alternative. The lack of write-through and the different ordering are bigger concerns.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c42) posted by **andreou@google.com** on 2012-02-03 at 06:20 PM_
---
This is just a short mathematical description, not an implementation (it is though O(1) to create a transposed view). Note though, since you value symmetry, that the result of this description is even more symmetrical to partition() than the version you suggest (each one would be a transpose() away from each other, whereas in your version it would take more than one mirror to show the symmetry...), so if you think this is a valid argument, you should favoring this flavor instead. Not that symmetry alone is enough for inclusion, to be sure, there would have to be enough verbose code, code that would be saying 'the long story' and which would be compressed to a short story if we add this new word -- much like how the word 'transpose' simplified the description of what a lot of people where describing to each other.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c43) posted by **Hannes.Schmidt** on 2012-02-04 at 05:13 AM_
---
For the record, can we all agree that transpose(partition(list,n)) is not equivalent to distribute(list,n) because the ordering is different?
If you want to ditch this effort at this stage and start from scratch writing an O(1) version of transpose() (O(1) wrt to both time and memory) , that handles the edge cases (jagged sublists, for example), implements write-through and then also explain the interleaved ordering in your "short story", be my guest. I'm afraid I have spent too much time on this, already. I salute your tenacity in preventing this from happening, though.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c44) posted by **kevinb@google.com** on 2012-02-04 at 05:15 AM_
---
Nothing's been prevented.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c45) posted by **wasserman.louis** on 2012-02-04 at 05:55 AM_
---
I am absolutely pro-having these arguments.  (This is exactly what happens internally for just about every change.)
I am -1 on transpose, though, which seems awfully difficult to describe for the edge cases.  Distribute is nice, elegant, simple, and, I still believe, useful.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c46) posted by **Hannes.Schmidt** on 2012-02-04 at 05:57 AM_
---
Can we get on with it, then? I understand concerns about library size, Guava becoming kitchen-sink and so on. But this is not a about adding a whole new flurry of classes, it's about adding 60 lines of straight-forward code, guaranteed to not affect backwards-compatibility, with 100% test coverage. Sorry for sounding cranky, it's been a long week.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c47) posted by **kevinb@google.com** on 2012-02-04 at 06:29 AM_
---
Hannes, you've been very patient with this discussion, and I appreciate that, but I think we should all take a break from it and ask you to patient a bit longer.  It is very unlikely we're going to add this method in time for Guava 12 anyway.
My concern is not with this method looked at as an individual addition.  You may believe that that's all this is about, since you talk about how many lines of code it has and how good its test coverage is. But these are not major concerns.
Rather, each small change means we have to look at the API as a whole in a fresh light.  With this we'd now have three versions of partition:  fixed sublist count, fixed sublist size, fixed sublist size with padding.  These are spread out oddly across Iterables, Iterators and Lists.  That's a partial cross product (even more so than we already have), and that's awkward.  How to name the new method is also a major concern, and there is a very strong chance that we would need to go through the pain of renaming the existing partition() method if we add this.  Why: because both forms are _exactly_ "partitioning"; there's absolutely nothing in the partition name to suggest fixed sublist size.
There's more: if you can partition() an Iterable, shouldn't you be able to "distribute" a Collection? Why or why not?
There's more: the behavior of the List&lt;List> returned by Lists.partition() stays relatively sane even if the backing list changes.  That might not be true with this one, and we may need to think about how to specify it properly or whether we have to copy sublists like Iterables.partition does.
These decisions are a lot more intricate than it seems, and we do not yet have enough evidence justifying the _broad_ applicability of this method to even justify the amount of time we've already spent discussing it.
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c48) posted by **jim.andreou** on 2012-02-05 at 01:02 AM_
---
Hannes, I think you misunderstood my comment. When I say this: "This is just a short mathematical description, not an implementation (it is though O(1) to create a transposed view)", the _only_ reason I state the complexity is because your (3) point in #41, which implied that matrix transposition is costly (it is not). Louis already has an O(1) implementation anyway. Hope it's clear now.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c50) posted by **Hannes.Schmidt** on 2012-02-05 at 08:38 PM_
---
Ok, I see where you guys are coming from now. Let me just summarize my point of view and then I'll leave you to your decision making. Of course, there is no rush to get this out. I was more concerned about the amount of discussion that had already gone into this issue but I see now that your concerns as the (I assume) maintainers are at a higher level than mine.
Based on my own anecdotal evidence, distribute() is more useful than partition(). Its post-condition is slightly harder to achieve and I think more useful in the real world. But again, this is purely anecdotal evidence. I would like to see both included, if merely to raise awareness of their symmetry.
Having a transpose() on lists is also useful but to say transpose(partition) == distribute is just wrong because of the different ordering they produce. This is my main concern. After all, were talking about lists here whose main property is consistent ordering. The interleaved ordering produced by transpose(partition) would come as a big surprise to many users.
Louis, how does your transpose() handle jagged sublists?
Kevin, why do you think partition() behaves more sanely in case of changes to the backing list? I tend to think that distribute() and partition() behave equally bad/well in that case.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c51) posted by **wasserman.louis** on 2012-02-05 at 08:48 PM_
---
@Kevin, I agree with Hannes that I don't see how distribute() behaves any more weirdly in the case of backing-list changes.  It is true that elements will get moved between sublists -- that's also true of partition.  It's also true that for small modifications, most elements will stay in the same part for both distribute and partition.  (I'm using my implementation of distribute at codereview, for reference.)
But all of this is beside the point of "we need more evidence for the usage of distribute."  Kevin, I wonder if we can scan the Google codebase for uses of partition with a division in the partition size expression.  The presence of a division would be a strong indicator that they're trying to do something like distribute().  Or perhaps we should just do a study of uses of partition in the first place?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c52) posted by **jim.andreou** on 2012-02-06 at 12:32 AM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c53) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c54) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=451#c55) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
We had quite the epic discussion about this 3 years ago.
The upshot of it all is that yes, there is currently no way to accomplish a partition into a specified number of partitions (rather than partition size). Conceptually, there should be; in real life it's curious that this complaint has not arisen more often.
However, imho we should still do the aforementioned research into how many current partition() users are attempting this using bad math.
Looking over 100+ randomly-chosen usages of this method, I discovered only two cases where the user may have been trying to use math to get a desired number of partitions. So that concern is not going to be a good source of motivation for this.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=450) created by **yogy.namara** on 2010-10-16 at 01:26 PM_
---
Sometimes we use blank/empty strings instead of nulls, and we may want to skip them or replace them with something when joining.
Basically, for the same reason that Joiner provides useForNull and skipNulls, it should also provide useForBlank and skipBlanks.
---
Perhaps we want the empty string check to be done on the result of the toString() on each part object, and not directly on the parts themselves. In this sense the two methods are different from useForNull and skipNulls, which does the null check only on the part directly, and would append "null" if the toString of a non-null object returns null.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=450#c2) posted by **cgdecker** on 2010-10-16 at 04:19 PM_
---
This seems like a case where the feature wouldn't be generally useful enough to justify its existence, especially given that Joiner isn't just for use on lists of Stings and that toString() methods for objects that aren't CharSequences probably shouldn't be returning empty or blank (in my opinion).
What I'd probably do is make a Predicate "notBlank()" and/or a Function "useForBlank(String)" and use filtering or transforming to achieve the same result:
&nbsp;&nbsp;String skippedBlanks = Joiner.on(',').join(Iterables.filter(strings, StringPredicates.notBlank()));
&nbsp;&nbsp;String replacedBlanks = Joiner.on(',').join(Iterables.transform(strings, StringFunctions.useForBlank("none")));
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=450#c3) posted by **kevinb@google.com** on 2010-10-16 at 05:28 PM_
---
I agree with Colin.  Thanks for the suggestion, Yogy.
---
**Status:** `WontFix`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=428) created by **SeanPFloyd** on 2010-09-21 at 09:20 AM_
---
A method that is often requested takes a long and formats it as x KB, x MB etc.
Here are several requests from StackOverflow (the second is mine):
http://stackoverflow.com/questions/3758606/how-to-convert-byte-size-into-human-readable-format-in-java
http://stackoverflow.com/questions/3263892/format-file-size-as-mb-gb-etc
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=428#c1) posted by **andreas.lundblad** on 2010-09-21 at 10:13 AM_
---
Sample implementation available at http://stackoverflow.com/questions/3758606/how-to-convert-byte-size-into-human-readable-format-in-java
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=428#c2) posted by **kevinb@google.com** on 2011-01-27 at 06:16 AM_
---
_(No comment entered for this change.)_
---
**Status:** `Started`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=428#c3) posted by **jason.de...@systemsnavigator.com** on 2011-02-15 at 10:24 AM_
---
Why not use FileUtils from Apache, i.e. FileUtils.byteCountToDisplaySize(long size). It was also suggested in one of the topics in the links.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=428#c4) posted by **SeanPFloyd** on 2011-02-15 at 10:35 AM_
---
@jason
a) nice, thanks, didn't know that
---
Will various locales be supported?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=428#c6) posted by **kurt.kluever** on 2011-06-07 at 06:24 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Accepted`
**Owner:** kurt.kluever
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=428#c7) posted by **kevinb@google.com** on 2011-07-13 at 06:18 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=428#c8) posted by **kevinb@google.com** on 2011-07-18 at 04:03 PM_
---
Comments welcome on the following take on this (surprisingly ugly) issue. I find the binary prefixes weird, but we're concerned about ambiguity (should we be?). See
http://en.wikipedia.org/wiki/Binary_prefix
Note also that we're not primarily concerned with _formatting_ here, as that might be locale- and preference-dependent. We see these classes as analogous to TimeUnit and something like a Duration.
public enum BinaryPrefix {
&nbsp;&nbsp;public long convert(long value, BinaryPrefix prefix) { ... }
}
public enum MetricPrefix {
&nbsp;&nbsp;public long convert(long value, BinaryPrefix prefix) {...}
}
public final class DataSize {
&nbsp;&nbsp;public enum Unit { BIT, BYTE };
&nbsp;&nbsp;public DataSize(long value, BinaryPrefix prefix, Unit unit) {...}
&nbsp;&nbsp;public DataSize(long value, MetricPrefix prefix, Unit unit) {...}
&nbsp;&nbsp;public boolean isBinary() {...}
&nbsp;&nbsp;public boolean isMetric() {...}
&nbsp;&nbsp;public BinaryPrefix getBinaryPrefix() {...}
&nbsp;&nbsp;public MetricPrefix getMetricPrefix() {...}
&nbsp;&nbsp;public Unit getUnit() {...}
&nbsp;&nbsp;public long getValue() {...}
}
---
**Status:** `Accepted`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=428#c9) posted by **kevinb@google.com** on 2011-07-18 at 04:04 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=428#c11) posted by **ogregoire** on 2011-07-25 at 11:03 PM_
---
Why not use a DataSize that stays quite generic and provide two subclasses: BinaryDataSize and MetricDataSize. This way, it's still possible to keep only one Prefix enum. Conversion should be easy between Binary- and MetricDataSize.
Also, I think that the use cases for bits are too narrow. Nowadays, the "bit" (in a quantifiable context) is still used for OS distinction (32 bits-systems vs. 64 bits-systems) as well as the speed limit where the "byte" is omnipresent. I'd simply drop it. Also, if we drop the bit/byte distinction, the values may be used for any quantifiable and not only for data. Some side methods may be used to specify the data, but I'd put them in static contexts.
Finally as a side note I would use Decimal- instead of Metric- as it's quite the name, in fact (see your link).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=428#c12) posted by **fry@google.com** on 2011-12-10 at 03:49 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Base`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=428#c13) posted by **kak@google.com** on 2011-12-15 at 09:45 PM_
---
_Issue #827 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=428#c14) posted by **kevinb@google.com** on 2012-02-16 at 07:04 PM_
---
I'm recasting this issue as being about the data type itself -- we won't be wanting to get into the formatting and parsing of user-visible text.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=428#c15) posted by **wasserman.louis** on 2012-04-03 at 04:23 PM_
---
Has anything happened with this?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=428#c16) posted by **kak@google.com** on 2012-04-04 at 03:58 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=428#c17) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
---
+1 for dropping bits and/or DataSize.Unit to make scope of the calculations broader (i.e. for calculating any generic unit).
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=422) created by **Simon.Legner** on 2010-09-17 at 07:35 AM_
---
Did you consider to implement a toString helper using the Java Reflection API? A similar function is provided by Apache's commons-lang [1].
[1] http://commons.apache.org/lang/api-2.5/org/apache/commons/lang/builder/ToStringBuilder.html#reflectionToString(java.lang.Object)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=422#c1) posted by **ray.j.greenwell** on 2010-09-17 at 10:27 PM_
---
That can also be useful, but:
- Sometimes it's too much information. You might just want print a summary of important fields.
- The reflection methods are defined as not returning the Fields in any particular order (although in practice I find it to be in declaration order). In any case, you may want to output more important fields prior to less important ones.
- Finally, a reflection-based toStringer may not be able to access every field, nor can it print computed values.
In reality it's far more convenient to customize the output rather than do a full TMI dump, but sometimes a reflection-based output is useful for simpler classes.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=422#c2) posted by **boppenheim@google.com** on 2010-09-23 at 04:32 AM_
---
It's definitely annoying to have to modify the tostringhelper call every time you add/change/delete a field (equals and hashCode too for that matter).  I tend to agree with Ray about the downfalls though.  I also would be interested to see what the performance implications of using reflection would be.  I understand it's not as bad as it used to be though.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=422#c3) posted by **ian.b.robertson** on 2010-10-04 at 08:48 PM_
---
There are some annotation-driven solutions out there.  Project Lombok will use annotation processing to generate the methods.  Pojomatic doesn't require any special compile-time processing, but uses reflection.  Reflection definitely is slower, but for most cases is still plenty fast.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=422#c4) posted by **j...@nwsnet.de** on 2010-10-05 at 10:26 AM_
---
What about classes which refer to each other via fields? When all fields are considered by such a dynamic `toString()`&nbsp;helper, wouldn't that result in possibly infinite recursion when trying to call `toString()`&nbsp;on its values?
I recall having a similar/related issue (though the `toString()`&nbsp;implementations explicitly included such fields).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=422#c5) posted by **kevinb@google.com** on 2011-03-19 at 03:13 PM_
---
I really don't want to go here.  These utilities are what they are; they're programmatic, not reflective, and I'm comfortable with saying that whatever provides the reflective functionality will just be something else.  Or, if we provide anything, it will be in a com.google.common.reflect package and will handle much more than just toString.
---
**Status:** `WontFix`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=422#c6) posted by **SeanPFloyd** on 2011-03-21 at 11:25 AM_
---
Kevin: com.google.common.reflect sounds good. Are there any plans in that direction?
Our general advice for people writing toString by hand is to use [AutoValue](https://github.com/google/auto/tree/master/value).
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=418) created by **mathias.bogaert** on 2010-09-15 at 12:45 PM_
---
The JavaDoc states that once a service has been stopped, it can't be restarted. Why is this?
I'm exposing the start() and stop() methods through JMX, and would like to control my service from there, but it won't allow me to restart a stopped service.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=418#c1) posted by **kevinb@google.com** on 2010-11-05 at 06:49 AM_
---
Our Service concept models a single incarnation of a service.  You can model a restartable service as a wrapper that creates new Service instances as needed.
By analogy, you can't eat the same hamburger over and over again, but you can order a new hamburger just like it.
---
**Status:** `WontFix`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=418#c2) posted by **piotr.findeisen** on 2013-07-22 at 01:24 PM_
---
I have the same scenario as Mathias. Perhaps, there could be a generic wrapper around Service that provides a "restartable Service" behavior?
Implementing a "restartable Service" with a "Service" requires a bit of re-usable boiler plate which is easy to get wrong.
For example if you allow to call start() when current service state is STOPPING, you would want new Service (your new hamburger, Kevin) to withhold execution until the old one is complete (so that you don't end up with 2 burgers in your mouth).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=418#c3) posted by **cgdecker@google.com** on 2013-08-09 at 07:09 PM_
---
_Issue #1503 has been merged into this issue._
I am not as categorically opposed this proposal as i once was :)
I can definitely see the value in being able to restart a service but i think I need some more information
Could you provide a concrete usecase of where you would like to use this?  The hamburger metaphor isn't hugely useful.
How would the Service interface change?
Would 'reset' be a method on Service? just abstractservice (and the other abstract service base classes)?
Would we add a new State enum?
Ability to query how many times it has been restarted (generation count)?
What happens if you call reset() and the service isn't in a terminal state?
Would we want services to be able to 'auto restart'?
I think the change to AbstractService will probably be significantly larger than the proposed change since I assume there are many places where the 'DAG' nature of service states is assumed implicitly.
Also there is a serious backwards compatibility concern for preexisting services, most services assume that FAILURE is terminal and so probably will need additional work to handle restarting (to reset state initialiy set in constructors).  I'm not sure how we would manage that.  Luckily Service is `@Beta` so we can break them... not that that is a great plan :)
thanks for the reminder!
> Would 'reset' be a method on Service? just abstractservice (and the other
> abstract service base classes)?
> Depends how far we want to take it
well, this is important.  Since if we aren't modifying Service or
since most users use the Abstract base classes its not clear how useful the
feature would be without support in those places (or writing a lot of new
code to support the restartable usecase in new similar classes).  Also,
ServiceManager.
for the configuration usecase, the model is you get notified of a new
config and so you stop() and start() all services that depend on the
config.  that makes sense i suppose.  Other than a standard start()/stop()
STARTING states buy you?  Is it interacting with some other infra that is
generically monitoring the services?
On Tue, Jan 6, 2015 at 10:30 AM, Igor Okulist notifications@github.com
wrote:
> @lukesandberg https://github.com/lukesandberg Happy New Year!
>
> Please review response above.
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/418#issuecomment-68908955.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=390) created by **jvdneste** on 2010-07-30 at 10:45 AM_
---
For instance Iterators.concat returns a value of type Iterators$5
This is not very meaningful when visible in stacktraces or during step-through debugging
return new Iterator&lt;T>() { ... }
could be replaced with
class ConcatIterator implements Iterator&lt;T> { ... }
return new ConcatIterator()
As far as I know, the difference is entirely cosmetic. I'll agree it's a very tedious thing to do, but it really helps debugging.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=390#c1) posted by **kevinb@google.com** on 2010-07-30 at 03:21 PM_
---
We'll consider it... but we'd likely be very tempted to change them right back again once lambdas arrive in the language.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=390#c2) posted by **fry@google.com** on 2011-01-28 at 04:55 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Accepted`
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=390#c3) posted by **kevinb@google.com** on 2011-07-13 at 06:18 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=390#c4) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=390#c5) posted by **kevinb@google.com** on 2012-03-02 at 06:51 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-General`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=390#c6) posted by **kevinb@google.com** on 2012-05-30 at 07:41 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Enhancement-Temp`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=390#c7) posted by **kevinb@google.com** on 2012-05-30 at 07:45 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement-Temp`, `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=390#c8) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=384) created by **hoodwgs** on 2010-07-20 at 07:31 PM_
---
It would be nice to have an varargs Objects.firstNonNull()
This would reduce a lot of "if"s "else"s.
Implementation:
&nbsp;&nbsp;&nbsp;&nbsp;public static &lt;T> T firstNonNull( T... objs ){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for( T obj : objs )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if( obj != null )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return obj;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new NullPointerException();
&nbsp;&nbsp;&nbsp;&nbsp;}
Utilization:
&nbsp;&nbsp;&nbsp;&nbsp;String var1 = null;
&nbsp;&nbsp;&nbsp;&nbsp;String var2 = null;
&nbsp;&nbsp;&nbsp;&nbsp;String var3 = "ccc";
```
System.out.println( aaa );
```
like...
Iterable.firstNonNull( Iterable&lt;T> col )
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=384#c1) posted by **kevinb@google.com** on 2010-07-20 at 08:33 PM_
---
You can use:
Iterables.find(collection, Predicates.notNull()).
For varargs, use Arrays.asList(a, b, c, ...) as the 'collection' above.
---
**Status:** `WontFix`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=384#c2) posted by **kevinb@google.com** on 2011-01-19 at 06:07 PM_
---
Since this keeps coming up, here's my latest explanation of the rejection:
As noted, I feel the way to evaluate this method is not as a generalization of Objects.firstNonNull(a, b), but as a specialization of Iterables.find(), which differs from that method in two ways:
1. Uses a particular predicate (Predicates.notNull())
To point #1, the design focus of Guava has always been to provide generalized capabilities that can be easily composed together to get more specific results.  If we ever redundantly offer a function that is just a specialization of another, that is really only because that special case is very, very commonly used.
To point #2, I am very reluctant to add more any varargs methods to any of our libraries.  This language feature has not panned out very poorly.  It causes warnings, it forces arguments to the last position, it causes very confusing overload resolution ambiguities.... Plus, when Java gets collection literals (as slated, although I do understand it will be a while), that will be an alternative that doesn't suffer any of those drawbacks.  At that point the benefits of varargs will just completely evaporate into a savings of two characters ("[" and "]"), and we'll regret all the varargs methods we're stuck with.
So what about only adding a 3-argument form?  The question is how sharply the applicability of the method drops off between 2 and 3 and between 3 and 4.  I predict, without evidence, that the drop-off is very, very sharp from 2 to 3.  The drop-off from 3 to 4 is probably not as high, relatively speaking, as the 2->3, so I think we'd only be buying a bit of time until users say "hey, it makes no sense that you stop at 3, now how about 4, 5, ....."
In summary, the find(asList(), notNull()) alternative exists, and while it's certainly a little clumsy, I believe it's not too clumsy when we consider the relative rarity of the use case.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=384#c3) posted by **amertum** on 2011-01-19 at 08:23 PM_
---
My comment has really no added value on this topic but I'd like to tell that I really like the way you argue :D
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=384#c4) posted by **morten.hattesen** on 2011-02-10 at 12:28 AM_
---
I can clearly see the arguments for rejecting the overloaded Objects.firstNonNull(), but the suggested alternatives are no where near as declarative/expressive as...
String a = Objects.firstNonNull( var1, var2, var3, var4);
They all drown in boilerplate (Predicates, Iterables, asList, ...) and loose the clarity/expressiveness.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=384#c5) posted by **kurt.kluever** on 2011-03-22 at 03:42 PM_
---
_Issue #577 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=384#c6) posted by **cgdecker** on 2011-05-24 at 02:04 PM_
---
_Issue #632 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=384#c7) posted by **kak@google.com** on 2013-02-26 at 08:16 PM_
---
Let's move this into the research bucket. Both Greg and I were +1 on adding it. Kevin wanted us to try to decide what "N" to choose.
Semi-related (overloads w/o varargs):
&nbsp;ImmutableList#of(e1, ... e11)
&nbsp;ImmutableSet#of(e1, ... e5)
&nbsp;ImmutableMap#of(k1, v1, ... k5, v5)
---
**Status:** `Research`
**Owner:** kak@google.com
**Labels:** `Type-Enhancement`, `Package-Base`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=384#c8) posted by **kevinb@google.com** on 2013-04-30 at 05:24 PM_
---
Still, no one has once offered motivating use cases. These would make it clear to us why existing solutions are insufficient.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=384#c9) posted by **aheydon@google.com** on 2013-04-30 at 05:39 PM_
---
I'd like to second Morten's comment #4 on this topic. When people are looking to find the first non-null element in a sequence of multiple values, their first thought is not to combine Iterables.find(), Arrays.asList(), and Predicates.notNull(). At the very least, could you at least augment the Javadoc of the existing Objects.firstNonNull() method to include the text of Kevin's comment #1?
---
Why does the current firstNonNull have 2 parameters? Why not 3 or 5?
firstNonNull implies - by its name - that it's a way, even _the_ way to get the first non null among objects. Kevin's #1 comment is just as well applied to 2 params as to any longer list.
Thus, if having firstNonNull makes any sense, then have a vararg version of it makes sense. If for any >2 number of params the less expressive workaround suffices, then it suffices for =2 params and firstNonNull should be deprecated or removed.
So, please either prove me wrong, extend a vararg version, or remove the method.
Kindly (though firmly),
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=384#c11) posted by **amertum** on 2013-04-30 at 10:34 PM_
---
It makes me think that firstNonNull(var1, var2) is equivalent to Optional.fromNullable(var1).or(var2) as well.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=367) created by **blair-ol...@orcaware.com** on 2010-06-09 at 09:21 PM_
---
Adding a method to Interner that returns the number of elements
in the interner would be useful for unit testing and to allow
JMX or other tools to report on the size of the interner to help
track memory usage.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=367#c1) posted by **kevinb@google.com** on 2010-06-10 at 04:57 PM_
---
It's been on our minds that a map constructed by MapMaker doesn't have the kind of "size" method you'd really want.  Right now, it painstakingly counts every element to get an exact result, even if it ends up having to lock the entire table to do it (in extreme cases)!  What you'd rather have is a fast approximation.  Once you had the ability to do this for a "MapMaker-made map", the way to expose the feature to interners might be just to allow a custom MapMaker to be provided when creating the interner.  Which would of course allow other features as well.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=367#c2) posted by **fry@google.com** on 2011-01-28 at 04:18 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Accepted`
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=367#c3) posted by **kevinb@google.com** on 2011-07-13 at 06:18 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=367#c4) posted by **kevinb@google.com** on 2011-07-16 at 08:37 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Accepted`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=367#c5) posted by **fry@google.com** on 2011-12-10 at 03:46 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Collect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=367#c6) posted by **wasserman.louis** on 2012-04-25 at 05:51 PM_
---
A Cache-powered Interner could support this, no?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=367#c7) posted by **kevinb@google.com** on 2012-04-27 at 02:29 PM_
---
You can't really have an Interner backed by a Cache, per the Interner contract, if that Cache might have any eviction policy (besides weakKeys).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=367#c8) posted by **kevinb@google.com** on 2012-05-30 at 07:41 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Enhancement-Temp`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=367#c9) posted by **kevinb@google.com** on 2012-05-30 at 07:45 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement-Temp`, `Type-Enhancement`
---
But this Cache gets created for the Interner, so there's no chance for it having an unexpected eviction policy, is it?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=367#c11) posted by **kevinb@google.com** on 2012-06-30 at 02:09 AM_
---
We were at one time considering letting you back an interner with any Cache, and I think Louis's point is that that would solve this issue too, since you could call cache.size().  But we're not doing that, so my point is that this issue is still a valid request.  I suspect you want CacheStats for your interners too.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=359) created by **hshsce** on 2010-05-12 at 09:22 AM_
---
<b>What steps will reproduce the problem?</b>
1. File dir = Files.createTempDir(); (e.g. unit test set up)
2. fill dir with some random files
3. Files.deleteRecursively(dir); (e.g. unit test tear down).
<b>What is the expected output? What do you see instead?</b>
I expect directory to be deleted. IOExceptio is thrown instead
<b>What version of the product are you using? On what operating system?</b>
Darwin foo.lan 10.3.0 Darwin Kernel Version 10.3.0: Fri Feb 26 11:58:09 PST 2010; root:xnu-
1504.3.12~1/RELEASE_I386 i386
<b>Please provide any additional information below.</b>
I suspect that IOException is thrown because non empty directory cannot be deleted. It is non
empty because Files.deleteDirectoryContents() method stopped silently without any action after
detecting symbolic link. In fact on my Mac OS the /tmp dir is linked with symbolic link to
/private/tmp dir.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=359#c1) posted by **kevinb@google.com** on 2010-07-30 at 03:56 AM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Priority-Medium`
---
I have the same issue
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=359#c4) posted by **Randgalt** on 2011-01-26 at 07:13 PM_
---
the problem is this line of code in deleteDirectoryContents()
```
if (!directory.getCanonicalPath().equals(directory.getAbsolutePath())) {
return;
}
```
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=359#c5) posted by **fry@google.com** on 2011-01-28 at 04:12 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Accepted`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=359#c6) posted by **kevinb@google.com** on 2011-07-13 at 06:18 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=359#c7) posted by **cpovirk@google.com** on 2011-07-21 at 06:25 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Duplicate`
**Merged Into:** #365
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=349) created by **jherico72** on 2010-04-13 at 10:32 PM_
---
For whatever reason, Sun didn't add the Closeable interface to Socket when
they introduced Closeable in Java 5.  They're fixing it in Java 7, but in the
meantime it would be nice to have Socket specific methods on Closeables in
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=349#c1) posted by **fry@google.com** on 2011-01-28 at 04:04 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Accepted`
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=349#c2) posted by **kevinb@google.com** on 2011-07-13 at 06:18 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=349#c3) posted by **fry@google.com** on 2011-12-10 at 03:45 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-IO`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=349#c4) posted by **wasserman.louis** on 2011-12-31 at 05:22 PM_
---
Since Java 7 is out, is this still a thing?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=349#c5) posted by **t...@duh.org** on 2011-12-31 at 07:35 PM_
---
Everyone suddenly jumped ship from JDK6 to JDK7?
Yes, it's still an issue until JDK6 support is dropped. Adding a method call should not cause issues with JDK7 usage (the Socket method will win at compile time as it's more specific).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=349#c6) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=349#c7) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=349#c8) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=345) created by **kai@google.com** on 2010-04-08 at 07:59 PM_
---
By the UTF-8 definition, UTF-8 files are allowed to have an optional leading
BOM.  This BOM is stupid and pointless, but many Windows apps seem to
generate UTF-8 files with the BOM.  Guava's classes Files and Resources do
not handle UTF-8 files with a BOM.  I'm not sure where this fix belongs, or
whether it should even be fixed at all (since Windows is being stupid, and
people are rightly sick and tired of working around Windows issues).  BTW, I
don't personally use Windows.  I'm reporting this issue only because I
library that are running into this issue.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=345#c1) posted by **kevinb@google.com** on 2010-04-09 at 07:05 PM_
---
Good to know. Based on this, it will probably make sense for us to check for a byte-
order mark and just advance past it. Do JDK classes like Reader do this, I assume?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=345#c3) posted by **fry@google.com** on 2011-01-28 at 04:03 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Accepted`
**Labels:** `Type-Defect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=345#c4) posted by **mail4danny** on 2011-02-04 at 04:18 PM_
---
No, the JDK just quietly ignores this ;-)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=345#c5) posted by **finnw1** on 2011-02-04 at 09:01 PM_
---
The JDK does detect (and strip) the BOM for some encodings, e.g.
Standard encodings:
UTF-16
UTF-32
Non-standard encodings (that are reported by Charset.availableCharsets()) on my system:
x-UTF-16LE-BOM
X-UTF-32BE-BOM
X-UTF-32LE-BOM
It's for those that are not expected to contain a BOM that the BOM is returned to the application.
It sounds as though what you want is a standard encoding based on UTF-8 that accepts a BOM, e.g.
But (1) this is a feature request not a defect and
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=345#c6) posted by **kevinb@google.com** on 2011-07-13 at 06:18 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=345#c7) posted by **fry@google.com** on 2011-12-10 at 03:45 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-IO`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=345#c8) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=345#c9) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=345#c10) posted by **j...@durchholz.org** on 2012-12-27 at 10:01 AM_
---
1) The BOM is useful if the program needs a way to autodetect a text file's encoding. This is so even in Unixoid systems, the output from the file command says "UTF-8 Unicode (with BOM) text", so if it's a misfeature, it's not just one of Windows. Of course it's just heuristics, but heuristics does have its place.
2) Arguing that something belongs into the JDK instead of into Guava ignores the very mission statement of Guava, which is essentially "let's do things right where the JDK dropped the ball". So in fact if the JDK does this wrong, Guava should do something about it.
3) Some programs want to see the BOM, others want to have the BOM skipped for them if it's present. Programs need a way to express that. Using different character sets would cover that.
4) I'm not sure what the semantics of an x-UTF-8-BOM charset would be when writing: Write a BOM or not? The path of minimal resistance would be to write the BOM with x-UTF-8-BOM and leave it unwritten with UTF-8, but that would punish the best approach (ignore BOM on input, don't write it on output) with the most complicated handling (different character sets for reading and writing).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=345#c11) posted by **NikolayMetchev** on 2014-01-07 at 11:57 AM_
---
This was filed as a bug in the JDK. The decided not to fix it there for backward compatibility reasons:
http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
https://developers.google.com/gdata/javadoc/com/google/gdata/util/io/base/UnicodeReader?csw=1
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=334) created by **blank101** on 2010-02-26 at 11:00 PM_
---
I find the following very annoying:
Predicates.and(Predicates.not(Predicates.in(someCollection)),Predicates.not
...etc.
I wrote a (very bare) wrapper implementation of Predicate (attached), which
provides for all the methods in Predicates in a functional style (ala the
similar proposal for Iterables), which allows some thing like:
ComposablePredicate.in(someCollection).not().and(Predicates.notNull())
which I think is more clear than the example above.  I don't see this in the
dead ideas or otherwise closed issues, so I thought I'd suggest it.
The one implementation decision I'm not sure about is an immutable vs
mutable delegate, but I'm pretty happy with the immutable version.
N.B.: this composition problem also applies to functions: e.g.,
Functions.blah(Functions.blah(Functions.blah( ... ) becomes rapidly
unreadable for any substantive number of functions.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=334#c1) posted by **kevinb@google.com** on 2010-02-27 at 12:48 AM_
---
We have great "fluent" versions of Predicate, Function and Iterable, and I hope we can
release them soon.  The only real problem is that these classes are THE hardest things
to name EVER.
Right now the best I have come up with is FluentPredicate, FluentFunction and
FluentIterable. :(
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=334#c2) posted by **blank101** on 2010-02-27 at 05:41 AM_
---
it doesn't conjure up to much an advertising theme.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=334#c3) posted by **david.henderson** on 2010-03-09 at 10:31 PM_
---
The term "Chainable" is used in some contexts.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=334#c4) posted by **blank101** on 2010-03-09 at 11:27 PM_
---
I know IDEs, auto-completion, blah-blah-blah...but "Chainable" is really long.
"Fluent" (too ambiguous, too long), hence would prefer "Flow" as the prefix (and that's
how I've named my parallel Collections framework), but it would be a reasonable name.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=334#c5) posted by **cgdecker** on 2010-03-09 at 11:55 PM_
---
seem worth using a name that neither reads well nor describes the class as well as
Fluent. That said, I think if Kevin felt this general category of names was what he
really wanted to use for these classes he'd just have used Fluent and been done with
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=334#c6) posted by **blank101** on 2010-03-10 at 01:22 AM_
---
Function -> Composite
Predicate -> Filter
?
I still think I consistent prefix would be preferable.  The basic behavior of all these
things (functions, predicates, iterables, iterators, etc) remains largely consistent with
their "parent" objects, but each has the same sort of sequentially callable
---
This fluency support could be extended to more than predicates/functions/iterables.
interface Filterable&lt;E> {
&nbsp;&nbsp;&nbsp;&nbsp;Filterable&lt;E> filter(Predicate<? super E> p);
}
interface Transformable&lt;E> {
&nbsp;&nbsp;&nbsp;&nbsp;&lt;F>Transformable&lt;F> transform(Function<? super E,? extends F> f);
}
interface Composable&lt;E> {
&nbsp;&nbsp;&nbsp;&nbsp;&lt;D>Composable&lt;D> compose(Function<? super D,? extends E> f);
}
interface FluentFunction&lt;D,E> extends Transformable&lt;E>, Composable&lt;D>, Function&lt;D,E>
{
&nbsp;&nbsp;&nbsp;&nbsp;// equivalent to Functions.compose
&nbsp;&nbsp;&nbsp;&nbsp;&lt;F>FluentFunction&lt;D,F> transform(Function<? super E,? extends F> f);
&nbsp;&nbsp;&nbsp;&nbsp;// equivalent to Functions.compose
&nbsp;&nbsp;&nbsp;&nbsp;&lt;C>FluentFunction&lt;C,E> compose(Function<? super C,? extends D> f);
}
interface FluentPredicate&lt;E> extends Filterable&lt;E>, Composable&lt;E>, Predicate&lt;D,E> {
&nbsp;&nbsp;&nbsp;&nbsp;// equivalent to Predicates.and
&nbsp;&nbsp;&nbsp;&nbsp;FluentPredicate&lt;E> filter(Predicate<? super E> p);
&nbsp;&nbsp;&nbsp;&nbsp;// equivalent to Predicates.compose
&nbsp;&nbsp;&nbsp;&nbsp;&lt;D>FluentPredicate&lt;D> compose(Function<? super D,? extends E> f);
&nbsp;&nbsp;&nbsp;&nbsp;FluentPredicate&lt;E> and(Predicate<? super E> p);
&nbsp;&nbsp;&nbsp;&nbsp;FluentPredicate&lt;E> or(Predicate<? super E> p);
&nbsp;&nbsp;&nbsp;&nbsp;FluentPredicate&lt;E> not();
}
interface FluentIterable&lt;E> extends Transformable&lt;E>, Filterable&lt;E>, Iterable&lt;E> {
&nbsp;&nbsp;&nbsp;&nbsp;// equivalent to Iterables.filter
&nbsp;&nbsp;&nbsp;&nbsp;FluentIterable&lt;E> filter(Predicate&lt;E> p);
&nbsp;&nbsp;&nbsp;&nbsp;// equivalent to Iterables.transform
&nbsp;&nbsp;&nbsp;&nbsp;&lt;F>FluentIterable&lt;F> transform(Function<? super E,? extends F> f);
}
interface FluentIterator&lt;E> extends Transformable&lt;E>, Filterable&lt;E>, Iterator&lt;E> {
&nbsp;&nbsp;&nbsp;&nbsp;// equivalent to Iterables.filter
&nbsp;&nbsp;&nbsp;&nbsp;FluentIterator&lt;E> filter(Predicate&lt;E> p);
&nbsp;&nbsp;&nbsp;&nbsp;// equivalent to Iterables.transform
&nbsp;&nbsp;&nbsp;&nbsp;&lt;F>FluentIterator&lt;F> transform(Function<? super E,? extends F> f);
}
interface FluentCollection&lt;E> extends Collection&lt;E>, FluentIterable&lt;E> {
&nbsp;&nbsp;&nbsp;&nbsp;// equivalent to Collections2.filter
&nbsp;&nbsp;&nbsp;&nbsp;FluentCollection&lt;E> filter(Predicate&lt;E> p);
&nbsp;&nbsp;&nbsp;&nbsp;// equivalent to Collections2.transform
&nbsp;&nbsp;&nbsp;&nbsp;&lt;F>FluentCollection&lt;F> transform(Function<? super E,? extends F> f);
}
// and so on, giving FluentMap, FluentList, FluentQueue, FluentSet, FluentSortedMap,
FluentSortedSet
// we can add FluentFuture, FluentThreadLocal, etc. as we would like
class Fluency {
&nbsp;&nbsp;&nbsp;public static &lt;E> FluentIterable from(Iterable&lt;E> iterable);
&nbsp;&nbsp;&nbsp;public static &lt;E,F> FluentFunction from(Function<? super E,? extends F> function);
// and so on
}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=334#c8) posted by **blank101** on 2010-03-10 at 01:27 PM_
---
That is very similar to what I do; I do put the additional interface requirement for
FluentIterable that the iterator() method return a FluentIterator.  Also, for the various
collections, I included fluent versions of the mutators (fluentAdd, fluentRemove, etc).
Also my base interfaces (the Filterable, Composable, Transformable equivalents) I
covered more of the functionality in the Predicates, Functions, Iterables, Iterators
static helper classes.
What are the specifics of your Fluent map?  It's not as obvious to me what's being
---
As you said I also put the additional constraints of FluentIterable returning a
FluentIterator on iterator(). FluentMap is similar, it returns a FluentSet on keySet()
and entrySet() and a FluentCollection on values(). Also it implements
Filterable&lt;Map.Entry&lt;K,V>> but not Transformable (it's not a pressing need for me).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=334#c10) posted by **finnw1** on 2010-04-23 at 01:46 PM_
---
So will you also be renaming "Ordering" to "FluentComparator"?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=334#c11) posted by **kevinb@google.com** on 2010-04-23 at 02:52 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=334#c12) posted by **blank101** on 2010-04-23 at 04:35 PM_
---
Indeed; any news on when the other fluent horses will be released?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=334#c13) posted by **fry@google.com** on 2011-01-26 at 10:46 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Accepted`
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=334#c14) posted by **kevinb@google.com** on 2011-07-13 at 06:18 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=334#c15) posted by **fry@google.com** on 2011-12-10 at 03:45 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Base`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=334#c16) posted by **wasserman.louis** on 2012-02-16 at 06:48 PM_
---
_(No comment entered for this change.)_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=334#c17) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=334#c18) posted by **em...@soldal.org** on 2012-05-08 at 01:19 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=334#c19) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=334#c20) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=332) created by **amertum** on 2010-02-24 at 01:10 PM_
---
I need explicit ordering with elements that are equals such as
<pre>
Ordering.explicit(a, [b1, b2], c).compare(b1, b2) returns 0
</pre>
explicit signature should be discussed, may be
Ordering.explicit(List&lt;Iterable&lt;T>> elements) should be enough ?
<pre>
Ordering.explicit(UNKNOWN_LOWER, a, [b1, b2], c).compare(d, a) returns -1
or
Ordering.explicit(UNKNOWN_GREATER, a, [b1, b2], c).compare(d, a) returns 1
</pre>
because right now, com.google.common.collect.ExplicitOrdering.rank(T)
I joined a first implementation that handle equals elements fully inspired
from package visible com.google.common.collect.ExplicitOrdering
What do you think of this need ?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=332#c1) posted by **amertum** on 2010-02-24 at 03:49 PM_
---
edit:
because right now, com.google.common.collect.ExplicitOrdering.rank(T)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=332#c2) posted by **amertum** on 2010-02-24 at 03:51 PM_
---
EDIT : when the T value is UNKNOWN
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=332#c3) posted by **kevinb@google.com** on 2010-04-27 at 02:45 PM_
---
On the a-b1-b2-c case, can you provide a more full illustration of what you're really doing, so we can think
about whether there's another way to do it?  I'm not sure that adding a complex new overload to support this
case would pay for itself in the API.
On handling unknown values, I think there's a chain of orderings you can use to accomplish this:
Ordering.explicit(...).nullsFirst().onResultOf(UNKNOWN_TO_NULL_FUNCTION);
It's not very compact, but if this is not a very common operation, that's fine.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=332#c4) posted by **amertum** on 2010-04-27 at 03:49 PM_
---
The way to handle unknown values is fine. It's a nice thought I should had.
It would be great to let extends-able package final class
com.google.common.collect.ExplicitOrdering to simplify customization.
About the a-b1-b2-c case, it happened because we used enum to describe some business
data type.
Let's take an example :
we have enum RABBIT_TYPE { WHITE_RABBIT, SMALL_RABBIT, GRAY_RABBIT, BIG_RABBIT}.
The categorization is wrong among this type because we mixed different kind of
physical attribute (color and height) but we cannot change that easily.
So, for us, color attribute are equals and height attribute are equals but they all
are of the same enum type. Maybe we could create RABBIT_COLOR_TYPE and so on, but java
don't let extends enum and we are stuck with all legacy code that use these enum type.
Hope it helps.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=332#c5) posted by **markdavis@google.com** on 2010-08-25 at 05:29 PM_
---
For equality, I agree that the function is probably the way to go. So for the case mentioned, it could have:
Ordering.explicit(GRAY_RABBIT, BIG_RABBIT).onResultOf(MAP_EQUALS)
where MAP_EQUALS maps WHITE_RABBIT => GRAY_RABBIT, etc.
It might be worth adding a convenience method
onResultOf(Map&lt;F,? extends T> map)
For the null case, I agree that it would be more handy to have something built-in, rather than have to repeat the list (and take the extra lookup cost) in a separate function. Maybe something like:
exceptionsFirst() // any item that would cause a ClassCastException is sorted first (see nullsFirst)
exceptionsLast() // any item that would cause a ClassCastException is sorted last (see nullsLast)
or
exceptionsAsNulls() // items causing exceptions are treated as nulls for ordering.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=332#c6) posted by **ray.j.greenwell** on 2010-10-14 at 08:16 PM_
---
I want to provide a default ordering for the "nulls".
Example: I have a Map&lt;String, Object> containing a bunch of labeled fields of userdata. There are some common fields that are expected to be present like "userId", or "email", but may not be, and there may be many more fields, some added in the future.
I want an ordering where "userId" comes first, then "email", followed by any other fields in alphabetical order.
Does that clarify the use case?
What I ended up doing was destructively modifying the map: iterating through a List of "known fields", and adding them in order and removing them from the map. Then I sorted the remaining keys and added those.
Devil's advocate: probably the proper way to do this is to have one's "known fields" in an Enum, with every possible field listed, plus one at the end called CUSTOM. Then have a FieldName class that has one of two constructors: one that takes the enum (and validates that null or CUSTOM is not passed-in) and one that takes a String (for custom fields). This class is Comparable and sorts first by enum and then by the String...
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=332#c7) posted by **kevinb@google.com** on 2010-10-16 at 05:26 PM_
---
At this point I am generally sympathetic to the notion that Ordering.explicit as currently implemented is insufficient, and we should come up with the thing that can do all the things that users need.  I don't know what that will look like exactly, yet, but am open to hear specific proposals
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=332#c8) posted by **fry@google.com** on 2011-01-26 at 10:45 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Accepted`
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=332#c9) posted by **amertum** on 2011-02-01 at 10:12 PM_
---
Some methods signature ideas to handle equality :
as for this ordering : WHITE_RABBIT = GRAY_RABBIT < SMART_RABBIT < FAST_RABBIT < SMALL_RABBIT = BIG_RABBIT
Ordering.explicit(newArrayList(WHITE_RABBIT, GRAY_RABBIT), newArrayList(SMART_RABBIT), newArrayList(FAST_RABBIT), newArrayList(SMALL_RABBIT, BIG_RABBIT));
Ordering.explicit(Iterable&lt;Iterable&lt;T>> elements)
or using newArrayList alias
Ordering.explicit(eq(WHITE_RABBIT, GRAY_RABBIT), explicit(SMART_RABBIT, FAST_RABBIT), eq(SMALL_RABBIT, BIG_RABBIT));
or method chaining (looks nice)
Ordering.explicit().eq(WHITE_RABBIT, GRAY_RABBIT).explicit(SMART_RABBIT, FAST_RABBIT).eq(SMALL_RABBIT, BIG_RABBIT);
or builder
Ordering.explicitBuilder().ascending().eq(WHITE_RABBIT, GRAY_RABBIT).then(SMART_RABBIT, FAST_RABBIT).eq(SMALL_RABBIT, BIG_RABBIT).build();
Ordering.explicitBuilder().eq(WHITE_RABBIT, GRAY_RABBIT).lowerThan(SMART_RABBIT, FAST_RABBIT).eq(SMALL_RABBIT, BIG_RABBIT).build();
Which one do you prefer ? Other ideas ?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=332#c10) posted by **kevinb@google.com** on 2011-07-13 at 06:18 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=332#c11) posted by **kevinb@google.com** on 2011-07-16 at 08:37 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Accepted`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=332#c12) posted by **goo...@sa.me.uk** on 2011-11-10 at 10:53 PM_
---
I'd like to be able to this:
Ordering.explicit(List&lt;T>).unknownsLast().compound(Comparator&lt;T>)
So that I can order by the list, then by the comparator when the item isn't in the list. Currently I have to add all remaining possible items to the end of the list pre-sorted by the second Comparator.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=332#c13) posted by **fry@google.com** on 2011-12-10 at 03:44 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Collect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=332#c14) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=332#c15) posted by **drmeths** on 2013-10-01 at 09:43 AM_
---
The proposed solution earlier in this thread requires a lot of unnecessary code, and needs to use the explicit list twice in the setup chain:
Ordering.explicit(...).nullsFirst().onResultOf(UNKNOWN_TO_NULL_FUNCTION);
I think this proposed syntax is a good solution in keeping with the general chained approach to building Orderings.
Ordering.explicit(List&lt;T>).unknownsLast().compound(Comparator&lt;T>)
In order to achieve this and to leverage the existing rank map within ExplicitOrdering we need to have access to this.  I think the neatest way to do this would be to make an inner class of ExplicitOrdering that acts (similarly to nullsFirstOrdering) as a guard and uses the rank map to check for the existence of left and right before deferring to ExplicitOrdering.
I would propose the following API changes to allow explicit ordering to take this form in order to handle unknown objects.
1) Change the visibility of ExplicitOrdering&lt;T> to public
2) Change the factory methods for .explicit(...) in Collection to return ExplicitOrdering&lt;T> rather than Ordering&lt;T>
3) Add the following methods to ExplicitOrdering&lt;T>
public Ordering&lt;T> unknownsFirst()
public Ordering&lt;T> unknownsLast()
I have a working prototype for this including tests if anyone is interested in looking at it.
We still want to do some internal experimentation and potential-usage research.
(1) is #1542. Can you post there with some benchmarks for the performance gains you'd get from `Iterable` handling?
Performance concerns are something we haven't see much in the past. (Possibly that's because passing a plain `Iterable` would perform about as poorly as `newArrayList(iterable)` already does, since we basically need to copy it to a list internally, while a `Queue` or other `Collection` should be better.)
Sorry, it's not that we depend on having a `List`. It's just that we copy its contents into an `ImmutableMap.Builder`, and we presize that builder based on the size of the input. If the input is any kind of `Collection` (as in your case), that works. If it's a plain `Iterable`, then we can't presize. The code will still work, but we'll be resizing the `Builder` as we go, so you'll end up with almost the same effect as if you copy to a `List` yourself.
But again, this doesn't apply to your use case.
 Edit: We could still make the signature _accept_ an `Iterable`, do an `instanceof Collection` test, and presize if the _runtime_ type is `Collection`.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=329) created by **ogregoire** on 2010-02-23 at 09:45 AM_
---
Would it be possible to add some kind of List that has a predefined limited
size?
It is different in a normal List in the way that the add method will not be
usable when adding new elements; but it is not an array because its size is
The implementation would be the same of an ArrayList, and would grow like
an ArrayList, except that the internal array would never grow above the
defined value.
Some may say that the ForwardingList would fit the job, but I disagree
because if I use an ArrayList as concrete implementation, that list's
be used. Some other may think about the Arrays.asList, but this one's size
is simply not modifiable.
When the maximum size is reached, and the add method is called, some new
ensureCapacity method is called.
Some similar other collections may be created, but in this case, I think
using a ForwardingXxxx would perfectly fit the job.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=329#c1) posted by **kevinb@google.com** on 2010-02-23 at 03:51 PM_
---
This sounds similar to the JDK's ArrayBlockingQueue.  Would that work for you (even though it does not
implement the List interface)?
---
Positive points of that class (regarding the initial requirements):
- the methods do approximately what I want; (I don't know why, but I didn't think
- It isn't a List (if I had to always manipulate "new ArrayList" and "new
ArrayBlockingQueue", it would extremely poor performances); I can't easily access the
nth element (getting it, setting it)
- Seems thread-safe (since is a bloquing queue), which in some cases may induce poor
performances as well.
- Initiates an array of size defined initially, where I expect it rather to grow when
needed, but no more than the initial size. But, this requirement is not really used
by my team.
- Quoting the doc: "By default, this ordering is not guaranteed."
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=329#c3) posted by **kevinb@google.com** on 2010-04-23 at 08:36 PM_
---
I think the ForwardingList approach should be sufficient for this case. Note that you
can call .trimToSize() on the ArrayList if you're concerned it's too big.
---
**Status:** `WontFix`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=320) created by **finnw1** on 2010-01-30 at 09:49 AM_
---
I often want to create a Map from its entrySet.  I've rolled my own version
of this in a few of my projects.  It would be nice to have a standard API
for it.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=320#c1) posted by **finnw1** on 2010-12-08 at 12:07 PM_
---
The interface proposed in Issue #330 would also solve this.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=320#c2) posted by **fry@google.com** on 2011-01-28 at 03:58 PM_
---
Why not simply use ImmutableMap.copyOf(Map)?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=320#c3) posted by **fry@google.com** on 2011-01-28 at 04:02 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=320#c4) posted by **kevinb9n** on 2011-01-28 at 09:00 PM_
---
I think the answer to that question is "because what have is a Set&lt;Entry>, not a Map."  I am not clear on why exactly users find themselves in this situation, but plan to look deeper into it.
---
**Status:** `Accepted`
---
I regularly start with Iterable&lt;E> and end up with Iterable&lt;Map.Entry&lt;K,V>> where sometimes E=K or E=V, it's much simpler to keep working with Iterable&lt;Map.Entry&lt;K,V>> and only in the end instantiate a Map&lt;K,V>.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=320#c6) posted by **wasserman.louis** on 2011-03-08 at 08:26 PM_
---
It strikes me that while an Iterable&lt;Map.Entry&lt;K,V>> does not always represent the entrySet() of a Map, it could be the entrySet() of a Multimap.  Perhaps we should look at it in that way instead?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=320#c7) posted by **kevinb@google.com** on 2011-03-09 at 03:07 PM_
---
That is probably the best case anyone's made yet for the value of methods accepting Iterable&lt;Map.Entry>!  I am smacking myself for never thinking of it this way -- how many times I've lamented that Map and Multimap implement no common interface!
If someone would look through the whole API for any examples of methods that would really want to accept either Map or Multimap (meaning that they can plausibly deal with duplicate keys), then we can look at the feasibility of It&lt;Entry>-accepting versions of those methods.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=320#c8) posted by **wasserman.louis** on 2011-03-09 at 05:53 PM_
---
I'm not sure I follow.
I haven't yet found any methods that "would really want to accept either Map or Multimap," but here's the point I was initially trying to make:
If we're presented with an Iterable&lt;Map.Entry&lt;K,V>>, we don't have any guarantee that the keys are distinct.  (Map.entrySet() returns a Set&lt;Entry&lt;K,V>> for precisely the reason that we're certainly guaranteed that there are no duplicate entries.)  However, any Iterable&lt;Map.Entry&lt;K,V>> could be the entries() of a Multimap, regardless of duplication.
In particular, I'd certainly support a LinkedListMultimap.create(Iterable&lt;Entry&lt;K,V>>), with the result that the entries() of the resulting multimap would be the same entries in the same order.
Another, related, possibility would be Multimap.putAll(Iterable&lt;Entry&lt;K,V>>), since there is currently no putAll(Map&lt;K,V>).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=320#c9) posted by **j...@nwsnet.de** on 2011-03-31 at 12:03 PM_
---
I'd like to see the addition of methods to create a map from `Iterable<Map.Entry<K, V>>`&nbsp;-- preferably both mutable and immutable.
I'm not sure about the MultiMap-related discussion here; currently I'm just concerned about basic maps.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=320#c10) posted by **cgdecker** on 2011-04-14 at 03:54 AM_
---
MapJoiner is an example of something I'd like to see support Multimap as well as Map... I wanted to be able to do this for some code I was playing with recently. I wrote up the code for that and was going to submit a separate issue, but was reminded of this.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=320#c11) posted by **cgdecker** on 2011-04-14 at 04:01 AM_
---
Just realized that supporting Multimap directly in MapJoiner would break the package-dependency rule I seem to recall seeing mentioned at some point, but Iterable&lt;Map.Entry<?, ?>> wouldn't.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=320#c12) posted by **kevinb@google.com** on 2011-07-13 at 06:18 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=320#c13) posted by **fry@google.com** on 2011-12-10 at 03:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Collect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=320#c14) posted by **wasserman.louis** on 2012-01-11 at 05:13 PM_
---
_Issue #861 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=320#c15) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=320#c16) posted by **wasserman.louis** on 2012-02-17 at 07:08 PM_
---
...I observe that creating maps from iterables of entries is listed in the Idea Graveyard.  (I'm working on justifying it, though...?)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=320#c17) posted by **finnw1** on 2012-02-17 at 07:13 PM_
---
@wasserman.louis, see also kevinb's comment on Issue 385
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=320#c18) posted by **wasserman.louis** on 2012-02-17 at 07:17 PM_
---
Ah.  I did not see that.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=320#c19) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=320#c20) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=320#c21) posted by **wasserman.louis** on 2012-08-14 at 07:18 PM_
---
_Issue #1107 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=320#c22) posted by **wasserman.louis** on 2012-08-14 at 07:19 PM_
---
_Issue #1107 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=320#c23) posted by **lukes@google.com** on 2012-08-14 at 07:23 PM_
---
_Issue #1107 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=320#c24) posted by **jaredjacobs** on 2012-10-05 at 11:39 PM_
---
Kevin, to contribute to your research effort, here's the reason I currently need this: Someone implemented something as a List&lt;Pair> that really should have been a Map. I'm writing some temporary translation code for backwards compatibility. (Yes, it's temporary, but I'd still like it to be concise and readable.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=320#c25) posted by **kak@google.com** on 2012-10-23 at 04:45 PM_
---
_Issue #1116 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=320#c26) posted by **kevinb@google.com** on 2012-10-23 at 04:45 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=320#c27) posted by **ceefour666** on 2012-11-03 at 03:45 PM_
---
I highly support this.
1. static ImmutableMultimap.copyOf(Iterable&lt;Map.Entry&lt;K, V>>)
2. (instance) Multimap.putAll(Iterable&lt;Map.Entry&lt;K, V>>)
3. I would love to have instance-level Map.putAll(Iterable&lt;Map.Entry&lt;K, V>>) but since
&nbsp;&nbsp;&nbsp;it's part of JDK then this would do:
&nbsp;&nbsp;&nbsp;static Maps.putAll(Map&lt;K, V>, Iterable&lt;Map.Entry&lt;K, V>>)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=320#c28) posted by **lowasser@google.com** on 2012-11-23 at 04:05 PM_
---
http://stackoverflow.com/questions/13527055/how-to-create-a-treemultimap-from-an-iterable-collection/13532402#13532402 seems like a genuinely valid use case for the Multimap variant.  Tldr:  Iterables.limit on an Iterable of entries is a reasonable need, though I'd imagine that applies only when the entries have some predictable order.  The Map variant would usually be something like Ordering.least of for sorted maps?
---
Also, in gson, the JsonObject has an entrySet() method - but it would be nice to directly convert that into a Map (instead of littering iteration code everywhere).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=320#c30) posted by **lowasser@google.com** on 2014-09-26 at 09:43 PM_
---
We were convinced internally that there was a need for this; it's been added, and the change will be mirrored out soon.
---
**Status:** `Fixed`
**Owner:** lowasser@google.com
Updated, thanks.  _[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=309) created by **hein.meling** on 2010-01-05 at 11:15 PM_
---
Suggest to provide:
sum()
average()
for Ints, Longs, Floats etc.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=309#c1) posted by **kevinb@google.com** on 2010-01-06 at 01:00 AM_
---
Agreed.
The best way to implement Longs.average() is a somewhat interesting puzzle.
---
**Status:** `Accepted`
---
I think I'm missing something.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=309#c3) posted by **hein.meling** on 2010-01-06 at 08:12 AM_
---
About varargs; currently I have this:
int sum(Collection&lt;Integer> c)
in my project. Not sure if such a collection can be transformed into an array without copying; if so varargs are
fine, otherwise I would like to have both.
Another issue that come to mind when I started to think about test cases for this was: what to return if the sum
exceeds the limit of its primitive type. (maybe this was what you were referring to as a puzzle with
Longs.average()?)
We have to avoid any silent overflows for this. Maybe the return type should be Number to allow
BigInteger/Decimal to be returned for those cases.
---
for the Longs.average() wouldn't it be interesting to use BigInteger as internal
mechanics?
Or use an integer to keep track of the number of times the overflow (or underflow) is
reached.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=309#c5) posted by **kevinb@google.com** on 2010-01-06 at 04:54 PM_
---
Yup, BigInteger is the simple solution, but I'm quite curious to benchmark simpler
appropriate.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=309#c6) posted by **fry@google.com** on 2011-01-26 at 10:16 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=309#c7) posted by **j...@nwsnet.de** on 2011-01-27 at 09:07 AM_
---
I'd like to have each method to accept iterable, too.
While looking at my custom math utilities: What about rate and percentage calculation? Like this:
&nbsp;&nbsp;public static double calculateRate(double count, double total) {
&nbsp;&nbsp;&nbsp;&nbsp;// Compare against 0.0 to prevent infinity as result.
&nbsp;&nbsp;&nbsp;&nbsp;return total == 0.0 ? 0.0 : count / total;
&nbsp;&nbsp;}
This might be useful to implement for multiple primitives as one might be dealing with doubles or floats etc. depending on the application.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=309#c8) posted by **wasserman.louis** on 2011-03-15 at 05:24 PM_
---
I'm up for writing this, including some attempts I've thought of for "simpler alternatives."
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=309#c9) posted by **raymondofrish** on 2011-03-16 at 02:01 AM_
---
How about something like the following? Not thorough benchmarked or optimized, but surely better than BigInteger, no? I hear there's a nice microbenchmarking tool available for Java...
```
public static long average(Iterable<Long> longs) {
long count = Iterables.size(longs);
long integerSum = 0;
long remainderSum = 0;
for (long num : longs) {
integerSum += num / count;
remainderSum += num % count;
}
return integerSum + remainderSum / count;
}
```
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=309#c10) posted by **kevinb@google.com** on 2011-07-13 at 06:18 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=309#c11) posted by **cpovirk@google.com** on 2011-07-13 at 08:40 PM_
---
_(No comment entered for this change.)_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=309#c12) posted by **blank101** on 2011-07-19 at 07:06 PM_
---
Recollecting back to my numerical methods class, there are also some interesting issues for the floating point primitives when calculating sum/average values beyond (over|under)flow.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=309#c13) posted by **wasserman.louis** on 2011-10-18 at 11:26 PM_
---
Revisiting...
I'm thinking we might just provide sum(), which has a less ambiguous return type.
In particular:
long IntMath.sum(int... ints)
BigInteger LongMath.sum(long... longs)
since we can safely assume that the sum of an array of ints will fit into a long.  (The result will fit in 96 bits, so we can do intermediate accumulation with smaller types, too...)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=309#c14) posted by **j...@nwsnet.de** on 2011-10-19 at 07:53 AM_
---
So iterables are not supported as arguments? I've got a lot of them floating around when creating reports.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=309#c15) posted by **dancerjohn** on 2011-10-19 at 10:35 AM_
---
You can use Longs.toArray(Lists.newArrayList(myIterable)) to convert to an array and pass to a varargs.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=309#c16) posted by **j...@nwsnet.de** on 2011-10-19 at 12:31 PM_
---
That does two copies. Seems a little unnecessary, considering that the "for each" loop introduced in Java 5 can iterate both arrays and iterables.
As implementing the loop twice (for each number type) would be somewhat unattractive, one might convert the other way round, i.e. from array to iterable. `Iterators.forArray`&nbsp;exists, and it might be the time to add it to `Iterables`, too. Then, that (or `Arrays.asList(array).iterator()`, as mentioned in a code comment) might more efficient.
For the record, a very common use case in my projects is retrieving a total field's value from some iterable of objects using `transform`&nbsp;and then summing up those numbers.
---
Can't you have Collections instead of Iterables ? You speak about the transform case, but to be honest, I never had the case where I wanted to perform only one action on my transformed list, so it was always "persisted" in a collection in order to be used more than once without having to re-transform it. Don't forget that Collection2 contains a transform(Collection,Function) method as well...
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=309#c18) posted by **j...@nwsnet.de** on 2011-10-19 at 07:23 PM_
---
Well, as long as I can get away with passing just iterables around, I try to do it. Maybe I'm overestimating the memory efficiency here (compared to, say, generators in Python).
OTOH, I had the impression that one tried to avoid arrays in favor of collections, especially in Guava. Also, what is a common use case that supports the idea of accepting _varargs_? I'd expect to either have very few numbers which I then could just easily sum up using the classic `+`&nbsp;operator, or a whole bunch of numbers that are in some kind of container (usually a collection, not an array [see my expectation above], but I don't know how popular number crunching in Java with Guava is) anyway.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=309#c19) posted by **kevinb@google.com** on 2011-10-20 at 06:17 AM_
---
"avoid arrays in favor of collections" -- definitely, for _Object_ arrays, but primitive arrays do make some sense.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=309#c20) posted by **fry@google.com** on 2011-12-10 at 03:42 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Primitives`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=309#c21) posted by **j...@nwsnet.de** on 2011-12-15 at 09:32 AM_
---
I revisited the use of my custom sum methods and it turns out that they are called with an `Iterable`&nbsp;in most cases because `Iterables.transform`&nbsp;is often used beforehand (on values that mostly already are in `Iterable`s, too) to extract an attribute. The few cases that pass a `Collection`&nbsp;are those that call `Map.values()`.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=309#c22) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=309#c23) posted by **kevinb@google.com** on 2012-05-25 at 06:47 PM_
---
I'd like to save the topic of the mean/average for when we look at statistics calculation in general.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=309#c24) posted by **wasserman.louis** on 2012-05-25 at 08:30 PM_
---
We need more detail, though:
1. What is the return type of sum(int[])?  It always fits in a long, but...
2. What is the return type of sum(long[])?  BigInteger, or long?
3. Do we deal with floats and doubles?  Do we take steps to reduce rounding error?  (There are steps that can be taken.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=309#c25) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=309#c26) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
---
private final &lt;T> long sum(long bias, Iterable&lt;T> ts, Function&lt;T, Integer> transformer) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long sum = bias;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(T t : ts) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum += transformer.apply(t);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return sum;
&nbsp;&nbsp;&nbsp;&nbsp;}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=309#c28) posted by **wasserman.louis** on 2012-06-26 at 01:26 PM_
---
Hrrrrm.  I'd like this method to do very limited things, because if you need it to do _smarter_ things, you can just write the implementation yourself, given that it's only a few lines at the most.
At the moment, I'm leaning towards a very dumb, straightforward implementation.  IntMath.sum(int...) returns an int.  If you want something more sophisticated, whip it up yourself; this is just a convenience method for the most common case.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=309#c29) posted by **orionllmain** on 2013-05-14 at 01:36 PM_
---
int IntMath.sum(int[] array)
int IntMath.average(int[] array)
long LongMath.sum(int[] array)
long LongMath.sum(long[] array)
long LongMath.average(long[] array)
double DoubleMath.sum(int[] array)
double DoubleMath.sum(long[] array)
double DoubleMath.sum(float[] array)
double DoubleMath.sum(double[] array)
double DoubleMath.average(int[] array)
double DoubleMath.average(long[] array)
double DoubleMath.average(double[] array)
BigInteger BigIntegerMath.sum(int[] array)
BigInteger BigIntegerMath.sum(long[] array)
BigInteger BigIntegerMath.sum(BigInteger[] array)
BigInteger BigIntegerMath.average(int[] array)
BigInteger BigIntegerMath.average(long[] array)
BigInteger BigIntegerMath.average(BigInteger[] array)
@lowasser shall we bring this to API review?  _[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=275) created by **cpovirk+external@google.com** on 2009-10-26 at 05:10 PM_
---
Some of our GWT tests currently accept JavaScriptException instead of
NullPointerException.  It would be nice to eliminate this diff between GWT
and non-GWT tests.
Whether we do this for 1.0 depends on whether it gets in our way when
getting the tests out the door.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=275#c1) posted by **kevinb9n** on 2009-10-26 at 05:15 PM_
---
Honestly, I am not even viewing "getting the tests out the door" as critical for 1.0.
We'll just run them internally. Then after 1.0 we can move everything over to guava,
and then work on getting the tests working there.  Hopefully by then there'll have
been time to make more of the tests "amphibious" than are currently.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=275#c2) posted by **cpovirk+external@google.com** on 2009-10-26 at 05:39 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Milestone-Post1.0`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=275#c3) posted by **kevinb@google.com** on 2010-07-30 at 03:53 AM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Milestone-Post1.0`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=275#c4) posted by **fry@google.com** on 2011-01-26 at 10:16 PM_
---
_(No comment entered for this change.)_
---
**Owner:** cpov...@google.com
**Labels:** `Type-Defect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=275#c5) posted by **kevinb@google.com** on 2011-01-27 at 01:31 PM_
---
Chris, is this ancient, or still relevant?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=275#c6) posted by **kevinb@google.com** on 2011-01-27 at 01:47 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Tests`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=275#c7) posted by **kevinb@google.com** on 2011-01-27 at 01:57 PM_
---
_(No comment entered for this change.)_
---
**Owner:** ---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=275#c8) posted by **cpovirk@google.com** on 2011-01-27 at 06:41 PM_
---
Just barely still relevant:
$ grep JavaScriptException -r javatests/com/google/common/
javatests/com/google/common/primitives/gwt/CharsTest.java:import com.google.gwt.core.client.JavaScriptException;
javatests/com/google/common/primitives/gwt/CharsTest.java:    } catch (JavaScriptException expectedInGwt) {
javatests/com/google/common/primitives/gwt/BytesTest.java:import com.google.gwt.core.client.JavaScriptException;
javatests/com/google/common/primitives/gwt/BytesTest.java:    } catch (JavaScriptException expectedInGwt) {
javatests/com/google/common/primitives/gwt/DoublesTest.java:import com.google.gwt.core.client.JavaScriptException;
javatests/com/google/common/primitives/gwt/DoublesTest.java:    } catch (JavaScriptException expected) {
javatests/com/google/common/primitives/gwt/IntsTest.java:import com.google.gwt.core.client.JavaScriptException;
javatests/com/google/common/primitives/gwt/IntsTest.java:    } catch (JavaScriptException expectedInGwt) {
javatests/com/google/common/primitives/gwt/LongsTest.java:import com.google.gwt.core.client.JavaScriptException;
javatests/com/google/common/primitives/gwt/LongsTest.java:    } catch (JavaScriptException expectedInGwt) {
I don't know offhand whether primitives has other reasons to have separate GWT and non-GWT tests; the larger issue here is probably to merge them, starting with the JavaScriptException=>NPE change.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=275#c9) posted by **kevinb@google.com** on 2011-07-13 at 06:18 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=275#c10) posted by **fry@google.com** on 2011-12-10 at 03:41 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Primitives`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=275#c11) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=275#c12) posted by **kevinb@google.com** on 2012-05-30 at 07:49 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Tests`, `Type-Dev`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=275#c13) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=271) created by **cpovirk+external@google.com** on 2009-10-23 at 09:04 PM_
---
Issue 205, comment 32 by alen_vrecko@yahoo.com notes that serializing a
HashBiMap results in an empty HashBiMap -- no elements, but no error.
We should either clearly break GWT serialization for such classes...
&nbsp;&nbsp;private HashBiMap() {
->
&nbsp;&nbsp;private HashBiMap(Void void) {
...or we should write the serializers.  Probably the latter.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=271#c1) posted by **alen_vre...@yahoo.com** on 2009-10-24 at 01:11 PM_
---
Thanks for opening this issue. Maybe there is a good reason why HashBiMap is not
serializable? Anyway, as disabling goes:
My fist idea is; How about putting @BreakDefaultGwtSerialization on the classes that
should not be gwt serializable (but they or their superclass implement
io.Serializable). The build rule will then put an extra field at the end of the file
that is not gwt serializable. Serialization will then blow up.
There is a missing CustomFieldSerializer for ImmutableBiMap. It is gwt serializable =
true.
I think you can copy the emulated classes from super to collect (next to serializers).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=271#c2) posted by **hayward.chan** on 2009-11-02 at 10:39 PM_
---
nowadays, we can add rpc.blacklist to prevent them from getting gwt serialized.
http://code.google.com/p/google-web-toolkit/source/browse/trunk/user/src/com/google/gwt/user/RemoteService.gwt.xml
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=271#c3) posted by **kevinb9n** on 2009-11-06 at 01:26 AM_
---
GWT support is decommissioned for 1.0.
---
**Labels:** -`Milestone-1.0`, `Milestone-Post1.0`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=271#c4) posted by **kevinb@google.com** on 2010-07-30 at 03:53 AM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Milestone-Post1.0`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=271#c5) posted by **fry@google.com** on 2011-01-26 at 10:15 PM_
---
_(No comment entered for this change.)_
---
**Owner:** cpov...@google.com
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=271#c6) posted by **kevinb@google.com** on 2011-01-27 at 01:58 PM_
---
_(No comment entered for this change.)_
---
**Owner:** ---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=271#c7) posted by **kevinb@google.com** on 2011-01-27 at 02:10 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Defect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=271#c8) posted by **kevinb@google.com** on 2011-07-13 at 06:18 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=271#c9) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=271#c10) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=271#c11) posted by **kevinb@google.com** on 2012-06-22 at 06:57 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-General`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=269) created by **kevinb9n** on 2009-10-22 at 10:38 PM_
---
The things that we may need to make gwt-serializable still:
All Functions
All Predicates (alwaysTrue() and alwaysFalse() already done)
more detail:  see the GWT column of
http://spreadsheets.google.com/ccc?
key=0AoFn3TZKLWTUcGQ4ZEFReUhiZGV4UTQ2Yk50NzhRWWc&hl=en
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=269#c1) posted by **kevinb9n** on 2009-10-30 at 05:20 PM_
---
_(No comment entered for this change.)_
---
**Owner:** ---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=269#c2) posted by **kevinb9n** on 2009-11-06 at 01:26 AM_
---
GWT support is decommissioned for 1.0.
---
**Labels:** -`Milestone-1.0`, `Milestone-Post1.0`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=269#c3) posted by **kevinb@google.com** on 2010-07-30 at 03:53 AM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Milestone-Post1.0`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=269#c4) posted by **fry@google.com** on 2011-01-26 at 10:14 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Task`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=269#c5) posted by **fry@google.com** on 2011-01-26 at 10:15 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Task`, `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=269#c6) posted by **kevinb@google.com** on 2011-07-13 at 06:18 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=269#c7) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=269#c8) posted by **kevinb@google.com** on 2012-05-30 at 07:41 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Enhancement-Temp`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=269#c9) posted by **kevinb@google.com** on 2012-05-30 at 07:45 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement-Temp`, `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=269#c10) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=269#c11) posted by **kevinb@google.com** on 2012-06-22 at 06:57 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-General`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=243) created by **sberlin** on 2009-09-18 at 02:09 PM_
---
It's often necessary (or useful) to refactor code that's been serialized.
It's a PITA to require old classes to sit around just for the sake of
deserializing.  One approach to this is to avoid ever serializing classes
been using an approach that locates the newer class on-the-fly, not
requiring the old class to even exist anymore.  We've been using this
approach for the past 5-6 years or so, and it works wonders.
See:
https://www.limewire.org/fisheye/browse/~raw,r=1.17/limecvs/components/common/src/main/java/org/limewire/util/ConverterObjectInputStream.java
The basic idea is you tell it "this is the package or name of my old
class", and "this is the package or name of my new class".  If you
construct your ObjectInputStream as a ConverterObjectInputStream instead,
it will transparently return the new classes, without even requiring that
the old classes exist on the classpath (or anywhere, for that matter).
We initially developed this back when we migrated off of
com.sun.java.util.collections and began using java.util... and have made
great use of it to allow us to refactor with ease.
Feel free to take the code & modify as necessary for inclusion (such as
removing our built-in conversions referencing the limewire code).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=243#c1) posted by **jared.l.levy** on 2009-09-18 at 09:19 PM_
---
Thanks for the suggestion.
For now, we'll focus on making sure our current serialized forms are correct and
adding tests to verify that. We don't want to delay the 1.0 release by adding any
additional serialization functionality.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=243#c2) posted by **kevinb9n** on 2009-09-21 at 05:50 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Enhancement`, `Milestone-Post1.0`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=243#c3) posted by **kevinb@google.com** on 2010-07-30 at 03:53 AM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Milestone-Post1.0`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=243#c4) posted by **fry@google.com** on 2011-01-26 at 10:07 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Accepted`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=243#c5) posted by **fry@google.com** on 2011-01-26 at 10:24 PM_
---
https://bitbucket.org/frostwire/frostwire/src/97d134a3afe4/components/common/src/main/java/org/limewire/util/ConverterObjectInputStream.java
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=243#c6) posted by **kevinb@google.com** on 2011-07-13 at 06:18 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=243#c7) posted by **kevinb@google.com** on 2011-08-01 at 09:16 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=243#c8) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=243#c9) posted by **kevinb@google.com** on 2012-03-02 at 06:51 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-General`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=243#c10) posted by **kevinb@google.com** on 2012-05-30 at 07:41 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Enhancement-Temp`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=243#c11) posted by **kevinb@google.com** on 2012-05-30 at 07:45 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement-Temp`, `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=243#c12) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=218) created by **rwallace1979** on 2009-08-12 at 11:37 PM_
---
I find myself always wanting to iterate over a collection to aggregate the
data and wishing Google Collections had a fold operation.
An implementation can be found on StackOverflow,
&lt;http://stackoverflow.com/questions/950751/how-to-implement-a-list-fold-in-java/951337#951337>.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c1) posted by **rwallace1979** on 2009-08-13 at 12:07 AM_
---
A possibly easier implementation is to create a new FoldFunction type.  And implement
foldLeft as
```
static <A, B> A foldLeft(Iterable<B> xs, A z, FoldFunction<A, B> f)
{
A p = z;
for (B x : xs)
{
p = f.apply(p, x);
}
return p;
}
interface FoldFunction<A, B>
{
A apply(A a, B b);
}
```
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c2) posted by **andre.ruediger** on 2009-08-13 at 08:52 AM_
---
What about a compress() function? (Maybe there's a better name.) compress() would
have to return null in the case of failure. Like this:
```
static <T> Iterable<T> compress(Iterable<T> iterable, CompressFunction<T> f) {
Iterator<T> i = iterable.iterator();
if (!i.hasNext())
return Collections.emptyList();
T first = i.next();
if (!i.hasNext())
return ImmutableList.of(first);
Stack<T> compressed = new Stack<T>();
compressed.push(first);
while (i.hasNext()) {
T t = i.next();
T c = f.compress(compressed.peek(), t);
if (c != null) {
compressed.pop();
compressed.push(c);
} else {
compressed.push(t);
}
}
return ImmutableList.copyOf(compressed);
}
interface CompressFunction<T> {
T compress(T t1, T t2);
}
class Range {
int from, to;
}
class CompressRanges implements CompressFunction<Range> {
public Range compress(Range r1, Range r2) {
if (r1.from > r2.to || r1.to < r2.from)
return null;
Range r = new Range();
return r;
}
}
```
I'd like to hear your input on this. Do my random thoughts make sense to anybody?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c3) posted by **jvdneste** on 2009-08-14 at 09:42 AM_
---
I prefer the term reduce, and i'd also like to see it in the library.
```
/** (a, b, c, d) -> f(f(f(a, b), c), d) */
public static <T> T reduce(final Iterable<? extends T> gen, final Function2<? super
T, ? super T, ? extends T> f) {
final Iterator<? extends T> it = gen.iterator();
if (!it.hasNext()) {
return null;
}
T result = it.next();
while (it.hasNext()) {
result = f.apply(result, it.next());
}
return result;
}
/** (a, b, c, d), initial -> f(f(f(f(initial,a), b), c), d) */
public static <X,Y> X reduce(final Iterable<? extends Y> gen, final X initial, final
Function2<? super X, ? super Y, ? extends X> function) {
final Iterator<? extends Y> it = gen.iterator();
if (!it.hasNext()) {
return initial;
}
X acc = initial;
while (it.hasNext()) {
acc = function.apply(acc, it.next());
}
}
```
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c4) posted by **jvdneste** on 2009-08-18 at 08:42 AM_
---
This requires the inclusion of a two-argument functor interface. I've seen negative
reactions on previous requests so I'm thinking there's little chance of this one
getting accepted. The fact that it keeps coming back accounts for something though.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c5) posted by **kevinb9n** on 2009-08-18 at 09:51 PM_
---
I am not specifically declaring this to be out of scope, but it's important to realize
main reason we have Predicate at all is just that it's hard to filter an iterator by
hand, and a filter() library method needs something like that, so there it is. The
main reason we have Function is that MapMaker needs it.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c6) posted by **kevinb9n** on 2009-09-17 at 04:59 PM_
---
(remember that "Accepted" != "promise that we will do it")
---
**Status:** `Accepted`
**Labels:** `post-1.0`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c7) posted by **kevinb9n** on 2009-09-17 at 05:45 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`post-1.0`, `Milestone-Post1.0`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c8) posted by **kevinb9n** on 2009-09-17 at 05:57 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c9) posted by **kevinb@google.com** on 2010-07-30 at 03:53 AM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Milestone-Post1.0`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c10) posted by **dan.rosen** on 2010-10-09 at 12:17 AM_
---
A two arg version of Function isn't necessary.  Just some sort of tuple type, let's say Pair&lt;A, B>.  So Rich's implementation reduces to:
static &lt;A, B> A foldLeft(Iterable&lt;B> xs, A z, Function&lt;Pair&lt;A, B>, A> f)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A p = z;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (B x : xs)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p = f.apply(new Pair(p, x));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return p;
&nbsp;&nbsp;&nbsp;&nbsp;}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c11) posted by **cgdecker** on 2011-04-08 at 03:30 AM_
---
_Issue #446 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c12) posted by **cgdecker** on 2011-04-08 at 04:48 AM_
---
Creating a Pair type and using it like that just makes the semantics of the function less clear and forces lots of Pair objects to be created when they needn't be.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c13) posted by **gscerbak** on 2011-05-10 at 11:39 AM_
---
I have written Iterable around AbstractLinkedIterator with static factory method called unfold which tkes first element and a Function to compute the next element.
Then I added static factory methods first() and rest() for Functions decomposing Iterables using Iterables.getFirst() and Iterables.skip().
Finally fold look as simply as this:
```
public static final <E, A> A fold(final Iterable<E> iterable,
final Function<E, A> accumulator) {
final Function<Iterable<E>, Iterable<E>> rest = rest();
final Function<Iterable<E>, E> first = first();
final Iterable<E> generator = Iterables.transform(unfold(iterable, rest),
first);
return Iterables.getLast(Iterables.transform(generator, accumulator));
}
```
The accumulator is simply a function - guava javadocs allow for functions with side effects, so it is possible to store the state of folding in the function itself. This is a trade-off between purity and problems with tuples in Java, resp. creating custom classes just for the accumulated value.
Example:
```
@Test
public final void sum() {
final Function<Integer, Integer> sum = new Function<Integer, Integer>() {
private Integer sum = 0;
public Integer apply(final Integer input) {
sum += input;
return sum;
}
};
assertThat(fold(limit(unfold(1, successor), 100), sum), is(5050));
}
```
If you find this approach useful, just let me know, I will polish the source and I will publish it.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c14) posted by **kevinb@google.com** on 2011-07-13 at 06:18 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c15) posted by **fry@google.com** on 2011-12-10 at 03:40 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Collect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c16) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
---
In my own project I implemented folding as follows:
&nbsp;&nbsp;interface Reducer&lt;A, B> {
&nbsp;&nbsp;&nbsp;&nbsp;A reduce(A a, B b);
&nbsp;&nbsp;}
&nbsp;&nbsp;class Iterables {
&nbsp;&nbsp;&nbsp;&nbsp;static &lt;A, B> A reduce(Iterable&lt;B> xs, A z, Reducer&lt;A, B> reducer);
&nbsp;&nbsp;}
&nbsp;&nbsp;class BigDecimals {
&nbsp;&nbsp;&nbsp;&nbsp;static Reducer&lt;BigDecimal, BigDecimal> sum();
&nbsp;&nbsp;}
With these in place I could reduce a list to a sum as follows:
&nbsp;&nbsp;Iterable&lt;BigDecimal> lineTotals = ...
&nbsp;&nbsp;BigDecimal grandTotal = Iterables.reduce(lineTotals, BigDecimals.sum());
I hope you guys will consider adding this feature to Guava; with this one exception, Guava has always seemed to have exactly what I need for data processing.
If there is interest from the project maintainers in adding this feature, I'd be delighted to do the work and submit a patchset.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c18) posted by **wasserman.louis** on 2012-04-09 at 07:17 PM_
---
FYI, I think we're astronomically more concerned about the API design, the potential for misuse, and our already existing concern over the readability of the functional idioms we provide (pending Java 8), than the difficulty of adding the feature once an API is endorsed, but we'll definitely update this issue if we decide to pursue folds and the like.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c19) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c20) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c21) posted by **phidias51** on 2012-07-09 at 08:21 PM_
---
I recently found myself needing the same type of functionality for calculating basic statistical functions on lists of numbers.  Since the interest within the project seems limited, has anyone given any thought to making this a separate project?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c22) posted by **wasserman.louis** on 2012-07-09 at 08:46 PM_
---
This certainly exists in other projects (functional-java is an example), but...yeah.
(I have to admit, I still don't see what advantage this sort of thing would gain over a traditional for-loop.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c23) posted by **phidias51** on 2012-07-09 at 09:39 PM_
---
In my case I want to be able to do something like this:
Double sum = List.reduce(List&lt;Double> values, SumReduction summation)
Additional classes for StandardDeviation, Mean, Median, Max, Min would also be useful.  Having the interfaces and a couple of simple implementations would make it easier for people to be able to implement more complex mathematical functions.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c24) posted by **wasserman.louis** on 2012-07-10 at 01:04 PM_
---
...I'm still not seeing what possible advantage this would have over methods named e.g. sum(List&lt;Double> values), mean(List&lt;Double> values), median(List&lt;Double> values), etc.  If you write those methods out, they're almost certainly _shorter_ than "functional-style" reducers based on anonymous classes.  If you want to be able to plug different ones in, you're still probably better off with just a Function&lt;List&lt;Double>, Double>.
Furthermore, some of those operations _can't_ be implemented as simple folds.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c25) posted by **phidias51** on 2012-07-10 at 03:53 PM_
---
The problem with creating specific methods like sum, mean, etc is that it's always incomplete in someone's mind.  By creating an interface and a couple of simple implementations, it demonstrates how implementations will be used.  If someone wants to then spinoff an SPI project to implement a more complete set of functions, or to create libraries of different types of functions, they could do that.
Although the Function&lt;List&lt;Double>, Double> complies with the generic signature of the Function interface, it doesn't make sense from a practical sense.  As someone mentioned earlier, the intent of the Function interface is to perform an operation on a each object in a collection with the intent being that you could end up with a transformed copy of the list, or a transformed instance of the original list.
If you accidentally tried to use one of these implementations (of Function&lt;List&lt;Double>, Double>) with Lists.transform, the code would compile, but you would have runtime errors when you ran it.  Therefore, I think a new interface with a different method signature would better communicate the intent of these types of aggregate functions.
Could you give me some examples of  "operations [that] _can't_ be implemented as simple folds"?  I'm not claiming that it's a panacea, nor doubting what you say, merely interested in what you mean.
---
Standard deviation cannot be implemented as a simple fold, since you must first do one pass to determine the mean, then a second pass to accumulate the square of the difference from the mean.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c27) posted by **wasserman.louis** on 2012-07-10 at 10:44 PM_
---
And median can't be implemented as a simple fold, since all the implementations I know of require either multiple passes, or at least O(n) extra storage, which kind of defeats the point.
I'm still not really getting the point, though.  If you want to write a project to implement more functions...you write a library with a bunch of static methods: foo(List&lt;Double>), or whatever.  (I also vaguely recall that Guava's been working on some statistics utilities, which we might see sometime in the future...)
In any event, the only advantage I can think of to making these objects, instead of e.g. static methods, is being able to pass them around polymorphically and then apply them...which is a need satisfied by Function&lt;List&lt;Double>, Double>.  I'm not suggesting anyone use Lists.transform with such a function, but I am saying that you can pass them around polymorphically and call their apply() method, which seems to me like it covers the one advantage objects would have over functions.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c28) posted by **ian.b.robertson** on 2012-07-24 at 05:09 PM_
---
&lt;pedantry>Standard deviation could be implemented with a fold, although the accumulator would need to be accumulating both sum(x_i) and sum(x_i)^2.&lt;/pedantry>
That said, I agree with Louis - for loops aren't that bad, and they perform well.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c29) posted by **bytefu** on 2013-08-30 at 08:29 AM_
---
> That said, I agree with Louis - for loops aren't that bad, and they perform well.
> Assembler code isn't that bad, and it performs well. Does it mean that we don't need C and Java? 'fold' is a standard idiom for processing lists, after all.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c30) posted by **ceefour666** on 2013-08-30 at 08:45 AM_
---
+1 for #29 above.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c31) posted by **orionllmain** on 2013-08-30 at 08:57 AM_
---
Guys, introducing fold without adding other high order functions like skipWhile, takeWhile, reduce, groupBy, flatMap, indexWhere and so on is not the best idea, I think. Guava is not an FP library. If you want fold, use totallylazy. Or Scala.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c32) posted by **bytefu** on 2013-08-31 at 08:45 AM_
---
-> #31
Guava already has filter() and transform(). They're FP, they don't belong there. Or do they? I don't see any real reasons not to include some "FP" methods for collection processing. They reduce :) code, they are faster to write than beloved for-loops, and they look nicer in IntelliJ Idea even today, without Java 8 with it's nya-looking lambdas.
You suggest to use some other library or even Scala just for one or two missing functions? I don't want my pom.xml to become separate project, just because I use a library every time I need a method.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c33) posted by **orionllmain** on 2013-08-31 at 04:24 PM_
---
I want only say that fold is definitely not enough for me. Why fold? Why not flatMap, maxBy or zip? You either add all of these methods, or you add nothing. Adding only fold looks ridiculous.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c34) posted by **xaerxess** on 2013-08-31 at 09:17 PM_
---
> Why fold? Why not flatMap, maxBy or zip?
> &nbsp;\- flatMap - there's [FluentIterable#transformAndConcat](https://google.github.io/guava/apidocs/com/google/common/collect/FluentIterable.html#transformAndConcat%28com.google.common.base.Function%29),
> &nbsp;\- maxBy - use [Ordering#onResultOf](https://google.github.io/guava/apidocs/com/google/common/collect/Ordering.html#onResultOf%28com.google.common.base.Function%29) + [Ordering#max](https://google.github.io/guava/apidocs/com/google/common/collect/Ordering.html#max%28java.lang.Iterable%29),
> &nbsp;\- zip - not in Guava - [requires Pair / Tuple](http://code.google.com/p/guava-libraries/wiki/IdeaGraveyard#Tuples_for_n_>=_2) + see [this issue](https://github.com/google/guava/issues/677).
>
> I don't see any real reasons not to include some "FP" methods for collection processing.
> They would require adding many things to Guava API (two-arg functions, pair, etc.) - see new [java.util.function package from Java 8](http://download.java.net/jdk8/docs/api/java/util/function/package-summary.html) - but contrary to Java 8, functional idioms in Java 6/7 are horribly verbose and ugly.
Although Guava could adopt some names / API from Project Lambda to "backport" FP goodies to Java 6/7, it would be painful to use fold without language support (i.e. without lambdas). And bringing FP idioms to Java as such is separate discussion, for example my collegue believes that average "enterprise" Java programmer will have troubles with lambdas and they are not necessary in the language where for-loop is a common and well known idiom. (FYI: I know / have been using higher order functions in Lisp / Perl and it's not the same experience for both code writer and reader in Java, at least without lambdas in core for which I am waiting impatiently.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c35) posted by **lowasser@google.com** on 2013-12-03 at 07:56 PM_
---
_Issue #1601 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c36) posted by **lowasser@google.com** on 2013-12-03 at 07:56 PM_
---
_Issue #1601 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c37) posted by **jysjys1486** on 2014-02-04 at 08:24 AM_
---
The following assumes sequential operation:
interface Collector&lt;T,A,R> {
&nbsp;&nbsp;&nbsp;A newContainer();
&nbsp;&nbsp;&nbsp;void accumulate(A container, T element);
&nbsp;&nbsp;&nbsp;R finish(A container);
}
Like Java 8 Collector, though functions of supplying and accumulating is pushed to the interface.
&lt;T,A,R> R collect(Iterable<? extends T> elements, Collector<? super T, A, ? extends R> collector) {
&nbsp;&nbsp;&nbsp;final A container = collector.newContainer();
&nbsp;&nbsp;&nbsp;for (T each : elements)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;collector.accumulate(container,each);
&nbsp;&nbsp;&nbsp;return collector.finish(container);
}
Typical mutable reduction implemention
class Collectors {
&nbsp;&nbsp;&nbsp;public static &lt;T, C extends Collection&lt;T>> Collector&lt;T,?,C> toCollection(Supplier<? extends C> factory) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ...
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;// ...
}
Utility for collectors.
---
I just use this arrangement:
public interface Foldable&lt;A, R> {
&nbsp;&nbsp;&nbsp;&nbsp;R fold(A left, R right);
&nbsp;&nbsp;&nbsp;&nbsp;/**
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\* reduce or fold the {@link Iterable} with an initial value and folding function from left to right
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\* @param list
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\* @param acc
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\* @param f the Foldable (interface override)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\* @return
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_/
&nbsp;&nbsp;&nbsp;&nbsp;static &lt;A, R> R foldRight(final Iterable&lt;A> list, final R acc, final Foldable&lt;A, R> f) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Iterables.isEmpty(list))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return acc;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return foldRight(Iterables.skip(list, 1), f.fold(Iterables.getFirst(list, (A)null), acc), f);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/_*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\* reduce or fold the {@link Iterable} with an initial value and folding function from right to left
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\* @param list the iterable list or set etc.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\* @param acc initial value
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\* @param f the Foldable (interface override)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\* @return the result of folding from right to left
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;static &lt;A, R> R foldLeft(final Iterable&lt;A> list, final R acc, final Foldable&lt;A, R> f) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Iterables.isEmpty(list))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return acc;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return f.fold(Iterables.getFirst(list, (A)null), foldLeft(Iterables.skip(list, 1), acc, f));
&nbsp;&nbsp;&nbsp;&nbsp;}
}
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c39) posted by **wasserman.louis** on 2014-03-27 at 01:45 AM_
---
The nested Iterables.skips will give extremely terrible performance, certainly quadratic if not worse.  You should really just be folding over the Iterator instead.
At this point we're not adding any more functional features to Guava because of Java8.
No, it's not that, we'll be supporting a pre-Java-8 Guava fork for quite a long time.  And we're committed to maintaining that as a high quality experience.  However, that doesn't go so far as to cover investing in brand new features that can only at best hope to be poor substitutes for what's coming in 8.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=196) created by **lindner+unus...@inuus.com** on 2009-06-23 at 01:15 AM_
---
It might be nice to initialize the temporary arraylist used for Immutable
classes to a specific size by adding an optional constructor that takes sizing
parameters.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c1) posted by **kevinb9n** on 2009-08-12 at 06:13 PM_
---
Seems plausible to me, we'll see how it works out.
---
**Status:** `Accepted`
**Labels:** `post-1.0`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c2) posted by **kevinb9n** on 2009-09-17 at 05:45 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`post-1.0`, `Milestone-Post1.0`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c3) posted by **kevinb9n** on 2009-09-17 at 05:57 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c4) posted by **kevinb@google.com** on 2010-07-30 at 03:53 AM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Milestone-Post1.0`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c5) posted by **kevinb@google.com** on 2011-07-13 at 06:18 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c6) posted by **wasserman.louis** on 2011-10-20 at 08:57 PM_
---
+1 for something like builder.ensureCapacity, maybe.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c7) posted by **fry@google.com** on 2011-12-10 at 03:39 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Collect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c8) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c9) posted by **opinali@google.com** on 2012-04-26 at 07:31 PM_
---
Lots of input in the list, before the original poster, me and others, knew about this issue: https://groups.google.com/forum/?fromgroups#!topic/guava-discuss/2rZDhvsOXss
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c10) posted by **wasserman.louis** on 2012-04-26 at 07:34 PM_
---
I...think I'd be +1 on this change, still -- either with an ensureCapacity method, a capacity-accepting builder() variant, or both.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c11) posted by **tpeierls** on 2012-04-26 at 08:14 PM_
---
Prefer ensureCapacity style over mysterious int argument.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c12) posted by **opinali@google.com** on 2012-04-26 at 08:15 PM_
---
Concrete proposal: at minimum, we need a new public constructor for all Immutable*.Builder classes, with a parameter "int initialCapacity".  Ideally we could also have an overload of the builder() factory with the same parameter, but only the constructor is strictly necessary. In any case, the builder's constructor will intialize its backing store with the precise initialCapacity provided.
This change alone will make sure that no reallocation/growing/copying costs will be incurred as elements are added.  It's worth notice that this is useful not only when the exact element count is known beforehand; it's very useful too when a reasonable guess can be made, so in the worst case, costs of storage growth will be reduced.
It's also possible to make other optimizations to reduce buffer copying; the attached code illustrates implementation including a simple benchmark. Running the benchmark (java -server -D64 -Xms256m -Xmx256m) results, in my system, in a score of 76ms for the standard code and 41ms for the code with all suggested optimizations, almost twice as fast, with no performance tradeoffs. Actually the major tradeoff is in the code, as I'm using raw arrays as backing store instead of relying on ArrayList; but the builder's needs are very simple so the extra code and implementation complexity are minimal. This new code will be slightly faster even for the non-optimal case where preallocation and copy avoidance optimizations are not effective.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c13) posted by **wasserman.louis** on 2012-04-26 at 09:42 PM_
---
We have much more sophisticated internal benchmarks using Caliper.  I'll do some experiments.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c14) posted by **wasserman.louis** on 2012-04-27 at 01:50 AM_
---
I sent in a code review at http://codereview.appspot.com/6092044/.  This change doesn't actually expose any of the added features -- not until we come to some agreement about which methods should be exposed and how -- but there were also some ways to improve on opinali's implementation -- which didn't pass unit tests, by the way.
I'm slightly concerned that some of the builder implementations can set internal capacity, and some cannot.  Exposing control over the capacities seems a bit like exposing an implementation detail -- one that might even change in the future.  =/  That makes me...a bit wary, but not too much.
But let me summarize our options, as far as I can see.  We could choose any subset of the following.
1. Expose a new Builder(int) constructor directly.  I'm not a fan of this option -- we prefer factory methods for a reason (most notably, they can have useful names).  (Indeed, in retrospect I wish that the Builder constructor weren't exposed at all.)
2. Expose a new factory method for Builders that sets the initial capacity.  This could have a clarifying name like "builderWithCapacity(int)" or "builderWithExpectedSize(int)".
3. Expose an "ensureCapacity" method from the Builder objects.  This option could reasonably become a no-op for builders that don't have that implementation detail.  Disadvantage: you can't shrink builders beyond the default initial size, and this seems like a much rarer use case -- usually the user either knows the size at construction time, or doesn't know it until build() gets called.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c15) posted by **stephan202** on 2012-04-27 at 06:05 AM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c16) posted by **wasserman.louis** on 2012-04-27 at 06:08 AM_
---
I think I agree.  Any alternative suggestions on the name, though?  I'd prefer not to just expose builder(int), which really doesn't make the meaning of its argument clear.  As Tim said, a "mysterious int argument" is rather suboptimal.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c17) posted by **neveue** on 2012-04-27 at 07:44 AM_
---
I like the names you suggested ("builderWithCapacity(int)" and "builderWithExpectedSize(int)"), because they are similar to "Lists.newArrayListWithCapacity(int)" and "Sets.newHashSetWithExpectedSize(int)". Similarity is good when naming things.
The names are long, but it doesn't bother me. Most people will use the default "builder()" method. Having a longer and precise name is good for the few cases where users need to specify the capacity.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c18) posted by **kevinb@google.com** on 2012-05-30 at 07:41 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Enhancement-Temp`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c19) posted by **kevinb@google.com** on 2012-05-30 at 07:45 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement-Temp`, `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c20) posted by **cpovirk@google.com** on 2012-06-21 at 09:11 PM_
---
We finally discussed this in our API-review meeting.  We're skeptical that the performance improvement would be enough to justify the API complexity, especially when the new API's mere existence suggests to users that they ought to be pre-sizing their builders.  Additionally, users can always create a pre-sized ArrayList themselves and then call copyOf(), reducing the cost to one arraycopy.
We're still considering how to optimize the Immutable\* construction paths, including the idea of never "expanding" a builder array, only creating additional arrays as necessary for the spillover.  Somewhere along the line, we'll write some Caliper benchmarks to help guide us.
(We've already taken one optimization CL (&lt;https://github.com/google/guava/commit/03afbea918471a1b536c0754b10719adc0317135 and it's possible that even that was a step too far, but it turned up an interesting bug elsewhere in our code (&lt;https://github.com/google/guava/commit/26b9a4da08e4ee8002c527195121c2741fa43f29 so even benchmarks were to show that it weren't worthwhile, it will have been worth something :)  (Also note that it didn't require an API change, though it did complicate the implementation a bit.))
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c21) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c22) posted by **kevinb@google.com** on 2012-12-20 at 06:45 PM_
---
Good news, everyone.  We've convinced ourselves these methods should be added.  We apologize, of course, that we couldn't make this decision a higher priority a while ago.
Our _unordered_ top preferences are:
a) ImmutableList.builderWithInitialSize(42)
b) ImmutableList.builder(42)
c) ImmutableList.builder(42) _and_ new ImmutableList.Builder&lt;Foo>(42)
Your thoughts?
---
**Status:** `Accepted`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c23) posted by **kevinb@google.com** on 2012-12-20 at 06:46 PM_
---
Also consider whether your preference changes if the parameter passed in is a variable, or a call to someCollection.size(), etc., rather than an int literal.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c24) posted by **neveue** on 2013-01-06 at 05:36 PM_
---
I prefer a) because it's clearer, and similar to "Lists.newArrayListWithCapacity()".
What about "ImmutableList.builderWithCapacity()"?
---
I wonder if using a bigger growth factor instead of 1.5 for `ImmutableList.Builder`&nbsp;would be a good idea. Unlike with `ArrayList`, the needlessly allocated memory gets usually freed (eligible for GC) immediately, so the main reason for using a small growth factor doesn't apply here.
According to the `ImmutableListCreationBenchmark`, replacing the growth factor of 1.5 by 4 is a clear win:
.    size             benchmark        ns linear runtime
.      10    BuilderAddFastGrow      66.3 =
.      10            BuilderAdd      91.0 =
.      10    PreSizedBuilderAdd      38.2 =
.      10         CopyArrayList      55.7 =
.      10 CopyPreSizedArrayList      65.5 =
.    1000    BuilderAddFastGrow    3701.5 =
.    1000            BuilderAdd    5091.7 =
.    1000    PreSizedBuilderAdd    2294.7 =
.    1000         CopyArrayList    5289.3 =
.    1000 CopyPreSizedArrayList    3775.2 =
. 1000000    BuilderAddFastGrow 4149068.4 ==================
. 1000000            BuilderAdd 5519544.3 ========================
. 1000000    PreSizedBuilderAdd 2568223.4 ===========
. 1000000         CopyArrayList 6836726.6 ==============================
. 1000000 CopyPreSizedArrayList 4610333.8 ====================
I also wonder what a public `Builder`&nbsp;constructor is good for when the class is final and a static factory method is provided?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c26) posted by **wasserman.louis** on 2013-01-07 at 12:30 AM_
---
A clear win for CPU time, sure, but not all users can tolerate high GC churn.
Opinions vary over whether the public Builder constructor is preferable when type inference cannot determine the type it should have -- e.g. new Builder&lt;Foo>() when ImmutableList.builder() can't infer the proper type -- but at this point, it's part of a non-Beta API, so we don't have much choice about it.
---
The CG churn is just one more reason _against_ using such a small growth factor. Using it leads to many allocated chunks, and their total size is _big_. The exact figures depend on the target size, but out of the growth factors of `{1.5, 2, 3, 4}`&nbsp;the smallest one is nearly always the _worst_ choice in this respect!
This small program outputs the total memory allocated in the builder when lists of all sizes from 1 to `10**N`&nbsp;get created:
Such totaling (or averaging) is necessary so that certain factors don't get favored accidentally like e.g. a size of 40 favors the factor 3 (initialSize=4 -> 4_3+1=13 -> 13_3+1=40).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c28) posted by **neveue** on 2013-01-17 at 10:08 AM_
---
> Opinions vary over whether the public Builder constructor is preferable when type
> inference cannot determine the type it should have -- e.g. new Builder&lt;Foo>() when
> ImmutableList.builder() can't infer the proper type -- but at this point, it's part
> of a non-Beta API, so we don't have much choice about it.
Couldn't users write ImmutableList.&lt;Foo>builder()? In which case the public constructor becomes redundant, and we don't have to provide a public constructor for pre-sized builders.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c29) posted by **kevinb@google.com** on 2013-01-17 at 03:56 PM_
---
They _can_, but as noted, "opinions vary" over whether that's horrible.  It certainly wasn't what we intended people to do when we created the method (we assumed it was only for the case that type inference would work).
---
ImmutableList&lt;Number> list1 = new ImmutableList.Builder&lt;Number>().add(1).add(2.3).build();
ImmutableList&lt;Number> list2 = ImmutableList.&lt;Number>builder().add(1).add(2.3).build();
In theory, the former allows to use the diamond operator, but it doesn't work either. Allowing both syntaxes is the _third_ possibility, IMHO worse as it leads to mixed syntax. Maybe you could deprecate one of them, maybe _advising_ against it would be enough.
Concerning future Java progress I don't expect the inference to work in any of the cases before 2050, so it doesn't matter which one you choose.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c31) posted by **drichter@google.com** on 2013-06-13 at 09:39 PM_
---
ImmutableList&lt;Number> list1 = new ImmutableList.Builder<>().add(1).add(2.3).build();
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c32) posted by **cgdecker** on 2013-06-13 at 09:57 PM_
---
@drichter: Actually, that won't compile unfortunately, for the same reason that
ImmutableList&lt;Number> list = ImmutableList.builder().add(1).add(2.3).build();
won't compile. Java can't intefer the the type returned by ImmutableList.builder() or new ImmutableList.Builder<>() without it being assigned to something.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c33) posted by **paulduffin@google.com** on 2013-06-27 at 09:36 AM_
---
Mixing Number and literal numbers is not handled well by Java at all. It should be able to infer the types of the following, and actually does a very good job but in fact it is too good as it infers the type of ImmutableList.of as ImmutableList&lt;Number & Comparable> which is not assignable to ImmutableList&lt;Number>:
&nbsp;&nbsp;&nbsp;&nbsp;ImmutableList&lt;Number> list = ImmutableList.of(1.1, 2.3);
Ignoring that I think that the use of .add() chain followed by .build() to construct a known size list is a bad way to do it. Better in my opinion to just use ImmutableList.of() - for most usages Java can infer the type correctly whereas it cannot for the .add() chain - plus of() is faster.
&nbsp;&nbsp;&nbsp;&nbsp;ImmutableList&lt;String> list = ImmutableList.of("1", "2"); // Ok
```
ImmutableList<String> list = ImmutableList.builder().add("1").add("2").build(); // Fails
```
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c34) posted by **cpovirk@google.com** on 2013-12-02 at 02:54 PM_
---
_Issue #1598 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c35) posted by **schlosna** on 2014-04-30 at 02:21 AM_
---
Is there any further input that would help get this change into the next release of Guava (18.0), be it code, additional API comments, etc.? I have several places building large collections that would benefit greatly from being able to specify the desired capacity when known a priori. This is especially true when dealing with serialization/deserialization.
Based on issue 1736, I would favor Immutable*.builderWithCapacity(int).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c36) posted by **snekse** on 2014-04-30 at 11:00 PM_
---
I'm in favor of the general Immutable*.builderWithCapacity(int) format, but would the int be the actual capacity with resizing occurring before int elements have been added?
We have actually been sinking a fair amount of time into studying this.
At every turn we keep finding that the actual measurable benefits are significant in _fewer circumstances_ than we thought, and that those benefits when they do exist are _smaller_ than we thought.
We're not denying that those benefits exist. But the costs are also real; there IS an added burden that many thousands of users will take on once a tuning parameter like this were to exist - deciding whether to use it, discussing with a reviewer whether to use it, adding bulk to their code to use it, actually putting thought into how to come up with a "good guess" when the real value isn't known (note that is not the common case), etc. That may not seem like a big cost, but it's not free.
Also, I'm sorry that it is now too late for 19.0, as rc1 is already out.
I do realize that on 2012-12-20 I announced that we had decided in favor of this. I'm sorry that decision eroded. That's pretty annoying.
Phew, I had a minor heart attack when I saw those commit titles, but it turns out we did indeed use `builderWithExpectedSize()` consistently for all of the APIs, and did _not_ use `builder**For**ExpectedSize()` for `ImmutableSet`.  _[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=135) created by **stolsvik** on 2009-04-01 at 09:47 AM_
---
MultiMap is great. However, in the place I replaced lots of annoying code
with a multimap, I used a ConcurrentMap. Now I have to rewrite all code to
use external synchronization, possibly inflicting performance. Thus, a
Concurrent version of MultiMap would be great.
I read in another issue that there are such code being worked on - how is
that doing? I assume this is utterly known, but the original
ConcurrentHashMap is public domain, so possibly the main concurrency-logic
could be ripped?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=135#c1) posted by **stolsvik** on 2009-04-01 at 09:53 AM_
---
.. also, read-only/unmodifiable views of these maps would be nice.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=135#c2) posted by **jared.l.levy** on 2009-04-01 at 12:30 PM_
---
The Multimaps.synchronized_Multimap and Multimaps.unmodifiable_Multimap methods
create synchronized or unmodifiable multimaps. Those provide most of the
functionality you're asking for.
The library does lack a ConcurrentMultimap class analogous to ConcurrentMap or
ConcurrentMultiset. I actually wrote one, but its code quality and usefulness aren't
strong enough to justify including it in the open-source library.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=135#c3) posted by **stolsvik** on 2009-04-01 at 12:54 PM_
---
ah, hadn't found those methods yet (I've just started using GCollections). Thanks.
I'll still be looking forward for the Concurrent versions..! :)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=135#c4) posted by **will.horn** on 2009-04-15 at 06:51 PM_
---
I think a ConcurrentMultimap sounds great.  My use case is analogous to collecting
property change listeners.  The multimap is keyed by a property and can have multiple
listeners associated with it.  Mutations are rare compared to traversing the
different views to notify listeners of something.  Multimaps.synchronizedMultimap
requires me to manually synchronized on the entire collection each time I want to
iterate a view of it.
I guess read-only/unmodifiable views would also solve my problem.
For a single listener list, java.util.concurrent.CopyOnWriteArrayList works well.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=135#c5) posted by **karlthepagan** on 2009-06-12 at 01:15 AM_
---
The use-cases I am seeing Multimap in are the property change listener pattern as
well as tracking references to "user" sessions (i.e. entityid -> set of session
handles) for session management.
ConcurrentMultimap.remove(K,V) particularly I would like to see implemented correctly
to handle the pruning data race.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=135#c6) posted by **kevinb9n** on 2009-09-17 at 05:57 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=135#c7) posted by **kevinb9n** on 2009-09-17 at 06:02 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Milestone-Post1.0`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=135#c8) posted by **kevinb@google.com** on 2010-07-30 at 03:53 AM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Milestone-Post1.0`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=135#c9) posted by **fry@google.com** on 2011-01-26 at 09:55 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Accepted`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=135#c10) posted by **joe.j.kearney** on 2011-01-27 at 10:37 AM_
---
I've implementated this based on ConcurrentHashMap, here:
http://code.google.com/p/libjoe/source/browse/trunk/src/collect/com/google/common/collect/ConcurrentHashMultimap.java
A better solution will be to have a proper MultimapMaker supporting all the gubbins that MapMaker provides; that's clearly a larger proposition. I look forward to seeing what comes in Guava for this.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=135#c11) posted by **kevinb@google.com** on 2011-01-27 at 01:20 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=135#c12) posted by **jbellis** on 2011-02-02 at 04:17 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=135#c13) posted by **kevinb@google.com** on 2011-02-03 at 02:55 AM_
---
Here's the rushed version.
Some multimaps have many values per key, some few.
For some, updates tend to cluster by keys, others not. (time-wise, or thread-correlated-wise)
The first time I ranted about this, this list went on for a little while.  Summary: there are many, many different "shapes" of multimaps and patterns of access.
As a result, I strongly suspect that any best effort we made at producing one or two "general purpose" concurrent multimaps would very likely have the property that they performed worse than a synchronized multimap for a majority of users!
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=135#c14) posted by **kevinb@google.com** on 2011-04-08 at 02:12 AM_
---
_(No comment entered for this change.)_
---
**Status:** `WontFix`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=135#c15) posted by **cpovirk@google.com** on 2014-07-16 at 02:04 PM_
---
I'm about to link someone here from StackOverflow, so I'll provide a little more detail:
Some comments from a later internal discussion in 2011:
"""
I tried to build a general-purpose concurrent multimap, and it turned out to be slightly faster in a small fraction of uses and Much slower in most uses (compared to a synchronized multimap). I was focused on making as many operations as possible atomic; a weaker contract would eliminate some of this slowness, but would also detract from its usefulness.
I believe the Multimap interface is too "large" to support an efficient concurrent implementation - sorted or otherwise. (Clearly, this is an overstatement, but at the very least it requires either a lot of work or a loosening of the Multimap interface.)
On the other hand, it's certainly conceivable to put together a less-general interface that encapsulates some Multimap use cases, and to build a higher-performance concurrent implementation of that. I tried to do this with [with my project] - the concurrent-ness isn't terribly clever, but it tries to do one thing and do it well.
Are there some usage patterns of Multimaps that we can identify and build a less-general interface around?
"""
We do have a couple concurrent multimap implementations internally, but they come with warnings like this:
"This lock-free ListMultimap is generally slower than a synchronized multimap. For better performance, call com.google.common.collect.Multimaps#synchronizedListMultimap instead. The lock-free nature of this class has some benefits, in situations where performance is not a concern. This multimap does not need to be locked when iterating across its views, leading to simpler code. Arbitrary multimap updates can occur without making any iterators throw a ConcurrentModificationException."
Your best bet is probably to construct a `ConcurrentHashMap<K, CopyOnWriteArrrayList<V>>` (or maybe switch out `CopyOnWriteArrrayList` for `CopyOnWriteArrraySet` to if you want `Set` semantics, or consider using `Sets.newConcurrentHashSet`).  _[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=130) created by **nimrod.priell** on 2009-03-12 at 08:19 AM_
---
I think this is one very strong class in the API and you made it package
viewable only. So I can't for example build a BiMap backed by my own map
implementations or some standard java impl. like LinkedHashMap for
insertion-order iteration.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=130#c1) posted by **kevinb9n** on 2009-03-12 at 06:39 PM_
---
It's always been a future possibility, but designing and documentation for
inheritance is a painful, very time-consuming activity and is not a priority for 1.0.
iterate in the corresponding order.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=130#c2) posted by **jared.l.levy** on 2009-03-12 at 06:43 PM_
---
Instead of making StandardBiMap public, we could instead create a BiMaps.newBiMap()
method that takes backing maps as input parameters. That approach avoids problems
that arise when collection classes are publicly extendable.
We currently don't have that method because, until now, nobody has asked for it.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=130#c3) posted by **kevinb9n** on 2009-03-12 at 06:46 PM_
---
Actually, we used to have it, for a long time, internally, and then we noticed that
of the few people who used it, none of them were actually getting the benefit from it
they thought they were.  We decided after giving it a chance that this was not very
useful, and we got rid of it.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=130#c4) posted by **jared.l.levy** on 2009-03-12 at 06:48 PM_
---
Correction: Maps.newBiMap()
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=130#c5) posted by **kevinb9n** on 2009-09-12 at 02:14 AM_
---
_(No comment entered for this change.)_
---
**Labels:** `post-1.0`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=130#c6) posted by **kevinb9n** on 2009-09-12 at 02:15 AM_
---
_Issue #235 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=130#c7) posted by **kevinb9n** on 2009-09-17 at 05:45 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`post-1.0`, `Milestone-Post1.0`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=130#c8) posted by **kevinb9n** on 2009-09-17 at 05:57 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=130#c9) posted by **kevinb9n** on 2009-10-30 at 04:00 PM_
---
_Issue #283 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=130#c10) posted by **kevinb@google.com** on 2010-07-30 at 03:53 AM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Milestone-Post1.0`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=130#c11) posted by **fry@google.com** on 2011-01-26 at 09:50 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Accepted`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=130#c12) posted by **kevinb@google.com** on 2011-07-13 at 06:18 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=130#c13) posted by **fry@google.com** on 2011-12-10 at 03:36 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Collect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=130#c14) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=130#c15) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=130#c16) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=130#c17) posted by **lowasser@google.com** on 2012-11-07 at 08:21 PM_
---
_Issue #1195 has been merged into this issue._
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=130#c18) posted by **amend6** on 2013-01-10 at 02:02 PM_
---
Related to this I want to extend the RegularImmutableBiMap,
but there is no public class access.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=130#c19) posted by **lowasser@google.com** on 2013-01-10 at 05:01 PM_
---
The immutable collections can definitely not be extensible.  That's part of Effective Java item 15 -- immutable classes cannot be extended.
We're considering making HashBiMap insertion ordered by default, but there still may be value in having a BiMapBuilder (similar to MultimapBuilder).
We're kicking around a design like this
- hashKeys()
- linkedHashKeys()
- enumKeys(Class)
- treeKeys()
- treeKeys(Comparator)
- hashValues()
- linkedHashValues()
- enumValues(Class)
- treeValues()
- treeValues(Comparator)
- expectedEntries(int)
- build()
How much interest is there in this?
So each direction might maintain its own separate iteration order, but if one side is plain "hash" then it should probably just reuse the iteration order of its inverse, since anything's better than arbitrary order.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=113) created by **jvdneste** on 2009-01-05 at 04:20 PM_
---
given a class:
class Foo implements Iterable&lt;Foo>
then:
Iterable&lt;Foo> i = Lists.newLinkedList(new Foo())
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=113#c1) posted by **kevinb9n** on 2009-01-05 at 04:34 PM_
---
quibble: I don't think it should introduce bugs since it should fail to compile. It
fails to compile, right?
Note: we hate this too, so the new APIs for ImmutableList etc. use different method
names (of/copyOf).  Also we're removing the varargs overloads for all the collection
factory methods except newArrayList() and newHashSet() and if we were smart we'd
probably remove them all.
---
**Status:** `WontFix`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=113#c2) posted by **jvdneste** on 2009-01-06 at 12:27 AM_
---
The code attached compiles in eclipse, but the test fails.
(The tree iterator (walk) would imho also be a nice addition to the library)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=113#c3) posted by **kevinb9n** on 2009-01-06 at 04:56 PM_
---
In this code, you're using raw types and suppressing warnings. I don't claim anything
will work right if you do this. Please provide an example that is warning-free if one
exists, and please don't make me hunt down a third-party library to compile it. Thanks.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=113#c4) posted by **jvdneste** on 2009-01-06 at 05:59 PM_
---
Sorry. You're right.
Attached is an example that illustrates the problem properly (although I get the
feeling we're already spending more time on it than it's worth).
I'm using Lists.newArrayList, because Lists.newLinkedList appears to be safe.
(sorry about that as well, http://mvnrepository.com/artifact/com.google.collections/google-collections/0.8 is
unexpectedly not the same as google-collect-snapshot-20080820.zip from this project
site)
I'm merely trying to say that I didn't get any warnings or errors with this code.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=113#c5) posted by **kevinb9n** on 2009-01-06 at 06:09 PM_
---
thank you, this example is much better.  Clearly, a class Foo that implements
Iterable&lt;Foo> is going to cause problems for these methods.
I'm reopening this issue to consider removing the varargs newArrayList and newHashSet
methods.  They really are not that useful.  However, we may also just choose to put a
small warning about this situation in their javadoc.  I lean toward the former.
---
**Status:** `New`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=113#c6) posted by **kevinb9n** on 2009-03-17 at 06:37 PM_
---
_(No comment entered for this change.)_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=113#c7) posted by **kevinb9n** on 2009-09-17 at 05:59 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Docs`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=113#c8) posted by **fry@google.com** on 2011-01-26 at 09:49 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Accepted`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=113#c9) posted by **kevinb@google.com** on 2011-07-13 at 06:18 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=113#c10) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=113#c11) posted by **kevinb@google.com** on 2012-03-02 at 06:51 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-General`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=113#c12) posted by **kevinb@google.com** on 2012-05-11 at 08:55 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Docs`, `Type-Documentation`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=113#c13) posted by **kevinb@google.com** on 2012-05-30 at 07:51 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Documentation`, `Type-ApiDocs`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=113#c14) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=113#c15) posted by **cushon@google.com** on 2014-03-21 at 04:34 PM_
---
&nbsp;&nbsp;&nbsp;&nbsp;Lists.newArrayList(null);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^
&nbsp;&nbsp;both method &lt;E#1>newArrayList(Iterable<? extends E#1>) in Lists and method &lt;E#2>newArrayList(Iterator<? extends E#2>) in Lists match
&nbsp;&nbsp;where E#1,E#2 are type-variables:
&nbsp;&nbsp;&nbsp;&nbsp;E#1 extends Object declared in method &lt;E#1>newArrayList(Iterable<? extends E#1>)
&nbsp;&nbsp;&nbsp;&nbsp;E#2 extends Object declared in method &lt;E#2>newArrayList(Iterator<? extends E#2>)
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=35) created by **juri.pakaste** on 2007-11-04 at 12:27 PM_
---
Two Iterator/Iterable/Collection related methods I seem to be
Here's their documentation from CPython 2.5. zip:
```
zip(seq1 [, seq2 [...]]) -> [(seq1[0], seq2[0] ...), (...)]
Return a list of tuples, where each tuple contains the i-th element
from each of the argument sequences.  The returned list is truncated
in length to the length of the shortest argument sequence.
```
And enumerate:
&nbsp;&nbsp;&nbsp;enumerate(iterable) -> iterator for index, value of iterable
&nbsp;&nbsp;&nbsp;Return an enumerate object.  iterable must be an other object that supports
&nbsp;&nbsp;&nbsp;iteration.  The enumerate object yields pairs containing a count (from
&nbsp;&nbsp;&nbsp;zero) and a value yielded by the iterable argument.  enumerate is useful
&nbsp;&nbsp;&nbsp;for obtaining an indexed list: (0, seq[0]), (1, seq[1]), (2, seq[2]), ...
I've implemented these in a MIT-licensed library for Java, JIterTools, at
Iterables. There's also a variant of zip called zipFill that goes on as
long as there are items in one of the Iterables/Iterators, reading extra
values for exhausted Iterators from an associated function.
I'd love to see all of them/some of them/something like them included in a
well-maintained library of various Collection related things and Google
Collections looks like a prime candidate as long as Commons Collections is
inactive. I'm not particular about the exact details, though. Of the
methods I've implemented, zip is the cleanest with no extra classes needed
for parameters or return values. Both enumerate and zipFill need helper
classes.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=35#c1) posted by **jared.l.levy** on 2007-11-04 at 04:31 PM_
---
Thanks for the suggestion! They both seem like plausible additions to the library.
The methods Iterators.pairUp() and Iterables.pairUp() provide the same functionality
as zip, for the case when you have two iterators or iterables. How often would people
want to zip more than two?
There would definitely be uses for enumerate(). In my code, at least, there are many
cases when I increment a counter within a for loop. An enumerate() command would make
the code more clean and would eliminate a possible bug if someone calls continue
inside the loop.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=35#c2) posted by **cpovirk+external@google.com** on 2007-11-04 at 05:43 PM_
---
It looks to me like we aren't supplying Iterators.pairUp() and Iterables.pairUp(),
eventually work them in.  To me, the case of two objects of different types seems
more useful than the case of an arbitrary number of objects of the same type, so I'm
not sure I'd use zip() in addition to pairUp().
enumerate() I do believe would be useful.  It looks like we aren't including
enumerate(), of course, doesn't have this problem.  I've written versions of
enumerate() before using a Pair&lt;Integer, T>, but I think I may like your approach of
getSecond()?  Users shouldn't have to work about ordering like they do with the Pair
approach).
---
I didn't see pairUp in the API docs, I guess it's new?
Looking at my own code and the Python libraries I've installed here, using just two
arguments for zip looks like the common case, although using more than two does
happen. There's attractive genericity to supporting an arbitrary number of iterators,
but supporting just two does free you from having to use Collections instead of a
more specialized object with named members. I'd go (and have gone) for the more
generic approach, but it's not a clear-cut case. You could always construct a tree of
paired up iterators, but that might get hairy rather quickly, with an unreadable
As for Enumerate, yes, the main thing I dislike about Python's enumerate is that I
always have to check the documentation about the order of the things in the tuple.
Giving the parts clear names beats that.
One issue I have with my enumerate method is the name - there's potential for name
though, at least to me.
How do you guys feel about zipFill? It's probably less commonly useful, but I did use
it just last week when I was outputting side by side sets of objects and wanted to
consume all the data from both iterators with just one foreach.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=35#c4) posted by **kevinb9n** on 2007-11-05 at 08:28 AM_
---
yeah, Pair and Itera*s.pairUp() need to get integrated out from our internal codebase
still.
will comment on the rest of the stuff in this bug tomorrow.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=35#c5) posted by **kevinb9n** on 2009-09-17 at 05:57 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=35#c6) posted by **kevinb9n** on 2009-09-17 at 06:02 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Milestone-Post1.0`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=35#c7) posted by **kevinb@google.com** on 2010-07-30 at 03:53 AM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Milestone-Post1.0`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=35#c8) posted by **kevinb@google.com** on 2010-07-30 at 03:56 AM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Priority-Medium`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=35#c9) posted by **j...@nwsnet.de** on 2010-08-18 at 12:58 PM_
---
I second the request for `zip`&nbsp;and `enumerate`&nbsp;equivalents. They are not just common in Python, but also in Groovy, e.g. in the form of `withIndexOf`.
&nbsp;&nbsp;===> [zero, one, two, three, four]
&nbsp;&nbsp;===> [zero, two, three]
Or is there a better way to do this?
---
I made an Enumerate class in Java to mock python's enumerate functionality.I'm just posting the link (http://stackoverflow.com/questions/4308406/java-enhanced-enhanced-for-loop/4312761#4312761) so that you people can check and comment on it.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=35#c11) posted by **jvdneste** on 2010-11-30 at 02:50 PM_
---
http://paste.pocoo.org/show/298031/
This is how I implement it. Fairly straightforward. Performance is not that great since you end up creating a Pair and Integer object for every item, but it is nice to have anyway.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=35#c12) posted by **fry@google.com** on 2011-01-26 at 08:52 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Accepted`
---
Seems to me we want to have the dot product of two Iterables. A subtype of this product would be the construction of a Pair. This allows for things like (without syntax checking):
Iterable&lt;Pair&lt;A, B>> zipList = dotProd(iterable1, iterable2, new BinaryFunction&lt;Pair&lt;A, B>, A, B>() {
&nbsp;&nbsp;Function&lt;Pair&lt;A, B>> apply(final B b) {
&nbsp;&nbsp;&nbsp;&nbsp;return new Function() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pair&lt;A, B> apply(final A a) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new Pair&lt;A, B>(a, b);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}}; }};
to define a zip function. But similary, we could define a dot product which returns the maximum element, or the 'normal' product of both lists.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=35#c14) posted by **kevinb@google.com** on 2011-07-13 at 06:18 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=35#c15) posted by **kevinb@google.com** on 2011-08-09 at 02:38 AM_
---
I believe the "zip" case is handled by issue 677 now?
The "enumerate" idea is one we considered and rejected long ago; there's no need for it, "int i = 0; / i++;" works just fine.
---
**Status:** `Obsolete`
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=14) created by **kevinb9n** on 2007-10-23 at 04:22 AM_
---
Occasionally you have a List of elements which you already know to be in
sorted order. The canonical example is the results from a SQL query with an
ORDER BY clause.
You know the data to be sorted, yet you have no way to offer the niceties
of the SortedSet/NavigableSet APIs to your callers. In order to construct a
used to sort the data -- but the data is already sorted!
I believe the way out of this is a method Sets.immutablePreSortedSet(List).
&nbsp;This method would copy the elements out of the list, assuming that
whatever order they come out in is the order you want.  It would not demand
a comparator from you (although, if you can provide one, perhaps it should
accept it, as this could speed up some of the operations.  and if you don't
provide one, what should the set's comparator() return?  Should it return a
Comparators.givenOrder()?).
This idea is not fully-formed, but it's a shame to see methods forced to
use List to model data which is often known to be dup-free and is ordered,
not indexed.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=14#c1) posted by **kevinb9n** on 2009-03-17 at 05:09 PM_
---
Case 1: you can provide a comparator. In this case, you should provide it -- and just
create an ImmutableSortedSet.  Creating that will cause a sort() to happen which will
be a no-op, and that's not great but not terrible.  It's possible we could provide
another way to create an ISS where you declare your data is already increasing, thus
the factory only has to check that each element is higher than the one before it, and
doesn't have to call sort().  Meh.
Case 2: you can't provide a comparator. Some complicated database sort was done, for
instance. So your comparator becomes an Ordering.givenOrder() over the elements you
have. ImmutableSortedSet.inGivenOrder().addAll(list).build(). I kind of like this,
but I haven't heard a loud demand for it. (then again, many people are not loudly
demanding it but are still returning List from APIs that really should be Sets.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=14#c2) posted by **jared.l.levy** on 2009-08-13 at 02:06 PM_
---
There's a problem with Case 2. Without a comparator, you can't implement the
comparator(), headSet(), tailSet(), and subSet() methods.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=14#c3) posted by **jim.andreou** on 2009-08-13 at 02:20 PM_
---
Could you elaborate on that a bit? E.g. why Ordering.givenOrder()/.explicit() wouldn't
do?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=14#c4) posted by **kevinb9n** on 2009-08-13 at 02:43 PM_
---
Yeah, those methods would only be able to accept values that are elements in the set,
so they'd be a bit crippled, but I'm not sure it's a deal-breaker.
This whole idea still lacks real motivation from users.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=14#c5) posted by **jim.andreou** on 2009-08-13 at 03:05 PM_
---
Hmm, alright. Though it wouldn't be any more "crippled" than Ordering.explicit()
itself. And you already decided that it doesn't pay off enough to allow defining what
happens with elements not contained in the list (with something similar to
nullsFirst()/nullsLast()), with which I agree, so I don't see this as a big issue - but
the real deal-breaker would be indeed lack of enough demand :)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=14#c6) posted by **leonidos** on 2009-09-03 at 07:21 PM_
---
ImmutableSortedSet should guarantee that its items are ordered using the comparator()
order, so it's a good idea to accept the client assumption (that items are already
ordered). But, I think, an acceptable case when the order is checked at the
construction phase - so ImmutableSortedSet.copyOfSorted(List&lt;E> list) can check the
given list to be correct, and accept it if correct or throw an exception if not.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=14#c7) posted by **leonidos** on 2009-09-10 at 01:36 PM_
---
In the previous message - I meant "it's not a good idea accept the client assumption".
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=14#c8) posted by **kevinb9n** on 2009-09-17 at 06:02 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Milestone-Post1.0`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=14#c9) posted by **jared.l.levy** on 2010-02-16 at 07:11 PM_
---
I just added ImmutableSortedSet.withExplicitOrder() methods to Google's internal code
---
**Status:** `Fixed`
**Owner:** jared.l.levy
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=13) created by **kevinb9n** on 2007-10-23 at 04:14 AM_
---
A UniqueList is a List which rejects duplicate elements (recall that the
modification methods on List, add/add/addAll/addAll/set, are permitted
the offered element(s)). The same goes for the modification methods on the
list's listIterator().
a Set in a completely "read-through, write-through" fashion.  So the
UniqueList&lt;E> interface would extend List&lt;E> to add this asSet() method. I
don't believe that any subtype of Set is needed for this; AFAIK it just
needs regular Set methods and not much else.
As well, the subList() method could be refined so that it also returns a
UniqueList&lt;E>. Of course, the sublist would throw IAE in response to any
operation that would result in a duplicate element in the _parent_ list.
An AbstractUniqueList&lt;E> class could be provided which only needs the
implementing class to supply a backing List and a backing Set, and
optionally override a few methods for better performance.
Unfortunately, the Collections methods sort(), shuffle(), reverse() and
swap() would fail on a UniqueList. They all make the assumption that the
list being acted upon has no problem with temporarily containing the same
element twice.  There's nothing we can do about that -- it's the price you pay.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=13#c1) posted by **stevelle** on 2007-11-14 at 09:22 PM_
---
For completeness, where would I use a UniqueList instead of a SortedSet?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=13#c2) posted by **kevinb9n** on 2007-11-15 at 01:00 AM_
---
A List gives you explicit control over the order of the elements; a SortedSet doesn't
(the comparator decides).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=13#c3) posted by **jkwatson** on 2009-04-24 at 08:22 PM_
---
Is a LinkedHashSet an example of a UniqueList?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=13#c4) posted by **kevinb9n** on 2009-04-24 at 09:04 PM_
---
No, it doesn't have random access.  (It also silently discards duplicates instead of
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=13#c5) posted by **jared.l.levy** on 2009-04-24 at 09:19 PM_
---
More generally, a LinkedHashSet doesn't implement the List interface, which includes
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=13#c6) posted by **kevinb9n** on 2009-09-17 at 06:02 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Milestone-Post1.0`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=13#c8) posted by **w.schoenborn** on 2010-05-06 at 02:41 PM_
---
I am really looking forward to this. Any progress? Any help needed?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=13#c9) posted by **kevinb9n** on 2010-05-06 at 02:49 PM_
---
useful so far, so it's low-priority.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=13#c10) posted by **kevinb@google.com** on 2010-07-30 at 03:53 AM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Milestone-Post1.0`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=13#c11) posted by **kevinb@google.com** on 2010-07-30 at 03:56 AM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Priority-Medium`
---
"There's nothing we can do about that -- it's the price you pay."
Not really.. If the list has elements: A, B, C, D, E and you want to set the element at index 0 to E then you can simply swap their positions.
Result: E, B, C, D, A
And this doesn't break the contract of the Set operation.
"Replaces the element at the specified position in this list with the specified element (optional operation). "
All you have to do is to add more specifications to the set method.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=13#c13) posted by **kevinb@google.com** on 2011-01-27 at 01:54 PM_
---
_(No comment entered for this change.)_
---
**Owner:** kev...@google.com
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=13#c14) posted by **kevinb@google.com** on 2011-01-27 at 01:58 PM_
---
_(No comment entered for this change.)_
---
**Owner:** ---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=13#c15) posted by **kevinb@google.com** on 2011-02-03 at 06:35 AM_
---
---
Yes if you follow the way I described above most of the Collections methods will work on the list as expected. (the shuffle method doesn't seem to work)
Here is a simple implementation of the UniqueList
import com.google.common.base.Preconditions;
import java.util.AbstractList;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
/**
&nbsp;*
&nbsp;\* @author Michael
&nbsp;*/
public class SimpleUniqueList&lt;E> extends AbstractList&lt;E> {
```
private List<E> data;
public SimpleUniqueList() {
data = new ArrayList<E>();
}
public void add(int index, E e) {
Preconditions.checkArgument(!data.contains(e));
data.add(index, e);
}
public E remove(int index) {
return data.remove(index);
}
public E set(int index, E e) {
int i = data.indexOf(e);
if (i == -1) {
return data.set(index, e);
}
data.set(i, data.get(index));
return data.set(index, e);
}
public E get(int index) {
return data.get(index);
}
public int size() {
return data.size();
}
public static void main(String[] args) {
List<String> ul = new SimpleUniqueList<String>();
ul.add("A");
ul.add("B");
ul.add("C");
ul.add("D");
ul.add("E");
System.out.println(ul);
Collections.sort(ul);
System.out.println(ul);
System.out.println(ul);
System.out.println(ul);
}
```
}
Running the above program will print out the following output:
[A, B, C, D, E]
[A, B, C, D, E]
[E, D, C, B, A]
[A, D, C, B, E]
It would have been good if Josh put a method for swapping two elements in the List interface. Something like swap(int i, int j)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=13#c18) posted by **neveue** on 2011-02-10 at 01:09 PM_
---
```
@Test
public void test() {
List<String> ul = new SimpleUniqueList<String>();
ul.add("D");
ul.add("C");
ul.add("B");
ul.add("A");
ul.set(0, "A");
Assert.assertEquals(ul, ImmutableList.of("A", "C", "B", "D"));
}
```
I think the UniqueList should throw an IllegalArgumentException when attempting to "set" an already stored element. This would stop sort() / reverse() / swap() from working, but it is IMO the only contract that makes sense for the set() method.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=13#c19) posted by **kevinb@google.com** on 2011-02-10 at 02:48 PM_
---
... yep, and that's what it does.  The idea of corrupting other data in the list at will is not even something that should be considered.
---
Yes indeed, it's quite confusing and the fact that the shuffle method doesn't work on the list is quite disappointing.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=13#c21) posted by **kevinb@google.com** on 2011-07-13 at 06:18 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Triaged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=13#c22) posted by **raymond.rishty** on 2011-11-03 at 12:55 AM_
---
I have a UniqueList implementation that I gives the user the option of how duplicates ought to be handled--ignore, replace, or throw an exception. One obtains a list by something like UniqueList.ignoreDuplicates() or UniqueList.replaceDuplicates(), etc.
That said, more often than not, when someone thinks they want a UniqueList, and LinkedHashSet does just fine. Moreover, given the option, most developers I work with will pick the most tolerant implementation. They don't want non-conforming data to be rejected.
That is to say, to Kevin's point (from 2/10) I'm not certain that my approach is worthwhile. Per the API, List.add is allowed to reject the addition (by throwing an Exception), but for it to remove another entry, or silently ignore the addition is certainly breaking the contract and probably a bit perverse.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=13#c23) posted by **fry@google.com** on 2011-12-10 at 03:12 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Collect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=13#c24) posted by **fry@google.com** on 2012-02-16 at 07:17 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Acknowledged`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=13#c25) posted by **kevinb@google.com** on 2012-05-30 at 06:07 PM_
---
Raymond: first, "ignore" and "replace" are the same thing. If they ever aren't, that object implemented equals() incorrectly.  Equals Means Interchangeable.
Second, our UniqueList also gives you the choice of either exception or silently-collapse.  Just use either uniqueList.add(e) or uniqueList.asSet().add(e), respectively.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=13#c26) posted by **wasserman.louis** on 2012-05-30 at 07:18 PM_
---
Honestly, I'm inclined to play up the role of ImmutableSet.asList() here, since it satisfies a sensible "unique list" contract, has unambiguous semantics (since it is, of course, immutable), and all the other fun stuff.
Do we have any actual use cases that this doesn't address?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=13#c27) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=13#c28) posted by **kevinb@google.com** on 2012-06-22 at 06:16 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Research`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=13#c31) posted by **linakster** on 2014-01-10 at 09:13 PM_
---
Sorry for the bump. Did this get resolved?
If anything, a unique list should always be an ImmutableList. The user has no knowledge of the contents of the list, so even throwing an exception or returning false is an ideal hair-pulling scenario to debug (in which case it could be an interface not extending Collection to clearly define it's own behavior)
Using static factory for ImmutableList:
ImmutableList&lt;T> ImmutableList.uniqueListOf(Iterable<? extends T> elements,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalence<? super T> elemEq) {
```
return  new DefaultUniqueListImpl<>(elements, elemEq).asList();
```
}
Using a dedicated interface just for UniqueList (like java.util.Map), as it preserves the "Equivalence" instance used for computing equality, . This cannot extend Collection, as it violates the "contains(Object)" contract in using Object.equals; instead uses the provided "Equivalence" :
```
Equivalence<? super T> elementEquivalence();
ImmutableList<T> asList();
int size();
// ....collection + list/random access methods....
// can freely throw exceptions as this interface is concrete and does not extend
// Collection, hence not compelled to adhere to contract
void shuffle();
void sort();
void swap(int i, int j);
```
}
Will also be nice to have simple default operation in Collections2, for quick checks. Something like:
boolean Collections2.containsUniqueElements(Collection<?> c)
{
&nbsp;&nbsp;&nbsp;if (list instanceof Set) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;if (c instanceof Multiset) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (E e : m) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (m.count(e) > 1) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;return containsUniqueElements(c, Equivalence.objectEquals());
}
boolean Collections2.containsUniqueElements(Collection&lt;T> c,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalence<? super T> elemEq) {
```
return c.size() == ImmutableList.<T>uniqueListOf(c, elemEq).size();
// or
return c.size() == new FastComputingSizeUniqueListImpl<>(c, elemEq).size();
```
}
Comments and/or critiques?
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=10) created by **sberlin** on 2007-09-24 at 06:12 PM_
---
This is a contribution of LimeWire's PatriciaTrie, as discussed at:
http://groups.google.com/group/google-
guice/browse_frm/thread/ffb2a3b3b9e39e79?tvc=1 .
The files can be licensed as necessary (we own the copyright and can
change/transfer the license).  I'm not sure what license, if any, these
would need to be for inclusion.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c1) posted by **kevinb9n** on 2007-10-01 at 07:51 PM_
---
thanks!
of use cases for this trie.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c2) posted by **sberlin** on 2007-10-01 at 08:10 PM_
---
We use it internally for a few cases.
&nbsp;1) An IP list.  We have a KeyAnalyzer that analyzes ip addresses to store them
(and/or ranges of them) as compactly as possible.  See:
https://www.limewire.org/fisheye/browse/~raw,r=1.18/limecvs/core/com/limegroup/gnutel
use-case, although it works very well. :)
Other use cases:
&nbsp;3) A very efficient (both in memory & CPU) dictionary.  It could be used for
something like a cellphone's phonebook.  You start typing and it immediately finds
all strings that began with your string.  At the same time the structure acts like a
Map preventing you from adding the same String twice.  It's kind of like a super-
SortedMap.
I'm sure there's a ton of other cases, but those are the ones we use (and have plans
to use).  The really awesome things about Patricia is the way it does lookups.
Consider the IPList -- IPv4 addresses have a fixed size of 32 bits.  So no matter
how many items you have stored in the Trie, it will always do at most 32 bit
comparisons.  And it will often do less (because it intelligently traverses the
tree), and it will keep things sorted and tell you all addresses that begin with
X.Y, etc...
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c3) posted by **kevinb9n** on 2007-10-16 at 03:37 PM_
---
Great stuff, folks.  Thanks so much.
With the sheer mountain of work involved in getting our existing stuff polished, I'm
do think that this trie and tries in general are a very promising addition, so don't
lose hope!
---
**Status:** `Accepted`
**Owner:** kevinb9n
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c4) posted by **kevinb9n** on 2007-10-23 at 04:29 AM_
---
I can imagine that many use cases for a Trie break into at least two categories
1. The SortedMap/NavigableMap the right API abstraction that the caller wants, but
due to the nature of the data, a Trie can be much faster than existing
implementations of these interfaces.
simpler that deals only with prefix-matching like (rough guess):
&nbsp;&nbsp;public interface Trie&lt;N, V> {
&nbsp;&nbsp;&nbsp;&nbsp;boolean containsMatch(List<? extends N> sequence);
&nbsp;&nbsp;&nbsp;&nbsp;V get(List<? extends N> sequence); // doesn't require exact match
&nbsp;&nbsp;&nbsp;&nbsp;void put(List<? extends N> sequencePrefix, V value);
&nbsp;&nbsp;}
A separate issue: should we consider providing an alternate interface that is
tailored to character-based tries, so this alternate API could use CharSequence in
place of List&lt;Character>?  Then there would be two simple methods
Tries.asCharacterTrie() and Tries.forCharacterTrie() to go back and forth between the
two.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c5) posted by **sberlin** on 2007-10-23 at 05:49 AM_
---
From my experience, #1 is exactly right.  A Trie easily doubles as a super-efficient
SortedMap/NavigableMap.
function with a similar interface, but tailored towards the combined sequence
instead of the pieces that build up the sequence.  That is, the methods would look
like:
&nbsp;&nbsp;&nbsp;public interface Trie&lt;K, V> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SortedMap&lt;K, V> getPrefixedBy(K prefix); // returns a view over all entries
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void put(K key, V value);
&nbsp;&nbsp;&nbsp;}
CharSequence to a Character, or a NumberSequence to a Number.  This has the
advantage of being able to reuse the interface for arbitrary-length keys or fixed-
length keys whose contents don't divide easily into objects.  (For example, IP
The Trie interface in the submission includes a few additional convenience methods
and directly subclasses SortedMap (if it were targetted for 1.6, it would extend
NavigableMap too).  The additions are for better use with fixed-size keys and being
able to visit the entries in the map while traversing (with a 'Cursor').
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c6) posted by **sberlin** on 2007-10-23 at 05:50 AM_
---
(Really, that getPrefixedBy could just return a List&lt;V> - having it return a vw of
the map itself enables some really cool things.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c7) posted by **kevinb9n** on 2007-11-03 at 05:32 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Post-1.0`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c8) posted by **kevinb9n** on 2008-06-02 at 05:48 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Post-1.0`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c9) posted by **tim.frey.online** on 2009-03-22 at 10:31 AM_
---
Hello,
It's a proposal for a fast memory aware Trie that can deal with non equal memory costs.
Hope I could help,
Tim
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c10) posted by **ray.a.conner** on 2009-08-03 at 05:53 PM_
---
&nbsp;&nbsp;Set< List< E > >
or, easily enough, a
&nbsp;&nbsp;Map< List< E >, V >
where E is typically a character (List&lt;E> is a String). The representation allows
certain specific operations to be very efficient, and is efficient for storage when
there are many common prefixes among the List&lt;E> (a spelling dictionary, for example).
There may be some benefit to completely abstracting it in this way, although
translating the common use case of a String key would be an excessive amount of overhead.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c11) posted by **ray.a.conner** on 2009-08-03 at 06:05 PM_
---
As a use case, I've used it for finding phrases within a large text document. I have
some set of phrases that I'm looking for (not Strings, but sequences of words, hence
- List&lt;String>) stored as a Trie. To search, I walk the normalized text (split on
List&lt;String>, keeping track of possible matches as I go.
Generalizing, this is finding all possible subsequences of List&lt;E> (the text) that
are members of a given Set&lt;List&lt;E>> (the search phrases).
The big benefit is that the text, which can be very large, only needs to be traversed
once to find any one (or all) of thousands of possible phrases. It scales very well.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c12) posted by **creswick** on 2009-08-03 at 06:31 PM_
---
I have the same use case as Ray.a.conner, and I'd also use it for scalable tab|auto-
completion in interactive consoles|text fields.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c13) posted by **sberlin** on 2009-08-03 at 06:34 PM_
---
Are you folks using the attached PatriciaTrie implementation, or a separate one?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c14) posted by **jared.l.levy** on 2009-08-03 at 06:44 PM_
---
The Google code base includes multiple Java trie implementations. If we chose to add
a trie to the library, we'd probably start with one of those.
---
**Labels:** -`Type-Defect`, `Type-Enhancement`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c15) posted by **ray.a.conner** on 2009-08-03 at 08:13 PM_
---
I rolled my own implementation, some years ago. I wasn't storing simple strings, and
to sequences of strings, sequences of objects was a no-brainer. Although I never
needed to implement many of the Trie operations that others find useful; I only
needed sub-sequence matching.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c16) posted by **kevinb9n** on 2009-09-17 at 06:02 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Milestone-Post1.0`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c17) posted by **master.java.xiao** on 2009-11-24 at 08:06 AM_
---
_(No comment entered for this change.)_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c18) posted by **kevinb@google.com** on 2010-07-30 at 03:54 AM_
---
_(No comment entered for this change.)_
---
**Owner:** kev...@google.com
**Labels:** -`Milestone-Post1.0`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c19) posted by **kevinb@google.com** on 2010-07-30 at 03:56 AM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Priority-Medium`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c20) posted by **kevinb@google.com** on 2011-01-27 at 01:59 PM_
---
_(No comment entered for this change.)_
---
**Owner:** ---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c21) posted by **kevinb@google.com** on 2011-02-03 at 06:24 AM_
---
Work is beginning... expect in maybe release 10 or 11.
---
**Status:** `Started`
**Labels:** `Milestone-Release10`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c22) posted by **rkapsi** on 2011-02-24 at 10:35 PM_
---
Awesome! I don't know if it's of any use for you but our Trie has been under ASL 2.0 for a few years now and has undergone a few refacorings.
&lt;http://code.google.com/p/patricia-trie>
Cheers,
&nbsp;Roger
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c23) posted by **jim.andreou** on 2011-02-25 at 02:35 AM_
---
Yep, will certainly take this into consideration, thanks for the links. I find the last method (#prefixMap(prefix)) especially nifty, exposing the recursive structure of a trie (though I would expect to see the self type being returned, instead of SortedMap, that's lossy).
That said, I have to admit that personally I'm a bit predisposed against patricia. My reasoning is that for the same kind of performance, we could go with a ternary trie, which is more flexible (e.g. no key analyzer, not necessarily unbalanced trees). But I don't trust what "that kind of performance" means for big tries. I'm still going through the literature hunting for other options (e.g. http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.18.3499, http://www.naskitis.com/)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c24) posted by **sberlin** on 2011-02-25 at 02:55 PM_
---
It probably could return the Trie itself, but would require a bit more work to make sure the additional trie operations stayed with the sub-trie range.  Roger & I ate, slept & breathed patricia for a couple weeks while putting this together years ago.. so don't hesitate to ask if you have any questions on it.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c25) posted by **wasserman.louis** on 2011-03-07 at 05:41 PM_
---
I'd be interested in working on this -- heh, I've been living and breathing http://hackage.haskell.org/package/TrieMap for some time now.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c26) posted by **fry@google.com** on 2011-03-23 at 01:48 AM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Milestone-Release10`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c27) posted by **kevinb@google.com** on 2011-07-13 at 06:19 PM_
---
_(No comment entered for this change.)_
---
**Status:** `Accepted`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c28) posted by **fry@google.com** on 2011-12-10 at 03:11 PM_
---
_(No comment entered for this change.)_
---
**Labels:** `Package-Collect`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c29) posted by **ian.g.simpson** on 2012-03-10 at 04:48 AM_
---
Any update on this?  I just checked out 11.0.2 and I still don't see a Trie implementation in it.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c30) posted by **kevinb@google.com** on 2012-03-11 at 11:08 PM_
---
There's been some progress, but unfortunately it's not high-priority. :-(  Unlikely for 13.0, maybe 14.0.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c31) posted by **ian.g.simpson** on 2012-03-22 at 06:23 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c32) posted by **wasserman.louis** on 2012-03-22 at 06:31 PM_
---
It's just not a data structure that has that many use cases or appears that often, I think?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c33) posted by **wasserman.louis** on 2012-03-22 at 06:35 PM_
---
I think starring the issue can't hurt, and might help; ranting and raving _can_ hurt and definitely won't help; talking about why you need this, discussing your priorities for the data structure and outlining some detailed use cases helps more than anything else, but won't necessarily guarantee that it'll be a top priority.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c34) posted by **ian.g.simpson** on 2012-03-22 at 08:24 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c35) posted by **ma...@vekslers.org** on 2012-03-27 at 04:10 PM_
---
I feel that guava could benefit from Trie internal implementation. This can be very efficient for java devs looking to use Scala like data structures. http://www.meetup.com/saylambda/events/47056842/
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c36) posted by **Lichtenberger.Johannes** on 2012-03-28 at 05:24 PM_
---
I'm interested in a persistent approach based on the COW-principle, that is revisions of the tree are stored in a very compact form and updates affect a minimum of nodes (which I think should be the normal case for tries). But most likely I will have to modify an existing implementation or write it from scratch. That is if Lucene can't be used, as I want to provide a full-text index for a versioned tree-structure.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c37) posted by **jon.h.clark** on 2012-03-28 at 05:30 PM_
---
I'd just like to the sentiment that tries are very useful and find uses all over the place. As a PhD student in CS, I work on natural language processing and machine translation. There, we use tries for efficiently storing language models (a bunch of probabilities associated with n-grams) and even translation models (a list of target phrases associated with some source language phrase/n-gram and, of course, more probabilities).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c38) posted by **kevinb@google.com** on 2012-05-30 at 07:43 PM_
---
_(No comment entered for this change.)_
---
**Labels:** -`Type-Enhancement`, `Type-Addition`
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c39) posted by **Sam.Halliday** on 2012-08-01 at 07:30 PM_
---
+1 for Trie, I find myself wanting a solid Java implementation on occasion, and usually fall back to a TreeMap&lt;String> hack which gets the job done (albeit with a much larger memory footprint).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c40) posted by **onlynone** on 2012-08-22 at 02:28 PM_
---
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c41) posted by **phraktle** on 2012-11-15 at 11:53 PM_
---
An interesting project for concurrent tries: http://code.google.com/p/concurrent-trees/
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c42) posted by **Ja...@wetheinter.net** on 2013-01-24 at 01:32 PM_
---
Compared to the org.reflections classpath scanner (which uses MultiMap and single threaded scanning), my Trie-backed implementation can, if scanning multiple jars with multiple threads, run over seven times faster, and deliver deep iterators, instead of multiple MultiMaps delivering set views.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c43) posted by **Ja...@wetheinter.net** on 2013-01-24 at 02:22 PM_
---
Sorry for the double post, but one more place I use Trie's for great effect: My StringTrie which uses char[] or CharSequence as keys, internally uses a CharPool that extends the base Trie structure, and translates a char[], start index and end index into singleton char[] instances (which pass == tests).  This changed my memory footprint from double that of TreeMap to less than half (on larger datasets).
My implementation does not store a node per character; rather, it will store a char[] matching a unique sequence of chars, and using a trie-backed CharPool, it will only create as many arrays as there are unique sequences in your data (and using a shared CharPool shared across instances ensures I never allocate a byte more memory than I need).
In my benchmarks, I found that memory usage on highly-variant, dense data structures (like long sequences of toStringd() random numbers) was quite high (a new char[] per node), but with a CharPool to the rescue, memory usage was based on number of unique sequences + number of unique sequence combinations, instead of unique sequence combinations \* number of sequences per combination.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c44) posted by **knut.wannheden** on 2013-01-24 at 02:40 PM_
---
Hi James,
Any chance that you'll share your implementation? I also have a use case where I'm currently using a TreeMap (which allows for a poor man's prefix matching) and I would like to experiment with a Trie to save some memory.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c45) posted by **Ja...@wetheinter.net** on 2013-01-24 at 04:59 PM_
---
I'll package it up, put it on github in the near future, and reply back here with a link.  Star the issue, and you'll get emailed.
The concurrency support is tied directly into my own internal library (which does let you inject your own implementations for handling threads or ignoring multithreading), but the whole library itself is Not Safe For Work (tm).
If I can't deploy a new version soon, I can put a cut out standalone of the trie and the charpool in a gist instead; just be warned that for small maps, you won't be saving space.  Large maps, especially ones with common prefixes (or subsequences, using a shared CharPool) WILL save you on memory.
For my purposes, I save lots, because I am working with long, repetitive strings (especially when descending into inner classes, methods, fields, vars, etc).  If you just maintain a big map of mostly-unique strings, trie is probably not for you.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c47) posted by **oliver.schrenk** on 2013-03-15 at 12:04 PM_
---
Hi James,
Did you have time to put your trie implementation up on github? I'm interested because I have a large pool of keys sharing very long prefixes and I'm interested in your approach.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=10#c48) posted by **ashwin.jayaprakash** on 2013-03-15 at 05:01 PM_
---
We're not working on this anytime soon...and it will require a lot more investigation and studying.
/n  I think the add Class proxy will be better.
Why don't the add Class Proxy like cglib? Thank you for your answer.
um...
But reflection is the important feature of Java.
If the situation that APIs of reflection poor performance on Android can't be improved.
Do I miss anything?
Any help would be appreciated! Thanks! Hi, I have the goal as test and it worked fine. Thanks for the reply, after I ran "man clean install -DskipTests", it works. I think it just cleaned the old artifacts.  As of 23.3, `com.google.common.collect.TreeTraverser` is deprecated. Are `Files.fileTreeTraverser()` and `MoreFiles.directoryTreeTraverser()` deprecated too? Should users migrate to `java.nio.file.SimpleFileVisitor`?
Note that `MoreFiles.directoryTreeTraverser()` appeared in 21.0 (Java 8), despite `SimpleFileVisitor` presence (Java 7). My understanding was that there wont be any breaking changes after 22.0. So option (a) is actually not an option, is it? @szarnekow I thought that too, but then I remembered that the Guava team also announced that `@Beta` stuff will still be eligible for consideration of removal. Given that `TreeTraverser`'s still in `@Beta`, option (a) is still a valid option AFAICT.  ```
List<String> list=Lists.newArrayList();
public static <T> void tokenTest(T object) throws Exception{
//    TypeToken<T> token=new TypeToken<T>() {};
TypeToken<T> token=(TypeToken<T>) TypeToken.of(object.getClass());
System.out.println(token.getRawType());
System.out.println(token.resolveType(object.getClass().getTypeParameters()[0]));
}
```
if i use the "TypeToken<T> token=new TypeToken<T>() {};",it will throw IllegalStateException.
if i use the "TypeToken.of(object.getClass())",it will get Class of ArrayList,but i want to get the Class of List.
Can i get the Class of List?
Suppliers class has an ofInstance(Tinstance) method which accept a object of type T as value and return a supplier that provides that value. It would be better off that it also has a method for the opposite direction: given a supplier, return it's value. Although we can easily get the value of a supplier by calling supplier.get(), it is feasible only when we already defined a supplier explicitly, we can not do it with a **Lambda** expression. For example:
`String str = (() -> { return "abc" + "def"; }).get();`
The code above is invalid. We have to write this:
```
Supplier<String> supplier = () -> {return "abc" + "def"; };
String str = supplier.get();
```
But if Suppliers class can have a valueOf method, we can write this:
`String str = valueOf(() -> {return "abc" + "def"; });`
That would be much more elegant. Of course, with a very short amount of inner code, it's not necessary to put code into lambda, but if there are many lines of code, putting it into a Lambda will give us better code separation of concern, hence easier to understand. Besides, providing such a method does no harm to the class.
> but if there are many lines of code
Wouldn't you then just typically put the code in a separate private method and just call it? > If there are "many lines of code," you should pull out a method. If there aren't, then you should just execute the logic directly in the function, not in a lambda.
Of course that's the usual way people doing that, but lambda provides an alternative way, which might be useful in some cases, e.g. 5 or 10 lines of code that I wouldn't like to put to a separate method? After all, extracting method requires clearly defining the parameters of the new method, while with lambda, we can refer to the local variables very conveniently. And I believe there are some other benefits. You can just cast it into one supplier.  Guava has immutable and unmodifiable versions of Map and SortedMap (which also satisfies NavigableMap) but nothing for ConcurrentMap, as far as I can tell. Neither does the JDK itself or commons-collections. Immutable and unmodifiable ConcurrentMap implementations would be useful for satisfying bounds checking. Hi @rdicroce. Can you explain what you mean by "bounds checking"?
I ask as I struggle to understand why an unmodifiable concurrent map would be useful, as AFAICT it's kind of the whole point for concurrent maps to be mutable; they're mutable in such a way that multiple threads can safely write to and read from a given map in overlapping time intervals.
If all you want is for the map to be read and not written to, then AFAICT wrapping it in `Collections.unmodifiableMap([...])` or copying it with `ImmutableMap.copyOf([...])` should be enough.
If I've misunderstood something, please do let me know. :) In my case, we had a ConcurrentMap<X, ConcurrentMap<Y, Z>>. We want to get something out of the inner map, but it's possible the key doesn't exist in the outer map. So we used outerMap.getOrDefault(outerKey, ImmutableMap.of()).get(innerKey). But that fails bounds checking because ImmutableMap doesn't implement ConcurrentMap, so we had to change the type to ConcurrentMap<X, Map<Y, Z>>.
So I suppose what I'm really looking for is something like Collections.emptyMap() for ConcurrentMap. A Guava Table could also satisfy this particular case, but I don't see any implementations of it that are thread-safe. A synchronized Table would be a bad idea in our case. We're storing some timestamps so we can quickly determine if a client has the current version of a resource, so we can avoid a DB call. Which means this map gets hit on every request. We did ultimately change the field declaration, but that removes a compile-time safety check. The inner map needs to be thread-safe, so now it is possible for someone to accidentally put a regular Map (e.g. HashMap) that's not thread safe in there.  Could you please reconsider extending `Preconditions` with custom exceptions?
This is a follow up on #1388.
First, reasoning against such feature summed up from #1388 (mostly [this comment](https://github.com/google/guava/issues/1388#issuecomment-61351926)):
1. `Preconditions` are for programming errors (e.g. NPEs), not business logic
Counterargument:
2. Newest Guava leverages Java 8, so now a lightweight implementation is possible:
public final class Preconditions {
(...)
public static void checkArgument(boolean expression, Supplier<? extends RuntimeException> exceptionSupplier) {
if (!expression) {
throw exceptionSupplier.get();
}
}
(...)
}
```
and usage:
checkArgument(expression, () -> new MyCustomRuntimeException());
``` Thanks  So that projects depend on this can be published to a public artifact repository.
Note that this is not breaking backward compatibility. All codes except this file can be still compiled in Java 6. Guava has an `Automatic-Module-Name` in its `MANIFEST.MF` now, so I believe this is not quite as important as it may seem. But if I'm mistaken, then I'd be more than happy to be proven wrong.
https://github.com/twonote/radosgw-admin4j/blob/java9/pom.xml#L127
@cpovirk could you tell me more about this problem?  Java 9 has just introduced the "Convenience Factory Methods for Collections" feature. As `ImmutableList.of()` and similar methods in Guava, these factory methods create unmodifiable collections and prohibit null elements. The created collections are serializable if all of their elements are serializable.
Please find more details on http://openjdk.java.net/jeps/269.
It's worth considering to extend the Javadoc of the corresponding Guava classes (`ImmutableList`, `ImmutableMap` and `ImmutableSet`) like it happened in 3afc6e45c39504ece02d14f4a462f65acfa98652 to discourage using the old factory methods in favor of the Java 7 diamond syntax. The reason I'm using `ImmutableList` et.al. in favour of `Collections.unmodifiableCollection` is the semantic type in my API. It's clear that I return an immutable type. Whereas returning just `Collection` will confuse callers with runtime exceptions. To add to @ooxi's comment, I'd also argue that using `Immutable*` consistently prevents unnecessary copying when using `Immutable*.copyOf([...])` a lot for defensive programming reasons. Thank you all for sharing your points on this. All of them are completely reasonable.
But in that case I am wondering if it could be possible to extend the Javadoc or https://github.com/google/guava/wiki/ImmutableCollectionsExplained Wiki page to highlight why Java 9 folks should still prefer the immutable collections provided by Guava instead of using the new ones in JDK.  A symlink should work.  Hi, following is in Kotlin, I hope you don't mind.
**My Service**
class TestService : AbstractExecutionThreadService() {
// ~ Properties -------------------------------------------------------------------------------
private val L = logger()  /* slf4j logger */
val inputQueue = SynchronousQueue<String>()
// ~ Initializers -----------------------------------------------------------------------------
init {
addListener(
object : Service.Listener() {
override fun starting() {
L.info("starting")
}
override fun running() {
L.info("running")
}
override fun failed(from: Service.State, failure: Throwable) {
L.info("failed: ${failure}")
}
override fun stopping(from: Service.State) {
L.info("stopping")
}
override fun terminated(from: Service.State) {
L.info("terminated")
}
},
Executors.newSingleThreadExecutor()
)
}
// ~ Methods ----------------------------------------------------------------------------------
override fun run() {
while (true) {
val event = inputQueue.take()
if (event == "CRASH") {
} else if (event == "SHUTDOWN") {
break
}
}
}
override fun triggerShutdown() {
while (state() == Service.State.STOPPING) {
if (inputQueue.offer("SHUTDOWN", 500, TimeUnit.MILLISECONDS)) {
break
}
}
}
}
```
**My Tests**
```
@Test
fun startAndShutdown() {
val app = TestService()
val sm = ServiceManager(listOf(app))
sm.startAsync().awaitHealthy()
sm.stopAsync().awaitStopped()
}
@Test
fun startAndShutdown() {
val app = TestService()
val sm = ServiceManager(listOf(app))
sm.startAsync().awaitHealthy()
app.inputQueue.put("CRASH")
sm.stopAsync().awaitStopped()
}
```
The first test, starting and stopping works fine and gives the following output:
```
[pool-1-thread-1]         a.f.m.TestService*             INFO    starting
[main]                    a.f.m.TestService*             INFO    triggerShutdown
[pool-1-thread-1]         a.f.m.TestService*             INFO    running
[main]                    a.f.m.TestService*             INFO    offer
[pool-1-thread-1]         a.f.m.TestService*             INFO    stopping
[pool-1-thread-1]         a.f.m.TestService*             INFO    terminated
```
The second test, where I post an event that is supposed to crash the run-loop sometimes works with this output:
```
[pool-1-thread-1]         a.f.m.TestService*             INFO    starting
[pool-1-thread-1]         a.f.m.TestService*             INFO    running
[pool-1-thread-1]         a.f.m.TestService*             INFO    failed: java.lang.IllegalStateException
```
And sometimes the `triggerShutdown` method hangs, because it posts to `inputQueue` and nobody `takes` from there:
```
[pool-1-thread-1]         a.f.m.TestService*             INFO    starting
[pool-1-thread-1]         a.f.m.TestService*             INFO    running
[main]                    a.f.m.TestService*             INFO    triggerShutdown
[main]                    a.f.m.TestService*             INFO    offer
[main]                    a.f.m.TestService*             INFO    offer
[main]                    a.f.m.TestService*             INFO    ...
```
Why is the logging listener not called all the time? Sometimes the stopping event is logged, sometimes it's not there. When `main` hangs in `triggerShutdown`, the `Failure` event is never logged.
```
[pool-1-thread-1]         a.f.m.TestService*             INFO    starting
[main]                    a.f.m.TestService*             INFO    triggerShutdown
[pool-1-thread-1]         a.f.m.TestService*             INFO    running
[main]                    a.f.m.TestService*             INFO    offer
[pool-1-thread-1]         a.f.m.TestService*             INFO    stopping
[main]                    a.f.m.TestService*             INFO    offer
[main]                    a.f.m.TestService*             INFO    offer
[main]                    a.f.m.TestService*             INFO    offer
[main]                    a.f.m.TestService*             INFO    offer
```
Is there another way in my scenario to access `state()` in `triggerShutdown` to see whether the service has exited while we tried to shut it down? Wbat I'm doing now is `while(isRunning())` instead of `true` and just `offer` the shutdown message once, without any waiting. If `run()` is blocked, it take the message and abort, if it is busy it will check `isRunning()` on the next loop-iteration.  Thanks. In any case I would add to the description of `triggerShutdown` that it should be fast and that it's not supposed to block, similarly do how `doStart()` is described in the docs.
I believe that every blocking action there could be replaced with some smarter construct. Ah, good find. If you happen to find a solution to the issue above, please tell.
A `ClosableQueue` would be a nice addition to guava.  I do exactly this in Gradle and it works perfectly.  **app: guava
version: 20.0**
**code 1:**
```
public class EmbedMonitoredServices {
// ------------------------------------------------------------------------
private static final Logger logger = LoggerFactory.getLogger(EmbedMonitoredServices.class);
private static final Set<Service> monitoredServices = Sets.newHashSet();
private static ServiceManager monitoredServiceManager;
private static MonitoredWebService monitoredWebService;
// ------------------------------------------------------------------------
private static MonitoredWebService getMonitoredWebService() {
if (monitoredWebService == null) {
monitoredWebService = new MonitoredWebService();
}
return monitoredWebService;
}
private static ServiceManager getMonitoredServiceManager() {
if (monitoredServiceManager == null) {
monitoredServices.add(getMonitoredWebService());
monitoredServiceManager = new ServiceManager(monitoredServices);
}
return monitoredServiceManager;
}
// ------------------------------------------------------------------------
public static ServiceManager manage() {
return getMonitoredServiceManager();
}
// ------------------------------------------------------------------------
public static class MonitoredWebService extends AbstractService {
// --------------------------------------------------------------------
private static final String CONTEXT_PATH = "/scout-web-monitor";
private static final String PACKAGE_PATH = EnvironmentContents.PROJECT_HOME + "/lib/ext/scout-web-monitor-1.0.0.war";
private static Server server;
// --------------------------------------------------------------------
protected void doStart() {
server = new Server(8080);
MBeanContainer mbContainer = new MBeanContainer(ManagementFactory.getPlatformMBeanServer());
server.addBean(mbContainer);
WebAppContext webapp = new WebAppContext();
webapp.setContextPath(CONTEXT_PATH);
webapp.setWar(PACKAGE_PATH);
webapp.addAliasCheck(new AllowSymLinkAliasChecker());
webapp.addLifeCycleListener(new LifeCycle.Listener() {
public void lifeCycleStarting(LifeCycle event) {
LoggingUtils.info(logger, manage().servicesByState());
}
public void lifeCycleStarted(LifeCycle event) {
LoggingUtils.info(logger, manage().servicesByState());
notifyStarted();
LoggingUtils.info(logger, manage().servicesByState());
}
public void lifeCycleFailure(LifeCycle event, Throwable cause) {
notifyFailed(LoggingUtils.error(logger, cause));
}
public void lifeCycleStopping(LifeCycle event) {}
public void lifeCycleStopped(LifeCycle event) {
notifyStopped();
}
});
server.setHandler(webapp);
try {
server.start();
// erver.dumpStdErr();
server.join();
} catch (Exception e) {
throw LoggingUtils.error(logger, e);
}
}
protected void doStop() {
try {
server.stop();
} catch (Exception e) {
throw LoggingUtils.error(logger, e);
}
}
}
}
```
```
public static void startMonitoredService(PrintStream stdout, NmapProfile profile) throws Exception {
showLogo(stdout);
Environments.initializeLogback();
LoggingUtils.info(logger, "Start Monitored Service.");
EmbedMonitoredServices.manage().startAsync().awaitHealthy();
LoggingUtils.info(logger, "Monitored Service started.");
LoggingUtils.info(logger, "Monitored Service started.");
}
```
**print:**
```
[INFO] Start Monitored Service.
[INFO] Logging initialized @5375ms
[INFO] jetty-9.2.22.v20170606
[INFO] {NEW=[MonitoredWebService [STARTING]]}
[INFO] jetty-9.2.22.v20170606
[WARN] ServletContext@o.e.j.s.ServletContextHandler@542e560f{/,null,STARTING} has uncovered http methods for path: /
[INFO] Started ServerConnector@8c11eee{HTTP/1.1}{0.0.0.0:61614}
[INFO] Started @6749ms
[INFO] {NEW=[MonitoredWebService [STARTING]]}
[INFO] {NEW=[MonitoredWebService [RUNNING]]}
[INFO] Started ServerConnector@32a068d1{HTTP/1.1}{0.0.0.0:8080}
[INFO] Started @7163ms
``` OK,I know,comment line server.join is work fine.  Hi,
It's generated by the https://github.com/lvc/japi-tracker tool according to the article https://wiki.eclipse.org/Evolving_Java-based_APIs_2.
Hope it will be helpful for users and maintainers of the library.
Thank you.
See also report for Guava GWT: https://abi-laboratory.pro/java/tracker/timeline/guava-gwt/  When creating `ImmutableSortedMap` instances the documentation for methods `copyOf` and `copyOfSorted` state:
> "NullPointerException - if any key or value in map is null"
However this behavior is not consistent an it is possible to create a map with null values.
Given a `HashMap` of stings with `map:{a:null}` all the `copOf` methods throw as expected, with a `map:{a:null, b:two}` then none of the `copyOf` methods throw.
Given a `SortedMap` of strings with `map:{a:null}` and a natural order `copyOf` and `copyOfSorted` all throw as expected; with a `map:{a:null, b:two}` then `copyOf(Map)` and `copyOfSorted(SortedMap)` throw; `copyOf(Iterable)`, `copyOf(Iterable, Comparator)`, `copyOf(Map, Comparator)` do not throw; with a `map:{a:one, b:null}`
`copyOf` and `copyOfSorted` all throw as expected.
From what I can tell this behavior is only present for maps with two elements and only when the `null` is the first value of the first key. The `of` and `builder` methods are not effected an throw as expected.
Move to the correct pom.xml.
Fixes #2920
Feel free to make a separate change rather than merging this PR to satisfy any IP rules. @jodastephen By my understanding, if you just sign the Google CLA, then that should be enough to allow this PR to be considered for merging. I signed it! As it stands, I don't think its clear how test libraries will operate with modules - I suspect that modules don't really apply there. If runtime code might depend on testlib then of course it should have a module name.  There are several issues with using `jsr305.jar` by Guava.
JSR-305 is dormant, has been for a long while and shows no hope of ever producing an agreed set of annotations in our lifetime. Further more these annotations use `javax.` packages which it is not possible to use according to the Oracle Java binary licence, so applications can not use and ship these dependencies along with a JRE without violating the Oracle licence agreement.
> F. JAVA TECHNOLOGY RESTRICTIONS. You may not create, modify, or change the behavior of, or  authorize your licensees to create, modify, or change the behavior of, classes, interfaces, or subpackages that are in any way identified as "java", "javax", "sun", oracle or similar convention as specified by Oracle in any naming convention designation.
The JSR-305 group has not defined any official releases according to its jsr page so the only implementations is a seemingly random implementation provided by the FindBugs team. Even if the team where experts on the JSR (which some where) they are not official as there has been no vote and are not available from the JSR hompage - so the javax package name restriction still applies.
Using `jsr305` causes additional issues, if Guava is used in a modular JDK9 applications, because it puts the annotations into `javax.annotation` package, which is also used by a couple of other JAR-s and a legacy JDK module `java.xml.ws.annotation`. If one wants to create a modular JDK9 application with two dependencies to conflicting JAR-s, Java refuses to compile and run it because of a package split. Example:
* Guava -> forces us to require `jsr305` automatic module,
* Dagger -> forces us to require either `java.xml.ws.annotation` or `jsr250` automatic module.
All of the modules use `javax.annotation`.
Findbugs has been rebooted as Spotbugs and they are going to make a switch from JSR-305 to their own internal annotations in version 4.0.0 that do not break anything:
https://github.com/spotbugs/spotbugs/pull/180
I think Guava should consider switching to them in order not to pollute application dependencies with `jsr305` JAR. I agree that this is more a long-term action. I created this issue more to raise the awareness of the problems with `jsr305` and new Java. Spotbugs 4.0 is not released yet, and other tools would have to agree for a new set of annotations, and provide the sufficient support. But on the other hand, Guava is in the right position to influence a decision, which way to go.
* avoiding it will only reduce the problem, not remove it (JSR-250 contains other annotations, too - if any of them is in use by any dependency or main project, you need to patch the modules).
* Java 9 provides a new, unambiguous variant: `javax.annotation.processing.Generated`,
* you can detect which one of them is available by the classloader, and generate the code either without any annotation, with `javax.annotation.Generated`, or with `javax.annotation.processing.Generated`. For JDK8, it would work "as usual", and for JDK9, it would depend on the required JDK module in the application module descriptor, so that the developer has a choice, which way to go.
I appreciate that you didn't forget about `Generated` :). > If we're moving off the "standard" annotations, I wonder what it makes the most sense for us to migrate to.
Adopting the Checker Framework's annotations may make sense here. Considering that, AFAIK, its nullability annotations are the most plentiful and advanced out there, it may encourage more people to try the framework out.
But if its annotations count as type annotations, then we'd be unable to use them... > Hopefully most tools care only about the simple class name of the annotations, not their packages.
This is not true of Kotlin, although they'll be receptive to adding your annotations to their list. Looking at the options, it seems to me that Checker Framework would be a good solution. Thanks for pointing me to that, @jbduncan. I'm curious what the replacement for `javax.annotation.concurrent.Immutable` is with Checker Framework, if there is one - do you happen to know, @jbduncan? @kashike I admit that I don't know if the Checker Framework has an `Immutable` annotation, but I _do_ know that error-prone's annotations project has one. I've never tried the Checker Framework personally, so I don't know how it behaves in combination with error-prone (which, by comparison, I _have_ used), but theoretically if one can get them to work nicely together, then we'd have a superior, statically analysed solution to `javax.annotation.concurrent.Immutable`. ...but that's not even considering the other sorts of annotations that we're already using and will probably still want to use, like `@Nullable`...
This may get tricky. The Checker Framework authors themselves suggest that their own type annotations are [backwards-compatible](https://checkerframework.org/jsr308/jsr308-faq.html#backward-compatibility) with Java 6, but only if they're written inside comments.
Does it? I [don't see everything](https://github.com/spotbugs/spotbugs/tree/master/spotbugs-annotations/src/main/java/edu/umd/cs/findbugs/annotations) that was listed [above](https://github.com/google/guava/issues/2960#issuecomment-336681820) - it appears as if some annotations that are used by Guava are not in spotbugs.
As for Checker Framework: it appears to have most things, except `@Immutable`: https://gist.github.com/kashike/d8fb2007ab01041a08a2d5cf20bc2d17
~...create a custom `@Immutable` annotation?~ It seems as if errorprone has one already, actually.
@kashike Apologies if I've not explained myself very well before, but I just want to make sure we're both on the same page with regards to the Checker Framework's annotations.
It seems to me from what @cpovirk's said already and what I personally know of the Checker Framework's annotations that, sadly, since they are  _type annotations_, they can only be used in Java 8+ projects - JSR308, which is what type annotations are derived from, is only implemented in compilers that understand Java 8.
The only workaround I've found so far (suggested by the Checker Framework authors [here](https://checkerframework.org/jsr308/jsr308-faq.html#backward-compatibility)) is to write type annotations in comments. So, for example, instead of:
List<@Nullable String> listOfNullsAndStrings = ...;
```
we'd have:
List</*@Nullable*/ String> listOfNullsAndStrings = ...;
```
The Checker Framework understands type annotations written like this, but I somewhat doubt other tools like IntelliJ IDEA, {Find,Spot}Bugs, and Google's internal tools understand them written like this too. Thus, we may not be able to use the Checker Framework's annotations in Guava until Android catches up.
If you did understand this already, apologies! Otherwise, I hope that this has cleared things up a bit. :) Thanks for the reply, @jbduncan. I'm also looking at what to use in my own projects (which are Java 8) - sorry for not stating this.
I've been using `com.google.code.findbugs:jsr305` for a long time now, but this issue has made me want to switch to something new (which, in this case, is currently going towards `org.checkerframework:checker-qual`) for annotations on things (I annotate pretty much everything that can be annotated with `@Nonnull` or `@Nullable`, as well as `@Immutable`). `checker-qual` seems to have everything *except* `@Immutable`.
This is continue of #2152 the problem still exists, but this time on java 9.
```log
java version "9"
Java(TM) SE Runtime Environment (build 9+181)
Java HotSpot(TM) 64-Bit Server VM (build 9+181, mixed mode)
```
I've tested with 22.0, 23.0, 23.1
Tested with 23.1 as well, on java 8 it works fine but on java 9 not discovering anything.
i don't use special chars it was working fine on 22.0 i've upgraded my project to java 9 and it didn't discover any class then i tried 23.0 and 23.1 versions and none of them discovered any class. Same way as shown in #2152
@Test
public void testMain() throws Exception {
ClassLoader loader = this.getClass().getClassLoader();
ClassPath p = ClassPath.from(loader);
ImmutableSet<ClassPath.ClassInfo> list = p.getTopLevelClasses("testpackage");
Assert.assertEquals(3, list.size());
}
```
Also tried with `ClassLoader.getSystemClassLoader()` and `Thread.currentThread().getContextClassLoader()` Upgrading to 23.1 fixed the issue for me.
```
openjdk version "9"
OpenJDK Runtime Environment (build 9+181)
OpenJDK 64-Bit Server VM (build 9+181, mixed mode)
```
Using like this from kotlin:
val topClasses = ClassPath.from(SomeClass::class.java.classLoader).topLevelClasses
```  Hacktoberfest looks like a good opportunity to get some project exposure as well as get some issues worked. Any contributors/maintainers interested in tagging some issues with the `hacktoberfest` label?  Awesome! Just thought I would toss the idea out there.  Here is an example where someone modified the TreeSet and TreeMap to include indexing functionality:
https://code.google.com/archive/p/indexed-tree-map/
I find this to be very useful, and is easily added to any binary search tree.  Just include the weight of each subtree, and update the weights as necessary.  Use the weights to find nodes by index, and vice-versa. It is more similar to the existing tree multi set. I found a couple of more examples.  In javolution.org, they have a FastSortedTable, which supports indexing.  No idea if it uses a tree, but it is basically a multiset.
http://javolution.org/apidocs/index.html
Then the Goldman Sachs / Eclipse Collections has something called TreeSortedSet, and UnmodifiableSortedSet.  These have indexOf, and forEach using a range of indices.
https://www.eclipse.org/collections/javadoc/9.0.0/index.html?overview-summary.html
This may be the closest description:
https://en.wikipedia.org/wiki/Order_statistic_tree
@jrtom Sorted lists. Like some sort of alternative to `MinMaxPriorityQueue`? - uniformly random selection
- median and other quantiles
agree with @maaartinus. you can use this extended ability to create stemplots of any size, too. @lowasser Your alternative may be very inefficient if the data set is modified frequently. What's more, it only supports Doubles. It is a better alternative to GapList here https://dzone.com/articles/gaplist-lightning-fast-list   Fix misspelled method name from "substing" to "substring".  In version 23.1, it looks to me that `com.google.common.graph.Traverser` has been released, but that the class has not been fully implemented yet. Was it intended to release Traverser so soon?
/cc @cgdecker  SGTM @jrtom. I'll close this issue then, as I anticipate it will resolve itself eventually. :)  Now,I have a need that get a live view of Map<K,V> from collection<V>.
Originally,i thought Maps.uniqueIndex was what I wanted.
But,i found that the Maps.uniqueIndex return type is ImmutableMap,it don't update when the collection<V> update.
For example:
```
super();
this.id = id;
this.type = type;
this.code=code;
this.author = author;
}
private Long id;
private String code;
private String type;
public String toString() {
return ToStringBuilder.reflectionToString(this, ToStringStyle.NO_CLASS_NAME_STYLE);
}
}
```
I want to get a Map<Long,TestGuavaA> idToObjects,a Map<String,TestGuavaA> codeToObjects from a collection<TestGuavaA>,and modifications to the backing collection are read through to the two returned map.
This like Maps.asMap ,but is inverse.
How can i do it? Or how can i get a live view of Map<K,V> from Map<T,V>?
For example:I want to get a Map<Long,TestGuavaA> idToObjects from a Map<String,TestGuavaA> codeToObjects,and modifications to the backing map are read through to the two returned map. Thank you.I know why we can't get a live view.
But how about this idea that use decorator pattern and observer pattern to create a Map of  keep update?
What's wrong about my thinking? Thank you.   @JainSid96 @cpovirk It's not really clear to me what purpose this PR serves, given that it contains many existing commits from master. Could you clarify its purpose for me? @JainSid96, would you mind at all closing this PR? AFAICT, it is just tracking the new commits that are being added to Guava, and thus it's spamming my email inbox.  Java 8u144 (Mac 10.11.6)
Expected: Calling `parallelStream()` on an ImmutableMap-derived Set should lead to pipeline execution on multiple threads. Calling `spliterator()` on a ImmutableMap-derived Set should yield a splittable (`trySplit() != null`) spliterator.
Actual: Pipeline executes on main thread only. Spliterator is not splittable.
Diagnosis:
The spliterator is ultimately constructed using an `IntStream#range` which is sequential. The `AbstractWrappingSpliterator` that results from the `mapToObj` checks the stream context and refuses to split if the stream is sequential (even though the underlying spliterator is splittable, see `trySplit:189, StreamSpliterators$AbstractWrappingSpliterator (java.util.stream)`). `RegularImmutableSet` and friends are constructed using `ArraySpliterator`, which don't have this problem.
```
range:798, IntStream (java.util.stream)
indexed:94, CollectSpliterators (com.google.common.collect)
indexed:40, CollectSpliterators (com.google.common.collect)
spliterator:386, ImmutableSet$Indexed (com.google.common.collect)
parallelStream:602, Collection (java.util)
```
```
public class Problem {
public static void main(String[] args) {
Set<String> list = Stream.iterate("a", str -> str + "a")
.limit(1000)
.collect(toImmutableMap(Function.identity(), Function.identity()))
.keySet();
Logger logger = Logger.getAnonymousLogger();
logger.info("Parallel stream is parallel: " + list.parallelStream().isParallel());
logger.info("Parallel stream's spliterator can be split: "
+ (list.parallelStream().spliterator().trySplit() != null));
ThreadLocal<Boolean> invoked = ThreadLocal.withInitial(() -> false);
list.parallelStream()
.map(str -> {
if (invoked.get()) {
return str;
}
invoked.set(true);
logger.info("Parallel stream executed on thread " + Thread.currentThread().getName());
return str;
})
.forEach(str -> {});
}
}
```
Expected:
```
INFO: Parallel stream is parallel: true
INFO: Parallel stream's spliterator can be split: true
INFO: Parallel stream executed on thread main
INFO: Parallel stream executed on thread ForkJoinPool.commonPool-worker-4
INFO: Parallel stream executed on thread ForkJoinPool.commonPool-worker-2
...
```
Actual:
```
INFO: Parallel stream is parallel: true
INFO: Parallel stream's spliterator can be split: false
INFO: Parallel stream executed on thread main
```  Fix addresses a problem occurred on IBM JDK 6. To ensure
that we can call underlying method, Throwables#getSizeMethod,
to get  stack size, first a smoke test  with dummy exception.
Once method executed with success, it is safe to return it for
further usage.
Issue: https://github.com/google/guava/issues/2887 For the sake of clarification: there were two obvious ways:
- Guard a call to `JavaLangAccess#getStackSize` inside `AbstractList#size` in `Throwables#jlaStackTrace` with `try-catch`
- Make a dry call of `JavaLangAccess#getStackSize` and if it success, then assume, that it is safe to call it
We can go with the first option, however, I think, that second seems more elegant.  @cpovirk
Exactly. I think it just ensures that API works fine, instead of making only one method out of two work as designed.
The resolution piggy-backs on documented Maven [`ComparableVersion`](http://maven.apache.org/ref/3.5.0/maven-artifact/apidocs/org/apache/maven/artifact/versioning/ComparableVersion.html) feature that equates `ga`-suffixed versions (e.g. `24.0-ga`) with non-suffixed ones (e.g. `24.0`) in the context of comparing / ordering / determining the latest version.
Note: This also reverts [the patch](https://github.com/google/guava/commit/61d2a6faec8b27d021b9f37f7dfb6655ae060fad) by @cpovirk, restoring the original vanilla (Java 8+) Guava versioning scheme (e.g. from patched `24.0-jre` back to `24.0`).
Note: [`README.md`](https://github.com/google/guava/blob/master/README.md#latest-release) text should be updated before releasing the next version to reflect the suffix change for the Android version. I have read the issue linked. Nevertheless I think using `-ga` instead of `-android` will lead to a lot of confusion. Without having seen this pull request I would not have known the difference between `24.0` and `24.0-ga` and would most likely have picked `24.0-ga` when updating (since general availability seems better than no suffix). @ooxi You'd have every right to get confused initially (even though such mistake would usually get immediately realized at your project compile time) - what Guava is trying to achieve with releasing both android/java7 and java8+ artifacts is indeed confusing. Arguably, they do have a reason for doing this, though.
Wikipedia's Software release life cycle article has this diagram:
![Software release life cycle](https://upload.wikimedia.org/wikipedia/commons/0/07/Software_dev2.svg)
which probably (yet not necessarily) reflects some majority opinion / consensus on the topic.
Anyway, in case of a doubt a quick glance at [Guava project landing page](https://github.com/google/guava/#latest-release) should clear any confusion and make the choice between vanilla and android/java7-specific version reasonably obvious. Thank you for such an in-depth explanation of your reasoning. While I still would have been confused and would likely have chosen the wrong version at first, you are right in your estimation that it would have been more logical to use `24.0` than `24.0-ga`. I therefore withdraw my initial rejection of this change.  We've got an `Equality` helper class in our code base that helps us implement `equals` and `hashCode` methods, and I think it'll be a nice feature for guava. It's similar to `ComparisonChain`, but for equality.
The API is basically this:
public boolean equals(Object obj) {
return Equality.startComparison(this, obj, MyObj.class)
.superEquals(super::equals)
.field(MyObj::val1)
.field(MyObj::val2)
.intField(o -> o._int)
.booleanField(o -> o._bool)
.arrayField(o -> o._array)
.result();
}
public int hashCode() {
return Equality.startHash(this)
.superHashCode(super::hashCode)
.field(MyObj::val1)
.field(MyObj::val2)
.intField(o -> o._int)
.booleanField(o -> o._bool)
.arrayField(o -> o._array)
.result();
}
public boolean staticEquals(T obj1, T obj2) {
return Equality.startComparison(obj1, obj2)
.field(...)
.field(...)
.result();
}
The benefits of this API are:
- It automatically handles null checks, casting, object equality, type safety, and short-circuits when appropriate.
- Implementing `equals` and `hashCode` are symmetric - just copy and paste the `.field(...)` calls. It's also easy to see if you've missed out a field from one of the methods
- It removes all the boilerplate otherwise necessary, and you can easily see what is used to determine equality in the class.
There is AutoValue, but there are many situations where you can't or don't want to use auto-generated classes like that, and this can be used to easily replace existing equals methods without otherwise changing the class. There are some cases where you either can't or don't want to use AutoValue, and then this API will really help with those manual implementations.
This API is also very useful for easily writing an `Equivalence` implementation.   Scenarios like the following happen way too often:
List<Integer> myList = ...;
int myInt = myList.size > 1 ? myList.get(1) : -1;
```
My suggestion is to add a method to the `ObjectArrays` and `Lists` classes which gets an element out of a list/array or returns the default value when the index of the element is out of bounds.
Example usage:
List<Integer> myList = ...;
int myInt = Lists.getDefault(myList, 1, -1);
```
This could also be done with `Optional`s:
List<Integer> myList = ...;
int myInt = Lists.get(myList, 1).orElse(-1);
``` This is already in `Iterables`, no?
Iterables.get(myList, 1, -1);
```
And its docs also note the JDK8 equivalent, which could also be used for arrays:
Arrays.stream(myArray).skip(1).findFirst().orElse(-1);
```  The [lookup3.hashlittle()](http://www.burtleburtle.net/bob/hash/doobs.html) hashing function is useful for anything where one collision in 2^32 is acceptable, as described in the c code documentation. As I found no implementation for java in any well-known library, I believe that the adding this hashing function to Guava is a good addition to the library and users of the hashing package.
If accepted, I would like to contribute with code to add this feature. Thank you in advance. I am proposing to add an entire `HashFunction` implemented in java. I think that it is a good addition to compute hashes for table lookups.
An example usage case is to get the checksums for the HDF5 fileformat, which uses it for computing the checksum of different file blocks.  Refer to objects by their interfaces(Item 52) I signed it!  Example:
if (Objects.equal(status, "STOPPED") || Object.equal(status, "RELEASED") || Object.equal(status, "DELETED")) {
// do something
}
```
Could we add a method `Objects.equalAny(Object, Object...)`, then example will be:
if (Objects.equalAny(status, "STOPPED", "RELEASED","DELETED")) {
// do something
}
```
It's simple, right?
Here is my implementation:
public static boolean equalAny(@Nullable Object a, @Nullable Object... any) {
if (any == null && a == null) {
return true;
} else if (any != null) {
for (Object obj : any) {
if (equal(a, obj)) {
return true;
}
}
}
return false;
}
``` Can't you just do:
if (Arrays.asList("STOPPED", "RELEASED", "DELETED").contains(status)) {
// do something
}
``` @Stephan202 `Arrays.asList()` no dependency and maybe more faster for several elements;
@kluever `ImmutableSet.of()`  elegant and fast for much more elements;
Both ok, thanks  @lowasser  Maybe there should be `Ints.reverse(int[])`? Then a two step solution would be fast. If there is reverse sorting, I would think there should be an interface for implementing your own comparator (`IntComparator`, `FloatComparator`, etc.) which behave like a `Comparator`, but for primitives.
Ints.sort(new int[] {5, 2, 3, 1}, Ints::compare); // IntComparator can be functional
```
There would need to be an implementation of sorting (mergesort, quicksort) which utilizes the custom comparator interface - one for each primitive potentially.
@thekeenant On the other hand, that library looks like it's licensed under the GPLv2 + Class Exception, which doesn't sound great to me for projects except GPL-licensed ones. That's what the classpath exemption is for.
On Fri, Sep 8, 2017 at 3:52 PM Jonathan Bluett-Duncan <
notifications@github.com> wrote:
> Edit: On the other hand, that is quite a bit of baggage to add, might as
>
> @thekeenant <https://github.com/thekeenant> On the other hand, that
> library looks like it's licensed under the GPLv2 + Class Exception, which
> doesn't sound great to me for projects except GPL-licensed ones.
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2936#issuecomment-328198178>, or mute
> the thread
> .
>
Note that [fastutil](https://github.com/vigna/fastutil) has `IntArrays#quickSort(array, IntComparator)`. Similar support is provided for other primitive types plus other sort strategies. For those who work with primitives for performance reasons, they may already be using libraries dedicated towards that purpose.   here is the requirements:
I need to manipulate the bits array directly in my case, but since the bloomfilter is a final class, I cannot extend and use such private member directly.
any explanation why set it to be final class? still it's about the implementation of the bloomfilter
https://github.com/google/guava/blob/master/guava/src/com/google/common/hash/BloomFilter.java > any explanation why set it to be final class?
I think it's final for the reason given in [Effective Java 2nd Edition](https://www.amazon.co.uk/Effective-Java-Second-Joshua-Bloch/dp/0321356683), _Item 16: Favor composition over inheritance_. ...but the Guava team may be able to clarify if I'm mistaken on this. :)  It's often necessary to know the size of the collection being built. For example, to special case if this is the first element, or if the collection is empty. The workarounds are ugly.
This should be free for most builders since they already track the size. I only care about this for `List`, `Set`, and `Map`, so if it's fine if it can't be added for more exotic collections like `ListMultimap`.
I believe this has been done for `ImmutableList` [recently](https://github.com/google/guava/commit/7928bbe079303c54373453353c9ef2cd7de9365e) - so recently that it's not had the chance to make it into a release yet. AFAICT, sized builders have yet to be added for `ImmutableSet` and `ImmutableMap`. Oops, I think I posted too quickly for my own good!
If I understand what you're asking, you're asking for a method like `Immutable{List,Set,Map}.Builder#size`  for querying the size of a builder, rather than builders which are pre-sized to a certain size. Have I understood you correctly? (@lowasser got there before me. :) ) @jbduncan yes, exactly. Apologies for not explaining more clearly.
@lowasser that's a great point about duplicates for `ImmutableSet`.
We could add a `size()` method for `ImmutableList`, `ImmutableMap`, and any others where it makes sense and is free. Additionally, we could add an `isEmpty()` method for most/all builders. Knowing if the collection is empty will cover a good number of use cases, though sometimes you do need the size (most often for `ImmutableList`).  Related Pull request to fix the documentation https://github.com/google/guava/pull/2916 has been merged.
If the delegate in the Suppliers.memoize throws an exception on calling get() then further calls to the get() method of the Memoized suppliers still goes to the delegate. With the pull request the Javadocs clarify that there is a danger that the underlying delegate could be called more than once.
What we need is a method with the following signature
`Suppliers.memoize(Supplier<T> delegate, boolean memoizeExceptions)`
By default the single argument memoize method could delegate to the above method with a "false" flag i.e, exceptions are NOT memoized by default. However if true is passed then even when the delegate throws an exception, that exception is stored by the memoized supplier and is re-thrown everytime it is called.
**Use cases where this can be used**
- A class X uses a memoized Supplier the delegate talks to an external Paypal like service or a configuration service. When the delegate fails we do not want to retry the external service (until such time as we have a notification that the external service is back up in which case class X re-initializes the supplier)
- A class X has a memoized supplier with expiration of 5 seconds and wants an absolute guarantee that even in the case of failures the underlying delegate is NEVER called more than once in 5 seconds.
I am happy to contribute a patch if this new API is accepted.  Any updates? I am very happy to contribute a patch if people think this is a sensible change to implement Just an opinion, but I feel like memoizing the exception could have some "surprising" behavior:
- As @kevinb9n mentioned, it would still have the original stacktrace when it's rethrown on subsequent calls, which could be confusing and unhelpful to people trying to debug it.
- Exception classes sometimes assume that they're going to be immediately used by the "catch" block and then discarded. Some of them might store "heavyweight" data, expecting that will be garbage collected shortly. Or they may even reuse and modify objects within the exception at a later time, which would be (incorrectly) reflected when the original exception is rethrown later.
I think it's better if it's responsibility of the original supplier to provide additional behavior like memoizing exceptions (as appropriate to your application) or throttling calls.  @eldk Have you tried updating to the latest version of `guava-android` (23.0, I believe) instead? :) (You can find the Maven/Gradle co-ordinates for `guava-android` at https://search.maven.org/#artifactdetails%7Ccom.google.guava%7Cguava%7C23.0-android%7Cbundle). Thanks for letting me know the results of applying 23.0-android @eldk! This is out of my league now unfortunately, so let's wait for someone from the Guava team to reply. Those rules are vastly overly keep-y. Why are you suppressing warnings and
then also keeping for each?
On Mon, Aug 28, 2017 at 3:32 PM eldk <notifications@github.com> wrote:
> Hello,
>
> With :
> -dontwarn java.lang.ClassValue
> Proguard (4.7) still throw errors.
>
> In #2117 <https://github.com/google/guava/issues/2117> the link to that
> topic
> https://stackoverflow.com/questions/9120338/proguard-configuration-for-guava-with-obfuscation-and-optimization
>
> -dontwarn com.google.common.base.**
> -keep class com.google.common.base.** {*;}
> -dontwarn com.google.errorprone.annotations.**
> -keep class com.google.errorprone.annotations.** {*;}
> -dontwarn com.google.j2objc.annotations.**
> -keep class com.google.j2objc.annotations.** { *; }
> -dontwarn java.lang.ClassValue
> -keep class java.lang.ClassValue { *; }
> -dontwarn org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement
> -keep class org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement { *; }
>
> Thanks @cpovirk <https://github.com/cpovirk> , @breyed
> <https://github.com/breyed>, @gengjiawen <https://github.com/gengjiawen>
>
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2926#issuecomment-325455128>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAEEEd066G4sdYg6jNJBXp_KKzdvtGQIks5scxWwgaJpZM4PDKt0>
> .
>
There's probably a good reason why we've had ImmutableList.toImmutableList since 21, but not this yet. But hey, doesn't hurt to ask :) Thanks!   In Guava 23...
Assume `nodeA` exists but  #`nodeU` does not exist. Execute:
`graph.edgeValueOrDefault(nodeA, nodeU, 5)`
The result is `null`. I would expect the result to be `5`, given that there is no edge between `nodeA` and non-existent `nodeU`. Guava 22 an earlier have the expected behavior.
I see that Guava 23 now returns an `Optional` for `edgeValue`, so the statement can easily be converted to `graph.edgeValue(nodeA, nodeU, 5).orElse(5)`, however if this is the intended behavior of the `edgeValueOrDefault` method for this situation, it deserves some additional explanation in the Javadoc. Or simply deprecate this method and recommend people transition to `edgeValue().orElse()`. Now that Guava is going to have more frequent releases and thus 23.2 is likely to be released before 24, I wonder if it would make sense to shift the milestone to 23.x.
Currently the Android branch is fully Java 7 compliant, effectively departed from the evolution of the mainstream of Guava library. As more and more Guava functions take advantages out of Java 8 language features, especially lambda and interface default / static method, for more convenient APIs, we Android developers are still bound by the old Java 7 coding style, just because of the libraries we are using.
Please consider adopting interface default / static method in the Android branch of Guava in a future version, like some popular Java 8/9 backport libraries (such as [Android Retro-stream](https://github.com/retrostreams/android-retrostreams)). Got that, The word "android" in the branch name is a little misleading, I thought it was made solely for Android development.
Hope some day in the future, we could ditch the 1.7 source compatibility and move on. But at present, Android is still in painful version fragmentation, desugar is our only consolation for that.  I was looking at some source code when I came across one comment that let me think :
https://github.com/google/guava/blob/5087f785bed999500743e2775192ffc17d14bce6/guava/src/com/google/common/primitives/Primitives.java#L42
To my mind, the implementation would be cleaner :
private static final BiMap<Class<?>, Class<?>> primitiveToWrapperType = ImmutableBiMap.<Class<?>, Class<?>>builder()
.put(boolean.class, Boolean.class)
.put(byte.class, Byte.class)
.put(char.class, Character.class)
.put(double.class, Double.class)
.put(float.class, Float.class)
.put(int.class, Integer.class)
.put(long.class, Long.class)
.put(short.class, Short.class)
.put(void.class, Void.class)
.build();
```
instead of :
/** A map from primitive types to their corresponding wrapper types. */
private static final Map<Class<?>, Class<?>> PRIMITIVE_TO_WRAPPER_TYPE;
/** A map from wrapper types to their corresponding primitive types. */
private static final Map<Class<?>, Class<?>> WRAPPER_TO_PRIMITIVE_TYPE;
static {
Map<Class<?>, Class<?>> primToWrap = new HashMap<Class<?>, Class<?>>(16);
Map<Class<?>, Class<?>> wrapToPrim = new HashMap<Class<?>, Class<?>>(16);
add(primToWrap, wrapToPrim, boolean.class, Boolean.class);
add(primToWrap, wrapToPrim, byte.class, Byte.class);
add(primToWrap, wrapToPrim, char.class, Character.class);
add(primToWrap, wrapToPrim, double.class, Double.class);
add(primToWrap, wrapToPrim, float.class, Float.class);
add(primToWrap, wrapToPrim, int.class, Integer.class);
add(primToWrap, wrapToPrim, long.class, Long.class);
add(primToWrap, wrapToPrim, short.class, Short.class);
add(primToWrap, wrapToPrim, void.class, Void.class);
PRIMITIVE_TO_WRAPPER_TYPE = Collections.unmodifiableMap(primToWrap);
WRAPPER_TO_PRIMITIVE_TYPE = Collections.unmodifiableMap(wrapToPrim);
}
private static void add(
Map<Class<?>, Class<?>> forward,
Map<Class<?>, Class<?>> backward,
Class<?> key,
Class<?> value) {
forward.put(key, value);
backward.put(value, key);
}
```
Thank you to help me understand !    You forgot to rebase and squash the branch to have only a single commit. sorry, I'm going to create a new pr on this.  Hi,
Do you have any idea why Lombok annotation processor stopped working after upgrading Guava from 16.0.1 to 23.0? I have a lot of dependencies in my project, so it might be something else, because I tried creating a sample project with only guava and lombok, and it worked just fine, but it's still Guava upgrade causing problems.
Regards,
That's not really a lot of information to go by. We may be able to help you if you can provide us with a [MVCE](https://stackoverflow.com/help/mcve). You may actually find that in producing the MVCE, you locate what's causing Lombok to stop working for you. :)
Hope this helps. Alternatively, since you've apparently said that you created a MVCE of your own in private (which I missed first time, sorry!), you could try building up your MVCE to gradually look more like the project you're dealing with that has the Lombok problem. I hope that it would allow you to locate the source of the problem.
Hope this helps again. I just tried doing it, but ended up with something that compiled/worked fine :) In case I give it one more try, I will let you know, if I found anything.  Clarify javadoc about the delegate being called utmost once. This is not true if the get method on the delegate throws RuntimeException. @googlebot signed the CLA now! Can someone tell me why there is a tag of cla:no ? I have signed the CLA 8 days ago? @kannanekanath, it seems that @googlebot wasn't intelligent enough to realise beforehand that you requested it to check the CLA status for you.
Maven's dependency resolution looks at group and project IDs, and then attempts to find the most recent version. Because the only difference between the android and JRE versions of guava is the version number, this can result in Java 8 projects getting the Android version of Guava (and, presumably, vice versa).
For reference, at the time of writing [search.maven.org](http://search.maven.org/#search%7Cga%7C1%7Cguava) believes the most recent guava release is the one for Android.
The correct thing to do is give the Android version a different project ID. Seems like a classifier would be far more appropriate. That would also work, so long as the JRE version retained the default classifier (which I think is `jar`). See #2839, as well. #2839 could also be resolved by adding a classifier. Expecting just the version string to work won't work. Can we please get a 23.1 release that just adds the classifiers and stops projects breaking? Then pick a different project ID :) The problem right now is that more and more projects are potentially being broken. Using the right terminology now :)
So the maven namespace is segmented by group id (which can be `com.google.guava`), artifact id (which is currently `guava` in both cases) and version (`23` or `23-android` right now). The correct solution, as pointed out, is to use a classifier, but apparently this is hopelessly broken.
The next best solution is to change the artifact id. This will lead to a situation where people might end up depending on both `guava` and `guava-android`. A group id can have many different artifact ids without them clashing --- if they couldn't then maven as we know it couldn't work. @cpovirk @shs96c I'm not sure I understand what the problem is with a project potentially depending on both `guava` and `guava-android`. Can you elaborate further for me? @jbduncan, it depends on what you're targeting, and what gets put into your classpath:
Because the packages are the same, whichever is first on the classpath will be selected. In some cases, this will work as expected. In some cases it won't. Because maven's dependency resolution is "novel" at best, which you get is a bit of a crapshoot. Unless you use version pinning, the version dependency appears to be advisory at best. @cpovirk yes there's a problem. Doing that will break android projects.
I'm just getting reports from users who are using maven's default versioning strategy (not necessarily using gradle). I guess they're using [aether](https://wiki.eclipse.org/Aether/What_Is_Aether).
You know, GH could really do with threading of comments. In case it isn't clear, this particular issue Selenium was having was due to leaving the version as open ended:
<dependency>
<groupId>com.google.guava</groupId>
<version>[23.0,)</version>
</dependency>
This allows selenium to specify the minimum required version of guava but anticipating that we will still be compatible with future versions of guava that another project may specify. The problem we encounter is that if another project depends upon us and doesn't specify their version of guava, maven may choose the 'latest' it finds in central... which by timestamp happens to be 23.0-android.
Having users not accidentally include both android and jdk 8 versions is certainly a problem... but solving it in this way feels like bad maven practice. It seems like it's a bug for maven to try to figure out a way for everyone to identify two packages that are incompatible with each other.
`jre` just means `Java Runtime Environment`. IBM ships one too, and the OpenJDK has a "jre" package . I _think_ it's an accepted industry term.
@lukeis Do you know if the Selenium team ever considered one of the following workarounds?
2. "Shade" Guava into Selenium with a tool like the Maven Shade plugin? @jbduncan we are currently working around the issue by setting the version explicitly to 23.0.
1. Internally we use a static version of guava, but our maven dependency used to pin to `(23,]` (version 23 or later). Prior to that, we didn't specify a range `23.0`, but this caused problems when we replaced usages of guava's `Function` with java 8's.
2. Shading will bloat the jar, and won't resolve this issue for other users. @cpovirk, yeah, making sure that the jre version is released after the android version will mask this issue for many users. Note that if different coordinates are used, in addition to the classpath ordering issue you could run into same-package conflicts in Java 9 if I understand Jigsaw correctly. If Android later supported modules then a module conflict would occur. If you went down this path then using a different package name would be advisable. The current solution avoids that, though has its own problems.
Per @cpovirk's link to the Maven's Version Plugin for update checks, a similar [plugin](https://github.com/ben-manes/gradle-versions-plugin) for Gradle exists using its dependency resolver. I personally prefer the Maven best practice of not using dynamic versions, optionally locking them down, and excluding when appropriate. In Gradle one can use a `resolutionStrategy` to reject a dependency, e.g. if the version has `-android` in it. I never had to do that in Maven though perhaps it has a similar capability.
Probably the ideal solution is to separate the two variants into their own package and coordinates to avoid any conflicts and work side-by-side. That's not an upgrade friendly approach, which I guess is why it wasn't done. Pushing the handling into the build system seems like the next best option. Re: https://github.com/google/guava/issues/2914#issuecomment-323814922 In Guava 20, `com.google.common.base.Function` did not extend `java.util.function.Function`. In Guava 21, it did. As a library that people depend on, we switched our API to accept the Java 8 `Function` rather than Guava's.
We upped our guava dependency to version 21. Projects using selenium and guava as a dependencies, however, did not pick up this change --- because of the way that maven dependency resolution works, the project would also need to bump their guava version to 21 or more.
One solution is to shade the Android library into a different package. Libraries that expect to run on Android can make the move to the new package. Those that expect to run on the JRE need do nothing (or make a breaking change, and make _everyone_ make a choice).
On an Android device, it'll be clear that a dependency on the JRE version is a terrible mistake. However, because of the way that the JRE works, if a JRE-based library of application depends on the Android version, all that will happen is that the classpath will be longer, and deployable artefacts will be larger. Disk space is cheap. Also, why not just distribute the Android version of guava as an AAR, and not as a JAR? Given the fact that maven version/artifact resolution is not going to be
incompatible, can we use some approach like maven-enforcer or whatever to
supply constraints, such that a project won't have both in its deps graph?
The key as I see it is that these are incompatible and there is no way, in
the raw dependency mechanism, to specify that incompatibility.
On Thu, 31 Aug 2017 at 07:53 Simon Stewart <notifications@github.com> wrote:
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2914#issuecomment-326320674>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAUN4i_jPM3icsPvbg7Fs5UTQ0qyg3dOks5sdsjMgaJpZM4O4ET0>
> .
>
> We also promise that it's usable as on the JRE (for Java 7 users). (I don't know enough about AAR to say more than that.)
AAR is an Android-specific way of packaging a library. If you've got something that is only meant for an Android app, that's the best way to distribute it.
https://gist.github.com/lopspower/6f62fe1492726d848d6d might be useful. The only advantage would be to bundle the ProGuard rules so they're used
automatically which seems very low value compared to now shipping 3
artifacts (jdk8, jdk6/7-ish, and android).
On Fri, Sep 1, 2017 at 1:43 PM Simon Stewart <notifications@github.com>
wrote:
> We also promise that it's usable as on the JRE (for Java 7 users). (I
>
> AAR is an Android-specific way of packaging a library. If you've got
> something that is only meant for an Android app, that's the best way to
> distribute it.
>
> https://gist.github.com/lopspower/6f62fe1492726d848d6d might be useful.
>
> 
> You are receiving this because you commented.
>
>
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2914#issuecomment-326642112>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAEEEWTU-6QCj_ebF-RlcVAaj7MoP0Dhks5seEImgaJpZM4O4ET0>
> .
>
You'd be shipping two: just guava as a jar (targeting java 8, as now), and guava as an aar, which android projects could depend on. That would then contradict this statement by @cpovirk:
> Update: Admittedly "Android" is itself not the best term, since we advise Java 7 users to use it, too. An aar would require the artifact only notation in Gradle. I think that if the explicit extension and transitively unqualified dependency of guava were in the tree, then both would be retrieved. If so, this would require Android users to manually exclude which would require a fix to the user's build. That doesn't seem clearer than using a resolution strategy / enforcer to restrict versions. @cpovirk If we changed `-android` version suffix to `-a`, [maven version comparison rules](https://stackoverflow.com/a/31482463) would treat it as lesser than vanilla release version, i.e. `24.0` (for java 8+) would be considered newer than `24.0-a` (for android / java 7) by maven.
This way we can keep normal guava version normal (and "latest") while providing android / java 7 specific version, too. @yborovikov Isn't `a` intended for `alpha` releases? It could be misleading. @perceptron8 `-a` is indeed _sorted_ the same way as `-alpha` (and `-b` - as `-beta`). however, the meaning of `-a` doesn't have to translate to "alpha", and, unless we publish alpha releases to maven central, should not create much confusion (at least no more than `-android`).
for example, java `build 1.7.0_80-b15` doesn't mislead us into thinking it's a beta release, does it? :)
i believe a single sentence in the `README.md` would be enough to explain the meaning and purpose of releasing both `guava:24.0a` and `guava:24.0`. Downside of using `-a`: it might be sorted before `rc`, etc. and considered a "pre-release" version by various tools (e.g. [mvnrepository](https://mvnrepository.com/artifact/com.google.guava/guava)).
So we could use `-ga` ("google android") suffix instead - this is considered to be equal to no suffix, so `24.0` and `24.0-ga` would be treated as equally fresh by maven.
Checked these (version `xx-ga` and `xx`) against maven-enforcer-plugin's [requireUpperBoundDeps](https://maven.apache.org/enforcer/enforcer-rules/requireUpperBoundDeps.html) rule - neither is considered newer than the other, both can be used interchangeably. `GA` is sometimes used as `General Availability` in version strings. It looks like some JBoss artifacts used this and then switched to `Final`, so perhaps there was an issue they encountered. I wouldn't redefine known suffixes even if they are non-standard. @ben-manes We're trying to achieve something Maven doesn't have a prescribed solution for here.
You're right, `ga` is one of well-known qualifiers (and stands for `general availability`, as you mentioned), and that's the reason this version qualifier gets special treatment (re version comparison) from Maven.
We would be piggy-backing on this [documented](http://maven.apache.org/ref/3.5.0/maven-artifact/apidocs/org/apache/maven/artifact/versioning/ComparableVersion.html) Maven feature:
> strings are checked for well-known qualifiers and the qualifier ordering is used for version ordering. Well-known qualifiers (case insensitive) are:
>
> -    alpha or a
> -    beta or b
> -    milestone or m
> -    rc or cr
> -    snapshot
> -    **(the empty string) or ga or final**
> -    sp
This approach should resolve this very issue of Maven version comparison treating `23.0-android` version as the latest over `23.0` one - as stated by the issue submitter.
<sub>As for why JBoss switched from `ga` version suffix to `Final` - personally I have no idea, as well as why do projects use `-ga` or `.Final` suffixes for their vanilla release artifact versions, to begin with. My guess would be some historical reasons (e.g. JBoss docs circa 2004 said: ["We did not want to depend on a specific build tools naming and ordering rules, because those things tend to change over time. While Maven is the popular choice today ..."](https://developer.jboss.org/wiki/JBossProjectVersioning)).</sub> Copied from [the discussion doc](https://docs.google.com/document/d/1NYGbfz56C0Oh4IGymXjeQUVK4FcRiqDbpc4vGLnDMrY/edit#) shared by @cpovirk:
While it's considered bad practice to just tell Maven "use latest version" (or rely on version ranges), there's another practice of assuring (via `maven-enforcer-plugin`) that a library (transitively shared by multiple dependencies) resolves a version no older than what's required by any of the dependencies.
In [our case](https://github.com/uber/tchannel-java) we try to maintain Java 7 compatibility by using android-flavored guava version, and upgrade to 23.0-android broke the (java 8) builds that depend on the project yet try to enforce the latest versions among shared dependencies - `23.0-android` is considered by Maven to be a newer one and `guava-23.0` fails the check.
Arguably, java 7 / android builds will experience similar issues (e.g., trying to use `24.0-android` while some dependencies use `24.0-jre`).
Ideally, Guava would produce two versions that are considered equally fresh by Maven tooling - and there is such option: use `24.0` for vanilla version and `24.0-ga` for android one.
This would allow a project to pick the flavor it needs while enforcing that the latest (among dependencies) version is being effectively used.
(Of course, android builds would still rely on / check that Java 8 features are not being actually used in the execution path of the libraries - but that's unavoidable anyways.)  There already is the method Multimaps.flatteningToMultimap for a stream of values.
But one could also want to map an object against multiple keys coming from a stream.
So a collector method flatteningToMultimap(Function<? super T, ? extends Stream<? extends K>>, Function<? super T, ? extends V>, Supplier) would be useful.
See Issue #2911 @googlebot I signed it!  The default conflict resolution by throwing is fine most of the time, but sometimes, conflicting keys are acceptable as you either don't care about the values as in #360 (choosing the bigger city might be an option).
Sometimes, you can't do anything about the conflicts, like when I was importing inconsistent third party data recently. Letting the later inserted values win might help in cases like in #2252.
Therefore, I'm suggesting `ImmutableMap.Builder#build(BinaryOperator<Entry<K, V>> merger)`. It should be rather easy to implement. In case of no conflict, the merger doesn't get used and building is as efficient as without it. Otherwise, some simple tweaks are needed like possible cloning and final shrinking of `entries` in `fromEntryArray`, something like ten to twenty code lines. To keep things simple, the iteration order would be always according to the first occurrence of the key, regardless of what the `merger` returns. I missed it. I could have used it, though it'd need some rewrite while the builder feels natural (as two methods are adding entries). This collector is cheating with a `LinkedHashMap` temporary, unlike the two argument variant using the builder.
I guess, the three argument variant could be trivially implemented using my proposed build method. If there are few merges, it'd be probably way more efficient. With many merges, the builder could grow much bigger than the map.
All the alternatives make the builder look an unwanted child.  I have created several of my own builders for immutable classes.
If I use the ImmutableMap.Builder, the builder will collect duplicate keys and fail on the "build()".  (Similar problem to that was described in [https://github.com/google/guava/issues/360](url)).
The proposal in issue 360 was to to immediately throw an IllegalArgumentException from the Builder if a duplicate key was added.  This proposal was rejected because of the potential performance impact, which makes sense.
However, would it be possible to add a "containsKey(K)" method to roll through the existing entries looking for any with a matching key? This would be admittedly be an expensive operation, but the caller must decide if he wants to take the performance hit.  The current functionality / performance of the Builder#put... would not be impacted.
```
if (foobars.containsKey(foobarName)) {
} else {
}
}
public void FooBarsHolder build() {
return new FooBarsHolder(foobars.build());
}
```
As a workaround I am currently using a LinkedHashMap and then a ImmutableMap.copyOf(map); however, it would be nice to deal with the maps in the same manner as the lists, etc. I ran into this just yesterday and also switched to a mutable `Map`. IMHO the problem with your proposal is that nobody should ever use `ImmutableMap.Builder#containsKey` because of its quadratic complexity and because you can do
```
if (mutableMapUsedAsBuilder.put(foobarName, foobar) != null) {
}
```
instead. It's even simpler and there's no additional lookup.
It's not exactly equivalent in case of duplicate keys, but you could use your variant as is or mine and put back the original value, *if you insist on "first wins"*. AFAIK the only advantage of using the `Builder ` in this case is that it produces less garbage, which IMHO isn't worth the overhead of `containsKey`. Hello Maaartinus,
Thanks for your quick answer.
~~The problem I see with your proposal is that in the event that I have a duplicate key, I have now pushed it to the builder and can not remove it - a guaranteed fail if I still get around to "build()" at some point.   This would make it impossible to recover from this condition without starting all over with a new builder.~~
^^ ignore that ... see now that your were indicating I should use my mutable map and not the immutable map  The link was generated as plaintext. The change will result in the link
being rendered as a hyperlink. @cpovirk Thanks for looking into this, and the detailed responses.   I will close this PR.  I have extended a toMap function in the FluentIterable, you can flexibly specify the key and value, you can also specify the key conflict strategy  Simple change - added a few new constructors and passed the tmpDir in.
This will allow multiple threads to use this class and write to different places while preserving the existing functionality. I have read/signed the CLA. I am not sure why it wont let me put this pull request up @JoeHale It may not be accepting your PR because the email address you use to log into GitHub is different from the email address you assigned to your local Git installation's `user.email` setting.
Try double-checking the email address you set for `user.email` (following these instructions to set it or reset it if needed: https://git-scm.com/book/en/v2/Getting-Started-First-Time-Git-Setup), and then try running `git commit --amend` to hopefully correct your commit with the right email address and then `git push --force-with-lease` to push the corrected commit.  "Snapshot API Diffs from 22.0" should now be "Snapshot API Diffs from 23.0" or just "Snapshot API Diffs".
This PR applies a good number of apparently applicable IntelliJ IDEA code inspections. Hi @cpovirk, sorry for being quiet on this.
I think a few things were missed, but I'm not sure which, so I'm rather satisfied with the commit you've pushed. Thanks!  Such references can cause JVM-level deadlocks in multithreaded environment, when one thread tries to load superclass and another thread tries to load subclass at the same time.
My refactor will not change the method provided to outer space. Assuming there is a cycle, wouldn't the initialization-on-demand holder idiom work? That would be preferable to ThreadLocal.  LocalCache.asMap().compute(...) deadlocks if its lambda throws an exception. Demonstrated by the test.
Fixed by properly handling the exception and realising the lock. I signed it!  Dear Guava developers,
I've been using ImmutableList for a while. I notice that in more than 50% of the cases I know its size before I build it. Would it be possible to expose ImmutableList.builder(int capacity)?
In fact, I can see this comment in the code:
Builder(int capacity) {
super(capacity);
}
Best wishes,
See also issue #2657 . ok!  A really interesting edge case for HashMap was reported due to my usage, see https://github.com/ben-manes/caffeine/issues/176.
It seems that when the entrySet iterator removes entries, the untreeifying causes the entries to be rewritten. Then the entries returned by the iterator are stale and `setValue` has no effect on the HashMap. This is because unlike concurrent maps, the `setValue` does not perform a `map.put(key, value)` to handle the race.
I believe this is a JDK bug and we are awaiting feedback. Guava's testlib doesn't assert this case, so it might be a good addition. https://bugs.openjdk.java.net/browse/JDK-8186171  Hi guys. Probably I'm not aware about something. But why don't you want to make that preconditions set is available for public audience ? I found it very helpful to use it in my projects.
Thanks in advance, Dima.        Almost every usage of `CacheLoader` only needs to implement `load()`, so being able to do that with a lambda would be helpful. Something like this:
public static <K, V> CacheLoader<K, V> cacheLoader(LoaderFunction<K, V> loader)
{
return new CacheLoader<K, V>()
{
public V load(K key)
{
return loader.load(key);
}
};
}
public interface LoaderFunction<K, V>
{
V load(K key)
} `Function` cannot throw. I still don't understand why the Supplier version typed the key as Object... @lowasser, thanks for the tip! I never noticed that method. It would be nice to have a version for functions that throw checked exceptions. @kevinb9n The reason is that users prefer their collections to be typed, if only for consistency in their code. The current form forces the cache to be `Cache<Object, V>`, whereas developers are used to be restricting to `Cache<K, V>`. That makes it incompatible with other builder steps, like `RemovalListener`, if the key has meaning outside of the loader. Its not a big deal, but in the few cases where it seemed appropriate the end result didn't use it.
CacheBuilder.newBuilder()
.build(CacheLoader.from(Unchecked.function(key -> {
return value;
})::apply);
```
can work around exceptions. It looks worse in isolation, but the extra noise drops out with real build logic. (You can add `Unchecked.RETHROW_ALL` to propagate as the original checked exception if needed) In general, I agree with tunneling exceptions, but forcing users to do that here seems broken since CacheLoader and LoadingCache already support checked exceptions.
aha, so now I understand, thanks! :)
Somehow that escaped me and I always thought it was forcing the key type, which seemed weird given the people involved.  `Cache` interface was designed to throw an exception in the case of null or empty values. While this seems a reasonable behavior for `Cache.get`, I didn't figured out how to deal when calling `Cache.getAll`.
I/O is expensive, so I collect all data I need at once using `Cache.getAll`. In the case that at least one key has no value, it throws an exception, which does not allow me to access the other valid values.
I found to options: first, using `Cache.get` instead of `Cache.getAll`; second, including null values as Optional. Both options are terrible considering performance. Is there a recommended solution to deal with this scenario? Otherwise, if possible, how could I help to improve the Cache API in this issue? @lowasser thanks for your quick reply. Using `Optional` forces me to include in the cache data that should not be there. Even knowing that I can flag the key to be quickly removed, it doesn't seem an adequate solution specially if I have a high occurrence of null values. In an extreme example, if the frequency of null values is so high that it exceeds the maximum cache size, the cache becomes an useless overhead. If the frequency of not being found but requested is high then there will be a lot of unnecessary I/O and hash table locking. In that case negative caching of the misses is useful to reduce that, which is where `Optional` can be used as a sentinel value. If that leads to cache bloat then the best option is use a Bloom Filter to filter out most absent requests. This is a fairly standard idiom inside databases and a recent example is [LinkedIn's feed rewrite](https://engineering.linkedin.com/blog/2017/07/building-the-activity-graph--part-2), which uses enhancements to Guava that they contributed. So your worst-case is bad for many reasons and requires a richer solution for a workload with a high miss rate.
The cache interface was designed in a Java 4/5 world, where Guava was a leading force in reducing null as a common return or parameter value. In this case Josh Bloch felt strongly in favor for using a checked exception, where checked is for recoverable conditions. This and implementation details fit the trade offs of the time and would be hard to argue against even in retrospect if transported back then.
In the [cache rewrite](https://github.com/ben-manes/caffeine) nulls are favored over exceptions. This is to match Java 8's `compute` methods and that `getUnchecked` or not handling the checked exception is the most common case. The update to a Java 8 API gave the opportunity to change this, but its more about keeping consistent with the community's coding style. I don't think that Guava's approach is incorrect, though, because when performance matters you'll have to add a filtering technique regardless to reduce bottlenecks. @ben-manes thanks for your explanation and references. Bloom filter sounds nicely, but would bring the overhead of managing a new structure ensuring consistency with the original data source. Given the options, I'll go for `Optional` and measure in a real scenario how it affects the performance. Thanks again @ben-manes and @lowasser for your help. @jrtom I don't think so. I guess the OP wants `getAllPresentLoadAbsentWhenPossible`, which would be an aggregate of exception ignoring `get`s. When working with single elements, you may throw and handle it in `get`, so that you don't pollute the cache (though polluting it may be a good thing as Ben wrote). I guess, something like
`try {return getAll();} catch (....) {return getAllPresent();}`
could come close to what he requested. Despite the double lookup, it could be more efficient than the alternatives, assuming that what @ben-manes wrote doesn't apply in this case.
It can use like this:
Map<Integer, Integer> maps = fromProperties(prop, (k)->Integer.valueOf(k), (v)->Integer.valueOf(v));
```
It's very useful when we use it to convert properties to a generics map.
And in other way, we can implement with BiFunction<T, U, R> to expand this method. I signed it!  The method try to initialize unsafeComparator and expect ExceptionInInitializerError or ClassNotFoundException if initialization fails. Actualy the static initializer throws Error if something goes wrong to "force fallback to PureJavaComparator". According to spec JVM transfers it to ExceptionInInitializerError for the first time and starting from second genertates NoClassDefFoundError (not ClassNotFoundException, no exceptions allowed to be thrown from static initializer).
```
try {
Class.forName(unsafeComparatorClassName());
return true;
} catch (ExceptionInInitializerError | ClassNotFoundException tolerable) {
// probably running on Android
return false;
}
```
Guess this is a missprint and author was intended to use NoClassDefFoundError here. For example, the ForNameTest.java:
```
public class ForNameTest {
public static void main(String[] argv) {
System.out.println("sun.arch.data.model: " + System.getProperty("sun.arch.data.model"));
try {
Class.forName("unsafeComparator");
} catch (Throwable t) {
System.out.println("1st - " + t);
}
try {
Class.forName("unsafeComparator");
} catch (Throwable t) {
System.out.println("2nd - " + t);
}
}
}
class unsafeComparator {
static {
if (!("32".equals(System.getProperty("sun.arch.data.model"))))
}
}
```
produce the following output:
```
java -showversion ForNameTest
java version "1.8.0_131"
Java(TM) SE Runtime Environment (build 1.8.0_131-b11)
Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)
sun.arch.data.model: 64
1st - java.lang.Error
2nd - java.lang.NoClassDefFoundError: Could not initialize class unsafeComparator
```  The mechanism which detects whether to fallback on the non-lazy stack trace implementation seems to be broken on AIX 5.3 with IBMs JDK `jdk-6.0.0.645-aix-powerpc`. When iterating through the list returned by the method on such a system I get the following exception + trace
> Caused by: java.lang.UnsupportedOperationException: You cannot access stack trace depth this way in this implementation
at sun.misc.SharedSecrets$1.getStackTraceDepth(SharedSecrets.java:172)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:60)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:37)
at java.lang.reflect.Method.invoke(Method.java:611)
at com.google.common.base.Throwables.invokeAccessibleNonThrowingMethod(Throwables.java:292)
at com.google.common.base.Throwables.access$200(Throwables.java:48)
at com.google.common.base.Throwables$1.size(Throwables.java:284)
at java.util.AbstractList$SimpleListIterator.hasNext(AbstractList.java:51)
at com.google.common.collect.Iterators$PeekingImpl.hasNext(Iterators.java:1171)
at java.lang.J9VMInternals.initializeImpl(Native Method)
at java.lang.J9VMInternals.initialize(J9VMInternals.java:199)
... 21 more
Explicitly using `new Throwable().getStackTrace` resolved the problem. @cpovirk
I'm interested in this one, so if no one minds, I want to make an implementation for a fallback, however, should we care only for `UnsupportedOperationException` or it is worth to catch something generic e.g. `RuntimeException`?  (hence I'm not a fan of such an idea) @cpovirk
Agree, will do it then and create a PR soon. Thanks!   In the Guava 23.0 [release notes](https://github.com/google/guava/wiki/Release23), there was a mention of a class `GraphTraverser` which AFAICT isn't in the open source version of Guava. Is it a real class in Google-internal Guava? If so, are there any plans to eventually release it? Okey dokey, thanks for the quick response @kevinb9n!
I'll keep this issue open for now. If or when the Guava 23.0 release notes are fixed, I'll close it. :) Ta @cgdecker! :+1:   Change CacheBuilder constructor modifier to private and rewrite corresponding tests  Change CacheBuilder constructor modifier to private and rewrite corresponding tests.  First I thought this exception is connected to [Guice ](https://github.com/google/guice/issues/1119)but it is rather coming from Guava, isn't it?
What is the proper approach to track down the problem in a compex Spark app having this exception?
On another system there is no such error and it is very hard to understand the exact source of the error.
```
Exception in thread "main" com.google.inject.internal.util.$ComputationException: java.lang.ArrayIndexOutOfBoundsException
at com.google.inject.internal.util.$MapMaker$StrategyImpl.compute(MapMaker.java:553)
at com.google.inject.internal.util.$MapMaker$StrategyImpl.compute(MapMaker.java:419)
at com.google.inject.internal.util.$CustomConcurrentHashMap$ComputingImpl.get(CustomConcurrentHashMap.java:2041)
at com.google.inject.internal.util.$StackTraceElements.forMember(StackTraceElements.java:53)
at com.google.inject.internal.Errors.formatSource(Errors.java:690)
at com.google.inject.internal.Errors.formatInjectionPoint(Errors.java:720)
at com.google.inject.internal.Errors.formatSource(Errors.java:684)
at com.google.inject.internal.Errors.format(Errors.java:555)
at com.google.inject.ProvisionException.getMessage(ProvisionException.java:59)
at my.custom.spark.app.main.Main.main(Main.java:68)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:498)
at org.apache.spark.deploy.SparkSubmit$.org$apache$spark$deploy$SparkSubmit$$runMain(SparkSubmit.scala:731)
at org.apache.spark.deploy.SparkSubmit$.doRunMain$1(SparkSubmit.scala:181)
at org.apache.spark.deploy.SparkSubmit$.submit(SparkSubmit.scala:206)
at org.apache.spark.deploy.SparkSubmit$.main(SparkSubmit.scala:121)
at org.apache.spark.deploy.SparkSubmit.main(SparkSubmit.scala)
Caused by: java.lang.ArrayIndexOutOfBoundsException: 43168
at com.google.inject.internal.asm.$ClassReader.<init>(Unknown Source)
at com.google.inject.internal.asm.$ClassReader.<init>(Unknown Source)
at com.google.inject.internal.asm.$ClassReader.<init>(Unknown Source)
at com.google.inject.internal.util.$LineNumbers.<init>(LineNumbers.java:62)
at com.google.inject.internal.util.$StackTraceElements$1.apply(StackTraceElements.java:36)
at com.google.inject.internal.util.$StackTraceElements$1.apply(StackTraceElements.java:33)
**at com.google.inject.internal.util.$MapMaker$StrategyImpl.compute(MapMaker.java:549)**
... 18 more
```  setException() after setFuture is not a noop, but I don't disagree with the general premise. I suppose it's theoretically possible for something to escape when setting the listeners on the Future... but again, Future catches RuntimeExceptions thrown from execute(), and from misbehaving objects passed in to setFuture().   Hmm, I wonder if Android even supports the diamond operator... Diamond is a compilation feature only. Has nothing to do with runtime.
On Wed, Jul 19, 2017, 8:12 PM Jonathan Bluett-Duncan <
notifications@github.com> wrote:
> Hmm, I wonder if Android even supports the diamond operator...
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/pull/2875#issuecomment-316558655>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAEEEc4aphRfggnNsSCGurhyQXlqepulks5sPptxgaJpZM4Odcbr>
> .
>
well, travis had a android test as well... Yep, looks like it passes Travis (which indeed runs the Android tests), so I've no objections to this!  Java 8 defined specific primitive spliterators for doubles, ints,  and longs.
The primitive lists of those specific types in com.google.common.primitives should implement spliterator and return those primitive optimized spliterators. The intent of my request is to allow for the framework to provide better optimized Streams. By default, the spliterator provided is based on the iterator implementation. This not only is not going to optimize access for an array, it is not likely to support splitting to allow parallel streams. Additionally, it guarantees auto-boxing is going to take place, as that is how AbstractList implements an Iterator. No, I am talking about the List returned from [Longs.asList(long...)](http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/primitives/Longs.html#asList-long...-) and friends.
I apologize for not stating that more clearly in the original request. Auto boxing will still (likely) occur through streams. The stream implementation itself will be more efficient based on the backing long[] compared to the List's default Iterator.  Building an object identity is still quite verbose to write IMHO, even though we now have nice and convenient utilities:
public class Item {
private final int id;
private final String name;
public Item(int id, String name) {
this.id = id;
this.name = name;
}
public int getId() {
return this.id;
}
public String getName() {
return this.name;
}
public boolean equals(Object otherObject) {
if (!(otherObject instanceof Item)) {
return false;
} else {
Item otherItem = (Item) otherObject;
return Objects.equals(this.id, otherItem.id);
}
}
public int hashCode() {
return Objects.hash(this.id);
}
}
```
And it's getting even worst when building a comparable identity (making `compareTo` consistent with `equals`):
public class Item implements Comparable<Item> {
private final int id;
private final String name;
public Item(int id, String name) {
this.id = id;
this.name = name;
}
public int getId() {
return this.id;
}
public String getName() {
return this.name;
}
public boolean equals(Object otherObject) {
if (!(otherObject instanceof Item)) {
return false;
} else {
Item otherItem = (Item) otherObject;
return Objects.equals(this.id, otherItem.id);
}
}
public int hashCode() {
return Objects.hash(this.id);
}
public int compareTo(Item otherItem) {
return ComparisonChain.start()
.compare(this.name, otherItem.name)
.compare(this.id, that.id)
.result();
}
}
```
My main point is that, identity is built using only one field in this example, but say I want to add another field to make my `Item`s unique, I'll have to update the three methods `equals`, `hashCode` and `compareTo`...
---
I was thinking of such a Java8-lambda-based `Identities` utility:
public class Item {
private static final SimpleIdentityFactory<Item> ITEM_IDENTITY_FACTORY = Identities.simpleIdentityFor(Item.class)
.with(Item::getId)
.build();
private final SimpleIdentity<Item> identity;
private final int id;
private final String name;
public Item(int id, String name) {
this.identity = ITEM_IDENTITY_FACTORY.build(this);
this.id = id;
this.name = name;
}
public int getId() {
return this.id;
}
public String getName() {
return this.name;
}
public boolean equals(Object otherObject) {
return identity.equals(otherObject);
}
public int hashCode() {
return identity.hashCode();
}
}
```
This could also probably cover the comparable identities:
public class Item implements Comparable<Item> {
private static final ComparableIdentityFactory<Item> ITEM_IDENTITY_FACTORY = Identities.comparableIdentityFor(Item.class)
.asc(Item::getName)
.asc(Item::getId)
.build();
private final ComparableIdentity<Item> identity;
private final int id;
private final String name;
public Item(int id, String name) {
this.identity = ITEM_IDENTITY_FACTORY.build(this);
this.id = id;
this.name = name;
}
public int getId() {
return this.id;
}
public String getName() {
return this.name;
}
public boolean equals(Object otherObject) {
return identity.equals(otherObject);
}
public int hashCode() {
return identity.hashCode();
}
public int compareTo(Item otherItem) {
return identity.compareTo(otherItem);
}
}
```
---
Could have been even nicer to player with interfaces default implementations and let an `Identifiable<T>` interface implement the methods for us thanks to a (non-defaulted) `getIdentity()` method, but unfortunately, [it's forbidden](https://stackoverflow.com/a/24026292/1225328) ;) @cpovirk Indeed, AutoValue looks pretty convenient, thanks for the feedback!  The link to [RangeMap](https://github.com/google/guava/wiki/NewCollectionTypesExplained#rangemap) documentation is missing in the right panel of the wiki under pages as shown below:-
<img width="243" alt="screen shot 2017-07-13 at 2 39 02 pm" src="https://user-images.githubusercontent.com/8141860/28159078-6b30d7f8-67d9-11e7-9b61-60d3d1e70e6e.png">
Maybe an idea worth discussing (or at least one to quickly be dismissed): How about adding (some of) the methods from `Futures` as default methods to `ListenableFuture` for nice chaining:
public interface ListenableFuture<V> extends Future<V> {
void addListener(Runnable listener, Executor executor);
default <O> ListenableFuture<O> transform(Function<? super V, ? extends O> function) {
}
default ListenableFuture<V> withFallback(final FutureFallback<? extends V> fallback) {
return Futures.withFallback(this, function);
}
// TODO: add more
}
```
old:
ListenableFuture<Foo> f1 = executor.submit(task);
ListenableFuture<Bar> f2 = Futures.transform(f1, (foo) -> toBar(foo));
ListenableFuture<Bar> f3 = Futures.withFallback(f2, (ex) -> handleEx(ex));
```
new
ListenableFuture<Bar> f = executor.submit(task)
.transform((foo) -> toBar(foo))
.withFallback((ex) -> handleEx(ex));
```
@sfussenegger I think that the recent addition of [`FluentFuture`](https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/FluentFuture.html) (planned for 23.0 IIRC) more or less resolves this (albeit without extending `ListenableFuture` with default methods, as you requested).
What do you think? @jbduncan Nice. Same idea but a different implementation.  It would be nice to have Uninterruptibles support for Condition.await() and overlaods.
So we could write
```
lock.lock();
try{
awaitUninterrutibly(condition,1,MINUTE);
}finally{
lock.unlock();
}
```
Please enhance `Graphs` with a method finding n-cliques, max clique (or cliques) in  a `Graph`.
I am aware this cannot be implemented efficiently (finding max clique is a NP-complete problem), but that doesn't unfortunately mean it's useless :)  Without reading the Javadocs, there is no way to know that the `get` method -- in addition to `ExecutionException` -- could also throw `UncheckedExecutionException` (and `ExecutionError`).
In my case, this just bit me as I was using Guava to cache Hibernate DB code, an unchecked `javax.persistence.NoResultException` was throw, and my `catch` clause which unwraps the original, underlying exception failed to work:
try {
return theCache.get(theKey);
} catch (ExecutionException e) {
throw e.getCause();
}
```
Could the wiki please be updated to note these unchecked exceptions?   Exception cause can be set by initCause method which can lead to a circular reference:
cause.initCause(exception);
```
Calling `Throwables.getCausalChain( exception )` or `Throwables.getRootCause( exception )` could lead to an infinitive loop.
It is good idea to use a `Set` to add cause exceptions to avoid iterating over a circular reference when `Set.add` method returns `false`.  > Another option (instead of using a set) would be to use the old "fast pointer/slow pointer" trick.
AFAIK this is only useful when you don't have enough memory for the whole loop.
---
kevinb9n has already commented on this: https://stackoverflow.com/a/7586027/581205
I guess, people requesting this got confused by `Throwable` initializing cause to itself, which leaks when using reflection (e.g., converting to JSON). Besides this dirty trick, I doubt that there are loops out there. As you mentioned `printStackTrace` method is smart enough to avoid this loop by using a `Set` collection.
I describe importance of this issue through an example: if Guava is used in exceptions processing frameworks/projects which their consumers are unknown and also exceptions could be thrown from many different reliable and unreliable sources it might put exception processing framework into an unknown state which is not acceptable unless to avoid using Guava for this particular case and using a custom solution similar to what JDK does for `printStackTrace`.  Libraries like log4j2 use Implementation-Version to determine which version of a library is use when logging stack traces.
Yep, that's exactly what it's about. It would log `[guava.jar:21.0.0]` instead of `[guava.jar:?]`, so it somewhat improves diagnostics.
Specification-Version and Implementation-Version are going to be the same here, I assume, although I think that over here, we chop the last number off the version number for the Specification-Version to indicate compatibility semantics.
Throwing exception in compute function of Cache ConcurrentMap and computing the same key after makes deadlock in LocalCache.java:2387
@Test
public void testCacheLoaderException() {
Map cache = CacheBuilder.newBuilder().build().asMap();
Integer n = 1;
try {
cache.computeIfAbsent(n,k->{
});
} catch (Exception e) {
}
int v = (int)cache.computeIfAbsent(n, k->k); //deadlock here
Assert.assertEquals(1, v);
}
All recursive operations on a map are undefined behavior, so this works as intended. When the cache was a feature of MapMaker it had this behavior for computations on `get`, but I switched it to fail fast by detecting the lock was already held. Ideally the computations would emulate that for consistency and friendliness, but it isn't required.
Java 8's `ConcurrentHashMap` will live-lock on this call and `HashMap` may corrupt itself. In Java 9 it will fail fast in both cases, if detected.
So this works as intended, but could be a tad nicer. Oh shoot, I misread. I've seen the recursion issues raised so many times across hash tables that, on seeing multiple `computeIfAbsent` calls, I saw the imagined pattern.
It does appear that `LocalCache.compute` fails to handle exceptions from `loadingValueReference.compute` and leaves the failed entry in the cache. The subsequent call waits for a future that has never been finalized. Isn't this the behavior referenced in https://github.com/google/guava/pull/2799? I'm also observing some strange behaviour with guava caches under contention. Not sure if these two issues are related. If they aren't, I'm happy to open a separate issue.
The issue is _very_ easy to trigger. I published a sample project on https://github.com/hibox-systems/guava-cache-test that demonstrates the issue. In my environment it works fine with 1, 2 and 3 threads. Using 4 threads or more always stalls the benchmark at some point. I have tried the benchmark with all published guava versions that are compatible with the sample code, i.e. guava 11.0 and newer. Tested with these JVM versions on Ubuntu 16.04 with a Intel Core i7-3770 CPU:
- OpenJDK 1.8.0_131-8u131-b11-2ubuntu1.16.04.3-b11
- Oracle 1.8.0_151-b12
- Oracle 9.0.1+11
Note that by default there are 4 hash segments, each having its own queue and counter for replaying reads. The queue is uncapped and draining is amortized across readers. There should be a per drain threshold to avoid over penalizing any thread. In a stress test like yours, one could imagine a memory issue, hang ups for the penalized callers, and contention adding to the read buffer. Caffeine uses a lossy ring buffer which avoids all of this. My guess is you are hitting the worst case which wouldnt be expected in practice, or at least not with the hardware available when the cache was designed.  Because [`ImmutableEntry`](https://github.com/google/guava/blob/c462d69329/guava/src/com/google/common/collect/ImmutableEntry.java) is a package-private type [`Maps.immutableEntry()`](https://google.github.io/guava/releases/21.0/api/docs/com/google/common/collect/Maps.html#immutableEntry-K-V-) has to declare its return type as `Map.Entry`, which (because it's an interface) can't be guaranteed to be immutable. This means that users of `Maps.immutableEntry()` can't express the immutability of the entry objects they're constructing to anyone they pass them off to. Since the immutable types are intended to be "'Interfaces', not implementations", I think it would make sense to expose this type publicly. [AbstractMap.SimpleImmutableEntry](https://docs.oracle.com/javase/7/docs/api/java/util/AbstractMap.SimpleImmutableEntry.html) is built in, so I don't think this is necessary. `SimpleImmutableMap` is actually still problematic since it's not `final` (and hence subclasses could potentially still not be immutable).
There are cases where you want to represent a key-value mapping but can't use a `Map` structure directly (e.g. this is how [proto3 supports maps](https://developers.google.com/protocol-buffers/docs/proto3#maps)) and providing a properly immutable `Entry` implementation would make such patterns safer, rare as they may be.  I'm using Guava 20 because my runtime is fixed to Java7 (App Engine Standard)
```
<dependency>
<groupId>com.google.guava</groupId>
<version>20.0</version>
</dependency>
```
Here is a simple code
```
public static void main(String[] args) {
Map<String, String[]> map = new HashMap<>();
map.put("one", new String[] {"a", "b"});
map.put("two", new String[] {"c", "d"});
map.put("three", new String[] {"e", "f"});
String join = Joiner.on("\n").withKeyValueSeparator("/").join(map);
System.out.println(join);
}
```
And here is the output
```
one/[Ljava.lang.String;@53e25b76
two/[Ljava.lang.String;@73a8dfcc
three/[Ljava.lang.String;@ea30797
```
It seems that the `Arrays.toString()` method is not properly managed when an array need to be outputted
For the moment I managed the problem like this
```
Maps.EntryTransformer<String, String[], String> mapTransformer = new Maps.EntryTransformer<String, String[], String>() {
public String transformEntry(String key, String[] value) {
return Arrays.toString(value);
}
};
Map<String, String> map2 = Maps.transformEntries(map, mapTransformer);
String join = Joiner.on("\n").withKeyValueSeparator("/").join(map2);
System.out.println(join);
```
It resolves #2851  I signed it!  Annotation libraries do not have `optional` any more, and are now runtime dependencies. In those libraries there are very few `RetentionPolicy.RUNTIME` annotations, and even those are not processed by Guava itself.
Please change scope of those dependencies to `<scope>provided</scope>` to have them at compile time but not to drag them into runtime. Dupe of #2824 Ok, in that case following line is not true any more: https://github.com/google/guava/blob/master/guava/pom.xml#L18  I wanted to copy map returned by `Maps.transformValues` using `Maps.immutableEnumMap. Double transformation really surprised me.
`transformEntry()` was called twice per entry:
1. [Maps.java#L150](https://github.com/google/guava/blob/fce5e62628a1eb3eab4dfdb7b6f2ce7fa3567557/guava/src/com/google/common/collect/Maps.java#L150) (null-check),
2. inside [`EnumMap(Map)`](https://docs.oracle.com/javase/8/docs/api/java/util/EnumMap.html#EnumMap-java.util.Map-) constructor.
This may be not the most elegant solution, but
```
for (Map.Entry<K, ? extends V> entry : map.entrySet()) {
checkNotNull(entry.getKey());
checkNotNull(entry.getValue());
}
return ImmutableEnumMap.asImmutable(new EnumMap<K, V>(map));
```
could be replaced with something similar to:
```
Class<K> keyType = (Class<K>) map.keySet().iterator().next().getDeclaringClass();
EnumMap<K, V> enumMap = new EnumMap<>(keyType);
for (Map.Entry<K, ? extends V> entry : map.entrySet()) {
K key = checkNotNull(entry.getKey());
V value = checkNotNull(entry.getValue());
enumMap.put(key, value);
}
return ImmutableEnumMap.asImmutable(enumMap);
```
It would be a little less efficient than using `EnumMap(map)` constructor in case of non-views (`put()` vs `putAll()`)~~, so additional `instanceof TransformedEntriesMap` check may be desirable~~.
I know that i can use `ImmutableMap.copyOf` before passing transformed map to `Maps.immutableEnumMap` or use `Maps.toImmutableMap` collector, but I decided to let you know what happened as you may have similar usages in your code base.
Please ignore `instanceof TransformedEntriesMap` note I made initially. This method should behave in a fully predictable way regardless of `map`' type (non-guava views etc.), so just make sure that `getValue()` is called once). By the way, `(Class<K>)` cast is unnecessary. > Actually, maybe what we should do is just perform the null checks after copying to the `EnumMap`?
@cpovirk That's clever, but it won't be as lazy as `ImmutableMap.copyOf(map)` which throws on first null key/value. This, again, could be surprising. > "Not lazy" in the sense that, if the transformation function returns null, we might transform other values before throwing? That seems probably tolerable.
Yes, that's what I meant. If this little "over-transformation" is tolerable, I don't mind at all! :) Just, please, don't transform twice.
Good luck, @lowasser! ;) Thank you! :)  The `SafeBox` example for `Monitor` is much more verbose than expected. We can do better:
public class SafeBox<V> {
private V value;
private final Monitor monitor = new Monitor();
private final Monitor.Guard valuePresent = guard(monitor, () -> value != null);
private final Monitor.Guard valueAbsent = guard(monitor, () -> value == null);
public V get() throws InterruptedException {
try (LockedMonitor ignored = monitor.autoEnterWhen(valuePresent)) {
V result = value;
value = null;
return result;
}
}
public void set(V newValue) throws InterruptedException {
try (LockedMonitor ignored = monitor.autoEnterWhen(valueAbsent)) {
value = newValue;
}
}
}
```
I think it's awkward to ignore a return value just to be able to use the Monitor with try-with-resource.
I fully support the creation of Guards using a BooleanSupplier, though! I wonder why @cpovirk explicitly excluded Monitor in his search query at issue #2785.  @ChristianCiach agreed, though I think it's nicer than try/finally. Too bad try-with-resources doesn't let you elide the resource variable (compared to `with` in Python where the `as xxx` is optional).  **tl;dr** This fixes part of Java 8's functional mapping combined with IOException, which is currently a pain.
In this Java 8 world, I found useful to have an interface called `IOFunction` that is basically `Function` that can throw `IOException`.
Typical form:
import java.io.IOException;
@FunctionalInterface
public interface IOFunction<F, T> {
T apply(F input) throws IOException;
}
Until here, there's nothing really interesting with this interface.
What makes it interesting is coupling it with `ByteSource` and `CharSource` to have a very quick access to a parsed object from those `ByteSource` and `CharSource`.
The typical implementation is rather obvious:
// In ByteSource
public <T> T read(IOFunction<InputStream, T> function) {
try (InputStream in = openStream()) {
return function.apply(in);
} catch (IOException e) {
throw new UncheckedIOException(e);
}
}
"Hey, but that's what `ByteProcessor` and `LineProcessor` do!"
Well, yes and no.
`ByteProcessor` takes control of things I don't want it to take control, such as the size of the chunks that need to be processed. Often `ByteProcessor` requires me to internally buffer bytes that overlap between chunks. Same thing for `LineProcessor`: not every text file is line-based. For instance, huge one-line JSON files, which happen every so often.
Also, both `ByteProcessor` and `CharProcessor` are 2-methods interfaces, meaning that they can't be `@FunctionalInterface`, so I can't simply pass a lambda or a method reference to the `read` methods.
Finally the `IOException` isn't manageable in stream-like API without much burden. This is why `UncheckedIOException` was introduced (see `java.nio.file.Files.lines`, for instance).
See how `IOFunction` makes it easy:
Optional<CharSource> source = ... ;
Optional<Properties> properties = source.map(s -> s.read(this::loadProperties));
Properties loadProperties(Reader reader) throws IOException {
Properties properties = new Properties();
properties.load(reader);
return properties;
}
Look! No resource management, clean `*Source` usage. Clean mapping (as in no inner `try`), I didn't use any complex structure: just a simple method making something obvious. Try making the same with `CharProcessor`. Yup, it's a pain :( Outside of `CharSource`? Well, what's the point to have the resource managed for you then if you don't use it? :P
So to ease the use of `ByteSource` and `CharSource` with Java 8, please think about making such `IOFunction`. Of course It's also OK to have a `FromBytesFunction` for `ByteSource` and `FromCharsFunction` for `CharSource` (this naming is similar to the `ToIntFunction` style, but it seems weak, anything else is welcome, ofc.).
Note that I've edited to make the intent of the method clearer: mapping inside stream-like API. It seems this wasn't clear at first: I thought the whole "Java 8 context" was clear enough, I was wrong. As a bonus, `Properties loadProperties(CharSource source)` avoids problems like "should i close the reader?", "is anyone else using it?" etc. I know. And you're entirely right, @lowasser ! It's not the question of being a pain or something. It's more like being more fluent and readable. I didn't mention that my personal implementation catches the `IOException` and wraps it in an `UncheckedIOException`, which is the deal when using `ByteSource` in j.u.Optional or stream-like API. Writing it plainly causes lots of duplication of that bit. @ogregoire Is `source.read(this::loadProperties)` more readable than `loadProperties(source)`? Really? Who said that? I said it's about being more fluent and readable.
Fluent when dealing with streams, and readable in the code that reads: you don't have to manage the try-with-resources... The try-with-resources is nice and easy, but if we have a tool to even avoid it, why not? You want to read? Then you just write your code from your `InputStream` or your `Readable`.  When we have some reflexive symmetric transitive relation between two instances of one class then an equivalence relation is a helpful assistant for check that this relation was accounted in code earlier.
For example we processed a relation between two people (p1, p2) and we don't want to process a relation (p2,p1) because it is the same. We put (p1, p2) to a set and when we invoke 'contains' method for (p2, p1) on the set we will get true.
[More about Equivalence Relation](https://en.wikipedia.org/wiki/Equivalence_relation)
[Example of implementation](https://github.com/ivan-osipov/guava/commit/007e471f459085edea9a04a13e08c40af4659911) Guava already provides an [`Equivalence`](https://github.com/google/guava/blob/master/guava/src/com/google/common/base/Equivalence.java) class. If I understand correctly, that seems to be what you're looking for. @Stephan202 as I know the goal of an Equivalence class to define a strategy to check equality of objects, I offer the class for storing a relation between objects
@lowasser exactly, it's sort of an unordered pair. In my opinion, when we use a pair - we try to simplify life for ourself, but when we use Equivalence Relation we try to improve our algorithms
@jrtom perhaps, we can, but if we want to keep our code understandable it becomes a not good idea. And Equivalence Relation can support nullable values.  I'm sure that migrating from Maven to Bazel has been thought about by someone on the Guava team already, but I thought that the task might as well be jotted down in an issue on GitHub as a future reminder and a meta-issue for when the time comes.
Perhaps the two most important criteria which Bazel needs to meet before migration can even be started would be:
- [ ] Be at a stable version (likely version 1.0 or greater).
- [ ] Can run on all the major OSs that Maven supports (or some other reasonable definition of cross-platform). Will likely include widely-used Linux distributions (Ubuntu, Fedora and others), macOS/OS X, and Windows 7+. @cpovirk Do you know if Dagger receives bug reports from its Windows users who wish to build Dagger from scratch?
I raised this as an issue with the Bazel devs some time ago, but I've admittedly not yet tested if more recent versions like 0.5.x work, so maybe my fear is unfounded now. I haven't received any, but I'd happily accept any request, and we could always set up AppVeyor tests if necessary   @cpovirk, thanks. Could you please also consider (or reject) #2848?  Previously, the TreeTraverser required that `children()` extended
`Iterable<T>`. This commit adds support for trees where children are
returned as `Iterable<? extends T>`.
Use case: support for https://github.com/prestodb/presto/blob/master/presto-parser/src/main/java/com/facebook/presto/sql/tree/Node.java#L43 without need to copy children lists during traversal. @lowasser , good point, thanks, but it just doesn't look that good.
@jrtom , this is even better since signature `<T> preOrder(T x, Function<T, ? extends Iterable<? extends T>>)` will compile nicely with method references. `TreeTraversal.using(func)` can't be made to work with method references in the "relaxed" case unless explicit type for method generic is provided.
That said, is there going to be  `preOrder()` operating on `SuccessorsFunction`-s? I looked into sources, but couldn't find anything besides the interface declaration.
Last but not least, does the _probable_ retirement of `TreeTraverser` say anything in regards on this PR? :)  This is recommended for any java library which is being published to
repositories like MavenCentral or JCenter to ensure that when you do
eventually convert the library to a Java 9 module, it won't change
names requiring all of your consumers and the projects which depend
upon your consumers to update their `moudle-info.java` files to
pick up the new name.
We can debate whether or not `com.google.guava` is the name you want
to adopt for your module. Other possible candidates are:
* `google.guava`
* `com.google.common.guava`
[This article](http://blog.joda.org/2017/05/java-se-9-jpms-automatic-modules.html) covers
a lot of the reasons you might want to use `com.google.guava`, but I have also read reasonable arguments for more concise names if you aren't worried about module name conflicts.
Related (a little bit) to #2571 @jodastephen, the author of that article, actually strongly [suggests](https://groups.google.com/forum/#!msg/guava-discuss/1I--H7xwwR8/OLvJo-FhAwAJ) using `com.google.common`. @Stephan202 you are right. I am happy to change the module name in the pull request to `com.google.common` if the Guava project owns that entire package namespace. I was under the (quite possibly wrong) impression that other libraries provided by other teams at Google might also contribute to that package namespace, and as such, thought that we should coordinate with other libraries/modules that provided subpackages of `com.google.common` by naming this module `com.google.common.guava`. I agree that it would be better to use the root package of the whole package hierarchy.
But, first I would like someone to be able to confidently confirm, "No other jar files inside or outside Google contribute classes to the `com.google.commons` package. It is entirely dedicated to the guava project."
If that's the case, I'll update the pull request on getting that confirmation. It's true. As long as you're willing to claim that the package root `com.google.common` is owned by the guava team, it's a fine choice. I've updated the pull request to match.
@cpovirk Does the Guava project wholly own the `com.google.common` package and it's sub-packages, both externally on GitHub and internally within Google?
On the assumption that my new understanding is correct, I'll rephrase my previous questions:
1. Does the Guava project wholly own the `com.google.common` package (not necessarily it's sub-packages)?
First of all, I think that Stephen makes a well-reasoned argument in his [JPMS module naming](http://blog.joda.org/2017/04/java-se-9-jpms-module-naming.html) post.
The point about `com.google.common` not being wholly "owned" by the Guava team is why I originally proposed that we deviate from Stephen's suggestion and go with `com.google.guava` instead of `com.google.common`. The scenario we want to avoid is this one in the future.
There is are 3 separate and mostly-independent teams inside Google each of which maintains a module which exports some packages in the `com.google.common` namespace. Let's call the teams (the people):
Blue Team
Red Team
Guava Team publishes a module which exports packages (reduced for space):
- com.google.common.annotations
- com.google.common.base
- com.google.common.collect
Blue Team publishes a module which exports packages:
- com.google.common.bonnet
- com.google.common.bird
- com.google.common.sky
Red Team publishes a module which exports packages:
- com.google.common.head
- com.google.common.hydrant
- com.google.common.robin
Only one of those teams can call their module `com.google.common`. If the Guava Team takes that, then what will the Blue Team and Red Team use? I'm assuming here that we don't really want the package structure to reflect organizational structure. It should represent what the code in the packages actually does. So, we don't want to force rerooting packages like `com.google.guava.common.base` or `com.google.blue.common.bird` just to create artificial common prefixes we can use for the module names.
There isn't really a great answer here. Personally, I think that `google.guava` would be a fine name. And `google.blue` and `google.red` may eventually make sense for the other modules once they are written. Modules (like the jars in which they are packaged) typically are the natural responsibility of a team of people. Package names are about the organizational logic of the code, but module names can (and maybe even should) reflect the group that is responsible for the module's maintenance. Suppose the Guava project grows in such a way that it makes sense to deliver a separate module for all of the "collect" and "base" packages separate from all the other packages currently bundled in the library. Which of the modules retains the name "com.google.common"?  I think it would make more sense at that point to announce to the community that the "google.guava" module is jettisoning the "collect" and "base" packages into a new "google.guava.core" or maybe "google.guava-core" or maybe even "google.lychee" module.
I actually think it might be better to separate the module names from the packages they contain because those concepts evolve through separate development lifecycles.
But, ultimately, I care less about the name you choose, than that you choose it before the 23.0 release, so we can get it published with this new manifest attribute. The choice is your's. Lets start by observing that Google (the company) owns everything under `com.google`. As such, it can choose to structure module names under there any way it wants, so long as there is a company-wide co-ordination to ensure that no package appears in two modules. This observation allows many choices for the module name however, and as such isn't that helpful.
(The observation is however that ALL Google modules should start with `com.google`, so I'd object strongly to `google.guava` as your module name).
In my blog, I describe this case, and argue that the implied super-package in a case like this is the next level up. Thus, I arrive at my view of `com.google.common` being the right package name for Guava. Doing so does not stop other teams using `com.google.common.bird` or `com.google.common.head` as module names if they need to.
------
Now, today this would be a pain to do, because it would mean publishing a separate artifact to Maven Central for each package, something that nobody would really want. However, there is a fair chance that Oracle will consider having multi-module jar files in a future release of Java (ie. one jar file containing many modules). Were this to happen, having a module for each package is suddenly not such a bad idea, as users could then depend on the subset of Guava they care about, or the whole of it, and not suffer any clashes.
module ???? {
requires transitive com.google.common.annotations;
requires transitive com.google.common.base;
requires transitive com.google.common.collect;
}
This is similar to the JDK, where the `java.se` module [aggregates others](https://stackoverflow.com/questions/44178366/what-is-the-significance-of-java-se-module-in-java-9). But note that there is no `java.se` package. ie. Aggregating modules can and will have names that differ from the packages, because they necessarily are aggregations of disconnected packages for the purpose of convenience.
Given this world view, `com.google.guava` is a viable module name, because the "Guava" project can be thought of as an aggregation of a set of unrelated packages Google chooses to publish publicly.
One final note however, if `com.google.guava` were chosen, Google the company would be committing to never having a package name of `com.google.guava`, as to do so would be asking for trouble.
------
What is the process by which the guava team can get this decision made? Now that JDK 9 looks like passing the official processes with no further changes, it is safe (and recommended) to add `Automatic-Module-Name` to Guava.
You'll keep declaring that until you write a proper module-info file, which won't be too hard to do once JDK 9 is finally released. (Maven has support for compiling module-info.java on JDK 9 and merging the .class file with the rest of the code so it all works on JDK 8).  There is a failing test on the `master` branch. It makes it difficult to test my own changes when master isn't healthy.  This might be a problem with my environment, but I'm not sure yet, so I'm filing this issue in case others have seen it.
```
$> mvn --version
pache Maven 3.5.0 (ff8f5e7444045639af65f6095c62210b5713f426; 2017-04-04T03:39:06+08:00)
Maven home: /Users/pepper/.sdkman/candidates/maven/3.5.0
Java version: 1.8.0_131, vendor: Oracle Corporation
Java home: /Users/pepper/.sdkman/candidates/java/8u131/jre
Default locale: en_US, platform encoding: UTF-8
OS name: "mac os x", version: "10.12.5", arch: "x86_64", family: "mac"
$> mvn package -e
...
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.031 sec
Results :
testScanDirectory_symlinkCycle(com.google.common.reflect.ClassPathTest): /var/folders/hj/8mjn8yss769b4tq09bqjnlmw0000gn/T/ClassPathTest482883858389546958: unable to guarantee security of recursive delete
testScanDirectory_symlinkToRootCycle(com.google.common.reflect.ClassPathTest): /var/folders/hj/8mjn8yss769b4tq09bqjnlmw0000gn/T/ClassPathTest3964094197949145330: unable to guarantee security of recursive delete
Tests run: 831436, Failures: 0, Errors: 2, Skipped: 0
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO]
[INFO] Guava: Google Core Libraries for Java .............. SUCCESS [ 13.045 s]
[INFO] Guava Testing Library .............................. SUCCESS [ 23.493 s]
[INFO] Guava GWT compatible libs .......................... SKIPPED
[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 06:37 min
[INFO] Finished at: 2017-06-15T10:32:15+08:00
[INFO] Final Memory: 73M/1479M
[INFO] ------------------------------------------------------------------------
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.7.2:test (default-test) on project guava-tests: There are test failures.
[ERROR]
[ERROR] Please refer to /Users/pepper/dev/github.com/eljobe/guava/guava-tests/target/surefire-reports for the individual test results.
[ERROR] -> [Help 1]
org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.7.2:test (default-test) on project guava-tests: There are test failures.
Please refer to /Users/pepper/dev/github.com/eljobe/guava/guava-tests/target/surefire-reports for the individual test results.
at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:213)
at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:154)
at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:146)
at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:117)
at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:81)
at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:51)
at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128)
at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:309)
at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:194)
at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:107)
at org.apache.maven.cli.MavenCli.execute(MavenCli.java:993)
at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:345)
at org.apache.maven.cli.MavenCli.main(MavenCli.java:191)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:498)
at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289)
at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229)
at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415)
at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356)
Caused by: org.apache.maven.plugin.MojoFailureException: There are test failures.
Please refer to /Users/pepper/dev/github.com/eljobe/guava/guava-tests/target/surefire-reports for the individual test results.
at org.apache.maven.plugin.surefire.SurefireHelper.reportExecution(SurefireHelper.java:74)
at org.apache.maven.plugin.surefire.SurefirePlugin.execute(SurefirePlugin.java:642)
at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:134)
at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:208)
... 20 more
[ERROR]
[ERROR] Re-run Maven using the -X switch to enable full debug logging.
[ERROR]
[ERROR] For more information about the errors and possible solutions, please read the following articles:
[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException
[ERROR]
[ERROR] After correcting the problems, you can resume the build with the command
[ERROR]   mvn <goals> -rf :guava-tests
```
I can dig into this problem for a few minutes, but it would be great if someone else can take a look who might be familiar with the tests.  Test Travis with env matrix  The default implementations of `{Byte,Char}Source.isEmpty()` seem to do unnecessary work when the size is known to be non-zero.
Here is what `ByteSource` does now:
public boolean isEmpty() throws IOException {
Optional<Long> sizeIfKnown = sizeIfKnown();
if (sizeIfKnown.isPresent() && sizeIfKnown.get() == 0L) {
return true;
}
// Fall back to reading a byte from the input stream...
```
I feel like it should do this instead:
public boolean isEmpty() throws IOException {
Optional<Long> sizeIfKnown = sizeIfKnown();
if (sizeIfKnown.isPresent()) {
return sizeIfKnown.get() == 0L;
}
// Fall back to reading a byte from the input stream...
```
That way it avoids reading the input stream when the size is known to be non-zero.
I see warnings in the javadocs that some sources report inaccurate sizes, but the example given is non-empty files that report a size of zero.  Are there empty files that falsely report a non-zero size?  If not, I think this change is safe. I think both of these source code examples are equivalent, functionality- and performance-wise, because the `&&` operator _short-circuits_ by my understanding. This means that `sizeIfKnown.get() == 0L` will only be evaluated if `sizeIfKnown.isPresent()` evaluates to true.
Consequently, I believe this change doesn't really do anything. The change skips reading a byte in the known, non-empty case. > The change skips reading a byte in the known, non-empty case.
I admit I struggle to see why. Can you give an example? When `sizeIfKnown()` returns `Optional.of(1000L)`, compare when the method returns. In the first case `ifPresent()` is true but `get() == 0L` is false thus the `if` is not taken. In the second case `isPresent()` is true so the `if` is taken, and then `false` is returned. Oh, I see now! Thanks for enlightening me. :)  For understandable reasons, `com.google.common.hash.Hashing.md5` and `sha1` were deprecated because they are cryptographically broken and it's vital that programmers not rely on them for secure uses.
I propose that the existing deprecation of `md5` and `sha1` remain; but that a non-deprecated, equivalent version of them be provided for uses such as mine. They should be named something like `unsafeMD5` or `brokenSHA1` to convey the risk of using them, but should not cause compiler warnings when used. That's a good workaround, thanks @cpovirk. By defining a Java class with its fine-grained warning suppression, I was able to eliminate the compiler warnings. This solution works for me (and I hereby place this code in the public domain):
package mypackage;
import com.google.common.hash.HashFunction;
import com.google.common.hash.Hashing;
/**
* Provides an md5 and sha1 hash function without producing deprecation warnings.
*/
public class LegacyHashing {
@SuppressWarnings("deprecation")
public static HashFunction md5() {
return Hashing.md5();
}
@SuppressWarnings("deprecation")
public static HashFunction sha1() {
}
}
``` @cpovirk What about nesting `LegacyHashing` inside of `Hashing` and linking the methods the other way round (i.e., `Hashing.md5()` calling `Hashing.LegacyHashing.md5()`) in order to make them easy to discover?  Moving to Bazel would be a very valid option once Bazel cleanly supports Windows, Mac, and Linux, and has the ability to publish artifacts to Maven Central (I'm actually not sure if this feature has been implemented yet). :) It's not really Bazel's responsibility to push to central. As long as it
spits out jars pushing to central can (and should) be done using something
On Fri, Jun 2, 2017 at 6:45 PM Jonathan Bluett-Duncan <
notifications@github.com> wrote:
> Moving to Bazel would be a very valid option once Bazel cleanly supports
> Windows, Mac, and Linux, and has the ability to publish artifacts to Maven
> Central (I'm actually not sure if this feature has been implemented yet). :)
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2840#issuecomment-305922773>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAEEEc8EzVdZzwsDvvnxn6X38iyoZznMks5sAIt8gaJpZM4NuxEa>
> .
>
> Strings are checked for well-known qualifiers and the qualifier ordering is used for version ordering. Unknown qualifiers are considered after known qualifiers, with lexical order (always case insensitive),
https://github.com/apache/maven/blob/master/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java
@cgdecker "" is the same as "final", so 23.0-rc1 < 23.0 = 23.0-final. It's definitely not about release order. Anyone using movable dependency resolution deserves trouble. But +1 for
killing the badge.
On Thu, Jul 27, 2017, 6:32 PM Chris Povirk <notifications@github.com> wrote:
> Sounds like a good move.
>
> Hopefully Gradle users aren't having too much trouble with 22.0-android as
> "latest."
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2839#issuecomment-318415886>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAEEEVLgk3WmS8krHhM3RW4Alo4u-Js7ks5sSLudgaJpZM4NurXN>
> .
>
We just upgraded our codebase to Guava 20 and started getting this compiler error:
```
[ERROR] COMPILATION ERROR :
[INFO] -------------------------------------------------------------
[ERROR] cannot access com.google.errorprone.annotations.CanIgnoreReturnValue
class file for com.google.errorprone.annotations.CanIgnoreReturnValue not found
[INFO] 1 error
[INFO] -------------------------------------------------------------
```
It seems similar to #2721 except that it affects both Guava 20 and 21 and also seems much more serious since it's an actual compile error and not a warning. After investigating further, the issue seems to be when using (any) annotation processing as well as `ForwardingExecutorService` (which was annotated with `@CanIgnoreReturnValue` as part of Guava 20). My uninformed guess is that javac wants to walk the type hierarchy so it can execute the right annotation processors, so when you have a class that extends `ForwardingExecutorService` it will try to read the annotations and fail when it gets to `@CanIgnoreReturnValue`.
I pushed a very simple example [here](https://github.com/jhaber/guava20-example), you can clone it and run `mvn compile` to reproduce the issue. The project just has a class that extends `ForwardingExecutorService`:
public class MyExecutorService extends ForwardingExecutorService {
protected ExecutorService delegate() {
return null;
}
}
```
and a `META-INF/services/javax.annotation.processing.Processor` file to activate javac's annotation processing. Note that the service file points to a non-existent annotation processor and the build still fails with the `CanIgnoreReturnValue` error. This seems to suggest that the failure is happening while javac is setting up for annotation processing, rather than while the annotation processor is executing (eg, the failure is not related to the implementation of the annotation processor nor is there a way for an annotation processor to catch and ignore these errors).
I see that transitive dependencies have been added as part of Guava 22, which seems unfortunate but probably better than the alternative (especially in light of this issue). The other "fix" that comes to mind is to remove the class-level `@CanIgnoreReturnValue` annotation from `ForwardingExecutorService` and instead annotate the individual methods (in my testing this didn't cause the same compile error, but might cause the warnings that #2721 was referring to). Would it be possible to get a new release of Guava 20 and 21 with one of these (or some other) fix? We have ~2,000 Maven modules that depend on Guava which complicates things a bit. Maven allows you to remove dependencies with exclusions but doesn't have a mechanism to do the opposite (add a new dependency to an artifact). If that existed, we could add the errorprone annotations dependency to Guava in our parent pom and have it apply to everything. But that's wishful thinking; in the meantime we just used the shade plugin to add an errorprone annotations dependency to Guava and depend on this version of Guava internally. For anyone who needs to do the same (I'm quite surprised no one has reported this issue yet) I put the POM in a [gist](https://gist.github.com/jhaber/971262d033df389a73495a20f76ccf0d).
To your second point, I don't like the idea of adding transitive dependencies to Guava (what if these dependencies in turn start adding their own transitive dependencies, and so on). But adding the dependencies seems better than the current state because, as I noted above, it is much easier (at least with Maven) to exclude an unwanted transitive dependency than it is to add a transitive dependency that doesn't exist. Anyone who doesn't want the new dependencies can simply add the appropriate exclusions (and if using `dependencyManagement` this only needs to be done in one place).
Other options that come to mind are to just remove the errorprone annotations which arguably don't belong in Guava, but it seems like that was already suggested and found unacceptable. A more extreme possibility is to release two versions of Guava. The first version would be like Guava 22; the classes have these extra annotations and there are transitive dependencies. The second version would have no transitive dependencies and in addition the class files would have these annotations stripped (to prevent weird issues like this one). I'm not sure if there's an existing Maven plugin that can do this specifically but it shouldn't be too hard to get working (it seems like a subset of the maven-shade-plugin functionality). @jhaber: If I understand your situation correctly you could also add `error_prone_annotations` to your parent-POM with the `provided` scope. That way it will be present compile-time but not be packaged. We do this in our project (~130 modules) for this dependency as well as others which contain only annotations (`com.google.code.findbugs:jsr305`, `org.immutables:value`). This also doesn't interfere with the dependency analysis performed by the `maven-dependency-plugin`, so it's okay if most/all modules don't _actually_ use those dependencies. Just to follow up, we've since upgraded to 22.0. Having the dependencies listed and excluding the ones we don't want has been much easier on our end. And since it seems like this is going to be maintained going forward I don't think there's a pressing need to make any patch releases.  [2017-06-01 18:16:52,334](main)([]) ERROR - ContextLoader - Context initialization failed
org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'com.google.common.cache.CacheBuilderSpec' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {}
at org.springframework.beans.factory.support.DefaultListableBeanFactory.raiseNoMatchingBeanFound(DefaultListableBeanFactory.java:1466)
at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1097)
at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1059)
at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:835)
at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:741)
... 94 common frames omitted
Wrapped by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'com.homeaway.ecommerce.commons.clients.PayoutVendorAccountCache': Unsatisfied dependency expressed through constructor parameter 1; nested exception is org.springframework.beans.f
at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:749)
at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:189)
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1148)
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1050)
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:512)
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:482)
at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306)
at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)
at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302)
at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197)
at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:754)
at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:866)
at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:542)
at com.homeaway.api.operations.dependencies.CommonDependencyContainer.loadBeanFactory(CommonDependencyContainer.java:166)
at com.homeaway.api.operations.dependencies.CommonDependencyContainer.<init>(CommonDependencyContainer.java:123)
at com.homeaway.api.operations.configuration.DefaultOperationsConfiguration.createDependencyContainer(DefaultOperationsConfiguration.java:471)
at com.homeaway.api.operations.configuration.DefaultOperationsConfiguration.resourceServiceRegistry(DefaultOperationsConfiguration.java:324)
at com.homeaway.api.operations.configuration.DefaultOperationsConfiguration$$EnhancerBySpringCGLIB$$a2fe5538.CGLIB$resourceServiceRegistry$22(<generated>)
at com.homeaway.api.operations.configuration.DefaultOperationsConfiguration$$EnhancerBySpringCGLIB$$a2fe5538$$FastClassBySpringCGLIB$$461876f3.invoke(<generated>)
at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:228)
at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:356)
at com.homeaway.api.operations.configuration.DefaultOperationsConfiguration$$EnhancerBySpringCGLIB$$a2fe5538.resourceServiceRegistry(<generated>)
at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:162) [4 skipped]
at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:588)
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1128)
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1022)  Greetings,
This test
@CollectionFeature.Require(SUPPORTS_ADD)
public void testAddAll_supportedNonePresent() {
assertTrue(
"addAll(nonePresent) should return true", collection.addAll(createDisjointCollection()));
expectAdded(e3(), e4());
}
```
in CollectionAddAllTester
is called for my Map, and keySet() and entrySet() of the map, which is fine.
but it is also calling for the values() collection of the map. How is that supposed to work? How am i supposed to generated keys?
Yes, i am passing SUPPORTS_ADD. ok, will remove. thanks Hello. My cell phone device have been hack and I have coming across off a lot of damage that the hacker have cause using my device I have limeted control of the cell phone any how I need help  @luisvega10 I think you might be in the wrong place, maybe try gsm hosting forums.
I am running
```@CollectionFeature.Require(absent = KNOWN_ORDER, value = SUPPORTS_ITERATOR_REMOVE)
public void testIterator_unknownOrderRemoveSupported() {
runIteratorTest(MODIFIABLE, IteratorTester.KnownOrder.UNKNOWN_ORDER, getSampleElements());
}
```
on a set, and the stimuli running is
[hasNext, hasNext, next, hasNext, remove]
My set throws an IllegalStateException on the remove, but the reference does not throw an exception.
thus, it fails, in
```if (referenceException == null) {
if (targetException != null) {
Helpers.fail(targetException, "Target threw exception when reference did not");
}
```
Am i wrong in throwing that exception? i thought once hasNext() was called, the remove couldn't be called... ok. thank you.  The test
@CollectionFeature.Require(value = SUPPORTS_ADD, absent = ALLOWS_NULL_VALUES)
public void testAddAll_nullUnsupported() {
List<E> containsNull = singletonList(null);
try {
collection.addAll(containsNull);
fail("addAll(containsNull) should throw");
} catch (NullPointerException expected) {
}
expectUnchanged();
expectNullMissingWhenNullUnsupported(
"Should not contain null after unsupported addAll(containsNull)");
}
```
only catches NPE. My collection throws IllegalArgumentException when null is presented, and thus testlib fails the test. Seems like any exception really should be caught. or at least IAE well, there is this
*         prevents it from being added to this collection
but ok. if NPE is expected to be thrown, then i'll change it. throwing NPEs is just so ugly  The maven artifact for guava 22.0 declares non-optional compile dependencies (e.g. jsr305, error_prone_annotations) while the previous version 21.0 declares all compile dependencies as optional. Is this intended?
Ordering.immutableSortedCopy should allow to pass wildcard type (Similar to ImmutableList.copyOf()).
public <E extends T> ImmutableList<E> immutableSortedCopy(Iterable<? extends E> elements).
We use it sometimes, but lack of wildcard forces to use ugly casts.  Runnable doesn't throw exceptions. Callable throws all Exceptions and has a return value, forcing one to declare a Callable<Void> argument in their code, and forcing users of the API to "return null" at the end of their lambdas for no good reason.
A ThrowingRunnable that throws a generic exception type would be really handy. Something like:
```
public interface ThrowingRunnable<T extends Exception> {
public void run() throws T;
}
```
I don't know how many times I defined a ThrowingRunnable that throws a specific exception type. This seems pretty useful with Java 8 for helper utilities that take a lambda that throws something and throws that same thing in return. Here's a few ideas:
```
/** Runs the runnable if the executionIndentifier hasn't been seen before */
public class ExecutionMemoizer {
public <T extends Exception> void runOnce(ThrowingRunnable<T> throwingRunnable, Object executionIdentifier) throws T {...}
}
public class ThrowingRunnables {
public static <T extends Exception> ThrowingRunnable<T> sequence(ThrowingRunnable<? extends T>... runnables) {...}
}
```
My first question should be, I guess, why doesn't this exist already. It's not a far fetched idea, somebody probably thought of this before. There must be a reason, and I'm curious about it.
If you think this would be a nice thing to have, I'll contribute.
Thanks!  This is available as `Checked` types in other utilities, e.g. [jOOL](https://github.com/jOOQ/jOOL) and [vavr](https://github.com/vavr-io/vavr). Its probably better to add one of them instead. Available in [MG](https://github.com/google/mug/tree/master/core/src/main/java/com/google/mu/function) as well.  A `Map.compute` may return `null` to indicate the entry should be removed if present. The `valueReference` is stored within the cache, allowing a subsequent `LoadingCache.get` to wait on it. This results in `LocalCache.waitForLoadingValue` to throw an `InvalidCacheLoadException` with the message `CacheLoader returned null for key`. Since the cache loader was not invoked, this message is incorrect and means the two methods cannot be used together, concurrently.
The user expectation would be that the load proceeds by retrying the load if `null` from a computation (but fails if from a cache loader). That may require using a sentinel value.
You can checkout this [commit](https://github.com/ben-manes/caffeine/commit/764df3aac6aacb78a4fc5a2134f911fd60dfa9f9) and run `MultiThreadedTest` using `./gradlew slowGuavaTest`.
Expected: is an empty collection
but: <[Failed: key 15 on operation com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$3/841283083@91eee99
com.google.common.cache.CacheLoader$InvalidCacheLoadException: CacheLoader returned null for key 15.
at com.google.common.cache.LocalCache$Segment.waitForLoadingValue(LocalCache.java:2321)
at com.google.common.cache.LocalCache$Segment.get(LocalCache.java:2206)
at com.google.common.cache.LocalCache.get(LocalCache.java:4147)
at com.google.common.cache.LocalCache.getAll(LocalCache.java:4210)
at com.google.common.cache.LocalCache$LocalLoadingCache.getAll(LocalCache.java:5154)
at com.github.benmanes.caffeine.cache.testing.GuavaCacheFromContext$GuavaLoadingCache.getAll(GuavaCacheFromContext.java:422)
at com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$1(MultiThreadedTest.java:101)
at com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149) Actually there are simpler fixes. A sentinel value would be invasive by requiring all read/write methods to check and translate, and computers to allocate a function to translate a null to the sentinel.
- Add a `ComputingValueReference` and have an instanceOf check in `waitForLoadingValue` when a null was detected. This class could extend `LoadingValueReference` as its merely tagging the behavioral difference.
- Add a decorator to the user's `CacheLoader` and move the assertion there. (This would also be needed in `get(key, callable)`).
All would require the cache loading calls to handle a retry loop. These two (or perhaps a similar variant) would be easy to implement and isolates the changes. We could also run a snapshot through the test suites to verify.  Added some Unit Tests that cover uncovered code until yet. @cpovirk
Would you mind approving my contribution?  New in Release 22 are a bunch of Maven dependencies that look like they should be compile-only, but are now required at runtime.
```
[INFO] +- com.google.guava:guava:jar:22.0:compile
[INFO] |  +- com.google.code.findbugs:jsr305:jar:1.3.9:compile
[INFO] |  +- com.google.errorprone:error_prone_annotations:jar:2.0.18:compile
[INFO] |  +- com.google.j2objc:j2objc-annotations:jar:1.1:compile
[INFO] |  \- org.codehaus.mojo:animal-sniffer-annotations:jar:1.14:compile
``` In case you didn't know "compile-only" is the `provided` scope. The `compile` scope is compile-time and later (i.e. including `runtime` and `test`).
Sounds like they should be either `<optional>true</optional>`, `<scope>provided</scope>`, or moved into a new "build tools" pom that people can depend on separately. I believe `<scope>provided</scope>` matches your intent, so is probably the correct solution. Any chance of a quick 22.1 release to resolve this? Otherwise we'll be adding a ton of exclusions for dependency convergence. I believe #2721 (0e29934933f33379de953727171f7ca1ec616a58) is a reasonable change, but since it affects backward compatibility, I think it should be clarified at least in the release notes. Please be aware that changes to pom.xml do not appear in the Full JDiff Report. Then my third suggestion still remains - move them to be dependencies of a new artifact.
Then people who just want to use the library don't have to add exclusions, and anyone who wants to build against it avoiding #2721 adds the extra dependency.
```
<dependency>
<groupId>com.google.guava<groupId>
<type>pom</type>
<scope>provided</scope>
</dependency>
I can still see them been dragged on our Maven project by `23.0-rc1`  I am using MutableValueGraph and has  graph structure as
1,1 -> 0
1,2 -> 2
2,2 -> 0
2,3 -> 3
3,3 -> 0
now if i get edge value for (1,2) it returns 2 but for (1,3) it returns null
its their any way to make it return 5(i.e 2+3) or should i use any other data structure for this purpose  I realize you have to do something in this scenario, but there's no where I can find in the doc that mentions that users might be interested in watching for a ClassCastException from contains in this situation. I never casted in my code - I just called it like this:
Range range = Range.downTo(0);
then later:
range.contains(0.00001);
the call to contains threw a ClassCastException because the range that was created contained a lower bound of type Integer and the value I passed to contains was clearly a Double. When compareTo was used (both are comparable), the code attempted to cast one of them to the other type. As I understand it here, the problem isn't that 0 can't be cast to a double - it's that 0 (integer) can't be autoboxed into a Double. I see what you're saying. I showed you the code I wrote, but I failed to mention that I was calling Range.downTo(minValue, minInclusive) within a generic builder:
```
class GuavaRangeBuilder<T extends Comparable<?>> {
private T minValue;
private T maxValue;
private BoundType minInclusive;
private BoundType maxInclusive;
...
Range build() {
...
return Range.downTo(minValue, minInclusive);
...
}
```
No compiler warnings here - T was an Integer at the time "build()" was called, thus Range was created with an Integer as the lowerBound.
Thanks for the feedback, btw.  This is not a issue, is just a question. Is there any reason why you are using "Object var1" parameter instead of "K var1" for invalidate method? I see for all the other methods the generics are used.      UnsignedBytes, UnsignedInts and UnsignedLongs all have many methods that can be re-implemented using methods in the primitive wrapper classes new to Java 8, and/or deprecated and scheduled for removal.
Here are the obvious mappings I found in UnsignedInts:
------|------
UnsignedInts.compare(int, int) | Integer.compareUnsigned(int, int)
UnsignedInts.toLong(int) | toUnsignedLong(int)
UnsignedInts.divide(int, int) | Integer.divideUnsigned(int, int)
UnsignedInts.remainder(int, int) | Integer.remainderUnsigned(int, int)
UnsignedInts.parseUnsignedInt(String) | Integer.parseUnsignedInt(String)
UnsignedInts.parseUnsignedInt(String, int) | Integer.parseUnsignedInt(String, int)
UnsignedInts.toString(int) | Integer.toUnsignedString(int)
UnsignedInts.toString(int, int) | Integer.toUnsignedString(int, int)
Specific examples:
ImmutableDoubleArray a = ImmutableDoubleArray.of(Double.NaN);
a.equals(a) == ? (hopefully true)
a.equals(ImmutableDoubleArray.of(Double.NaN)) == ?
a.indexOf(Double.NaN) == ?
a.lastIndexOf(Double.NaN) == ?
```
I suppose behaviour with the infinities and `-0.0` is unambiguous, but perhaps this should be documented too. Hi. Sorry, I'm not sure quite how I missed that for `indexOf(double)` and `lastIndexOf(double)` - the behaviour is quite clear.
For `equals(Object)` however there is no doc comment, which is the actual problem. (It needs to exist, unlike that of e.g. `ImmutableList<T>`, whose specification is inherited from `List<T>`.)
This also goes for `ImmutableIntArray` and `ImmutableLongArray`, although of course they don't suffer from any NaN weirdness.  Currently, `Iterables.getOnlyElement` just uses the iterator. A small optimization is to check whether the iterable implements `List` and `RandomAccess`, and if so, use `size()` and `get(0)` to get the only element. This would save an iterator allocation.  In my dissertation software, I have an instance of `MutableGraph<Equivalence.Wrapper<CustomDataClass>>`, where the associated `Equivalence` is `Equivalence.identity()`.
It involves some difficult-to-read boilerplate during interaction, due to need to create and unwrap the `Wrapper` instances. The alternative is to make `CustomDataClass`'s `equals` and `hashCode` be identity-based rather than value-based, and whereas I could do that, it feels dirty as `CustomDataClass` is supposed to be value-based (as if it were an `@AutoValue` class, or a `case class` or `data class` from Scala or Kotlin).
If I could specify upfront when creating the graph that the equality and hash codes of nodes are  determined by `identity()`, then that would eliminate a good amount of boilerplate in my code.
This could probably be expanded to accept any `Equivalence` rather than just `identity()`. However, it's not clear to me if it could be also be expanded to `ValueGraph`s and `Network`s; I suspect it would be useful sometimes for edge values to have a different `Equivalence` to nodes, so that would make things more complicated. @jrtom For my dissertation, I'm trying to model the order of "events" in a hypothetical concurrent software system:
- `MutableGraph` is the data structure that determines how the events are ordered.
- Each event is a node in the graph.
- A directed edge from `nodeU` to `nodeV` means that `nodeU` happen(s|ed) before `nodeV`.
Each event contains an "entity" (e.g. a networked computer) and a "message" (e.g. bits down the wire).
That's all fine, but when I insert an event into the `MutableGraph<CustomDataClass>`, I have a potential situation where if an event has an equal entity and message to an event that's already in the graph, then the new event doesn't get inserted. This happens for 2 reasons:
- `CustomDataClass.equals()` equates instances by the value of their entity and message, so the two events are considered "equal"
- `common.graph.Graph`s cannot contain 2 or more equal nodes
It's a problem because 2 or more events with an equal entity and message may occur during the lifetime of a concurrent software system (for the purposes of my dissertation). Since graphs reject equal nodes, I need a different solution.
My solution is to wrap each event with `Equivalence.identity()`. This causes two distinct events which coincidentally have equal entities and messages to _not_ be considered equal by the graph (because `==` is now used for equality), which allows both events to be inserted.
However, this means that the `MutableGraph` now contains `Wrapper<CustomDataClass>`s rather than plain `CustomDataClass`s. This introduces visual indirection, which makes code that I wrote to work with the graph harder for me to read, understand again, and update.
I hope this clears things up. I'd be very happy to answer your questions @jrtom, but as I've not explained the full story and the details are rather academic, I agree with you that it would be best to take this to email.
My email address is available on my profile; I can't seem to find yours, so how would you like to do this?  BloomFilter should follow the same philosophy as the Java Collections FrameWork: lightweight - no built-in thread-safety. When building BloomFilters we should focus on building it through reducing:
```
(bf,value)-> { bf.put(value); return bf; }
(bfl,bfr) -> { bfl.putAll(bfr); return  bfl; }
```
During this reduction process, which happens in parallel, at no point in time we need the properties of thread-safety.
Nice opportunity to write a `java.util.stream.Collector` that helps us reducing this straight out of Java 8 streams.
For reference - please see http://stackoverflow.com/questions/31788714/reducing-with-a-bloom-filter Argh, ninja'd by @lowasser. :wink:
Anyhoo, here is what I was going to say:
---
Hi @jdesmet, I think it'll take a _lot_ of convincing towards the Guava team to drop thread-safety in `BloomFilter`, because they only just recently accepted a huge PR to allow `BloomFilter` to be thread-safe (https://github.com/google/guava/pull/2761).
I admit I don't understand why "reducing" is any better than `BloomFilter`'s current way of doing things. Can you elaborate further? Also, do you have any numbers to prove that `BloomFilter` as it is is not fast enough? Of course I did not have any concrete evidence that non-thred-safe would be faster. That was just assuming by the way the Collections Framework was laid out and documented, and lack of better researching myself. I trust the findings in [#2761](https://github.com/google/guava/pull/2761). Interesting topic thread.
On the other hand - there will be always some level of distrust, maybe also in the correctness as extra levels of complexity are introduced. After all I had this first reaction to the `@ThreadSafe` tagging.
"Reducing" was quoted as a method for building the `BloomFilter`, because it only requires the properties of a monoid, and does not require thread-safety of the underlying data structures being reduced. Otherwise, if no additional overhead, I believe that current way BloomFilter works can be properly wrapped in any reducer. All I need is the `put` and `putAll`. The correctness is fudged because Guava's BloomFilter doesn't have a `clear()` method and, fundamentally, the data structure is probabilistic. That meant the concurrent version could be low overhead because races are benign.
public static <T> Collector<T, ?, List<T>> toImmutableList()
public static <T> Collector<T, ?, Set<T>> toImmutableSet()
public static <T extends Comparable<?>> Collector<T, ?, SortedSet<T>> toImmutableSortedSet()
public static <T, K> Collector<T, ?, Map<K, T>> toImmutableMap(
Function<? super T, ? extends K> keyMapper)
public static <T, K, U> Collector<T, ?, Map<K, U>> toImmutableMap(
Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends U> valueMapper)
Argh... okay. That certainly isn't where I expected to find a collector. :/ Java's don't expose the implementation details, e.g. `toMap()` doesn't state that it is a `HashMap`. Since the collectors in Guava do expose the type, e.g. `ImmutableMap`, your approach seems quite reasonable.  New child of EventBus that uses immediate Dispatcher, which isn't used in any impl as of now. I signed it!  Referencing #1259.
The documentation for Ints.trParse explicitly says that a NullPointerException is not thrown if the input is null. However, this is not true and the function does indeed throw a NPE.
I have simply removed the misleading lines from the doc. @googlebot I signed it!          Iterator<String> iter1 = Arrays.asList("1", "5").iterator();
Iterator<String> iter2 = Iterators.concat(Iterators.singletonIterator("2"), iter1);
assertEquals("2", iter2.next());
assertEquals("1", iter2.next()); // iterator points to before "5" now
Iterator<String> iter3 = Iterators.concat(Iterators.singletonIterator("3"), iter2); // prepend 3
assertEquals("3", iter3.next());
assertEquals("5", iter3.next()); // here we get NoSuchElementException   Yup, that's exactly what we want. d'oh  If the computeIfAbsent methods fails with a runtime exception, successive calls to computeIfAbsent lock due to a call to oldValue.waitForValue which never will receive a value then.
A test case to reproduce this behavior - the second computeIfAbsent will never return and your app is frozen.
The pull request restores the previous state of the cache on RuntimeException and the test will finish correctly.
`public class TestGuava extends TestCase
{
private Cache<String, Boolean> cache = CacheBuilder.newBuilder()
.maximumSize(10000)
.expireAfterAccess(30, TimeUnit.SECONDS)
.build();
private Map<String, Boolean> cacheMap = cache.asMap();
private final static Boolean TEST_BOOLEAN = new Boolean(true);
public void testComputeException()
{
try
{
cacheMap.computeIfAbsent("a", key ->
{
});
fail();
}
{
// expected
}
Boolean ret = cacheMap.computeIfAbsent("a", key -> {
});
assertEquals(Boolean.TRUE, ret);
assertSame(TEST_BOOLEAN, ret);
ret = cacheMap.computeIfAbsent("a", key -> {
return new Boolean(true); // should not create a new entry
});
assertEquals(Boolean.TRUE, ret);
assertSame(TEST_BOOLEAN, ret);
}
}` I signed it! This should rethrow Throwable in case of an Error. @ben-manes : You mean instead of catching "just" the RuntimeException (which actually is rethrown) to catch a Throwable, right? Else, I don't know which "Error" you mean. Yes, use Throwable. Otherwise a [java.lang.Error](https://docs.oracle.com/javase/8/docs/api/java/lang/Error.html) or sneakily thrown checked exception will not be handled. Well, thanks to Java 8 that one was easy to fix. Done! I'd like to ask if there is something else I can do that this fix gets merged?  I would also like to see this fix merged and released soon as I've seen a couple separate projects hit deadlocks on cache `compute` and the fix for https://github.com/google/guava/issues/2743 did not fully handle the above mentioned failure cases.
Thanks!  The linked Google Spreadsheet is no longer available (at least externally). I think it's fine to remove since the link to unicode.org details which codepoints are defined as whitespace.
Also, I double checked, and the list hasn't changed compared to what's used in CharMatchers. Cool! That other link works from my side.
I think the spreadsheet is a great reference (and I've seen it referenced around the net) so I think it's definitely worth keeping.
I'll update the PR I'm the next few days to swap the link.  I'd like RateLimiter to come out of Beta. It has been around since version 13.0 There is a TODO over at com.google.common.util.concurrent.RateLimiter.create
/*
* TODO(cpovirk): make SleepingStopwatch the last parameter throughout the class so that the
* overloads follow the usual convention: Foo(int), Foo(int, SleepingStopwatch)
*/
@VisibleForTesting
static RateLimiter create(SleepingStopwatch stopwatch, double permitsPerSecond) {
RateLimiter rateLimiter = new SmoothBursty(stopwatch, 1.0 /* maxBurstSeconds */);
rateLimiter.setRate(permitsPerSecond);
return rateLimiter;
}
```
Would you want a pull request to refactor this?  Here is the sample code that demonstrates the problem:
@Test
public void testRemoveDuringIterate1() {
ListMultimap<String, Integer> map = LinkedListMultimap.<String, Integer>create();
map.get("one").add( 1);
map.get("one").add( 2);
map.get("one").add( 3);
map.get("one").add( 4);
map.get("one").add( 2);
Iterator<Integer> it = map.get("one").iterator();
assertTrue(it.hasNext());
assertEquals(Integer.valueOf(1), it.next());
map.remove("one", 4);
List<Integer> remain = new ArrayList<>();
it.forEachRemaining((e)->remain.add(e));
assertEquals(Arrays.asList(2,3,2), remain);
}
@Test
public void testRemoveDuringIterate2() {
ListMultimap<String, Integer> map = LinkedListMultimap.<String, Integer>create();
map.get("one").add( 1);
map.get("one").add( 2);
map.get("one").add( 3);
map.get("one").add( 4);
map.get("one").add( 5);
Iterator<Integer> it = map.get("one").iterator();
assertTrue(it.hasNext());
assertEquals(Integer.valueOf(1), it.next());
map.remove("one",2);
List<Integer> remain = new ArrayList<>();
it.forEachRemaining((e)->remain.add(e));
assertEquals(Arrays.asList(3,4,5), remain);
}
```
First test passes, but second fails on last check, `remain` is [2,3,4,5] instead of expected [3,4,5]
I would expect that iterator either ignores all changes, or respect them all.
I suggest the following fix https://github.com/alsemenov/guava/commit/5562a2392823ad346c570d18cd177d8e88897852  Currently the `ToStringHelper` class constructs a StringBuilder with an initial capacity of 32 in the `toString` method
```
public String toString() {
// create a copy to keep it consistent in case value changes
boolean omitNullValuesSnapshot = omitNullValues;
String nextSeparator = "";
StringBuilder builder = new StringBuilder(32).append(className).append('{');
```
I think it would be useful to add an instance field to ToStringHelper that holds a Appendable instance that can be given to it, or defaulted to the ` new StringBuilder(32)`. Also additional factory methods would be added to`MoreObjects` to allow the user to specify said instance, e.g. `public static ToStringHelper toStringHelper(Appendable buffer, Object self) `.  This would allow reuse of StringBuilders as opposed to creating them every time. Scratch the `Appendable`, it can throw an `IOException`. Either `AbstractStringBuilder` or just a `StringBuilder` I am not having performance problems, but this seems like a good middle ground for people. There are cases were you don't want to allocate large `StringBuilders` over and over again, but want to stick with `ToStringHelper` for consistency sake. How about a `toString(StringBuilder sb)` and the original `toString()` that calls `toString(new StringBuilder(32))`? Having more flexibility seems like a win. I'd be more than happy to provider a PR > `ToStringHelper` already builds up a linked list of wrapped entries
I really wonder why. Building the string immediately in `add` would make it much simpler. The result would change in some strange cases, e.g., for `ToStringHelper.add("a", null).omitNullValues().toString()`, but learning to set an option before use shouldn't be hard. The result would also differ when the object changes between calls, but this doesn't seem important either. Where am I wrong?
I guess, I wouldn't use `toString(StringBuilder sb)`, but what about `appendTo(StringBuilder sb)`, which is more general (like `Joiner#appendTo`)? So there are cases where we get some really large strings (> 1K), so reusing large buffers (via a thread local or something) would be a win for me.  It is multiple things that are appended that cause the re-sizing of the buffer so it won't be a single resize. It is generally for logging. Performance critical is relative. Profiling the code you can see that the object allocation is definitely a drag. Disabling logging which basically no-ops these toStrings across improves performance by about 20%. So I wanted to still use Guava because of the flexibility in generating the toStrings, but wanted to re-use the buffers on a per-thread basis to cut down on those large allocations. It is easy enough to roll my own, but thought this would be a good addition to guava for those folks that like a middle ground.  Is it possible to support the use case here:
http://stackoverflow.com/questions/11120985/guava-collections-limit-permutation-size
Or alternatively, provide a static function like Sets#powerSet that returns instead of "the set of all possible subsets.." the set of all possible subsets of a given size? BTW I'm happy to do the legwork to implement this, provided one of the two solutions above makes sense. I believe this has been fixed as of https://github.com/google/guava/commit/8e7ff6a20794497109bcdae369c15d81d35dc3e7, with the introduction of `Sets.combinations(Set, int)`.
I don't know which release - 22.0 or 23.0 -  that it's planned for, however.  Hello.
Trying to compile my GWT (2.8.0) project by maven with dependency:
```
<dependency>
<groupId>com.google.guava</groupId>
<version>21.0</version>
</dependency>
```
and got the following:
```
[INFO] diagnostic C:\Users\user\.m2\repository\com\google\guava\guava-gwt\21.0\guava-gwt-21.0.jar(com/google/common/collect/Collections2.java):532: error: cannot access com.google.common.collect.AbstractIterator
private static final class OrderedPermutationIterator<E> extends AbstractIterator<List<E>> {
^
bad source file: C:\Users\user\.m2\repository\com\google\guava\guava-gwt\21.0\guava-gwt-21.0.jar(com/google/common/collect/AbstractIterator.java)
file does not contain class com.google.common.collect.AbstractIterator
Please remove or make sure it appears in the correct subdirectory of the sourcepath.
[ERROR] error on execute: error during compilation
...
[ERROR] Failed to execute goal org.bsc.maven:maven-processor-plugin:1.0.0:process (process) on project portal: Error executing: error during compilation -> [Help 1]
org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.bsc.maven:maven-processor-plugin:1.0.0:process (process) on project portal: Error executing
at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:213)
at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:154)
at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:146)
at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:117)
at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:81)
at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:51)
at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128)
at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:309)
at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:194)
at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:107)
at org.apache.maven.cli.MavenCli.execute(MavenCli.java:993)
at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:345)
at org.apache.maven.cli.MavenCli.main(MavenCli.java:191)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:498)
at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289)
at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229)
at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415)
at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356)
Caused by: org.apache.maven.plugin.MojoExecutionException: Error executing
at org.bsc.maven.plugin.processor.AbstractAnnotationProcessorMojo.execute(AbstractAnnotationProcessorMojo.java:204)
at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:134)
at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:208)
... 20 more
Caused by: java.lang.Exception: error during compilation
at org.bsc.maven.plugin.processor.AbstractAnnotationProcessorMojo.executeWithExceptionsHandled(AbstractAnnotationProcessorMojo.java:353)
at org.bsc.maven.plugin.processor.AbstractAnnotationProcessorMojo.execute(AbstractAnnotationProcessorMojo.java:197)
... 22 more
```
Target JDK is 1.8.
I'll appreciate any help about that. Thanks. Hi @cpovirk, it does not work, furthermore with 20.0 version I see the same situation. Ok I'll try to reproduce the problem with some GWT example and let you know. Thanks for help.  It turns out `google` is now a public suffix! I signed it!  In a normal application is common to throw an exception after eval an expression like
```
if (balance < amount) {
throw new InsufficientFundsException();
}
```
```
if (!optional.isPresent()) {
throw new NotFoundException();
}
```
This PR aims to get rid of those boilerplate code with propagateIf
```
Throwables.propagateIf(balance < amount, () -> new InsufficientFundsException());
Throwables.propagateIf(!optional.isPresent(), () -> new NotFoundException());
```
```
Throwables.throwIfInstanceOf(e, MyException.class)
```
The same could be achieved with
```
}
```
Both have similar amount of caracteres. The same applies for Preconditions so I assumed that amount of caracteres is not the main factor here and reduce the boilerplate code and unneeded complexity it was the main goal. Plus, you can eliminate characters:
```
Throwables.propagateIf(balance < amount, InsufficientFundsException::new);
```  Unfortunately, in cases where useful factory methods already exist, I cannot access them ;)
#2514 I think you should highlight the existence of `CacheLoader.from(func)` for lambda usage in the JavaDoc.  Currently, `TreeTraverser<T>` has a method `Iterable<T> children(T root)`.  Since for traversal, the returned `Iterable` is only used as a producer, the return type can be `Iterable<? extends T>` (and the `using()` static function can take a `Function<T, ? extends Iterable<? extends T>>`).
The use case is a tree model where at some level only leaf nodes exist, so there is for example a `List<LeafNode>`  (where `LeafNode` extends T).  With the current implementation, this has to be copied into a new list in order to compile (or using some ugly unsafe double-casting).
@kevinb9n,
Personally I feel that users who test with such fine granularity have to accept the extra brittleness, certainly for an API that is in beta.  After all the fix is trivial (just change the variable type).  Of course, they could also just pass a Java8 method reference to TreeTraverser.using(), and then test the method directly. @jrtom I can imagine one would like to model some kind of classification in a type safe way. Let's take taxonomic hierarchy as an example (https://en.wikipedia.org/wiki/Taxonomic_rank).
```
public abstract class Rank {
public Set<? extends Rank> getChildren() {
return ImmutableSet.of();
}
}
public class Life extends Rank {
private Set<Domain> children;
public Set<Domain> getChildren() {
return children;
}
}
public class Domain extends Rank {
// and so on...
}
// ... and on...
```
If PECS was applied, you could easily traverse entire `Life tree` (tree of life) by using `TreeTraverser.<Rank>using(Rank::getChildren).preOrderTraversal(tree)`. Now it's impossible. BTW, no casting/copying involved.
Another example, this time from real... life: Country / State / ... / City / Street (this hierarchy is locale-dependent, so I can't translate 1:1).
The point is, sometimes you really know what kind/class of children you can expect/return and where.
I hope that this post explains at least a little. Indeed, my uses cases were along the lines of the example that @perceptron8 has shown.  Another possibility (besides having the wildcard in the superclass's return type for `getChildren()`) is that the function to map parent to children uses `instanceof` and a (clean, safe) cast to distinguish between different types, some of which may return a specific type of children.
Regarding the use of `Set` vs `Iterable`: the fact that one needs to copy the children in case the model doesn't return a `Set` is one thing that worries me a bit.  The fact that one will need to copy them specifically into a `LinkedHashSet` (or similar `Set` implementation) in order to preserve the iteration order of the model, is another thing.  Uses cases where the order is important: DOM traversal, UI component hierarchy, ... I would like to argue against using `Set` as return type in a `TreeTraverser` replacement. We use it for abstract syntax trees, and if given something like `a + a`, we certainly expect it to visit `a` twice.
Btw., our abstract syntax trees are another example where `<? extends T>` would be useful. Ours looks like this:
```
class ASTNode {
List<? extends ASTNode> children();
}
class Expression extends ASTNode {
List<? extends Expression> children();
}
// many more subclasses of ASTNode and Expression...
```
Currently we use several of the ugly unchecked casts to solve this. @HermanBovens I believe Traverser is already included in the latest release, [23.2](https://github.com/google/guava/releases/tag/v23.2), under `com.google.common.graph.Traverser`. @jbduncan I just noticed this so had deleted my comment, but thanks anyway. @HermanBovens Okay, thanks for letting me know. For the future, it's often best not to delete comments outright, as it leaves conversations disjointed. When I personally do it or have seen others do it, I find it's more helpful to just leave an edit explaining why the comment is no longer applicable. :)  Everytime I wanted to use `StandardSystemProperty`, it was because I was in a testing context, to render the the call to `System.getProperty(String)` abstract. The only reason I see any use to `StandardSystemProperty` is to avoid using hardcoded keys, plus a cherry-on-top access to the real value.
However, when it comes to testing, I was actually stuck with the real value of `System.getProperty(String)` (because that's what `StandardSystemProperty.value()` provides) and had to use an external framework such as [System Rules](http://stefanbirkner.github.io/system-rules/) to change the real values. I couldn't simply "mock" them.
So I never use this enum because it's either too much or too few.
I would suggest to replace `StandardSystemProperty` with an injectable, mockable layer, a bit like what exists with `Stopwatch` and `Ticker`.
My suggested approach is the following:
public class SystemProperties {
private static SystemProperties defaultInstance = new SystemProperties(System::getProperty);
public static SystemProperties getInstance() { return defaultInstance; }
public static SystemProperties getInstance(Function<String,String> mapper) { return new SystemProperties(mapper); }
private SystemProperties(Function<String,String> mapper) { this.mapper = mapper; }
public Optional<String> get(String key) { return Optional.ofNullable(mapper.apply(key)); }
private String getRequired(String key) {
String value = mapper.apply(key);
if (value == null) { throw new RuntimeException("Expected property to exist: " + key); }
return value;
}
public String fileSeparator() { return getRequired("file.separator"); }
public String javaClassPath() { return getRequired("java.class.path"); }
... // All of the properties accessed through appropriately named methods.
}
I see several advantages to this:
1. The system properties are not hardcoded by the final user (it's already the case with the current enum)
2. The properties accessor becomes injectable (it's not the case with the current enum)
3. The properties accessor isn't hard to mock: just use an existing function. (it's not the case with the current enum)
4. Access to non-standard system properties is also normalized. (it's not the case with the current enum)
5. The properties are accessed by a method to easily change under the hood (it's already the case with the current enum)
--------
The current enum and this suggestion could even live together. If we even add an interface `SystemProperty`, so that custom properties could live with standard ones (and retrofit `StandardSystemProperty` to implement that interface), we could imagine replace the method `getProperty(String)` in the above suggestion with `getProperty(SystemProperty)`.
The usage could then become:
final SystemProperty CUSTOM_PROPERTY = SystemProperties.define("custom.property");
@Inject SystemProperties systemProperties;
...
systemProperties.get(CUSTOM_PROPERTY);
But this is already going to the next step.
-----
I could create this class and suggest a PR, but I'd like to have advice before starting it.  The following code snippet fails with IllegalStateException:
Stream<Integer> stream = Arrays.asList(1).stream();
Stream<Integer> stream2 = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8).stream();
Streams.concat(stream, stream2).parallel().toArray();
```
Stack trace:
```
Exception in thread "main" java.lang.IllegalStateException: Accept exceeded fixed size of 5
at java.util.stream.Nodes$FixedNodeBuilder.accept(Nodes.java:1224)
at java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948)
at com.google.common.collect.CollectSpliterators$1FlatMapSpliterator.lambda$forEachRemaining$1(CollectSpliterators.java:246)
at java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948)
at com.google.common.collect.CollectSpliterators$1FlatMapSpliterator.forEachRemaining(CollectSpliterators.java:246)
at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)
at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)
at java.util.stream.Nodes$CollectorTask.doLeaf(Nodes.java:2183)
at java.util.stream.Nodes$CollectorTask.doLeaf(Nodes.java:2149)
at java.util.stream.AbstractTask.compute(AbstractTask.java:316)
at java.util.concurrent.CountedCompleter.exec(CountedCompleter.java:731)
at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)
at java.util.concurrent.ForkJoinTask.doInvoke(ForkJoinTask.java:401)
at java.util.concurrent.ForkJoinTask.invoke(ForkJoinTask.java:734)
at java.util.stream.Nodes.collect(Nodes.java:328)
at java.util.stream.ReferencePipeline.evaluateToNode(ReferencePipeline.java:109)
at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:540)
at java.util.stream.AbstractPipeline.evaluateToArrayNode(AbstractPipeline.java:260)
at java.util.stream.ReferencePipeline.toArray(ReferencePipeline.java:438)
at java.util.stream.ReferencePipeline.toArray(ReferencePipeline.java:444)
at org.dive.java.Example.main(Example.java:15)
```
Everything is fine if `Streams.concat` is changed to `Stream.concat`  I met a case in using GuavaCache.
Cache<String, Object> cache = CacheBuilder.newBuilder()
.expireAfterWrite(600, TimeUnit.SECONDS)
.build();
When use this cache, I have several cache nesting, a method with cache call another method with cache, then when I want to invalidate the cache manually.
cache.cleanUp() doesn't work, and cache.invalidateAll() is ok.
Can someone provide an explanation?
Thanks. https://github.com/google/guava/wiki/CachesExplained#when-does-cleanup-happen
AFAICT from the javadocs, `cleanUp()` only does "maintenance", which may include removing expired entries if the cache thinks it is necessary to do so. So by my understanding, if it did anything else (like removing non-expired entries) then that would count as errorneous behaviour.
Hope this helps.  After serializing / deserializing Absent instances won't be the same (e.g. in an Apache Spark context with Kryo serialization).
Therefore the implementation below contains a bug. Why not just check if the two instances have the same class definition?
```
@Override public boolean equals(@Nullable Object object) {
return object == this;
}
``` To bad you cannot make absent an enum...
Kryo does not use `readResolve` or `writeReplace`. That requires custom code to when configuring, e.g. by changing the default serializer to cache and honor those methods. I'm not sure about others, like FST. Absent extends Optional, so it can't extend Enum. For custom serialization frameworks, most users will expect that they will need to provide custom serializers. Beyond the basics, recommending that users implement their own or use a [package](https://github.com/magro/kryo-serializers) is all that you'd have to do. I can add a custom serializer, no worry at all. But as `Present` serialization works I expected `Absent` serialization to work also. @kevinb9n I'm sorry I don't understand your latest comment, what's the tool you're talking about? @lowasser I understand and totally agree, thank you.  I've been working on a project that centres around DAGs. I was very surprised to find cycles cropping up, so I tracked the issue down to Graphs.transitiveClosure.
Then, I thought to actually check the documentation more thoroughly. It looks like this is intended behaviour, but should this behaviour maybe be changed? (Maybe a flag parameter that can be passed to disable self-cycles)
If not, maybe the documentation could make this a little clearer, since the Guava notion of the transitive closure is slightly different from the usual definition (unless I've really misunderstood things) - reachability elsewhere is defined as within 1 or more hops, but in Guava it is 0 or more.
There's a one-line workaround at least (`graph.nodes().forEach(n -> graph.removeEdge(n, n));`), hopefully that doesn't fall afoul of any concurrent modification rules. I think requiring the user to specify whether they want self-loops or not is best, as it would be more explicit and help to prevent surprises.
Requiring a `GraphBuilder` rather than a boolean parameter is a cool idea, but I think it may be too verbose in practice. How about an enum class like the following, which would provide more context than just a boolean param?
public enum class SelfLoops {
ALLOW, DISALLOW
}
```  Sample code [provided](https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/Stopwatch.html) states to use the following code:
Stopwatch.createStarted(
new Ticker() {
public long read() {
return android.os.SystemClock.elapsedRealtime();
}
});
```
However Ticker's "read" function is supposed to return nanoseconds.  Suggested change:
Stopwatch.createStarted(
new Ticker() {
public long read() {
return android.os.SystemClock.elapsedRealtimeNanos();
}
});
```
Without this change all my times where in s when logging using:
```
log.info("time: " + stopwatch);
```  It's all grown up.  I am not entirely sure about this, but shouldn't ForwardingCollection also forward calls to spliterator()?
The JavaDoc has a default method method warning that states:
> This class does not forward calls to default methods. Instead, it inherits their default implementations. When those implementations invoke methods, they invoke methods on the ForwardingCollection.
While this may be true, I think spliterator() could be an exception. Let's assume I want a ForwardingList to delegate its calls to an ArrayList. An ArrayList is easily splittable and overrides spliterator() to use its efficient implementation of Spliterator.
In this case, when using a ForwardingList and not overriding spliterator() manually, the default spliterator() implementation of the List interface will be used, which is a slow iterator-based implementation.
What do you think? Am I overlooking something? Or is this by design? Thanks, that's a good explanation!   From an API I have a com.google.common.base.Optional object i.e. of the guava library and I am running my project against Java 8 version. Now, if I use transform(Optional.transform) method and use Java 8 syntax of method reference to implement a Function in transform method, it throws the error shown below.
### **Example code -**
```
import com.google.common.base.Function;
import com.google.common.base.Optional;
public class MethodReferenceIssue {
public static void main(String[] args) {
System.out.println(getValue());
}
static Optional<Long> getValue(){
final Optional<Test> testOptional = Optional.of(new Test(2L));
return testOptional.transform(Test::getCode);
}
}
class Test {
public Test(long code) {
this.code = code;
}
public Long getCode() {
return code;
}
}
```
```
error: method transform in class Optional<T> cannot be applied to given types;
[ERROR] reason: cannot infer type-variable(s) V
[ERROR] (argument mismatch; invalid method reference
[ERROR] method getCode in class Test cannot be applied to given types
[ERROR] required: no arguments
[ERROR] found: ? super Test
[ERROR] reason: actual and formal argument lists differ in length)
[ERROR] where V,T are type-variables:
[ERROR] V extends Object declared in method <V>transform(Function<? super T,V>)
[ERROR] T extends Object declared in class Optional
```
Now I have solved this for now by creating a variable of type Function and then pass it as a parameter then it works fine.
### **Example code -**
```
import com.google.common.base.Function;
import com.google.common.base.Optional;
public class MethodReferenceIssue {
public static void main(String[] args) {
System.out.println(getValue());
}
static Optional<Long> getValue(){
final Optional<Test> testOptional = Optional.of(new Test(2L));
Function<Test, Long> testOpt = Test::getCode;
return testOptional.transform(testOpt);
}
}
class Test {
public Test(long code) {
this.code = code;
}
public Long getCode() {
return code;
}
}
```
**NOTE :-** this occurs with Guava version 21.0 and it works fine with guava version 20.0 But there is a change in Function interface and that's why there is reference issue while using the method reference. Please try to run the code sample provided here.
it is not because of transform it is because com.google.common.base.Function extends java.util.function.Function. @cpovirk - I have mentioned the exact code sample and I am facing the issue in the same while running it(in this sample only). Yes, it will compile as I am also able to compile it, but it will give the mentioned error if you run the `mvn install` command or try to execute the code.
Please try executing the main and I hope you will get the same error. @cpovirk - I have faced the similar issue in `public static <F, T> Iterable<T> transform(
final Iterable<F> fromIterable, final Function<? super F, ? extends T> function) ` in `com.google.common.collect.Iterables.java ` as I can not use Java 8 syntax for method reference as a second parameter.   Hi @monkeychen, was this empty Pull Request intentional?
Did you perhaps mean to pull `google/guava:master` into your own Guava fork? :)  ```
List<String> lst = ImmutableList.of("str");
Streams.mapWithIndex(lst.stream(), (c, i) -> {
System.out.println(c);
return c;
}).collect(toImmutableList());
```
its print: str
that's ok
but
```
List<String> lst = ImmutableList.of("str");
Streams.mapWithIndex(lst.stream(), (c, i) -> {
System.out.println(c);
return c;
});
```
this print nothing.
Map<String, String> map = Maps.newHashMap();
List<String> lst = ImmutableList.of("str");
Streams.mapWithIndex(lst.stream(), (c, i) -> {
map.put(c, c);
return c;
});
System.out.println(map);
```
expect get  {"str", "str"} but {}  very helpful for me to understand stream.
thank you!  I can currently write:
```
int max = Ints.max();
```
And I will get an exception at runtime. There is a way to enforce at least one argument while keeping the existing version for back compat if they have supplied an actual array.
The existing one changes signature to `public static int min(int[] array)`. Then a new overload would be coded as so, so that `Ints.max()` yields a compile time error.
/**
* Returns the greatest value present in {@code head}, {@code tail}.
*
* @param head an int {@code int} value
* @param tail an array of {@code int} values
* @return the value present in {@code tail} or {@code head} that is greater than or equal to every other value
*     in the parameters
*/
public static int max(int head, int... tail) {
int max = head;
for (int i = 1; i < tail.length; i++) {
if (tail[i] > max) {
max = tail[i];
}
}
return max;
} Yep the only breaking cases are ones that are currently runtime exceptions anyway.
I suppose the signature I should have proposed would be `max(int a, int b, int... others)` because any `max` etc with less than 2 args makes no sense. Custom linting could also catch such cases though.  # Our use-case
```
ListMultimap<String, Foo> foosByName = ...;
List<Foo> foos = foosByName.get("foo");
// this actually hands the object over to another thread which eventually sends it over the wire
output.send(foo);
...
// later
foosByName.removeAll("foo"); // internally calls clear() on the backing collection
```
```
java.util.ConcurrentModificationException
at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901)
at java.util.ArrayList$Itr.next(ArrayList.java:851)
at com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection$WrappedIterator.next(AbstractMapBasedMultimap.java:486)
...
```
# Rationale
We're aggregating data into a `ListMultimap<String, Foo>`. Then, when the time is right and all data for a specific foo name has been collected, we want to send it out. This is done via handing the `List<Foo>` returned by `foosByName.get("foo")` to another thread which then _iterates_ over the list's contents and does the actual sending. While this is in progress, we can sometimes observe a `ConcurrentModificationException` being thrown because the original aggregator thread has called `foosByName.removeAll("foo")` in the meantime.
The original aggregator thread cannot instead call `List<Foo> foos = foosByName.remove("foo")` and then send the list out because its actually being sent out multiple times, to multiple destinations, upon multiple signals. But we're sure we're not mutating it in any way anymore.
# Expected behaviour
`foosByName.removeAll("foo")` should not call `clear()` on the underlying collection as it might have been handed out to someone else already. Is there any real-world reason for the call?
P.S. Obviously we changed our design as it was iffy at best. Still, the unexpected `clear()` seems to be unnecessary?  I want to count the number of elements in bloomfilter.
Here is the solution discussed in stackoverflow:
http://cstheory.stackexchange.com/questions/10023/computing-the-approximate-population-of-a-bloom-filter
and here is my implementation.
public int getPopulationApprox() {
double proportionOf0s = 1 - bits.bitCount / (double)bitSize() ;
return Convert.toInteger(Math.log(proportionOf0s) / (numHashFunctions * Math.log(1 - 1.0 / bitSize())) ) ;
}
Could any one take a look? Should I push a change? looks different
http://cstheory.stackexchange.com/questions/10023/computing-the-approximate-population-of-a-bloom-filter  "compute.amazonaws.com" is not recognized as a public suffix.  "hasPublicSuffix" returns false for a few others as well:
My understanding is if it ends in a suffix from PSL it should return true - is that correct ?
Thanks.  Currently, the `delegate` is put directly into the instance, violating Effective Java 2nd Edition, Item 76.  Previously, the BloomFilter wasn't thread-safe and required external locking to ensure safety. Now, it's thread-safe and lock-free through the use of atomics and compare-and-swap.
This PR introduces **no** API changes beyond an extra `@ThreadSafe` annotation on the BloomFilter class. It should also be entirely backwards (and forwards) compatible with the serialization format because that too isn't being changed.
Please extend extra scrutiny to the `LockFreeBitArray.putAll()` method because it's not present in our internal fork of the BloomFilter class and has thus not gone through our integ tests or has seen prod (I wrote it for this PR).
Fixes #2748. >To strengthen your argument, you should probably add a benchmark to show the performance impact for reads and writes in a single threaded case. See Guava's Caliper benchmarks.
I have JMH benchmarks (see this email for [Caliper vs JMH](https://groups.google.com/forum/#!msg/mechanical-sympathy/m4opvy4xq3U/7lY8x8SvHgwJ)) set up for our internal fork which is largely the same except the serialization parts have been ripped out, other hash strategies have been added etc. Perf using the standard murmur3 strategy should be identical.
I can update that and post numbers. It's not ideal, but it's the best I have without going through the massive hassle of supporting JMH benchmarks for guava (I wouldn't trust Caliper). @ben-manes
OK, I'm doing benchmarks first for the suggestions you've made. [Here's my benchmark code](https://gist.github.com/Valloric/f57aa7726947250065dc1a878fc33888), for reference only.
Benchmark results I currently have:
```
NOTE: "Batch" means 10k puts, NOT one put!
NOTE: The units aren't the same across benchmarks; some use nanos, some micros.
Original PR
Benchmark                                                        Mode  Cnt      Score       Error  Units
LockFreeBloomFilterBenchmark.measureContainMultiThread           avgt    4    511.674     17.661  ns/op
LockFreeBloomFilterBenchmark.measureContainSingleThread          avgt    4    490.260      4.765  ns/op
LockFreeBloomFilterBenchmark.measurePutBatchRandomsMultiThread   avgt    4  15080.691  11069.316  us/op
LockFreeBloomFilterBenchmark.measurePutBatchRandomsSingleThread  avgt    4  10408.925    203.714  us/op
LockFreeBloomFilterBenchmark.measurePutSameSingle                avgt    4    624.769     39.450  ns/op
Benchmark                                                        Mode  Cnt      Score     Error  Units
LockFreeBloomFilterBenchmark.measureContainMultiThread           avgt    4    494.897   21.302  ns/op
LockFreeBloomFilterBenchmark.measureContainSingleThread          avgt    4    489.003   14.366  ns/op
LockFreeBloomFilterBenchmark.measurePutBatchRandomsMultiThread   avgt    4  12040.170  312.177  us/op
LockFreeBloomFilterBenchmark.measurePutBatchRandomsSingleThread  avgt    4  10927.175  381.793  us/op
LockFreeBloomFilterBenchmark.measurePutSameSingle                avgt    4    634.361   75.430  ns/op
```
As expected, LongAdder helps in the multi-threaded Put scenario. So I'll make that change. I'll run a similar benchmark for the lambda change. @ben-manes
And here are the benchmarks for the original code, without any lock-free stuff. Note that the benchmark names for the original code still have "lockfree" in them but the code is not actually lock-free.
```
NOTE: "Batch" means 10k puts, NOT one put!
NOTE: The units aren't the same across benchmarks; some use nanos, some micros.
Benchmark                                                        Mode  Cnt      Score     Error  Units
LockFreeBloomFilterBenchmark.measureContainSingleThread          avgt    4    489.003   14.366  ns/op
LockFreeBloomFilterBenchmark.measurePutBatchRandomsSingleThread  avgt    4  10927.175  381.793  us/op
LockFreeBloomFilterBenchmark.measurePutSameSingle                avgt    4    634.361   75.430  ns/op
Without PR (no atomics or locking, original code)
Benchmark                                                        Mode  Cnt      Score      Error  Units
LockFreeBloomFilterBenchmark.measureContainSingleThread          avgt    4    474.787    10.863  ns/op
LockFreeBloomFilterBenchmark.measurePutBatchRandomsSingleThread  avgt    4   8958.676    56.457  us/op
LockFreeBloomFilterBenchmark.measurePutSameSingle                avgt    4    624.619    37.565  ns/op
```
As expected, the puts are slightly slower (about 20%) in the lock-free version. The read perf is the same because atomic reads are free on x86 (and x86-64). It's hard for me to imagine a realistic single-threaded use-case for a bloom filter; even then, since the read path is what almost always matters in a bloom filter and that sees no slowdown, I think a 20% hit on the single-threaded put path is acceptable.
@lowasser Any thoughts on this PR so far? @lowasser @ben-manes The latest code addresses all issues that have been brought up so far.   @lowasser @ben-manes
OK, benchmarks with the extra IF branch. Note that I'm including another set of benchmarks for the same code pairs, but the second set is with a much smaller bloom filter: 10k puts on a BF with 50k expected insertions vs the original 10k puts on a BF with 150M expected insertions. I added this to look at cases with more thread contention.
```
Benchmark                                                        Mode  Cnt      Score     Error  Units
LockFreeBloomFilterBenchmark.measureContainMultiThread           avgt    4    487.889   14.100  ns/op
LockFreeBloomFilterBenchmark.measureContainSingleThread          avgt    4    489.317    4.928  ns/op
LockFreeBloomFilterBenchmark.measurePutBatchRandomsMultiThread   avgt    4  11804.317   39.740  us/op
LockFreeBloomFilterBenchmark.measurePutBatchRandomsSingleThread  avgt    4  11673.301  407.479  us/op
LockFreeBloomFilterBenchmark.measurePutSameSingle                avgt    4    618.878   38.190  ns/op
Original PR + LongAdder + no-lambda + extra IF in retry loop
Benchmark                                                        Mode  Cnt      Score     Error  Units
LockFreeBloomFilterBenchmark.measureContainMultiThread           avgt    4    495.849   72.557  ns/op
LockFreeBloomFilterBenchmark.measureContainSingleThread          avgt    4    490.722    4.135  ns/op
LockFreeBloomFilterBenchmark.measurePutBatchRandomsMultiThread   avgt    4  11860.600  142.482  us/op
LockFreeBloomFilterBenchmark.measurePutBatchRandomsSingleThread  avgt    4  11234.194  257.156  us/op
LockFreeBloomFilterBenchmark.measurePutSameSingle                avgt    4    630.437   51.002  ns/op
=== SMALLER BENCH BLOOM FILTER! ===
Benchmark                                                        Mode  Cnt     Score     Error  Units
LockFreeBloomFilterBenchmark.measureContainMultiThread           avgt    4   523.716   76.739  ns/op
LockFreeBloomFilterBenchmark.measureContainSingleThread          avgt    4   494.077    6.449  ns/op
LockFreeBloomFilterBenchmark.measurePutBatchRandomsMultiThread   avgt    4  6541.044  112.961  us/op
LockFreeBloomFilterBenchmark.measurePutBatchRandomsSingleThread  avgt    4  6318.562  179.519  us/op
LockFreeBloomFilterBenchmark.measurePutSameSingle                avgt    4   616.819    4.884  ns/op
Original PR + LongAdder + no-lambda + extra IF in retry loop
Benchmark                                                        Mode  Cnt     Score      Error  Units
LockFreeBloomFilterBenchmark.measureContainMultiThread           avgt    4   529.688    78.308  ns/op
LockFreeBloomFilterBenchmark.measureContainSingleThread          avgt    4   501.248     5.284  ns/op
LockFreeBloomFilterBenchmark.measurePutBatchRandomsMultiThread   avgt    4  6574.708  1121.399  us/op
LockFreeBloomFilterBenchmark.measurePutBatchRandomsSingleThread  avgt    4  6241.094   275.969  us/op
LockFreeBloomFilterBenchmark.measurePutSameSingle                avgt    4   618.840    20.353  ns/op
```
The results are the same with and without the extra IF. Should I add it then or not? I'm leaning "no" because it doesn't seem to be paying off. Personally I'm fine with either. Also, the extra IF seems to be introducing extra variance in the multi-threaded runs, probably because of branch prediction failures.
It could also just be noise, but it's consistent across BF sizes. Note that you are using a uniform distribution. The `if` check would be helpful if the entry had already been added to avoid unnecessary CASes. A Zipf distribution ([example](https://github.com/ben-manes/caffeine/blob/master/caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/GetPutBenchmark.java)) might show beneficial results. @ben-manes That's convincing enough for me. Perf is flat on a uniform distribution and the difference in variance is likely to be noise, and even if it isn't, it probably doesn't matter.
More data:
```
Original PR + LongAdder + no-lambda + extra IF in retry loop
Benchmark                                                        Mode  Cnt     Score     Error  Units
LockFreeBloomFilterBenchmark.measureContainMultiThread           avgt    4   500.731   68.968  ns/op
LockFreeBloomFilterBenchmark.measureContainSingleThread          avgt    4   490.522    5.937  ns/op
LockFreeBloomFilterBenchmark.measurePutBatchRandomsMultiThread   avgt    4  6530.204  114.009  us/op
LockFreeBloomFilterBenchmark.measurePutBatchRandomsSingleThread  avgt    4  6267.970  176.621  us/op
LockFreeBloomFilterBenchmark.measurePutSameSingle                avgt    4   615.487    9.207  ns/op
```
I did another run of the benchmark with the same smaller BF config and the large variance from the previous run went away. So it's noise, making the IF a safe pick. It's either better with a zipfian distribution, or no worse. Note that with the new IF in the retry loop, we can now remove this IF check:
if ((oldValue & mask) == 0) {
bitCount.increment();
return true;
}
```
We just always run the body now. @lowasser @ben-manes
Code updated to address all issues raised so far.  > Note that my approval carries no weight towards integration.
I know, but it carries weight with me in that I'm more confident this is working well. :) @lowasser Friendly ping. :) @lowasser One more ping... > LGTM, I'll try to get this merged internally.
Thank you! :) Resolved merge conflicts recently introduced through changes on `master`. @lowasser Any updates? It's been 2 weeks since this PR reached a stable state... @lowasser Can I help in any way? If I can make your life easier by changing this PR, I'd be happy to do so. @lowasser @artityod Any updates? This has been ready to merge for a month and a half now... @lowasser Thanks for the update! Glad to see this hasn't fallen by the wayside. :)  Hi
Please reopen this issue.
https://github.com/google/guava/issues/2757.
Given further updates on same.
Hi,
after adding `compile 'com.google.guava:guava:21.0'` to my Android project Gradle's dependencies, I got this build error:
>
> Information:Gradle tasks [:app:assembleBrandAFastBuildDebug]
> Error:Lambda coming from jar file need their interfaces on the classpath to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath to be compiled, unknown interfaces are java.util.function.Consumer
> Error:Lambda coming from jar file need their interfaces on the classpath to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath to be compiled, unknown interfaces are java.util.function.Supplier
> Error:Lambda coming from jar file need their interfaces on the classpath to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath to be compiled, unknown interfaces are java.util.function.Supplier
> Error:Lambda coming from jar file need their interfaces on the classpath to be compiled, unknown interfaces are java.util.function.BinaryOperator
> Error:Lambda coming from jar file need their interfaces on the classpath to be compiled, unknown interfaces are java.util.function.BiConsumer
> Error:Lambda coming from jar file need their interfaces on the classpath to be compiled, unknown interfaces are java.util.function.BinaryOperator
>...
> Error:Lambda coming from jar file need their interfaces on the classpath to be compiled, unknown interfaces are java.util.function.Consumer
> Error:Lambda coming from jar file need their interfaces on the classpath to be compiled, unknown interfaces are java.util.function.Consumer
> Error:Lambda coming from jar file need their interfaces on the classpath to be compiled, unknown interfaces are java.util.function.BiPredicate
> Error:Lambda coming from jar file need their interfaces on the classpath to be compiled, unknown interfaces are java.util.function.Consumer
> Error:Lambda coming from jar file need their interfaces on the classpath to be compiled, unknown interfaces are java.util.function.Function
> Error:Lambda coming from jar file need their interfaces on the classpath to be compiled, unknown interfaces are java.util.function.IntFunction
> Error:Default method void addAll(java.lang.Iterable ranges) not supported in Android API level less than 24
> Error:Default method boolean enclosesAll(java.lang.Iterable other) not supported in Android API level less than 24
> Error:Default method void removeAll(java.lang.Iterable ranges) not supported in Android API level less than 24
> Error:Default method boolean test(java.lang.Object input) not supported in Android API level less than 24
> Error:Default method void forEachEntry(java.util.function.ObjIntConsumer action) not supported in Android API level less than 24
> Error:Default method void forEach(java.util.function.Consumer action) not supported in Android API level less than 24
> Error:Default method java.util.Spliterator spliterator() not supported in Android API level less than 24
> Error:Static method void com_google_common_collect_Multiset_lambda$forEach$1(java.util.function.Consumer action, com.google.common.collect.Multiset$Entry entry) not supported in Android API level less than 24
> Error:Static method void com_google_common_collect_Multiset_lambda$forEachEntry$0(java.util.function.ObjIntConsumer action, com.google.common.collect.Multiset$Entry entry) not supported in Android API level less than 24
> Error:Default method void forEach(java.util.function.BiConsumer action) not supported in Android API level less than 24
> Error:Static method void com_google_common_collect_Multimap_lambda$forEach$0(java.util.function.BiConsumer action, java.util.Map$Entry entry) not supported in Android API level less than 24
> Error:Execution failed for task ':app:transformClassesWithPreJackPackagedLibrariesForBrandAFastBuildDebug'.
> > com.android.build.api.transform.TransformException: com.android.builder.core.JackToolchain$ToolchainException: Jack compilation exception
> Information:BUILD FAILED
> Information:Total time: 1 mins 15.703 secs
> Information:190 errors
> Information:0 warnings
> Information:See complete output in console
I'm already using:
```
android {
compileSdkVersion 25
buildToolsVersion "25.0.2"
...
jackOptions {
enabled true
}
compileOptions {
sourceCompatibility JavaVersion.VERSION_1_8
targetCompatibility JavaVersion.VERSION_1_8
}
release {
minifyEnabled false
proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
}
}
```
Gradle's project configuration snippet:
classpath 'com.android.tools.build:gradle:2.5.0-alpha-preview-01'
In `gradle-wrapper.properties` I have:
distributionUrl=https://services.gradle.org/distributions-snapshots/gradle-3.5-20170213202653+0000-all.zip
Could you provide any resolution to this problem? I've already found a temporary solution to this problem
After downgrading library version from:
compile 'com.google.guava:guava:21.0'
to
compile 'com.google.guava:guava:20.0'
build successfully completes and app runs fine.
@kevinb9n thanks for response.  For this time, previous version Guava in version 20 is enough.
If I would find another workaround besides downgrading lib version, I would let you know.
Hope that version 22 would have this problem fixed ;-)
@cpovirk could you provide any solution other than downgrading Guava version as you closed unresolved issue? Just wondering. Java 8 support: compile 'com.google.guava:guava:22.0-android'  Now that Guava Supplier extends Java Supplier the Suppliers utility methods (e.g. `Suppliers#memoize(Supplier)` should accept a Java Supplier instead of a Guava one. From Guava 21 onwards, this shouldn't be a breaking change, because a Guava Supplier is a Java Supplier.
I'd be willing to submit a PR for this change if this seems acceptable. > Is it possible that breaking binary compatibility isn't a real problem anymore in the modern world? I admit I'm out of touch with that and would love some edification.
@kevinb9n
The binary compatibility of Guava is greater and greater problem because Guava has becomes immensely popular and we're stuck with long-dead dependencies that rely on unsupported versions of Guava. So we're stuck with a dependency we need, but can't rewrite ourselves, without being given time.
What we do to fix it internally is grab a copy of the source code of the project and compile it against a more recent version of Guava (and fix its Guava usage if Guava changed its API in between).
One alternative: a new utility class that duplicates the methods but changes signatures to accept and return Java Supplier instead. @kevinb9n Actually I was trying to explain how we do outside of the "everything-is-up-to-date-at-all-times" world ;)  I am getting following exception while referencing guava latest 21.0 jar.
java.lang.NoClassDefFoundError: Could not initialize class com.google.common.io.BaseEncoding
return BaseEncoding.base64Url().omitPadding().encode(buffer); // or base32()
Please do the needful.
Maven build is fine for this; and I can see jar is update to 21.
Issue I am getting at runtime on this. Please find the complete logs for this issue.
String generateRandomPassword() {
final byte[] buffer = new byte[24];
random.nextBytes(buffer);
return BaseEncoding.base64Url().omitPadding().encode(buffer); // or base32()
}
**Log traces:**
[2017-03-09T08:45:17.389+0000] [glassfish 4.1] [SEVERE] [] [org.glassfish.jersey.server.ServerRuntime$Responder] [tid: _ThreadID=41 _ThreadName=http-listener-1(1)] [timeMillis: 1489049117389] [levelValue: 1000] [[
An exception has been thrown from an exception mapper class com.oracle.acs.gateway.services.mapper.GeneralExceptionMapper.
java.lang.NoClassDefFoundError: Could not initialize class com.google.common.io.BaseEncoding
at com.oracle.acs.gateway.exception.GeneralExceptionMapperImpl.generateRandomErrorCode(GeneralExceptionMapperImpl.java:134)
at com.oracle.acs.gateway.exception.GeneralExceptionMapperImpl.handleGeneralException(GeneralExceptionMapperImpl.java:85)
......
..
..
Caused by: javax.ejb.TransactionRolledbackLocalException: Exception thrown from bean: java.lang.NoSuchMethodError: com.google.common.base.CharMatcher.ascii()Lcom/google/common/base/CharMatcher;
at com.sun.ejb.containers.EJBContainerTransactionManager.checkExceptionClientTx(EJBContainerTransactionManager.java:665)
at com.sun.ejb.containers.EJBContainerTransactionManager.postInvokeTx(EJBContainerTransactionManager.java:507)
at com.sun.ejb.containers.BaseContainer.postInvokeTx(BaseContainer.java:4566)
at com.sun.ejb.containers.BaseContainer.postInvoke(BaseContainer.java:2074)
... 108 more
Caused by: java.lang.NoSuchMethodError: com.google.common.base.CharMatcher.ascii()Lcom/google/common/base/CharMatcher;
at com.google.common.io.BaseEncoding$Alphabet.<init>(BaseEncoding.java:452)
at com.google.common.io.BaseEncoding$Base64Encoding.<init>(BaseEncoding.java:891)
at com.google.common.io.BaseEncoding.<clinit>(BaseEncoding.java:316)
Looks like repetitive of issue: https://github.com/google/guava/issues/719
but should have been corrected in latest release.
Following is the outcome of mvn dependacy:tree
Not seen any google-common references ...
+- commons-beanutils:commons-beanutils:jar:1.9.3:compile
|  \- commons-collections:commons-collections:jar:3.2.1:compile
+- org.apache.poi:poi:jar:3.16-beta1:compile
|  \- org.apache.commons:commons-collections4:jar:4.1:compile
+- com.google.guava:guava:jar:21.0:compile
+- org.glassfish.jersey.containers:jersey-container-servlet:jar:2.26-b01:provided
|  +- org.glassfish.jersey.containers:jersey-container-servlet-core:jar:2.26-b01:provided
|  +- org.glassfish.jersey.core:jersey-common:jar:2.26-b01:provided
|  |  +- org.glassfish.jersey.bundles.repackaged:jersey-guava:jar:2.26-b01:provided
|  |  \- org.glassfish.hk2:osgi-resource-locator:jar:1.0.1:provided
|  \- javax.ws.rs:javax.ws.rs-api:jar:2.1-m02:provided
I notice the `org.sonatype.oss-parents` is deprecated. Is there any action planed for it?
> Sonatype OSS Parent poms - oss-parents
> This project is no longer active or supported. We suggest to manage parent POM files for your own organization as needed. The POM files from this project no longer work with latest Maven and/or Java versions. I see it from https://github.com/sonatype/oss-parents  From a ten year old paper, there's a [function that approximates the number of items in a bloom filter](https://en.wikipedia.org/wiki/Bloom_filter#Approximating_the_number_of_items_in_a_Bloom_filter).
All it needs is Bloomfilter's `bits.bitSize()`, `bits.bitCount()`, and `numHashFunctions`. I played around with it and found it to be remarkably accurate for large and small, empty and full filters alike. I was seeing accuracy between 2 and 5 9's based on the size of the filters.
I'd be happy to implement it (properly) if needed. I think there is value in this addition, and since it's just a calculation with some internal values, I don't see any major downsides. I suppose there isn't a way to quantify the accuracy of the results, but between Javadoc and a descriptive method name (like in "mightContain") the approximate nature of the result could be clear. Just general data introspection purposes. If committing non-unique elements, it lets you use the same data structure in place of a HyperLogLog for cardinality estimates. This is especially useful if you're using bloom filters to represent subsets of data and combining them - you can get very fast union cardinality estimates in O(1) with a small memory footprint.
It's also just a nice sanity check in general. "yeah, that number looks about right". If you get a chance, play with the snippet I posted - I was really impressed at the accuracy with various sizes and fill percents. Just FYI - I haven't abandoned this, I'm proceeding through the internal process to do this under the corporate CLA. @kluever I've been added to the Amazon CCLA under my email beutlert@amazon.com is this same?
http://cstheory.stackexchange.com/questions/10023/computing-the-approximate-population-of-a-bloom-filter It is the same. Interesting that the conversation there happened 5-9 years after it was published in a paper... but the derived formula is the same anyhow.
By the way, still waiting to get a green light from @kluever on this. I'd argue that the counter suffers from any of the same drawbacks as the formula above - it's still susceptible to collisions, so it's still an approximation. Users needing perfect precision for cardinality shouldn't be using a BloomFilter anyway. From an implementation standpoint, this requires changes to pretty much everything, including serialization (potentially breaking backward compatibility with serialized filters) and would require a change to BitArray::putAll method signature. I would be very surprised if the differences in approximations were anything but negligible. Oh! Sorry about that. I agree that works for most users, although the limitation also extends to situations where the filters are being deserialized. Being a probabilistic data structure, the approximate count is intrinsic to the object the same way mightContain() is, so this would allow the object to be passed around without having to pair it with a count. Glad to see this added - thank you!
For fun @kevinb9n regarding the `ln(1 - k/m)` => `-k/m` substitution - it's just stopping after the first term of the Taylor series expansion for ln. Since `k/m` is constrained to being so close to 0, it's still a very accurate approximation.
If calculating `k` hashes and `m` bits from the given optimal formulas using `p` fpp and `n` expected insertions, the accuracy of the first term Taylor approximation varies almost completely on `n`. At n=100, it's already 99.65% accurate. At n=1000, it's 99.965%, and we get an extra 9 for every order of magnitude n grows. Pretty nifty.  Feature request: a Graphs.reachableNodes() method that has multiple starting points.
It should be more efficient than calling the existing reachableNodes() multiple times. Do you want me to send a CL?  Upgrading Guava to v21 with GWT 2.8, i'm getting the following errors on ImmutableMap recent evolutions while compiling GWT project :
```
[ERROR] Errors in 'com/google/common/collect/super/com/google/common/collect/ImmutableMap.java'
[INFO]       [ERROR] Line 91: Type mismatch: cannot convert from Collector<capture#35-of ? super T & capture#37-of ? super T,capture#39-of ?,Object> to Collector<T,?,ImmutableMap<K,V>>
[INFO]    Tracing compile failure path for type 'com.google.common.collect.ImmutableMap'
[INFO]       [ERROR] Errors in 'com/google/common/collect/super/com/google/common/collect/ImmutableMap.java'
[INFO]          [ERROR] Line 91: Type mismatch: cannot convert from Collector<capture#35-of ? super T & capture#37-of ? super T,capture#39-of ?,Object> to Collector<T,?,ImmutableMap<K,V>>
[INFO]       [ERROR] Errors in 'com/google/common/collect/ImmutableSetMultimap.java'
[INFO]          [ERROR] com.google.common.collect.ImmutableMap cannot be resolved to a type
[INFO]       [ERROR] Errors in 'com/google/common/collect/ImmutableMultimap.java'
[INFO]          [ERROR] com.google.common.collect.ImmutableMap cannot be resolved to a type
[INFO]       [ERROR] Errors in 'com/google/common/collect/AbstractMultimap.java'
[INFO]          [ERROR] com.google.common.collect.Multimaps.Entries cannot be resolved to a type
[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
```
Any ideas to solve this ?  Stopwatch is missing a getter for the start time.
If you're happy with the API change, I can submit a PR.
Cheers Right. Better put, it's missing a feature to get the elapsed time since it was started. Please correct me if I'm wrong @alb-i986, but if starting time is something you're after, then I think you might be better served by something like or based on Java 8's new date library or joda-time.
After all, [if the amount of trouble programmers go through just to program timezones](https://www.youtube.com/watch?v=-5wpm-gesOY) are any indication, then I would suspect that finding the time elapsed between a "starting point" and some point in the future or past (which I assume is what you want to do) is probably harder than one would think. :/ Sorry, my bad. I now understand that `elapsed(Timeunit)` returns the elapsed time since the stopwatch was started.
So what I'm missing is a method (let's call it "partialElapsed") to get the elapsed time between now and the previous call to elapsed (or since started), so that I can write:
sw.start();
do1();
log.debug("do1 took " + sw.partialElapsed(MILLIS) + "ms);
..
doN();
log.debug("doN took " + sw.partialElapsed(MILLIS) + "ms);
log.debug("The whole process took " + sw.elapsed(MILLIS) + "ms);
For example, the stopwatch included in the Google app Clock on Android 6 supports this.
PS: @jbduncan Thanks for the link, funny and useful video :) @kevinb9n that's not even necessary, you can achieve this result fairly easily using the existing Stopwatch API.
Stopwatch stopwatch = Stopwatch.createStarted();
benchmark();
System.out.printf("benchmark() took %d ms.%n", stopwatch.elapsed(TimeUnit.MILLISECONDS));
stopwatch.reset().start();
benchmark();
System.out.printf("benchmark() took %d ms.%n", stopwatch.elapsed(TimeUnit.MILLISECONDS));
stopwatch.reset().start();
...
```  @cpovirk Did you mean to close this or add it to the `22.0` milestone? I _just_ realised that this issue had an associated fix commit. Apologies!  While AbstractTable defines a method valuesSpliterator(), that method does not get called. Instead, the default implementation from AbstractCollection is used.  As part of my work at LinkedIn, I've created a lock-free version of Guava's `BloomFilter` class (technically, a lock-free version of the `BitArray` class inside `BloomFilterStrategies`). **Would Guava upstream be interested in seeing a PR for this change?** The PR would naturally come with extra tests.
### Short overview
Our use-case involves a hundred+ threads doing a total of millions of read QPS on the bloom filter with ~20 QPS of writes. So I wrapped the bloom filter with a read-write lock. This wasn't performant enough though on the read side; after lots of benchmarks and analysis, the root cause was the write lock; even removing the read locks (which of course introduces race conditions, but was done for the sake of a benchmark) made no difference for read path perf... but removing both read _and_ write locks improved read perf greatly (but it would of course be terribly unsafe). My guess is that it was exclusive access to the cache line that stored the lock data that caused excessive CPU cache bus traffic, but I don't have data to back that up.
Replacing the internals of the BitArray so that it used an `AtomicLongArray` for the `data` member along with compare-and-swap usage (plus an `AtomicLong` for the `bitcount` member) improved perf substantially.
This is all on a modern server CPU with 24 logical CPUs (12 cores) + HotSpot Java 8 JVM. Great! I'll send a PR. It might take a bit because:
1. I have a lot of stuff on my plate right now. :)
2. I need to sort out the CLA business.
3. I stripped out all the serialization bits for our `LockFreeBloomFilter` fork; you guys definitely want to keep those so it will require a bit of work. Got the code into shape for a PR. Waiting on internal legal review (part of getting CLA stuff squared away). I'm told this will take about a week. Are you using a Bloom-1 design ([paper](http://www.cise.ufl.edu/~tali/1569342377.pdf), [fix](http://sci-hub.cc/10.1109/TPDS.2014.2378268))? Otherwise you'll run into races that may not be acceptable. However, it requires a slightly different equation per the second paper. @ben-manes I haven't referred to the literature before going down the lock-free path (I probably should have) because my intention was not to create the most optimal implementation (like the one memory access version the paper you cite advocates), but merely a superior one to what's currently in Guava. I erred on the side of: 1) simplicity of implementation, 2) correctness and 3) "good enough" performance.
I'd _love_ to hear your thoughts on the code (once my legal team clears it for publishing).
This change also wasn't the only one that contributed to perf in our fork of the BloomFilter; actually the biggest benefit came from switching away from Murmur3 as the hash function and [using xxHash from the Zero Allocation Hashing project](https://github.com/OpenHFT/Zero-Allocation-Hashing) along with the Kirsch-Mitzenmacher approach exhibited in the MURMUR128_MITZ_32 strategy.
[JMH](http://openjdk.java.net/projects/code-tools/jmh/) benchmarks on the BloomFilter with representative data for our service showed the xxHash approach taking ~93ns for `mightContain` vs ~440ns for the MURMUR128_MITZ_64 strategy that's used by default.
The third change I made (which I very much doubt Guava upstream would like to merge) was to rip out the `Funnel` business, hardcode String as the BloomFilter key (it's the only key type we use) and use a custom `toAsciiBytes` String -> byte[] conversion function [mentioned on this page as the fastest approach.](http://java-performance.info/charset-encoding-decoding-java-78/) I benchmarked various other Charset conversions (including the "unencoded chars" approach Guava uses) and the custom function was consistently 30% faster.
We can get away with that since we know all our keys are ASCII Strings, but Guava can't.
Just in case it wasn't clear, my PR will only contain the lock-free parts (since I doubt the other parts are something upstream is interested in).
The use of allocation surprised me and I think its the dominant cost of Guava's implementation. It makes sense as a very elegant API, but also a poor fit for data structures where performance matters. Usually one builds data structures where the internals bypass elegant APIs because performance matters. So Guava's is more of a good example to learn from for average cases, but not when performance is important.
I agree. I think it's perfectly fine for Guava to aim for a reasonable and sound implementation that works well in a wide variety of cases even if that leaves some perf on the table. When someone really needs lots of perf, it's a great base to start from (Apache v2 FTW); it certainly saved me a ton of time since I didn't have to write everything from scratch.
Though IMO it also makes sense to improve that base perf when possible without impacting the traits you mentioned (generality, API, etc). The lock-free PR I have sitting on my machine is a fairly small diff. It doesn't change the external APIs at all and strictly improves perf. Since common  bloom filters use-cases are write-light and read-heavy and atomic _reads_ (not writes) are free on x86 (and x86-64) because of that architecture's memory model, even the single-threaded use-case won't be negatively affected. And that's without mentioning that a single-threaded use-case for a bloom filter is... rare, at best. Just wanted to drop a note saying that I haven't forgotten about this; my patch is winding its way through our internal legal review. Sorry about the delay folks! I've received all the legal approvals; I plan on sending the PR later today. Posted the PR: https://github.com/google/guava/pull/2761  I have been using Guava version 20.0 and Spring GuavaCacheManager version 4.3.3.RELEASE for caching in my application.
I'm initialising guava cache builder in spring configuration file and using cacheable annotation in cache file.
As per Guava CacheBuilder RemovalListener docs,
> Warning: after invoking this method, do not continue to use this cache
> builder reference; instead use the reference this method returns. At
> runtime, these point to the same instance, but only the returned
> reference has the correct generic type information so as to ensure
> type safety. For best results, use the standard method-chaining idiom
> illustrated in the class documentation above, configuring a builder
> and building your cache in a single statement. Failure to heed this
> advice can result in a ClassCastException being thrown by a cache
> operation at some undefined point in the future.
*I'm using the reference returned by removal listener in spring configuration file.*
*But still is there any possibility of ClassCastException being thrown by a cache operation at some undefined point in the future for the below code?*
***Since here CacheBuilder is created/initialised with removal listener in a single step then at later point Cache build will be lazily initialised at Spring GuavaCacheManager getCache***
Spring configuration file
@configuration
@EnableCaching
public class SpringConfig {
public CacheBuilder<Object, Object> cacheBuilder() {
CacheBuilder<Object, Object> cacheBuilder = CacheBuilder.from("maximumSize=1000,expireAfterAccess=1d").removalListener(addRemovalListener());
return cacheBuilder;
}
@Autowired
private CacheBuilder<Object, Object> cacheBuilder;
public CacheManager cacheManager() {
GuavaCacheManager cacheManager = new GuavaCacheManager();
cacheManager.setCacheBuilder(cacheBuilder);
cacheManager.setAllowNullValues(false);
return cacheManager;
}
private RemovalListener<Object, Object> addRemovalListener() {
return new RemovalListener<Object, Object>() {
public void onRemoval(RemovalNotification<Object, Object> removal) {
if(RemovalCause.EXPLICIT != removal.getCause()) {
try {
String key = (String) removal.getKey();
String val = (String) removal.getValue();
......
......
} catch (Exception e) {
logger.error("Cache RemovalListener Exception [{}]", e.getMessage(), e);
}
}
}
};
}
}
Spring Cache File
@Service
public class SpringCache {
@Autowired
private CacheManager cacheManager;
@Cacheable(cacheManager="cacheManager", key="#p0", cacheNames="cacheKeysMap", sync=true)
public String getKeyFromCache(String key) {
......
......
return value;
}
@CacheEvict(cacheManager="cacheManager", key="#p0", cacheNames="cacheKeysMap")
public void deleteFromCache(String key) {
}
} My only concern is,
My basic tests are working fine.
and building your cache in a single statement for RemovalListener, I'm worried will it have an ClassCastException possibility at some undefined point in future?** My Cache will have key as String and value as CUTOM_OBJECT.
CacheBuilder<Object, Object>
RemovalListener<Object, Object>
RemovalListener logic has type casting,
> String key = (String) removal.getKey();
> CUTOM_OBJECT val = (CUTOM_OBJECT) removal.getValue();
Is that fine?  The Ordering Javadoc says:
> If you are using Java 8, this class is now obsolete (pending a few August 2016 updates). [...] However, at this time we have no plan to deprecate this class.
> In light of the significant enhancements to Comparator in Java 8, the overwhelming majority of usages of Ordering can be written using only built-in JDK APIs.  Because of this, and because it's awkward to have to convert comparators into Ordering instances, Ordering and its methods are planned for deletion.
So, is Ordering deprecated or not?  How urgent is migrating from Ordering to Comparator? @kevinb9n I think, regardless of whether Ordering will be deprecated or not in the future, that the note that says "(pending a few August 2016 updates)" should be amended to prevent confusion. @ronshapiro I think this issue was closed a bit prematurely, because I AFAIK the note in the javadocs about "(pending a few August 2016 updates)" has not been updated or removed yet. :) No worries! Many thanks for opening it again. :) @ronshapiro @cpovirk Many thanks for resolving this! :)  The TOC displayed on all the [Wiki](https://github.com/google/guava/wiki) pages is missing `CaseFormat` under `Strings`:
The linked page contains an entry `CaseFormat` which isn't shown. Don't know what Wiki type this is, but usually they are auto-generated. Weird. Might mean there are more of these.  The [doc comments](https://google.github.io/guava/releases/21.0/api/docs/com/google/common/base/Equivalence.html) for Equivalence state that "A future version of this class will implement BiPredicate<T, T>. In the meantime, to use an equivalence (say, named equivalence) as a bi-predicate, use the method reference equivalence::equivalent."  However, as of Guava 21.0, Equivalence does implement that method.  This section should therefore go away.
I'm not sure whether this was a one-off miss when converting to Java 8, or if there are other similar misses in updating the doc comments.  I have seen that the documentation suggests that the accessor methods on mutable graph throws `ConcurrentModificationException` while iterating through `adjacentNodes()`. I have a sample dfs that removes edges while performing dfs:
```
private Set<EndpointPair<String>> backEdges(MutableGraph<String> g, String root, String current, Set<String> visited,
Set<EndpointPair<String>> backEdges)
{
visited.add(current);
for (String n : g.adjacentNodes(current))
{
if (!visited.contains(n))
{
backEdges(g, current, n, visited, backEdges);
}
else if (!n.equals(root))
{
// Found a back-edge
EndpointPair<String> edge1 = EndpointPair.ordered(current, n);
EndpointPair<String> edge2 = EndpointPair.ordered(n, current);
logger.info("Removing edge {} {}", edge1.nodeU(), edge1.nodeV());
// Remove from graph
g.removeEdge(edge1.nodeU(), edge1.nodeV());
g.removeEdge(edge2.nodeU(), edge2.nodeV());
// Add to result set
backEdges.add(edge1);
backEdges.add(edge2);
}
}
return backEdges;
}
```
A node is removed and immediately the iterator throws exception. Is there a way that this could be avoided though only `removeEdge()` is applied here? Hi @sudharsannr. There are at least two solutions for this unfortunate little problem with the spec of `MutableGraph` that I can think of:
1. In the for-loop, copy the `g.adjacentNodes(current)` into an `ImmutableSet`. This prevents ConcurrentModificationException because the newly-created immutable set is never modified in the for-loop:
for (String n : ImmutableSet.copyOf(g.adjacentNodes(current))) { // copy prevents CME
...
}
```
2. If copying the nodes is too expensive memory- or time-wise for your needs, try _recording_ the edges to remove within the for-loop, and then remove them all after exiting the for-loop. Something like below (I've not run it through a compiler or tested it, so YMMV):
visited.add(current);
List<ImmutableList<String>> edgesToRemove = new ArrayList<>();
for (String n : g.adjacentNodes(current))
{
if (!visited.contains(n))
{
backEdges(g, current, n, visited, backEdges);
}
else if (!n.equals(root))
{
// Found a back-edge
EndpointPair<String> edge1 = EndpointPair.ordered(current, n);
EndpointPair<String> edge2 = EndpointPair.ordered(n, current);
logger.info("Removing edge {} {}", edge1.nodeU(), edge1.nodeV());
// Record to remove from graph later
edgesToRemove.add(ImmutableList.of(edge1.nodeU(), edge1.nodeV()));
edgesToRemove.add(ImmutableList.of(edge2.nodeU(), edge2.nodeV()));
// Add to result set
backEdges.add(edge1);
backEdges.add(edge2);
}
}
// Remove recorded edges from graph now
for (ImmutableList<String> e : edgesToRemove) {
g.removeEdge(e.get(0), e.get(1));
}
return backEdges;
``` Option 1 would work. Option 2 would not work since it is a recursive call and cannot defer removing the edge at the end. My guess is that when edges are removed, successor and predecessors would be affected. Hi @jrtom, apologies, I realise with hindsight that it was strong of me to refer to the CME-throwing behaviour of MutableGraph as a "problem".
What I'd meant to say was, when I first encountered the CME-throwing behaviour of MutableGraph whilst iterating over one and adding new nodes to it in one of my personal projects, I was rather surprised by the CME because I didn't expect it. (I think I experienced this before the very well-written piece on Graph in the wiki was written). However, having thought about it, I understood (and still do understand now) why it throws CME, and your explanation of why it throws CME summarises it quite nicely. :)
Current signature of `Sets.difference` method is
SetView<E> difference(final Set<E> set1, final Set<?> set2)
however, for all usages of `set2` argument everything would work as well if argument was of type `Collection<?>`, without impact on performance for current usages. Why not to make signature less strict?
In my use case, I do following manipulation:
Set<Foo> nonspecialLeftFoos  = Sets.difference(leftFoos ,specialFoos.keySet());
Set<Foo> nonspecialRightFoos = Sets.difference(rightFoos,specialFoos.values());
Thanks for response. > (...) for all usages of set2 argument everything would work as well if argument was of type Collection<?>, without impact on performance for current usages.
`Collection.contains()`, which `Sets.difference()` uses a lot, is _O(1)_ for hash based sets and _O(log(n))_ for tree based sets. You can't guarantee anything below _O(n)_ in general (`List`, `Queue` and so on). Iterating over `Sets.difference()` would be _O(n^2)_ in that case - that's not something you want - it's about _O(n)_ now. @perceptron8 agree, I talked about not worsening performance for sets since no other type could be passed so far. For other types of collections the performance would certainly be worse. This could be emphasized in javadoc in similar manner as for example in the note in `Sets.intersection` method's javadoc.
Anyway, if you find proposed change too risky and tend to be misused, I am fine with any of workarounds, of which the @lowasser 's one seems to be the best readable. > If you really want that behavior you can also always get it with
Sets.filter(set, not(in(Collection))).
Or, if you're on Java 8 and a fan of lambdas: `Sets.filter(set, e -> !collection.contains(e))`.  E.g. there are:
<pre lang="java">
LoadingCache<K, V> cache = CacheBuilder.newBuilder()
.refreshAfterWrite(w, MINUTES)
.build(new CacheLoader<K, V>() {
public V load(K key) throws Exception {
}
});
</pre>
It would be great if it will be possible to make `cache` return expired value while recalculating. @lowasser. I had some more experiments and found that I have no idea how to make cache periodically refresh values (without any extra code). The main idea is the possibility to get quite fresh values instantly at any time. Using only `refreshAfterWrite` I have to do some manual polling, otherwise I could get old values or a noticeable delay (in combination with `expireAfterWrite`) after a long silence period. I see. The issue in it's current statement is exhausted.  Introduce a Collector to ease merging of Maps with java stream API.
Given (random Maps implementations used to ensure collector is generic):
HashMap<String, Integer> foo = new LinkedHashMap<>();
foo.put("one", 1);
foo.put("two", 2);
NavigableMap<String, Integer> bar = new TreeMap<>();
bar.put("three", 3);
bar.put("four", 4);
Stream<Map<String, Integer>> stream = ImmutableSet.of(foo, bar).stream();
```
ImmutableMap<String, Integer> collectedTheOldWay = stream
.map(Map::entrySet)
.flatMap(Set::stream)
.collect(ImmutableMap.toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));
```
can now be done with:
ImmutableMap<String, Integer> collected = stream.collect(ImmutableMap.mergeMapsCollector());
``` Hi,
> For this feature, I'd wonder why the maps were created separately in the first place?
That is just for the example.
> Do people actually have an unbounded number of maps, or do they have a fixed number of maps that need to be combined?
Of course, the actual purpose is for an unbounded number of maps. For a fixed number of maps, your code is better.
My cases are usually like the Map is generated by a `Stream#map` call. Let's take a new example (imperative/no-stream-style first):
ImmutableMap.Builder<MyKey, MyValue> allKnownValues = ImmutableMap.builder();
Bar bar = this.convertFooToBar(foo);
ImmutableMap<MyKey, MyValue> mapForFoo = bar.getTheMap();
allKnownValues.putAll(mapForFoo);
}
return allKnownValues.build();
```
With the stream API, should be:
.map(Bar::getTheMap) // gives the Stream<Map<MyKey, MyValue>>
.map(Map::entrySet)
.flatMap(Set::stream)
.collect(ImmutableMap.toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));
```
With the suggested new API:
.map(Bar::getTheMap)
.collect(ImmutableMap.mergeMapsCollector());
```
I think this kind of creating a Map by dynamically filling it with dynamically computed maps is frequent (hence, the `ImmutableMap.Builder#putAll(Map)`). I won't discuss the need for this API because I think Guava maintainers have a much better point of view/experience for that than mine. My experience is just that people will favor 1st code (imperative style) to 2nd code which is too verbose and quite cryptic for the non-stream-API-fluent-developer and I think the 3rd one is much more functional-style (ie: declarative about the expected result), but it's just based on nothing more than my day-to-day experience.
Also, maybe `mergeMaps` is not the suitable term but I'm not a native english-speaker) and a `mergeOperator` could be passed.  Let's say I want to convert a list `list` to an immutable sorted set `set`:
List<Integer> list; // Source
ImmutableSortedSet<Integer> set; // Target
```
When creating a sorted, immutable copy of an iterable or iterator over `Comparable`s, I have the option to leave the ordering implicit:
set = ImmutableSortedSet.copyOf(list);
```
For the streaming API, I would love to see the same option:
// Currently needed:
set = list.stream().collect(toImmutableSortedSet(naturalOrder()));
// What I want to use:
set = list.stream().collect(toImmutableSortedSet());
``` I also would like to have the `SortedSet` with natural ordering as default when no parameter is passed. I had to create a custom collector to have this functionality.
public static <E extends Comparable<E>> Collector<E, ?, ImmutableSortedSet<E>> toImmutableSortedSet() {
return ImmutableSortedSet.toImmutableSortedSet(Ordering.natural());
}
```  i.e., returns true if a parameter is annotated with @Nullable
*or* @CheckForNull. Both annotations mean "this can be null".
fixes #2656 CLA signed by Addepar, Inc. Hi @bdworth, try replying "I signed it!" without the quotes. It doesn't seem @googlebot recognised the fact that you signed the CLA (it should only have took it a few seconds to run if it did AFAICR), so entering that phrase should get it to check your CLA status and respond back. I signed it! How strange - @googlebot is still not responding...
@cpovirk, I'm not sure if you're the right person to ask, but do you know what @bdworth should do next? I didn't sign anything -- I just used that phrase since I was told googlebot wanted that.
My CEO signed a corporate CLA on behalf of Addepar. I should be on the list of contributors in the CLA he signed. Not posting the email address for that group here since this page is public. Thanks. This seems like an unnecessary amount of overhead for a simple four-line change (the rest are tests), but it'll be good to have in place. Any luck? *ping*? New CLA resubmitted.  Currently `Stopwatch` is final which makes it impossible to mock it with mockito to unit test classes using it.
It would be great to make `Stopwatch` non final to avoid this problem.
Thanks! The excellent question of @lowasser aside, as of version 2.1.0, Mockito has incubating support for [mocking final types, enums and final methods](https://static.javadoc.io/org.mockito/mockito-core/2.7.0/org/mockito/Mockito.html#39). We're successfully using this in our project. @lowasser Thanks for your question. It is probably possible to mock Ticker for tests, but this makes tests dependent on internals of Stopwatch implementation - thing that we are trying to avoid.
@Stephan202 using newer Mockito is probably an option, but unfortunately there are situations when this is not possible or diffigult. E.g. current version of spring boot test utils requires older mockito. Well, ideally in unit test we would like to make sure that our code called start/stop/etc. Not that Ticker has moved through some number of ticks. @lowasser I ran into the same issue as @mar-kolya reports. In a unit test, I want to verify that my code called `Stopwatch.elapsed`, but instead had to mock `Ticker` and then verify its `read()` was called X+1 number of times (because Stopwatch calls it when it's started). Not the end of the world, but if Stopwatch interacted with ticker in other places, my test would depend on those internals. I think you can use PowerMockito to mock the final class. Everything else you can still use Mockito to setup and verify expectation.  `NullPointerTester` has `ignore()` to ignore methods, but there's no equivalent method for ignoring constructors.
This is easy to work around by calling `testConstructor()` on a set of filtered constructors. But it would be nice if core Guava included a way to ignore constructors before calling `testAllPublicConstructors()` or `testConstructors()`.  I was surprised to learn that `ContiguousSet.asList()` returns an `ImmutableList` which copies the discrete domain values into a new array:
```
Exception in thread "main" java.lang.OutOfMemoryError: Requested array size exceeds VM limit
at com.google.common.collect.ImmutableCollection.toArray(ImmutableCollection.java:186)
at com.google.common.collect.ImmutableSet.createAsList(ImmutableSet.java:371)
at com.google.common.collect.ImmutableSet.asList(ImmutableSet.java:367)
```
Can `ContiguousSet.asList()` be changed to return a subclass of `ImmutableList` which computes the values as requested instead so that a `ContiguousSet` can be viewed as a `List` to be used with methods that act on lists? Hi @lowasser, what about Eclipse Collection's [`Interval`](http://www.eclipse.org/collections/javadoc/8.0.0/org/eclipse/collections/impl/list/Interval.html)?
AFAICT, it's somewhat similar to `ContiguousSet`, in that they both are lazy views over a "range" of comparable objects, one major difference being that `Interval` implements `List<Integer>` and `RandomAccess` (which makes it more similar to `ContiguousSet.asList()` API-wise), whereas `ContiguousSet` is more generic (it can work on any generic type rather than just `Integer`).
English, _s'il vous plat_. :wink:  When compiling code that depends on Guava 21.0, [Edit: I mistakenly said 20.0 originally] using Maven, I get many warning messages like this:
> Cannot find annotation method 'value()' in type 'com.google.errorprone.annotations.CompatibleWith': class file for com.google.errorprone.annotations.CompatibleWith not found
I do not use the errorprone library in my code, so this error message is due to its use by Guava.
Obviously, these are only warning messages and are not critical.
These warnings are happening even in some pretty simple packages where there are no exotic maven plugins.
The warnings happen during the "default-compile" step from maven-compiler-plugin.  I've tried version 3.3 and 3.6 of that plugin.
The warnings appear even if I set `<showWarnings>false</showWarnings>`
Ok.  So this is related to annotation processors of some basic sort.  My standard build involves this:
```xml
<build>
<plugins>
<plugin>
<groupId>org.apache.maven.plugins</groupId>
<artifactId>maven-compiler-plugin</artifactId>
<version>3.3</version>
<configuration>
<source>1.8</source>
<target>1.8</target>
<compilerArgs>
<arg>-Xlint:all</arg>
<arg>-Xlint:-serial</arg>
</compilerArgs>
<showWarnings>true</showWarnings>
<showDeprecation>true</showDeprecation>
</configuration>
</plugin>
</plugins>
</build>
```
Then 9 identical warnings appear if my java code contains one single line like this:
`ImmutableTable.Builder<?,?,?> builder = ImmutableTable.builder();`
Again, not a bug in the program operation, just an annoying set of warning messages. We ran into this attempting to upgrade the `jdbi3` project to Guava 21:
https://github.com/jdbi/jdbi/pull/697
We also don't do anything super fancy with Maven plugins, but we do attempt to set "warnings as errors" everywhere.  That said, despite being logged at `ERROR` level, it doesn't fail the build.
```
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.5.1:
testCompile (default-testCompile) on project jdbi3-sqlobject: Compilation failure
[ERROR] /home/travis/.m2/repository/com/google/guava/guava/21.0/guava-21.0.jar(com/google/common/collect/Multimap.class):
warning: Cannot find annotation method 'value()' in type 'CompatibleWith':
class file for com.google.errorprone.annotations.CompatibleWith not found
``` No, sorry, an earlier version of this comment incorrectly stated the build failed.
The actual problem is that the javac output all gets logged at the maximum error level -- so the `WARNING` that this emits will be represented as an `ERROR` if there are *other* build errors, which is confusing.  Once you fix the other unrelated build errors this message then gets downgraded to a `WARNING`.  So it does not actually break out build, but it does introduce warnings -- which as soon as "warnings as errors" gets fixed (someday :crossed_fingers:) it will then actually fail the build I am also seeing this, on a standard `javac -Xlint -Werror` build with `ant`.
The messages are
```
[javac] .../guava.jar(com/google/common/collect/Multiset.class): warning: Cannot find annotation method 'value()' in type 'CompatibleWith'
[javac] error: warnings found and -Werror specified
```
Because we want to use `-Werror`, this breaks our build and prevents us from upgrading Guava. @PhilippWendler thanks for trying javac.  Which JDK version is it?
I have found that I can eliminate the warning message in a Maven build by using this flag for the `maven-compiler-plugin`:  `<forceJavacCompilerUse>true</forceJavacCompilerUse>`.   That should make Maven use the `javac` command in my jdk, which is 1.8.0_66.   I don't exactly understand why that removes the warning. I tested with javac 1.8.0_111 from OpenJDK. ^ And if you declare that dependency `<scope>provided</scope>`, then it shouldn't end up in your final aggregate build artifact (WAR, Uber JAR, etc.), meaning there should be no downside to doing so. You should be able to reproduce the problem in branch `guava21` of [sosy-lab/java-common-lib](https://github.com/sosy-lab/java-common-lib). You can start a build with `javac` with `ant clean build-project`. The definition of the ant target that calls `javac` is in `build/build-compile.xml`, you can see the compiler options there.
The problem is reproducible with this branch on AppVeyor ([log](https://ci.appveyor.com/project/PhilippWendler/java-common-lib/build/build%2014%20guava21)) and Travis ([log](https://travis-ci.org/sosy-lab/java-common-lib/jobs/195317529)).
Btw, we are even using error-prone already (though I disabled it in that branch for easier debugging) and want to upgrade to 2.0.15 at some point anyway, but I think that it would still be good if Guava would not have this problem.
The Eclipse Java Compiler builds our project just fine (`ant clean build-project-ecj`). @cpovirk  To reproduce the problem in Maven you must use *both* `Xlint` and `showWarnings` or `  showDeprecation`.   @PhilippWendler did something similar with `javac -Xlint -Werror`.  So it may be that the problem is related to `lint`.
You can then reproduce it with a project containing one single java class like this:
private ImmutableTable.Builder table = ImmutableTable.builder();
}
```` We are also experiencing this issue.  The noise makes it hard to want to push Guava 21 forward through all our projects. Any chance of a 21.1 release?  Or is 22.0 coming soon? > Does the workaround work OK?
Yes, it does work.  However I don't think you should expect that everyone will go to github and search this issue.
To me personally this definitely seems like a defect large enough to warrant a patch release.  It causes everyone who may treat warnings as errors to have to either search for this obscure issue, or to modify their projects in a way that is not reasonable (you should be able to reasonably treat warnings aggressively as external libraries should not be causing compiler warnings). I'm using guava 22.0
I tried your workaround by adding
```xml
<groupId>com.google.errorprone</groupId>
<artifactId>error_prone_annotations</artifactId>
<version>2.0.15</version>
```
I have a lot of warnings before and after applying the workaround like this
Compile with -strict or with -logLevel set to TRACE or DEBUG to see all errors.
Computing all possible rebind results for 'com.google.gwt.useragent.client.UserAgentAsserter'
Rebinding com.google.gwt.useragent.client.UserAgentAsserter
Checking rule <generate-with class='com.google.web.bindery.requestfactory.gwt.rebind.RequestFactoryGenerator'/>
[WARN] Unknown type 'com.google.web.bindery.requestfactory.shared.RequestFactory' specified in deferred binding rule
Checking rule <generate-with class='com.google.web.bindery.requestfactory.gwt.rebind.RequestFactoryEditorDriverGenerator'/>
[WARN] Unknown type 'com.google.web.bindery.requestfactory.gwt.client.RequestFactoryEditorDriver' specified in deferred binding rule
Checking rule <generate-with class='com.google.gwt.editor.rebind.SimpleBeanEditorDriverGenerator'/>
[WARN] Detected warnings related to 'com.google.gwt.editor.client.SimpleBeanEditorDriver'.   Are validation-api-<version>.jar and validation-api-<version>-sources.jar on the classpath?
Specify -logLevel DEBUG to see all errors.
[WARN] Unknown type 'com.google.gwt.editor.client.SimpleBeanEditorDriver' specified in deferred binding rule
Rebinding com.google.gwt.useragent.client.UserAgentAsserter
Checking rule <generate-with class='com.google.web.bindery.requestfactory.gwt.rebind.RequestFactoryGenerator'/>
[WARN] Unknown type 'com.google.web.bindery.requestfactory.shared.RequestFactory' specified in deferred binding rule
Checking rule <generate-with class='com.google.web.bindery.requestfactory.gwt.rebind.RequestFactoryEditorDriverGenerator'/>
[WARN] Unknown type 'com.google.web.bindery.requestfactory.gwt.client.RequestFactoryEditorDriver' specified in deferred binding rule
Computing all possible rebind results for 'com.google.gwt.user.client.DocumentModeAsserter'
Rebinding com.google.gwt.user.client.DocumentModeAsserter
Checking rule <generate-with class='com.google.web.bindery.requestfactory.gwt.rebind.RequestFactoryGenerator'/>
[WARN] Unknown type 'com.google.web.bindery.requestfactory.shared.RequestFactory' specified in deferred binding rule
Checking rule <generate-with class='com.google.web.bindery.requestfactory.gwt.rebind.RequestFactoryEditorDriverGenerator'/>
[WARN] Unknown type 'com.google.web.bindery.requestfactory.gwt.client.RequestFactoryEditorDriver' specified in deferred binding rule
Rebinding com.google.gwt.user.client.DocumentModeAsserter
Checking rule <generate-with class='com.google.web.bindery.requestfactory.gwt.rebind.RequestFactoryGenerator'/>
[WARN] Unknown type 'com.google.web.bindery.requestfactory.shared.RequestFactory' specified in deferred binding rule
Checking rule <generate-with class='com.google.web.bindery.requestfactory.gwt.rebind.RequestFactoryEditorDriverGenerator'/>
[WARN] Unknown type 'com.google.web.bindery.requestfactory.gwt.client.RequestFactoryEditorDriver' specified in deferred binding rule
Computing all possible rebind results for 'com.google.gwt.logging.client.LogConfiguration
The first thing I don't understand is: what exactly is trying to call a method on an annotation that isn't included in the classpath? Secondly, how does that thing (whatever it is) _even know_ that the annotation has the `value()` method, if the annotation class is not on the classpath?
As was [recently cleared up](https://stackoverflow.com/a/46882631/421049) on one of my recent [Stack Overflow questions](https://stackoverflow.com/q/45596949/421049) (involving this same situation), it appears that if an annotation with a runtime retention policy is attempted to be accessed at runtime via reflection, yet that annotation is not present on the classpath, the JDK _should silently ignore the annotation_. (See also this [related Stack Overflow answer](https://stackoverflow.com/a/3568041/421049).) So if missing annotations "just disappear" at runtime, how is this "thing" finding it and trying to call its `valud()` method --- or even knowing that it has a `value()` method?
Yes, I understand that the tricky part here is that the compiler isn't trying to access the class at runtime. But in a way that makes it even more mysterious how it even knows that the annotation has a `value()` method, if that annotation's class is not present at compile time. And why is this lint tool or whatever trying to call that method in the first place?
I might have mentioned I'm probing this in depth, not to criticize Guava, but to determine the best thing to do in our own public Java library. I'm not sure that the best response is to say, "OK, we'll just force all users of our library to download several dependencies that they don't need to actually _use_ our library" just because of a somewhat obscure use case in which it's not even clear that `javac` is doing the right thing.
As you point out, @enwired could have worked around this problem simply by adding an explicit dependency to `error_prone_annotations`. Guava's "solution" is to basically force @enwired (and everybody else) to include this dependency --- along with several other dependencies, the absence of which were not causing _anybody_ problems that we know of.
Thanks for discussing this with me! As the original submitter of this bug, I'll add my two cents.
I think that there is something fishy about the fact that javac reports compiler warnings about code that is not part of the code being compiled.  I no longer think this is a bug of guava.  The change made in the guava pom file seems like a work-around for a deficiency in javac or in java language specification related to annotations.
I wish there were some way to avoid forcing me to include a dependency on errorprone.  This particular library doesn't bother me because it is small and useful.  But the general principal that could lead to other libraries becoming forced inclusions in the future does bother me.
Perhaps javac could implement an additional 'SuppressWarnings' directive for this case.  But I'm not going to file a request for that myself.  I have a TreeMultiSet as a member of the singleton object. When I clear the set using clear(), it doesn't clear any.
```
class Campaign {
private static Campaign singleton;
private TreeMultiset<Item> items;
public Campaign() {
items = TreeMultiSet.create();
}
public void destroy() {
items.clear();
}
public void setItem(Item item) {
items.add(item);
}
public static Campaign getSingleton() {
if (singleton == null) {
synchronized (Campaign.class) {
if (singleton == null) {
singleton = new Campaign();
}
}
}
return singleton;
}
}
Item item = new Item();
Campaign.getSingleton().setItem(item);
Campaign.getSingleton().destroy(); //its not clearing the set. no errors either.
``` Hi Rohit5ram,
I tested your method,changed the Item class to integer and  my test result turned out the clear() method is ok.
Using this on Android 4.2.2
Item extends some ParentItem and implements Comparable,Parcelable
```
public class Item extends ParentItem implements Comparable<Item>, Parcelable {
public int priority;
public String id;
public int compareTo(@NonNull Item item) {
int value = item.priority.compareTo(this.priority);
return (value != 0) ? value : 1; //to insert items with same priority.else equal priority items are overwritten
}
}
```
In Campaign class I filter the set a lot many times.
```
Collections2.filter(items, new Predicate<Item>() {
public boolean apply(Item item) {
return item.id.equals("MAIN");
}
} );
```
Anything to do with these ?
You `compareTo` is seriously broken, you really shouldn't expect any collection using it to work:
> The implementor must ensure sgn(x.compareTo(y)) == -sgn(y.compareTo(x)) for all x and y.
Is this something which you're at liberty to talk about? @jbduncan greatest-to-least ordering Hi @rohit5ram, since you're on Android, I presume you cannot use Java 8 features?
If so, I think you can fix your problem if you simplify your `compareTo` implementation from
int value = item.priority.compareTo(this.priority);
return (value != 0) ? value : 1;
```
to
return item.priority.compareTo(this.priority);
```
I believe this should compare your `Item`s by their `priority` in reverse order (so greatest-to-least order), but I've not tested it, so please don't hold me to it. :)
My solution assumes you're _only_ interested in comparing `Item`s by their `priority`.
If you also want to compare by `id` and the other fields in your `Item` class, then you'll need something different (which I can help you with again).
The issue is with clear(). I am able to insert in greatest-to-least order with duplicates as well using the existing code. I have given heads up on my implementation so that it can help you to find a reason on why isn't it able to clear the set.
I assumed TreeMultiSet take duplicates. But with this
`item.priority.compareTo(this.priority);`
its replacing the old object of same priority
Can you please help ? I couldn't have said it any better myself, regarding @lowasser's comments on Multisets and comparators!
@rohit5ram, does this answer all of your concerns for now? :)
Or is there anything else we can do to help you with understanding/using TreeMultiset and/or solving your overall problem (like comparing by multiple fields e.g. `priority` and then `id` and then your class's other fields)? @jbduncan @lowasser The requirement is that every object is unique(pre-known) and should be sorted based on priority. In order to sort it at the time of insertion, I chose TreeMultiSet. I feel the data structure should not be of set.
The best-suited data structure for this would be an ArrayList. So I changed the code as below.
`ArrayList<CampaignFileItem> campaignFileItems;
Collections.sort(campaignFileItems)
`
`return item.priority.compareTo(this.priority);`
Please suggest if you feel on adding anything or else you can close the issue. Thanks a lot !
Hi @rohit5ram, there are two things I can think of which may allow you to improve your code.
1. I'd consider moving your current `Item.compareTo` implementation into it's own Ordering comparator, like so:
private static final Ordering<Item> ITEM_BY_PRIORITY_REVERSE_ORDERING =
new Ordering<Item>() {
public int compare(Item left, Item right) {
Preconditions.checkNotNull(left, "left");
Preconditions.checkNotNull(right, "right");
return Ints.compare(left.priority, right.priority);
}
}.reverse();
```
The advantage of this is that you can implement `Item.compareTo` separately in terms of _all_ its fields rather than just `priority`, which is what future readers of your code would expect `compareTo` to do, I imagine.
2. I'd then consider replacing `ArrayList<CampaignFileItem> campaignFileItems = ... /* your unsorted items */; Collections.sort(campaignFileItems);` with
ImmutableList<Item> campaignFileItems = ITEM_BY_PRIORITY_REVERSE_ORDERING.immutableSortedCopy(... /* your unsorted items */);
```
The advantage of this is you end up with an immutable data structure, which is easier to reason about as you can never accidentally change it (assuming `Item` itself is immutable, i.e. all its fields are `final` and they are of primitive types and/or object types which themselves cannot be mutated e.g. `String`).  Sometimes I want to check if more than one String is null or empty, but the method in the API only allows one String as argument.
Tell me what you guys think about it:
``` java
static boolean stringIsNullOrEmpty(@Nullable String... string) {
for (int i = 0; i < string.length; i++) {
if (string[i] == null || string[i].length() == 0) {
return true;
}
}
return false;
}
``` @kevinb9n I just thought it would be less verbose for those who want to call this method and use a new resource instead of `Strings.isNullOrEmpty(first) || Strings.isNullOrEmpty(second)...`
But I agree with you, I had not thought about the stack trace before opening the issue. If you want such a functionality, you can always use the following:
Stream<String> strings = ... ;
boolean anyNullOrEmpty = strings.anyMatch(Strings::isNullOrEmpty);
If you don't use streams (because of Java 7- or else), you can use:
Predicate<String> isNullOrEmptyPredicate = new Predicate<String>() { public boolean apply(String s) { return Strings.isNullOrEmpty(s); }  }
String[] strings = ... ;
boolean anyNullOrEmpty = FluentIterable.from(strings).anyMatch(isNullOrEmptyPredicate); Nice, @ogregoire thank you.  updated copyright - filled in template I signed it! Hi @bepahol, I'm neither on the Guava team nor a lawyer, but I'm under the impression one isn't meant to replace the brackets _within the Apache license itself_ with a copyright year - just those in source files which themselves have an abbreviated Apache license header. @jbduncan - ahhhh ok. Makes sense, thank you.  This is kind of a meta issue.
Project contributors' e-mail addresses, which were originally displayed in an incomplete/"obfuscated" form in Google Code issues as per the authors' privacy settings, have become fully visible after migration of the issues to GitHub ([random example](https://github.com/google/guava/issues/6)).
> Original issue created by [FULL E-MAIL ADDRESS] on [TIMESTAMP]
This does not affect authors who had their username displayed instead (though it might be simple to derive their e-mail addresses from that, but that's not the point here).
Why did this happen? Why did anyone think it would be a good idea to expose people's e-mail addresses, and against their accounts' privacy settings stating otherwise?
While damange has been done already (Hello, spam!), I request the full addresses (or at least mine) to be removed from GitHub issues. (People can't do this on their own as the comments were posted by @gissuebot.)
Due to this alarming incident I feel I should refrain from contributing to Google projects for the time being. I consider this a serious breach of trust. Thanks, Colin.
Apologies accepted.  ReverseConverter, ConverterComposition, & FunctionBasedConverter classes implement Serializable without transient/serialized member variables I signed the CLA.
lowasser - it's in response to this: http://cwe.mitre.org/data/definitions/594.html & squid:S1948
"Fields in a Serializable class must themselves be either Serializable or transient even if the class is never explicitly serialized or deserialized. That's because under load, most J2EE application frameworks flush objects to disk, and an allegedly Serializable object with non-transient, non-serializable data members could cause program crashes, and open the door to attackers."
Contributor License Agreement (CLA),I signed it! Understood - if you're fine with this, let me close the pull request.
Thanks so much for the speedy response.  One of the things I miss most when switching from `FluentIterable` to streams is a `filter` method that takes a `Class<T>` argument and returns a `Stream<T>`. Maybe Guava could provide a utility for this?
Doing it manually like `stream.filter(o -> o instanceof MyClass).map(o -> (MyClass)o)` involves having to specify `MyClass` twice and is not safe against accidental modifications of only the latter operation. Furthermore I prefer to avoid manual casts where possible because someone reading the code would always need to ask themselves whether the cast is actually safe.
I see two ways a utility method could be done:
- A method `<T> Stream<T> filter(Stream<? extends T> stream, Class<T> cls)`. Unfortunately this breaks the fluentness.
- A method `<T> Function<? extends T, Stream<T>> filter(Class<T> cls)` which could be used with `Stream.flatMap`. Unfortunately, this adds extra object allocations.
I am not sure which of these would be better, partially because I am unsure what kind of guarantees and optimizations might be lost when using the `flatMap` approach (given that using `flapMap` makes it impossible to use any information about the size of the input stream, whereas with a combination of `map` and `filter` it is still knowable that the resulting size is at most the size of the input stream). This is one of the reason why I think it would be beneficial for Guava to add it instead of just implementing it myself. @PhilippWendler , you can also use
stream.filter(MyClass.class::isInstance).map(MyClass.class::cast)
I admit it still duplicates `MyClass` but at least is less explicit. I usually format it on single line even if every element of fluent chain is otherwise on its own line. An other approach is to define the function
public static <S, T extends S> Function<S, Stream<T>> subclasses(Class<T> clazz) {clazz) {
return x -> clazz.isInstance(x) ? Stream.of(clazz.cast(x)) : Stream.empty();
}
```
and then use `stream.flatMap(subclasses(MyClass.class)`.  yeah, the overhead is very `tiny`
but how does this sound ? LOL, you mean manually do the inlining.
IdentityHashMap, I just felt this new class never gets used.   Pls make ListIterator impl used here com.google.common.collect.Lists.ReverseList#listIterator a separate public class and/or provide static method to create it somewhere.
Now I can reverse list itself but not listIterator @guai Can you explain why you want this static method to be exposed? Have you already considered `Lists.reverse(theList).listIterator()`? If so, can you explain why it doesn't meet your needs? That's exactly it. I have some API method returning ListIterator and not list itself. And then I need to iterate it in reverse order. Actually wrap it in reverse iterator and pass to another already existing class which accepts iterator. ListIterator is itself an iterator. So this Reverseing anonymous class from ReverseList#listIterator does exactly what I need.  Of course I can do it once again myself, but its already there hidden. I think expose it is a good idea @lowasser, I have the control. And I already did it. But my rule of thumb when I deal with collections is to check if there something already done in guava. In this case it is, but hidden.
Is there any smell in code that returns a ListIterator instead of List which I'm not aware of?
If your API were to return `Stream`, then that would be a little bit better because one could then perform functional operations like `map` and `filter` easily. However, in this case it doesn't solve the problem that you need to reverse it, as Streams can only be traversed once like {List}Iterators.
In this case, if you could make this API of yours return a `List`, then that would allow you to create your own "reverse view" class and solve your problem efficiently. This is because (1) lists have a finite number of elements that you can query with `size()`, and (2) you can easily access elements in a list in reverse order using `get(size() - index + 1)` (as shown in Lists.ReverseList#reverseIndex) without putting them into a new list.
And since Guava already provides a reverse-view class for lists via  `Lists.reverse`, you don't even need to implement it yourself. Thus, if you can somehow make your API return a `List`, you can then easily write `Lists.reverse(yourApi()).iterator()` and pass the resulting iterator to your other API, solving your problem efficiently both memory- and time-wise.
I hope this helps. @jbduncan, but ListIterator doesn't have to be backed by a list. Its just something traversable in both directions. API may do something more than just be a list, it may (I dunno) notify some other services about content being iterated etc.
To implement a list is more of a trouble. And in this case one should implement ListIterator anyway. To return custom ListIterator looks quite reasonable to me.
> but ListIterator doesn't have to be backed by a list.
You're right, it doesn't.
But if it isn't backed by a list, then that would surprise maintainers in the future, wouldn't it? I'd argue that misusing `ListIterator` like this makes this API harder to understand and use.
Is this API something you have control over? If so, I'd encourage you to replace its return type with a custom interface that has whichever methods from `ListIterator` that you need.
If not, then I think the most reasonable solution would be something like,
ListIterator<T> listIterator = theListIteratorReturningApi();
Iterator<T> reverseIterator = Lists.reverse(ImmutableList.copyOf(listIterator)).iterator();
theReverseIteratorAcceptingApi(reverseIterator);
```
> To return custom ListIterator looks quite reasonable to me.
Please correct me if I missed something, but by my understanding (and [@lowasser's](https://github.com/google/guava/issues/2706#issuecomment-271952523) apparently), it's not possible to implement an efficient reverse-view of a `ListIterator` unless it's backed by a list, because the reverse-view needs to call `backingList.size()` to implement `nextIndex()` and `previousIndex()` in O(1) time. @lowasser summarised it nicely for me. :) Ok then. Gone inventing the wheels :(  In the [new docs for `Ordering#greatestOf()`](http://google.github.io/guava/releases/21.0-rc2/api/docs/com/google/common/collect/Ordering.html#greatestOf-java.lang.Iterable-int-), there's a hint for Java 8 users:
> Use `Streams.stream(iterable).collect(Comparators.greatest(k, thisComparator))` instead.
Yeah, well, [`Comparators`](http://google.github.io/guava/releases/21.0-rc2/api/docs/com/google/common/collect/Comparators.html) doesn't have `Comparators.greatest()`, does it? Am I missing an obvious method on `Stream` that would do the right thing? Ah, good, thank you!
During the day I took a look at the Ordering implementation and it does a
full sort on the data, anyway :(. For that
ImmutableList.of("a", "b", "c", "d", "e", "f")
.stream()
.sorted(Comparator.comparing(str -> str.toString()))
.limit(5)
.collect(Collectors.toList());
might be good enough. I hoped to see a O(n) solution.
EDIT: Yes, I'm blind. The main line is O(n). Soooooo, how busy are you on a scale from 1 to 10? Guava needs your sweet, sweet code with `Ordering#greatestOf()`... Thank you. Doesn't matter when the code is there, before 22 lands would be nice.
I really appreciate what you guys are doing, keep it up!  Is there a way to invalidate an entry without causing removal listeners to be triggered?
I want the removal listener to execute when an entry expires after a certain amount of time, not when it is invalidated manually.
Thanks.  Indeed. Give me some time, please. I need to collect my thoughts.
You are right that keyFunction is equally useful as countFunction. I was concerned about the similarity of
* `toImmutableMap(Function keyFunction, Function valueFunction)` to
* `toImmutableMultiset(Function elementFunction, ToIntFunction countFunction)`.
The former one throws if there is at least one duplicate key mapping. The latter uses implicit, although obvious "mergeFunction" (addAll). This is fully described in javadoc, which I missed. No more confusion probably.
`Multisets.toMultiset` with `Supplier` looks good too (as good as already existing `Multimaps.toMultimap`).
I perceive no natural-order collectors as a design decision as every ImmutableSorted* collector requires explicit Comparator. That's consistent and clear. I can live with `naturalOrder()`.
In short, proposed API seems appropriate.
I keep my fingers crossed for a positive result of the review! ;) Almost there? See https://github.com/google/guava/commit/6df8b3ca1d1d6b2dfe3aff0316079da61937eef9#commitcomment-20466808 - and don't kill me, please.
It's very nice that you decided to expose these Collectors. Thank you again! @lowasser Could you, please, check above? It's just about renaming (and consistency). I can't wait to mark this as resolved. @lowasser I think this can be closed because of 15c2b77. @lowasser I think that there is still one thing missing: wildcards. I came to this today, when I tried to replace my own implementation with delegation to `Multisets.toMultiset`. I wish I had noticed this before.
```
public static <T, E, M extends Multiset<E>> Collector<T, ?, M> toMultiset(
Function<T, E> elementFunction,
ToIntFunction<T> countFunction,
Supplier<M> multisetSupplier
)
```
one would expect
```
public static <T, E, M extends Multiset<E>> Collector<T, ?, M> toMultiset(
Function<? super T, ? extends E> elementFunction,
ToIntFunction<? super T> countFunction,
Supplier<M> multisetSupplier
)
```
See `Mutlimaps.toMultimap` which is similar but correct. @cpovirk Well, it's still inconsistent with [ImmutableMultiset.toImmutableMultiset(Function, ToIntFunction)](https://google.github.io/guava/releases/22.0/api/docs/com/google/common/collect/ImmutableMultiset.html#toImmutableMultiset-java.util.function.Function-java.util.function.ToIntFunction-). Does it have to be? Please, please, just use PECS. It is not only more flexible but also more idiomatic. @cpovirk Check [ImmutableSortedMultiset.toImmutableSortedMultiset(Comparator, Function, ToIntFunction)](https://google.github.io/guava/releases/22.0/api/docs/com/google/common/collect/ImmutableSortedMultiset.html#toImmutableSortedMultiset-java.util.Comparator-java.util.function.Function-java.util.function.ToIntFunction-) too! @lowasser Could you please take a look? @kevinb9n Any chances before Guava 23?  Repeatedly applying Sets.intersection(...) should not result in stack overflow error.
Attaching a unit test to reproduce the current (erroneous?) behavior (using 'com.google.guava:guava:21.0-rc1'):
import com.google.common.collect.Sets;
import org.junit.Test;
import java.util.HashSet;
import java.util.Set;
import static java.util.Arrays.asList;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.hasSize;
public class IntersectionTest {
@Test
public void shouldNotResultInStackOverflow() {
Set<String> set1 = new HashSet<>();
Set<String> set2 = new HashSet<>(asList("4", "5"));
for (int i = 0; i < 30000; i++) {
set1 = Sets.intersection(set1, set2);
assertThat(set1, hasSize(equalTo(0)));
}
}
}  Hi! I checked some of the new brilliant features of 21.0-rc1 (thanks!) and here's what I found.
1. `Multimaps.toMultimap(Function, Function, Supplier)`
* `com.google.common.base.Function` should be `java.util.function.Function`
* `com.google.common.base.Supplier` should be `java.util.function.Supplier`
2. `Tables.toTable(Function, Function, Function, Supplier)`
* change `com.google.common.base.Supplier` to `java.util.function.Supplier`
3. `Sets.toImmutableEnumSet()`
* is renaming to `Sets.toImmutableSet` possible?
* how about additional `ImmutableEnumSet.toImmutableEnumSet` returning `Collector<E, ?, ImmutableEnumSet<E>>`?
4. `ImmutableMultiset.toImmutableMultiset(ToIntFunction)`:
* could you, please - if at all - expose above instead of
`toImmutableMultiset(Function, ToIntFunction)`? *
5. `ImmutableSortedMultiset.toImmutableSortedMultiset(ToIntFunction)`
* could you, please - if at all - expose above instead of
`ImmutableSortedMultiset.toImmutableSortedMultiset(Comparator, Function, ToIntFunction)`?  *
* `EnumMultiset.toEnumMultiset()`
* `EnumMultiset.toEnumMultiset(IntFunction)`
* `HashMultiset.toMultiset()`
* `HashMultiset.toMultiset(IntFunction)`
* `LinkedHashMultiset.toMultiset()`
* `LinkedHashMultiset.toMultiset(IntFunction)`
* `TreeMultiset.toMultiset()`
* `TreeMultiset.toMultiset(IntFunction)`
* `TreeMultiset.toMultiset(Comparator)` for `<E extends Comparable<? super E>>`
* `TreeMultiset.toMultiset(Comparator, IntFunction)`
* `ImmutableSortedMultiset.toImmutableSortedMultiset()` for `<E extends Comparable<? super E>>`
*) `Function` parameter seems to be unnecessary. I believe it's more idiomatic to use `Stream.map(Function).collect(toImmutableMultiset(ToIntFunction))` and/or `Collectors.mapping(Function, toImmutableMultiset(ToIntFunction))`.
With the best wishes! **) `Multisets.toMultiset(Supplier)` and `Multisets.toMultisets(IntFunction, Supplier)` could be useful for implementing mutable Multisets collectors, but you surely know that... Thank you for quick reply!
> Many of the mutable Multiset collectors you mention can be done with the JDK built-in Collectors.toCollection(Supplier) (...)
That's true. If you would like to expose `.toMultiset(IntFunction)` or `.toMultiset(Function, IntFunction)` however, consider no-arg method too.
> We consciously do not expose an ImmutableEnumSet type (...)
My mistake, can't agree more. Forget about it.
> As far as the c.g.c.b versus j.u.f function issues go, we expect ~all users of these functions to be passing in lambdas and method references for which there is no meaningful difference.
Please, be consistent within the same class at least. `toTable(Function, Function, Function, Supplier)` uses `c.g.u.b.Supplier`, but `toTable(Function, Function, Function, Supplier)` - `j.u.f.Supplier`.
And please, be careful with expectations like the above. They may be true for most of the time, but I've already encountered cases where I wanted to pass *named* j.u.f parameters to the latest Guava methods and I couldn't (I've implemented my own multiset collectors; I wanted to deprecate some of them now, temporarily delegating to Guava collectors; couldn't just pass params which were declared as j.u.f since the beginning; not a great problem, but...).
Also, if your assumption was entirely true, c.g.u.b.Function wouldn't extend j.u.f.Function.
> As regards your footnote, I would absolutely expect the Function type to be necessary for many uses (...)
I've always treated `Multiset` as something more similar to `Set` than a `Map`. It is a `Collection`, right? (being a map is an implementation detail). That's why elementFunction suprised me. BTW note that `ImmutableMultiset` *collector* is inconsistent with `ImmutableMap` about duplicates. It may be also an argument against `ToIntFunction` TBH.
See also https://github.com/google/guava/issues/1087 The version conflict would be mitigated if guava-immutables package had a different version number.
guava-N could depend on any version of guava-immutables though.
We are on Guava 15 internally due to a broken dependency issue with another package (long story).
What about [Proguard](https://github.com/google/guava/wiki/UsingProGuardWithGuava)?  https://github.com/google/guava/wiki/NewCollectionTypesExplained#multimap
Actual:
"You can and should cast asMap.get(key)"
Should Be:
"You can and should cast asMap().get(key)"  Fixes issue #1597   When I'm creating my graph, I don't know all the nodes/edges, so I use proxies like the ids of the nodes and the ids of the edges while registering the edges and nodes as they come in. Think of this as a stream being parsed where the node 1 says "I'm linked to 2 and 4", but we haven't parsed 2 nor 4 already.
When I'm done creating it, I'd like to have a copy of the graph but with the actual nodes and edges. So similarly to all the `Maps.transform*` methods, I'd like to have `Graphs.transform*` methods where applicable.
The only alternative I see is to create proxy items before creating the graph, but that's a heavy burden on the user,  Thanks for your considerations, both of you.
What you showed as example, @jrtom, is exactly what I'm looking for. I'm mostly working with value graphs at the moment so I'd expect indeed more methods than the one you developed.
Also, since I consider this as IO deserialization, I don't care about the performance because the IO latency seems far greater than the creation of a new graph from memory objects. @jrtom I actually wonder if it's a bit premature to close this issue, because Bazel's BUILD_file_generator has a [function](https://github.com/bazelbuild/BUILD_file_generator/blob/dfa872bb8f60d679707a53f2dd2eb93b106710bf/src/main/java/com/google/devtools/build/bfg/ClassToSourceGraphConsolidator.java#L60-L91) which is vaguely similar to what I understand this issue is requesting, and it specifically comes with a note saying:
```text
// TODO(bazel-team): Migrate this function into Guava graph library
``` (@jrtom I just happened to discover the project when browsing the [bazelbuild](https://github.com/bazelbuild) org page a few days ago (Bazel's interested me for a while now), and in turn I got curious about the project's implementation, so I skimmed over its internal files. I just happened to view a particular file, and in the process I found that particular comment.
Kind of a cool coincidence, I'd say. :smiley:) Okay, sounds like a good reason to keep this issue closed for now then. Anything to keep the open issues reasonably less cluttered is a good thing in my book. :+1:   Please avoid putting Exception with a capital E into strings.  These end up in logs and cause headaches for both manual and automated things that look for such a string.  I've seen lots of regexes changed from 'Exception' to '[^d]Exception' to work around this.  Which will work fine until someone throws an exception that ends with a d.
```
public String toString() {
return MoreObjects.toStringHelper(this)
.add("hitCount", hitCount)
.add("missCount", missCount)
.add("loadSuccessCount", loadSuccessCount)
.add("loadExceptionCount", loadExceptionCount)
.add("totalLoadTime", totalLoadTime)
.add("evictionCount", evictionCount)
.toString();
}
* I should be able to provide my own `Random` instance. It's important for testing and safe-threading
* I'd use a `String` insead of a `char[]` as it's so much more legible.
* Regarding the original issue, I keep my idea that I should be able to store a generator. Your implementation doesn't do that. This is the biggest win of having the issue implemented. i signed it plz recheck ##line 148
public static String random(int len, char start, char end) {..}
or
public static String randomNumeric(int len, char start, char end) {....}
How about filling Appendable? For exapmple:
public static void randomNumeric(int len, char start, char end, Appendable target)
```
It may be useful for Writers and StringBuilders.  Added test cases for bug regarding incosistency between Ints.tryParse
and Longs.tryParse to show there is no defect. I signed it!  Please consider adding the method `splitToArray(String)` to `Splitter`.
## Why do I want it?
1. Because I often use arrays internally when reading speed matters more than the rest.
2. Because `Splitter.splitToList(String)` was added in release 15 and an array counterpart seems totally acceptable for the same reasons `Splitter.splitToList(String)` was added..
3. Because splitting to arrays is the default Java implementation (`String.split(String)`) and I'd kind of expect `Splitter` to provide if not the same behavior (luckily) at least the same output type.
4. Because repeating `String` at least once is too verbose for such a simple use case. All alternatives need the text `String` to be written at least one extra time.
I saw several ways to write this but none are really convincing:
String[] split = Iterables.toArray(splitter.split(text), String.class);
I'm not convinced by this, especially when I see that [StringsExplained](https://github.com/google/guava/wiki/StringsExplained) still recommends using `Lists.newArrayList(splitter.split(text))` even though `Splitter.toList(String)` exists. Also, since it's obvious we're using `String`s, I don't see why I'd have to repeat `String` several times.
### Inline, no cast, but reflection
String[] split = splitter.splitToList(text).toArray(new String[0]);
This is rather easy to write in one line, but has the strong disadvantage to internally use reflection (because you rarely get an array of length 0 when you split from an unknown length). Again, the repetition of `String` as a type narrower is annoying.
### Inline, cast
String[] split = (String[])splitter.splitToList(text).toArray();
List<String> splitList = splitter.splitToList(text);
String[] split = splitList.toArray(new String[splitList.size()]);
Probably the best answer in regards to speed (hopefully), but is on two lines because it has to use a variable. Also, this is totally redundant The fourth variant [may](https://shipilev.net/blog/2016/arrays-wisdom-ancients/) in practice not be faster than the second variant.  sometimes I need to merge List&lt;A&gt; and List&lt;B&gt; to List&lt;C&gt;, the object of A and B have a combine property such as id. Is there any function like below
```
List<T> merge(List<F1> list1, List<F2> list2, Function<T, F1, F2> func);
Are you trying to find a way of
1. creating a list containing `list1`'s elements followed by `list2`'s elements
2. and then transforming the elements in the new list using `func`? sorry.  @jbduncan
for example.
```
class Student{
long studentId;
String name;
}
class Exam{
long studentId;
int score;
}
class ScoreRecord{
String name;
int score;
}
List<Student> students;
List<Exam> exams;
List<ScoreRecord> table = somefunction(students, exams, (student, exam) -> {
if(student.getStudentId == exam.getStudentId) {
return new ScoreRecord().setName(student.getName).setScore(exam.getScore);
}else{
return null;
}
});
````
use 'somefunction' I can join the two objects by some key into object of other class  and collect as a list.
do I express it clearly? I didn't understand what you meant by "by some key", but I think the rest of what you said made sense to me.
Am I right to understand now that you're trying to combine `students` and `exams` in such a way that each corresponding element from the two lists gets transformed into a `ScoreRecord` (so something like the following, except in a more concise way)?
List<String> names = ImmutableList.of("Jonathan", "Mark", "Philip");
List<String> ages = ImmutableList.of("22", "30", "18");
class Record {
final String name;
final String age;
Record(String name, String age) {
this.name = name;
this.age = age;
}
}
ImmutableList.Builder<Record> recordsBuilder = ImmutableList.builder();
for (int i = 0; i < Math.min(names.size(), ages.size()); i++) {
String name = names.get(i);
String age = ages.get(i);
recordsBuilder.add(new Record(name, age));
}
ImmutableList<Record> records = recordsBuilder.build();
```
If so, then you'll probably have to wait until _Guava 21.0_ is released, as it will have a new [`Streams.zip`](http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/Streams.html#zip-java.util.stream.Stream-java.util.stream.Stream-java.util.function.BiFunction-) method which does exactly that but for streams. (I presume from your usage of a lambda expression in your last message that you know how to turn lists into streams.)
I presume that when _21.0_ is released, you'd use `Streams.zip` like this:
Stream<Record> recordsStream =
names,
ages,
(name, age) -> new Record(name, age));
// or
recordsStream = Streams.zip(names, ages, Record::new);
// you'd then transform it into a list if needed, either an immutable one (recommended if possible)...
ImmutableList<Record> records = recordsStream.collect(ImmutableList.toImmutableList());
List<Record> mutableRecords = recordsStream.collect(Collectors.toCollection(ArrayList::new))
// Or if it doesn't matter to you...
List<Record> records2 = recordsStream.collect(Collectors.toList());
``` There is a litter different. The two object student and exam must match the condition of 'student.getStudentId == exam.getStudentId', when it can generate a new object of ScoreRecord.@jbduncan @memimy2015 What type of list would this method return? I have not thought about it, any type is ok, ImmutableList, List ... @liach An immutable list would be the easiest to implement. Hi @memimy2015, there's a detail which I'm still unsure about regarding what you want to achieve, so I wonder if you could clarify things further for me.
Do you want to compare elements like this (before checking on a particular "key")...
```
students.get(0) <-> exams.get(0)
students.get(1) <-> exams.get(1)
...             <-> ...
students.get(N) <-> exams.get(N)
```
...or like this?
```
students.get(0) <-> exams.get(0)
students.get(0) <-> exams.get(1)
students.get(0) <-> ...
students.get(0) <-> exams.get(N)
students.get(1) <-> exams.get(0)
students.get(1) <-> exams.get(1)
students.get(1) <-> ...
students.get(1) <-> exams.get(N)
...             <-> ...
students.get(N) <-> exams.get(N)
Hmm, did you mean to sound so presumptuous? I struggle to see how you came to the conclusion that @memimy2015 definitely wanted a normal merge over a Cartesian merge. As far as I can tell, they've given no indication so far that they wanted one over the other. So may I kindly ask for the future that you do not jump to conclusions so quickly and to wait to hear from @memimy2015 themselves before answering my question for them?
> But for the two lists, they need the size() method to ensure a merge can be done.
Not necessarily. It's possible to "merge" or "zip" (or whatever term you think best describes this idea) two sequences _without_ a predefined size, by simply merging until one of the two sequences is exhausted. See [`Streams.zip`](https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/Streams.html#zip-java.util.stream.Stream-java.util.stream.Stream-java.util.function.BiFunction-) for an example of what I mean. If I understood the original request correctly, it's not a 'zip' operation because elements should match based on their key, not on their positions. So if lists are not sorted, there should be additional operation to find the matching element by key, something like
Map<Long, Exam> examByStudentId = Maps.uniqueIndex(exams, e -> e.studentId);
List<ScoreRecord> records = Lists.transform(students, student -> {
Exam exam = examByStudentId.get(student.studentId);
return new ScoreRecord(student.name, exam.score);
});
``` @loki-1 The point is that `List`s are ordered, compared to `Collection`s and `Iterable`s. The order of the elements in the list is based their positions instead of some other key. @loki-1 Correctly! Your method can solve my request. I want to know if there is a method I can do this by 1 line code. @liach Sorry, I don't understand what do you mean. List order may or may not be consistent with key order depending on how inputs are generated.
@memimy2015 I doubt if it should be 1 method, because you have at least 2 different operations: matching items from 2 lists and mapping them into output item. ```
students.get(0) <-> exams.get(0)
students.get(1) <-> exams.get(1)
...             <-> ...
students.get(N) <-> exams.get(N)
``` @liach I still don't see how lists are special here. For this to work, you need both input collections to be sorted in compatible way. It can be achieved with Lists, SortedSets, LinkedHashSets and so on.
```
studentsIterator.next() <-> examsIterator.next()
studentsIterator.next() <-> examsIterator.next()
...
``` Ok.  This format is becoming a thing. I couldn't find it in Guava's media types. I signed it!  Hello,
Would it be legit to add an AtomicLongMap.create(ConcurrentMap) method which keeps the provided Map as undelrying ConcurrentMap? it would typically used over a ConcurrentSkipListMap to provide ordering over keys.
Thanks I see your points. This is note a strong requirement on my side, and as you said, Java 8 provides nice alternatives. Thanks  Please add audio content-type 'audio/vorbis', 'audio/x-wav' to com.google.common.net.MediaType and ability to create MimeType using full name of mime-type, for example:
MimeType.create("audio/x-wav")  tive iterators #2666 There is soo much overhead in this implementation... And streams unavailable: guava support java 6+ .. Next Guava will require Java 8  Unless I'm missing something, the method `UnsignedInts.checkedCast(long val)` seems to be missing. This method is available for all of the smaller types (e.g., bytes) in both signed and unsigned variants. It is also available in `Ints` for signed values.
There doesn't seem to be a particular reason for the omission, since there doesn't seem to be any particular implementation difficulty and it exists in almost all the other "unsigned" variants.
This method is needed and useful for the same reason as all the other `checkedCast` variants. Just adding a workaround until the method is added:
`UnsignedInteger.valueOf(val).intValue()`
Of course, this unnecessarily creates an UnsignedInteger object, although escape analysis will often be able to eliminate it. Wow, haha, I had added `UnsignedShorts` locally to work around issue #670 and I failed to notice it was local while writing the above (that's why it had so few methods). I think the rest of the reasoning still holds though.  I edited my initial report so it makes more sense.  Perhaps I'm going crazy and doing something incredibly stupid, but my understanding is that the attached code should output 2, and at some point call TestObject.equals; it returns 0 and seems to never even call my defined equals() method. Everything in the specs that I read says that's how it should work, so either the doc is unclear or something is funky. Needless to say calling Objects.equal(new TestObject(7), new TestObject(7)) returns true. Additionally, Collections.frequency(ms, new TestObject(7)) returns 2, as it should. I was under the understanding they should return the same thing?
`
package ExcelMLTesters;
import com.google.common.collect.HashBasedTable;
import com.google.common.collect.HashMultiset;
import com.google.common.collect.Multiset;
import com.google.common.collect.Table;
import java.util.Objects;
private static class TestObject {
private int val;
public boolean equals(Object obj) {
System.out.println("I'm comparing "+ this.toString() +"  and " + obj.toString());
if (obj instanceof TestObject)
return this.val == ((TestObject)obj).val;
return false;
}
public int getVal() {
return val;
}
public void setVal(int val) {
this.val = val;
}
public TestObject(int val) {
this.val = val;
}
public String toString() {
return "TestObject{" +
"val=" + val +
'}';
}
}
// TODO Auto-generated constructor stub
}
public static void main(String[] args) {
// TODO Auto-generated method stub
Table table = HashBasedTable.create();
table.put("a", 1, new TestObject(5));
table.put("a", 3, new TestObject(3));
table.put("b", 1, new TestObject(7));
table.put("c", 1, new TestObject(7));
table.put("d", 1, 1);
table.put("e", 1,1);
Multiset ms = HashMultiset.create(table.column(1).values());
// Call me crazy, but shouldn't this output 2 and call TestObject.equals() at some point?
System.out.println(ms.count(new TestObject(7)));
}
}
` Yep - thank you! that did indeed work - and I did violate the hashCode contract - but FYI:
Collections.frequency actually works as expected. TestObject.equals() was **never called**, whereas in Collections.frequency it is.
The documentation for Multiset states that the equals() method is called, unless other specified by the implementation, the implementation doc for HashMultiset does not specify otherwise.
http://google.github.io/guava/releases/20.0/api/docs/ - the doc for Multiset says under the general heading.
"A multiset uses Object.equals(java.lang.Object) to determine whether two instances should be considered "the same," unless specified otherwise by the implementation."
It also says, under count() : "Note that for an Object.equals(java.lang.Object)-based multiset, this gives the same result as Collections.frequency(java.util.Collection<?>, java.lang.Object) (which would presumably perform more poorly)."
The HashMultiset doc repeats the same - maybe it would be a good idea to make it explicitly understood for idiots like me that you have to make sure that hashCode is implemented.
Absolutely fair, @jrtom , that was an amateur hour mistake by me, but maybe there's a way to disambiguate the documentation is all.  Oh I agree; the reason that I went down the rabbit hole is that the doc explicitly said it uses equals() like Collections.frequency() unless the implementation doc says otherwise, and the implementation doc wasn't very clear in saying otherwise (although it should be freaking obvious to me, since it is backed by a hash table, duh).  Add collectors for `enum`-specialized `ImmutableSet` and `ImmutableMap`:
- `toImmutableEnumSet()`
- `toImmutableEnumMap(keyFunction, valueFunction)`
- `toImmutableEnumMap(keyFunction, valueFunction, mergeFunction)`
For example, if a user has code like this:
ImmutableSet<Month> months = stream.collect(ImmutableSet.toImmutableSet());
```
... then it would be cool if they could optimize their code like this:
ImmutableSet<Month> months = stream.collect(ImmutableSet.toImmutableEnumSet());
```
... and it would be lame if they had to do this (it would be so lame that they wouldn't bother):
ImmutableSet<Month> months = stream.collect(SomeHelper.toImmutableEnumSet(Month.class));
// Elsewhere... javadoc and tests omitted...
public static <E extends Enum<E>> Collector<E, ?, ImmutableSet<E>>
toImmutableEnumSet(Class<E> elementType) {
Objects.requireNonNull(elementType);
return Collectors.collectingAndThen(
Collectors.toCollection(() -> EnumSet.noneOf(elementType)),
Sets::immutableEnumSet);
}
``` Hi: I have been working on this issue and discovered that the fauxverride tests are failing because the original equals code no longer works. Specifically, `K extends Enum<K>` as a type literal's equals method depends on the place where it is declared and its name. (The code can be found under sun.reflect.generics.reflectiveObjects.TypeVariableImpl's equals method).
I was able to fix the tests by simply comparing the result of `Type::getTypeName`, however, this is not correct as it is also sensible to the specific name of the generics declared.
Part of me wants to call that a problem with `FauxveridesTest`.  I don't understand the reason that `MethodSignature` cares about the generic type parameters for equality.  As long as the method names and parameter types are the same, shouldn't javac enforce that the generic type parameters are also the same?  (I'm sure I'm missing something.)
In any case, I don't think it's essential that these methods live in `ImmutableSet` and `ImmutableMap`.  That home would be good for discoverability, but maybe that home would be bad for other reasons that include this fauxverides issue.  If these methods instead lived next to `Sets.immutableEnumSet(...)` and `Maps.immutableEnumMap(...)` (for example), they would still be useful. Fair enough. I can move my code. Do you think I should report a separate issue on the test? > Fair enough. I can move my code. Do you think I should report a separate issue on the test?
Unless it's causing other problems, I wouldn't bother.  I'm just a random guy from the internet though... Guava 21.0 shipped with `com.google.common.collect.Sets.toImmutableEnumSet`. If the Guava team does not plan to add the other two types of collector, then this issue can be closed. They did add the other two as well.  Thanks! D'oh I was looking in the wrong place. You're right! Nice.  Add the following methods:
public class Iterators {
// ...
public static PrimitiveIterator.OfInt toIntIterator(Iterator<Integer> iterator);
public static PrimitiveIterator.OfLong toLongIterator(Iterator<Long> iterator);
public static PrimitiveIterator.OfDouble toDoubleIterator(Iterator<Double> iterator);
}
``` Also, Java standard library has no methods for getting empty iterators:
public static PrimitiveIterator.OfDouble emptyDoubleIterator();
```  `RangeMap` doesn't coalesce connected ranges (by design), and it would be nice if there were a built-in way to coalesce connected ranges if they have the same value. For example:
{[0..1): 1, [1..2): 1, [2..3): 2}
Is roughly equivalent to:
{[0..2): 1, [2..3): 2}
And it can be both a time and space savings to be working with a smaller data structure. Particularly for a case such as a `RangeMap` built up from `Range.singleton()` keys a `coalesced()` operation could save a lot of resources. Definitely; I'd expect it to be a copy operation as a live view would eliminate the benefit of reducing the underlying number of ranges in use (and probably be much more complex to implement). `ImmutableRangeMap.coalescedFrom(RangeMap)` could also work. We opted to add a mutating `.putCoalescing()` operation rather than a copy or a view. Please let us know if you have a use case for which this isn't sufficient.  I'm writing a music tracker and I need a sparse table that does everything listed below:
- Fast insertion of elements, at any point.
- Fast removal of elements, at any point.
- Fast insertion of rows and columns, at any point.
- Fast removal of rows and columns, at any point.
- Fast sorted iteration.
- Fast slices/subtables. E.g. if the table has 200 columns and 100 rows (not necessarily densely populated), I wanna be able to get a subtable from row 10 to row 20 and column 20 to column 30. The subtable should have comparable performance to the original table, e.g. remove(1,1) in the original table should be as fast as remove(1,1) in the subtable, even if the subtable is in the middle of the original table.
- Fast indexing is NOT required, and subtables are meant to mitigate this. For iteration, caches of predecessor and successor may speed up the iteration to be O(1) (Ex. the one in [TreeMultiSet.java](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/TreeMultiset.java#L538-L539)), but the java `TreeMap`'s iteration performance is actually O(log(size)), making `TreeBasedTable` slower in iteration. Here is an analysis of @SoniEx2's requests:
(C: columns' size; R: rows' size)
>- Fast insertion of elements, at any point.
TreeBasedTable: Always O(log(C)+log(R))
>- Fast removal of elements, at any point.
TreeBasedTable: Always O(log(C)+log(R))
>- Fast insertion of rows and columns, at any point.
TreeBasedTable: Rows O(log(R)), Columns O(R*log(C))
>- Fast removal of rows and columns, at any point.
TreeBasedTable: Rows are O(log(R)), Columns O(R*log(C))
>- Fast sorted iteration.
>- Fast slices/subtables. E.g. if the table has 200 columns and 100 rows (not necessarily densely populated), I wanna be able to get a subtable from row 10 to row 20 and column 20 to column 30. The subtable should have comparable performance to the original table, e.g. remove(1,1) in the original table should be as fast as remove(1,1) in the subtable, even if the subtable is in the middle of the original table.
For this one, creating a view would be O(1), all other operations are the time above, but a clone would be way slower in creation. (guess linear time)
>- Fast indexing is NOT required, and subtables are meant to mitigate this.
for one example:
I can make sure my key can't contain separator. but I can't make sure my value can't contain separator due to the value is generated by third-part service or special codec which can get separator. So I think we should fix this issue. It is common issue for most of case, Throwing IAE isn't reasonable or easier to let's happen low rating bug.
Can someone help to take a look at this PR. Thanks.@cgdecker I signed it! anyone can take a look? @jiafu1115 Should this regard different types of splitters? Or add some method like `ignoreExtraSeparator()`? @liach no. only change the inner behavior for MapSplitter. This is the simplest way to meet requirement.WDYTThanks There must be a reason why it throws an exception when detecting more than one separators. You should ping a project manager. @liach I had pinged the issue creator @cgdecker who is also the member for guava but no feedback util now. So I does not know who I should ping. so just waiting now. I think we need to ping the authors of `Splitter`. @lowasser  @liach Thanks for your reminder. We may need to wait and wait and wait...... @eamonnmcmanus Thanks for your change for title, it is more clear now.
Hi,
at first glance, the following program works as expected. However, it causes constant 12% load on an i7-4790 CPU @ 3.60Ghz:
public static void main(final String[] args) throws InterruptedException
{
RateLimiter limiter = RateLimiter.create(0.1);
Stopwatch sw = Stopwatch.createStarted();
while (true) {
if (Thread.interrupted()) {
}
if  (limiter.tryAcquire(200, TimeUnit.MILLISECONDS)) {
System.out.println(sw.elapsed(TimeUnit.MILLISECONDS) + " ms");
}
}
```
**So what's wrong with my code?**
The reason for the high CPU usage is that tryAcquire _immediately returns false without waiting_ if it detects that a permit will not become available within the timout period.
- _Stuff_ has been done
- `timeout` has passed
But most of the time, `tryAcquire` will return without satisfying any of those. This is mentioned in the Javadocs but I think it's really easy to read past that part without realizing the consequences.
If I had to propose a solution, I'd probably introduce a new method called `acquireOrWait` that implements my use case and/or highlight the consequences of early returns in the `tryAcquire` JavaDocs.
Please forgive me if this is a duplicate, I've tried searching first but couldn't find a related issue.
I found that this part of code can include a bug:
```
for (int i = 1; i < n; i++) {
E cur = contents[i];
E prev = contents[uniques - 1];
if (comparator.compare(cur, prev) != 0) {
contents[uniques++] = cur;
}
}
```
Why you not process the last one element? I mean this:
`for (int i = 1; i < n; i++)` ![1](https://cloud.githubusercontent.com/assets/11968111/20677455/71fcaaa6-b593-11e6-9ee6-b8513a88dc59.png)
![2](https://cloud.githubusercontent.com/assets/11968111/20677467/7b6c4b0a-b593-11e6-96f7-2f2ff97a71a8.png)
```
if (comparator.compare(cur, prev) != 0) {
contents[uniques++] = cur;
}
```
That's why one of these elements in "E... contents" array disappeared (was rewrites with the previous element) :) @lowasser , here is comparing of these objects:
![screen shot 2016-11-28 at 20 17 00](https://cloud.githubusercontent.com/assets/11968111/20682353/f39ab40e-b5a7-11e6-86cd-94c0902f5481.png)
` if (comparator.compare(cur, prev) != 0) `
![screen shot 2016-11-28 at 20 39 04](https://cloud.githubusercontent.com/assets/11968111/20683025/c02ae64a-b5aa-11e6-87d6-0388f0d439d7.png)
This is Kotlin:
```
override fun compareTo(other: RolledSectionRectangularData): Int {
val keyCmp = compareSortKeyTo(other)
return if (keyCmp != 0) keyCmp
else priority.compareTo(other.priority)
}
protected fun compareSortKeyTo(other: NamedInfo): Int {
return Integer.compare(priority, other.priority)
}
``` ![screen shot 2016-11-28 at 21 06 27](https://cloud.githubusercontent.com/assets/11968111/20684034/94bfa5e6-b5ae-11e6-9921-a041b6b19f44.png)
Yes, guys, you're right! Thank u a lot for help me with it.  Same here!
Output:
```
[0, 3, 1, 2]
Try to remove 1:
[0, 3, 1]
```
Source:
```
MinMaxPriorityQueue<Long> values = MinMaxPriorityQueue.create();
values.add(2L);
values.add(3L);
values.add(4L);
values.add(0L);
values.add(1L);
values.remove(4L);
System.out.println(values);
System.out.println("Try to remove 1:");
values.remove(1L);
System.out.println(values);
```
I see this as an external Maven artefact that we include if we want to use such functionality, a bit like the tools that generate utilities during the compilation like Dagger or AutoValue.
Hopefully, this is possible without having to change `@Beta`'s retention policy from class to source. I don't really know the arcanes of the compiler so I can't really say...  expected: `NullPointerTester` treats `@CheckForNull` like `@Nullable`
actual: `NullPointerTester` fails if a `@CheckForNull` parameter isn't checked for null.
```
import javax.annotation.CheckForNull;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import com.google.common.testing.NullPointerTester;
import org.testng.annotations.Test;
import static com.google.common.base.Preconditions.checkNotNull;
public class FooTest {
static final NullPointerTester tester = new NullPointerTester();
static class Foo {
@Nonnull String a;
@CheckForNull String c;
public Foo(@Nonnull String a, @Nullable String b, @CheckForNull String c) {
this.a = checkNotNull(a, "a");
this.b = b;
this.c = c;
}
public String concat(@Nonnull String d, @Nullable String e, @CheckForNull String f) {
return concatStatic(d, e, f);
}
public static String concatStatic(@Nonnull String a, @Nullable String b, @CheckForNull String c) {
String result = checkNotNull(a, "a");
if (b != null) {
result += b;
}
if (c != null) {
result += c;
}
return result;
}
}
/*
* Tests fail complaining that no exception is thrown for parameter 2.
*/
@Test
public void testAllPublicConstructors() {
tester.testAllPublicConstructors(Foo.class);
}
@Test
public void testAllPublicInstanceMethods() {
Foo foo = new Foo("a", null, null);
tester.testAllPublicInstanceMethods(foo);
}
@Test
public void testAllPublicStaticMethods() {
tester.testAllPublicStaticMethods(Foo.class);
}
}
```
Making this change would be useful for anyone who uses Guava with [FindBugs](http://findbugs.sourceforge.net/). FindBugs takes `@CheckForNull` to mean "this should be checked for null" and `@Nullable` to mean "this should be ignored from null checking". `javax.annotation`. Added imports above. @bdworth How about making concatStatic... actually static? ha, right. "fixed", so now all three tests fail as expected   Fair points. Sometimes I really want to use arrays, to save some space (avoid Autoboxing). I guess I'll create a wrapper class for my arrays.  I need to use guava and I must to use google maps m4b (premium), but I get the next error:
Error:Execution failed for task ':app:transformClassesWithJarMergingForDebug'.
> com.android.build.api.transform.TransformException: java.util.zip.ZipException: duplicate entry: com/google/common/base/FinalizableReference.class
this is here too: https://code.google.com/p/gmaps-api-issues/issues/detail?id=10246
any solution?  I ran into exactly this some time ago and I'm afraid you can't use `Striped` when both threads need multiple locks and you don't know which in advance. The goal of `Striped` is to reduce the number of needed locks and this can be only done by mapping multiple inputs onto the same lock. You were unlucky getting
```
A1 -> L1 <-B2
A2 -> L2 <- B1
```
and you can't avoid the deadlock by changing the order as you don't know the mapping.
I'm afraid, there's no solution involving `Striped`, unless you know all locks a thread needs upfront. In case you do, then you can use `Striped.bulkGet` so you get the locks in a fixed order.
Otherwise, if you need to lock based on identity, then you can
- lock on the object themselves
- or lock on what you get from a `Cache<YourObject, YourLock>` using `weakKeys`.
If you need to lock based on `equals`, then you can
- or lock on what you get from a `Cache<YourObject, YourLock>` using `weakValues`.
- use a `WeakHaskMap<YourObject, YourLock>`, but this works only if you can assure keeping `yourObject` alive as long as the lock is needed. *So better don't.*
If you use Map<Key, Lock> then the purpose of striped locking is not lost. Understood.
But what I understood is A1 and B1 are resolving to same lock - A2 and B2 are resolving to same lock ? If that is the case I thought having two striped instances could solve the issue.   In version 20.0 the errorprone annotations are used throughout the codebase so the error_prone_annotations dependency is not optional anymore. I signed It!
Ok.  I'm closing this PR so I can do more investigation.  When we updated to version 20.0 we started getting
```
Error:java: cannot access com.google.errorprone.annotations.CanIgnoreReturnValue
class file for com.google.errorprone.annotations.CanIgnoreReturnValue not found
```
when compiling the project in IntelliJ.  The workaround is to explicitly add the error_prone_annotations dependency to our app but I'm not sure what part of our code is trying to use that annotation.  Can support be added to the new graph package classes to support `java.io.Serializable`? Yes, sorry, to clarify I am more interested in `ImmutableGraph` implementing `Serializable` so that I can easily persist graphs to use in later executions of my software. I might persist it in a database or simply as a file on a file system but ultimately I want to be able to run a process multiple times, each run generates a graph, some time later I will run it again and I'll then want to compare graphs from previous runs with the new runs.
I could create my own serialization and deserialization code for it but it would be nice to be able to simply cache it and retrieve it later.
Hm, interesting note, thank you @cpovirk. I suppose if I changed versions then I would need to deserialize my entities with the previous version and then reserailize it with the new version; probably best to avoid it then and roll my own.
Sounds good. I will do my own for now and watch for a JUNG update as well. Thank you.
P.S. I know some tools like Common JCS and/or Hibernate require some entities to implement `Serializable` but that isn't currently my use case.
I have the following workaround but it seems expensive (although for small trees I suppose it doesn't really matter):
fun <N> Graph<N>.children(node: N): Set<N> {
return nodes().toMutableSet().apply { retainAll(successors(node)) }
}
```
Can supported be added to specify the order of nodes returned by `successors()`?  fixes https://github.com/google/guava/issues/2648 . I signed it.  I should be covered by Amazon corporate CLA, though it's not appearing on my account for some reason.
@jct-amzn I think @googlebot hasn't recognised that you've signed the CLA? By my understanding, once you type the message
> I signed it!
then googlebot should automatically detect it (it's a GitHub service/bot, not a human user :smiley:) and it should tell you what you need to do next to change the red "cla: no" label into a green "cla: yes" label.
My google account doesn't show that I'm part of the correct corporate CLA, so I think there's some problem on the backend, in the way the dots are all connected (github email -> google group -> CLA signatory).
Anyway it's just some one-time bookkeeping and I'm working on resolving it.
I signed it!
Ok, trying again.  Google CLA recognizes me now.
I signed it! checking back on the status of this.  the CLA verifier probably doesn't support private email addresses in the github account.
if the bot is using this app script to do the CLA check:
https://github.com/angular/google-cla-verifier-for-github/blob/master/cla-verifier.gs
then you can see that they're just pulling the "fake" email from the patch file:
https://github.com/angular/google-cla-verifier-for-github/blob/master/cla-verifier.gs#L210
so I think there is no way the bot can trace that back to my actual email address, which should be in their signatories spreadsheet. thanks Will.  Can you update the 'cla' label so the request doesn't get auto-closed again?
I'm going to work out a different arrangement at work so this isn't so complicated next time. Hi @cpovirk, as a external reviewer, I managed to find a couple of things in that commit which I think could be improved upon. I've shared my thoughts on those things in the comments below:
1. https://github.com/google/guava/commit/7c11b8d9220b710d5598b774e22cc774f68f40e7#commitcomment-20999208
2. https://github.com/google/guava/commit/7c11b8d9220b710d5598b774e22cc774f68f40e7#commitcomment-20999157
3. https://github.com/google/guava/commit/7c11b8d9220b710d5598b774e22cc774f68f40e7#commitcomment-20999165 Thanks @cpovirk .  I'll keep AndroidIncompatible in mind for future commits.  No worries about the CLA, I know I was making it a challenge.  Guava 20 depends on error prone annotations 2.0.12 which requires Java8.
However GWT 2.8 still allows Java7 to be used as JVM even tough internally it compiles using JDT and source level 1.8. When using Java 7 + GWT 2.8 + guava-20-gwt you get an unsupported major.minor version 52.0 error when GWT tries to load an error prone annotation from classpath.
In terms of GWT support I think the latest version of error prone annotations you should depend on is 2.0.5 as its the last version build for Java7. Looks like Guava can not use error prone annotations 2.0.5 as it does not contain LazyInit annotation. So I rebuild error prone annotations 2.0.14 using Java7 which fixes the GWT issue.
Hmm good question, already a few days ago. I think there is probably a chance that I have used 2.0.14.
At least I am sure that I did a google search after seeing the error and found https://github.com/google/error-prone/issues/369 . So I thought all versions above 2.0.5 had been built with Java8 and would cause the error.  Hi I have a requirement to save or pass it my graph as json to other apis but what I am seeing is graph interfaces are not serializable so any new update has been coming up relating to this requirement. Can you help me in how I can export it as a json. Yes I was targeting JSON. It was in my mind to do serialization & deserialization my own but thought to discuss it once with the community.
Thanks alot.
I found a small typo here: https://github.com/google/guava/wiki/ReflectionExplained#is-the-first-parameter-of-the-method-annotated-with-nullable :
`method.getParameterAnnotations[0]` should be `method.getParameterAnnotations()[0]`  Why for BaseEncoding.base64Url() padding character is '**=**'? In javascript google libraries like:https://github.com/google/closure-library/blob/master/closure/goog/crypt/base64.js padding character is '**.**'. It should be url safe, but '**=**' is a URL reserved character. I think it's easy to get confused, better to force client specify padding character manually.  [@jrtom suggests](https://github.com/google/guava/issues/2609#issuecomment-260100298) moving the topic of topological sorting to a separate issue.
## Usage
The most outstanding usage of topological sorting is dependency management. For example, an order of executing tasks. (some depend on others)
## Suggestion of implementation
Since topological sorting is from graph algorithm, I proposed to put it together with direct acyclic graphs in the [previous issue](issue/2609). But the algorithm will be much slower once it involves with graphs.
- Using graphs
- Using a hash map and a priority queue
Will this be making it into Guava in the near future? @kashike This sort is easy to understand. Each time you keep a collection of items without a prerequisite, and you then unlock more item when you add each of those in the collection to the sorted list. You can find a loop when you can no longer unlock but there are still entries left.  This will be a method that generates a `List` view of the array argument, similar to `Arrays.asList()`. The difference is that the requested method will create an unmodifiable view of the array, which is faster than an immutable view like `ImmutableList`. (It copies the array) This method would be a single wrapper instead of a double wrapper like this:
Collections.unmodifiableList(Arrays.asList(new Object{}));
```
And the one above is long enough for us to create a shortcut for it. @liach - what is the difference between unmodifiableList and immutable one?
In both cases you would like to  have a list that cannot be modified - i.e - have elements added or removed from it
UnmodifableList's backing list can be modified, and the unmodifiable version can reflect that change.
ImmutableList is immutable, that is it can never be modified.
List<String> list = Lists.newArrayList("apple", "banana");
List<String> view = Collections.unmodifiableList(list);
view.forEach(System.out::println);
System.out.println(); //to separate two outputs
list.set(1, "pear");
view.forEach(System.out::println);
```
The expected output should be:
```
apple
apple
``` @liach  so you would like to retrieve an unmodifiable list, which is backed by an array? Yes, and it should be as light as possible I would prefer not to have an interim allocation of Arrays.asList , but simply have
the array, and return an umodifiable list that is backed by it (I refer to the example you gave - I feel Arrays.asList is an unnecessary allocation).
I would like to work on a patch for this -
My idea is to return an object implementing the list interface, and throwing an exception on the methods that modify the list (i.e - add).
What do you think?
Yes. Generally something like `Arrays.ArrayList` but does not support `set(int index, E element)` operation. Thanks @liach , i will be glad to contribute the patch. Hi @yairzaslavsky, I'd recommend you wait until someone on Guava team replies back to this issue before writing your patch. This is because on the [Contributing](https://github.com/google/guava/blob/master/CONTRIBUTING.md) page, it explicitly states that API additions will only be considered after a lengthy and thorough review process, and so if your write the code now, it may be all for nought. @jbduncan  I have read it, but thanks for pointing it out to me.
For me it's easier sometimes to express myself via code. I am perfectly fine with the possibility the idea gets rejects. A pull request, even if not perfect, can show what we had in mind.
Thanks for the reply!  Starting with Guava 19 emulations of `java.util.concurrent.Future/CountDownLatch` have been added and a matching `java.util.Util.gwt.xml` has been added to publish the super source. Both classes depend on `java.lang.InterruptedException` which has been super sourced as well using `java.lang.Lang.gwt.xml`.
However `java.util.Util.gwt.xml` does not inherit `java.lang.Lang.gwt.xml` so the GWT compiler generally does not see super source of `java.lang.InterruptedException` if you would only inherit `Util.gwt.xml` in a GWT app.
Basically if a GWT app does not directly or indirectly inherit `Collect.gwt.xml` (the only module that actually inherits `Lang.gwt.xml`) GWT compilation fails as nearly everything pulls in `Base.gwt.xml` which in turn pulls in `Util.gwt.xml`.
Also I am not so sure why `Base.gwt.xml` pulls in `Util.gwt.xml` as the code in the base package does not seem to depend on anything from java.util.concurrent, but maybe that's because inside Google you have more code covered through `Base.gwt.xml`.
So please revisit and fix your inherits structure for GWT.
I think it's fine to document it on the Guava 19 / 20 release notes as a known issue and publish the fix with 21.0.
Btw: It's likely that GWT will provide CompletableFuture emulation in the future, thus also emulating most if not all java.util.concurrent classes Guava currently provides. I am just curious but is there a reason why you guys don't contribute reasonable implemented JRE emulation to GWT itself?
Some times, we need events to be executed by specified executor. I signed it!
Improved the performance of indexOf methods of primitives.
The original time efficiency was O(nm), where n is the size of the array
and m is the size of target. The new time efficiency is O(n).
The algorithm used is Sunday algorithm, a string matching algorithm that can be used on arrays.
All tests passed locally. For now I do not really have good data to test these methods. Could you provide some big data if possible?
Hi @liach. From what I can tell, I'm not sure if you actually need big data to test the performance of your new implementations of the methods.
In situations like this, people typically write micro-benchmarks with a framework like [JMH](http://openjdk.java.net/projects/code-tools/jmh/) to show how their solutions compare to existing ones speed-wise.
So my personal suggestion would be to investigate JMH if you're not already familiar with it, and then write a micro-benchmark between the current impls and yours, show us the results, and provide us with the source code so we can help you improve the benchmark in case it doesn't follow best practices. (But I admit that I wouldn't be the best person to ask about best practices, as I hardly know how to even write benchmarks with JMH or other frameworks.)
(I know that Google use Caliper instead as their framework for micro-benchmarking, but some people think it's a bit flawed and that JMH produces more accurate results, so I'd personally be inclined to use JMH for my own benchmarks. But that's a story for another time and for someone else to talk about, as I am not familiar with the details. :smile:)
Actually are benchmarks like [these](https://github.com/google/guava/blob/master/guava-tests/benchmark/com/google/common/primitives/UnsignedBytesBenchmark.java)?
Yes, that's right. What you've shown is a link to one of Guava's Caliper benchmarks. However, I'd strongly recommend looking into **OpenJDK JMH** instead, because it's supposed to be much more reliable.
See https://groups.google.com/forum/#!msg/mechanical-sympathy/m4opvy4xq3U/7lY8x8SvHgwJ for more information.
Do I do in a separate project? I am not really clear about this.
I think so? That's what the [front page](http://openjdk.java.net/projects/code-tools/jmh/) seems to say. But I'm really not the right person to ask, as I've never written a benchmark before.
Hi all -
I'm experiencing a problem serializing ImmutableLists in GWT. More specifically, the issue I stumbled upon is:
`[INFO] com.google.gwt.user.client.rpc.SerializationException: Type 'com.google.common.collect.SingletonImmutableList' was not included in the set of types which can be serialized by this SerializationPolicy or its Class object could not be loaded. For security purposes, this type will not be serialized.: instance = ...
`
The culprit is an object that contains an ImmutableList with a single object embedded.
Does the serialization test suite include coverage for singletons?
Thanks,
As discussed in https://github.com/google/guava/issues/2591#issuecomment-258624388, I wonder if it'd be worth adding a map stream class to Guava 21.0+, in the spirit of OpenGamma Strata's MapStream ([javadoc](http://strata.opengamma.io/apidocs/index.html?com/opengamma/strata/collect/MapStream.html)) or StreamEx's EntryStream ([javadoc](https://amaembo.github.io/streamex/javadoc/index.html?one/util/streamex/EntryStream.html)). @cpovirk I believe this issue should have "platform: java 8" and "package: collect' labels? :) Thanks for adding them @cpovirk! :) I would also like such a class, though I would suggest to make it more general and not only focused on maps.
It could look like this:
public interface PairStream<A, B> {
static <A, B> PairStream<A, B> empty();
// Zip methods, with different handling of iterables of different length:
// throwing exception, truncating, or padding with null
static <A, B> PairStream<A, B> zip(Iterable<A> a, Iterable<B> b) { }
static <A, B> PairStream<A, B> zipShorter(Iterable<A> a, Iterable<B> b) { }
static <A, B> PairStream<A, B> zipPadded(Iterable<A> a, Iterable<B> b) { }
static <T, A, B> PairStream<A, B> of(Iterable<T> it, Function<T, A> aFunc, Function<T, B> bFunc) { }
// Maybe additional convenience method for maps?
static <A, B> PairStream<A, B> of(Iterable<Map.Entry<A, B>> entryStream) { }
static <A, B> PairStream<A, B> ofEntries(Map<A, B> map) { }
<R> PairStream<R, B> mapLeft(BiFunction<A, B, R> f);
<R> PairStream<A, R> mapRight(BiFunction<A, B, R> f);
<R> Stream<R> map(BiFunction<A, B, R> f);
// Maybe convenience methods for simple projections?
Stream<A> toLeft();
Stream<B> toRight();
// flatMap(Left|Right) would pair each of the entries of the resulting stream
<R> PairStream<R, B> flatMapLeft(BiFunction<A, B, Iterable<R>> f);
<R> PairStream<A, R> flatMapRight(BiFunction<A, B, Iterable<R>> f);
<R, S> PairStream<R, S> flatMap(BiFunction<A, B, PairStream<R, S>> f);
// Sorted keeps pairs together, also overrides with Comparators
PairStream<A, B> sortedLeft();
PairStream<A, B> sortedRight();
ImmutableMap<A, B> toMap();
ImmutableMap<A, B> toMap(BinaryOperator<B> reducer);
ImmutableMultimap<A, B> toMultimap();
// Remaining Stream methods that can be adapted directly:
PairStream<A, B> filter(BiPredicate<A, B> p);
void forEach(BiConsumer<A, B> c);
PairStream<A, B> peek(BiConsumer<A, B> c);
PairStream<A, B> distinct();
PairStream<A, B> limit(long maxSize);
PairStream<A, B> skip(long n);
long count();
boolean anyMatch(BiPredicate<A, B> p);
boolean allMatch(BiPredicate<A, B> p);
boolean noneMatch(BiPredicate<A, B> p);
}
```
StreamEx's `EntryStream` seems to have a few nice additional methods that could be added here, too.
Besides the use case for maps, this `PairStream` would also be an elegant solution for the proposed `Iterators.forEachPair` (https://github.com/google/guava/issues/677#issuecomment-288425903).
It does not require any `Pair` class nor any new functional interfaces added to the API. Of course, the common argument against any Pair-related features is that pairs are bad and one should use "proper" classes instead, but I think specifically in this case the counterargument is that having a `PairStream` with methods that take `BiFunction`s and `BiPredicate`s is nicer than having a `Stream<MyDataClass>`, because one can directly access both values in the lambdas. For everyone's info, it seems that JOOQ JOOL is investigating something similar to @PhilippWendler's idea as a class called `Seq2`. Perhaps that might be a source of inspiration or things to avoid for this particular issue?
https://github.com/jOOQ/jOOL/pull/172 Looks like a `Streams.forEachPair()` has been added as of https://github.com/google/guava/commit/8f1a088475b51f03b9f28617893510cc74b82b49. I think @PhilippWendler's idea for a `PairStream` has merit, but if the name puts the Guava team off because of the association with `Pair`, then we could potentially name it `DuoStream` instead. :) @perceptron8 I noticed that you down-voted the idea of a `MapStream`. I'd be interested to hear why you think it's not such a good idea. :) @jbduncan It seems that I checked StreamEx's `EntryStream` only and I found it to be excessively complex, even bloated. I should've pay more attention to OpenGamma Strata's `MapStream` which is nice, simple and - I agree - could be useful.
It's great that you linked `Seq2` PR. Flattened `Pair` is still a `Pair`, just implicit. `PairStream`, `DuoStream`, `BiStream`... different names, same mess.
I withdraw from down-voting the `MapStream`, as it is definitely worth considering. However, I'm still against `EntryStream` and any Pair/Tuple-involving ideas.
Thanks for asking :)
Looks like Google [MG](https://github.com/google/mug) has just released an implementation of a [`BiStream`](https://github.com/google/mug/pull/4) class.
Could you please add `Stream<R> Streams.zipMapEntries(Map<K, V> map, BiFunction<K, V, R> func)` to Guava? I think this would be a worthy addition that does not suffer from any of the open questions for `PairStream`. An alternative would be to add this method to `Maps`, but I think it would be less discoverable there (in `Streams`, people will notice it when they look for `Streams.zip`). Of course, adding an instance method to `ImmutableMap` in addition would also be great.
`zipMapEntries` would only be a shortcut for `map.entrySet().stream().map(entry -> func.apply(entry.getKey(), entry.getValue()))`, but I think it is still valuable because it often allows using method references instead of lambdas that unpack the entries, and because being able to assign names to the key and value parameters in a lambda transports more semantics than just calling `entry.getKey()` and `entry.getValue()`.  Quite simple and will provide at least some capabilities for visualization  Guava is a commonly used library, which nearly all of its users do not need this feature. After all, this feature should instead be done in a separate project at best.
here is example of how our project tried to upgrade to guava 20 from 19 (simple version bump) - https://github.com/checkstyle/checkstyle/pull/3527.
https://teamcity.jetbrains.com/viewLog.html?buildId=917921&tab=Inspection&buildTypeId=Checkstyle_IdeaInspectionsPullRequest
All is that only due to commit: https://github.com/google/guava/commit/f6da31136af15dd324d56d253bc17c5b9afe9759#diff-7ed40f507101a8625df970c98abcbc55
It is used jdk class `javax.annotation.CheckReturnValue` to trigger validation and google custom class `com.google.errorprone.annotations.CanIgnoreReturnValue` to suppress violation.
yes it works for google, but now for others. I think it is not accurate to use different markers for triggering and suppressions. If you want to use errorprones's `CanIgnoreReturnValue` please use smth like `com.google.errorprone.annotations.CheckReturnValue` (non existing class).
but usage of jdk marker/annotation trigger validation process of other tools. Extra dependencies are also not desirable.
It would be better to use `CheckReturnValue` on certain methods as show at - http://errorprone.info/bugpattern/CheckReturnValue.
or to use some friendly(common for all) approaches that other tools can use and ignore that methods.  > by default is important to us,
I hope you understand that guava is library so "us" should be "us and users". In other case popularity of guava will decrease. CIs will not let to upgrade to new version of guava.
I just gave example in simple opensource project.
I posted an note at error-prone team - https://github.com/google/error-prone/issues/475
You are quite demanding for someone who is using great software free of charge. :)
I just want to stress the point that solution should be consistent. It either jdk's annotations or errorprone's . Either way will satisfy community who use other static analysis tools in CIs.
Umm, I may deserve some of the blame here.  I made a feature request for IntelliJ to support `@CheckReturnValue` on classes and packages (previously they supported it on methods only), and they added that feature, but I neglected to ask for `@CanIgnoreReturnValue` support at the same time.  I eventually did ask for `@CanIgnoreReturnValue` support and supposedly that is coming in the next minor version of IntelliJ, 2016.3.  I was hoping that would be released before Guava 20, but sadly it did not work out that way.  Sorry!
See https://youtrack.jetbrains.com/issue/IDEA-158576
@michaelhixson , thank you !
I think we can close the issue and just wait for IntelijIdea 2016.3 release.
Added lastIndexOf(byte[] array, byte[] target) method to Bytes primitive class and its corresponding tests.
It is a fix for the issue #2617 . I signed it!
@luisalduucin You can add these to all the primitive classes.
Added the lastIndexOf method which receives two byte array as parameters for the Bytes primitive class and its corresponding tests.
It is a fix for the issue #2617 . I signed it!
Being public, it always gets into way of our class (import is done automatically by auto-importing tools).
If it's intended to be used by inheritance, then it can be `protected` as well.
If it really neede to be public, then it's better be available through a getter method. I signed it!
Nice addition - to get the count of all occurrences in the map (instead of iterate) No, size() returns the number of keys. I'm interested in the number of values.
If so, the javadocs for `Multimap.size()` should clear up matters for you. :)
Sorry, my mistake. Thanks
Hi all,
I have just downloaded GWT 2.8.0 and guava-20.0 + guava-gwt-20.0.
I added
```
<inherits name='com.google.common.base.Base'/>
<inherits name="com.google.common.collect.Collect"/>
```
to my .gwt.xml file and the jar file in the ant gwtc classpath. Then I cleaned the gwt-unitCache and I enabled the DEBUG logging in the ant `com.google.gwt.dev.Compiler` target.
```
<target name="gwtc" description="GWT compile to JavaScript (production mode)">
<java failonerror="true" fork="true" classname="com.google.gwt.dev.Compiler" maxmemory="512m">
<classpath>
<pathelement location="src"/>
<path refid="project.class.path"/>
</classpath>
<!--arg line="-strict"/-->
<arg line="-war"/>
<arg value="war"/>
<!-- Additional arguments like -style PRETTY or -logLevel DEBUG -->
<arg line="-logLevel"/>
<arg value="DEBUG"/>
<arg line="${gwt.args}"/>
<arg value="com.mycompany.mywebapp.MyWebApp"/>
</java>
</target>
```
When processing Guava-GWT Java files, the processor complains about missing annotations:
> Line 20: The import com.google.errorprone cannot be resolved
> Line 23: The import com.google.j2objc cannot be resolved
Also adding `<inherits name='java.lang.Lang'/>` to the module definition does not help ([see this stackoverflow topic](http://stackoverflow.com/questions/40360901/gwt-2-8-throws-exception-when-compiling-with-guava-20))
Warning on eclipse ,
`
Bound mismatch: The generic method cast(Class<T>, B) of type MutableClassToInstanceMap<B> is not applicable for the arguments (capture#8-of ? extends Class<? extends B>, capture#12-of ? extends B). The inferred type capture#10-of ? extends B is not a valid substitute for the bounded parameter <T extends B>
` I signed it!
link-local address validation with percent and scope id I signed it
policy and ImmutableSet not and a list created by ImmutableSet.asList
needs to be serialized
fixes #1841
I signed it!
I signed it!
policy and ImmutableSet not and a list created by ImmutableSet.asList
needs to be serialized
fixes #1841
`Files.readFirstLine(File, Charset)` and `LineReader.readLine()` are documented to possibly return `null`, but these methods are not annotated with `@Nullable`, and I think they should be.
These methods are public and final and they don't override any super method.  I can't imagine that adding the `@Nullable` annotation could cause any harm.
##
Side note:  I am trying gauge interest in adding more `@Nullable` annotations throughout the codebase.  These methods seem like the safest, most obvious candidates, but there are other candidates.  If you all aren't interested in marking these `@Nullable`, then I won't pursue the issue further.
No worries.  I hope the failures were false positives!
The javadoc for Function.equals has an invalid `{@object}` tag in the first sentence:
```
/**
* <i>May</i> return {@code true} if {@object} is a {@code Function} that behaves identically to
* this function.
*
```
I'm sure that was supposed to be `{@code object}`.  As it is now, the word "object" does not appear in the rendered javadocs and it reads like "May return true if is a Function that..."
The same issue exists in the javadocs of a few non-public APIs, in case you want to fix them:
- `{@from}` in InternetDomainName.validateSyntax
- `{@count}` in PairedStats constructor
As it turns out, since I originally posted #2411, the needs for my university project evolved a bit, as I realised I really needed a directed acyclic graph (DAG) rather than a tree.
I believe JGraphT provides an implementation of a DAG, but despite that I decided to settle on Guava 20-rc1 and `common.graph` recently (on one hand because I had licensing worries with JGraphT, and on the other hand because I think `common.graph` is currently a much cleaner alternative to both JGrapht and JUNG), so I would be excited to see DAG support in say `(Graph|ValueGraph|Network)Builder`, in a method like `supportsCycles(boolean)`, so I don't have to implement cycle-checking support myself anymore.
Glad to hear you like common.graph!
This is one thing we considered as an option on the *Builders, but is not in the current release because it requires either A) additional memory overhead (e.g. a UnionFind type data structure kept in sync with the graph) or B) a much slower addEdge() method (checking for a cycle on each add).
There is Graphs.hasCycle(), which if you called after every mutation is closer to the second solution.
I still highly recommend using common.graph rather than rolling your own. Especially in light of some research I did:
A disjoint-set/union-find data structure is sufficient for maintaining an **undirected** acyclic graph with some memory overhead but virtually (ignoring the inverse Ackermann function) no time overhead for adding edges. Although that's assuming insertions only (no deletions). However, even if we ignore the possibility or removing edges for now, the **directed** acyclic case is much harder. Maintaining the acyclic guarantee in real-time (that is, with each edge addition/remove) is an open problem in Computer Science with no known efficient algorithm:
http://cstheory.stackexchange.com/q/5179
Compared to the current O(1) runtime for adding edges, all currently known algorithms have unacceptable runtime to be part of a graph library in my opinion.
Common.graph is of course perfectly capable of representing DAGs (and in fact, many of its uses inside Google are DAGs), it just won't maintain the _acyclic_ guarantee. However, if you're able to build up the entire graph at once, a good approach is to do so and then assert that `Graphs.hasCycle()` is false.
PS: There is currently an internal version of `List<N> topologicalOrdering(Graph<N> graph)` (where `graph` is a DAG), which we're hoping to add to Guava in v21.
@Bezier89 Regarding maintaining acyclic guarantees in real-time, have you read http://homepages.mcs.vuw.ac.nz/~djp/files/PK-JEA07.pdf?
Oh woops! Thanks for your feedback @jrtom. That'll teach me to actually _read_ a paper before sharing it with others. :P
@jrtom Is it possible to make an `ImmutableDirectedAcyclicGraph` that implements `DirectedAcyclicGraph`? An immutable one would be possible and it can be simply created via a `GraphBuilder` or from another graph.
Provide a list to check whether the order of a list is possible; provide a comparator to form a list.
- Provide a `List<N>` of nodes to check whether such a topological order is applicable on this DAG;
- Provide a `Comparator<N>` to generate a `List<N>` representing the topological order. The comparator is used to determine which node to be added first when there are multiple nodes with an in-degree of zero.
Ah, okay, I was kind of hoping no-one would ask. As it turns out, after thinking about it some more and discussing it with my supervisor, I realised I didn't need a DAG after all - just a regular tree! So I'm actually not using a DAG in my project anymore. :P
I originally thought I needed a DAG because I imagined there would be scenarios where two directed branches moving outwards from the root of my "tree of messages" (https://github.com/google/guava/issues/2411#issuecomment-193399619) would need to merge back together into a single directed branch. If that were the case, a DAG would've let me model this easily, but soon afterwards I realised that branches never do merge back together (for technical reason(s) which aren't easy for me to pin down).
In package `collect`, there is a class called `SortedLists` which assume input `List`s for the methods in the class are all sorted. Is it possible to create a helper class like that one, probably called `DirectedAcyclicGraphs`?
For the default `hasCycle` implementation, we can use Java 8 default methods for interfaces.
So is a class called `AcyclicGraphs` possible to prevent such duplicates? Users need to guarantee that their graph does not have cycles before calling methods in that class.
Yes
Indeed. DAG will hang on. But how about topological ordering functionality? That one is commonly used.
It is actually DAG related. See [Wikipedia](https://en.wikipedia.org/wiki/Topological_sorting):
![image](https://cloud.githubusercontent.com/assets/7806504/20235628/dcf4e184-a84b-11e6-97c2-21edb33c972c.png)
That sounds fair enough to me. Thanks for taking the time to contribute to the earlier discussion @jrtom!  http://www.gwtproject.org/release-notes.html#Release_Notes_2_8_0
That's not a typo; it means "if and only if".
But then again, it's not a word I've personally seen used in _any_ context apart from Guava and [Spotless](https://github.com/diffplug/spotless), and I'm a born Englishman. (Is it a word that originated in the US perhaps?)
So I think it's worth replacing all occurrences of "iff" with "if and only if" in the javadocs, if only to make things explicit and clearer.
Maybe the term is more common in mathematics and logic. I'm not a native speaker and I thought it was actually quite well known.
Personally I like its brevity, but I recall seeing a PR to "fix" a similar typo in some other project a few months ago. So indeed, a case can be made that it's better to be explicit.
Thanks for opening this. Our not-well-enforced policy has been to never use "iff" (or "e.g.", or "i.e.", or really most abbreviations) in our javadoc.
The `ByteArrayByteSource` implementation of `ByteSource` passes its internal array to objects provided by the user, thus allowing the user to modify the data within the `ByteSource`. This directly contradicts the `ByteSource` javadoc which claims that:
> it is an immutable _supplier_ of `InputStream` instances.
The following methods display this issue:
- `ByteArrayByteSource.copyTo(OutputStream)`
- `ByteArrayByteSource.read(ByteProcessor)`
- `ByteArrayByteSource.hash(HashFunction)`
This clearly involves unexpected implementations of the parameter objects. It should be noted that neither `OutputStream` nor `ByteProcessor` javadocs even suggest that input data should not be modified. `HashFunction` does indicate that implementations should be pure functions, and goes so far as to specify that input data should not be modified, however enforcing that is obviously not possible.
A sample class which demonstrates this issue is below:
``` java
public final class Main {
public static void main(String[] args) throws IOException {
final ByteSource byteSource = ByteSource.wrap(new byte[]{0, 0, 0, 0});
byteSource.copyTo(new OutputStream() {
public void write(final byte[] buf, final int off, final int len) {
for (int i = 0; i < buf.length; i++) {
buf[i] = 2;
}
}
public void write(final int b) {
throw new UnsupportedOperationException("write has not been implemented");
}
});
System.out.println(Arrays.toString(byteSource.read()));
}
}
```
There is a fix possible by cloning the byte array while copying. I will submit a PR soon.
Similar case is #1855, where internal arrays are also not guarded against malicious code.
An alternative to defensive copies would be to pass bytes to the recipient individually, though that would also incur a performance penalty.
I am in favour of simply adding some documentation to warn of potential misuse. The performance hit of a defensive copy would be frustrating.
Using `Maps#subMap` from #1907 on a `TreeMap` twice instance causes IllegalArgumentException "fromKey out of range", when the latter range is coarser than the first one:
``` java
TreeMap<Integer, Boolean> treeMap = new TreeMap<Integer, Boolean>(ImmutableMap.of(1, false, 2, false, 3, false, 4, false, 5, false));
Maps.subMap(Maps.subMap(treeMap, Range.closed(2, 4)), Range.closed(1, 5));
```
My use case is to apply restrictions (sometimes based on userinput) on a `TreeMap<Long, ?>` (where `Long` corresponds to timestamps) at different spots in the application.
Tested w/ d67899df652c8a889c578a53a639d4c399925e2c.
You might consider keeping track of the original `NavigableMap` and the current `Range`, and intersecting the `Range` as you receive new input, e.g.
```
public class MapViewport<K extends Comparable<? super K>, V> {
private final NavigableMap<K, V> map;
// constructor
// setters for range such as intersection, union, and set
public NavigableMap<K, V> getView() {
return Maps.subMap(map, range);
}
}
```
This has the added advantage of avoiding constructing recursively nested views.
Thank you both for taking the time to investigate this behavior. I agree that it is a JDK issue and documented behavior.
The entry https://github.com/google/guava/releases/tag/v20.0-rc1 points the change log of Guava 19.0 instead of Guava 20.0
The documentation for [Quantiles.ScaleAndIndex.computeInPlace()](https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/math/Quantiles.ScaleAndIndex.html#computeInPlace%28double...%29) has the wrong description of the return value; from the other methods in the class, it looks like it should say "the quantile value", not "an unmodifiable map of results: the keys will be the specified quantile indexes, and the values the corresponding quantile values".
It looks like maybe this is a copy/paste error from copying this from [Quantiles.ScaleAndIndexes.computeInPlace()](https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/math/Quantiles.ScaleAndIndexes.html#computeInPlace%28double...%29).
I think this is done, I'll let @cpovirk confirm.  HelloI write a test code
```
cache<String, Integer> cache =
CacheBuilder.newBuilder()
.expireAfterAccess(10, TimeUnit.SECONDS).build();
cache.put("test", 1);
Thread.sleep(5000);
// output 1:1
System.out.println(cache.size() + ": " + cache.getIfPresent("test"));
Thread.sleep(10000);
// output 1:null
System.out.println(cache.size() + ": " + cache.getIfPresent("test"));
```
The cache doesn't update its size after the key expired, it's a bug or others?
Thanks & Regards.
Gwt 2.8 compiler return the following error
`[ERROR] Errors in 'jar:file:/home/paolo/.m2/repository/com/google/guava/guava-gwt/20.0-SNAPSHOT/guava-gwt-20.0-20161005.174957-374.jar!/com/google/common/collect/ConsumingQueueIterator.java'
[ERROR] Line 33: No source code is available for type java.util.ArrayDeque<E>; did you forget to inherit a required module?`
All works with latest release  Use micro sign for microsecond unit.
This PR seems to be a subset of #2592 and should be closed?
The current symbol for microseconds is **s** (Greek),  The correct symbol would be **s** (SI).  The current rendering is in error.  Moreover, it does not print on an 8-bit console unless the code page is Greek.
http://www.unicode.org/reports/tr25/
On Thu, Oct 6, 2016 at 1:51 PM, Christopher Yeleighton <
notifications@github.com> wrote:
> The current symbol for microseconds is _s_ (Greek), The correct symbol
> would be _s_ (SI). The current rendering is in error. Moreover, it does
> not print on an 8-bit console unless the code page is Greek.
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> https://github.com/google/guava/issues/2593, or mute the thread
> https://github.com/notifications/unsubscribe-auth/AA5Cl3ANpEZB4PNBAPGUUF6nac7mdWPEks5qxV9fgaJpZM4KQZud
> .
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
U+03BC  is the preferred character in a Unicode context.  Stopwatch should be usable in a non-Unicode context.  In our case, we get ?s in the log.
Can you convince us that there exists such a thing as a "non-Unicode context"? I've never heard of that before, just software that was broken or misconfigured and needed to be fixed.
In other words, our attitude has been "Unicode (and UTF-8) everywhere" for a long time and it's seemed to serve us well.
@kevinb9n: Windows cmd? I'd say that's the prototypical example. :smile:
(I _do_ know it's hardly a good terminal, but it's still used in Windows contexts, and I think Microsoft have so far refrained from changing its encoding to, say, UTF-8, to preserve backwards-compatibility.)
Hmm, good point @kevinb9n.
For Windows users, I suppose the workaround for this is to use a non-cmd terminal like PowerShell or Cygwin. (I presume they decode bytes as UTF-8 out-of-the-box, but I've not checked.)
**Edit:** Assuming, of course, it's feasible to do so.
I do not think we would receive the opposite report any time soon.  The problem of **?s** vs **s** is several orders of magnitude above the problem of **s** vs **s** in terms of severity.
The workaround is to write a wrapper around Stopwatch that replaces **** with **** in toString.  Not nice, especially because your Stopwatch is final for whatever reason.
The fact that the TR mentions the Unicode context explicitly implies that non-Unicode contexts exist too.  So, if you believe the TR, you have to take that for granted.
BTW, Microsoft PowerShell hangs on console input when executing a binary executable, so it is not a general replacement.
We don't want to devote time to studying these characters. We want a reference that clearly shows which one is better and we want to just go with that. It seemed like we found it.
(Note: if it's true that some program deliberately doesn't embrace UTF-8, then Guava may or may not work well with that and we really can't be concerned about that. Google's position for a long time has been that UTF-8 is the canonical and superior character encoding for the modern world.)
Can't you use the following?
```
stopWatch.toString().replace("\u03BCs", "\u00B5s");
```
@ogregoire: I use similar code in the wrapper.
@kevinb9n: In practice, **** is supported by ISO8859\* and EBCDIC character sets but not by IBM code pages, in which case it should be rendered as **u**.  But IBM code pages do not support **** either.
We can map SI **** to **u** in the character renderer but we cannot map Greek **** to **u**; it would be very inappropriate to do so as it would conflict with the normal rendering as **m**.
The micro sign is a different character than Greek small letter mu.  The current rendering is in error.  Moreover, it does not print on an 8-bit console unless the code page is Greek, which is insane.
See #2593 for a discussion on this change.
Hi,
I read that you plan on adding JDK8 support in version 21. I want to bring your attention to https://bitbucket.org/cowwoc/guava-jdk8/ which I authored a few months ago.
Feel free to borrow design ideas and/or code sniplets for your upcoming release.
Thanks for this tip. I'm sorry to say that we've done a large amount of
work on this that you just haven't gotten the chance to see yet. :-( We're
trying to get 20.0 out the door and then dump this code out to you. When
that happens, we'd appreciate your suggestions for making it better.
wrote:
> Hi,
>
> I read that you plan on adding JDK8 support in version 21. I want to bring
> authored a few months ago.
>
> Feel free to borrow design ideas and/or code sniplets for your upcoming
> release.
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> https://github.com/google/guava/issues/2591, or mute the thread
> https://github.com/notifications/unsubscribe-auth/AA5Cl-C8rKtJFOFSXwInWpz3Sht2GQeJks5qxTOKgaJpZM4KQOOt
> .
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
I just wrote this up really quickly. I assume that you have an even better, more efficient version, in the works: https://medium.com/@robertmassaioli/an-immutablemultimapcollector-for-guava-3f141f9040f#.m18fnmgwo
I'd be interested in seeing a map stream class in a similar vein to OpenGamma Strata's [MapStream](http://strata.opengamma.io/apidocs/com/opengamma/strata/collect/MapStream.html) or StreamEx's [EntryStream](https://amaembo.github.io/streamex/javadoc/one/util/streamex/EntryStream.html).
I don't have any uses for such a class yet, but I imagine it would be useful if one needs to do something where they'd either need to use deep-nested chaining of the functional methods in `common.collect.Maps` or `map.entrySet().stream()`, both of which in my opinion are a bit clunky.
@cpovirk I realise that your invitation for particular suggestions was probably aimed at @cowwoc, so would you prefer that I raise my MapStream suggestion above as a new issue?
Please let me know if you create a separate issue. I will add my comments there. Thank you.
@cowwoc If there are any noteworthy things in your library that you'd like Guava to consider (or you still have any other comments you'd like to share), I suggest creating a new issue rather than waiting for @cpovirk to create one that may never come. :)
Example:
```
ImmutableSetMultimap<Integer, String> sortedMultimap = Stream.of(10, 20, 40, 30, 15).
map(i -> i / 10, i -> Integer.toString(i)).
asImmutableSetMultimap().
sortKeys((a, b) -> b.compareTo(a)).
sortValues((a, b) -> b.compareTo(a)).
build());
```
My API still offers the static factory methods that others have implemented but for improved readability or advanced use-cases, I recommend the builder pattern.
Also, notice the way it's implemented users are guided forward by a multi-step DSL. At each step of the DSL, code-complete will offer a different set of methods until a terminal method is invoked.
Ah I see, looks rather interesting to me. I especially like the DSL-y, aids-with-code-completion idea!
However I still think it's worth creating a new issue with this builder-pattern-based collector idea as the topic, as this issue is currently closed and the Guava team may never visit it again.
@jbduncan Done: https://github.com/google/guava/issues/2640
```
Presentation slides focusing on base, primitives, and io
Presentation slides focusing on cache
Presentation slides focusing on util.concurrent
```
It'll be nice to fix the links to the correct path. :)
InetAddresses.isInetAddress("fe80::8b2:d61e:e5c:b333%15") returns false for a valid IPv6 address. Does this method not support Link-Local IP address?
Why does your string ends with "%15"? Is that a typo?
Number after '%' is scope id. Please see following link for more details -
http://superuser.com/a/99753
I see. Thank you. I looked at the code and tests, and it looks like link-local addresses with zone indices are not supported.
(Assuming I or someone issues a PR) Is there a reason why it is not supported?  My old account is being link to my new account my old was hacked one to many times
Sound could is try to link back to me
Ooh, really looking forward to this.
No pressure! :wink:
According to IntelliJ, these usages of StringBuilder can be simplified. By my understanding, this is because they do not contain any loops, and thus, as of Java 6, JVMs are able to optimize these concatenations into more-efficient StringBuilder calls at compile time. Thus this change improves readability without losing performance.
All code which initializes an IOException with a cause exception now uses the appropriate constructor (which was introduced in Java 6), rather than initCause. Since Guava now depends on Java 6, this (as far as I can tell) is a safe change to make.
A change was made from using an Iterator to an enhanced for-loop for (arguably) improved readability and, by my understanding, no performance impact.
All other changes should hopefully be self-explanatory. :)
I signed it!
i can't get access to the class of Constraint or Constraints, the compiler said they are not public. So how can i use these classes under a new java project?Any help guys?
`Constraint(s)` has, to the best of my knowledge, always been non-public. I don't really know why it was included in Guava to begin with, but you're not supposed to use it yourself - Guava itself uses it for implementation purposes only.
The recommended way of doing what `Constraint` does is to either use `Preconditions` or, if `Preconditions` makes your code difficult to read or it simply doesn't meet your needs, use combinations of if statements and exception throwing as you normally would.
In that case, I'd strongly recommend that you read the Guava [user guide](https://github.com/google/guava/wiki) and explore the javadoc (latest version [19.0](http://google.github.io/guava/releases/19.0/api/docs/)), as they will introduce you the sorts of things which Guava can do for you in a nice, readable fashion.
I presume you already know how to actually use Guava itself with a build tool like Maven or Gradle or within your IDE? If not, you may need to search for a tutorial on how to get Guava set up, as I believe the README assumes you're already familiar with how to do so.
Sure thing, i will have a try : )
:+1:
Maybe it was public in an earlier version of Guava? Or maybe the person you saw created a package called `com.google.common.collect` in their app, put a class there, and called `Constraints` from within that class.
I believe that's legal Java, because `Constraints` is only package-private (not completely private), and so his class would have _technically_ been in the same _package_ as `Constraints` and been able to access it, even though the 2 classes would've been in different directories.
**But this is really bad practice, so don't do it in your own code.** :wink:)
I'm using guava16.0.1 on cdh(cloudera).But when I call `Queues.newArrayDeque()` it shown me this error:
``` bash
Exception in thread "main" java.lang.NoSuchMethodError: com.google.common.collect.Queues.newArrayDeque()Ljava/util/ArrayDeque;
at com.github.fge.jsonschema.processors.validation.ValidationStack.<init>(ValidationStack.java:70)
at com.github.fge.jsonschema.processors.validation.InstanceValidator.<init>(InstanceValidator.java:87)
at com.github.fge.jsonschema.processors.validation.ValidationProcessor.process(ValidationProcessor.java:54)
at com.github.fge.jsonschema.processors.validation.ValidationProcessor.process(ValidationProcessor.java:34)
at com.github.fge.jsonschema.core.processing.ProcessingResult.of(ProcessingResult.java:79)
at com.github.fge.jsonschema.main.JsonSchema.doValidate(JsonSchema.java:76)
at com.github.fge.jsonschema.main.JsonSchema.validate(JsonSchema.java:109)
...
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:498)
at org.apache.spark.deploy.SparkSubmit$.org$apache$spark$deploy$SparkSubmit$$runMain(SparkSubmit.scala:731)
at org.apache.spark.deploy.SparkSubmit$.doRunMain$1(SparkSubmit.scala:181)
at org.apache.spark.deploy.SparkSubmit$.submit(SparkSubmit.scala:206)
at org.apache.spark.deploy.SparkSubmit$.main(SparkSubmit.scala:121)
at org.apache.spark.deploy.SparkSubmit.main(SparkSubmit.scala)
```
Having this same problem. Just updated my version of Guava to the latest, 20.0 and still happens.
Not using Cloudera. Just trying to use validator in a servlet.  We are using Google Commons APIs in our project and security scan on our code has reported following problem. Could you please let me know if this is of any concern or it can be fixed in new version of this API.
**Problem:** The application fails to release (or incorrectly releases) a system resource before it is made available for re-use. This condition often occurs with resources such as database connections or file handles. Most unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, it may be possible to launch a denial of service attack by depleting the resource pool.
**Recommendations (Generated by tool)**
When a resource is created or allocated, the developer is responsible for properly releasing the resource as well as accounting for all potential paths of expiration or invalidation. Ensure that all code paths properly release resources
Class:
com.google.common.io.Files
This is the complete information that the tool provides.
It relates to improper closing of connections that are created in the class com.google.common.io.Files.
After looking at the Files class, I came to a conclusion that java doc of Files should be updated to say that users of the API are responsible for closing resources. Secondly, I think the tool is reporting correctly since the class opens files but does not close them. So @venusjain10 , look at places where the Files API is used and check if the resources are closed properly and you should be OK. And for guava, someone should update the java doc.
We are using google commons APIs in our project and security scan on our code has reported following problem. Could you please let me know if this is of any concern or it can be fixed in new version of this API.
**Problem:** Creating and using insecure temporary files can leave application and system data vulnerable to attack. In particular,file names created by the tmpnam family of functions can be easily guessed by an attacker. If an attacker can predictthe filename and create a malicious collision, he may be able to manipulate the behavior of the application.
**Recommendations (Generated by tool)**
Class:
com.google.common.io.FileBackedOutputStream
I have not used the class FileBackedOutputStream directly. However I am not sure if the classes that we have used from the API internally use FileBackedOutputStream.
We are using google commons APIs in our project and security scan on our code has reported following problem. Could you please let me know if this is of any concern or it can be fixed in new version of this API.
**Problem:** Standard random number generators do not provide a sufficient amount of entropy when used for security purposes. Attackers can brute force the output of pseudorandom number generators such as rand().
**Recommendations (Generated by tool)**
If this random number is used where security is a concern, such as generating a session identifier or cryptographic key, use a trusted cryptographic random number generator instead
com.google.common.cache.Striped64
Can you provide some link that provides details information of randomness prediction and control?
I need to understand how do I make sure that the randomness is Controlled and predictable as I have not invoked the Striped64 class directly in my application code.
And in case I am looking for optimized code, what is my option? The issue is that the code scan has reported it as a major problem.
I was just trying to confirm that the API internally does not use the class for security purposes. i understand that is not the case. Thanks for your help!
If there's a plan to implement this method in ImmutableMap.Builder, I'm happy to send a CL.
Yep, we're using copyOf on a hash map. Thought I'd save some memory,
though.
The links at https://github.com/google/guava/wiki/HashingExplained#hashing are referring to 12.0 docs meanwhile the links in other sections above are referring to snapshot version.
I wasn't able to find an issue for this, so apologies if this has been raised already.
If not, this seems to be a pretty important medium-to-long-term thing to look into, as Guava currently uses sun.misc.Unsafe in a number of places, which by my understanding would prevent Guava from being used in Jigsaw-enabled versions of Java, including Java 9.
On Wed, Sep 21, 2016 at 12:36 PM, Jonathan Bluett-Duncan <
notifications@github.com> wrote:
> I wasn't able to find an issue for this, so apologies if this has been
> raised already.
>
> Has Guava been tested with any of the early-access Java 9 and/or Jigsaw
> releases yet?
>
> If not, this seems to be a pretty important medium-to-long-term thing to
> Jigsaw-enabled versions of Java, including Java 9
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> https://github.com/google/guava/issues/2571, or mute the thread
> https://github.com/notifications/unsubscribe-auth/AA5Cl6sN5NjLotWT34upHBri7CQqC54Aks5qsYcpgaJpZM4KDMZj
> .
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
Yes, that's true actually!
However, I think the fallbacks work on the assumption that sun.misc.Unsafe is a class which exists and which can be made accessible by reflection, which I believe has been "fixed" in Jigsaw by either removing sun.misc.Unsafe completely or moving it to a jdk-internal module which can only be accessed with a command-line argument. If I'm mistaken on this, then I'd be more than happy to be proved so. :)
But despite all this, I still think it's important to test Guava against Java 9 and Jigsaw if it's not been done so already, in case there are other crucial areas where backwards-compatibility has been broken and would otherwise prevent open source Guava's uptake by Java 9 users in the future.
Ah, I see.
We'll be receptive to specific fix requests, but probably won't be able to put much thought into this ourselves until we get to the point of testing migrating ourselves to Java 9.  (Bear in mind we finally successfully moved to Java 8 last week! But Java 9 should definitely be a quicker project.)
Ah yes, I learned about your successful migration to Java 8 the other day. Congratulations!
Going back to the subject of Java 9 though, you may very well be right about it being quicker to migrate to than Java 8.
On one hand, it'll help that with the release of [MRJARs](http://openjdk.java.net/jeps/238), one can have build artifacts that continue to use internal APIs like com.sun.\* on Java 8 but use officially supported replacements on Java 9+. But on the other hand, if there are places in Guava where com.sun.\* is vital and Oracle have not provided sufficient replacement APIs, then Guava may end up being stuck on Java 8, which concerns me.
I'm also concerned by how OpenJDK 9 has, at the time of writing of me writing this, gone past the Feature Complete milestone, which may make improving the replacement APIs difficult if needed.
What are your thoughts on this @kevinb9n?
Also, whereas I don't feel qualified enough to _thoroughly_ test Guava against Java 9 & Jigsaw and to talk to Oracle in your stead (as I'm not familiar with all of Guava's intricacies), I _am_ more than happy to run Guava against Java 9 and reply back to this issue if I discover anything. Would you be happy if I did this @kevinb9n?
According to `jdeps -jdkinternals`, Guava only relies on `sun.misc.Unsafe`, which has been mostly replaced by [variable handles](http://openjdk.java.net/jeps/193) in Java 9. There might be some other things that are different but not explicitly depended on. I'm going to try making a fork of Guava that uses Java 9 as it's JDK requirement and run my small projects on that for testing.
I just ran `jdeps -jdkinternals` using jigsaw-jdk-9-ea+136_windows-x64_bin on my copy of Guava, and it seems that `sun.security.jca.{ProviderList, Providers}` and `sun.misc.FpUtils` are used in test code as well. But I'm not so concerned about that, because the tests which use those APIs are more-or-less one off cases, and it looks like they can be changed, disabled or removed if needed.
I also did a half-thorough search of the Guava non-test codebase, and it seems that @kevinb9n was actually right, and I was wrong!
Although using `sun.misc.Unsafe` on a JVM which doesn't have that class would cause exceptions/errors to be thrown by the Guava classes that use it, it seems the exceptions _do_ get caught _eventually_, higher up all the potential call chains, by other Guava classes, and that viable alternatives would be used whenever they happen.
So it seems this issue is actually not as urgent as I first thought it was! :stuck_out_tongue_closed_eyes:
I also just ran through `master` and replaced all the usages of `Unsafe` with `VarHandle`. The code looks much cleaner, and it was a quick & easy transition. So handling this when Java 9 is released probably shouldn't be too much of a hassle.
@kenzierocks Thanks for looking into that.
So I suppose this would only be urgent then if Guava starts having users who try to _compile_ the Guava sources or tests with JDK 9+ and they find that certain `sun.*` classes which Guava depends on have been removed. But we won't really know until Maven supports Java 9.
I also don't know enough to know exactly which classes have been planned for removal/module encapsulation in JDK 9 and which are just deprecated (jdeps doesn't seem to give me the whole picture here), so more research would be needed.
The transition might be made even easier by the lexicographical [`Arrays::compare`](https://bugs.openjdk.java.net/browse/JDK-8033148) methods, which could potentially be used to implement or replace `UnsignedBytes.lexicographicalComparator`.
I found this use of an internal JDK field which doesn't work on Java 9.
https://github.com/google/guava/commit/b5b4b40a9c17484828dbd7ceb28e0a468dad0b75#commitcomment-20536128
There's a fallback, but it just does nothing. Is that a problem? What goes wrong if we use the fallback? Filed https://github.com/google/guava/issues/2920 (SGTM, @eamonnmcmanus. Many thanks in advance!)  If you call hasLowerBound()/hasUpperBound() without checking for null you are getting a NPE if the Range itself wasn't initalized. It should return false if the lower/upper Endpoint is null.
`
public boolean hasLowerBound() {
return lowerBound != Cut.belowAll();
}
`
https://github.com/google/guava/wiki/CollectionHelpersExplained
I read it, but I don't quite get it.
``` java
@Override public boolean addAll(Collection<? extends E> c) {
return standardAddAll(c); // implements in terms of add
}
```
How do you know that `standardAddAll` calls `add`?  Do you go read the source code?  Is it part of the contract in a doc I missed?
The reason I ask is that I'm trying to do the same making a "virtual" table, and I'm not sure in how many places I need to override the calls if I'm creating my own columns.  columnMap?  columnKeySet?  All methods with the word "column" in them?
Reading this particular paragraph...
"A sensible definition of addAll(java.util.Collection<? extends E>) in terms of add(E). If you override add(E), you may wish to override addAll(java.util.Collection<? extends E>) to forward to **this implementation**."
I'm reasonably sure it refers to `standardAddAll`, but somehow the wording is throwing me off a bit; it's as if "this implementation" could refer to `add` instead.
Wouldn't it be better to reword the paragraph like so?
"A sensible definition of addAll(java.util.Collection<? extends E>) in terms of add(E). If you override add(E), you may wish to override addAll(java.util.Collection<? extends E>) to forward to `standardAddAll`."
(Or would most people understand the original paragraph, and is it just that my... sense?... of the English language a bit unusual? :wink:)
I can describe what I was trying to do, and maybe that example will help clarify if the wording needs tuning.
I've got a table that fits in my allowed memory.  It has a special column "pixels" that has some poorly encoded image data, as well as other regular columns.
I'd like to "pretend" to all downstream consumers that the table doesn't have a column "pixels", but instead actually has (virtual) columns pixel.1, pixel.2... pixel.484 that map to that cell's specific offset pixel value.  (I can read the entire column and find the max pixels to find the 484 limit)  In my first naive attempt I blew it out to 484 additional columns, but that hit a memory limit.  So I read up on ForwardingTables, and it sounded perfect for these sort of "virtual" columns.
But then I ran into this paragraph, and started wondering how many places I would have to override for the virtual columns to be consistent across all method calls - if I had to do    `containsColumn` as well as `column` as well as `columnMap` etc.
On Travis there appears to be a warning regarding a forked jvm. An example build is https://travis-ci.org/google/guava/jobs/143991838#L5029
> [INFO] Running com.google.gwt.junit.tools.GWTTestSuite@53d5264c
> [WARNING] Forked JVM has been killed on time-out after 600 seconds
This seems to be happening on all builds and I can also reproduce this error locally running on Ubuntu 16.04.
Sadly the errors have returned after commit https://github.com/google/guava/commit/c298e2dcfed6c3f42407477b9fc6fc5094d88468, see builds https://travis-ci.org/google/guava/jobs/161959726#L5083 and https://travis-ci.org/google/guava/jobs/161705406#L5065
Javadoc at FluentIterable#isEmpty() says:
"Determines whether this fluent iterable is empty."
However, in reality it checks whether underlying iterator is exhausted yet and never checks for emptiness. Either the method  behaviour or the javadoc is misleading.
update source
Typo fix - link -> line.
I signed it!
Ah, it was, I've done another one now, it seems you can't change the email address on the CLAs. Hopefully it can support two for the same github account. It's a lot of work to fix a single character in the documentation....
To continue the conversation I started at https://github.com/google/guava/commit/0f0f616ef7962d97748e2b1bbbd539e96dcbc7b4#commitcomment-18709801, I found a potential replacement for lines 76-84 which both removes the need to copy `reachableNodes` set into an `ImmutableList` and, like the current solution, carefully avoids iterating over all reachable nodes within the inner loop unless necessary.
``` java
...
Set<N> reachableNodes = reachableNodes(graph, node);
visitedNodes.addAll(reachableNodes);
Iterator<N> outerIterator = reachableNodes.iterator();
for (int a = 0; outerIterator.hasNext(); a++) {
N nodeU = outerIterator.next();
for (N nodeV : Iterables.limit(reachableNodes, a + 1)) {
transitiveClosure.putEdge(nodeU, nodeV);
}
}
...
```
However, although I'm reasonably certain that the above solution uses less memory and runs faster than the old one for sufficiently large graphs, I've not actually created any benchmarks (JMH or otherwise) or done any profiling to prove so.
When I run all of the tests under `com.google.common.graph` (including some new ones which I wrote myself and put under my local copy of `GraphsTest.java`) with the above code change applied on my Windows machine, they all pass without any problems.
Has the Guava team already considered a solution like this? If not, would it be worthwhile for me to submit a Pull Request for this?
We have gone ahead and made this change, and it should show up soon.  Thanks for the suggestion, @jbduncan!  :)
Oh wow, fantastic! How thrilling! :blush: :grin:
I look forward to seeing it pop up in source code.
Will I be given credit in the commit message or somewhere else when it rolls in?
I ask because since I didn't actually submit a PR, it I doubt it'll credit me as the author in GitHub's records.
I did mention your name in the change description. I don't believe GitHub
will register you as the author though (but if that's important I'm sure
there's a way to do it).
On Sep 13, 2016 8:47 AM, "Jonathan Bluett-Duncan" notifications@github.com
wrote:
> Will I be given credit in the commit message or somewhere else when it
> rolls in?
>
> I ask because since I didn't actually submit a PR, it I doubt it'll credit
> me as the author in GitHub's records.
>
> 
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> https://github.com/google/guava/issues/2563#issuecomment-246726663, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/AGCCk59wBO-cjQXAj69xJWL_cBSqD1SYks5qpsWggaJpZM4J6BoU
> .
@jbduncan You're mentioned in the commit message ("Credit to jbduncan for the idea").  :)
@Bezier89 @jrtom If I could be registered as the author then that would be great. If not, then as long as I'm given credit in the commit message then that's fine with me too. :)
if there is still bytes to read.
CLA signed.
After examination of the javadoc, the current behavioir is not a bug:
> An attempt is made to read as many as `len` bytes, but a smaller number may be read.
It is just that the code that exposed bad behavior did not use `com.google.common.io.ByteStreams#read` or equivalent.
Updated email address
Presently we are tightly coupled with log2 method to enforce the method contract "@throws IllegalArgumentException if {@code x <= 0}"
I'm following fail fast concept at this place. If we know that for non positive values of x this method is going to fail we can fail it even before calling log2 method.
Please review [NewCollectionTypesExplained#multimap](https://github.com/google/guava/wiki/NewCollectionTypesExplained#multimap`).
Search for "mapping from unique keys to collections of values".
In NewCollectionTypesExplained.md there is:
> a -> [1, 2, 4]
> b -> [[3|3]]
> c -> [[5|5]]
that was likely supposed to be:
> a -> [1, 2, 4]
> b -> [3]
> c -> [5]
Thanks!
I signed it!
I haven't, sorry! Shame on me :(
As detailed in issue #2554 there was a bug in com.google.common.collect.testing.Helpers#isEmpty when passed an Iterable that is not a Collection.
Added a test that fails before the patch, succeeds after.
Fair enough! Thanks for the direction.
```
public static String toString(Iterable<?> iterable) {
return Iterators.toString(iterable.iterator());
}
```
```
public static String toString(Iterable<?> iterable) {
if (iterable == null) {
return "null";
}
return Iterators.toString(iterable.iterator());
}
```
Currently I have a very complex object that I can't toString() because some field in its fifth hierarchy uses this toString() and I get a NPE.
Hi, I can't control the types inside the nested iterables.
1) Do you mean that there might be some consumer code that relies on this to throw NPE and you don't want to break it?
2) The "normal" way in Java when you try to print null to a log, is to write the string 'null' and not throw an NPE.
Thanks for the quick respond.
I can't control those places because I am using a third party and these objects are not in my control.
can we make :
Ints.tryParse(String s, int radix)
Longs.tryParse(String s, int radix)
Ints.tryParse(CharSequence s, int radix)
Longs.tryParse(CharSequence s, int radix)
?
Overloads would work, the only concern is that the extra indirection (assume no copy paste) increases the likelihood of hitting the MaxInlineLevel limit which might result in perf degradation in certain use cases.
If I compile gwt project with gwt.version 2.8.0-beta1 I get this error.
```
Compiling module app.Application
[INFO]    Tracing compile failure path for type 'com.google.common.collect.BinaryTreeTraverser'
[INFO]       [ERROR] Errors in 'jar:file:/Users/ros/.m2/repository/com/google/guava/guava-gwt/20.0-SNAPSHOT/guava-gwt-20.0-SNAPSHOT.jar!/com/google/common/collect/BinaryTreeTraverser.java'
[INFO]          [ERROR] Line 134: No source code is available for type java.util.BitSet; did you forget to inherit a required module?
[INFO]    [ERROR] Aborting compile due to errors in some input files
```
With gwt 2.8.0-rc1 my project compile but can't upgrade gwt version.
I agree with you.
We have a problem with SDM which fails during the first compilation and the problem seems in the generation of the source maps compiling with  GWT 2.8.0 rc1 (and rc2)(https://groups.google.com/forum/#!topic/google-web-toolkit/ATR3ZWcVrEs)
We also hope they'll fix with final 2.8.0 but in the mean time we are stuck.
GWT 2.8 added BitSet emulation.
[INFO]    Tracing compile failure path for type 'com.google.common.collect.BinaryTreeTraverser'
[INFO]       [ERROR] Errors in 'jar:file:/Users/cyril/.m2/repository/com/google/guava/guava-gwt/20.0-SNAPSHOT/guava-gwt-20.0-SNAPSHOT.jar!/com/google/common/collect/BinaryTreeTraverser.java'
[INFO]          [ERROR] Line 134: No source code is available for type java.util.BitSet; did you forget to inherit a required module?
[INFO]    [ERROR] Aborting compile due to errors in some input files
Somebody has an idea ?
GWT 2.8 has ArrayDeque implementation
The implementation of the method indexOf(Object o) in the AbstractList iterates over the iterator. In the case of Cartesian list, the index can be computed instead.
A return statement occurred in the first
iteration of the loop making the loop
statement redundant, as it is semantically
equivalent to an if-statement.
Replaced the loop-statement with the
equivalent if.
I signed it!
[`TreeRangeMap.getEntry()`](https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/TreeRangeMap.html#getEntry%28K%29) returns a `Map.Entry` that doesn't support [`Map.Entry.setValue()`](http://docs.oracle.com/javase/7/docs/api/java/util/Map.Entry.html#setValue%28V%29). This would be particularly useful for `RangeMap`s, where the caller may not know in advance what the actual key (the range) is.
By "doesn't support put" are you referring to the unmodifiable map returned by [`.asMapOfRanges()`](https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/TreeRangeMap.html#asMapOfRanges%28%29)? I would agree that does't need to support `.setValue()`, though I see now it's backed by the same `Map.Entry` instances `.getEntry()` returns.
Conceptually it makes sense to me that a `TreeRangeMap`'s values could be modified by calls to `setValue()` on the entries the `TreeRangeMap` _itself_ exposes (as opposed to an unmodifiable view).
My specific use-case involved aggregating data - I constructed a `TreeRangeMap<LocalDate, Integer>` and added a series of ranges with `0` as the value. I was hoping I could then do something like:
```
for (Datapoint d : datapoints) {
// no knowledge at this point of which range the datapoint falls into
Entry<Range<LocalDate>, Integer> e = rangeMap.getEntry(d.date());
e.setValue(e.getValue() + d.value());
}
```
```
Entry<Range<LocalDate>, Integer> e = rangeMap.getEntry(d.date());
rangeMap.put(e.getkey(), e.getValue() + d.value());
```
I know it's not a huge distinction in terms of performance, but I was surprised `.setValue()` wasn't supported. I'd argue the intent of this second format is less clear, as well.
As another benefit, if the caller doesn't need to incorporate the old value it even becomes a one-liner:
```
rangeMap.getEntry(d.date()).setValue(d.value());
```
I notice now that `TreeMap` doesn't support `Entry.setValue()` either (which surprised me - I'd have thought it would be particularly beneficial for a tree since it would provide O(1) value-overwrites). Nevertheless, I think there's still value for `RangeMap` since the caller may not even have the actual `Range` key a priori.
Currently the ImmutableTable is not Serializable. Is it for any reason?
The Javadoc link just 404s to the broken Googlebot.
The one on the front page for the latest release.  This one:
http://google.github.io/guava/releases/19.0/api/docs/
Hmmm it may be something to do with the network administration here, I will investigate that first.  Sorry to have bothered you.
Add a method to create a temp directory beneath a user defined parent directory instead of the system's temp directory
add repository
same on
Just adding a method similar to already existing in Strings class, I'm thinking in something like [this](https://github.com/google/guava/compare/master...jonathanbeber:master)
@lowasser got there just before me! :smiley:
Today I tried to build a few ImmutableMaps which store class objects and related conversion functions. This worked well for primitive types and the related Wrapper functions but not for Lists and Collections. As soon as I started to add multiple related classes java compilation broke with
> error: incompatible types: Object is not a functional interface
and nothing more. IntelliJ and other IDEs do not show any related error hints and when I change Immutable map to JDK classses like HashMap the error disappears.
Success:
``` java
private static final Map<Class, Function<List, ?>> convertListToType
= ImmutableMap.<Class, Function<List, ?>>builder()
.put(String.class, Object::toString)
.put(Set.class, HashSet<Object>::new)
.build();
```
``` java
private static final Map<Class, Function<Integer, ?>> convertIntegerToType
= ImmutableMap.<Class, Function<Integer, ?>>builder()
.put(double.class, Double::new)
.put(Double.class, Double::new)
.put(float.class, Float::new)
.put(Float.class, Float::new)
.put(long.class, Long::new)
.put(Long.class, Long::new)
.put(String.class, Object::toString)
.build();
```
``` java
private static final Map<Class, Function<List, ?>> convertListToType
= ImmutableMap.<Class, Function<List, ?>>builder()
.put(Set.class, HashSet<Object>::new)
.put(String.class, Object::toString)
.build();
```
(This is the first success case with rows switched.)
``` java
private static final Map<Class, Function<List, ?>> convertListToType
= ImmutableMap.<Class, Function<List, ?>>builder()
.put(String.class, Object::toString)
.put(Set.class, HashSet<Object>::new)
.put(HashSet.class, HashSet<Object>::new)
.build();
```
(This is the first success case with an additional row containing the  "HashSet.class"  information.)
Interesting find.  Java 9's javac and Eclipse's compiler can both handle this, so it does look like a bug in Java 8's javac.
I don't know how Guava could work around this.  Consider this other code which demonstrates the same problem:
``` java
import java.util.List;
import java.util.Map;
import java.util.function.Function;
class GenericsTest {
static class Builder<K, V> {
Builder<K, V> put(K k, V v) { return this; }
Map<K, V> build() { return null; }
}
static Map<Class, Function<List, ?>> convertListToType =
new Builder<Class, Function<List, ?>>()
.put(Integer.class, GenericsTest::foo)
.put(String.class, Object::toString)
.build();
static <T> Integer foo(List<T> list) {
return null;
}
}
```
I think the only choice is to work around this application side, for example by avoiding raw `List` in favor of wildcard `List<?>`.
Okay. If it isn't a failure on guavas site I will close this issue.
Hello,
I try to get all classes within a package:
``` java
ClassPath.from( Thread.currentThread().getContextClassLoader() ).getTopLevelClassesRecursive( "my.package" );
```
This works fine, except the jar file contains spaces. My jar stores all dependencies so I can get the classes from my jar:
```
my/
package/
someclass.class
```
If I run the test.jar within a path without spaces e.g. c:\Users\MyUser\ with java -jar test.jar everything is fine, but on c:\Users\MyUser\Dir With Spaces\ and java -jar test.jar the getTopLevelClassRecursive returns an empty set.
Same error exists under OSX, if I run the jar under /User/MyUser/ with java -jar test.jar everything is fine but under /User/MyUser/New Folder/ I get also an empty set.
Duplicate of https://github.com/google/guava/issues/2152?
Yes, it's a duplicate. `#getTopLevelClassesRecursive` delegates to `#getTopLevelClasses`. see parsing spaces when it changed for '%20' in cmd or classLoader
Example: file:/C:/Program%20Files/lib.jar @flashpixx #2152 has been resolved, I think you can close this one.  The snapshot API has the following typos:
`com.google.common.math.StatsAccumulator`: `public final double populationVariance()` and
`com.google.common.math.Stats`: `public double populationVariance()` say
> This is guaranteed to return zero if **the the** dataset contains only exactly one finite value.
> This is guaranteed to return zero if **the** dataset contains only exactly one finite value.
Hello, how do you guys like an idea for an [equalsHelper](https://github.com/vorburger/java-sandbox/blob/master/equalshelper/src/main/java/ch/vorburger/equalshelper/MoreObjects2.java), which [can be used like this](https://github.com/vorburger/java-sandbox/blob/master/equalshelper/src/test/java/ch/vorburger/equalshelper/Thing.java#L10) ?
The point would just be to avoid repeating the well known null/this/getClass() in every equals() - less litany, more readable code, less accidental bugs.
AutoValue has the big disadvantage of not being compatible with major ORM frameworks, for instance. While an approach like the one suggested is.
@lowasser yep I've seen AutoValue (but never actually tried it) - certainly like the approach a lot in general (personally I'd Code Generate my grandmother, if she was alive..), and do realize/just (re)learnt the PITA of hand-writing hashCode and equals (arrays, urgh! see https://git.opendaylight.org/gerrit/#/c/41600/), but there probably still are some cases when people hand-write equals? For those, perhaps this could be handy.
BTW: Perhaps you'd like to point to AutoValue more prominently from the main Wiki page about this where everyone looks at, on https://github.com/google/guava/wiki/CommonObjectUtilitiesExplained ?
This is a semantics-preserving refactoring that migrates existing method implementations in classes to the corresponding implemented interface methods as `default` methods. The tool **does not** add new code; it only rearranges _existing_ code.
- We are evaluating a research prototype automated refactoring Eclipse plug-in called [Migrate Skeletal Implementation to Interface](https://github.com/khatchad/Migrate-Skeletal-Implementation-to-Interface-Refactoring). We have applied the tool to your project in the hopes of receiving feedback.
- The approach is very conservative. That may mean that not all changes that can be made were made. Please feel free to continue the refactoring manually if you wish.
- We only migrated methods declared in abstract classes with the hopes of such methods being suitable default methods in corresponding interfaces.
- The source code should be semantically equivalent to the original.
Thank you for your help in this evaluation! Any feedback you can provide would be very helpful. In particular, we are interested if each of the proposed changes are helpful or not.
I signed it!
Thank you for the consideration, @kluever! We'll be on the look out for the Java 8 branch.
Hi @kluever and @lowasser. I am thinking of applying for a [Google Faculty Research Award](http://research.google.com/research-outreach.html#/research-outreach/faculty-engagement/faculty-research-awards), deadline September 30, 2016, and proposing something based on this research. I know it is a ways away, but I was wondering if you know anyone that would be interesting in sponsoring the application, as that is one of the available fields. I can send more information if desired. Thanks!
HTTP/2 requires lowercase, and it's our collective future. Any code that cares
about the casing of headers is broken, so any code that breaks from this change
is destined to break when it's used with HTTP/2.
String.toLowerCase() and Ascii.toLowerCase() both have optimizations that make
code run faster if the input is already lowercase. I estimate that 0.0000001%
of Google's extensive compute resources are currently wasted converting headers
to lowercase when they could be lowercase already.
Works for me. Two quick notes about why this is too bad:
1. Any code that cares about case sensitivity here is almost certainly incorrect. Until recently this was academic. But any header that travels through an HTTP/2 channel comes out the other end in lowercase. Pushing a change of this magnitude through is fixing buggy code.
2. Because HTTP/2 exists, attempting to preserve case in HTTP headers is now a waste of code and CPU cycles. For example we use slow awkward TreeMaps with case-insensitive comparators rather than fast convenient LinkedHashMaps with lowercase keys.
I signed it!
The utility class `Sets` could use a new method `<T> Set<Set<T>> partition(Set<T> set, int size)`, similar to the one in `Lists` class. Such a method would be useful for various applications, e.g. for batch processing elements for which order is unspecified/unimportant, and I don't think there is a straightforward way of achieving the same effect with Java 8 streams API.
It's simply a matter of convenience. Let's say I have a method `void processElements(Set<Element> elements)`, a set of elements `Set<Element> elements` and I'd like to process these elements in batches. I can achieve that using `Iterables.partition`, e.g. like that:
```
StreamSupport.stream(Iterables.partition(elements, batchSize).spliterator(), false)
.map(list -> new HashSet<Long>(list)).forEach(batch -> {
processElements(batch);
});
```
But I'd much prefer to be able to do it like that:
```
Sets.partition(elements, batchSize).forEach(batch -> {
processElements(batch);
});
```
I find the latter more concise and more readable.
Or one like `partition(Set<T> set, int size, Supplier<Set<T>> setCreator)`?
Added static method to create Striped with Locks with 'fair ordering policy' = true
I signed it!
Seems caused by
LocalCache.java
boolean isExpired(ReferenceEntry<K, V> entry, long now) {
checkNotNull(entry);
if (expiresAfterAccess()
&& (now - entry.getAccessTime() >= expireAfterAccessNanos)) {
return true;
}
if (expiresAfterWrite()
&& (now - entry.getWriteTime() >= expireAfterWriteNanos)) {
return true;
}
return false;
}
Since expireAfterWrite = 0
But method
expiresAfterWrite() is implemented like
boolean expiresAfterWrite() {
return expireAfterWriteNanos > 0;
}
It never performs the time check
I observed that behaviour during some tests with the following cache
``` java
private final LoadingCache<String, Optional<String>> someCache = CacheBuilder.newBuilder()
.weigher(STRING_WEIGHER)
.maximumWeight(20000)
.expireAfterWrite(0, TimeUnit.SECONDS)
.softValues()
.build(new CacheLoader<String, Optional<String>>() {
public Optional<String> load(@NotNull final String s) throws Exception {
return loadCache(s);
}
});
```
Some previous tests loaded some values on the cache and a later test reading it was returning the actual value from the cache instead of invoking the "load" operation, even though the expireAfterWrite was set to 0.
Maybe I overlooked something. I will take a few more looks into it.
I couldn't reproduce. Can you provide an isolated test case?
just like method,
```
public static <K, V> ImmutableMap<K, V> uniqueIndex(Iterator<K> keys,
Function<? super K, V> valueFunction)
```
add a method with three parameters(Iterator object, Function keyFunction, Function valueFunction), for each object in Iterator, we use keyFunciont and valueFunciton to get key and value for map.
for _example
``` java
public static <T, K, V> Map<K, V> uniqueIndex(Iterator<T> values, Function<T, K> keyFunction, Function<T, V> valueFunction) {
checkNotNull(keyFunction);
checkNotNull(valueFunction);
ImmutableMap.Builder<K, V> builder = ImmutableMap.builder();
while (values.hasNext()) {
T value = values.next();
builder.put(keyFunction.apply(value), valueFunction.apply(value));
}
return builder.build();
}
```
See Issue #2509
I signed an individual CLA.
**Failure cases:**
_1) Positive_
Values rounded incorrectly: `0.99999999999999984` to `0.99999999999999994`
Rounding modes: CEILING or UP
Expected: `1`
Actual: `2`
Values rounded incorrectly:`-0.99999999999999984` to `-0.99999999999999994`
Rounding modes: FLOOR or UP
Expected: `-1`
Actual: `-2`
**Remarks:**
The reason is that values between 0 and 1 have higher fraction precision than values between 1 and 2. The code adds 1.0 to the value x, and double arithmetic uses HALF_EVEN rounding by default. This leads to unexpected results for edge cases when HALF_EVEN triggers rounding UP to 2.
**Proposed FIX:**
The FIX is to cast the double value `x` to a long before the addition of `1.0`:
Current:`x + 1.0`
Fixed: `(long)x + 1.0`
**Pull Request:**
See pull request [#2511](https://github.com/google/guava/pull/2511)
Specifically [here](https://github.com/google/guava/wiki/ListenableFutureExplained#application).
For the method that accepts an `AsyncFunction`, it should be renamed from `transform` to `transformAsync` instead. I would contribute but I'm not sure how to access the wiki as an intern.
:smiley:
merge
`Iterators.forArray` returns `UnmodifiableIterator`, but that just calls an overload, that returns an `UnmodifiableListIterator`
It would be useful if the public method returned a `ListIterator`, rather than restricting it to `Iterator`.
Plus, it would be good if the various overloads (array, offset, length) and (array, offset, length, index) were publically accessible, seeing as one `forArray` method is public already.
It would be binary-incompatible, since the return type of a method is part of its signature, as encoded in the invokestatic instruction in class files.
Looks like that there is an issue in EventBus - there is a way to register same handler class with one handler method two times and event will be handled 2 times
Here is gist with test to reproduce this issue
https://gist.github.com/kronar/4614b636ec5c379f1cd5df2a6fed1ec4
@lowasser I've  implemented builder for event bus which scans package in classpath and filters classes having methods annotated with @Subscribe annotation.  Couple of classes have multiple methods with this annotation so list of those classes contains duplicates. Therefore some pieces of business logic we're executed twice.
At ComparisonChain.java line 81.
Argument left can be null, if left is null, will throw NullPointException.
Must write as below code, not elegant.
`return ComparisonChain.start()`
`.compareFalseFirst(firstName != null, o.firstName != null)`
`.compare(firstName, o.firstName)`
Currently, example code in the description of ImmutableSortedMultiset.Builder class contains call for constructor which doesn't exist. This PR replaces constructor with `ImmutableSortedMultiset.naturalOrder()` call
I signed it!
TreeMultimap.create(TreeMultimap) take O(n)
```
- add new create(TreeMultimap) method using linear constructor of TreeMap
- change specifications of TreeMultimap and AbstractbasedMultimap
- change testMultimapCreateFromTreeMultimap according to new specifications
```
https://github.com/google/guava/issues/1579
Currently when calling `Joiner.on(String).join(Iterable<E>)` the `toString()` method is called to get a String from the given Object.
Sometimes you want to use `getName()` or `getText()` in order to get a String instead...
This way the developer could choose how he wants to get a string from the object.
That would be useful...
But still,,, I think my attempt would be more intentional...
```
List<JButton> buttons = new ArrayList<>();
//Initializing
Joiner.on(",").join(buttons, button -> button.getText());//returns text
```
I think this would work...
```
/**
* Appends the string representation of each of {@code parts}, using the previously configured
* separator between each, to {@code appendable}.
*
* @since 11.0
*/
@CanIgnoreReturnValue
public <A extends Appendable, E> A appendTo(A appendable, Iterator<E> parts, Function<E, String> function) throws IOException {
checkNotNull(appendable);
if (parts.hasNext()) {
appendable.append(toString(parts.next()));
while (parts.hasNext()) {
appendable.append(separator);
appendable.append(function.apply(parts.next()));
}
}
return appendable;
}
```
The current method could be replaced with
```
public <A extends Appendable> A appendTo(A appendable, Iterator<?> parts) throws IOException {
appendTo(appendable, parts, object -> object.toString())
}
```
`specialJoin(Iterable<E>, Function<E, String>)` ?
EDIT:
Double checked it... there is no problem in overloading... at least using Java 8
Also you could change
```
private static Iterable<Object> iterable(
final Object first, final Object second, final Object[] rest) {
checkNotNull(rest);
return new AbstractList<Object>() {
public int size() {
return rest.length + 2;
}
public Object get(int index) {
switch (index) {
case 0:
return first;
case 1:
return second;
default:
return rest[index - 2];
}
}
};
}
```
to
```
private static <E> Iterable<E> iterable(
final E first, final E second, final E[] rest) {
checkNotNull(rest);
return new AbstractList<E>() {
public int size() {
return rest.length + 2;
}
public E get(int index) {
switch (index) {
case 0:
return first;
case 1:
return second;
default:
return rest[index - 2];
}
}
};
}
```
and
```
public final String join(@Nullable Object first, @Nullable Object second, Object... rest) {
return join(iterable(first, second, rest));
}
```
to
```
public final <E> String join(@Nullable E first, @Nullable E second, E... rest) {
return join(iterable(first, second, rest));
}
```
In order to avoid errors of that kind and maintain type-safety, since therefore the Objects have to be all the same...
Given:
```
List<Integer> rowKeys = ImmutableList.of(1, 2, 3);
List<Integer> columnKeys = ImmutableList.of(1, 2, 3);
ArrayTable<Integer, Integer, String> input = ArrayTable.create(rowKeys, columnKeys);
ImmutableTable<Integer, Integer, String> option1 = ImmutableTable.copyOf(input);
ImmutableTable<Integer, Integer, String> option2 = ImmutableTable.<Integer, Integer, String>builder().putAll(input).build();
```
`copyOf` and `putAll` throw exceptions as if the developer had asked them to populate cell values with `null` but in actuality the developer didn't didn't explicitly populate the cells in question. In this case, I suggest simply skipping over `null` values and only `put`ing the remaining values.
@lowasser I was attempting to implement a Stream Collector for `ImmutableTable` using `ArrayTable` as an intermediate container. I guess my point is that it is practically impossible to convert an `ArrayTable` to any other kind of `Table` because of the way nulls are being handled.
Contrast this with `java.util` that differentiates between `null` values set by users versus non-existent mappings. This allows users to easily convert a `HashMap` to a `ConcurrentHashMap` even though the former supports `null` values while the latter does not.
Is there any particular reason that you decided to bubble this implementation detail up to the API level? An alternative implementation would be to add a `BitSet` that keeps track of which cells were explicitly set.
>  ArrayTable has those null values. That's how it's defined; it starts filled with nulls.
Okay. That point didn't come across when I read `The value corresponding to a given row and column is null unless another value is provided.` I wish there was a way to emphasize/clarify this point. Anyway, thanks for the clarification.
Don't know if someone is using my accounts
Added function Multimaps.index(Set<V>, Function<V, K>) based on
https://github.com/google/guava/issues/2468
Based on issue https://github.com/google/guava/issues/2468
Added a function Multimaps.indexSet
Hi, What do you think about adding additional parameters to "of" methods? Currently "of" supports up to 5 K,V.
I tried building version 19.0 under Windows from source using maven, simply cloned the git repo and issued "mvn install" until the following error occured:
```
com\google\common\collect\FilteredCollectionsTest$AbstractFilteredCollectionTest.class,
com\google\common\util\concurrent\AbstractFutureTest$3.class,
com\google\common\collect\TableCollectionTest$TreeRowMapHeadMapTests.class,
com/google/common/util/concurrent/testing/AbstractListenableFutureTest$4.class,
com/google/common/base/AbstractIterator.class,
com\google\common\reflect\TypeTokenTest$324.class,
com/google/gson/LongSerializationPolicy.class,
com/google/inject/spi/InjectionPoint$Position.class,
org/joda/time/tz/data/Europe/Lisbon,
javax/annotation/meta/TypeQualifierDefault.java,
com/google/common/collect/Lists$TransformingRandomAccessList$1.class,
org/junit/runner/manipulation/Sorter$1.class,
com\google\common\collect\MultimapsCollectionTest$2.class,
com/google/common/util/concurrent/AbstractService$3.class,
net/sf/cglib/core/EmitUtils$3.class,
com/google/common/base/CharMatcher.class,
com/google/common/collect/MapMakerInternalMap$WeakEvictableEntry.class,
com/google/common/util/concurrent/SettableFuture.class,
org/joda/time/YearMonthDay.class,
com/google/common/collect/Cut.class,
org/mockito/internal/invocation/InvocationsFinder$RemoveNotMatching.class,
com\google\common\hash\HashTestUtils$RandomHasherAction$1.class,
com\google\common\reflect\TypeTokenTest$30.class]>
should have contained <com/google/common/reflect/ClassPathTest.class>
testGetClassPathEntry(com.google.common.reflect.ClassPathTest):
expected:<file:/C:/usr/test/dep.jar>
but was:<file:/usr/test/dep.jar>
testGetClassPathFromManifest_absoluteDirectory(com.google.common.reflect.ClassPathTest):
Not true that <[\with\absolute\dir]> contains exactly <[C:\with\absolute\dir]>. It is missing <[C:\with\absolute\dir]> and has unexpected items <[\with\absolute\dir]>
testGetClassPathFromManifest_multiplePaths(com.google.common.reflect.ClassPathTest):
Not true that <[\with\absolute.jar,
C:\Users\tschoening\Documents\Svn\Src\Libs\trunk\Java\Google\Guava\19.0\src\guava-tests\base\relative.jar,
C:\Users\tschoening\Documents\Svn\Src\Libs\trunk\Java\Google\Guava\19.0\src\guava-tests\base\relative\dir]>
contains exactly <[C:\with\absolute.jar,
C:\Users\tschoening\Documents\Svn\Src\Libs\trunk\Java\Google\Guava\19.0\src\guava-tests\base\relative.jar,
C:\Users\tschoening\Documents\Svn\Src\Libs\trunk\Java\Google\Guava\19.0\src\guava-tests\base\relative\dir]>.
It is missing <[C:\with\absolute.jar]> and has unexpected items <[\with\absolute.jar]>
testGetClassPathFromManifest_absoluteJar(com.google.common.reflect.ClassPathTest):
Not true that <[\with\absolute.jar]> contains exactly <[C:\with\absolute.jar]>.
It is missing <[C:\with\absolute.jar]> and has unexpected items <[\with\absolute.jar]>
Tests run: 726068, Failures: 7, Errors: 0, Skipped: 0
```
Several times now, I've wanted to know all the row & column values of the cells in a table (but not the actual values) as a `SetMultimap`:
```
<R, C> SetMultimap<R, C> tableRowColumnSet(Table<R, C, ?> table);
```
This would either be a method on the `Table` interface directly, or in the `Tables` helper class (the name needs a bit of work).
There is currently no easy way to get a view of all the rows & columns in the table without creating a new `SetMultimap` manually. This would be analogous to `Map.keySet()` and variants thereof, and seems like an obvious extension to the `Table` interface.
+1 on this idea. Though I can't remember the context, tucked away deeply in my multi-thousand line `TODO` file there is this note:
```
```
(Thanks, I can now remove that entry from my list ;).)
There could also be methods going the other way, analogous to `Maps.toMap`/`asMap` (using BiFunction from Java 8 as a shortcut):
```
ImmutableTable<R, C, V> toTable(SetMultimap<R, C> rowColumns, BiFunction<R, C, V> getValue);
```
Its more thinking about the data represented in a `Table` as `(R, C) -> V` rather than `R -> C -> V`. The current API leans towards the latter, but sometimes the data you're using best fits into the former interpretation (while still allowing access as `R -> C -> V`). In that case, the 'keyset' of a table is best represented as a `SetMultimap`, as described.
Our usages here is to load values from a datastore for specific `(R, C)` pairs, which is best represented as a `SetMultimap<R, C>`. The data is loaded into a `Table<R, C, V>`, and we want to do common operations on the pre-loaded and post-loaded keyset (for example, comparisons between the two to see what was actually loaded). The calling code then wants to view the data as a Table for the standard Table operations
The output log is
```
Loading modules
cat.contesencatala.contesencatala
Loading inherited module 'cat.contesencatala.contesencatala'
Loading inherited module 'gwt.material.design.GwtMaterialWithJQuery'
Loading inherited module 'gwt.material.design.GwtMaterialDesignBase'
[WARN] Line 40: Setting configuration property named 'CssResource.legacy' in module 'gwt.material.design.GwtMaterialDesignBase' that has not been previously defined
Loading inherited module 'cat.contesencatala.contesencatala'
Loading inherited module 'gwt.material.design.GwtMaterialWithJQuery'
Loading inherited module 'gwt.material.design.GwtMaterialDesignBase'
[WARN] Line 40: Setting configuration property named 'CssResource.legacy' in module 'gwt.material.design.GwtMaterialDesignBase' that has not been previously defined
com.google.gwt.dev.jjs.InternalCompilerException: Error constructing Java AST
at com.google.gwt.dev.jjs.impl.GwtAstBuilder.translateException(GwtAstBuilder.java:3099)
at com.google.gwt.dev.jjs.impl.GwtAstBuilder$AstVisitor.endVisit(GwtAstBuilder.java:352)
at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.traverse(AllocationExpression.java:670)
at org.eclipse.jdt.internal.compiler.ast.Assignment.traverse(Assignment.java:260)
at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:347)
at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1379)
at com.google.gwt.dev.jjs.impl.GwtAstBuilder.process(GwtAstBuilder.java:3058)
at com.google.gwt.dev.javac.CompilationStateBuilder$CompileMoreLater$UnitProcessorImpl.process(CompilationStateBuilder.java:141)
at com.google.gwt.dev.javac.JdtCompiler$CompilerImpl.process(JdtCompiler.java:384)
at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:470)
at com.google.gwt.dev.javac.JdtCompiler.doCompile(JdtCompiler.java:985)
at com.google.gwt.dev.javac.CompilationStateBuilder$CompileMoreLater.compile(CompilationStateBuilder.java:339)
at com.google.gwt.dev.javac.CompilationStateBuilder.doBuildFrom(CompilationStateBuilder.java:580)
at com.google.gwt.dev.javac.CompilationStateBuilder.buildFrom(CompilationStateBuilder.java:513)
at com.google.gwt.dev.javac.CompilationStateBuilder.buildFrom(CompilationStateBuilder.java:499)
at com.google.gwt.dev.cfg.ModuleDef.getCompilationState(ModuleDef.java:668)
at com.google.gwt.dev.codeserver.Recompiler.initWithoutPrecompile(Recompiler.java:200)
at com.google.gwt.dev.codeserver.Outbox.maybePrecompile(Outbox.java:82)
at com.google.gwt.dev.codeserver.Outbox.<init>(Outbox.java:61)
at com.google.gwt.dev.codeserver.CodeServer.makeOutboxes(CodeServer.java:156)
at com.google.gwt.dev.codeserver.CodeServer.start(CodeServer.java:118)
at com.google.gwt.dev.codeserver.CodeServer.main(CodeServer.java:91)
at com.google.gwt.dev.codeserver.CodeServer.main(CodeServer.java:50)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:497)
at com.google.gwt.dev.shell.SuperDevListener$1.run(SuperDevListener.java:84)
Caused by: java.lang.NullPointerException
at com.google.gwt.dev.jjs.impl.ReferenceMapper.get(ReferenceMapper.java:99)
at com.google.gwt.dev.jjs.impl.GwtAstBuilder$AstVisitor.pushNewExpression(GwtAstBuilder.java:2642)
at com.google.gwt.dev.jjs.impl.GwtAstBuilder$AstVisitor.endVisit(GwtAstBuilder.java:350)
... 26 more
```
You can check the code here:
Thx!
I've encountered the same issue
We have MultiInputStream, why don't we have a MultiOutputStream?
Exactly! I've been in the process of cleaning dependencies for one project i'm working on. Apache Commons IO have TeeOutputStream class. It's the only class from that whole library my project used. I prefer to use guava instead of apache libs. So i wrote MultiOutputStream myself for now.
@cpovirk hi, please let me I know what is the status for this issue?
I saw the issue and have an idea how to implement it.
Please let me know.
@cpovirk Just out of curiosity, does your implementation of "write" method of the mentioned class throw an "aggregate" exception containing the exception(s) occurred on OutputStream(s).
If yes then does the aggregated exception contain reference to faulting OutputStream?
We have implementation like.
```
public class OutputStreamException extends IOException {
private static final long serialVersionUID = 4271756986146326876L;
private OutputStream stream;
public OutputStream getFaultingStream(){
return stream;
}
public OutputStreamException(Throwable ex, OutputStream stream){
super(ex);
this.stream = stream;
}
}
public class MultiOutputStreamAggregateException extends IOException {
private static final long serialVersionUID = -3124926231957260300L;
private Iterable<? extends IOException> innerExceptions;
public Iterable<? extends IOException> getInnerExcpetions() {
}
public MultiOutputStreamAggregateException(Iterable<? extends IOException> innerExceptions){
super("Aggregated MultiOutputStream IO exception");
this.innerExceptions = innerExceptions;
}
}
```
Thanks
Currently Iterables.frequency() only supports finding object based on equals() method, and for getting frequency by custom predicate, user has to resort to doing something like Iterables.size(Iterables.filter(iterable, predicate));
Would be nice to have a convince method to enable getting frequency by predicate.
As a developer working in an insurance company which registered in Shanghai, I have a lot of problems in checking out and pulling the volley repository through a proxy server in this insurance company. I highly recommend you store the volley repository on github.com! Thank you all very much!
On Mon, May 16, 2016, 10:51 PM Kurt Alfred Kluever notifications@github.com
wrote:
> What is the volley repository? Are you sure you reported this to the
> correct project?
>
> 
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2482#issuecomment-219625753
Maybe this should be an issue instead of pull request, if you find this to be against the guidelines for contributing, please feel free to close this request immediately. I wanted to send a pull request instead to demonstrate how invasive the change would be. (not very)
Basically I was using `LoadingCache<String, Value>` in my application and used it to cache data based on a string key, and I also needed to invalidate the cache, so invalidate(key) was called whenever necessary. Later on I needed to change the type of the `LoadingCache` to `LoadingCache<Wrapper, Value>` in order to pass on some extra parameters for the `CacheLoader`. Everything compiled and seemed to work fine, but after a while some cache invalidation issues started to come up.
After debugging I figured out that the signature of `invalidate(key)` is actually `invalidate(Object key)`, instead of using the actual key type. The lack of cache invalidation in turn caused inconsistency in our actual data and at least a day of extra work trying to fix everything manually. So I thought if having the key type included in the signature could've saved me hours of work, maybe I'm not the only one.
In theory it would be possible that someone is using an object for invalidation that is not a subclass of key, but would still equal to it. In practice I find this rather unlikely, but I would like to hear some comments about how to proceed with this suggested change.
Also, I have not signed the Google CLA yet, but I can do it if necessary.
Looks like a similar issue is discussed in http://smallwig.blogspot.co.uk/2007/12/why-does-setcontains-take-object-not-e.html blog post and the end result would be that the current behaviour is more correct. However, in my particular case the `Well, when I typed that code into IntelliJ, it flagged a warning for me right away.` didn't seem to stand and there were no warnings whatsoever with IntelliJ IDEA 15.
Again, feel free to close this pull request. Guess I just need to solve this issue with big warning messages, but it feels quite wrong...
I forgot to reply to this, thanks to both of you for suggestions and I'll consider adding FindBugs to the project development process.
For now I'm avoiding the issue by having a generic wrapper around the different cache types we're using with the key type always defined, and unit tests for the cache invalidation. Need to see if that becomes insufficient at some point.
1. Addition of callback support for Preconditions API :
- checkArgument(boolean expression, Supplier<Object> errorMessge)
- checkState(boolean expression, Supplier<Object> errorMessge)
- checkNotNull(T reference, Supplier<Object> errorMessge)
- check(boolean expression, Supplier<TException> exception)
1. Throwable.catchException utility along with ThrowableAction interface and ThrowableActions utility methods.
I signed it!
why not just pass a custom object with an overridden toString method?
For example [Javadoc for package `base`](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/base/package-summary.html) link to [`@ParametersAreNonnullByDefault`](http://jsr-305.googlecode.com/svn/trunk/javadoc/javax/annotation/ParametersAreNonnullByDefault.html?is-external=true) results in 404.
Affects all links to JSR 305 annotations.
As far as I can tell JSR 305 is not maintained anymore. Maybe the easiest solution would be to not link to the JSR 305 annotations in the Javadoc.
There doesn't appear to be a new home. Perhaps you could just update the Guava build to download https://repo1.maven.org/maven2/com/google/code/findbugs/jsr305/3.0.1/jsr305-3.0.1-javadoc.jar, unzip it, and then point javadoc at the dir where it was unzipped.
@ispringer Or point to javadoc.io which does what you describe:
http://www.javadoc.io/doc/com.google.code.findbugs/jsr305/3.0.1
The following test reproduces the behaviour.
```
public class MyTest {
private final Striped<ReadWriteLock> stripedLock = Striped.lazyWeakReadWriteLock(64);
private final AtomicBoolean writeLocked = new AtomicBoolean(false);
private final Set<String> someSet = new HashSet<>();
private final Random random = new Random();
private final String key = "anyKey";
@Test
public void test() throws Exception {
final ExecutorService executorService = Executors.newCachedThreadPool();
final AtomicBoolean testFailed = new AtomicBoolean(false);
for (int i = 0; i < 1000000; i++) {
someSet.add("" + i);
}
for (int i = 0; i < 10; i++) {
executorService.submit(new Runnable() {
public void run() {
try {
while (!testFailed.get()) {
writeLockedMethod();
} else {
readLockedMethod();
}
}
} catch (AssertionError e) {
e.printStackTrace();
testFailed.set(true);
}
}
});
}
while (!testFailed.get()) {
Thread.sleep(1000);
}
fail();
}
private void readLockedMethod() {
final Lock readLock = stripedLock.get(key).readLock();
readLock.lock();
assertFalse(writeLocked.get());
try {
someSet.contains("" + random.nextInt(1000000)); //Just do something.
} finally {
readLock.unlock();
}
}
private void writeLockedMethod() {
final Lock writeLock = stripedLock.get(key).writeLock();
writeLock.lock();
//Since the atomic boolean is set inside the write lock, for the same key, this should never be true.
assertFalse(Thread.currentThread().getName(),writeLocked.get());
writeLocked.getAndSet(true);
try {
someSet.contains("" + random.nextInt(1000000)); //Just do something.
} finally {
writeLocked.getAndSet(false);
writeLock.unlock();
}
}
}
```
This is something I'm seeing as well. I had same problem with .lazyWeakReadWriteLock(int) in 20.0 version @cpovirk
Would you consider to make the `WeakSafeReadWriteLock` public? I use a similar thing to `Striped#lazyWeakReadWriteLock`, just without the striping.
Shouldn't this be fixed in the JDK? Just removing the static modifier of the nested classes would do. We could argue that the nested locks need no reference to the enclosing class, but this issue shows it's actually needed.
I had an idea of simply extending all three involved locks and overriding the `readLock` and `writeLock` getters, making the original locks unused. Your fix is cleaner, but it's more than ten times longer. It might perform worse because CHA for `Condition` and overridden methods deeper in the call hierarchy tree. Just guessing.
> `perObjectReadWriteLock`
That's it.
> fixing in JDK
Posted.
> in comparison with the overhead that people expect when using especially a read/write lock
In a lucky case, there's hardly anything besides a single CAS in `nonfairTryAcquire`, but agreed.
> I'm not sure we have that option for Condition
I wasn't that far at the time of posting... I'm afraid, we're not. This makes inheritance only half as usable (and the mixing would be weird), so let's forget it.
> I'm not necessarily inclined to support the fix in the JDK
@lowasser  Agreed, I'm not sure either. But the cost is tiny, so I posted it for them to evaluate.
> if ReentrantReadWriteLock is any more special than the many other APIs
In a sense it is, as there are the three classes where each just exposes different aspects of a single `sync` (whose identity matters), so keeping them all alive for the same time sounds good. I can't recall any similar case. > > Posted.
>
> If I recall correctly, I had to join the list before I could post. I'm not seeing your post, so that would explain it.
Thanks! I thought, I was a member already. Too many mailing lists. ;) Now, it worked. https://bugs.openjdk.java.net/browse/JDK-8189598  Looks like googlecode now returns 404 for the guava API docs. While the docs are also hosted on google.github.io this site is poorly indexed / has poor page rank in google search. So it's basically impossible to reliably google search for the docs. I'm navigating the docs manually now but that's a pain.
Is it possible to get 301 redirects from googlecode to github.io until the search index picks it up? And/or another way to fix the index?
thanks
Thanks! FWIW, I didn't notice #2474 since I didn't look for closed issues. Might want to consider leaving it open for a couple of days. Otherwise you might get more dups.
> So it's basically impossible to reliably google search for the docs. I'm navigating the docs manually now but that's a pain.
You can always search Google with `<your query> site:google.github.io/guava/releases/19.0/api/docs/`.
Hi,
http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/cache/CacheBuilderSpec.html is returning a 404 error and http://docs.guava-libraries.googlecode.com is redirecting to this repo. Is this a temporary issue or have your javadocs moved? If the latter, what is the preferred reference URL? http://google.github.io/guava/releases/18.0/api/docs/ or something else?
Thanks both, we'll use the github links from now on.
Hi, I would like to ask for removal of com.google.common.collect.TreeTraverser from Guava's Beta, since it's a simple and convenient way to traverse hierarchies; one concrete usage (amongst many) we give to it is traversing a class hierarchy in annotation processors. Could it be done? Thanks for your attention.
Hi, any thoughts on this request? Thanks for your kind response. I'm not having any kind of problems, it's only that today I was reassigned to a project where we make use of TreeTraverser a lot, and was a bit concerned about the plans the Guava devs have for that particular API.  To my surprise none of `copyOf` methods in immutable collections ([ex. ImmutableList#copyOf(Collection)](http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/ImmutableList.html#copyOf%28java.util.Collection%29)) document throwing NPE when copied collection / iterable / array is null itself. I believe it's not side-effect behavior but rather your [intended action](https://github.com/google/guava/wiki/UsingAndAvoidingNullExplained).
Currently you only have:
Currently, there's two `Multimap.index` methods both returning an `ImmutableListMultimap`. It would be useful if there was a method added alongside with the following signature:
```
<K, V> ImmutableSetMultimap<K, V> indexSet(Set<V> values, Function<? super V, K> keyFunction);
```
for the specific situation in which `values` is a `Set`, then the returned multimap can be a `SetMultimap`, as any subset of the `values` set will also be a valid set. And `SetMultimap` offers semantic guarantees on value uniqueness that is not guaranteed by `Multimap` or `ListMultimap`.
Of course, this method will need a different name to not overload the existing `index` method to maintain source compatibility.
In this example, we've got a method that takes a `SetMultimap` (that depends on the semantics provided by that class, namely, unique values per key). I want to use the output of `Multimaps.index` as the parameter to that method, but that always returns a `ListMultimap`, even if the input is a Set. So I'm forced to do an additional `ImmutableSetMultimap.copyOf` for no reason.
Coincidentally, the method requiring the `SetMultimap` is the same as mentioned in my last comment in #2487
Hi,
Can I work on this?
Thanks,
Could you please point me to the change CL 116244562, so that i can get an idea?  I ask you permission to start the project to port Google Guava for .NET Framework. I can do?
Why would you need a permission? Guava has a very [permissive license](https://raw.githubusercontent.com/google/guava/master/COPYING) :)
Thanks Bro!
```
"Licensor" shall mean the copyright owner or entity authorized by
the copyright owner that is granting the License.
"Legal Entity" shall mean the union of the acting entity and all
other entities that control, are controlled by, or are under common
control with that entity. For the purposes of this definition,
"control" means (i) the power, direct or indirect, to cause the
direction or management of such entity, whether by contract or
otherwise, or (ii) ownership of fifty percent (50%) or more of the
outstanding shares, or (iii) beneficial ownership of such entity.
"You" (or "Your") shall mean an individual or Legal Entity
exercising permissions granted by this License.
```
I need a License so I can drive Lol
Yes. We Can! Lol
Lets Beginning the Avocado Project, a port of Google Guava for .NET
T o be  honest I don't know how I got here I was looking for information  too getting Player Pro to work II was just reading something online and saw the word License I never thought would _ was ever going to get the Licesne_
Thanks for reaching out
```
public void close() throws IOException {
field1.close();
field2.close();
}
```
But there's a leak here - if the first `field1.close()` throws an exception, field2 will not be closed. If the IOException is handled and the program continues running, then field2 will never be closed and will leak.
I propose adding a series of methods that will close several objects safely, in a similar way to try-with-resources, with the proposed outline:
```
public static void closeAll(Closeable... closeables) throws IOException {
for (Closeable c : closeables) {
try {
closeables.close();
}
if (ex == null)
ex = e;
ex.addSuppressed(e);
}
}
if (ex != null) {
Throwables.propagateIfPossible(ex, IOException.class);
throw Throwables.propagate(ex);
}
}
```
With similar variants for `AutoCloseable`, `Iterator<? extends Closeable>`, etc... that could be used like so:
```
public void close() throws IOException {
Closeables.closeAll(field1, field2);
}
```
http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/io/Closer.html
Hmm, so the Closer could be used for Closeable:
```
public void close() throws IOException {
Closer.create().register(f1).register(f2).close();
}
```
However, this only works for `Closeable`, there's no class that deals with `AutoCloseable` (throwing `Exception`). And it's a lot of boilerplate for taking a series of fields and closing them safely - could static members be added to Closer that just take the fields as an array or `Iterable`, allowing several objects in a collection to be closed in the same way?
This request is specifically in the situation of member variables of a class being closeable, where the containing class itself implements `Closeable` (or `AutoCloseable`). If you're creating and destroying a `Closeable` within a single method, then try-with-resources works. But if the `Closeable` is a field on a class, then you can't using try-with-resources, you have to do it manually within the containing class's `close` implementation. You can use `Closer` within that method, but, as I've said above, it's quite verbose. A static method where you just pass in the variables to be closed would be better.
One situation where you'll have a collection is, for example, a class maintaining a pool of connections to external servers. When the pool is closed, you want to close all the open connections (presumably stored in a collection), and if an exception is thrown when closing, you don't want to leak any.
Hi, all,
Can event bus dispatch events beyond Java Type based filter?
For example, I have the following scenario. QuoteEventListener only want to listen events filtering by ticker instead of just java type QuoteEvent.class.
```
// stock quote event
public class QuoteEvent {
private final String ticker;
private final double price;
public QuoteEvent(String ticker_, double price_) {
ticker = ticker_;
price = price_;
}
public String getTicker() {
return ticker;
}
public double getPrice() {
return price;
}
}
QuoteEventListener listener1 = new QuoteEventListener("MSFT");
QuoteEventListener listener2 = new QuoteEventListener("GOOG");
EventBus eventBus = new EventBus("feeder");
eventBus.post(new QuoteEvent("MSFT", 12.34)); // only listener1 will be notified
eventBus.post(new QuoteEvent("GOOG", 12.34)); // only listener2 will be notified
```
@lowasser Yes, I can filtering this in listener. But I think it would be better that listeners should never touch events that they have not subscribed. What kind of event should they touch have been decided by EventBus. Which events of this kind should they touch? I think it's better that EventBus handles too.
@mingzhou I strongly agree... There should be an option to register some kind of ID or allow content-based filtering at the registration stage...
@lowasser @ShiroYacha Yeah, may be something like `@Subscribe(filter=EventPredicate.class)` while `EventPredicate implements java.functional.Predicate`...
In LocalCache.java
public V put(K key, V value) {
checkNotNull(key);
checkNotNull(value);
int hash = hash(key);
return segmentFor(hash).put(key, hash, value, false);
}
is there a specific reason for adding a null check for the value as well. why can't cache have null values.
Planilha de Alteraes
https://docs.google.com/spreadsheets/d/16i-99n-DpzYtVD0LsYbsyxWYMeVs-OUo7PCMbVXXSjs/edit?usp=sharing
My use case for `Iterables.partition()` is to construct precisely sized batches, not batches with dangerous null values in some of them.
Could partition offer a parameter to disable null padding, or better yet, offer a different method that doesn't pad at all?
@lowasser Thanks for clearing this up. I'll make a note to my team.
`SimpleTimeLimiter` requires an `ExecutorService`, but it only uses the `submit()` method, which is trivial to convert to `execute()`:
``` java
Future<T> future = new FutureTask<>(callable);
executor.execute(future);
```
The motivation is that implementing `Executor` is much easier than `ExecutorService`, especially when the full interface is not needed. We can work around this by using an adapter, but this is kludgy because it relies on knowledge of exactly which methods of `ExecutorService` are actually used: https://github.com/airlift/airlift/blob/master/concurrent/src/main/java/io/airlift/concurrent/ExecutorServiceAdapter.java
of course.
Just want to type less ...
Is there a reason that `Collections2.transform` accepts a `Function<? super F, T>` as its second argument instead of a `Function<? super F, ? extends T>`? The latter is the type used by the underlying `TransformedCollection` type and would expand usability. It would also make in consistent with similar functions in other classes in `collect` like `Lists` and `Iterables`. In particular it would help resolve a certain ambiguity that comes up when overloading with this method in Java 8. Consider the following example:
``` java
public class Fns {
public static <E, T> Collection<E> map(Function<? super T, E> fn, Collection<T> coll) {
return Collections2.transform(coll, fn);
}
public static <E, T> List<E> map(Function<? super T, ? extends E> fn, List<T> coll) {
return Lists.transform(coll, fn);
}
public static <E, T> List<E> map(Function<? super T, ? extends E> fn, T[] coll) {
return map(fn, Arrays.asList(coll));
}
}
```
This code works in Java 7, but in Java 8, the third overload generates an ambiguous reference error, because the compiler is not sure which of the first two overloads to use. This can be fixed by making the first version accept a `Function<? super T, ? extends E>`, but of course, this won't work with Collections2. If the type of the function argument to `Collections2.transform` could be changed, it would make our migration to Java 8 much easier.
Hi, could you please let me know when we may expect this to be resolved?
In that case can we have another transform method?
public class ExceptionTest {
@Test
public void testExceptionToString(){
try{
throw new RuntimeException("RuntimeException-test");
String ss = Throwables.getStackTraceAsString(e);
System.out.println("exception:"+ss);
}
}
```
@Test
public void testExceptionCausalChain(){
try{
throw new RuntimeException("RuntimeException-test");
List<Throwable> chain = Throwables.getCausalChain(e);
for(Throwable t :chain) {
System.out.println("exception:" + String.valueOf(t));
}
e.printStackTrace();
}
}
```
## }
I just want to focus on special package callstack!
I just want to get the call chains under the specific package
as
``` java
String ss = Throwables.getStackTraceAsString(e,specialPackageName);
```
Can you please elaborate it ? what exactly you are asking about ?
Sorry but could not get clear picture of your request .
I noticed recently that `MutableGraph` was split away from `Graph`, so I was curious as to why Sun Microsystems didn't do the same with the interfaces in the Java Collections framework. I googled it up and found [this StackOverflow answer](http://programmers.stackexchange.com/a/289372), which I think gives a very convincing explanation as to why they opted to go for optional, `UnsupportedOperationException`-based mutation methods rather than mutable sub-interfaces.
Has the Guava team considered the advantages and disadvantages of both approaches for `com.google.common.graph`?
Hi @kevinb9n and @jrtom, thank you both for your explanations. I can see that things aren't as clear-cut as I first imagined.
On a side note, if you ultimately decide that having `MutableGraph` as a sub-interface is the right thing to do, I wonder if it'd be worth adding a note to `Graph` that if one is using `Graph` directly, they shouldn't assume the impl is immutable (even if the interface has no mutation methods), due to `MutableGraph` being a sub-type. (It certainly wasn't obvious to me at first that `Graph`s could be anything but immutable.)
I also wonder if it'd be worth recommending the use of `MutableGraph`/`ImmutableGraph` over `Graph` to avoid this sort of confusion. I imagine this would be similar to how `List` and `Set` are encouraged over `Collection` (or `(List|Set)Multimap` over plain `Multimap` for that matter).
Yep, the javadoc clarifies things enough for me, so thanks @jrtom! Well, actually, it's the [wiki](https://github.com/google/guava/wiki/GraphsExplained#mutable-and-immutable-graphs) that explains it, but the Graph javadoc links to it, so that's fine for me. :)  I would like to ask for removal of com.google.common.base.StandardSystemProperty from Guava's Beta, as it's a really convenient way to reference system properties, and keeps devs from using hardcoded values or mantaining our own sets of constants. Could it be possible? Thanks for your attention.
Glad to hear that, thanks a lot for your response.
I'm facing an interesting problem:
After upgrading guava from r18 to r19, I cannot compile my project anymore, at least not with oracle javac (JDK 8u60 on linux):
```
[javac] [loading ZipFileIndexFileObject[/myproduct/lib/common/log4j/apache-log4j-2.5-bin/log4j-core-2.5.jar(org/apache/logging/log4j/core/config/plugins/PluginVisitorStrategy.class)]]
[javac] error: cannot access CheckReturnValue
[javac]   class file for javax.annotation.CheckReturnValue not found
[javac] Note: Some input files use or override a deprecated API.
[javac] Note: Recompile with -Xlint:deprecation for details.
[javac] 1 error
```
I don't know exactly yet why this happens but I realized that compared to r18, with r19 now more class files contain references to `javax.annotation.CheckReturnValue`
Interestingly, the last logging statement before the error is related to a log4j2 class although I can not see how the class and the compile error are related.
I'm not using any sort of compiler plugins / processors.
Interesting fact: Eclipse compiles the same project without any errors.
I'll check whether adding the jsr305 dependency will workaround the issue.
@cpovirk I came from scala background,but currently have to use java 7 with guava,so I think something like `foreach`,`lastIndexWhere` things would be nice.
Mutable Java collections can't be safely treated covariantly.  But there's a nice trick when you don't need to modify them:
``` java
void foo(List<Number> numbers);
void bar(List<Integer> ints) {
foo(Collections.unmodifiableList(ints));
}
```
This works because `Collections.unmodifiableList()` takes in a `List<? extends T>` but returns a `List<T>`.  (It also requires Java 8's type inference; write `Collections.<Number>unmodifiableList(ints)` on Java &le; 7.)  Similarly for sets, maps, etc.
It would be nice to be able to do the same thing with `Multimap`s, but the `Multimaps.unmodifiable*` methods are not covariant.
@lowasser I don't think so, changing a method from `foo(A<B> a)` to `foo(A<? extends B> a)` shouldn't break any `foo()` calls.  Is there some corner case I'm missing?
That whole feature is weird btw.  Even `unmodifiableSetMultimap()` doesn't dynamically return `SortedSet` proxies, only `unmodifiableMultimap()` does.  It looks like `unmodifiable{List,Set,SortedSet}Multimap()` could still be made fully covariant in keys and values.
@lowasser: I was talking about the `foo(Collections.unmodifiableList(ints));` line, which only works as written in Java 8.  Nothing to do with Guava.
@cpovirk: You're right of course, it's a sorted set of values we're talking about.
This is something very minor, but it will let me sleep easy;
I'm writing some extensions to [RichTextFX](https://github.com/TomasMikula/RichTextFX) using [ANTLR](https://github.com/antlr/antlr4), which means indexes galore, and it would make my life easier if I could get the `ImmutableSortedMap` to commit to a `List` return type, by covariantly overloading `ImmutableSortedMap.values()` to return an `ImmutableList` instead of an `ImmutableCollection`.
-  public ImmutableCollection<V> values() {
+  public ImmutableList<V> values(){
return valueList;
}
```
Any thoughts?
Specifically I'm building a `RangeMap<Integer, antlr.runtime.Token>` which represents text ranges as keys to the tokens as values. The tokens themselves know their text indices but its annoying to sort through them to find the token you want, much easier to keep a RangeMap of them.
`ImmutableRangeMap` is transformed into a `Map<Range, Value>` by `asMapOfRanges()`, which does a check to special-case an empty map, using an empty `ImmutableBiMap` instead.
Further, its aliased as an `ImmutableMap<>` rather than an ImmutableSortedMap.
Sorry for wasting your guys time!
> I'm not sure we'd want to commit to the current implementation. Can you use values().asList() or ImmutableList.copyOf(values()), either of which would return what you want in O(1)?
I can, and thats what I'll do.
You'd need an exceptionally large text file for linear time on the number of tokens to be a problem.
I was surprised to discover that the `put(K key, V value)` method of `TreeMultimap` will replace the existing value if the given key already exists. This defeats the purpose of a Multimap. (Yes the Java docs describe this behaviour, but that does not mean the behaviour is sensible or expected.)
I suppose there now exists code using TreeMultimap that expects this behaviour, so the put method likely should not be changed. I argue that a new method be introduced that allows adding new values for the same key. Perhaps `add(K key, V value)`.
I cannot post reproduction instructions, mostly because when I tried to I discovered TreeMultimap.put behaves exactly as expected! Turned out the values I was adding had a custom implementation of Comparable for which compareTo returned 0 for the different objects I was adding. Oops. Sorry for wasting your time!
@kluever Is there a way to track that transition? Just the [label](https://github.com/google/guava/labels/platform%3A%20java8)?
Cool! Looking forward to it 
[Javadoc](http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/cache/CacheBuilder.html) of CacheBuilder says it uses LRU as eviction policy, but my test says otherwise..
`private static void testCacheEvictionPolicy() {
int maxSz = 3;
LoadingCache<Integer, Integer> cache = CacheBuilder.newBuilder().maximumSize(maxSz).build(new CacheLoader<Integer, Integer>() {
public Integer load(Integer integer) throws Exception {
return integer;
}
});
callCache(cache, 3);
printCache(cache);
for (int i = 0; i < 1000; i++) {
callCache(cache, 1);
}
callCache(cache, 4);
printCache(cache);
}
```
private static void callCache(LoadingCache<Integer, Integer> cache, int n) {
for (int i = 1; i <= n; i++) {
try {
cache.get(i);
} catch (ExecutionException e) {
throw new RuntimeException(e);
}
}
}
private static void printCache(LoadingCache<Integer, Integer> cache) {
System.out.println("cache begin");
for (Map.Entry<Integer, Integer> entry : cache.asMap().entrySet()) {
System.out.println(entry.getKey() + " : " + entry.getValue());
}
System.out.println("cache end");
}`
```
output:
> cache begin
> 3 : 3
> 2 : 2
> 1 : 1
> cache end
> cache begin
> 3 : 3
> 2 : 2
> 4 : 4
> cache end
The URI constructor for file is much more robust when it comes to handling encodings.
It saves a lot of headache of worrying about implementation specific edge cases.
(Fixes #2152)
CLA done
I've applied the fix only to the getClassPathEntries method, even though it seems the fix would apply both there and the getClassPathFromManifest method.
In any case, that seems like a separate issue, so I would rather do another PR for it.  I have to read up on what constitutes a valid manifest file entry to make sure that all of the encoding problems are solved there too.
Leaking interrupt status from one task to another is a really unfortunate behavior. And while I don't disagree with your statement "we shouldn't be interrupting threads we don't own", I do think that something being the delegate of a SerializingExecutor is transferring ownership in a sense.
@cpovirk Hi, please let me know what is the status of this issue, cause I would like to cotribute.
@cpovirk Hi, did I understand properly, do I need to re-implement the `Splitter.onPattern` function?
BTW yesterday I did a code-change which caused to return ['o','o'] for input data as {input: "foo"; regex: "(?=o)|(?<=o)"}, may I ask for a review? (before it was returning just ['0']).
Another question may be I should create another "Issue" in order to track everything in right place?
update
I am writing a unit test and want to mock time. I am using the `Sleeper` `interface` and the `Ticker` abstract class. Something like this:
```
private static class FakeTime extends Ticker implements Sleeper {
private long total = 0;
this.now = System.nanoTime();
}
this.total += millis;
this.now += TimeUnit.MILLISECONDS.toNanos(millis);
}
public long getTotal() {
return total;
}
public long read() {
long result = now;
return now;
}
}
```
- `Ticker` feels more like an `interface` than an `abstract class`.
Proposal: Make `Ticker` an `interface`.
Thoughts?
Guava's testlib contains `FakeTicker` which is a handy utility similar to yours. Due to the static method a change to an interface wouldn't be possible until the Java 8 release. It might still be frowned upon as a breaking change.
Fix for #2365
I signed it!
Removal listeners are nice and all, but why doesn't `Cache.invalidate()` return true when an entry is successfully removed? The information is available to it and from a thread-safety perspective we cannot really know whether a particular call to `Cache.invalidate()` really removed an entry by using removal listeners.
Consider:
T1: Cache.invalidate("key") //"key" wasn't originally in the map
T2: Cache.put("key", "value")
T2: Cache.invalidate("key")
T1 seems that RemovalListener.onRemoval("key") was invoked, but it really corresponds to action by T2.
@kluever Thanks for the clarification. Closing seeing as this is by design and there is a reasonable workaround.
Perhaps this is a problem better tackled by an Information Flow library, however.
I hadn't seen that.
http://types.cs.washington.edu/checker-framework/current/checker-framework-manual.html#tainting-checker
looks
like it might be what I'm after. Thanks!
On Tue, 22 Mar 2016, 23:02 Louis Wasserman, notifications@github.com
wrote:
> I'd tend to expect this sort of problem to be best solved with Java 8 type
> annotations, and passing a variable around as a @Sensitive String rather
> than a Sensitive<String>?
>
> 
> You are receiving this because you authored the thread.
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2435#issuecomment-200070898
The Escaper returned by com.google.common.net.UrlEscapers.urlPathSegmentEscaper() should escape '@'.
Per http://tools.ietf.org/html/rfc3986#section-2.2 -
"""
If data for a URI component would conflict with a reserved
character's purpose as a delimiter, then the conflicting data must be
percent-encoded before the URI is formed.
```
/ "*" / "+" / "," / ";" / "="
```
"""
If urlPathSegmentEscaper() were to percent-encode '@', I think it would be an acceptable Escaper for escaping the host address part of a URL.
While it is less likely to cause a parsing problem in a path segment than in the host part it is strictly speaking incorrect for it not to be percent-encoded.
- Stephen
fix bug:
List<String> resultList = Lists.transform(list, new Function<Bean, String>() {
public String apply(Bean input) {
return input.getId();
}
});
after using this , the resultList can't be serializable
I signed it!
Yes, my resultList can do serializable depends on it's implementor, so i marked the top interface Iterator serializable.
Capitalization change in documentation line 62, report changed to Report
Very very trivial change to documentation of the read-me. Just cutting my teeth on Git..
I signed it!
Hi, thanks for the quick reply. I'm sorry that I could not provide any reference to a RFC or something like this. I have seen both parameters only in a few nginx and httpd configs. As I want to evaluate them in my code I thought I could use the class `HttpHeaders` but then I missed them.
I updated the AWS link. I also like the definition they use there.
I just read http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html and notice that `MemoizingSupplier` uses double checked locking. Is the article statement not an issue because the locking is done on a `volatile` field? Or because it's on a boolean?
**public static int lcm(int a, int b)**
```
/*
Returns least common multiple of two numbers. Uses gcd method of this library.
*/
```
I signed it!
Thanks :)
https://github.com/google/guava/wiki/CollectionUtilitiesExplained#listsin-addition-to-static-constructor-methods-and-functional-programming-methods-lists-provides-a-number-of-valuable-utility-methods-on-list-objects seems too long for a title :)
Created a function that returns byte array. Take paremeters of byte values, concat all of them and returns a single array.
Example:
byte array = new byte[2];
array = concatBytesToArray(0x06,0x01);
I signed it!
Hello,
Why not simply use `byte[] array = new byte[]{0x64, 0x61};` ?
Hello,
If you wanna add many byte values and you don't know how many. You can't this structure.
Thanks your comment.
But you have to either know how many you have (to pass them into the function) or pass in an array to begin with. Calling this method creates the array anyway (that's how varargs works), and your method just copies it. I see no use for such a method.
If you want to concat many byte values. Its useful.
Thanks your comment.
I am new here.@kluever  I used to merge this method for fetching mbus datas. But you are right.
This can also be done in such this way.
Thanks your comment.
#### public static int digitsOfNFactorial(int n)
//This method calculates digits number of number n's factorial without calculating 'n!'
//For example:for n=5--> 5!=120 --> returns 3
#### public static int getNumbersOfDigit(int n)
//This method calculates digits number of n
//For example:for n=4129--> returns 4
I signed it!
This is version 19.0
This:
``` java
public static void main(final String... args)
{
final CharMatcher m1 = CharMatcher.is('a');
final CharMatcher m2 = CharMatcher.isNot('a').negate();
System.out.println(m1.equals(m2));
System.out.println(m1);
System.out.println(m2);
}
```
prints:
```
false
CharMatcher.is('\u0061')
CharMatcher.is('\u0061')
```
@kluever pretty much so, yes; the logic is there anyway so that those two matchers are _functionally_ equivalent.
Since the logic is there to do that, what prevents equality to be computed accurately?
OK, well, I'll just close this issue. I'd have expected however that such a collapse would have been made...
Nevermind, I'll use something else, then.
We already normalize `CharMatcher`s in the `precomputed()` method. So we _could_ say that `equals` works as expected on the result of `precomputed()`, or (since `precomputed()` can be expensive) we could provide an `expensiveEquals(CharMatcher)` method. I agree that the use case has yet to be established, though.
@kluever this is for [grappa](https://github.com/fge/grappa). In this package, there is a cache mechanism for `Matcher`s (note: those are not `java.util.regex.Matcher`s) taking arguments.
My goal was to replace the custom Java `char` matchers in here (which rely right now on `Characters` instances) with `CharMatcher`s. Should the latter have implemented `.equals()` (and consequently `.hashCode()`), the swap would have been easy.
@eamonnmcmanus well, I don't care about "initial" precomputation. Actually I haven't tested with `.precomputed()` instances... But even that additional `.expensiveEquals()` wouldn't fit the bill.
In detail, how the key of the rules to be cached is by using a stupid, simple wrapper class which just calls back to `Arrays.deep{equals,hashCode}()`, which means it is expected that the individual parameters implement `.equals()` and `.hashCode()` as expected by the user.
When I am working with ranges that sometimes are connected and sometimes not, It is a litle cumbersome to have to check if the ranges are connected before any calling to the intersection method.
I added a new intersection method with a new optional flag parameter "_allowEmptyRanges_". When this flag is true, the method will return an empty set when ranges are not connected (instead of throwing an IllegalArgumentException).
The change is backward-compatible but I have included specitifc unit tests for this little change.
I would be glad to hear any comments from you.
I signed it!
Such as the following implementation:
public static CacheBuilder<K, V> newBuilder() {
return new CacheBuilder<K, V>();
}
```
The current implementation:
public static CacheBuilder<Object, Object> newBuilder() {
return new CacheBuilder<Object, Object>();
}
```
To facilitate reuse (I think):
``` java
CacheBuilder<Object, Object> builder = CacheBuilder
.newBuilder()
.expireAfterAccess(10, TimeUnit.SECONDS);
Cache<Integer, String> cache1 = builder.build();
Cache<Double, Serializable> cache2 = builder.build();
```
@lowasser Thanks, I remember to search 'CacheBuilder newBuilder' in 'Pull requests', but not in 'Issues'. So not found, I'm so sorry.
See a unit test demonstrating the issue here: https://github.com/gpanther/fastutil-guava-tests/blob/master/src/test/java/net/greypanther/guava/tests/tests/CustomToStringTest.java
It shows a HashMap subclass which overrides toString and as a result fails tests, even if CollectionFeature.NON_STANDARD_TOSTRING passed to MapTestSuiteBuilder.
I believe that methods like https://github.com/google/guava/blob/2cd4d629a2b6f1a462643b248e0972f44c5133b7/guava-testlib/src/com/google/common/collect/testing/testers/MapToStringTester.java#L45 should be marked with `@CollectionFeature.Require(absent = NON_STANDARD_TOSTRING)`.
In the last line under the heading : **Tuples for n>=2**, there is a link to AutoValue, which points to :
https://docs.google.com/document/d/1THRUCIzIPRqFSHb67pHV8KMbo55HphSXqlQcIx9oUiI/edit#heading=h.7ojt6jg2vdwc
which leads the user to a google doc asking to update whatever url lead them there to https://github.com/google/auto/tree/master/value
Current implementations of `putUnencodedChars` and `putBytes` are vulnerable to collisions from concatenating variable-length sequences. Prepending lengths of the inputs (using `putInt` as an example) would fix this.
As far as I remember, appending size doesnt prevent ambiguity  only prepending.
I wonder if a separate implementation is needed. Does _hash_ package guarantee backward-compatibility across different VM invocations? If not, then no contract would be broken by modifying existing imlementations.
I'd like to request the addition of a [Tree](http://mathworld.wolfram.com/Tree.html) data structure, which would be similar to a `DirectedGraph` but which has a single root, disallows cycles and self-looping edges, and is fully connected.
My use case for such a feature would be to model a sequence of actions, which may branch depending on some criteria.
I'm aware that such a data structure already exists in JUNG 2 (and this is probably the solution I'll use in the meantime), but I believe it would be something that users of the `com.google.common.graph` package, in a future stable version of Guava, would appreciate.
That sounds great @jrtom! Many thanks for your response. I realise trees are probably not going to appear in common.graph any time soon, but nonetheless it's exciting to hear what you have in mind for common.graph and JUNG.
@lowasser, I hope to get back to you soon with an answer, I'm just waiting for a confirmation that I can talk about my use case in detail here.
Also, thanks for fixing the typo in the issue title. :)
Hi @lowasser. I'm struggling to explain my use case very well and succintly, so I want to apologise in advance if you struggle with the wall-of-text below and/or if I've not described things well enough for you.
I'm doing my undergraduate dissertation, where I'm writing a tool which does logical & syntax-related checks on a subset of [SBVR](http://aaaipress.org/Papers/Symposia/Spring/2008/SS-08-01/SS08-01-010.pdf), a software modelling standard like UML which uses "Structured English" statements instead of diagrams.
For my dissertation, these statements describe the ordering in which "entities" in a hypothetical concurrent software system receive "messages" from each other. The most basic statement has the format
> entity1 **receives** msg1 **precedes** entity2 **receives** msg2
which describes how, in this system, `entity1` must receive `msg1` before `entity2` receives `msg2`. For my work, it doesn't matter where `msg1` and `msg2` come from.
I'm thinking of using a Tree to model the ordering between these messages rather than, say, a List. This is because in a more complex system, an entity (e.g. `entity1`) may expect to receive one message out of a choice of 2 or more (e.g. `msg1 | msg2`), and the message(s) it expects afterwards may change depending on whether it received `msg1` or `msg2`. In SBVR, this might be modelled as
> entity1 **receives** msg1 **or** entity1 **receives** msg2
To give a code example, if I had an SBVR statement like this:
> John **receives** msg1 **precedes** George **receives** msg2 **or** George **receives** msg3
<pre>Tree<EntityWithMessage, Object> messageOrderingTree = new Tree<>();
EntityWithMessage johnMsg1 = new EntityWithMessage("John", "msg1");
EntityWithMessage georgeMsg2 = new EntityWithMessage("George", "msg2");
EntityWithMessage georgeMsg3 = new EntityWithMessage("George", "msg3");
messageOrderingTree.addEdge(new Object(), johnMsg1, georgeMsg2);
messageOrderingTree.addEdge(new Object(), johnMsg1, georgeMsg3);
System.out.println(messageOrderingTree);
// prints the following:
//           John -> msg1
//              (root)
//               /  \
//              /    \
// George -> msg2    George -> msg3</pre>
I hope this gives you a better understanding of what I'm trying to do.
@jrtom and @lowasser, thank you both very much for your constructive feedback.
@jrtom, I understand your argument for the toString() representation for trees, and I completely agree! I only meant to show a visual example of what my tree would've looked like in case I hadn't made it clear from my makeshift API. :)
Thanks for your simple suggestion @lowasser, I'll see how it goes with using it in my dissertation.
I'm not sure what's the proper thing to do regarding leaving this issue open or closed. I presume it'd be useful to keep open as a reminder of sorts for the Tree impl, but I'd be more than happy to let @jrtom decide the usefulness of it. :)
I'm currently using JUNG 2.1, but I recently found that [Durian](https://github.com/diffplug/durian) has tree utilities like [TreeDef](https://diffplug.github.io/durian/javadoc/3.4.0/com/diffplug/common/base/TreeDef.html) and [TreeNode](https://diffplug.github.io/durian/javadoc/3.4.0/com/diffplug/common/base/TreeNode.html) which seem to fit my use case better.
Just thought I'd bring it up, since Durian's API may prove to be a source of inspiration for a tree implementation in common.graph (or indeed the next version of JUNG).
> which describes how, in this system, entity1 must receive msg1 before entity2 receives msg2. For my work, it doesn't matter where msg1 and msg2 come from.
Let's say that entityX receive msgX is called eventX. Here I will list some possibilities:
1. one event unlocks multiple events;
2. one event needs multiple events as precedent.
If both are true, then you need a DAG. If only one of them is true, then you need a tree indeed. If both are false, then it is simply a chain in which you do not really need graphs.
**Edit:** Also, only _one_ "event" can be preceded by zero events. This would make it the 'root' of my 'tree'.
Something like below would be what most people would think of as a "ordered tree" I think.
Viewed as a whole, a tree data structure is an ordered tree, generally with values attached to each node. Concretely, it is (if required to be non-empty):
A directed graph,
whose underlying undirected graph is a tree (any two vertices are connected by exactly one simple path),
with a distinguished root (one vertex is designated as the root),
which determines the direction on the edges (arrows point away from the root; given an edge, the node that the edge points from is called the parent and the node that the edge points to is called the child),
together with:
an ordering on the child nodes of a given node, and
a value (of some data type) at each node.  At work we use a lot the Verify utility class to make postconditions checks, it's a simple and effective way to do such checks. Nevertheless, it's marked with the Beta annotation. I read about Beta APIs https://github.com/google/guava/wiki/PhilosophyExplained#beta-apis and would like to ask for Beta removal from Verify, taking into account that the usage of Verify in our codebase has grown. Would it be possible? Thanks for your attention.
Thanks for your kind response, have a nice day!
Can't this be closed now as well?  One common issue when dealing with enums and enummaps (and switches with enums for that matter) is that with introduction of new enum values adding new entries into enummaps (or switches) for them can be easily forgotten.
Static factory methods (or a builder) could be used to fail fast when such a situation arises.
For example:
EnumMaps.forAllKeys(K1, V1, K2, V2)
Internally, when the construction of immutable enummap is done, validation is executed so that all possible enum keys are present and not null. Additionally, by enforcing that all enums are not null any of them could be used to get enum class (getDeclaringClass) which would bring an additional benefit to callers who wouldn't need to specify the enum type explicitly.
What do you think?
Well, I'm willing to implement it and contribute but would first like to discuss API specifics.
Where should it be located and how should those static factory methods be named?
Should non null be enforced for both keys and values or only for keys, etc. :)
Ok, when you get some free time on your hands, please take a look at the pull request, I've also opened a topic on guava google group. GWT tests seem to fail and last time I used GWT was about 3 years ago so any help would be appreciated :).
I think a builder is not enough and static factory methods should also be provided. I think putting both static factory methods and a builder in ImmutableMap and encoding enum in their name is a bad design choice. How many more use cases before ImmutableMap becomes too overloaded with ImmutableEnumMap stuff? I would also like to explicitly use ImmutableEnumMap type in my code or at least EnumMap since EnumMap is usually used different (at least from what I've seen) than a regular map.
> ImmutableMap is supposed to correspond to the Map interface; ImmutableSortedMap is supposed to correspond to the SortedMap interface. EnumMap is just another implementation of Map, just as HashMap is; it just happens to be more efficient for its specific use case.
Isn't ImmutableMap just another implementation of Map? Why is ImmutableMap public and why isn't everything in Maps? Why does Java API include a public EnumMap class and no explicit class similar to ImmutableMap?
Key difference between a regular Map and an EnumMap is that key is always an enum meaning there is a finite number of possible keys, always, for every possible EnumMap instance. Usually EnumMap is an alternative to a switch statement. But there is more than [that](https://docs.oracle.com/javase/7/docs/api/java/util/EnumMap.html):
> Null keys are not permitted.
Similar to that, ImmutableMap never allows modifying operations, is naturally thread safe if you don't modify keys/values etc.
Both the ImmutableMap and ImmutableEnumMap diverge from the Map contract more than enough that you would want an explicit type for both of them. So to sum it up, a reader will want to know that this is an EnumMap same as he wants to know it is an ImmutableMap. You don't want to check what is behind that Map definition same as you don't want to check what is the key type.
> Of course ImmutableMap diverges from Map, and EnumMap diverges from Map in some ways, but the only way I see that ImmutableEnumMap would diverge from ImmutableMap is the iteration order?
I have already answered that:
> Key difference between a regular Map and an EnumMap is that key is always an enum meaning there is a finite number of possible keys, always, for every possible EnumMap instance.
Second thing:
> but the only way I see that ImmutableEnumMap would diverge from ImmutableMap is the iteration order?
Same logic can be applied to ImmutableMap and Map, also like I've said in my previous response.
One more thing you didn't address:
> I think a builder is not enough and static factory methods should also be provided. I think putting both static factory methods and a builder in ImmutableMap and encoding enum in their name is a bad design choice. How many more use cases before ImmutableMap becomes too overloaded with ImmutableEnumMap stuff?
@cpovirk When do you expect the Java 8 version of the testlib to be available? Any possibility of providing snapshots so that I can experiment with it?
pull request for #2392
Duplicates the acquire methods for backwards compatibility.
The package private methods with signature changes have not been duplicated.
CLA is signed
I believe a more generic **empty** range could be introduced, because `(v..v]` and `[v..v)` have their side-effects.
Given `a = (5..5]`, `b = [10..15]` currently `a.span(b)` is equal to `(5..15]`. This is because `[10..15]` doesn't currently _encloses_ `(5..5]` but since it is basically an empty range I believe general empty ranges should be enclosed by every other range.
Introducing a generic empty range would have the benefit of having the followings:
- `range.encloses(empty) == true`, for every `range`
- `empty.encloses(range) == false`, for every `range` except `range === empty`
- `empty.span(range) == range` and `range.span(empty) == range` for every `range`
What do you think?
I thought this would be the case, but I had to ask, because it would make it a bit better, it would make `Range<C>` I believe a ring (in mathematical sense), where `+` would be the _span_ operation, `` would be the _intersect_ operation. The additive identity would be the `Range.empty()` and the multiplicative identity would be `Range.all()`.
Yeah, `Optional` could work, but just for the sake of being "empty" it isn't worth making the API uglier at the user side. `RangeSet` is a bit heavy because it would allow disconnected ranges.
Thanks anyway your input, much appreciated!
Hello,
**Example**:"JohnDoe123 WhiteHouse St.Earth Galaxy11111"
I would like to split above given fixed length string with lengths **_4, 3, 18,12,5_** such that I can get the _**first and last names, Street Address, City, ZipCode easily**_.
Thanks in advance!
Agreed. Going Data Structure way is surely one option. The reason I brought this up, In Banking/Financial/Insurance and perhaps other industries as well, a record is sent across the wire as a fixed length strings; Since Splitter already supporting different ways to split a string, I was just wondering that perhaps Splitting a Record in Fixed length string style to pick each column will be helpful.
Appreciate any thoughts on this.
This closes #2397
I signed it!
Currently, `Throwables.propagate` wraps all checked exceptions in a `RuntimeException`. Java 8 added `UncheckedIOException` specifically to wrap an `IOException` in an unchecked exception. `Throwables.propagate` should check for `IOException` and use this class rather than the raw `RuntimeException`.
This is a compatible change, as `UncheckedIOException` extends `RuntimeException`.
Well, the idea is fine, but it would ruin the compatibility with previous Java versions.
Well, this is for Java 8 only, obviously...
No use in constructing a fresh copy of the Mac just to get the bit-length.
D:\Projects\Scripte\gam-3.63-windows>gam info user ********
User: *********
Traceback (most recent call last):
File "<string>", line 9136, in <module>
File "<string>", line 6352, in doGetUserInfo
File "C:\Users\jlee\Documents\GitHub\gam363\src\build\gam\out00-PYZ.pyz\encodings.cp866", line 12, in encode
UnicodeEncodeError: 'charmap' codec can't encode character u'\u0456' in position 16: character maps to <undefined>
OS: Windows 8.1 - Rus
User information have same fields in UTF-8 with char Cyrillic (not English)
Note: UTF-8 - 2-byte vs cpXXX - 1-byte
:) Sorry. Wrong project
```
@Test
public void thisWillPass() {
Map<String, AtomicInteger> map = ImmutableMap.of("foo", new AtomicInteger(0));
increment(map);
verify(map);
}
@Test
public void thisWillFail() {
Map<String, Integer> map = ImmutableMap.of("foo", 0);
Map<String, AtomicInteger> aMap = Maps.transformValues(map, number -> {
return new AtomicInteger(number);
});
increment(aMap);
verify(aMap);
}
private void increment(final Map<String, AtomicInteger> map) {
map.get("foo").incrementAndGet();
}
private void verify(final Map<String, AtomicInteger> map) {
Assertions.assertThat(map.get("foo").get()).isEqualTo(1);
}
```
I have two test cases where one fails and the other passes. In both cases I attempt to increment an instance of AtomicInteger in a map by one. A map constructed manually works fine with the increment() method, while a map returned from Maps.transformValues() fails.
Is this by design? It's not clear to me from reading the API doc.
I see. When I first read that paragraph, I interpreted "applied lazily" as lazy initialization, i.e. the function will be invoked eventually once. Your comment that it "does no storage of its own" really clarifies that. Thanks!
I would like to consume permits and return either the time that the task may continue, or the time that the task must wait before continuing, as opposed to having the thread sleep.  reserveEarliestAvailable() and reserveAndGetWaitLength() are the internal methods, respectively, that provides such functionality.  Relying on the RateLimiter to sleep in order to enforce the rate is intuitive, but makes it harder to compose RateLimiters into other tools.  Additionally exposing methods to "try" acquiring, failing if the required delay would be too great, would preserve consistency with the current API.
Use-cases:
1.  Limiting the rate of asynchronous tasks.  RateLimiter enforces rates by sleeping on the acquiring threads.  I would like to enforce the rate of tasks by instead scheduling them to a ScheduledExecutorService with the delay returned by reserveAndGetWaitLength().  This creates a rate-limited ExecutorService.
2.  RateLimiter with capacity (see #1707).  An alternative to supporting createWithCapacity() is to expose reserveAndGetWaitLength().  If I want a RateLimiter with a burst capacity of B (in time), I can achieve this by sleeping for max(0, reserveAndGetWaitLength(numPermits) - B).
The alternatives are to fork or implement my own RateLimiter from scratch, exposing such methods.
I really wish this issue was addressed. I really am constrained by the same need as the OP.  All the major logic is now moved to a single private method.
Now there is no code duplication, and this should be help in adding new methods to this class by writing very little code without much risk of introducing bugs
This is a sample implementation for https://github.com/google/guava/issues/2384. The design needs to be discussed before proceeding.
Currently the Uninterruptibles class has many methods which do basically the same thing:
1. No timeout:
- Wait on something
- repeat
- set interrupted state if required
- return result if any
2. Timeout:
- Wait on something with timeout
- update timeout
- repeat
- set interrupted state if required
- return result if any
This same logic is repeated multiple times in every method. And presumably, given the requests for more such methods to be added to the class, the duplication will increase. I suggest cleaning up the code with a generic implementation. This genericization will be private initially with no change in public API. Later on we might choose to publicize this generic implementation so that clients can take advantage of this class even in cases where they have blocking implementations which cannot be supported directly by this class
I have created a pull request with a sample design and implementation. Please review.
1. By allocation you mean creating a new object once in every method?
2. Is it so much of a performance hit to worry about, given that it happens only once per call?
3. What will it take to reconsider the decision no to go with the above design?
One of the reasons I insist is that by going down this path, we will be in a position some time in the near future to expose a generic method for clients to use with their own and other third party blocking implementations - making this class useful in almost all cases.
If you feel strongly about avoiding object allocation at the cost of code duplication, I would like to try out an alternative approach of using reflection - Pass the required method and arguments to a single method.
4. What is your take on such an approach?
Understood. Seems that the solution is not as simple as it seemed when i saw the code initially.
Thanks for your time :)
You can close this issue.
https://github.com/google/guava/issues/1409
I signed it!
Sure. will do...
Hi,
Sorry about the delay. I have added 11 tests for the following cases:
- wait, waitSuccessfullyWithTimeout, waitUnseccessfullyWithTimeout for the following cases each:
1. No interrupt
2. Single Interrupt
Keeping in mind the reasons you have given and some open questions, I am not going forward with this change.
Closing this pull request. Please reopen if you need any further discussion.
-  What do we do in case of timedWait methods-  return on interrupt? or keep retrying till timeout? Or take a supplier to check and retry?
- Returning on interrupt will mean that the client might need to implement code to retry with reduced time which will essentially render the API pointless
- Not returning on interrupt will mean that in some cases, the method will wait more than required
- Taking a supplier as parameter is not preferred as discussed above.
Looks like Object.wait() is not a good candidate for uninterruptibility.
`replaceAll` is another sneaky one. Surprisingly `ConcurrentMap` does not override `Map`'s default with an atomic version which uses `entry.setValue(v)`. It has a JavaDoc warning, but is obviously easy to overlook.
It would be useful to add missing functionality to BaseEncoding for base85 or ascii85 as its called.
There doesn't seem to many libraries that offer it (actually none) and it would be another leg up over apache.
Fair enough.
I'll close.
I found it personally useful and thought it might have a good fit here.
I'm getting many
java.lang.NoSuchMethodError: com.google.common.base.Preconditions.checkState(ZLjava/lang/String;I)V
exceptions with 20.0-SNAPSHOT
To reproduce:
1. Checkout https://github.com/google/closure-compiler/commit/583b50ce47215846ef8e81025ac27e8fc1cac448
2. Run "mvn test"
3. Will see errors like:
java.lang.NoSuchMethodError: com.google.common.base.Preconditions.checkState(ZLjava/lang/String;I)V
I suspect https://github.com/google/guava/commit/1ef638f369964c1d1f56bd0ae588535c6abd99a4
might have something to do with this?
@cpovirk @kevinb9n Bumping the one in pom-main.xml to 20.0-SNAPSHOT works, thanks!
Running latest SNAPSHOT version 20160130.004722:
```
compile 'com.google.guava:guava-gwt:20.0-SNAPSHOT'
```
I get the following error when doing `gradle build`:
```
:compileJava/Users/mg/.gradle/caches/modules-2/files-2.1/com.google.guava/guava-gwt/20.0-SNAPSHOT/a12b43e9186d04817e2e73fd3883fe5305e69dc3/guava-gwt-20.0-SNAPSHOT.jar(com/google/common/collect/AbstractIterator.java):64: error: duplicate class: com.google.common.collect.AbstractIterator
public abstract class AbstractIterator<T> extends UnmodifiableIterator<T> {
^
/Users/mg/.gradle/caches/modules-2/files-2.1/com.google.guava/guava-gwt/20.0-SNAPSHOT/a12b43e9186d04817e2e73fd3883fe5305e69dc3/guava-gwt-20.0-SNAPSHOT.jar(com/google/common/base/Optional.java):298: error: cannot access AbstractIterator
return new AbstractIterator<T>() {
^
bad source file: /Users/mg/.gradle/caches/modules-2/files-2.1/com.google.guava/guava-gwt/20.0-SNAPSHOT/a12b43e9186d04817e2e73fd3883fe5305e69dc3/guava-gwt-20.0-SNAPSHOT.jar(com/google/common/base/AbstractIterator.java)
file does not contain class com.google.common.base.AbstractIterator
Please remove or make sure it appears in the correct subdirectory of the sourcepath.
```
It can only solved my:
```
tasks.withType(JavaCompile) {
options.compilerArgs += ["-sourcepath", ""]
}
```
Had deleted previous fork by accident.
Suggested changes implemented in this one.
Does anyone resolve the conflict and merge the code?
I cannot find the `Tables.synchronizedTable` function in guava 20.0-rc1.This function would be useful,please.
Consider replacing this unicode character by `..` or `-` or `,` ASCII characters.
Yes, gratuitous use of non-ASCII characters in toString() methods is not considerate to users who may not have the right fonts installed. It also results in a string representation that you would never want to actually make users type. Let's say you dump out some ranges in a text config file. How is a user supposed to enter those?
The problem is compounded by the fact that Range is final so you cannot subclass it to work around the problem.
> "no telling how many things we'd break by changing it."
If computers are parsing this thing then I think we've got a problem. Pretty much everywhere I've read `Object.toString()` is designed for human consumption, not computer parsing.
I doubt very many people have written parsers that are explicitly looking for \u2025 or else someone probably would have reported this earlier.
If you want to be backward compatible you could always move the separator string in a writable global variable or have a global useASCII variable.
BTW, the same issue exists with the representation of +/- infinity. It would be better to use "Infinity" (which is what Double uses) instead of the magic infinity character.
Also, if you add a parse method to Range to read from a String you can have it support the old and new syntax. That would save people from having to write their own parser that explicitly references the separator characters.
As for a parseable interface, something like the Converter API is probably the right thing to do. Users of Java 8 can then use a lambda:
```
Range.parseRange(someString, (Double endpoint) -> Double.parseDouble(endpoint));
```
You could add a few static methods for integer and double ranges for convenience which would probably cover most user's needs.
A less painful alternative is to add `toString(String separator)` which lets the user override the default separator. No magic globals there. And ideally you would somehow instruct users that the `toString()` implementation will be changing in an upcoming release so if they are somehow tied to a particular separator character they should use `toString(String separator)` instead of `toString()` whose separator may change over time.
As a side-note, I would also point out that it's problematic that `Range` doesn't "know" the underlying element type. See https://github.com/google/guava/issues/2374 for a recent example of how this could lead to misunderstandings.
Would it make sense to supplement `Range` (for `Comparable` in general) with type-specific implementations such as `IntRange`, `LongRange`, etc? It would allow us to implement more intuitive behavior and adding parsing capability because more feasible.
You might want to also look for \u221E (infinity).
An alternate toString implementation should also include a parameter for the infinity representation. It wouldn't hurt to add such a method, but it would be a less than ideal solution to the problem because it would force developers to replace all toString calls including the implicit ones in String.format calls.
Very nice. Thanks Kurt!
If you are using the EventBus constructor that that takes the `SubscriberExceptionHandler` you can't set the identifier.
Should an additional constructor be added so you can set the identifier?
http://google.github.io/guava/releases/19.0/api/docs/com/google/common/eventbus/EventBus.html#EventBus(com.google.common.eventbus.SubscriberExceptionHandler)
Awesome.
Thanks!
I just ran into the same issue missing the two-arg constructor - maybe its addition would be an easy but effective fix? a builder is cool, but needs more time to implement and test, i assume.
@cgdecker Is it being worked on by anyone? Do you have any specific design in mind? I would like to submit a PR for this.  `Range.closedOpen(0, Integer.MIN_VALUE)` throws `IllegalArgumentException: Invalid range: [0?-2147483648)` but by my understanding, it should not.
The implementation seems to fail because it sees `upper` as being less than `lower` but in practice it should be comparing `upper-1` to lower since the upper cut is open. `upper-1` is indeed greater than `lower` so I am expecting this Range to be valid. Is this a bug or a misunderstanding on my part?
How would I check whether some value is included in `[min, max)` if `max` can't equal `Integer.MAX_INTEGER`? If `Range` can't do this, is there another class I should be using?
Correct. That is the condition I want to check for but I want to express this in terms of a `Range`. The expression you mentioned (`x.compareTo(a) >= 0 && x.compareTo(b) < 0`) holds true for my case but `a > b` does not for the aforementioned reasons.
So if I understand you correctly, you are saying that it is strictly impossible for `Range.closedOpen()` to contain the value `Integer.MAX_VALUE`? If so, I have two comments:
1. Does it really makes sense for `Range` to enforce `a > b` if it doesn't have the ability to translate `b` from open to closed? Wouldn't it better to leave out this check and let the user assert it outside the API?
2. Is it reasonable to use this as a workaround? `Range.closed(min, max-1)` If so, perhaps it makes sense to mention this in the Javadoc? Example: "Please note that closedOpen() cannot contain the maximum value of the underlying type. Consider using closed(min, max-1) for such cases instead of closedOpen(min, max)."
Update (having read your last post): Is there a way to represent `[0, infinity]` as you mentioned using `Range` for Integers? If so, how?
Fair enough. Thank you for the explanation.
The code site wiki had a hidden comment just before the CharMatcher section in StringsExplained, and when the docs were migrated to github it got un-commented. Also, there's a missing line that's messing up the formatting of CharMatcher: https://github.com/google/guava/wiki/StringsExplained#charmatcher
Re-commenting the comment and adding a blank line before the table at the beginning of CharMatcher fixes the formatting.
Apparently pull requests against wikis aren't a thing, so here's the fix:
```
diff --git a/StringsExplained.md b/StringsExplained.md
@@ -60,16 +60,19 @@ If you wish to get a `List`, just use `Lists.newArrayList(splitter.split(string)
**Warning:** splitter instances are always immutable.  The splitter configuration methods will always return a new `Splitter`, which you must use to get the desired semantics.  This makes any `Splitter` thread safe, and usable as a `static final` constant.
+<!--
Escaping strings correctly -- converting them into a format safe for inclusion in e.g. an XML document or a Java source file -- can be a tricky business, and critical for security reasons.  Guava provides a flexible API for escaping text, and a number of built-in escapers, in the com.google.common.escape package.
All escapers in Guava extend the [http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/escape/Escaper.html Escaper] abstract class, and support the method String escape(String).  Built-in Escaper instances can be found in several classes, depending on your needs: [http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/html/HtmlEscapers.html HtmlEscapers], [http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/xml/XmlEscapers.html XmlEscapers], [http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/escape/SourceCodeEscapers.html SourceCodeEscapers], [http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/net/UriEscapers.html UriEscapers], or you can build your own with [http://google.github.io/guava/releases/snapshot/api/docs/ an Escapers.Builder].  To inspect an Escaper, you can use Escapers.computeReplacement to find the replacement string for a given character.
'></a>
+-->
many methods like these:
+
| `allAscii` | `collapse` | `collapseControlChars` | `collapseWhitespace` | `indexOfChars` |
|:-----------|:-----------|:-----------------------|:---------------------|:---------------|
| `lastIndexNotOf` | `numSharedChars` | `removeChars`          | `removeCrLf`         | `replaceChars` |
```
Hi,
This is a simple operation that has a wide range of applications (sizing buffers, primarily, but it also has uses in collection implementations etc), and it's not immediately obvious what the bit-twiddling algorithm is doing when it appears in a codebase. Would seem like a prime candidate for an addition to guava.
There's a simple bit-twiddling algorithm for ints & longs; doubles & bigintegers can probably use a combination of the existing log, floor & pow methods, unless there are clever ways of doing the same for those types (also see http://stackoverflow.com/questions/466204/rounding-up-to-nearest-power-of-2)
`return Integer.highestOneBit(n) << 1` ?
When `n` is already a power of two, this will return the next highest one (I want >=, not >). Admittedly, this can be solved using a check for `IntMath.isPowerOfTwo`, but it's still not exactly obvious. There is a related method `BigInteger.bitLength` that can be used for bigintegers, but nothing for doubles that I can see...
Well, if I have `int n = 4;` and I call `int x = Blah.nextPowerOfTwo(n)`, I logically expect that `x == 8`. Because "next", to me, means "not this one, but the one after".
A simple version of that is below, which is what I use. As its a one-liner I put the method in the class since its only rarely needed.
``` java
static int ceilingNextPowerOfTwo(int x) {
return 1 << (Integer.SIZE - Integer.numberOfLeadingZeros(x - 1));
}
```
+1 :)
With Ben's insight, you can still write:
```
return Integer.highestOneBit(n - 1) << 1;
```
Note the `n - 1`.
doesn't work for n <= 0
Powers of two are positive, it makes no sense to use negative values...
but your code returns 0 for 0 and all negative integers, and should return 1
If this is purpose (as @simonmcooper originallly wrote)
> nextPowerOfTwo
> return the smallest integer >= n that is a power of two
than you should return at least 1 for all inputs (or throw)
I'm having an issue deploying to weblogic 12c (12.1.2.0) where it loads the version of `com.google.common.base.internal.Finalizer` from weblogic instead of my WEB-INF/lib. The symptoms are identical to the [previous issue with the beans.xml](https://github.com/google/guava/issues/1527), but I have tried 15.0-cdi1.0, and also versions 17 and 19 and none of them work, so I don't think this is the same as that particular issue. I do have `prefer-web-inf-classes` in my weblogic.xml, and I have tried `prefer-application-packages` instead but it doesn't help.
If I load `Finalizer` using `Class.forName` it gets loaded from the right place, but when `FinalizableReferenceQueue` tries to load it, `Finalizer` gets loaded from weblogic's internal version (which is too old and therefore throws an `NoSuchMethodException`). I have turned on java's verbose classloading log to confirm.
You can see my simple [web.xml](https://gist.github.com/tstibbs/945a0a4c467f0547ec0c#file-web-xml), [weblogic.xml](https://gist.github.com/tstibbs/945a0a4c467f0547ec0c#file-weblogic-xml) and [servlet context listener](https://gist.github.com/tstibbs/945a0a4c467f0547ec0c#file-testfilter-java) (all it does it load the classes). The relevant bits of the log are [here](https://gist.github.com/tstibbs/945a0a4c467f0547ec0c#file-log-log), line 10 shows the class being re-loaded from the wrong place.
Hi, I just tried updating a HashBiMap using replaceAll and a second HashBiMap, but kept getting the error "java.lang.IllegalArgumentException: value already present: null".
After checking my own code, I set up a minimal code example to see what was going wrong.
It seems like calling replaceAll on an inverse of a HashBiMap doesn't work.
The println lines are just there to show you that it should work as in the line where I combine the two maps.
```
final int upperBound = 2;
final HashBiMap<Integer, Integer> b2a = HashBiMap.create();
IntStream.range(0, upperBound).forEach(i -> b2a.put(i, 100 + i));
System.out.println("b2a" + b2a);
final HashBiMap<Integer, Integer> b2c = HashBiMap.create();
IntStream.range(0, upperBound).forEach(i -> b2c.put(i, 200 + i));
System.out.println("b2c" + b2c);
final BiMap<Integer, Integer> a2b = b2a.inverse();
System.out.println("a2b" + a2b);
System.out.println("a2c" + Maps.asMap(a2b.keySet(), k -> b2c.get(a2b.get(k))));
a2b.replaceAll((a, b) -> b2c.get(b));
System.out.println("a2b'" + a2b);
```
It is interesting to note, that putAll for a copy of the combined map works.
i found the 19.0 add a new method for BloomFilter,i think i can put more elements into bloomFilter.but, when i try to put more than Integer.MAX_VALUE elemetns into it,it throws Exception:
<code>Caused by: java.lang.IllegalArgumentException: Out of range: 3386879438068</code>
<code>public static int checkedCast(long value) {</code>
<code>  int result = (int) value;</code>
<code>  if (result != value) {</code>
<code>    // don't use checkArgument here, to avoid boxing</code>
<code>    throw new IllegalArgumentException("Out of range: " + value);</code>
<code>  }</code>
<code>  return result;</code>
<code>}</code>
so, why did you add this new Method?and,how can i put more elements into BloomFilter?
Hello @cpovirk, I was trying to implement a speculative fix for this issue and make a pull request.
The issue that I am facing is that some classes are not present in this repository, while cloning `https://code.google.com/p/guava-libraries/` as in the [ContributorSetUp](https://github.com/google/guava/wiki/ContributorSetUp) page in the wiki has them.
This mismatch is an issue because I can't make a pull request on those files.
In detail, I was editing:
and the first two of these are missing.
Are these the right classes to edit? Can you help me in any way?
Thanks
SampleElements requires 5 distinct elements in the constructor (if they are not distinct some tests) but some collections (like the [Boolean collections from fastutil](http://fastutil.di.unimi.it/docs/it/unimi/dsi/fastutil/booleans/package-summary.html)) only have two distinct values.
I am guessing the signature could be:
public Range<C>[] subtraction(Range<C> other);
?
E.g. https://google.github.io/guava/releases/19.0/api/docs/package-list gives a 404, despite https://github.com/google/guava/blob/gh-pages/_releases/19.0/api/docs/package-list existing.
This causes things like
```
1 warning
[WARNING] javadoc: warning - Error fetching URL: https://google.github.io/guava/releases/19.0/api/docs/
```
Hi, can I just append a String variable at the start or end of this Joiner, before invoking its join method.
For example:
build a dynamic sql string like below:
("a", "b", "c")
now there is a set named "container" contains these three elements
and I can use Joiner.on(",").join(container) to build a String "a,b,c"
after that I must add "(" and ")" manually.
Is there a exist method to let me append the fixed String "(" and ")" to this instance of Joiner so that I can build up automatically.
thx
[testEquals_otherContainsNull](https://github.com/google/guava/blob/a9f8b899c07a33c2203b4e6cf84861646952aeed/guava-testlib/src/com/google/common/collect/testing/testers/SetEqualsTester.java#L67) looks up the "null" value in the set-under-test (indirectly, by comparing it with a test that contains null), even if CollectionFeature.ALLOWS_NULL_QUERIES was not specified.
IMHO this test should be conditioned on CollectionFeature.ALLOWS_NULL_QUERIES being specified during the generation of the test suite.
Just to give some context: I'm trying to test the [fastutil](http://fastutil.di.unimi.it/) collections using guava-testlib and that's how I run into this scenario ([IntOpenHashSet](http://fastutil.di.unimi.it/docs/it/unimi/dsi/fastutil/ints/IntOpenHashSet.html) throws NPE for example on equals if the "other" collection contains null).
@lowasser I'm pretty sure `equals()` is not permitted to throw in that case.  Otherwise it would be non-symmetric with `HashSet`.
The mediatype for php (text/php) and cmd (text/cmd) are not included,
Both versions reference missing method int GWT core library that is no longer present in 2.8.0.
Interesting aspect is that this problem only appears in SuperDev mode, there is no error message during 'normal' GWT compile.
SuperDev mode produces the following error message:
Compiling module XXXXX
[ERROR] Errors in 'com/google/common/collect/super/com/google/common/collect/GwtPlatform.java'
[ERROR] Line 38: The method createFrom(T[], int) is undefined for the type Array
Tracing compile failure path for type 'com.google.common.collect.GwtPlatform'
[ERROR] Errors in 'com/google/common/collect/super/com/google/common/collect/GwtPlatform.java'
[ERROR] Line 38: The method createFrom(T[], int) is undefined for the type Array
```
package com.google.common.collect;
import com.google.common.annotations.GwtCompatible;
import com.google.gwt.core.client.GwtScriptOnly;
import com.google.gwt.lang.Array;
@GwtCompatible
public static <T> T[] newArray(T[] reference, int length) {
return Array.createFrom(reference, length);
}
}
```
As you can see, it references Array.createFrom that was removed in version 2.8.0.
I would suggest the following solution. It doesn't use any internal API and seems to be working cleaner then previous one (Array,createFrom didn't initialize the elements of new array that were not copied from reference and they stayed undefined instead of null).
```
public static <T> T[] newArray(T[] reference, int length) {
T[] res = (T[]) new Object[length];
if ((reference != null) && (reference.length > 0)) {
System.arraycopy(reference, 0, res, 0, Math.min(length, reference.length));
}
return res;
}
```
Thank you!
Alrighty, if you use the proposed code above, it does NOT depend on any internal GWT structures at all. So it is safe to use it in any case (in all GWT versions).
I'm unaware of any other troubles, but this one is easy to fix.
Thanks.
I guess, that;s independent of this one. I'm not arguing, just if you accept this fix, it will make your life in terms of #1999 a bit easier.
OK, maybe, I'm not an expert in low-level implementation details, I guess,
GWT team should help here.
On Thu, 7 Jan 2016 13:51 Chris Povirk notifications@github.com wrote:
> The above fix compiles but doesn't actually return a T[], only an Object[]
> that looks like one. The method is expected to return a T[].
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2353#issuecomment-169532631.
are you using singleton pattern in your project .... if yes then why..
The code above is not what you want at all.
The class literal on the object array will cause troubles later if you try to assign it to a properly typed variable.
`javaemul.internal.ArrayHelper.createFrom(notCopied, length)`
All of the really intrinsic "must have this just to use java types" all live in the new javaemul.internal package.
These types are, of course, super sourced, but I imagine that it is no problem, as they will be accessed via super-sourced types.
Ah, I see it is patched using Arrays.copyOf, which is already emulated to route to the ArrayHelper.  Nevermind :D
I am expecting the cache to evict keys after System.gc(). This requires:
- cache.getIfPresent(v) works
- cache is cleared after System.gc()
But unfortunately it couldn't satisfy both conditions.
Here is how I created the cache:
```
Cache cache = CacheBuilder.newBuilder()
.weakKeys().build();
```
- Eviction works when the key is created and not assigned to a variable
```
cache.put(Math.random(), "a");
System.out.println("cache: " + cache.asMap());
System.gc();
System.out.println("cache: " + cache.asMap());
```
This showed the correct output:
```
cache: {0.7254227566649404=a}
cache: {}
```
- Eviction doesn't work if the the key is assigned to a local variable:
```
Cache cache = CacheBuilder.newBuilder()
.weakKeys().build();
{
Double r = Math.random();
cache.put(r, "a");
}
System.out.println("cache: " + cache.asMap());
System.gc();
System.out.println("cache: " + cache.asMap());
```
This showed the wrong output:
```
cache: {0.006581944795823524=a}
cache: {0.006581944795823524=a}        //  <=== notice here, the value is still in cache.
```
```
double r = Math.random();
cache.put(r, "a");
System.out.println("cache: " + cache.asMap());
System.out.println("v: " + cache.getIfPresent(r));
System.gc();
System.out.println("cache: " + cache.asMap());
```
This showed the wrong output:
```
cache: {0.3569447241229746=a}
v: null                     // <===  autoboxed Double at different time will give different segment hashes.
cache: {}
```
So, with Cache.weakKeys(), we don't have eviction on System.gc(), or cache with keys that don't have a match.
@lowasser Is there a way to construct the key when using .weakKeys(), then?
because
- when key is primitive, getIfPresent() doesn't work as using ==
- when key is object, getIfPresent() works; but we have to keep a reference of the object for future matching, which is a strong reference.
I think the use case is very general for expectation on .weakKeys(). not quite satisfied with this answer.
I will explore other alternative then. I don't think the current implementation of .weakKeys() works for me if it behaves this way.
Thanks for the information on weakKeys(). Good to find out it is only intended for comparison with == operator, and not intended for the GC based caching.
ah I see. I constructed the demo code to examine wrongly. (I thought out of scope with {} would remove the reference.) GC removes the cache entry after I refactored the demo code into a method.
you are right that it doesn't fit my use case. Thanks for the explanation
Could Guava add a `@VisibleForSubpackages` annotation?  This would be similar to the existing `@VisibleForTesting` annotation which documents why an interface has more visibility than desired and that external callers should not use it.  Specifically I ran into this with Apache jclouds which has a hierarchy of subpackages within a jar, e.g., `org.jclouds.s3` and `org.jclouds.s3.binders`.  Classes of the subpackage have public visibility so that the parent package can see them but are unintentionally exported to externally callers.  Having `@VisibleForSubpackages` would warn callers and allow external tools to remove references, e.g., Javadoc, semantic versioning checkers.
If `@VisibleForTesting` were a more generic term, e.g., `@UnfortunatelyVisible`, with a user-specified reason, this would address my use case as well as other potential cases.  The more generic term also removes confusion between super- and sub-packages in my example.  This feature request would also seem to interact with Java 9 module visibility although I do not believe it has a similar source-level annotation.
Yes, please! Although it it true that most of the time the visibility is for testing, sometimes there are other (sometimes valid) reasons, too, and this might help consolidating the mess around them.
Shouldn't Jigsaw modules be the preferred resolution?
We haven't thought about it; we haven't gotten any requests for it.  Any sense of how common this use case is?
Also, I agree with Ben that the long-term solution for this is the module system, but I could understand people not wanting to wait until Java 9 for a solution.
Maybe also consider a shim for ListenableFuture -> CompletableStage for Java 9 users (packaged in an [MRJAR](http://openjdk.java.net/jeps/238)?), if [this conversation on the OpenJDK mailing lists](http://mail.openjdk.java.net/pipermail/core-libs-dev/2016-September/043699.html) ends up being fruitful.
and spotify/futures-extra has the handy [CompletableToListenableFutureWrapper](https://github.com/spotify/futures-extra/blob/master/src/main/java/com/spotify/futures/CompletableToListenableFutureWrapper.java) (which [we use here](https://git.opendaylight.org/gerrit/#/c/64771/))  The [javadoc for TestContainerGenerator.order](https://github.com/google/guava/blob/master/guava-testlib/src/com/google/common/collect/testing/TestContainerGenerator.java#L66) states:
> This method runs only when CollectionFeature#KNOWN_ORDER is specified when creating the test suite. It should never run when testing containers such as HashSet, which have a non-deterministic iteration order.
However, 74 tests (out of 450) fail with the code below which (as described by the documentation) expects TestContainerGenerator.order not to be called and throws an UnsupportedOperationException for it:
``` java
public final class JavaUtilCollectionsTests {
public static Test suite() {
TestSuite suite = new TestSuite("HashSet");
suite.addTest(SetTestSuiteBuilder.<Integer>using(new TestSetGenerator<Integer>() {
public SampleElements<Integer> samples() {
return new SampleElements<Integer>(-7, 0, Integer.MIN_VALUE, 42, Integer.MAX_VALUE);
}
public Integer[] createArray(int length) {
return new Integer[length];
}
public Iterable<Integer> order(List<Integer> insertionOrder) {
throw new UnsupportedOperationException();
}
public Set<Integer> create(Object... elements) {
List<Integer> values =
Arrays.stream(elements).map(o -> (Integer) o).collect(Collectors.toList());
return new HashSet<>(values);
}
}).named("HashSet")
.withFeatures(CollectionSize.ANY, CollectionFeature.GENERAL_PURPOSE,
CollectionFeature.ALLOWS_NULL_VALUES, CollectionFeature.SERIALIZABLE_INCLUDING_VIEWS)
.createTestSuite());
return suite;
}
}
```
The expected result would be for all the tests to pass.
Changing the documentation to allow to just return the list if the order can not be guaranteed sounds good to me.
@cpovirk - no problem, I appreciate them being fixed. And thank you for this extensive test-suite, it really helps in sussing out the bugs from 3rd party collection frameworks!
Please consider adding following comparison operators to Ordering class:
- `eq(a,b)` as shortcut for `comparator.compare(a,b)==0`
- `nq(a,b)` as shortcut for `comparator.compare(a,b)!=0`
- `lt(a,b)` as shortcut for `comparator.compare(a,b)<0`
- `lte(a,b)` as shortcut for `comparator.compare(a,b)<=0`
- `gt(a,b)` as shortcut for `comparator.compare(a,b)>0`
- `gte(a,b)` as shortcut for `comparator.compare(a,b)>=0`
Not sure if this has been discussed previously but it is trivial to add methods that return CharSequence types to the Splitter API and maintain the existing API. We have some use cases for this feature where we do not want to create temporary char[] array copies of the intermediate substrings.
The Splitter API accepts CharSequence types as input and internally manipulates CharSequence types. This patch maintains the existing methods that return String types and adds additional methods that
return CharSequence types. The performance overhead on the existing methods that return String type is one additional call to Iterators#transform() that calls toString() on the CharSequence results. Note the #toString() call was already present in the existing implementation.
It looks like the API of Splitter was created at the time when the HotSpot
JVM did not allocate new char[] arrays for subsequences. That behavior was
changed in their release of JDK 7u6:
http://bugs.java.com/view_bug.do?bug_id=4513622. Might this warrant the
need for new methods that do not create new char[] arrays?
On Jan 2, 2016 3:26 AM, "Kurt Alfred Kluever" notifications@github.com
wrote:
> The Splitter API has been part of Guava since 1.0, and has been fairly
> stable (it's non-@Beta at this point). I'm somewhat doubtful that this
> use-case is popular enough for us to start expanding the API at this point.
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/pull/2345#issuecomment-168373137.
I signed it!
You have write permission, so it is your call.  But it does seem to violate the normal Googley convention that no dead or commented out code should be checked into the repository.  I guess all rules have exceptions.
Recently a [question on StackOverflow](http://stackoverflow.com/q/34472616/180719) showed that it was impossible to run such a portion of Java 8 code (compile-time is okay):
```
public final class SampleMain {
public static void main(String[] argArr) {
final ArrayListMultimap<Void, Void> arrayListMultimap = ArrayListMultimap.create();
arrayListMultimap.clear();
final Consumer<ArrayListMultimap> arrayListMultimapConsumer = ArrayListMultimap::clear;
arrayListMultimapConsumer.accept(arrayListMultimap);
}
}
```
This issue comes from the fact that some public methods are last defined in a package-private parent class. It has been referenced as issue [issue JDK-8143647](https://bugs.openjdk.java.net/browse/JDK-8143647) from the JDK and is fixed, but the fix is yet to be released.
So to workaround the JDK issue and protect Guava users from it, is it possible to look for each method that is last defined in a package-private parent class and overwrite those methods in public implementations with a rather simple call `super.method()`?
I think I know the argument for using Object-type parameters in this new Graph thing (is it similarity to the Collections API?), but I believe it is a good time to reconsider this in view of:
- Java changes that are (hopefully) going to come sooner or later (http://mail.openjdk.java.net/pipermail/valhalla-spec-experts/2015-December/000001.html),
- Graph being a totally new interface (at least for wider public), not released, still in beta.
It's always beneficial to have as much type-constrained API as possible. It would be especially nice in case of Graph, as it has many similarly named methods that are easy to confuse (that's my experience as of now).
I'll understand if you do nothing, but, please, at least think about doing something else.
@cpovirk I think that de8d63f and 206a5ac resolved this one (hooray!). Could you confirm, please?  I'm watching here: [Maps.uniqueIndex](http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/Maps.html#uniqueIndex%28java.lang.Iterable,%20com.google.common.base.Function%29)
I think those two are equivalent :)
@lowasser oops I didn't notice that one is for Iterator, and the other one is for Iterable. will close this issue! thanks.
Our project (https://github.com/google/closure-compiler) cannot build with GWT 2.8.0-beta1 and Guava 19.0 release. The Travis CI has been broken for a week. Can we expect a 20.0-SNAPSHOT to be published to google-snapshots soon?
Why use a SNAPSHOT at all?  Just use 19.0, better yet inherit the version from the parent pom
I had to hack the release process for v20151216 because gwt was broken in multiple places.
@cpovirk Thanks. I was looking at the wrong place.
@lindner The 19.0 release does not work with GWT 2.8.0-beta1, at least for Closure Compiler.
Mutable operations on `ImmutableRangeSet` (`add`, `remove`, `clear`, etc) should be marked as unsupported and deprecated and javadoc modified appropriately, in a similar way to mutable operations on the other immutable collections.
I use this api to read file to String in android(guava 19.0)
```
s = Files.toString(file, Charsets.UTF_8);
```
The traditional plain ugly java works fine.
Android Build Version Info
``` android
compileSdkVersion 23
buildToolsVersion "23.0.2"
```
Equivalent Java code
``` java
public static String readFileContent(File file) {
InputStream inputStream;
StringBuilder total = new StringBuilder();
try {
inputStream = new FileInputStream(file);
BufferedReader r = new BufferedReader(new InputStreamReader(inputStream));
String line;
while ((line = r.readLine()) != null) {
total.append(line);
}
} catch (FileNotFoundException e) {
LogUtil.d(TAG, String.format("e = %s", e));
} catch (IOException e) {
LogUtil.d(TAG, String.format("e = %s", e));
}
return total.toString();
}
```
@lowasser it doesn't get the file content.
And there is a weird thing about this: when i try to print the string, the expression seems not been executed at all.It not even show "s = null" or something like that.
``` android
LogUtil.d(TAG, "s = " + s);
```
So I tried in another way, I write a simple gradle-java project use the same file and guava 19.0.
It works fine.
will you look up to this? on android platform i still can't read the file using guava library.
`ImmutableSortedMap.copyOf` has an overload with the following signature:
```
copyOf(Map<? extends K,? extends V> map, Comparator<? super K> comparator);
```
but similar methods on `ImmutableSortedSet` are declared like so:
```
copyOf(Comparator<? super E> comparator, Collection<? extends E> elements)
copyOf(Comparator<? super E> comparator, Iterable<? extends E> elements)
copyOf(Comparator<? super E> comparator, Iterator<? extends E> elements)
```
The placement of the `Comparator` argument is inconsistent. I suggest one version is deprecated, and overloads with the arguments swapped over are added.
The `Comparator` coming second also matches with the JCL (`Collections.sort`, etc)
I would say there's no harm in deprecating the existing inconsistent ones, providing overloads, and leaving it like that for several versions. Gives people plenty of time to change.
I think it would be really useful if guava-testlib included an implementation (or implementations) of `Executor`, `ExecutorService`, `ListeningExecutorService` and `ScheduledListeningExecutorService` that allow manual progression/execution of the submitted tasks.
I've needed this a number of times while writing tests for classes that rely on these types and it is prone to error each time. Having it in the Guava Teslib would help out.
A possible use would be something like this:
``` java
ScheduledExecutorService e = TestExecutors.newTestExecutor();
Future<?> t = e.schedule(someRunnable, 10, SECONDS);
assertFalse(t.isDone());
e.runAll(10, SECONDS);
assertTrue(t.isDone());
```
Other options would be `runOne` and overloads that only run tasks that are already past their scheduled time.
Hi @mattnathan,
You might be interested in the deterministic implementations of those interfaces that JMock library provides: [DeterministicScheduler](http://www.jmock.org/javadoc/jmock-2.6.0/doc/org/jmock/lib/concurrent/DeterministicScheduler.html) and [DeterministicExecutor](http://www.jmock.org/javadoc/jmock-2.6.0/doc/org/jmock/lib/concurrent/DeterministicExecutor.html).
Changing your example a little bit by using `DeterministicScheduler` (which implements `ScheduledExecutorService`):
``` java
DeterministicScheduler e = new DeterministicScheduler();
Future<?> t = e.schedule(someRunnable, 10, SECONDS);
assertFalse(t.isDone());
e.tick(10, SECONDS);
assertTrue(t.isDone());
```
You are allowed to influence the progress manually by using the methods `runPendingCommands`,  `runNextPendingCommand`, `runUntilIdle` and `tick`, respectively.
Thanks for the pointer, will definitely take a look. One of my (unsaid) use cases for this was to have it implement `ListenableScheduledExecutor` too, but it could form the bases of that implementation quite easily I'd expect.
Hey!
I found that the following test will fail with a TimeoutException (the Future hangs indefinitely):
``` java
static final int REPS = 10000;
@Test
SettableFuture<Integer> settableFuture = SettableFuture.create();
ListenableFuture<Integer> chained = settableFuture;
for (int i = 0; i < REPS; ++i) {
chained = Futures.transform(chained, Functions.<Integer>identity());
}
settableFuture.set(0);
Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);
}
```
But if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.
My logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).
Hi Chris!
I think it's perfectly reasonable for you to say that there is a limit to the amount of chaining when using a `directExecutor`. The bit I'm worried about and would love to see resolved is the disappearing `StackOverflowError`. I think the reason it goes missing is because the execution goes along these lines:
1. Start executing a `Future` from the chain
2. Execution succeeds, mark it as 'done'
3. Attempt to execute the next `Future` (use `directExecutor`)
4. Stack overflow
5. Mark current future as 'failed', wait, nope, it's done, don't need to do anything.
It looks like the exception gets absorbed into a completed future (`ChainingListenableFuture` catches it by catching all `Throwable` and calls `setException` which then ignores the exception because the `Future` is already in the `COMPLETED` state).
The exception could go to the caller (so calling `.set(0)` would throw a `StackOverflowError`) - anywhere is better than nowhere.
We did indeed hit this in ["real" code](https://github.com/facebook/buck/commit/6ee1b3e9a44c9b451411b0e376f3c7eff438fe2e) (`MoreFututres.chainExceptions` is [essentially Futures.transform](https://github.com/facebook/buck/blob/master/src/com/facebook/buck/util/concurrent/MoreFutures.java#L169)). The code that was building the chain was silly, so the fix was easy. Like I said at the beginning - the fact that the error was entirely suppressed is the real issue.
Cheers!
I didn't get the last bit:
> `in which case we're back in danger of a stack overflow.`
From my understanding you'd wrap the `StackOverflowError` in something like `FutureExecutionRuntimeException` (which would be re-thrown/ignored by any intermediate futures). That should unwind the stack all the way to the top (which would most likely be a worker thread) where it would manifest as an runtime exception. How could we get another stack overflow in that case?
Looks good to me. I think RuntimeException could also mean that the executor failed or something like that, right? In that case I think the only options to make progress are either logging (+ignore) or re-throwing wrapped in an Error (or `FutureExecutionRuntimeException`).
The semantics of `or` on an `Optional` constructed using `Optional.fromNullable` surprised me. For the sake of example, consider this sample:
``` java
// Assume `possiblyAssignValue` returns type `String` which may per-execution randomly be
// either `"A"` or `null`
String maybeNotNull = possiblyAssignValue();
String definitelyNull = null;
String definitelyNotNull = "C";
System.out.println(Optional.fromNullable(maybeNotNull).or(definitelyNull).or(definitelyNotNull);
```
I would _expect_ that the code would sometimes print out `A` and other times `C`, pursuant to the nullness of `maybeNotNull`; however, the `or` methods will always cause a runtime exception, because they check that the argument is not `null` (or doesn't evaluate to `null`).
In my case, I am using `Optional` to help parse a response from a server, which might contain one element or another, mutually-exclusively: if I try and use `or` to do this (which I think is reasonable), then the code throws a runtime exception anytime the first element is present. In this case, the contract with the server says that the second can (and should!) be missing.
I'm not sure if it's the best solution, but one solution that presents itself to me is having a complementary set of methods on `Optional` for the two signatures which do not accept an `Optional` argument, such as `orNullable` which checks whether `defaultValue` or `supplier.get()` evaluate to `null` and return `Optional.absent` instead of throwing an exception. Such a solution would allow developers to both idiomatically code against their own assumptions about the mutual-exclusivity of two values' nullness, and explicitly handle edge cases (e.g. where the supplied default value is unexpectedly `null`) themselves.
Can't you use the following?
```
Optional<String> maybePresent = Optional.fromNullable(possiblyAssignValue());
Optional<String> definitelyAbsent = Optional.absent();
Optional<String> definitelyPresent = Optional.of("C");
String value = maybePresent.or(definitelyAbsent).or(definitelyPresent);
```
Here is the scenario.
I have a `Map<String,Object>` of defaults for something.
I want to build up a customized set of things that can be a partial set of those defaults.
I want to be able to overlay these customized things over the default and produce an `ImmutableMap` union of these two ( or more ) maps.
Right now I have to do this with a mutable map implementation and then wrap that with `.copyOf()`, I would rather be able to do it directly with the existing `Builder` implementations but I can not because they will throw exceptions because of the duplicate keys.
`Map<String,Object> mergedMaps = ImmutableMap.builder().putAll(defaults).put("custom","value").build();`
or
`Map<String,Object> mergedMaps = ImmutableMap.builder().putAll(defaults).putAll(partialOverlay).build();`
Is this something you will consider implementing?
Assuming the map of defaults specifies the complete domain, I suppose you could do the following:
``` java
Map<String, Object> defaults = ...;
Map<String, Object> custom = ..;
Map<String, Object> merged = ImmutableMap.copyOf(Maps.transformEntries(defaults, custom::getOrDefault));
```
Note that `Maps::transformEntries` produces a view, so there's no unnecessary copying here.
This is just as good if not better because of the possibility of unnecessary copying!
I am on Java 7 so I ended up with this.
```
final Map<Fields,Object> merged = ImmutableMap.copyOf(ImmutableMap.copyOf(Maps.transformEntries(defaults, new Maps.EntryTransformer<Fields, Object, Object>() {
final Map<Fields,Object> custom = imb.build();
@Override public Object transformEntry(@Nullable final Fields key, @Nullable final Object value)
{
return custom.containsKey(key) ? custom.get(key) : value;
}
})));
```
Thanks for the prompt response!
Here is a [link to a complete Gist](https://gist.github.com/jarrodhroberson/780d38e41df96f2be980) that I use all the time now!
There are several significant new collection methods in Java 8 (especially on the Map interface). Tests for these should be added to the guava collection test suite.
verifySimpleMessage(expected)  change to assertThat(expected).hasMessage("A message"),
so that the  compared target("A message") can be saw straightway
I signed it!
this is my first contribute in open source
exciting and hope to be accepted
Use-case (related to http://stackoverflow.com/q/1391918/14731 and http://stackoverflow.com/a/1815793/14731):
I'm using Fork/Join to populate a `ConcurrentHashMap`. Unfortunately, the latter does not guarantee iteration order (which I need). So now, every time I insert into the `ConcurrentHashMap` I also insert the key into a `ConcurrentLinkedQueue`. Then, when the user requests the output, I create a new sorted map as follows:
`ImmutableSortedMap.copyOf(concurrentHashMap, Ordering.explicit(new ArrayList<>(concurrentLinkedQueue)));`
This code is very performance-sensitive and from profiling I can tell that `Ordering.explicit()` invokes `Object.equals()` many times on the key. I'd like to instruct `Ordering.explicit()` to use `==` for comparison because (for my particular use-case) it is noticeably faster and perfectly legal (the same keys are added into the `Map` and `Queue`).
When some data are pushed to a system, we often need to get feed back mentioning if the pushed data were correct or not. If there is some errors or warnings, the client system expects to get an object containing all errors or warnings. It can be a simple list of `String` but it is more convenient if :
- Prebuild severity level are possible : "error", "warn".. and "info" ?
- The object has method such as `hasErrors`, `hasWarnings`, ...
- The obkect is nestable : an item can be a validation result itsef and not only a string
- The class has fluent style factory methods (or builder) for creating  the validation result.
Martin Fowler exposes this pattern as "Notification" : http://martinfowler.com/eaaDev/Notification.html
ImmutableSortedSet.copyOf(Collection) should fail if the input collection is not comparable.
This currently applies for most collections, but fails if the input is a singleton.
This is recorded in issue #1835.
I have noted that this is caught within TreeSet by invoking the comparator on the singleton item, so this change makes a similar call to catch the un-comparable items in a singleton ImmutableSortedSet.
I have added tests for a two-element input collection (which was already caught), and a new test for a single-element input; this latter test only passes once the code change has been inserted.
_This includes some people who define Comparators that throw if given equal elements!_
Note (just for info) that this is exactly what TreeSet does when you insert its first element.
The comparator call is what triggers the failure here:
```
SortedSet<Object> sortedSet = new TreeSet<Object>();
sortedSet.add(notComparable);
```
Fix for issue #2241
I signed it!
I've got some lazy iterators that I may or may not end up evaluating, but when I pass them into MergingIterator they are evaluated at construction time:
```
for (Iterator<? extends T> iterator : iterators) {
if (iterator.hasNext()) {
queue.add(Iterators.peekingIterator(iterator));
}
}
```
It would be nice to preserve the laziness of the passed in iterators by having the initialization happen during runtime. Seems like it would be pretty easy to wrap up the queue initialization into a memoized supplier.
Almost... I expect //2 to (potentially) read off all the supplied iterators, yet it currently happens at //1.
[UseGuavaInYourBuild](https://github.com/google/guava/wiki/UseGuavaInYourBuild) is out-of-date as it refers to old versions of guava, specifically 12.0 and 10.0.1 as opposed to the latest release 18.0.
As the latest releases are documented in the [README](https://github.com/google/guava/blob/master/README.md) file this wiki-page does not really serve a purpose, and can probably be removed.
An attempt to call _com.google.common.reflect.ClassPath#from_ ends with NullPointerException on IBM WebSphere 8.5.5.5. The following snippet from _com.google.common.reflect.ClassPath#getClassPathEntries_ causes issues:
``` java
URLClassLoader urlClassLoader = (URLClassLoader) classloader;
for (URL entry : urlClassLoader.getURLs()) {
```
_getURLs()_ on _com.ibm.ws.bootstrap.ExtClassLoader_ returns null:
``` java
public URL[] getURLs() {
return null;
}
public URL[] _getURLs() {
return super.getURLs();
}
```
The `tryParse` methods should behave similarly:
```
Floats.tryParse(null)   -> null
Ints.tryParse(null)     -> NPE
```
For a method like this I would prefer the null result since otherwise I would use the Java parseInt. But if they all should throw NPE I think that should be clearer in the JavaDoc (even if you normally do not document @NotNull parameters).
Just an idea: maybe they should return an optional and never throw? But then that would really break the api.
The String "null" leads to null - but for all tryParse variations (and its expected).
No it is not the String null. It is exacyly as I wrote it at the top:
```
Floats.tryParse(null)   -> null
Ints.tryParse(null)     -> NPE
```
And since you usually use methods like this in I/O I think they should be very forgiving, ie. accept null and not throw NPE on it.
I found it while trying to convert json to Java Objects where the JavaScript framework inserted null values instead of empty string (the json included both Integers and Doubles).
just simply null the string
`Longs.tryParse` returns a boxed `Long`, which is unboxed to the primitive `long`.
Unboxing a null value yields a NPE, so even something returning `null`, for instance `Longs.tryParse("a")` passes the test.
Solution: use the boxed type `Long` for the `unused` var
The only things I can think of is that it was an:
2 We somehow got another library without noticing (the dependency list was quit long)
But it is all the same since the behavior is consistent (now). (But sadly not what we needed so were using apache commons)
Sorry for the miss report
I'm trying to run only one of the selected test cases via `mvn` like this:
```
mvn -Dtest=UntrustedInputFutureTest#testSetFutureThenInterrupt test
```
But this doesn't work, `mvn` says `There are no tests to run.`.
How should I run only one test case?
Hi,
You are not able to run this test case using maven because this is defined using junit.framework.TestCase. This can be run by overriding the runTest() method or by creating a testSuite.
This could be a compiler bug, or it could be an issue with the way `ImmutableMap.Builder()` functions.
Here is my sample class which produces the compilation error (stack overflow during compile)
``` java
import java.util.Map;
import java.util.UUID;
import com.google.common.collect.ImmutableMap;
public class MapTest {
private static final Map<String, Object> map = new ImmutableMap.Builder<String, Object>()
.put("cbc3fdad-01ed-4f90-a75d-b239fb99acab", new Object())
.put("621a7f96-3513-4b4a-9c35-bc80fbc42f18", new Object())
.put("c95de3a1-da02-45a8-9cd4-2f6014fb47a6", new Object())
.put("6a759307-b797-40d7-9e53-fc3c335b73b4", new Object())
//... (10,000 total puts)
.build()
}
```
Here is the command used to compile the class (note: I first encountered this with guava 16, then thinking it may have already been fixed it duplicated the error with v 18)
``` text
$> javac -classpath guava-18.0.jar MapTest.java
The system is out of resources.
Consult the following stack trace for details.
java.lang.StackOverflowError
at java.util.regex.Pattern$1.isSatisfiedBy(Pattern.java:4111)
at java.util.regex.Pattern$5.isSatisfiedBy(Pattern.java:5251)
at java.util.regex.Pattern$5.isSatisfiedBy(Pattern.java:5251)
at java.util.regex.Pattern$CharProperty.match(Pattern.java:3776)
at java.util.regex.Pattern$GroupHead.match(Pattern.java:4658)
at java.util.regex.Pattern$Branch.match(Pattern.java:4602)
at java.util.regex.Pattern$Branch.match(Pattern.java:4602)
at java.util.regex.Pattern$Branch.match(Pattern.java:4602)
at java.util.regex.Pattern$BranchConn.match(Pattern.java:4568)
at java.util.regex.Pattern$GroupTail.match(Pattern.java:4717)
at java.util.regex.Pattern$Curly.match0(Pattern.java:4279)
at java.util.regex.Pattern$Curly.match(Pattern.java:4234)
at java.util.regex.Pattern$GroupHead.match(Pattern.java:4658)
at java.util.regex.Pattern$Branch.match(Pattern.java:4604)
at java.util.regex.Pattern$Branch.match(Pattern.java:4602)
at java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3798)
at java.util.regex.Pattern$Start.match(Pattern.java:3461)
at java.util.regex.Matcher.search(Matcher.java:1248)
at java.util.regex.Matcher.find(Matcher.java:664)
at java.util.Formatter.parse(Formatter.java:2549)
at java.util.Formatter.format(Formatter.java:2501)
at java.util.Formatter.format(Formatter.java:2455)
at java.lang.String.format(String.java:2940)
at com.sun.tools.javac.comp.DeferredAttr$DeferredTypeMap.<init>(DeferredAttr.java:828)
at com.sun.tools.javac.comp.Attr.checkMethod(Attr.java:3815)
at com.sun.tools.javac.comp.Attr.checkIdInternal(Attr.java:3593)
at com.sun.tools.javac.comp.Attr.checkMethodIdInternal(Attr.java:3504)
at com.sun.tools.javac.comp.Attr.checkMethodId(Attr.java:3479)
at com.sun.tools.javac.comp.Attr.checkId(Attr.java:3466)
at com.sun.tools.javac.comp.Attr.visitNewClass(Attr.java:2072)
at com.sun.tools.javac.tree.JCTree$JCNewClass.accept(JCTree.java:1516)
at com.sun.tools.javac.comp.Attr.attribTree(Attr.java:566)
at com.sun.tools.javac.comp.Attr.attribArgs(Attr.java:664)
at com.sun.tools.javac.comp.Attr.visitApply(Attr.java:1806)
at com.sun.tools.javac.tree.JCTree$JCMethodInvocation.accept(JCTree.java:1465)
at com.sun.tools.javac.comp.Attr.attribTree(Attr.java:566)
at com.sun.tools.javac.comp.Attr.visitSelect(Attr.java:3227)
at com.sun.tools.javac.tree.JCTree$JCFieldAccess.accept(JCTree.java:1897)
at com.sun.tools.javac.comp.Attr.attribTree(Attr.java:566)
at com.sun.tools.javac.comp.Attr.visitApply(Attr.java:1815)
at com.sun.tools.javac.tree.JCTree$JCMethodInvocation.accept(JCTree.java:1465)
at com.sun.tools.javac.comp.Attr.attribTree(Attr.java:566)
at com.sun.tools.javac.comp.Attr.visitSelect(Attr.java:3227)
at com.sun.tools.javac.tree.JCTree$JCFieldAccess.accept(JCTree.java:1897)
// stack trace repeats
```
Here is my Java version
``` text
java version "1.8.0_60"
Java(TM) SE Runtime Environment (build 1.8.0_60-b27)
Java HotSpot(TM) 64-Bit Server VM (build 25.60-b23, mixed mode)
```
Here is the dummy code I used for generating the source code to do 10,000 puts on the map
``` java
import java.util.UUID;
public class MapTest {
public static void main(String[] args) {
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 10000; i++) {
String id = UUID.randomUUID().toString();
sb.append("    .put(").append(quote(id)).append(", new Object()").append(")").append(System.lineSeparator());
}
System.out.println(sb);
}
private static final String quote(String s) {
return '"' + s + '"';
}
}
```
Changed compile command to the following and still getting the same error:
``` text
javac -J-Xmx4096m -classpath guava-18.0.jar MapTest.java
```
Also the code isn't in a method so is that size limit still enforced?
Oops my bad, your suggestion fixes my compilation problem.  Thanks for the help and information!
At present, the Range abstraction is implemented in terms of Cut, but the Cut type (and the Range constructor that utilizes that type) is package-private.
Cut seems like a mathematically-sound concept -- something that's unlikely to change soon. And there are a number of Range construction use cases where the ability to define a new Range in terms of Cuts would be a useful public operation to support. One common use case has to do with Nullable (or Optional, as you will) bounds. It's often the case that APIs, particularly external APIs like RESTful interfaces, might provide either or none of the endpoints of a range, particularly as part of a filtering request from a client. It's difficult to use the existing bounds-based static factories on Range to construct an appropriate Range easily because they (understandably) don't accept null bounds. So there's typically a lot of branching code to call the correct static factory such as .all(), .atLeast(), .atMost(), or closed() depending on whether none, either, or both of the bounds have been specified by a client
```
// Assume lowBound and highBound are Optional<T extends Comparable<T>>
final Cut<T> lowCut = lowBound.isPresent() ? Cut.<T>belowValue(lowBound.get()) : Cut.<T>belowAll();
final Cut<T> highCut = highBound.isPresent() ? Cut.<T>aboveValue(highBound.get()) : Cut.<T>aboveAll();
return new Range<T>(lowCut, highCut);
```
Without the ability to express the range conditions a bit more abstractly, code like that above leads to a lot of branching code to determine the correct static factory to invoke on Range.
If Cut is not the abstraction to expose publicly, maybe there's some other compact solution to this (at least in my experience) common use case of Optional / Nullable bounds?
Thanks, @lowasser -- your alternative may help in a number of cases I've run into. I'll close this issue based on the quick replies.
Toss this code block in a test class somewhere with appropriate imports.
```
static class Foo {
int value;
boolean fieldThatEqualsDoesNotUse;
Foo(int i, boolean b) {
value = i;
fieldThatEqualsDoesNotUse = b;
}
public int hashCode() {
return Objects.hashCode(value);
}
public boolean equals(Object o) {
if (o instanceof Foo) {
}
return false;
}
}
@Test
public void test() {
Foo f1 = new Foo(1, false);
Foo f2 = new Foo(2, true);
Foo f3 = new Foo(1, true);
Set<Foo> s1 = ImmutableSet.of(f1, f2);
// filter removes f1, leaving only f2
Set<Foo> filtered = Sets.filter(s1,
new Predicate<Foo>() {
return foo.fieldThatEqualsDoesNotUse;
}
});
assert !filtered.contains(f3);
}
```
The assert fails.
`f3.equals(f1)` is true, so a `.contains(f3)` check on the unfiltered set passes. This is correct. `f3` also passes the filter's predicate. These two facts combine in the current implementation of `FilteredCollection.contains()` to say that the filtered set contains `f3`, which is not correct.
### Problem:
Very small double values break the RateLimiter resulting in it allowing many more permits than it should. The tests below are similar to the ones in com.google.common.util.concurrent.RateLimiterTest but do not use a stopwatch.
### Test Case 1: Create with limit of Double.MIN_VALUE
```
RateLimiter r = RateLimiter.create(Double.MIN_VALUE);
assertTrue("Unable to acquire initial permit", r.tryAcquire());
assertFalse("Capable of acquiring an additional permit", r.tryAcquire());
Thread.sleep(5000);
assertFalse("Capable of acquiring an additional permit after sleeping", r.tryAcquire());
```
> Fails the second assertion ("Capable of acquiring an additional permit")
### Test Case 2: Create with limit of .0001
```
RateLimiter r = RateLimiter.create(.0001);
assertTrue("Unable to acquire initial permit", r.tryAcquire());
assertFalse("Capable of acquiring an additional permit", r.tryAcquire());
Thread.sleep(5000);
assertFalse("Capable of acquiring an additional permit after sleeping", r.tryAcquire());
```
> Succeeds
### Test Case 3: Create with limit of 1E-13
```
RateLimiter r = RateLimiter.create(0.0000000000001);
assertTrue("Unable to acquire initial permit", r.tryAcquire());
assertFalse("Capable of acquiring an additional permit", r.tryAcquire());
Thread.sleep(5000);
assertFalse("Capable of acquiring an additional permit after sleeping", r.tryAcquire());
```
> Fails the second assertion ("Capable of acquiring an additional permit")
Hi,
I do not know if this is correct way to contribute but I added a test case that shows RateLimiter works even for small values. I also sent a PR for that.
Regards,
While using the SimpleStatsCounter class in the com.google.common.cache package, we found that it is not thread-safe as documented. As a simple example, we can have one thread invoking recordLoadSuccess with a non-zero value. It executes loadSuccessCount.increment() and before it can execute totalLoadTime.add(loadTime), if another threads calls a snapshot on the cache, it will return an inconsistent state (where the successCount and loadtime are inconsistent).
Should the methods be synchronized in this class? If not, may be the documentation can be fixed to remove claims on thread-safety?
The challenge is that multiple fields have to be updated together, which cannot be done efficiently. The locking approach won't scale. Creating a new struct (composite update) for a CAS update won't scale due to GC pressure and CAS storms.
Perhaps the only way to implement it efficiently would be thread-local StatsCounters (mimic memcached's approach). The thread would synchronize and update, and the aggregator would synchronize to read. This would allow consistent read/writes with low overhead as the locks are not contended on. However, Java's `ThreadLocal` is not very efficient so a variant of `Striped64` would be required (e.g. see Caffeine's `StripedBuffer`).
Given that the stats are often consumed by a reporter which itself doesn't guarantee atomic updates of composite metrics, this is a moot point. If the stats are being captured as monotonically increasing over the lifetime of the cache, then an inconsistent view has marginal impact.
The current implementation is thread safe, but not atomic. I think that's a reasonable trade-off.
I agree that it is probably an overkill to synchronise to ensure thread-safe behaviour.
But the class is still not thread-safe as Ben suggests above. It is neither atomic nor thread-safe according to the definition of thread-safety by Brian Goetz ("Java Concurrency in Practice"),
> Furthermore, for a class to be thread-safe, it must continue to behave correctly, in the sense described above, when accessed from multiple threads, regardless of the scheduling or interleaving of the execution of those threads by the runtime environment, without any additional synchronization on the part of the calling code. The effect is that operations on a thread-safe object will appear to all threads to occur in a fixed, globally consistent order.
We all seem to agree that there won't be a globally consistent order here. Therefore, the documentation probably can be updated to remove the thread-safe guarantee and clarify the intended semantics of the SimpleStatsCounter (similar to AbstractCache.cacheStats()).
A slightly looser definition is what is used in practice. The term is typically meant as whether the class functions correctly when operated on by multiple threads. What "correctly" means is defined by the API contract. This more liberal definition is used by Wikipedia,
> A piece of code is thread-safe if it only manipulates shared data structures in a manner that guarantees safe execution by multiple threads at the same time.
`SimpleStatsCounter` is thread-safe in terms of the contract's requirements, which includes the necessary caveats. If those were missing or not honored, then the races would break the thread safety requirements. The requirements is monotonically increasing counts over the lifetime of the cache, with an inconsistent snapshot view of those counts. If counters were lossy (e.g. non-volatile updates) then it couldn't honor its contract when operated on by multiple threads.
Adding more documentation can't hurt, though.
Yes, but instead of one per counter there could be one per composite. Then the composite is `synchonized` on to read or write to it. The aggregation would be like `sum`. Each composite would be updated as a single step so the inconsistency wouldn't be visible. Due to the low collision rate, `synchronized` would not be contended and use spin locking instead of a full lock.
[StripedBuffer](https://github.com/ben-manes/caffeine/blob/master/caffeine/src/main/java/com/github/benmanes/caffeine/cache/StripedBuffer.java) already adapts `Striped64` to custom objects. In that case a lock-free ring buffer. A variant could be used to operate on composite counters.
A [quick hack](https://github.com/ben-manes/caffeine/commit/4c7ed823b425d8fffc13b332dd4d351cef81f843) showing what this would look like. The only missing portion is to have custom bi-functions to avoid creating a new capturing function on every call (avoid GC). Other than that making it pretty and benchmarking would be necessary.
An updated [example](https://github.com/ben-manes/caffeine/commit/4bcc696ebf3154a75c1bcc87e7502b352b74c91b) that is cleaned up a bit. Using a simple JMH benchmark of 8 threads incrementing the counts and 1 thread reading we get the following on a 4-core / 8HT laptop.
```
StatsBenchmark.stats:record        atomic  thrpt   10  171937150.141 ops/s
StatsBenchmark.stats:snapshot      atomic  thrpt   10     109742.654 ops/s
StatsBenchmark.stats:record    concurrent  thrpt   10  152614121.235 ops/s
StatsBenchmark.stats:snapshot  concurrent  thrpt   10    3928269.479 ops/s
```
Not surprisingly the writes are a little faster by combining the operations but the read performance is reduced. That's because writers now contend with reads, so the impact is observable. Of course in practice counters won't be heavily contended on and the difference won't matter.
So that's how this could be done. Its a fun exercise, but probably not worth the effort.
Oh, I forgot to add padding to avoid false sharing. A big improvement, but reads are still pretty poor. Updated [commit](https://github.com/ben-manes/caffeine/commit/ab0da7e09b96ad92c0c43131f4a88b7245b2edcc).
```
StatsBenchmark.stats:record        atomic  thrpt   10  215337580.177 ops/s
StatsBenchmark.stats:snapshot      atomic  thrpt   10     182681.894 ops/s
StatsBenchmark.stats:record    concurrent  thrpt   10  156842262.685 ops/s
StatsBenchmark.stats:snapshot  concurrent  thrpt   10    4037267.672 ops/s
```
Hi,
The following test fails on the last line.
First item is not evicted.
It fails for version 18 and 19 rc2.
```
Cache c = CacheBuilder.newBuilder()
.concurrencyLevel(4)
.maximumSize(1000)
.expireAfterAccess(10000L, TimeUnit.SECONDS)
.build();
for (int i = 0; i < 1000;  ++i) {
c.put(i, "v" + i);
}
assertNotNull(c.getIfPresent(0));
for (int i = 1000; i < 1003;  ++i) {
c.put(i, "v " + i);
}
assertNull(c.getIfPresent(1));
assertNull(c.getIfPresent(2));
c.cleanUp();
assertNull("BB " + c.getIfPresent(0), c.getIfPresent(0));
```
`getIfPresent(0)` is an access, so that entry moves from the least recently used status to the most recently used. If instead `asMap().containsKey(0)` is used then the tests passes. That's a fluke, as @lowasser explains. It can be deterministic if setting `concurrencyLevel(1)`, at which point strict LRU is enforced. Guava uses that trick for its unit tests, but it is not part of the API contract.
If I want to load a resource I have found by classpath scanning with `ClassPath`, I need to use `Resources.asByteSource(resourceInfo.url())`. This is only little code, but hard to discover because it uses a third class `Resources` which is neither related to what I have (`ResourceInfo`) nor what I want (`ByteSource`). I also need to remember that I should go via the URL and that I cannot use `ResourceInfo.getResourceName()`.
A direct method to get a `ByteSource` from a `ResourceInfo` would make this easier. Alternatively, this should be documented at least.
Hi folks
as we can see the methods of Cache interface, most of them are generic except `getIfPresent(Object key)`:
``` java
public interface Cache<K, V> {
...
V getIfPresent(Object key);
V get(K key, Callable<? extends V> valueLoader) throws ExecutionException;
...
void put(K key, V value);
...
```
is it intended? why not `V getIfPresent(K key)` to be consistent?
thanks
 XD
2015-11-16 14:12 GMT+08:00 Nick Tan notifications@github.com:
> Hi folks
>
> as we can see the methods of Cache interface, most of them are generic
> except getIfPresent(Object key):
>
> public interface Cache<K, V> {...
>   V getIfPresent(Object key);
>
>   V get(K key, Callable<? extends V> valueLoader) throws ExecutionException;...
>   void put(K key, V value);...
>
> is it intended? why not V getIfPresent(K key) to be consistent?
>
> thanks
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2227.
##
_ _
It's the [robustness principle](https://en.wikipedia.org/wiki/Robustness_principle). Consider the following case:
```
interface Foo { }
class Key implements Foo, Bar { }
Key key = new Key();
Foo foo = key;
Bar bar = key;
Cache<Foo,String> cache = ...
cache.put(foo, "key");
String str = cache.getIfPresent(bar);
assertNotNull(str);
```
It's certain that I can retrieve `"key"` using `foo` as key. But since `foo == bar`, why shouldn't I be able to retrieve `"key"` using `bar` as key?
**tl;dr:** A Cuckoo Filter provides similar functionality to a Bloom Filter with lower hashing overhead and deletion support.
**Add:** `public interface ProbablisticFilter`
**Add:** `public class CuckooFilter implements ProbablisticFilter`
**Modify:** `public class BloomFilter` **`implements ProbablisticFilter`**
The Cuckoo Filter is described in this paper: [Cuckoo Filter: Practically Better Than Bloom](https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf). Quoting from the abstract:
> We propose a new data structure called the cuckoo filter that can replace Bloom filters for approximate set membership tests. Cuckoo filters support adding and removing items dynamically while achieving even higher performance than Bloom filters. For applications that store many items and target moderately low false positive rates, cuckoo filters have lower space overhead than space-optimized Bloom filters. Our experimental results also show that cuckoo filters outperform previous data structures that extend Bloom filters to support deletions substantially in both time and space.
Possbile Interface:
``` java
public interface ProbablisticFilter<T> {
boolean mightContain(T object);
boolean put(T object);
long size(); // cardinality
long capacity(); // or expectedInsertions()
double expectedFpp();
}
```
We can contribute an implementation that follows the norms of the `BloomFilter` design if there's interest.
/cc @binfan999 @apc999 @dave-andersen @mkaminsky & Michael Mitzenmacher (couldn't find his GitHub username)
A casual read, this looks similar to [TinySet](http://www.cs.technion.ac.il/users/wwwb/cgi-bin/tr-get.cgi/2015/CS/CS-2015-03.pdf) and [TinyTable](http://www.cs.technion.ac.il/users/wwwb/cgi-bin/tr-get.cgi/2015/CS/CS-2015-04.pdf).
@bdupras thinks for ping me on this issue. I will be able to help if there is anything needed from my side.  Question here, I guess for `CuckooFilter`, it will implement `delete` (or similar) as that is the differentiator of CuckooFilter from BloomFilter, right?
@ben-manes I think cuckoo filter shares the similar idea of TinySet in the way they both store fingerprints in a hash table for approximate set-membership tests (like BloomFilter). One key difference is TinySet is more like using traditional open-addressing hashtable, while cuckoo filter is built based on partial-key cuckoo hashing (see more in our paper  Cuckoo Filter: Practically Better Than Bloom). My very biased view is, in the context of achieving really high-space efficiency and also good performance, partial-key cuckoo hashing is very easy to understand and implement correctly. :)
> ... `CuckooFilter`, it will implement `delete` (or similar)
Yes, absolutely. Perhaps as a separate interface, e.g. ...
``` java
public interface DeletableFilter<T> {
boolean delete(T object);
}
```
@apc999 I'll see if I can get our first attempt at an implementation out to a place where you can have a look. Nicely written paper, by the way - very easy to understand.
A few things of note about our implementation...
We chose a different strategy for calculating the alternate index. The paper's method using `xor` has a side-effect of requiring the number of buckets (B) to be a power of 2. Our implementation calculates an offset from the current index that is always odd, and then applies that offset positive or negative depending on whether the current index is even or odd, wrapping around the ends of the bucket array as necessary. This requires only that the number of buckets be even, giving us more flexibility in the memory footprint than power of 2.
We also implemented rollback on insert such that if we exhaust the max_kicks, we rollback and leave the filter in a consistent state before throwing an insertion error.
1. Our fingerprint is the first non-zero string of bits in the hash of the key. If the hash is 0, the fingerprint is 1. Without this, it's ambiguous if a cell containing 0 is empty, or contains a fingerprint of 0.
2. We created a "growable cuckoo filter" which contains a list of cuckoo filters. If a cuckoo filter is full, we allocate another filter and insert into that. The rollback on insert makes this possible (otherwise an insert failure drops data).
Thanks @kevinb9n. We'd certainly welcome an interface to implement against. Would you be interested in us providing a pull request to do that?
@kluever, we noticed in issue #1518 that you requested deletion support from the Bloom Filter. Are you still interested having a deletable filter implementation?
We are using the cache to cache some textures in our game, lets say you have a cache with a max size of 10 textures, if you tried to you use the cache to cache 11 textures, the cache becomes useless because it will keep evicting randomly old textures, which cost us rebuilding the texture, if the cache respect the size, then it will just keep the 10 textures in cache and we only need to reload/rebuild texture-11.   This way the cache will save us 95% of the cost of build textures1-10, now it simply like you don't have a cache !
Am I missing something ?
if (cache.isFull()){
cacheloader.load
//don't add it to the cache
}else{
cacheloader.load
//add to the cache
}
Guava uses the least-recently-used (LRU) policy, which evicts from the cache the entry that was last accessed the furthest in the past. This means that new entries are given priority over older ones by predicting that there will be a burst of new activity. In a game when a player enters inside a building, this prediction guesses that the player will stay in doors for a while, so keeping recently viewed content in the cache makes sense. Of course, that prediction may be wrong as the player may more frequently stay outside (least-frequently-used - LFU), so other policies try to find an [optimal balance](https://github.com/ben-manes/caffeine/wiki/Efficiency).
A caveat that may also be causing confusion is that Guava's Caches evict prior to reaching the maximum size threshold. This is a documented implementation quirk, with good arguments on both sides of whether this is preferable. Regardless, the cache will likely stay slightly below the maximum so a small cache (10) will be more affected by this detail.
Using LRU or LFU are fine as long as you're respecting expireAfterWrite or expireAfterAccess. This is not about a game, it's about showing that if you overshot the size of the cache even by one item then the whole cache will become useless. I wrote some code and I'll share code, but first I'll share the results.
``` java
[Cache max size (9) and trying to load (10) items]
[Respect Max Size][Total Time:1907][Loading Count:19][Removal Count:0]
```
This code will simply load 10 items , 10 times, I added some delay (Thread.sleep(100)) to make loading expensive. The code does this through 2 methods and compare the benefits of the cache, the first is the default method (i.e. get(key)), the second method I will check  if the cache is full and simply skip loading the item from the cache (or adding it to cache) and as you see the default method made the cache useless (100% loading) also notice the total time in the second method (20%).
#
# Example Code
``` java
import java.util.concurrent.TimeUnit;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import com.google.common.cache.RemovalListener;
import com.google.common.cache.RemovalNotification;
public final int MAX_CACHE_SIZE = 9;
public int removalCount = 0;
public int loadingCount = 0;
private RemovalListener<String, String> removalListener = new RemovalListener<String, String>() {
public void onRemoval(RemovalNotification<String, String> notification) {
// System.out.println("Removal [Count:" + removalCount + "][" +
// notification.getKey() + ":" + notification.getValue() + "] ");
removalCount++;
}
};
LoadingCache<String, String> uselessCache = null;
public void newCache() {
uselessCache = CacheBuilder.newBuilder().maximumSize(MAX_CACHE_SIZE).expireAfterWrite(10, TimeUnit.SECONDS).removalListener(removalListener).build(new CacheLoader<String, String>() {
public String load(String key) {
return doLoad(key);
}
});
}
public String doLoad(String key) {
// loading expensive item
String value = key + "-LOADED";
try {
Thread.sleep(100);
e.printStackTrace();
}
//System.out.println("Loading [Count:" + loadingCount + "][" + key + ":" + value + "] ");
loadingCount++;
return value;
}
public String get(String key, boolean defaultGuava) {
String value = null;
value = uselessCache.getUnchecked(key);
} else {
value = uselessCache.getIfPresent(key);
if (value == null) {
if (uselessCache.size() >= MAX_CACHE_SIZE) {
value = doLoad(key);
} else {
value = uselessCache.getUnchecked(key);
}
}
}
return value;
}
public static void main(String[] args) {
gt.newCache();
System.out.println("[Cache max size (9) and trying to load (10) items]");
long lastTime = System.currentTimeMillis();
for (int l = 0; l < 10; l++) {
for (int i = 0; i < 10; i++) {
String item = gt.get("" + i, true);
// System.out.println("Got item:" + item);
}
}
long totalTime = System.currentTimeMillis() - lastTime;
gt.loadingCount = 0;
gt.removalCount = 0;
gt.newCache();
lastTime = System.currentTimeMillis();
for (int l = 0; l < 10; l++) {
for (int i = 0; i < 10; i++) {
String item = gt.get("" + i, false);
// System.out.println("Got item:" + item);
}
}
totalTime = System.currentTimeMillis() - lastTime;
System.out.println("[Respect Max Size][Total Time:" + totalTime + "][Loading Count:" + gt.loadingCount + "][Removal Count:" + gt.removalCount + "]");
}
}
```
I did the your modification (Random access) and you're right about the 0.9 hit rate, but my method also provides the same results in both cases. There are many use cases where you would need to cycle through items, for examples; files in a directory or GUI children, etc.
If you compare your example to a different policy, like W-TinyLFU, then the hit rates are much better. As @lowasser said, this is because you're access patterns are very unfriendly for LRU so it makes the wrong predictions. Your `Respect Max Size` is the optimal hit rate since you know the access pattern is uniformly a full loop so the manual load will be best to evict / not admit. Adding Caffeine I get,
```
[Cache max size (9) and trying to load (10) items]
[Default Caffeine][Total Time:3109][Loading Count:30][Removal Count:21]
[Respect Max Size][Total Time:1967][Loading Count:19][Removal Count:0]
```
```
```
I regularly use `ImmutableMap.of(k,v)` to make up for the lack of a Map literal in Java as I find the syntax to be cleaner than initialising a map and putting stuff into it (and immutability is an added bonus). Since my use of this class is for brevity, I like to statically import the method as the immutability is not part of my intent. However the method name `of` does not read well as it does not indicate that Im building a map. As a result I have been using a [wrapper class](https://gist.github.com/mrmanc/8a290b9cf4d59964e8e0) to achieve the same result:
`assertThat(result).isEqualTo(mapOf("version","61d85376"));`
Each time I cant help wondering whether the community would embrace something like this in the original code, so I thought Id raise an issue to discuss this :smile:
An alternative would be to use `ImmutableMap.builder().put(key, value).build()`, and that would be nice if `ImmutableMap.builder()` was `ImmutableMap.map()` but I prefer the one-less-hop method Im using.
Of course there might be a much nicer option that Ive completely missed, and if that is the case I look forward to finding out!
I believe this is a duplicate of #1062.
@lowasser That's great to hear! I thought the dropping of literals in Java 8 was the end of it.
@ogregoire Thanks, you're absolutely right; this is a duplicate of #1062, which didn't come up in my searches. Closing this issue.
A `ComparisonTester` that is similar to `EqualsTester` but tests a `compareTo` method or a `Comparator` would be great to have.
Possible interface:
```
public class ComparisonTester {
public ComparisonTester addEquivalenceGroup(Object... equivalenceGroup);
public ComparisonTester testCompareTo();
public ComparisonTester testComparator(Comparator<?> comparator);
}
```
The expected order of objects could be simply defined by the order of calls to `addEquivalenceGroup`.
The class would test that objects within each equivalence group are deemed equivalent, that the order of equivalence groups matches the actual ordering, that `compareTo` is reflexive etc.
Testing `compareTo` of `Comparable` classes could then also be added to `ClassSanityTester` and `AbstractPackageSanityTests`.
Just had one of our Oracle colleagues ask if we had something like this.  I guess a lot of folks who don't use ComparisonChain end up implementing contract-violating compareTo methods, and they were hoping to recommend something like guava-testlib to help them.
I recently went over all `Comparator`s and all `compareTo` implementations in our code base, and indeed the majority of those that did not use ComparisonChain were wrong. So open-sourcing your ComparisonTester would be really appreciated.
Consider the use case: I want to read a ciphered, gzipped text file. This is done using the following code:
```
File file = ... ;
String text = Gzip.unzip(Cipher.uncipher(Files.asByteSource(file), cipher)).asCharSource(UTF_8);
```
It's rather straightforward. If I want to rewrite the file, it's easy, I just do the opposite :
```
Gzip.zip(Cipher.cipher(Files.asByteSource(file), cipher)).asCharSource(UTF_8).write(modifiedText);
```
First, I have to keep the information about the file, the cipher and the encoding myself. It's not really good.
Second, not everything is that straightforward. Sometimes, decisions at runtime, based on the content itself (various formats, encoding). This happens directly in the `{Byte,Char}Source` and has to be preserved when writing into the `{Byte,Char}Sink`. Here comes the context.
Each level of writing should have its own context, but that context should also be publicly accessible so that the information can be retrieved by the user when actually using the streams.
A way I thought about implementing this is maybe to have chained streams containing their own context and which can return the final `{Byte,Char}Source` and its corresponding `{Byte,Char}Sink`.
For instance:
| Level | ByteSource | Stream | ByteSink |
| --- | --- | --- | --- |
| File | FileByteSource | FileStream (holds path) | FileByteSink |
| byte <-> char | ByteToCharSource | ToCharStream (holds charset) | ByteToCharSink |
| gzip | GzipSource | GzipStream (holds zip level) | GzipSink |
Example of usage:
```
CharStream stream = Gzip.wrap(Cipher.wrap(Files.asByteStream(file), cipher)).asCharStream(UTF_8);
CharSource usableSource = stream.asSource();
CharSink usableSink = stream.asSink();
Charset charset = usableSource.getContext(ByteToCharContext.class).getCharset();
File file = usableSink.getContext(FileContext.class).getFile();
```
The main disadvantage if I write a single wrapper is that I have to write all the wrappers. Let's imagine I have the following:
```
File file = ... ;
ContextualByteSource byteSource = ContextualFiles.asByteSource(file);
ContextualCharSource charSource = byteSource.asCharSource(UTF_8);
```
What you're saying is that I'd have to totally rewrite the API to support this.
This is why I requested it in the first place. Because I think it's a win for the API (keeping the context is not so rare) and because implementing it myself, while entirely possible, is basically writing the whole Byte/CharSource/Sink api (including relevant factory methods) but with an extra method.
The first link seems broken:
([How to do this easily in Eclipse.](http://piotrjagielski.com/blog/working-with-static-imports-in-eclipse/))
I agree, it doesn't really have any added value.
Thanks! :-)
I don't think we should care about allocations/speed in unit tests.
Seems like it would be prudent to cut Truth 1.0 first?
Is there a refaster plugin to migrate?
for example:
@Test
public void test05() throws Exception {
ListeningScheduledExecutorService executor = MoreExecutors.listeningDecorator(Executors.newSingleThreadScheduledExecutor());
ListenableScheduledFuture<Long> future = executor.schedule(() -> {
long now = System.currentTimeMillis();
System.out.println(now);
return now;
}, 1, TimeUnit.SECONDS);
//        Futures.addCallback(future, new FutureCallback<Long>() {
//            public void onSuccess(Long result) {
//                System.out.println(result);
//            }
//
//            public void onFailure(Throwable t) {
//                t.printStackTrace(System.err);
//            }
//        });
Thread.sleep(10 \* 1000);
}
java version: 1.8.0_40
schedule only runs the task once, maybe you want scheduleAtFixedRate or scheduleWithDelay?
It's nice to have a function to test whether a particular string is in which case format.
In a tool application, a string will provided by external code. And if the value matches some known case format, It will then be normalised to a standard format. e.g. if input matches `UPPER_UNDERSCORE` and `LOWER_UNDERSCORE` will both converted to `LOWER_CAMEL`.
Some ideas illustrated as below:
```
/**
* Tests which CaseFormat the <code>value</code> is.
*
* @param value
* @return the case format for the value if found. <code>null</code> if no matches found.
*/
public static CaseFormat test(@Nonnull String value) {
// in worst case, may need to enumerate all format
// some quick test, like first detect underscore then check cases etc may help.
return CaseFormat.Test;
}
/**
* Tests whether <code>value</code> is in this case format.
*
* @param value
* @return <code>true</code> if <code>value</code> is matching case format.
*/
abstract boolean matches(@Nonnull String value);
```
The case I'm facing now is:
1. first, detect which case format the incoming identifier is. (This is what's requested here)
2. if it's known case format, but not target format, then convert it into target format. (this is existing feature)
Ah, I get you now. Sorry for mis-understood your comments in first place.
Regarding the particular case `whatever`, since there is no `HYPHEN` and `UNDERSCORE`, then it should be returning `LOWER_CAMEL`. I do agree that there could be ambiguous, say it can return `LOWER_ALL` as well, if such a case format existing.
On the other hand, at least for a particular type, it can have a `matches` function, as drafted in my original post. In this case, my tool can enumerate supported types one by one, and naturally, there is an ordering as "one-by-one" goes in app code.
Also, even it's un-deterministic for static function included in my original post, e.g.`LOWER_CAMEL` and `LOWER_ALL` case, it either can return first one in natural order (un-deterministic), e.g. definition sequence of enum, or it may return a list of matching (deterministic). I'm not sure the other scenarios, but for my tool, either way works. Since requirement for my case is to find what's the current format, and if it's a known format, then convert it to a _normalised_ format.
Thanks @kevinb9n
I may not open this issue. But I would like to provide more details about my case before leave this ticket rest in peace:
The current `CaseFormat` is from Known to Known conversion. My problem is from Unknown to Known.  I have a data dictionary in XML format, and my tool generates code for Java and .Net. And Id inside the XML file, may follow Java convention (camel), or .Net (First letter capital), or `lower_lower`, or `UPPER_UPPER`. I need this feature to first tell me which known format it is, and if it's supported format, then generates Java/ .Net format id, as well as constant definition.
What I can see it could probably be useful for IDE code formatter/ refactoring tools, but again, I'm not doing any tools like this before, it may not be the case. And even these are valid cases, I am not sure whether it qualifies the criteria. Maybe not.
On the other hand, I cannot find any utility tools satisfy this need either. And that's the reason why I'm asking here.
Alternatively what we are asking is to convert to a given case, no matter what the input format is.
In the reasoning you have given above, it really does not matter as long as we are able to go from a unknown case to a known case.  for example if "whatever" was provided and asked to convert to UPPER_CAMEL, it would return "Whatever" while for "whatEver" or "what_ever" will return "WhatEver"..
Hello,
So I need to compare the return value of newLocation.getName() against something for identifying which case format is it, and then it is possible to convert from that format to the required LOWER_UNDERSCORE
Thanks a lot!!
+5
I don't really care what the current case format for a given incoming string is, but whatever it is, I want to convert it to a specific case format. I'm not sure what systems could make use of finding out what format a string currently is in, but I would think that there's a not-small class of software that would be interested in taking in a string from some external, possibly untrusted, source and converting it to a specific case format.
We have a system that uses a case format for different fields on a variety of data for a variety of scenarios (usually it's display scenarios we care about), and we are not always in control of the input.
The alternative is to run through a bunch of guesses on the source format and see which conversion to a target format yields an identical string. Only then can the conversion be made.
I signed it!
Thanks for explanation. I was looking in dictionary under 'sporting' and I haven't found anything. Apparently under 'sport' there is something that may fit.
Time limited waiting is performed frequently on `Future` and this method overloads `Futures.getUnchecked()` method with one that accepts timeout value.
I signed it!
I signed it!
On Wed, 28 Oct 2015, 6:05 AM googlebot notifications@github.com wrote:
> CLAs look good, thanks!
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/pull/2210#issuecomment-151611921.
To simplify the process of collecting cache stats using e.g. _io.dropwizard.metrics_, `CacheBuilder.recordStats()` should have an overloaded version that accepts a StatsCounter Supplier.
See PR: https://github.com/google/guava/pull/2208
The concern with this is that it allows making foreign calls in critical sections. The code would need to be audited to ensure that an exception thrown by a custom implementation does not leave the cache in an invalid state. A fast but ugly solution would be to wrap a custom `StatsCounter` to consume and log any throwables. There's also the problem of slow foreign calls in critical sections, e.g. network calls, which can't be worked around. So the main task involved is ensuring that the cache is tolerant to custom implementations behaving poorly.
I agree to some point. Since it's an easy task to wrap a custom `StatsCounter` in a _guarded StatsCounter_ it's arguable something that should be done. **The PR is now updated with a quick take on this**.
The issue with slow foreign calls could be adressed by being crystal clear about this in the doc. I believe it's a bit diminishing to think that that shouldn't be enough ;-)
> No heavy work should be done in your custom `StatsCounter` this might affect the performance of the cache in a negative and unpredictable way!
Yep, this is now pretty much what I had in mind and considered doing in my [rewrite](https://github.com/ben-manes/caffeine). However I'd still like to hear feedback from @kevinb9n and friends, because I have a hard time justifying that this customization is useful in practice. I think that's why its been left in a state where it seems intended (by public interface), but not currently provided.
The main reason is to integrate with a framework like JMX, [Dropwizard Metrics](http://metrics.dropwizard.io/), or similar. Most of those approaches support both push and pull based accumulation, so integration is only slightly more painful by pulling the `CacheStats` and diffing if necessary. The other argument I've seen has been to clear the stats by resetting the values to zero. However that is a broken approach for many reasons, and is best done using a snapshot as a baseline to diff from. That leaves the only remaining justification being lighter weight recording, e.g. thread local or non-atomic counters. That's never brought up and, while ugly, can be worked around via decorators.
AFAIK, having this is the only way to collect e.g. success and fail load times (total load time is supported in CacheStats though). Getting rates/histograms directly without the need of a "cache stats collecting worker" is also compelling.
Without having a more complex _"cache stats worker"_ this is what I can come up with using `Cache.stats()`:
``` java
//registering gauges...
Gauge<Long> hitCountGauge = () -> loadingCache.stats().hitCount();
Gauge<Long> missCountGauge = () -> loadingCache.stats().missCount();
Gauge<Long> loadCountGauge = () -> loadingCache.stats().loadCount();
Gauge<Long> evictCountGauge = () -> loadingCache.stats().evictionCount();
Gauge<Long> requestCountGauge = () -> loadingCache.stats().requestCount();
metricRegistry.register(cacheName + ".hit_count", hitCountGauge);
metricRegistry.register(cacheName + ".miss_count", missCountGauge);
metricRegistry.register(cacheName + ".load_count", loadCountGauge);
metricRegistry.register(cacheName + ".evict_count", evictCountGauge);
metricRegistry.register(cacheName + ".request_count", requestCountGauge);
```
I even end up with a situation where `Cache.stats()` (with all its stats aggregation etc) needs to be called for every gauge.
``` java
public static class MetricsStatsCounter implements StatsCounter {
private final Meter hitsMeter;
private final Meter missesMeter;
private final Timer loadSuccessTimer;
private final Timer loadErrorTimer;
public MetricsStatsCounter(String metricsPrefix, MetricRegistry registry) {
this.hitsMeter = registry.meter(metricsPrefix + "." + "hits");
this.missesMeter = registry.meter(metricsPrefix + "." + "misses");
this.loadSuccessTimer = registry.timer(metricsPrefix + "." + "load.success");
this.loadErrorTimer = registry.timer(metricsPrefix + "." + "load.error");
this.evictionMeter = registry.meter(metricsPrefix + "." + "eviction");
}
public void recordHits(final int count) {
hitsMeter.mark(count);
}
public void recordMisses(final int count) {
missesMeter.mark(count);
}
public void recordLoadSuccess(final long loadTime) {
loadSuccessTimer.update(loadTime, TimeUnit.MILLISECONDS);
}
public void recordLoadException(final long loadTime) {
loadErrorTimer.update(loadTime, TimeUnit.MILLISECONDS);
}
public void recordEviction() {
evictionMeter.mark();
}
public CacheStats snapshot() {
//since we push stats to a MetricRegistry, we will never pull stats using Cache.stats()...
throw new UnsupportedOperationException();
}
}
```
@kevinb9n convinced now? ;-)
To simplify the process of collecting cache stats using e.g. _io.dropwizard.metrics_, `CacheBuilder.recordStats()` should have an overloaded version that accepts a StatsCounter Supplier.
> Just read the _guidelines for contributing_ and realized that I should have opened an issue for this instead of going directly to a PR. I do that, but I keep this PR as a reference...
I signed it!
The HttpHeaders class contains a listing of known HTTP Header keys. It already contains "X-Forwarded-Proto" (X_FORWARDED_PROTO)... but is missing "X-Forwarded-Port" (suggestion: X_FORWARDED_PORT).
These values are commonly sent as a pair when using an SSL load ballencer in front of a cluster.
X_FORWARDED_PORT is the suggested java name, X-Forwarded-Port has 1.8 million results, [Amazon Elastic Load Balancing](http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/x-forwarded-headers.html#x-forwarded-port) seems to use it.
FileBackedOutputStream only uses /tmp for creating file backings. I'd like to specify where the files go.
It calls
<code>File temp = File.createTempFile("FileBackedOutputStream", null);</code>
I'm requesting that the constructor for FileBackedOutputStream accept the parameter list to File.createTempFile:
<code>File temp = File.createTempFile(prefix, suffix, directory);</code>
Thanks,
Nice idea, i would suggest adding `File` to constructor parameters list insead of `prefix`, `suffix`, `directory`.
Replacing multiple spaces and tabs, which separates java tokens, by a
single space, excluding horizontal aligned tokens.
I signed it!
Nice, the google-java-format project looks really promising. I'll keep an eye on it. :wink:
Thanks for the information.
``` java
support
Map<K1,V1> >Map<K1,V2>
not supportConvert Map Type ???
Map<K1,V1> >Map<K2,V2>
You can support in the future
```
http://commons.apache.org/proper/commons-collections/javadocs/api-3.2.1/org/apache/commons/collections/MapUtils.html#transformedMap(java.util.Map, org.apache.commons.collections.Transformer, org.apache.commons.collections.Transformer)
Sometimes such demand
Such as redis return Map < byte [], byte [] > To Map < String, the String > OR Map < String, Object >...
Guava 19 is currently incompatible to GWT 2.8 because commit https://github.com/google/guava/commit/9e56ef17c335319d21f1f2c454176c9d32687a59 has been reverted in Guava 19 release branch.
Given that GWT 2.8 is around the corner (within a month or so, see https://groups.google.com/forum/#!topic/google-web-toolkit-contributors/lq82Uc7JMIQ) its probably a good idea to create two Guava 19 releases: One that is compatible with 2.6.1/2.7 and one that is compatible with 2.8.
Otherwise GWT people have to wait for Guava 20+ or use SNAPSHOT builds before they can switch to GWT 2.8.
Oh ok, didn't read that in the notes. Sounds fine to me as long as emphasis is put on "quickly" ;-) People are eagerly awaiting Java8 syntax and I just wanted to avoid that they can not upgrade GWT because of Guava.
Feel free to close this issue. Alternatively I would rewrite the title accordingly for tracking purpose.
`WrappingExecutorService` seems to be a useful class in of itself. `ForwardingExecutorService` is public, but `WrappingExecutorService` is not for no apparent reason.
+1000
Specifically in our case we needed to do copy spring scoped beans properly into 'children' threads - this meant running code before certain things happen in executor. `WrappingExecutorService` worked marvellously, but we had to copypaste it.
+1
A nice use case would be to create an Android-Espresso Idling resource that would wrap an ExecutorService, like this: https://gist.github.com/yairkukielka/086ef4fb1b30af6bb1522abb83f4daf6
For definition of Idling Resource, see https://developer.android.com/reference/android/support/test/espresso/IdlingResource.html
In our case, we have in thread-local storage a "trace token" identifier for the current request being processed. We want to have this copied into the thread-local storage of worker threads for the time that those worker threads are handling tasks submitted by the request.
This is also great for testing task submission ordering without relying on `Thread.sleep`.  Added SuppressWarnings annotation to a used member which is updated using reflection.
I indeed couldn't find the `@UsedFromReflection` annotation.
Found almost nothing when searching for "UsedFromReflection discussion" using google's search.
@cpovirk, can you share the discussion link? Thanks.
Added SuppressWarnings annotation to a used member which is updated using reflection
I signed it!
Closed because I commited using an unknown user :(
Fixes #2196.
oraclejdk7 and openjdk7 builds fail with:
> The log length has exceeded the limit of 4 Megabytes (this usually means that test suite is raising the same exception over and over).
>
> The build has been terminated.
It doesn't seem to be related to this PR.
oraclejdk8 build completes with:
> Done. Your build exited with 0.
If there's something else I can do, let me know.
I saw that gwtproject/gwt#9206 seems to be resolved.
Could someone restart following builds, please?
- https://travis-ci.org/google/guava/builds/86643322
- https://travis-ci.org/google/guava/builds/86655829
I'd like to avoid pushing commits just to trigger rebuild.
The last commit is not related to intersection - I hope you will find it valuable, however. I found that some assertions were too weak.
@cgdecker Thanks for restarting builds!
Let a < x < b:
- [x].intersection([x]) should return [x], returns [],
- [x].intersection([a..b]) should return [x], returns [],
- [a..b].intersection([x]) should return [x], returns [],
- [a..x].intersection([x..b]) should return [x], returns [].
I'll create a PR in a minute.
Yes, I use `ContiguousSet.intersection`. I believe it has no users at Google - this bug would have been discovered so long time ago! But... IMO it doesn't mean it should be deprecated and removed. `ContiguousSet.intersection` can be really useful as I'll try to show in a moment. Moreover, people often don't use something because they don't know it exists: `ContiguousSet` seems to be one of the less known classes.
My use case was to count the number of days common to two intervals. I could use `Range` for intersection and then `DiscreteDomain` for distance (or something more, well, domain specific, like `java.time.temporal.ChronoUnit`), but it wouldn't be so... compact. I can't, for instance, intersect two ranges without ensuring that they are connected; or I can, but I must be prepared to catch an exception - so it's either if-else or try-catch.
My code would look like:
```
Range<LocalDate> range1 = Range.closed(...);
Range<LocalDate> range2 = Range.closed(...);
int count;
if (range1.isConnected(range2)) {
Range<LocalDate> intersection = range1.intersection(range2);
count = (int) intersection.lowerEndpoint().until(intersection.upperEndpoint(), ChronoUnit.DAYS) + 1;
} else {
count = 0;
}
```
instead of:
```
ContiguousSet<LocalDate> interval1 = ContiguousSet.create(...);
ContiguousSet<LocalDate> interval2 = ContiguousSet.create(...);
int count = interval1.intersection(interval2).size();
```
(assuming I've created `DiscreteDomain<LocalDate>` already).
Also, I very often use `ContiguousSet` as `Iterable` - it's not just `size` that matters...
`ContiguousSet.intersection` is a tiny, simple method that shouldn't be hard to maintain. There are no alternatives (`Sets.intersection` creates view, etc.). I'd be happy if it stays with us.
Would this even be a win?  The advantage to code like `return Optional.of(...)` is that Java might scalarize the whole `Optional` instance.
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-dependency-plugin:2.10:unpack-dependencies (unpack-guava-sources) on project guava-gwt:
Artifact has not been packaged yet. When used on reactor artifact, unpack should be executed after packaging: see MDEP-98. -> [Help 1]
[ERROR]
[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.
[ERROR] Re-run Maven using the -X switch to enable full debug logging.
[ERROR]
[ERROR] For more information about the errors and possible solutions, please read the following articles:
[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException
[ERROR]
[ERROR] After correcting the problems, you can resume the build with the command
FileBackendOutput holds data in either a ByteArrayOutputStream or a File. Both of them provides quick access to content size. Use that knowledge to provide fast sizeIfKnown & size implementations.
I signed it !
On Thu, Oct 15, 2015 at 10:27 AM, googlebot notifications@github.com
wrote:
> Thanks for your pull request. It looks like this may be your first
> contribution to a Google open source project, in which case you'll need to
> sign a Contributor License Agreement (CLA).
>
> [image: :memo:] _Please visit https://cla.developers.google.com/
> https://cla.developers.google.com/ to sign._
>
> Once you've signed, please reply here (e.g. I signed it!) and we'll
>
> ## verify. Thanks.
> - If you've already signed a CLA, it's possible we don't have your
>   GitHub username or you're using a different email address. Check your
>   existing CLA data https://cla.developers.google.com/clas and verify
>   that your email is set on your git commits
>   https://help.github.com/articles/setting-your-email-in-git/.
> - If you signed the CLA as a corporation, please let us know the
>   company's name.
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/pull/2190#issuecomment-148316266.
I signed it with my other email address too.
On Thu, Oct 15, 2015 at 10:27 AM, googlebot notifications@github.com
wrote:
> Thanks for your pull request. It looks like this may be your first
> contribution to a Google open source project, in which case you'll need to
> sign a Contributor License Agreement (CLA).
>
> [image: :memo:] _Please visit https://cla.developers.google.com/
> https://cla.developers.google.com/ to sign._
>
> Once you've signed, please reply here (e.g. I signed it!) and we'll
>
> ## verify. Thanks.
> - If you've already signed a CLA, it's possible we don't have your
>   GitHub username or you're using a different email address. Check your
>   existing CLA data https://cla.developers.google.com/clas and verify
>   that your email is set on your git commits
>   https://help.github.com/articles/setting-your-email-in-git/.
> - If you signed the CLA as a corporation, please let us know the
>   company's name.
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/pull/2190#issuecomment-148316266.
`size()` can be optimised to not instantiate an `Optional` internally each time it's called. See the code below for an example of what I mean by this.
``` java
public long size() throws IOException {
return file != null ? file.length() : memory.getCount();
}
public Optional<Long> sizeIfKnown() {
return Optional.of(size());
}
```
https://github.com/google/guava/issues/2156
Implementation similar to other synchronized collections.
Copy unit test template from SynchronizedMapTest.
Make Synchronized.SynchronizedMap package protected (VisibleForTesting).
Lost my previous fork.
Requested Changes implemented in https://github.com/google/guava/pull/2377
This doesn't seem to be in `com.google.guava:guava:jar:20.0`. Where can it be found? It's not merged into Guava yet @user454322, see https://github.com/google/guava/pull/2377. :)  The `IndexOutOfBoundsException` is not in its correct column (4th row, `checkElementIndex(int index, int size)`)
The table is correctly formatted in the [old google wiki](https://code.google.com/p/guava-libraries/wiki/PreconditionsExplained).
update from origin
@cpovirk, thanks for the explanation!
I'd like to be able to implement custom ListenableFuture class where I could easily override cancel(boolean) method. The SettableFuture seems to be best fit but unfortunately it's declared final. Removing this restriction makes it much more reusable.
Thanks for mentioning `interruptTask()`, this is definitely better than overriding full `cancel()` method.
However, I still need both the `cancel()` and `set()` / `setException()` method. I actually think that this is pretty common use case for asynchronous tasks that are finished not by returning from method but after some notification is delivered (e.g. another `ListentableFuture`, completion callback etc.). In such case I need future for which it's possible to set the result and custom method for interrupting the task.
I believe that SettableFuture is best candidate here. Is there any drawback by making it non-final?
However, as you mentioned - this is mainly about optimizing `get()`, not `cancel()`... I think marking `get()` as final in `TrustedFuture` would make it safer, more readable and clear on purpose and on the other hand wouldn't affect extendability of `TrustedFuture` and as a result the inherited classes would take advantage of those performance optimizations as well :-)
Personally I agree it's not a big deal to inherit it from `AbstractFuture` in exactly the same way how `SettableFuture` is currently implemented. But I don't like I have to reinvent the wheel / duplicate the code. So maybe we can consider introducing another intermediate class `AbstractSettableFuture` and final `SettableFuture`. Although as described above it probably would hardly bring any value from the originally proposed approach.
Yes, I'm talking about duplicating `set` and `setException`. If I was able to inherit from `SettableFuture` it would save me few common lines of code. I need to call them externally as in this case it's basically used to implement integration pattern between 3rd-party framework and guava based code. I.e. (simplified version) `3rdparty.method().addListener((Future<?> updatedFuture) -> { guavaFuture.set(updatedFuture.get()); })`
For the `cancel()` request - I don't think it's somehow in conflict with specification. The specification only says that `isDone()` must return true and `isCancelled()` true as well but doesn't say when. And actually as the future is handled asynchronously by listener anyway it doesn't make any difference when you really "finish" the future.
That would be even worse because I would lose reusability of such class. And secondly I understand the original purpose of `SettableFuture` as the creating code doesn't yet know who and how updates the future. Otherwise it could be rather called Forwarded which in this case is just the listener.
RE: "subsequent calls toisDone()will always return true": But it still does. The only difference is that listeners invocation is postponed until the task is finished (if it already runs). The state of future would be always CANCELLED since the completion of `cancel()`and all the affected methods would return proper value.
Never mind. I can either copy the setters or base the code on spring [`SettableListenableFuture`](http://docs.spring.io/autorepo/docs/spring/current/javadoc-api/org/springframework/util/concurrent/SettableListenableFuture.html) which is more open in these terms.
Thanks anyway.
This resolves #1957 by providing the tryParseUnsigned\* methods.
Okay, I will make the changes. Do I have to close this pull request and create a new one?
I can't add the tryParse method for UnsignedBytes as there is no UnsignedByte class to return as a null object.
I've found some further inconsistencies. In UnsignedLongs.parseUnsignedLong, a NumberFormatException is thrown if the radix is not within the min or max radix which is consistent with Java's Long.parseLong. However, in Longs.tryParse, an IllegalArgumentException is thrown instead.
I think the new tryParse methods should throw NumberFormatException as well. But what should we do with the old methods?
I was searching for a way to convert an Iterable to a Collection, and Guava already has it. Sadly, it's not public...
Use case: I am creating a class where the API uses Iterable (because it's the right thing to do there), but have to call a 3rd party component that requires a Collection.
Works, but always creates a copy. Iterables.toCollections does not if it is passed a collection.
You really don't want it. Its horribly designed, error prone, and slow. The TCK is buggy and provides very poor coverage. The API is not friendly and the annotations are racy (non-atomic).
The implementations I've reviewed, written by the spec authors, do not even honor the API contract (e.g. ordered events are in fact not always ordered). The spec specifies the implementation algorithms to ensure that all match the design and quirks of the original reference, Ehcache. This requires extensive bridge code to reimplement features due to how over specified they are defined in the JavaDoc and TCK.
I don't think Guava can adequately implement the spec without abandoning most of the value of the cache. The team would probably discourage usage after having gone through the implementation exercise and not want to support it.
You can see my [adapter](https://github.com/ben-manes/caffeine) for a Guava-like cache. However, I'd recommend you look into the JSR and further advise you to avoid it if possible.
Indeed, I tried to run the TCK against my [guava-jcache](https://github.com/ocafebabe/guava-jcache) implementation and some tests don't pass but mostly because Guava doesn't support all the JSR-107 features (like "store by value" for instance)... But personally I don't need all the fancy JSR-107 features anyway! Let's face it, most of the time all you want from a caching solution is simply put and get operations. And in my case I also need the cache loading option since values are provided by the database but this already supported very well by Guava.
The two main reasons I had initially when I started working on this project was to be able to use Guava as my caching provider with the added value of a CacheManager (this is very handy when you need to force the invalidation of a specific cache from a caching service) and also have the possibility to plug a different caching solution (like EhCache, Hazelcast, etc.). And both are already working very well with the current state of my project!
Comments and/or suggestions are welcomed :)
The last updated plan said [mid 2016](https://groups.google.com/d/msg/guava-discuss/ZRmDJnAq9T0/-HExv44eCAAJ).
You may enjoy browsing through [Caffine's JCache adapter](https://github.com/ben-manes/caffeine), which is a Java 8 rewrite of Guava's cache. I think you could use many of the same techniques (event ordering via future chains, computes). The only race that may be hard to tackle is that Guava's removal notifications are asynchronous, but the removal JSR event must be fully ordered. That is solved in Caffeine by introducing a `CacheWriter`. I think you can be resolve that too, but it is a little more tricky.
I just realized that you're the author of Caffeine! I looked at this project very closely before starting to work on my own implementation. And honestly I wanted to use it but my biggest issue is the Java 8 requirement! At work we still rely on some Java libraries that aren't compatible with Java 8 yet. So for now we're stuck with Java 7! But I will revisit Caffeine as soon as we port everything to Java 8!
Thanks for you feedback!
https://github.com/google/guava/wiki/RangesExplained#encloses
Following statement needs review:
"[3..6] does not enclose (1..1] even though it contains every value contained by the latter range"
since the second part of the statement is not accurate.
Oh, I'm sorry.  You are correct.
The second statement is a vacuous truth.
https://en.wikipedia.org/wiki/Vacuous_truth
More specifically, since the range (1..1] does not contain _any_ elements, the range [3..6] _vacuously_ contains _all_ elements in (1..1].
Minor performance improvement in `ImmutableMap.copyOf(Map)`:
If `map instanceof ImmutableSortedMap`, no longer unnecessarily run the following, since it will always be `false`:
```
else if (map instanceof EnumMap)
```
This change also clarifies the intent of the method
The following test case fails on jdk6u45 (trigger a jdk6 bug probably fixed in jdk7). It happens as soon as an annotation processor is present in the classpath (not only auto-value).
``` java
package test;
import com.google.common.collect.ImmutableMultimap;
public final class Test {{
ImmutableMultimap.class.toString();
}}
```
``` xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion>
<artifactId>immutablemultimap</artifactId>
<version>0.0.1-SNAPSHOT</version>
<dependencies>
<dependency>
<groupId>com.google.guava</groupId>
<version>19.0-rc2</version>
</dependency>
<dependency>
<groupId>com.google.auto.value</groupId>
<artifactId>auto-value</artifactId>
<version>1.1</version>
<optional>true</optional>
</dependency>
</dependencies>
<build>
<pluginManagement>
<plugins>
<plugin>
<groupId>org.apache.maven.plugins</groupId>
<artifactId>maven-compiler-plugin</artifactId>
<version>3.1</version>
<configuration>
<source>1.6</source>
<target>1.6</target>
<compilerArgs combine.self="append">
</compilerArgs>
</configuration>
</plugin>
</plugins>
</pluginManagement>
</build>
</project>
```
```
[parsing started E:\projects\immutablemultimap\src\main\java\test\Test.java]
[parsing completed 17ms]
[search path for source files: E:\projects\immutablemultimap\src\main\java,]
[search path for class files: C:\Program Files\Java\jdk1.6.0_45\jre\lib\resources.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\rt.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\sunrsasign.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\jsse.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\jce.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\charsets.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\modules\jdk.boot.jar,C:\Program Files\Java\jdk1.6.0_45\jre\classes,C:\Program Files\Java\jdk1.6.0_45\jre\lib\ext\dnsns.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\ext\localedata.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\ext\sunjce_provider.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\ext\sunmscapi.jar,E:\projects\immutablemultimap\target\classes,E:\projects\maven\maven-local-repo\com\google\guava\guava\19.0-rc2\guava-19.0-rc2.jar,E:\projects\maven\maven-local-repo\com\google\auto\value\auto-value\1.1\auto-value-1.1.jar,.]
[loading com\google\common\collect\ImmutableMultimap.class(com\google\common\collect:ImmutableMultimap.class)]
[loading com\google\common\annotations\GwtCompatible.class(com\google\common\annotations:GwtCompatible.class)]
[loading java\lang\annotation\Retention.class(java\lang\annotation:Retention.class)]
[loading java\lang\annotation\RetentionPolicy.class(java\lang\annotation:RetentionPolicy.class)]
[loading java\lang\annotation\Target.class(java\lang\annotation:Target.class)]
[loading java\lang\annotation\ElementType.class(java\lang\annotation:ElementType.class)]
An exception has occurred in the compiler (1.6.0_45). Please file a bug at the Java Developer Connection (http://java.sun.com/webapps/bugreport)  after checking the Bug Parade for duplicates. Include your program and the following diagnostic in your report.  Thank you.
java.lang.NullPointerException
at com.sun.tools.javac.code.Symbol$MethodSymbol.params(Symbol.java:1196)
at com.sun.tools.javac.jvm.ClassReader.attachParameterAnnotations(ClassReader.java:1111)
...
```
```
[parsing started E:\projects\immutablemultimap\src\main\java\test\Test.java]
[parsing completed 13ms]
[search path for source files: E:\projects\immutablemultimap\src\main\java,]
[search path for class files: C:\Program Files\Java\jdk1.6.0_45\jre\lib\resources.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\rt.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\sunrsasign.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\jsse.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\jce.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\charsets.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\modules\jdk.boot.jar,C:\Program Files\Java\jdk1.6.0_45\jre\classes,C:\Program Files\Java\jdk1.6.0_45\jre\lib\ext\dnsns.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\ext\localedata.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\ext\sunjce_provider.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\ext\sunmscapi.jar,E:\projects\immutablemultimap\target\classes,E:\projects\maven\maven-local-repo\com\google\guava\guava\19.0-rc1\guava-19.0-rc1.jar,E:\projects\maven\maven-local-repo\com\google\auto\value\auto-value\1.1\auto-value-1.1.jar,.]
[loading com\google\common\collect\ImmutableMultimap.class(com\google\common\collect:ImmutableMultimap.class)]
[loading java\lang\Object.class(java\lang:Object.class)]
[loading com\google\common\annotations\GwtCompatible.class(com\google\common\annotations:GwtCompatible.class)]
[loading java\lang\annotation\Retention.class(java\lang\annotation:Retention.class)]
[loading java\lang\annotation\RetentionPolicy.class(java\lang\annotation:RetentionPolicy.class)]
[loading java\lang\annotation\Target.class(java\lang\annotation:Target.class)]
[loading java\lang\annotation\ElementType.class(java\lang\annotation:ElementType.class)]
Round 1:
input files: {test.Test}
annotations: []
last round: false
Round 2:
input files: {}
annotations: []
last round: true
[search path for source files: E:\projects\immutablemultimap\src\main\java,]
[search path for class files: C:\Program Files\Java\jdk1.6.0_45\jre\lib\resources.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\rt.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\sunrsasign.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\jsse.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\jce.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\charsets.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\modules\jdk.boot.jar,C:\Program Files\Java\jdk1.6.0_45\jre\classes,C:\Program Files\Java\jdk1.6.0_45\jre\lib\ext\dnsns.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\ext\localedata.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\ext\sunjce_provider.jar,C:\Program Files\Java\jdk1.6.0_45\jre\lib\ext\sunmscapi.jar,E:\projects\immutablemultimap\target\classes,E:\projects\maven\maven-local-repo\com\google\guava\guava\19.0-rc1\guava-19.0-rc1.jar,E:\projects\maven\maven-local-repo\com\google\auto\value\auto-value\1.1\auto-value-1.1.jar,.]
[loading com\google\common\collect\ImmutableMultimap.class(com\google\common\collect:ImmutableMultimap.class)]
[loading java\lang\Object.class(java\lang:Object.class)]
[loading com\google\common\annotations\GwtCompatible.class(com\google\common\annotations:GwtCompatible.class)]
[loading java\lang\annotation\Retention.class(java\lang\annotation:Retention.class)]
[loading java\lang\annotation\RetentionPolicy.class(java\lang\annotation:RetentionPolicy.class)]
[loading java\lang\annotation\Target.class(java\lang\annotation:Target.class)]
[loading java\lang\annotation\ElementType.class(java\lang\annotation:ElementType.class)]
[checking test.Test]
[loading java\lang\Class.class(java\lang:Class.class)]
[loading java\lang\String.class(java\lang:String.class)]
[wrote E:\projects\immutablemultimap\target\classes\test\Test.class]
[total 525ms]
```
@cpovirk I hope there is more to it than this commit, otherwise jdk6 javac is seriously fucked up!
@cpovirk thanks for solving this!
Unfortunately we still use jdk 6 in a number of projects at work (full migration to java 8 will not happen before Q2.2016). If this bug is not fixed then I guess we will just continue to use guava 18 until we migrate to java 8.
> Requires JDK 1.7 or higher (as of 19.0).
I think it is worth openning a bug at openjdk. then, if it fixed, release a 19.1 that restore jdk6 compatibility.
I confirm that I cannot reproduce the problem with 19.0-rc3. thanks!
Current version badges
A recipe for decision paralysis:
<img width="252" alt="screen shot 2015-09-29 at 1 13 43 am" src="https://cloud.githubusercontent.com/assets/66577/10155800/5eed22ca-6647-11e5-8ba3-939301198fe0.png">
I'd say squash the commits and use better labeling.  Current and Latest is a bit confusing.  If the param left is {false} and the param right is {true}, method compare returns -1.
If the param left is  {false} and the param right is {false,true},method compare also returns -1.
How could you distinguish these two situations using the return value -1 ?
OK^_^got it
Given how Google's recently migrated to Java 8 (https://github.com/google/guava/issues/2443#issuecomment-248103813), I think it's worth waiting until Guava 21 is in development to allow `Table.computeIfAbsent` to be implemented as a default method.
Great! In that case, if this has not yet been decided on internally, I'd feel strongly about making `Table.computeIfAbsent` a default method - it would have increased "discoverability" in IDEs, since one could type e.g. `fooTable.` and they'd see `computeIfAbsent` as a potential option.
@lowasser I get the impression from #902 and #1227 that there is real demand for a method like this or a Multitable class (but I don't know how much).
In particular, I find [this comment](https://github.com/google/guava/issues/902#issuecomment-61351113) regarding Bigtable very interesting. It suggests to me that even if Multitables are hardly useful when creating "low level" software (like command line programs), they are a lot more useful when creating more "high level" stuff like, say, Big Data applications.
Okay, that's obviously something _I_ can't do, as I'm not a Google employee, so all I can do at this point is look forward to further internal progress on this. :)
This suggests that we may want to consider (down the road, at least) improved support for Collection-based Values in a ValueGraph.  (Similar to Map<K, Collection<V>>, one can already do ValueGraph<N, Collection<V>>, but facilitating working with that kind of data is what Multimap is for.)
Hi,
This is being pedantic, but there seems to be no specific reason for the local newCount variable to be set to this.count -1 twice in the method.
Current code ...
```
V remove(Object key, int hash) {
lock();
try {
long now = map.ticker.read();
preWriteCleanup(now);
int newCount = this.count - 1;
AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
int index = hash & (table.length() - 1);
ReferenceEntry<K, V> first = table.get(index);
for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {
K entryKey = e.getKey();
if (e.getHash() == hash && entryKey != null
&& map.keyEquivalence.equivalent(key, entryKey)) {
ValueReference<K, V> valueReference = e.getValueReference();
V entryValue = valueReference.get();
RemovalCause cause;
if (entryValue != null) {
cause = RemovalCause.EXPLICIT;
} else if (valueReference.isActive()) {
cause = RemovalCause.COLLECTED;
} else {
// currently loading
return null;
}
++modCount;
ReferenceEntry<K, V> newFirst = removeValueFromChain(
first, e, entryKey, hash, valueReference, cause);
newCount = this.count - 1;
table.set(index, newFirst);
this.count = newCount; // write-volatile
return entryValue;
}
}
return null;
} finally {
unlock();
postWriteCleanup();
}
}
```
Replacement
V remove(Object key, int hash) {
lock();
try {
long now = map.ticker.read();
preWriteCleanup(now);
```
AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
int index = hash & (table.length() - 1);
ReferenceEntry<K, V> first = table.get(index);
for (ReferenceEntry<K, V> e = first; e != null; e = e.getNext()) {
K entryKey = e.getKey();
if (e.getHash() == hash && entryKey != null
&& map.keyEquivalence.equivalent(key, entryKey)) {
ValueReference<K, V> valueReference = e.getValueReference();
V entryValue = valueReference.get();
RemovalCause cause;
if (entryValue != null) {
cause = RemovalCause.EXPLICIT;
} else if (valueReference.isActive()) {
cause = RemovalCause.COLLECTED;
} else {
// currently loading
return null;
}
++modCount;
ReferenceEntry<K, V> newFirst = removeValueFromChain(
first, e, entryKey, hash, valueReference, cause);
int newCount = this.count - 1;
table.set(index, newFirst);
this.count = newCount; // write-volatile
return entryValue;
}
}
return null;
```
} finally {
unlock();
postWriteCleanup();
}
}
https://github.com/martinm1000/g18vs19
I was afraid of this... ;-(
Fix typo in comments
I signed it!
It would be very nice to have sample of thread safe bloom filter, what you guys think?
Avoiding nullability in Java is a recurring problem.
Other languages offer an `Optional`, which makes nullability composable.
Unfortunately this method wasn't called `defaultIfNull`, but `firstNonNull`, therefore people assumed it's a search.
This commit tries to solve that by _making_ it a search, and letting the users decide which approach they want:
ternary,
(first != null) ? first : ((second != null) ? second : checkNotNull(third));
```
Find,
Iterables.find(asList(first, second, third), Predicates.notNull());
```
```
or the same approach Guava already provided:
firstNonNull(first, second, third);
```
```
On Saturday, 19 September 2015, 12:58, googlebot <notifications@github.com> wrote:
```
Thanks for your pull request. It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA). Please visit https://cla.developers.google.com/ to sign.Once you've signed, please reply here (e.g. I signed it!) and we'll verify. Thanks.
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address. Check your existing CLA data and verify that your email is set on your git commits.
- If you signed the CLA as a corporation, please let us know the company's name.

Reply to this email directly or view it on GitHub.
Thanks, updated the commit message and posted a response to the Issue :)
I strongly support this change, as I've been in the same pitfall: when I've first seen the method `firstNonNull` in use, I've immediately assumed that it accepts any number of arguments (as it would be logical, given it's name and intent); and then I was disappointed when I tried to use it with three arguments.
The existing alternatives are far less elegant and concise, and also fragment the code base (while for the two-parameter cases I'm using `firstNonNull`, for the three-parameter cases I'm using something different).
If input is non-null, applies the function to it.
If either the input or the result is null, will return the default value.
This is an alternative for `Optional`, similarly to `firstNonNull`:
Optional.fromNullable(person.getName()).transform(String::toUpperCase).or("");
```
or
String name = person.getName();
if (name != null)
name = name.toUpperCase();
if (name == null)
name = "";
```
can now be written as (Java 8, default value and static import):
ifNonNull(person.getName(), String::toUpperCase, "");
```
Signed ;)
```
On Saturday, 19 September 2015, 12:55, googlebot <notifications@github.com> wrote:
```
Thanks for your pull request. It looks like this may be your first contribution to a Google open source project, in which case you'll need to sign a Contributor License Agreement (CLA). Please visit https://cla.developers.google.com/ to sign.Once you've signed, please reply here (e.g. I signed it!) and we'll verify. Thanks.
- If you've already signed a CLA, it's possible we don't have your GitHub username or you're using a different email address. Check your existing CLA data and verify that your email is set on your git commits.
- If you signed the CLA as a corporation, please let us know the company's name.

Reply to this email directly or view it on GitHub.
How is it different from `Optional` approach besides not creating an `Optional` instance?
``` java
Optional.fromNullable(name).transform(n -> n.toUpperCase()).or("");
```
The point of this modification is to provide an alternative for `Optional` for another very common case.
The same as for Guava's `firstNonNull`, e.g. instead of
```
we can _choose_ (this is the keyword here) to simply call
firstNonNull(first, second);
```
Which delimits the different parts of the computation way better, than `Optional` could.
The same applies to this changeset also, e.g. instead of
Optional.fromNullable(name).transform(n -> n.toUpperCase()).or("");
```
we can _choose_ to simply call
ifNonNull(name, n -> n.toUpperCase(), "");
```
Which keeps the bare essentials only.
ps. I statically imported `MoreObject`, because its methods are stateless and have meaning without the surrounding object, unlike `Optional`, where simply calling `fromNullable(first)` would look unintuitive.
(related to https://github.com/google/guava/pull/2164)
I like the general idea presented here, as there definitely are use cases when the above-defined `ifNonNull` would be the preferable choice.
What is the expected behavior when `thenFunction` returns null? Should `ifNonNull` return
- null (the current behavior),
- throw an exception, like the `Optional.transform` does in the above example
- `elseValue`, like the equivalent of the above example would do if it was using `java.util.Optional` from Java 8.
Integer find(List<Integer> inputs) {
return Iterables.find(inputs, new Predicate<Integer>() {
public boolean apply(Integer input) {
return input == 2;
}
});
}
```
but can be replaced with simple constructs, e.g.
Integer find(List<Integer> inputs) {
for (Integer input : inputs)
if (input == 2) return input;
throw new NoSuchElementException();
}
```
or
Iterables.find(inputs, Predicates.equalTo(2))
```
The same is true in this case, i.e. one could still extract commonly used functions and use them in a similar manner.
ifNonNull(person.getName(), Strings.toUpperCase(), "");
```
- The other argument is a more subjective one. `Idea` already presents these cases as if it were lambda style, making it more terse in reality than the variable&ternary style, i.e. instead of:
String name = person.getName();
if (name != null)
name = name.toUpperCase();
if (name == null)
name = "";
```
we can still see in the IDE
name = ifNonNull(person.getName(), (n)  { return n.toUpperCase(); }, "");
```
Thanks for the explanation :)
@cgdecker, could you please take a look at https://github.com/google/guava/pull/2164 also?
#2160
Consider the following snippet - even though comparison would be avoided beyond the first compare call, the parameter evaluation for the second one (`this.expensiveCalculation()`) would still be done.
```
ComparisonChain.start()
.compare(this.lessThanThat(), that.greaterThanThis())
.compare(this.expensiveCalculation(), that.expensiveCalculation())
.result();
```
I propose an extension similar to `Ordering::onResultOf` that can be used to avoid operations that are not needed because the comparison chain is "inactive" (result has already been determined).
```
ComparisonChain.start()
.compare(this.lessThanThat(), that.greaterThanThis())
.compare(this, that, ThisClass::expensiveCalculation)
.result();
```
The README refers to 19.0-RC1, but 19.0-rc2 is now available.
@cgdecker thanks, I can see it's updated now.  Do you have any idea when the final release for 19.0 is coming?  In the Gerrit project we're using 19.0-rc2 and it would be nice if we can upgrade to the final version before we cut the first RC for 2.12.
In Android a `SparseArray` implementation exists, that should be a more performant alternative to `Map<Integer, ?>` . It would be nice to have this class available in guava. Since it is already Apache licensed there shouldn't be much of a problem adding it to Guava.
Performance is explicitly called out by SparseArray as being worse than
On Wed, Sep 16, 2015 at 3:52 AM Tim Roes notifications@github.com wrote:
> In Android a SparseArray implementation exists, that should be a more
> performant alternative to Map<Integer, ?> . It would be nice to have this
> class available in guava. Since it is already Apache licensed there
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2157.
Sorry I meant more memory efficient, not more performant :-/
I'm new to osgi so perhaps I'm missing the obvious, but I have code that uses some classes in com.google.common.base, but because it is not exported in the MANIFEST.MF file, I am getting resolution errors.
I am working w/ version 15, but took at a look at v18 as well, and it looks like this package is still not exported.
Can someone tell me why that package isn't exported?  or if they have an inkling of what I"m doing wrong?
apologies - my eyes must have been crossed.
On Fri, Sep 18, 2015 at 5:39 PM, Colin Decker notifications@github.com
wrote:
> Closed #2155 https://github.com/google/guava/issues/2155.
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2155#event-413619511.
##
Adam Morgan
Salesforce ExactTarget Marketing Cloud http://www.exacttarget.com/
SMTS, Technical Services
why the condition of the second check is "nanos==expirationNanos" instead of "nanos==0 || now-nanos>=0". I doubt it.
**Summary**
ClassPath.getTopLevelClasses() returns empty list when the path of the classloader contains special characters.
**How to reproduce this error**
1. Create a packeage with three classes
2. Create the following unit test
``` java
@Test
public void testMain() throws Exception {
ClassLoader loader = this.getClass().getClassLoader();
ClassPath p = ClassPath.from(loader);
ImmutableSet<ClassPath.ClassInfo> list = p.getTopLevelClasses("testpackage");
Assert.assertEquals(3, list.size());
}
```
2. The test will fail. If you copy the project to a folder without special characters in its path the test will pass.
Looks to be caused by [This line](https://github.com/google/guava/blob/master/guava/src/com/google/common/reflect/ClassPath.java#L428)
It's caused because URLs automatically encode file names, while the File class expects raw unencoded input.
I'm not sure whether incorrect URLs should be supported at all. I'd rather see an exception than no results. I believe that it is an URLClassLoader's responsibility to make sure it returns valid URLs. This is what should be supported in the first place. It's not anymore since 81b23cdc840018da4fc07ccfcd55c78391f44df0 as you already know.
Before:
https://github.com/google/guava/blob/10e33c03a6d68fe1404aa721a4a7e37c1e63c43b/guava/src/com/google/common/reflect/ClassPath.java#L291
`entry.toURI()` - yes, this could throw... in very rare circumstances.
After:
https://github.com/google/guava/blob/81b23cdc840018da4fc07ccfcd55c78391f44df0/guava/src/com/google/common/reflect/ClassPath.java#L289
`entry.getFile()` - if resource's path contains unsafe characters, you will most likely get them back... escaped.
Few days ago we switched from Guava 18 to 20. Our apps are mostly deployed into "C:\Program Files\Apache Software Foundation...". We have a lot of spaces in classpaths. Every time `newFile(entry.getFile())` gives something like "/C:/Apache%20Software%20Foundation/...", one .jar is ignored by the Scanner (`!file.exists()` is true).
It seems like 81b23cdc840018da4fc07ccfcd55c78391f44df0 fixed ClassPath behavior for some exotic case but ruined the rest. I understand that it's still `@Beta`, so no offence, shit happens.
~~https://github.com/perceptron8/guava-issue-2152-test~~
[Edit: unnecessary since 896c51a, deleted]
I'd be happy if you fix this bug just with the following. There is no backward compatibility already, so why not?
```
try {
file = new File(entry.toURI());
}
```
This would be used only for processing URLs returned by UrlClassLoader. At the time #1899 was submitted, getClassPathEntries() was used for resolving Manifest's Class-Path entries too. Now it's not AFAIK. Nothing wrong should happen. Not only spaces, but also percent signs could be supported again.
Some exhaustive unit tests for ClassPath would be really handy.
This bug just caused us to downgrade Guava from 19.0 to 18.0, so we would be delighted if this issue could be fixed. @cpovirk The blog you mentioned at https://weblogs.java.net/blog/kohsuke/archive/2007/04/how_to_convert.html has a comment recommending, i.e., `Paths.get (entry.toURI ()).toFile ()` to handle UNC paths on Windows. Any issues with this approach? (Since Guava is migrating to Java 8 anyway...) I'm running into this problem in v21.0. Reverting to v18.0 solved the problem.  Could you confirm which version the commit mentioned above ended up in, or is expected to be in?
Thanks This problem still exists in java 9  `com.google.common.collect.ImmutableSet` is not producing consistent hash while using `com.google.common.hash.HashFunction`. If we wrap `HashSet` with `ImmutableSet` it works.
Please refer to `HashFunctionTest` below:
```
import com.google.common.collect.ImmutableSet;
import com.google.common.hash.HashCode;
import com.google.common.hash.HashFunction;
import com.google.common.hash.Hashing;
import org.apache.commons.lang3.SerializationUtils;
import org.junit.Before;
import org.junit.Test;
import java.util.HashSet;
import static org.junit.Assert.assertEquals;
public class HashFunctionTest {
private HashFunction hashFunction;
@Before
public void setUp() throws Exception {
hashFunction = Hashing.goodFastHash(128);
}
@Test // failed
public void testImmutableSet() throws Exception {
ImmutableSet<Integer> set1 = ImmutableSet.of(1, 2);
ImmutableSet<Integer> set2 = ImmutableSet.of(2, 1);
assertEquals(set1, set2);
HashCode hash1 = hashFunction.hashBytes(SerializationUtils.serialize(set1));
HashCode hash2 = hashFunction.hashBytes(SerializationUtils.serialize(set2));
assertEquals(hash1, hash2);
}
@Test // failed
public void testImmutableSetBuilder() throws Exception {
ImmutableSet.Builder<Integer> builder1 = ImmutableSet.builder();
builder1.add(1);
builder1.add(2);
ImmutableSet.Builder<Integer> builder2 = ImmutableSet.builder();
builder2.add(2);
builder2.add(1);
ImmutableSet<Integer> set1 = builder1.build();
ImmutableSet<Integer> set2 = builder2.build();
assertEquals(set1, set2);
HashCode hash1 = hashFunction.hashBytes(SerializationUtils.serialize(set1));
HashCode hash2 = hashFunction.hashBytes(SerializationUtils.serialize(set2));
assertEquals(hash1, hash2);
}
@Test // passed
public void testSet() throws Exception {
HashSet<Integer> set1 = new HashSet<>();
set1.add(1);
set1.add(2);
HashSet<Integer> set2 = new HashSet<>();
set2.add(2);
set2.add(1);
assertEquals(set1, set2);
HashCode hash1 = hashFunction.hashBytes(SerializationUtils.serialize(set1));
HashCode hash2 = hashFunction.hashBytes(SerializationUtils.serialize(set2));
assertEquals(hash1, hash2);
}
@Test // passed
public void testSetAndImmutableSet() throws Exception {
HashSet<Integer> set1 = new HashSet<>();
set1.add(1);
set1.add(2);
HashSet<Integer> set2 = new HashSet<>();
set2.add(2);
set2.add(1);
assertEquals(set1, set2);
ImmutableSet<Integer> immutableSet1 = ImmutableSet.copyOf(set1);
ImmutableSet<Integer> immutableSet2 = ImmutableSet.copyOf(set2);
HashCode hash1 = hashFunction.hashBytes(SerializationUtils.serialize(immutableSet1));
HashCode hash2 = hashFunction.hashBytes(SerializationUtils.serialize(immutableSet2));
assertEquals(hash1, hash2);
}
@Test // passed
public void testSetAndImmutableSetBuilder() throws Exception {
HashSet<Integer> set1 = new HashSet<>();
set1.add(1);
set1.add(2);
HashSet<Integer> set2 = new HashSet<>();
set2.add(2);
set2.add(1);
assertEquals(set1, set2);
ImmutableSet<Integer> immutableSet1 = ImmutableSet.<Integer>builder().addAll(set1).build();
ImmutableSet<Integer> immutableSet2 = ImmutableSet.<Integer>builder().addAll(set2).build();
HashCode hash1 = hashFunction.hashBytes(SerializationUtils.serialize(immutableSet1));
HashCode hash2 = hashFunction.hashBytes(SerializationUtils.serialize(immutableSet2));
assertEquals(hash1, hash2);
}
}
```
There is an analysis in this section, however, this report is protected from normal users, why? Could you open this benchmark report?
I'd like to do FluentIterable.from("a").append(otherStrings);
Granted, I can do FluentIterable.from(newArrayList("a")).append(otherStrings), but seems like a vararg is reasonable to avoid the "newArrayList" boilerplate.
This extends current indexOf function with possibility of specifying where to start and where to end with the search, similarly to java String.indexOf methods.
I signed it!
Hi, sure, I'm working on project which consumes ASCII input (potentially binary) and basically need similar functions for parsing as String provides.
If the data comes from structure I don't have control over - like ByteBuffer from NIO or ByteBuf from netty, this parameter will become pretty handy.
I'm out of luck as this file https://raw.githubusercontent.com/publicsuffix/list/master/public_suffix_list.dat always changes at a faster rate than guava releases.
@cpovirk All links in that pull request are dead or deleted
https://wiki.magnolia-cms.com/display/WIKI/TldPatterns+(public+suffix+list)+generator
![image](https://cloud.githubusercontent.com/assets/286258/9805541/c862fe9e-57ee-11e5-9b19-54431a3d8303.png)
`ByteSource.asCharSource` is present, and very useful. But I'm finding several cases where it'd be nice to have a `ByteSource` view of a `CharSource` without first serializing out to `String` and then calling `String.getBytes(Charset)`. Additionally, having both `ByteSource.asCharSource` and `CharSource.asByteSource` would let us chain the two to transcode from a `ByteSource` in one charset to a `ByteSource` in another.
I'm thinking about adding support for all the Java 8 [`java.util.function`](https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html) classes to the methods that use similar Guava classes.
For example, there would be both (type parameters removed for brevity):
- `Multimaps.filterEntries(Multimap map, google.common.base.predicate.Predicate predicate)`
-  `Multimaps.filterEntries(Multimap map, java.util.function.Predicate predicate)`
My project is using GWT 2.7.0 and Guava 18.0. When switching from 18.0 to 19.0-rc1 and making no other changes, I get the following error during GWT compilation:
```
Tracing compile failure path for type 'com.google.common.collect.ImmutableMapEntrySet'
[ERROR] Errors in 'com/google/common/collect/super/com/google/common/collect/ImmutableMapEntrySet.java'
[ERROR] Line 35: Weak cannot be resolved to a type
[ERROR] Line 20: The import com.google.j2objc cannot be resolved
[ERROR] Hint: Check that the type name 'com.google.common.collect.ImmutableMapEntrySet' is really what you meant
[ERROR] Hint: Check that your classpath includes all required source roots
```
Thanks, that worked. Didn't realize there was a new dependency. I'm using Bazel, which doesn't do automatic dependency management.
Hello is there any chance to have a license included inside the JAR/MVN?
> https://repo1.maven.org/maven2/com/google/guava/guava/19.0-rc1/guava-19.0-rc1.pom
It should look nearly like that:
`
<licenses>
<license>
<url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
<distribution>repo</distribution>
</license>
</licenses>
`
Its part of the [parent pom](https://repo1.maven.org/maven2/com/google/guava/guava-parent/19.0-rc1/guava-parent-19.0-rc1.pom). That should be an acceptable location for license validators.
Hi,
FluentIterable is very useful but lacks some shortcuts for transform/filtering of primitives and common data types (String, Date, Calendar).
Suggestion for transform shortcuts:
- asInt(), asLong(), asString(), asShort(), asByte(), asChar(), asDouble(), asFloat(), asDate(TimeZone), asDate(TimeZone, Format)
Suggestion for filter shortcuts:
- All: isNotNull(), isNull(),
- String: isEmpty(), isNotEmpty()
- Numbers: isNotZero(), isZero(), isPositive(), isNegative()
- Dates: isToday(), isThisWeek(), isThisMonth(), isThisYear(), isWeekEnd(), isNotWeekEnd()
The shortcuts could be clever enough to do the conversion before filtering. E.g. If I use isEmpty() as filter then asString() is executed first
In case is too specific for FluentIterable a new Fluent class can be created.
I can contribute with this change, but I prefer to talk about it first. I have some draft implementations.
- given a list of dates in numeric string format, get a filtered set of dates which are today
``` java
from(list).asLong().isPositive().asDate(TimeZone).isToday().toSet()
```
- given a list of text numbers, get a filtered list with the positive values as integer:
``` java
from(list).isNotNull().asInt().isPositive().toList()
```
Per https://github.com/google/j2objc/issues/521, the @WeakOuter annotations added in https://github.com/google/guava/commit/c62b07df3a68126e1cf549c85c35f4e55178990b can cause crashes in Objective-C translations of Guava (when the client possess a strong reference only to a view of a collection, and retains no strong references to collection itself).
Since this hasn't made it to official v19 and is still in RC, should this be rolled back until it can be guaranteed correct?
cc: @kstanger
Removing the @WeakOuter would result in a memory leak in ALL use cases. With the @WeakOuter, the code at least works correctly in MOST use cases. This is consistent with our current strategy for collection views and is not a regression from our J2ObjC fork of Guava.
We may need to revise our strategy for collection views, but until then, this is "working as intended".
One strategy is not _better_ than the other. The point is, neither strategy is fully _correct_ and we had to chose one. I'm happy to reconsider this decision based on your feedback, but this will be done with very careful consideration when I have the time to focus on this problem.
That scenario would result in the collection's reference to the view being a dead pointer at some point in the future. Keep in mind we don't necessarily have ARC's automatically nil'ed __weak reference semantics, and if we did we'd still need to make the necessary modifications to check for nil.
It's not okay because the collection will continue to return the same pointer after it's deleted. It has no way to detect that the pointer has been deleted.
Recommend adding to
or maybe also in the Javadoc a reminder that a call to Preconditions.checkXX(condition, format, formatValues...) allocates an Object[] on every call, regardless of whether the condition is true or false.
This can add a lot of garbage, and is especially bad in a UI loop on Android for example.
FluentIterable::toList doesn't infer return type of List<? super E> like Java 8 Stream can do.
```
class BaseClass {
final String name;
BaseClass(String name) {
this.name = name;
}
}
class SubClass extends BaseClass {
SubClass(String name) {
super(name);
}
}
// This should compile, but can't because the LHS is BaseClass, but after transform, we have FluentIterable<SubClass> and toList() can't adapt.
List<BaseClass> ret = FluentIterable.from(Splitter.on(CharMatcher.WHITESPACE).split("Foo bar baz"))
.transform(t -> new SubClass(t))
.toList();
// This compiles, FWIW in Java 8
.stream()
.map(t -> new SubClass(t))
.collect(Collectors.toList());
```
Darn - I tinkered with it.  I really wish there were lower bounds for type parameters, but apparently there are not - very clever how Stream did it - Collectors has a concrete unbounded type, but the collect method uses the lower bound wildcard `? super T` - which allows the higher type that is inferred from the LHS to be used to satisfy the unbound type of the collector.
Man, what hoops to jump through ugly and you're right not a hard solution/workaround. I'll close this.
`FluentIterable.of(1, 2, 3)` would be easier to use/more succinct than `FluentIterable.of(new int[]{1, 2, 3})`
This change does not break the existing API as E... becomes E[] by the time it is used in the method.
I signed the CLA!
@stephenh - I saw your comment on https://github.com/google/guava/issues/1070 but can't reply any longer.
FWIW, I rolled my own and have been getting good traction with it
See https://github.com/scr/j8iterables for some useful crossovers between Guava, Stream, and Jdk8!
I am wondering what's the solution for the overloading confusion that would be introduced by such a signature change when there's one single array argument? (A potential break in source back-compatibility.)
Hi folks, I'm hessitant to raise a suggestion already discussed and closed, but since last time Java 8 has come along, which might give the idea merit again(?)
It seems that the "impossible" `Iterables` equivalant of `Iterators.forEnumeration` could be implemented by taking a `Supplier<Enumeration<T>>`. With lambdas & method references this can yeild uses which aren't even too horrible, such as:
```
for (MyTreeNode node : Iterables.forEnumerationSupplier(tree::preorderEnumeration)) {
//...
}
```
and which also save a bit of memory churn c.f. `Collections.list`.
If you're reaching for the duplicate button already, the tickets you're looking for are: #1399 and #796 ;-)  Still I think the Supplier makes this well-defined, and hence different from the "single-use iterator as an iterable" graveyard-suggestion made within those tickets.
Oh, that's nice, and I agree this isn't _too_ horrible:
```
Iterable<MyTreeNode> nodes = () -> Iterators.forEnumeration(tree.preorderEnumeration());
for (MyTreeNode node : nodes) { ...
```
Yet since Java can't infer that the type needs to be `Iterable<T>` on the right-side of a for-each, I'd still be tempted to write my own utility to avoid either the cast or variable declaration. Simply extracting this line leads to the dangerous API:
```
public final class Enumerations {
public static <T> Iterable<T> asIterable(Enumeration<T> en) {
return () -> Iterators.forEnumeration(en);
}
```
which might encourage the accident of using an exhausted Enumeration. So I think I'll still end up with this utility when rolling my own:
```
public static <T> Iterable<T> asIterable(Supplier<Enumeration<T>> factory) {
checkNotNull(factory);
return new Iterable<T>() {
public UnmodifiableIterator<T> iterator() {
return Iterators.forEnumeration(factory.get());
}
};
}
```
It would also allow this:
```
Iterables.forEnumerationSupplier(this::preorderEnumeration)
.forEach(node -> node.doSomething());
```
which has a lot less punctuation than:
```
((Iterable<MyTreeNode>) () -> Iterators.forEnumeration(tree.preorderEnumeration()))
.forEach(node -> node.doSomething());
```
(a) My motivating case was `DefaultMutableTreeNode`, which has a few different methods returning Enumerations; and in some scenarios we may not be able to use a derived class; anyway...
(b) is nice: both concise and efficient. Between that and `Collections.asList` (for traditional loops) I'm happy to drop the request. While it might add a little symmetry, it's hard to argue for much 'utility' given this good alternative in Java 8. (The requested method could probably only be used 'concisely' in Java 8.)
Thanks!
Hello,
if one future fails in a combined future a large message with stacktrace is spit out via java.util.logging. This is inconvenient.
```
Aug 17, 2015 7:12:44 PM com.google.common.util.concurrent.Futures$CombinedFuture setExceptionAndMaybeLog
```
We know of lots cases where this behaviour cannot or shuold not be avoided (for instance, jobs failing because of timeouts).
I can think of a few workarounds, which may even need to be applied in grops, which are equally pesky:
- Working it around by java.util.logging at the system level is not practical as it requires manual changes at the OS/environment level.
- Working it around by java.util.logging programmatically is very inconvenient because it needs to be done before starting each test, or requires all test to be derived from a common "wrapper".
- Working it around by java.util.logging via command line is also very inconvenient because it needs to be done for each test execution environment (either surefire or Eclipse JUnit runner).
- Working it around at the code level by wrapping the input futures with a fallback (or similar) for the known cases requires lots of coding. Also breaks the downstream error handling.
- Working it around by bridging JUL to Slf4j tanks performance.
Can this be avoided? Forking and rebuilding from source just to comment out a logging line is a bit overkill.
Yes, it could be more than one error (i don't see the log every single time.) Perhaps I was misled by the wording of the error message? :)
scheduled for? I'm not in a rush, but if there's a 18.0.1 soon I'll
probably take it.
On 21 August 2015 at 15:57, Chris Povirk notifications@github.com wrote:
> @lukesandberg https://github.com/lukesandberg now, since I'll end up
> sending him the CL to make this change. Luke, what do you think of the
> message I propose in my previous post? (I will make it conditional so that
>
> (I'm ignoring the larger logging issue for the moment.)
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2134#issuecomment-133453097.
##
Cheers,
No problem, thanks for adding this issue to your roadmap :)
On 21 August 2015 at 18:08, Chris Povirk notifications@github.com wrote:
> An improvement to the log message might be able to be included in release
> 19 if we want. The underlying problem of having too much logging requires
> more thought, so I wouldn't expect anything until at least release 20.
> Sorry :(
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2134#issuecomment-133496699.
##
Cheers,
Hello,
just following it up.
This error mostly happens during stress tests. In that case it does appear that it's legitimate for multiple futures in a composite to fail. A specific stress test which wasn't failing before now fails because the inordinate amount of I/O generated by the logging message makes it slow down and time out.
As a workaround, redirecting stderr to /dev/null fixes it.
A similar level of stress could happen in production to an overloaded server. In that case, in practice, the solution (logging) will cause the problem to be worse (increase stress).
Forking the repo just to comment that line out starts to look like an attractive alternative :(
Can you change the code so it logs ONLY if a certain system property is set (and default to the old behaviour)?
http://stackoverflow.com/questions/6077267/java-logging-api-disable-logging-to-standard-output
> My understanding of the code is that we log only if:
>
>     any input fails with an Error
>
> or
>
>     You called allAsList, and more than one input failed, and the failures were different exceptions
In practice the second case will almost always be true if more than one Future fails. The Exceptions are collected in a ConcurrentHashSet. The problem is that almost no Exception implements equals() and hashCode() and it is highly unlikely that multiple threads throw the same instance of an Exception.
`MoreExecutors.java:541`
``` java
public <V> ListenableScheduledFuture<V> schedule(
Callable<V> callable, long delay, TimeUnit unit) {
TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);
ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);
return new ListenableScheduledTask<V>(task, scheduled);
}
```
`delegate.schedule(Runnable...)` is invoked here instead of the (intended?) `delegate.schedule(Callable<V>...)`. As a result, the `ScheduledListeningDecorator` is unusable for `Callable<?>`.
No, submitting a `Callable` does not work in the general case. Depending on how the "delegated" executor is implemented (in my case behaviour of `delegate.schedule(Runnable...)` and `delegate.schedule(Callable<V>...)` differ), the return value of the decorated Callable<T> always resolves to null, which is undesired. This behaviour was not present in guava 14.0.x. I believe it was introduced in 15.0.
Thanks :) If you need assistance on resolving this, I may have some hours to spare during the weekend.
Even if `delegate.schedule(Callable, ...)` returns the future correctly, the`ScheduledListeningDecorator.schedule(Callable<V> callable...)` wrapping it doesn't (and returns a null future). The reason is that the wrapper _doesn't_ invoke `delegate.schedule(Callable, ...)` at all, when it should.
I'll put together a repro test and send it to you.
Cannot reproduce the "null" issue with 19-SNAPSHOT in a simple test. Conditions must be more subtle. I can dig in a bit but probably have to get back to the office to narrow it down.
A simpler failure can be synthesized as follows:
``` java
ScheduledThreadPoolExecutor delegate = new ScheduledThreadPoolExecutor(1) {
public <V> ScheduledFuture<V> schedule(Callable<V> callable,
long delay, TimeUnit unit) {
return super.schedule(callable, delay, unit);
}
public ScheduledFuture<?> schedule(Runnable command, long delay,
TimeUnit unit) {
}
};
// this one works
delegate.schedule(Callables.returning(42), 1, TimeUnit.MILLISECONDS);
ListeningScheduledExecutorService service = listeningDecorator(delegate);
service.schedule(Callables.returning(42), 1, TimeUnit.MILLISECONDS);
```
As you wrote earlier, this violates the decorator contract (the decorator and the delegate are not interchangeable).
More investigation here.
You were right about the decorator itself not returning null. The real case is a bit more convoluted. Long story short, we have "special" schedulers in which we keep track of the executed/submitted tasks. The `null` comes as a side effect of those submitted tasks records.
Here's a repro case which mimics the problem (our original code is a lot more complicated, but this is another story).
``` java
public void testListeningDecorator_customSchedulerFailure()
// we keep track of all the tasks this executor has completed
final List<FutureTask<?>> taskList = Collections
.synchronizedList(new ArrayList<FutureTask<?>>());
ScheduledThreadPoolExecutor delegate = new ScheduledThreadPoolExecutor(
1) {
public <V> ScheduledFuture<V> schedule(Callable<V> callable,
long delay, TimeUnit unit) {
final FutureTask<V> task = new FutureTask<V>(callable);
taskList.add(task);
return super.schedule(new Callable<V>() {
public V call() throws Exception {
task.run();
return task.get();
}
}, delay, unit);
}
public ScheduledFuture<?> schedule(final Runnable command,
long delay, TimeUnit unit) {
final FutureTask<Void> task = new FutureTask<Void>(command,
null);
taskList.add(task);
return super.schedule(new Runnable() {
public void run() {
task.run();
}
}, delay, unit);
}
};
ListeningScheduledExecutorService service = listeningDecorator(delegate);
// we do the same thing twice.
// This goes through the decorator
ListenableFuture<Integer> future = service.schedule(
Callables.returning(42), 1, TimeUnit.MILLISECONDS);
// This bypasses the decorator
ScheduledFuture<Integer> bypass = delegate.schedule(Callables.returning(41), 1, TimeUnit.MILLISECONDS);
assertThat(future.get()).isEqualTo(42);
assertThat(bypass.get()).isEqualTo(41);
assertTrue(future.isDone());
assertListenerRunImmediately(future);
assertEquals(0, delegate.getQueue().size());
assertThat(taskList).hasSize(2);
assertThat(taskList.get(1).get()).isEqualTo(41);
assertThat(taskList.get(0).get()).isEqualTo(42); // boom!
}
```
You're welcome :)
That's the very inelegant workaround I've put in place - but it really
The main problem is that the decorator is not a decorator but the
definition of the interface suggests otherwise. If it helps, it started
behaving "as expected".
On 18 August 2015 at 16:01, Chris Povirk notifications@github.com wrote:
> Thanks for the investigation.
>
> forward calls to the corresponding methods.
>
> Going beyond that is likely to be tricky. Is there any chance that your schedule(Runnable,
> ...) method could check whether the input is already a Future and avoid
> wrapping in that case?
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2133#issuecomment-132240673.
##
Cheers,
Probably not necessary.
upgrade.
In the light of these results, it's not worth reworking the innards of the lib just
for this one corner case, as long as there is a clear and well defined
> This implies that the returned ListeningScheduledExecutorService **never
> calls the delegate's** submit, invokeAll, and invokeAny methods, so any
> special handling of tasks must be implemented in the delegate's execute
> method or by wrapping the returned ListeningScheduledExecutorService.
appears that we relied on a specific implementation detail (submit<X>
delegates to submit<X>) and assumed it was part of the contract.
Adding a caveat clause to the documentation in the tune of "while in older
wrapper is no longer guaranteed to mirror the behaviour of the delegated
executor" might help, perhaps?
On 20 August 2015 at 17:19, Chris Povirk notifications@github.com wrote:
> OK, it looks like we do document this:
>
> Creates an ExecutorService whose submit and invokeAll methods submit
> ListenableFutureTask instances to the given delegate executor. Those
> methods, as well as execute and invokeAny, are implemented in terms of
> calls to delegate.execute.
>
> http://google.github.io/guava/releases/18.0/api/docs/com/google/common/util/concurrent/MoreExecutors.html#listeningDecorator(java.util.concurrent.ExecutorService)
>
> It's possible that we could change that behavior, but I'm not sure what
> the implementation would look like. It seems like what you ultimately want
> is for the Future returned by the delegate to match the Future returned
> by the decorator, but keeping two Future instances in sync is something
> that's impossible to guarantee in general. We could maybe get it closer,
> and that might be good enough in your case, but we already have a
> workaround there, so I hesitate to complicate things. (I think we've
> already had bugs in listeningDecorator.)
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2133#issuecomment-133064805.
##
Cheers,
```
video/x-flv
video/3gpp
video/3gpp2
```
and some audio types:
```
audio/basic
audio/L24
audio/vnd.rn-realaudio
```
I found some other missed types:
image
```
image/pjpeg: Progressive JPEG
image/vnd.wap.wbmp: WBMP
```
text
```
text/cmd: commands
text/php: PHP scripts
```
message
```
message/http (RFC 2616)
message/imdn+xml: IMDN (RFC 5438)
message/partial: E-mail (RFC 2045 and RFC 2046)
message/rfc822: E-mail; EML files, MIME files, MHT files, MHTML files (RFC 2045 and RFC 2046)
```
model
For 3D models
```
model/example: (RFC 4735)
model/iges: IGS files, IGES files (RFC 2077)
model/mesh: MSH files, MESH files (RFC 2077), SILO files
model/vrml: WRL files, VRML files (RFC 2077)
model/x3d+binary: X3DB files
model/x3d+vrml: X3DV VRML files
model/x3d+xml: X3D XML files
```
```
application/x-pkcs12: p12 files
application/x-pkcs12: pfx files
application/x-pkcs7-certificates: p7b files (https://tools.ietf.org/html/rfc2315.html#section-9.1)
application/x-pkcs7-certificates: spc files
application/x-pkcs7-certreqresp: p7r files
application/x-pkcs7-mime: p7c files
application/x-pkcs7-mime: p7m files
application/x-pkcs7-signature: p7s files
```
application
```
application/EDI-X12: EDI X12 (RFC 1767)
application/EDIFACT: EDI EDIFACT (RFC 1767)
application/soap+xml: SOAP (RFC 3902)
application/x-woff: Web Open Font Format
application/xml-dtd: DTD (RFC 3023)
application/xop+xml: XOP
application/x-bittorrent: BitTorrent
```
x
```
application/x-dvi: DVI
application/x-latex: LaTeX files
application/x-font-ttf: TrueType (not registered, but the most frequently used)
application/x-stuffit: StuffIt
application/x-rar-compressed: RAR
text/x-jquery-tmpl: jQuery templates
application/x-javascript:
```
I am using the LoadingCache in a highly concurrent system and I observed some behavior that I am not sure is intended (to me it looks like a bug :) ). I wrote the following sample code to illustrate the problem :
``` java
public static void main(String[] args) {
final LoadingCache<String, Object> cache =
CacheBuilder.newBuilder()
.expireAfterAccess(65, TimeUnit.MINUTES)
.build(new CacheLoader<String, Object>(){
public Object load(String arg0) throws Exception {
Object obj = new Object();
System.out.println("creating object: " + obj);
return obj;
}
});
int threadCount = 600;
final String key = "hello/world";
Runnable task = new Runnable() {
public void run() {
try {
Object valueFromUnchecked = cache.getUnchecked(key);
if (valueFromUnchecked == null) {
System.out.println(Thread.currentThread().getName() + " valueFromUnchecked is null!!!");
}
Object value = cache.getIfPresent(key);
if (value == null) {
System.out.println(Thread.currentThread().getName() + " value is null!!!");
}
if (value != valueFromUnchecked) {
System.out.println(String.format(Thread.currentThread().getName() + "valueFromUnchecked:%s, value:%s", valueFromUnchecked, value));
}
} catch (Exception e) {
e.printStackTrace();
}
}
};
for (int i = 0; i < threadCount; i++) {
Thread t = new Thread(task);
t.setName("thread-" + i);
t.start();
}
```
Sometimes thing are fine, I don't get the output of "<thread name> value is null!!!" lines and some times I do. I never get the output of "valueFromUnchecked from getUnchecked is null!!!"
My understanding of from LoadingCache java doc, is that if  `getUnchecked()` does not return null then `getIfPresent()` shouldn't return null as well; given that the cache has not expired yet.
A cursory glance...
- Expiration isn't needed to reproduce this
- It seems that StrongValueReference returns null, though the value later materializes
- Inserting a memory fence resolves the issue (`Unsafe.fullFence()`)
- Caffeine passes
It seems like final field visibility rules aren't working as expected, since that should avoid reordering and a SVR should never return null. Probably needs to be tested on JDK6/7 for good measure. Nothing in the code looks obviously wrong fence-wise.
thanks for looking into this. Just FYI I compiled the above code into jvm 7 class file (because my prof system runs jvm 7). But I did run the code in both jvm7 and jvm8 both produced same result.
Okay, so what is happening is that when `LoadingValueReference#waitForValue()` returns the `count = 0`. This is because the computing thread doesn't increment it until after its published through the value reference. This lets the reader see the value immediately, but before the count changes. Then when the reader immediately performs a `getIfPresent` the count is still zero and it receives null due to an early exit. When the computing thread finally increments the count then everything works normally. This means that one could argue that the expected happens-before relationship is being violated.
The best approach would be to simply remove the guard conditions. I don't remember when they were introduced. Most likely Bob added them in the original computing map and, since we inherited that, we never thought about his optimization. I don't think it buys anything and a load barrier shouldn't be required for correctness.
Sorry that this wasn't immediately obvious. Its been a very long time since I've reasoned through this code. Unfortunately I don't know if this will be fixed will be fixed any time soon.
Actually the guards might have been okay when Bob added them, and an oversight when we introduced `LoadingCache`. When we used the `Map` interface there was no way to peek into the cache, as a `get` was computing. So that's when it was probably introduced to mirror the style in other methods and we didn't consider that interaction.
I can't reproduce it with master and the test program. Ran with TestNG `@Test(threadPoolSize = 10, invocationCount = 1000)`. I haven't looked into your analysis though.
so ... when will the fix of the issue be release? looks like it was intended, then removed from 20.0 release?  Guava tests build is failing on windows. PFB the failure snippet from surefire-reports.
guava-tests/target/surefire-reports/com.google.common.base.ThrowablesTest.txt:Tests run: 30, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.026 sec <<< FAILURE!
Binary file guava-tests/target/surefire-reports/com.google.common.io.ResourcesTest.txt matches
guava-tests/target/surefire-reports/com.google.common.reflect.ClassPathTest.txt:Tests run: 32, Failures: 5, Errors: 0, Skipped: 0, Time elapsed: 0.463 sec <<< FAILURE!
And here is the text for those two files
## Test set: com.google.common.base.ThrowablesTest
Tests run: 30, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.026 sec <<< FAILURE!
testGetStackTraceAsString(com.google.common.base.ThrowablesTest)  Time elapsed: 0.002 sec  <<< FAILURE!
junit.framework.AssertionFailedError: null
at junit.framework.Assert.fail(Assert.java:47)
at junit.framework.Assert.assertTrue(Assert.java:20)
at junit.framework.Assert.assertTrue(Assert.java:27)
at com.google.common.base.ThrowablesTest.testGetStackTraceAsString(ThrowablesTest.java:498)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:606)
at junit.framework.TestCase.runTest(TestCase.java:168)
at junit.framework.TestCase.runBare(TestCase.java:134)
at junit.framework.TestResult$1.protect(TestResult.java:110)
at junit.framework.TestResult.runProtected(TestResult.java:128)
at junit.framework.TestResult.run(TestResult.java:113)
at junit.framework.TestCase.run(TestCase.java:124)
at junit.framework.TestSuite.runTest(TestSuite.java:243)
at junit.framework.TestSuite.run(TestSuite.java:238)
at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:83)
at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:35)
at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:115)
at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:97)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:606)
at org.apache.maven.surefire.booter.ProviderFactory$ClassLoaderProxy.invoke(ProviderFactory.java:103)
at com.sun.proxy.$Proxy0.invoke(Unknown Source)
at org.apache.maven.surefire.booter.SurefireStarter.invokeProvider(SurefireStarter.java:150)
at org.apache.maven.surefire.booter.SurefireStarter.runSuitesInProcess(SurefireStarter.java:91)
at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:69)
---
## Test set: com.google.common.reflect.ClassPathTest
Tests run: 32, Failures: 5, Errors: 0, Skipped: 0, Time elapsed: 0.463 sec <<< FAILURE!
testGetClassPathEntry(com.google.common.reflect.ClassPathTest)  Time elapsed: 0 sec  <<< FAILURE!
junit.framework.AssertionFailedError: expected:file:/C:/usr/test/dep.jar but was:file:/usr/test/dep.jar
at junit.framework.Assert.fail(Assert.java:47)
at junit.framework.Assert.failNotEquals(Assert.java:283)
at junit.framework.Assert.assertEquals(Assert.java:64)
at junit.framework.Assert.assertEquals(Assert.java:71)
at com.google.common.reflect.ClassPathTest.testGetClassPathEntry(ClassPathTest.java:175)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:606)
at junit.framework.TestCase.runTest(TestCase.java:168)
at junit.framework.TestCase.runBare(TestCase.java:134)
at junit.framework.TestResult$1.protect(TestResult.java:110)
at junit.framework.TestResult.runProtected(TestResult.java:128)
at junit.framework.TestResult.run(TestResult.java:113)
at junit.framework.TestCase.run(TestCase.java:124)
at junit.framework.TestSuite.runTest(TestSuite.java:243)
at junit.framework.TestSuite.run(TestSuite.java:238)
at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:83)
at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:35)
at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:115)
at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:97)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:606)
at org.apache.maven.surefire.booter.ProviderFactory$ClassLoaderProxy.invoke(ProviderFactory.java:103)
at com.sun.proxy.$Proxy0.invoke(Unknown Source)
at org.apache.maven.surefire.booter.SurefireStarter.invokeProvider(SurefireStarter.java:150)
at org.apache.maven.surefire.booter.SurefireStarter.runSuitesInProcess(SurefireStarter.java:91)
at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:69)
testResourceScanner(com.google.common.reflect.ClassPathTest)  Time elapsed: 0.279 sec  <<< FAILURE!
No problem..!:)
Let me know if you want me to fix this.
@kevinb9n, I understand that you cannot run any tests on Windows internally, but I've noticed that for the Github-hosted version of Guava you use Travis CI a lot (I don't know if you also use Travis internally).
This makes me wonder if Google policy would allow you to use additional external CI services, and if so whether you'd consider using [AppVeyor](https://www.appveyor.com).
It seems to be a rather good complement to Travis, as it allows one to run CI tasks on Windows VMs, and it seems to be free for open source projects.
What are your thoughts on this?
On a related note, is the bug in `ThrowablesTest::testGetStackTraceAsString`currently being worked on?
If not, then I have a relatively trivial fix for the bug which I'd be happy to submit a Pull Request for.
@cpovirk, did you mean to say "jbduncan got...", or did you mean "jbduncan, (I) got..."?
Thanks @cpovirk, it's an honour. :)
RegularContiguousSet.equals() does not use Sets.equalsImpl() either but instead compares the DiscreteDomain and first+last.
@lowasser: Of course you're right :/ Sorry, should've thought harder.
> not sure whether
> ContiguousSet.hashCode() is called enough to be worth worrying about or not
It was in my case, and the next silly idea was to cache the hashCode. I've opted for storing the Ranges instead, which makes a lot more sense anyway.
You can view any JavaDoc jar hosted on Maven Central using [javadoc.io](http://www.javadoc.io/doc/com.google.guava/guava-testlib/19.0-rc1) or browse the [archive directly](https://oss.sonatype.org/service/local/repositories/releases/archive/com/google/guava/guava-testlib/19.0-rc1/guava-testlib-19.0-rc1-javadoc.jar/!/index.html) in Sonatype.
I use a custom badge to point to the JavaDoc, though that means manually incrementing the version label. Then you can point to either site as the destination, such as the repository if you have concerns about javadoc.io.
You could do the following. The only quirk is that the convention with dashes breaks for `19-rc1`.
[![JavaDoc](https://img.shields.io/badge/javadoc-19.0.rc1-brightgreen.svg)](http://www.javadoc.io/doc/com.google.guava/guava-testlib/19.0-rc1)
``` markdown
[![JavaDoc](https://img.shields.io/badge/javadoc-19.0.rc1-brightgreen.svg)](http://www.javadoc.io/doc/com.google.guava/guava-testlib/19.0-rc1)
```
An algorithm similar to `java.lang.Math.addExact()` should be used to compute `offset + length`  and fallback to `Integer.MAX_VALUE` or `Long.MAX_VALUE` in case of overflow.
There is 3 occurrences of this possibly overflowing addition in `ByteSource.java`.
I found this bug because I regularly slice bytesources with a length equals to Long.MAX_VALUE.
thanks!
while not a regression, I think the addition `offset + length` could also overflow in SlicedByteSource.sizeIfKnown()
I would like to have a new collection type like RangeMap, but instead of Range, I would like to retrieve values using Predicate. For instance, assume we are writing class which generates random values for given type.
If we use ordinary map we have to duplicate keys:
``` java
private final ImmutableMap<Class<?>, Randomizer> RANDOMIZERS = ImmutableMap.<Class<?>, Randomizer>builder()
.put(byte.class, byteRandomizer)
.put(Byte.class, byteRandomizer)
.put(short.class, shortRandomizer)
.put(Short.class, shortRandomizer)
.put(Collection.class, collectionRandomizer)
.put(List.class, collectionRandomizer)
.put(ArrayList.class, collectionRandomizer)
//...
.build();
public Object getRandomValueOf(Class<?> type) {
Randomizer randomizer = RANDOMIZERS.get(type);
if (randomizer == null) {
randomizer = new DefaultRandomizer(this);
}
return randomizer.random(type);
}
```
If we were able to use Predicates this code would be shorter:
``` java
private final PredicateMap<Class<?>, Randomizer> RANDOMIZERS = MutablePredicateMap.<Class<?>, Randomizer>builder()
.put(Predicates.<Class<?>>in(Arrays.asList(byte.class, Byte.class)), byteRandomizer)
.put(Predicates.<Class<?>>in(Arrays.asList(short.class, Short.class)), shortRandomizer)
.put(isEnum(), enumRandomizer)
.put(instanceOf(Collection.class), collectionRandomizer)
.build();
```
Why did I use maps? I think it's better than long if-else operators.
Ensures that the correct removal notification is published by `Segment#clear()`. Previously the operation was using the cause `EXPLICIT` when pending maintenance for expiration or collection would take precedence.
For additional safety, publishing notifications require passing a strong reference of both the key and value. This ensures that compiler reordering and races with the GC do not result in a reference collection and publishing a null value. This may not have been a problem due to happens-before ordering across methods, but simplifies away having to make these assumptions.
In addition to adding an expiration test, verified by removing the workaround in Caffeine's fixture. The tests pass with the changes and fail with 19-rc1.
It would be nice if there was a way to simplify a Windows path - i.e. one separated by `\` instead of `/`. Whether the existing `Files.simplifyPath` method is modified to use `File.separator{Char}` or whether a new method is required I don't know.
As a work around `Files.simplifyPath(path.replace('\\', '/')).replace('/', '\\')` would work.
would it be possible to ensure `InternetDomainName` rolls out w/ the latest version of the PSL (or as close to it as you can get) before release?
i don't know when the official release is slated for, but according to this site, https://iwantmyname.com/domains/new-gtld-launch-dates, there are new tlds on the horizon and depending on how quickly mozilla updates, it'd be nice to see as many of these included in the next release.
yes, i believe so.
awesome, thank you!!
do you have a target date (i realize it could change) for the 19.0 release?
I will second the vote for #1123, _enthusiastically_.
I'm using this as part of an application feature that runs comparisons of various competing websites. Having a static list of TLDs per Guava release means that any new public suffix created since the last release (in this case, over half a year back) will trigger an `IllegalStateException` when it is used with `InternetDomainName.topPrivateDomain()`.
New TLDs are being released more frequently than in the past, and I cannot imagine that problems arising from a static, infrequently-updated list are unique to my own use cases.  The ability to dynamically update the TLD list in Guava would be an immense improvement to this area of usability.
While I understand Kevin's point, the fix to this issue would be 15 minutes of thinkng, then _one_ method, and possibly a few tests. An hour, maybe two, an ideal candidate for a lazy Friday afternoon when nothing really productive gets done?
I'm sorry if this sounds inconsiderate, I do not and can not know how much work there is to be done by your team. This shows that you might want to post a status update and an optional roadmap, somewhere public ;).
Since Guava is dependency-free, you could publish a sibling artifact using the 'aar' packaging [whose format](http://tools.android.com/tech-docs/new-build-system/aar-format) allows embedding proguard rules.
Android users wanting the automatic rules would specify a dependency like
``` groovy
```
instead of just
``` groovy
compile 'com.google.guava:guava:19.0'
```
(Dependency-free is important because using a package qualifier on a dependency skips the deployed `pom.xml` for looking up transitive dependencies)
Right. Any build system parsing the `pom.xml` should ignore those anyway.
It would be great if there as a "it just works" solution. It all looks so good at first when a simple
```
compile 'com.google.guava:guava:19.0'
```
gives your project all the Guava goodness, but come time to build a real-world APK with
```
minifyEnabled true
shrinkResources true
```
the fun ends due to [all the errors](http://stackoverflow.com/q/9120338/145173). The error messages are obtuse and don't even provide much clue that Guava's the cause.
Is this dead? The proguard rules in the wiki seem terribly out of date. @cpovirk Any chance you could start including it in the public repo? @cpovirk any updates?  ![jar](https://cloud.githubusercontent.com/assets/7439619/8873965/a6db4cee-3229-11e5-9d75-20f2c128e269.png)
I am using Guava v 17.0 dependency in Maven and Cassandra connection is established successfully.
But when I run same JAR on Hadoop 2.0.0-CDH4.3.1, It throws me error
java.lang.NoSuchMethodError: com.google.common.util.concurrent.Futures.withFallback(Lcom/google/common/util/concurrent/ListenableFuture;Lcom/google/common/util/concurrent/FutureFallback;Ljava/util/concurrent/Executor;)Lcom/google/common/util/concurrent/ListenableFuture;
When I look at the Guava v17.0 JAR I cant find Futures.withFallback static method.
Is it related to Hadoop's version compatibility with Guava as Cassandra got connected when not running on Hadoop.
I'm using storm with cassandra and i came accross the same issue. I discovered that my storm  was using guava-13.0 which overrided the guava version included in cassandra driver while lauching my topology.
To fix it i removed the guava jar (version:13.0) from my storm lib directory and everything worked fine
If you are using Maven, you coud create a "fat jar" with the dependencies of guava14 (or higher) and override (shade) the package of the dependencies with conflicts, in this case "com.google" with for example "hidden.google". Maven has a Shade plugin to do that. Add this lines to your pom file:`
<build>
<plugins>
<!-- Maven Shade Plugin -->
<plugin>
<groupId>org.apache.maven.plugins</groupId>
<artifactId>maven-shade-plugin</artifactId>
<version>2.3</version>
<executions>
<!-- Run shade goal on package phase -->
<execution>
<phase>package</phase>
<goals>
<goal>shade</goal>
</goals>
<configuration>
<!-- add Main-Class to manifest file -->
<relocations>
<relocation>
<pattern>com.google</pattern>
<shadedPattern>hidden.google</shadedPattern>
</relocation>
</relocations>
</configuration>
</execution>
</executions>
</plugin>
</plugins>
</build>
`  Maps.transformValues()
``` java
// Map<String,String> > Map<byte[],byte[]>
HashMap<String, String> fromHashMap = new HashMap<String, String>();
HashMap<byte[], byte[]> target =
Maps.transformValues(fromHashMap, new Function<String, byte[]>() {
public byte[] apply(String input){
return input.getBytes();
}
});
// commons-collection
Map map = MapUtils.transformedMap(hash, new Transformer() {
public Object transform(Object input){
return ((String) input).getBytes();
}
}, new Transformer() {
public Object transform(Object input){
return ((String) input).getBytes();
}
});
```
Mapping keys can be supported efficiently as a view, if the mapping is bidirectional.
- What if some chars are not supposed to appear in the string. I might want to ignore I and l for they look very alike.
- There is no way to generate a unicode string.
- What if I want all letters in their capital forms?
You have to write your own code to cover the cases above. There are other issues to consider:
- Theres definitely a better solution with better performance than using BaseEncoding.
- Theres no formal proof to the randomness of strings generated.
See
http://stackoverflow.com/questions/41107/how-to-generate-a-random-alpha-numeric-string
Construct a BigInteger with N bits randomly obtained from a Random source
and encode it in Base-32.
Cheers,
Thiago Kronig
On Tue, Jul 21, 2015 at 11:37 AM lvxiang notifications@github.com wrote:
> generator, but found none. And Ive looked at this thread
> http://stackoverflow.com/questions/20782919/does-guava-have-a-method-to-generate-random-strings
> which suggested using the BaseEncoding in some way for your purposes. Im
> not a big fan of this solution. For one thing you have to know BASE64 very
> well so as not to make any mistakes, such as forgetting to omit paddings.
> Moreover, its not an instant solution as most APIs usually do, you have to
> think twice to come up with the idea. On the other hand, the solution is
> too detailed to allow flexibility, consider the following cases:
> - What if some chars are not supposed to appear in the string. I might
>   want to ignore I and l for they look very alike.
> - There is no way to generate a unicode string.
> - What if I want all letters in their capital forms?
>
> You have to write your own code to cover the cases above. There are other
> issues to consider:
> - Theres definitely a better solution with better performance than
>   using BaseEncoding.
> - Theres no formal proof to the randomness of strings generated.
>
> formats, and I see a good reason for Guava to provide dedicated APIs for
> situation. Please let me know your thoughts on this issue.
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2113.
[This answer](http://stackoverflow.com/a/157202/581205) uses no `BigInteger` and is pretty general. It also seems to be optimal (except for using `StringBuilder` where `char[]` would do).
```
char[] str = new char[length];
for(int i = 0; i < length; i ++)
str[i] = (char) ('0' + rng.nextInt(10));
return new String(str);
```
@ogregoire like your Rule and Ruler idea, almost same as what I have in my mind. You might consider taking the fluid-style by introducing something like a RuleBuilder.
@ogregoire agreed
+1
+1. I want to get rid of Apache's _commons-lang3_ but I need `org.apache.commons.lang3.RandomStringUtils`
+1
FWIW, this all seems easy enough to do with streams.  I threw together this little snippet to print 10 strings of 10 random ASCII (though you could choose what ever codepoints you want) characters:
```
Stream<String> randomStrings =
Stream.generate(
() ->
.ints('a', 'z')
.limit(10)
.collect(
StringBuilder::new,
(builder, codePoint) -> builder.appendCodePoint(codePoint),
StringBuilder::append)
```
Filtering, transforming to upper case, etc. are all easy enough to implement as further stream operations.  Given that it's straightforward enough to get a random string from the APIs in the JDK, I'm having a hard time imagining that this is such a common problem as to warrant its own, specific API in Guava -- a specific API would be more readable, but probably too niche. I just searched "random string java" in Google and got 381k hit. Doesn't seem very niche to me. We generally judge need based on evidence within Google's (very large) code base, not Google searches.  By that metric, there is a much stronger need for an API to generate random cats given that "random cat java" produces 940k results. :) Okay, you got me there. I'll try to find a good API to generate random cats
then ;-)
More seriously, there are implementations that are fed here, there is a
request, there is a real need from several of your user. All that's left to
the Guava team is to review and to accept one of the PRs. Leave it in beta
for a few releases and see if it's used. If not, drop it.
Le mar. 10 janv. 2017  04:40, Gregory Kick <notifications@github.com> a
> We generally judge need based on evidence within Google's (very large)
> code base, not Google searches. By that metric, there is a much stronger
> need for an API to generate random cats given that "random cat java"
> produces 940k results. :)
>
> 
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/2113#issuecomment-271478489>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAotWmLvXnfODqgRVqNWd-QUYbd1l_etks5rQv2ogaJpZM4FczoY>
> .
>
Oh, by the way, @gk5885, have you seen any 'z' printed by your snippet?
I guess, it could get nearly as popular as random java cats, except for that there are many options you didn't cover. (*)
- For example, I'm using a much simpler generator, but I need variable string length.
- Some people might require maximum speed and this could be achieved by passing `ThreadLocalRandom.current()` to `next` (with your generator they'd need to keep an instance per thread).
But then, this is a free software (as in speech) and discussions and improvements are welcome, I guess! I never said I hold the one truth and if I overlooked at some things, like the `SecureRandom` as default, I humbly ask to have them pointed so I can suggest a better alternative.
@jrtom It's basically the only metric we hear of in the past few years. Yes, there are others, but that aspect is rather opaque, from a point of view external to Google.  # Abstract
goal of this PR is to replace
```
byte[] buf = new byte[BUF_SIZE];
ByteArrayOutputStream baos = new ByteArrayOutputStream();
```
with
```
Buffers.Lease<byte[]> lease = Buffers.leaseByteArray();
try{
byte[] buffer = lease.getBuffer();
} finally {
lease.returnLease();
}
Buffers.Lease<ByteArrayOutputStream> lease = Buffers.leaseByteArrayOutputStream();
try{
} finally {
lease.returnLease();
}
```
in all cases where byte-array or ByteArrayOutputStreams are used method-internal, this way avoiding unneccessary memory allocation, increasing performance and enhancing the memory profile.
# Implementation
[ThreadLocalBuffers](https://github.com/berndhopp/guava/blob/master/guava/src/com/google/common/io/
Buffers.java) is the manager of thread-local byte-arrays and FastByteArrayOutputStreams. It uses [SoftReferences](https://docs.oracle.com/javase/6/docs/api/java/lang/ref/SoftReference.html) or [WeakReferences](https://docs.oracle.com/javase/6/docs/api/java/lang/ref/WeakReference.html) to store buffers, this way enabling Garbage Collection to collect the buffers when the system runs low on memory. All allocations of byte[] or ByteArrayOutputStream in where the allocated byte[]/BAOS is not the returned value of the method have been replaced with calls to ThreadLocalBuffers.
ByteSource.contentEquals was challenging, because it used not one but two byte-arrays for buffering, so I used two ByteBuffers that wrap around the upper and lower part of the thread-local buffer, thereby mimicking the two buffers.
# Results
The microbenchmarks show that avoiding buffer allocation yields a significant performance boost. Tests that did not show significant differences are left out. There have been no tests where performance dropped more than 2.00%.
| tested method | bytes copied | runtime w/ TL buffers | runtime w/out TL buffers | performance increase in % |
| --- | --- | --- | --- | --- |
| ByteStreams.copy | 10 | 105569 | 681130 | 545,2 |
| ByteStreams.copy | 100 | 107411 | 698152 | 549,98 |
| ByteStreams.copy | 10000 | 840354 | 1186307 | 41,17 |
| ByteStreams.readBytes | 10 | 68917 | 633365 | 819,03 |
| ByteStreams.readBytes | 100 | 69802 | 660336 | 846,01 |
| ByteStreams.readBytes | 10000 | 360357 | 934588 | 159,35 |
| ByteStreams.toByteArray | 10000 | 1962961 | 4962929 | 152,83 |
| ByteSource.contentEquals | 10 | 647140 | 3614650 | 458,56 |
| ByteSource.contentEquals | 100 | 685559 | 647694 | 453,81 |
| ByteSource.contentEquals | 10000 | 5987317 | 9460941 | 58,02 |
you can find the results here:
[ByteStreamsBenchmark w/ ThreadLocal](https://microbenchmarks.appspot.com/runs/087a68fc-af92-4971-97ae-346be17ee50b#r:scenario.benchmarkSpec.methodName,scenario.benchmarkSpec.parameters.n)
[ByteStreamsBenchmark w/out ThreadLocal](https://microbenchmarks.appspot.com/runs/dfb1c1b7-b9e2-431c-91f9-3be2f19db2a7#r:scenario.benchmarkSpec.methodName,scenario.benchmarkSpec.parameters.n)
[ByteSourceBenchmark w ThreadLocal](https://microbenchmarks.appspot.com/runs/f5517421-8f23-4237-9de1-f7d9e4c8f3ce#r:scenario.benchmarkSpec.parameters.n)
[ByteSourceBenchmark w/out ThreadLocal](https://microbenchmarks.appspot.com/runs/573ac1ff-a1e9-4870-9b0d-414e77e163e6#r:scenario.benchmarkSpec.parameters.n)
1. SoftReferences can induce poor gc behavior where (iirc) it takes 2 full gc for a softreference to be collected.  I believe the general advice is "don't use them, ever"
2. ThreadLocals can cause issues in certain application containers to leak classloaders.  I believe it is possible to workaround... i don't remember how.
Since preallocated buffers are such a win, the better option is probably to modify these apis so that users can supply their own buffer (which they could manage with a ThreadLocal+SofReference or whatever is appropriate)
Hi Luke, thank you for your comment.
It is often advised not to use ThreadLocals in webapplications (like [here](http://niklasschlimm.blogspot.de/2012/04/threading-stories-threadlocal-in-web.html) ) since webapplications typically use thread-pools and so threads never actually finish, leaving objects threadlocal-attached to a thread to never be collected by gc. However in this case, since we only store Soft-/WeakReferences, garbage collection is able to free the buffer-memory (except for the tiny SoftReference-Object itself),  thus avoiding the problem alltogether.
As for the SoftReference-issue, are you referring to http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6912889 ? To circumvent this issue, it would be enough to just replace SoftReference with WeakReference, since WeakReference does not cause these problems, but it would come with some performance penalty. Maybe a good solution would be to use WeakReferences only for all ByteArrayOutputStreams and byte-arrays larger than the initial size of 8k, since you need to fill the heap up almost completely with softreferenced memory to cause the problem, what is hardly possible with 8k per thread.
Also, guava uses SoftReferences in other places too, like http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/cache/CacheBuilder.html#softValues().
Regards
Bernd
Update:
after some more googling, I found this ( I guess that is what you referred to, concerning the threadlocals ): https://wiki.apache.org/tomcat/MemoryLeakProtection#customThreadLocal
So I will rewrite the code to not use custom ThreadLocals.
Update 2:
I implemented what I mentioned above here:
[not using custom ThreadLocals](https://github.com/berndhopp/guava/commit/589c5953268835c638b73a239dfcf27226a618a6#diff-26e4970e348a674eadbfcccaac4fdb43L27)
[using WeakReferences for byte-arrays larger than init-size](https://github.com/berndhopp/guava/commit/589c5953268835c638b73a239dfcf27226a618a6#diff-26e4970e348a674eadbfcccaac4fdb43R109)
[using WeakReferences for ByteArrayOutputStreams](https://github.com/berndhopp/guava/commit/589c5953268835c638b73a239dfcf27226a618a6#diff-26e4970e348a674eadbfcccaac4fdb43R253)
to my surprise, the code has gotten more elegant with the changes IMHO :-)
AFAIK, there's already such a leak in [`com.google.common.escape.Platform`](https://github.com/google/guava/blob/master/guava/src/com/google/common/escape/Platform.java#L40), which could be fixed trivially by avoiding `initialValue`.
@cpovirk @cgdecker @kluever @Bezier89 @cgruber @lowasser @lukesandberg @kevinb9n @gk5885 @cushon @jrtom @eamonnmcmanus @PeteGillinGoogle @kstanger @dimo414 @ronshapiro @15characterlimi
I'm sorry to bother all of you, but I've put a lot of effort into this PR and I presented some numbers to prove that it offers a tremendous performance improvement, so I wonder why it had been fallen asleep. Many critical functions work a multitude of times faster than before, so it should be worth considering.
I personally do not think that there should be additional API's to let a user supply its own buffers. I consider it the obligation of the framework to handle its buffers, otherwise most of the users would either not use buffer re-use at all or end up programming their own thread-local buffer implementation.
What are your thoughts, what is needed to get this merged? Do you have concerns about the implementation? Should there be more control for the user?
best
Bernd
- major comment: I'm not sure that ThreadLocal<Reference>s are the right approach here. Perhaps there is a better solution for the case that you care about (e.g. passing a pre-allocated array like in Collection.toArray()? or something else)?
- the Reference object itself cannot be garbage collected so this will necessarily create at least two objects per calling thread. Those two objects will then stick around for the rest of the lifetime of the thread.
- (minor) this creates a new class of possible bugs because the methods are not safe to call from one another (because the global variable that is the thread local could be overwritten by the other method). I guess the tests should catch that.
- like others said, relying on Soft/WeakReferences often has nonobvious implications for GC performance which I'm guessing will not be apparent in your benchmarks but still exist. Yes the CacheBuilder class supports SoftReferences but only if the caller explicitly asks for them, not silently under the hood.
- the javadoc of the gwt version claims that the class uses WeakReference / SoftReference but it actually keeps a static final byte[] instead. (yuck).
- Exceptions are more helpful if they quote the offending value. E.g.
checkArgument(minSize >= 0, "minSize must not be negative");
checkArgument(minSize <= MAX_BYTE_SIZE, "minSize must not exceed 2^16");
should probably be:
checkArgument(0 <= minSize && minSize <= MAX_BYTE_SIZE, "Expected 0 <= value < %s, got %s", MAX_BYTE_SIZE, minSize);
Hi Tobias, thanks for your comment. I'll go through them one by one.
> major comment: I'm not sure that ThreadLocals are the right approach here. Perhaps there is a >better solution for the case that you care about (e.g. passing a pre-allocated array like in >Collection.toArray()? or something else)?
There is no particular case I especially care about, this is a patch that should increase performance in every scenario. As I said, I don't think that passing a pre-allocated array or a similar api would help users along, since re-using buffers properly is a tricky task that should be handled by a framework.
> the Reference object itself cannot be garbage collected so this will necessarily create at least >two objects per calling thread. Those two objects will then stick around for the rest of the >lifetime of the thread.
What is the second object? The Reference object itself will not be collected until the thread finishes. But this object itself only allocates a negligible amount of memory.
> (minor) this creates a new class of possible bugs because the methods are not safe to call from >one another (because the global variable that is the thread local could be overwritten by the >other method). I guess the tests should catch that.
Here you've got a point, I'm working on a solution for that currently
> like others said, relying on Soft/WeakReferences often has nonobvious implications for GC >performance which I'm guessing will not be apparent in your benchmarks but still exist. Yes the >CacheBuilder class supports SoftReferences but only if the caller explicitly asks for them, not >silently under the hood.
I have not found much on the internet on these problems, besides http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6912889 , which I have already addressed
well, I don't think there are any bugs in the current code. But in case the ThreadLocalBuffers-class is to be made public one day, it may be better to make zeroing mandatory right now.
> the javadoc of the gwt version claims that the class uses WeakReference / SoftReference but it >actually keeps a static final byte[] instead. (yuck).
you're right, my bad
> Exceptions are more helpful if they quote the offending value. E.g.
> checkArgument(minSize >= 0, "minSize must not be negative");
> checkArgument(minSize <= MAX_BYTE_SIZE, "minSize must not exceed 2^16");
> should probably be:
> checkArgument(0 <= minSize && minSize <= MAX_BYTE_SIZE, "Expected 0 <= value < %s, got >%s", MAX_BYTE_SIZE, minSize);
agreed
I will push some more commits in the coming days to address these issues.
Update: ThreadLocal buffers are already used in Guava, @Maaartinus  pointed that out before: https://github.com/google/guava/blob/master/guava/src/com/google/common/escape/Platform.java#L29
We're sorry to be letting you wait for this long but there's a reason why we can't respond more right now. We'll be able to tell you more in a few weeks.
@cgdecker thanks for your answer. I'm a bit puzzled right now what the concerns are. Buffer reuse is a tricky task where you can do a lot of things wrong, it took me quite a lot of effort to come up with an implementation that is safe even when the same thread uses a buffer on different levels of the stack trace. Also, there is not really any good alternative algorithm or approach to the problem; if you want buffer reuse to be efficient, save and free of memory leaks, you will inevitably wind up with ThreadLocals, Weak-/SoftReferences and some sort of 'Lease' concept to avoid reuse by the same thread. Feel free to disagree on these points I mentioned, I'm willing to discuss them. But my point is: if you have a patch that increases performance in every possible scenario without any api break or side effects whatsoever, why would a user need more 'control' over it? I just cannot think of any scenario where a user-supplied buffer would make more sense than my implementation. It may outperform my implementation by a small margin if the user would cache a buffer in say a HttpSession, but there is just too much that could go wrong.
If your concerns are that it 'looks' somewhat fragile and hard to test properly, I can totally understand that, but that is just the nature of the beast in this case.
Both Quasar and Akka rely on plain old threads eventually, so the concurrency models may be different but they base on the same building blocks. In http://docs.paralleluniverse.co/quasar/ is says:
"Using ThreadLocals in a fiber works as youd expect  the values are local to the fiber."
Because a fiber is nothing but a wrapped Thread at the end of the day. Every concurrency library out there is based on plain old threads and ThreadLocal cannot be "tricked" out of working, so there is nothing to worry about. As long as every code execution in java happens in the context of a java thread, ThreadLocals will work and this patch will work.
# Abstract
goal of this PR is to replace the often seen but unneccessary
```
byte[] buf = new byte[BUF_SIZE];
```
or
```
ByteArrayOutputStream baos = new ByteArrayOutputStream();
```
with thread-local instances of the respective types in all cases where they are used method-internal, this way avoiding unneccessary memory allocation, increasing performance and enhancing the memory profile.
# Implementation
[ThreadLocalBuffers](https://github.com/berndhopp/guava/blob/master/guava/src/com/google/common/io/ThreadLocalBuffers.java) is the manager of thread-local buffers. It uses [SoftReferences](https://docs.oracle.com/javase/6/docs/api/java/lang/ref/SoftReference.html) to store buffers, this way enabling Garbage Collection to collect the buffers when the system runs low on memory. This class is package-local right now but can eventually be made public for other scenarios where a buffer is needed.
All allocations of byte[] or ByteArrayOutputStream where the allocated byte[]/BAOS was not the returned value of the method have been replaced with calls to ThreadLocalBuffers.
ByteSource.contentEquals was challenging, because it used not one but two byte-arrays for buffering, so I used two ByteBuffers that wrap around the upper and lower part of the thread-local buffer, thereby mimicking the two buffers.
# Results
The microbenchmarks show that avoiding buffer allocation yields a significant performance boost.
| tested method | bytes copied | runtime w/ TL buffers | runtime w/out TL buffers | performance increase in % |
| --- | --- | --- | --- | --- |
| ByteStreams.copy | 10 | 105569 | 681130 | 645,2 |
| ByteStreams.copy | 100 | 107411 | 698152 | 649,98 |
| ByteStreams.copy | 10000 | 840354 | 1186307 | 141,17 |
| ByteStreams.readBytes | 10 | 68917 | 633365 | 919,03 |
| ByteStreams.readBytes | 100 | 69802 | 660336 | 946,01 |
| ByteStreams.readBytes | 10000 | 360357 | 934588 | 259,35 |
| ByteStreams.toByteArray | 10000 | 1962961 | 4962929 | 252,83 |
| ByteSource.contentEquals | 10 | 647249 | 3614650 | 558,46 |
| ByteSource.contentEquals | 100 | 685559 | 3586983 | 523,22 |
| ByteSource.contentEquals | 10000 | 696307 | 9460941 | 1358,73 |
you can find the results here:
[ByteStreamsBenchmark w/out ThreadLocal](https://microbenchmarks.appspot.com/runs/dfb1c1b7-b9e2-431c-91f9-3be2f19db2a7)
[ByteSourceBenchmark w ThreadLocal](https://microbenchmarks.appspot.com/runs/f5517421-8f23-4237-9de1-f7d9e4c8f3ce)
[ByteSourceBenchmark w/out ThreadLocal](https://microbenchmarks.appspot.com/runs/573ac1ff-a1e9-4870-9b0d-414e77e163e6)
I signed it!
I have a `RemovalListener` attached to `LoadingCache`.
When the cache is accessed frequently, everything works good.
If there is no activity with the cache since entry write till entry expiration, then expired entity is "silently" evicted and removal listener is not called.
Tried with `expireAfterWrite == refreshAfterWrite` and `expireAfterWrite > refreshAfterWrite`.
Not sure whether it's a bug or designed behaviour caused by combination of config params. Anyway, I cannot find the solution for the problem in the documentation.
Does it mean that entries can be evicted/expired from the cache before `RemovalListener.onRemoval` call?
Assume that `RemovalListener.onRemoval` should be called right after (or right before) the actual entry removal from cache.
Issue here is that entry becomes expired and no more available through `get(key)` method, but `RemovalListener.onRemoval` was not called
Are entries removed in scope of maintenance?
I believe that entries should be available while they are not actually removed from cache
So is there a way to get such entries while they aren't actually removed during queued maintenance?
So there is a period of time when entity cannot be returned by get() (since it's expired), but the `RemovalListener` is not called yet? And cache still holds allocated memory for that entity?
It's not so efficient I guess. We want to use our resources with most efficiency and be able to get the entity while it sits in memory.
I'm also experiencing the same issue. Forcing cleanup appears to work, however, this isn't a desirable workaround. My entries are supposed to expire after a short period of time, but they do not. The removal listener never gets invoked and thus throws off the functionality of my application. This is of course when I do not force cleanup.
Ok. I believe you have reasons to hold entities in memory for some time. I don't mind. But I need to get the notification when the entity is evicted. Now it is called sometimes, and sometimes it is not. Looks like we have consistent performance and inconsistent behaviour.
I think that it will be much clear to have _desired_ time of expiration rather exact time and then mysterious unusable entries in memory.
Thus having setting `expireAfterWrite=4h` it will be expected that entries will be expired after 4h and ~1 second. And I believe that this is pretty much acceptable behaviour.
If an entry is present and expired than it is not suitable for use, so the cache should treat it as a miss and possibly fetch a new copy. If the entry is usable but may be stale, then if you use `refreshAfterWrite` the cache will return the existing entry and retrieve a new copy, possibly asynchronously. Expiration and refresh are closely related concepts, with the difference being whether the entry is considered usable by the application or not.
The fact that some entries are retained in memory after expiration, due to internal mechanisms, is a detail that shouldn't concern users very often. The cache makes no guarantee when a notification is published, so just like Java finalizers closing resources it shouldn't be relied upon occurring within a strict time period. Guava walks a fine line of expiring sooner than lazy caches (relying on the maximum size) and immediate expiration relying on dedicated threads and expensive data structures (e.g. O(lg n) priority queue).
Guava is pretty flexible and was careful about the tradeoffs for the common case. If those decisions aren't proper for your application, then decorating the cache to provide custom behavior is usually a workable solution.
I believe that if entity is present it is not expired, and if entity is expired it is not present in cache.
Application is quite sensitive to removal events and expects that entries are present in cache until removal event is fired. But apparently entries becomes unavailable from cache without removal event. And logic tries to detect removal event to prevent reading of removed/expired entries (or even put them back if application knows that there's no possibility to load/refresh them using back-end loader due to outage).
Application is heavily loaded and that _maintenance_ period (even if it takes seconds) causes too much of misses and consecutive errors due to loader outage.
Most importantly, base64 writes 4 bytes of output for every 3 bytes of input. There's no reasonable way to flush after 2 bytes of input.
I think the problem is assuming that flush makes sense for Base64. It does not. If you need flush, don't use Base64.
My multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,
``` java
(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),
(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),
(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),
```
This results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.
```
java.lang.NegativeArraySizeException
at com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)
at com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)
at com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)
at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
at com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)
at com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
at java.lang.Thread.run(Thread.java:745)
```
The saturated cast should handle that. Both ConcurrentHashMap
even though I don't know why it might occur.
On Jul 15, 2015 7:45 AM, "Kurt Alfred Kluever" notifications@github.com
wrote:
> Are your caches _really_ big? I see we do some summing up of segment
> sizes in a loop - maybe we are overflowing Integer.MAX_VALUE?
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2108#issuecomment-121638255.
Yes, its that simple. In `longSize()` use `return Math.max(0, sum)` which will cover all of the size() methods. This is essentially what I do in my [fixture](https://github.com/ben-manes/caffeine/blob/master/caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/GuavaCacheFromContext.java#L207), which is used to run all my tests against both Caffeine and Guava implementations to find bugs / check compatibility.
Either is fine with me. Since the size is an estimate, rather than exact, I'm not overly concerned either way. The `long` avoids overflow so your idea would be for better precision.
I was writing my own `Table` implementation today and realized I was duplicating much of the logic in Guava's `AbstractTable`, which is package-private.  I also realized I got a few implementation details wrong.  I can't copy and paste the code into my own project because `AbstractTable` relies on other package-private utilities in a few places.
Could you make `AbstractTable` public, so that other people can use it as a good starting point for their own custom tables?
Some methods of the class `Verify` miss the proper `@throws` tag. To be consistent with the method `Verify.verify(boolean, String, Object...)`, which already contains the proper `@throws` comment, I added the `@throws` tag where missing.
I am trying to identify what the latest version of Guava is, and where it can be downloaded from. This information is needed for a third party dependencies security review of a PCI DSS application, where guava is a dependency.
See the answer to #2018
I just noticed that the equality test for `Predicates.in` uses sets to test predicate equality:
```
public void testIn_equality() {
Collection<Integer> nums = ImmutableSet.of(1, 5);
Collection<Integer> sameOrder = ImmutableSet.of(1, 5);
Collection<Integer> differentOrder = ImmutableSet.of(5, 1);
Collection<Integer> differentNums = ImmutableSet.of(1, 3, 5);
new EqualsTester()
.addEqualityGroup(Predicates.in(nums), Predicates.in(nums),
Predicates.in(sameOrder), Predicates.in(differentOrder))
.addEqualityGroup(Predicates.in(differentNums))
.testEquals();
}
```
This test passes, but only accidentally. What it appears to test is that two `InPredicate`s are equal, if their `target` collections contain the same elements in any order. This test will fail, however, when you replace `ImmutableSet` with an ordered type like List. It only passes because `equals` on `Set`s is true despite of element order, and `InPredicate` simply forwards `equals` to its targets. From what I understand, `InPredicate#equals` should be true even if its target collections are ordered collections.
So this is either a misleading test, or `InPredicate#equals` does not work as intended.
That's fine--but then the test is wrong, or at least misleading? It seems to test that equality on the predicate is order-insensitive, but this is only true right now because the test uses sets... it would fail for any ordered collection.
If this tests what you say it should, then why go through this whole `sameOrder` `differentOrder` business?
(i.e. lack of order is a property of sets, not of the predicate)
In my case I'm using BaseEncoding.base64() encoder to write the base64-encoded data into another stream.
It seems there is no way to write the data correctly without the target stream being closed at the end.
I'm using the following code
```
String lineSeparator = System.lineSeparator();
BaseEncoding encoder = BaseEncoding.base64().withSeparator(lineSeparator, 64);
String data;
data = "{\"en_US\",0,0,\"\",-1,\"\",\"\",\"\",\"\"}";
byte[] bytes = data.getBytes();
ByteArrayInputStream stream = new ByteArrayInputStream(bytes);
ByteArrayOutputStream writerStream = new ByteArrayOutputStream(100);
Writer writer = new OutputStreamWriter(writerStream);
OutputStream target = encoder.encodingStream(writer);
ByteStreams.copy(stream, target);
//target.close();
writer.write("\n}, other text to be written");
writer.close();
```
When I'm running the following snippet the result is
```
eyJlbl9VUyIsMCwwLCIiLC0xLCIiLCIiLCIiLCIif
}, other text to be written
```
But the correct result should be
```
eyJlbl9VUyIsMCwwLCIiLC0xLCIiLCIiLCIiLCIifQ==
}, other text to be written
```
If I uncomment the line with target.close call I get an exception that output stream has been closed.
If I comment the line with writer.write I get the correct result but the other text has not been written and output stream has been closed.
Maybe this is a documentation issue and subject class shouldn't be used in such a scenario. In that case this should be stated in the documentation.
Louis, I haven't found the close() call you're referring to in BufferedWriter.close().
It does set underlying stream reference to null though.
I didn't look at all possible implementations. The one I have sources for contains this snippet
```
@SuppressWarnings("try")
public void close() throws IOException {
synchronized (lock) {
if (out == null) {
return;
}
try (Writer w = out) {
flushBuffer();
} finally {
out = null;
cb = null;
}
}
}
```
You're right.
When the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.
Due to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:
> The key and/or value may be null if they were already garbage collected.
Therefore a listener might decide to inspect the properties without a null guard, leading to an NPE.
``` java
@Test
public void clear_expireAfterAccess() {
RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);
ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =
ArgumentCaptor.forClass(RemovalNotification.class);
Cache<Integer, Integer> cache = CacheBuilder.newBuilder()
.expireAfterAccess(1, TimeUnit.MINUTES)
.removalListener(listener)
.ticker(ticker)
.build();
cache.put(1, 1);
ticker.advance(10, TimeUnit.MINUTES);
cache.invalidateAll();
verify(listener).onRemoval(captor.capture());
assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));
}
```
The fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause.
Unfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.
I would have the bandwidth (be incentivized) if the Guava team was able to provide obfuscated traces (#1110) for policy simulation.
Maybe this is easier to get worked on?
applied patch from https://codereview.appspot.com/5271042/
I signed it!
FWIW this would be very useful. Java 8 offers limited support for unsigned types, and in particular it does not offer UnsignedShorts.checkedCast() (it only offers widening conversions). That happens to be my use case.
@lowasser Any outstanding issues preventing this addition?  When the method `removeExactly` from the class `ConcurrentHashMultiset` is invoked with a negative number as second parameter, the method correctly throws `IllegalArgumentException`. This behavior is not documented in the javadoc comment of the method, since the `@throws` tag is missing. I added the missing tag.
I signed it!
bloom filter apply to filter big data usually, maybe billions of records, when the number of expected insertions is 10 billion and the false positive probability is 0.0001, it will take about 22G RAM, it not appropriate memorize by long array, I changed the type to "HashMap&lt;Integer, Long[]&gt;", ensure long array less than 20M, does this feather useful to somebody others ?
https://google.github.io/guava/releases/18.0/api/docs/package-list should be available so that we can Javadoc link to it.  I see that the file exists at `gh-pages/_releases/18.0/api/docs/package-list`, but for some reason it doesn't make it to the website.
In a "plain" publishing of Javadocs to `gh-pages`, the `package-list` file is obtainable.
Might we be able to look forward to this in the 19.0 release?
There is a error on the wiki page [NewCollectionTypesExplained - implementations](https://github.com/google/guava/wiki/NewCollectionTypesExplained#implementations-1):
```
<A href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/LinkedListMultimap.html">
LinkedListMultimap
```
```
<A href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/Table.html">
Table
Unknown end tag for </a>
```
I expect it would essentially be
```
public boolean overlaps(Range other) {
return isConnected(other) && !intersection(other).isEmpty();
}
```
```
logger.log(Level.SEVERE, "Could not dispatch event: "
+ context.getSubscriber() + " to " + context.getSubscriberMethod(),
```
This means any `@Subscribe` method which throws an exception fails to log the most important information of all: the actual exception thrown. (If the exception happened to be wrapping another exception, Guava will log the wrapped exception, but that's usually not the case.)
I believe this should be:
```
logger.log(Level.SEVERE, "Could not dispatch event: "
+ context.getSubscriber() + " to " + context.getSubscriberMethod(),
```
To reproduce, try the following. I would expect the log message to include `This message should appear in the logs`, but it doesn't.
```
import com.google.common.eventbus.EventBus;
import com.google.common.eventbus.Subscribe;
private static class Event { }
@Subscribe
public void handleEvent(Event event) {
throw new RuntimeException("This message should appear in the logs");
}
public static void main(String[] args) {
EventBus eventBus = new EventBus();
eventBus.post(new Event());
}
}
% javac -cp guava-18.0.jar GuavaBug.java
% java -cp guava-18.0.jar:. GuavaBug
Jun 24, 2015 2:30:42 PM com.google.common.eventbus.EventBus$LoggingSubscriberExceptionHandler handleException
SEVERE: Could not dispatch event: GuavaBug@7de26db8 to public void GuavaBug.handleEvent(GuavaBug$Event)
```
Hi, shouldn't this be:
``` java
logger.log(Level.SEVERE, "Could not dispatch event: "
+ context.getEvent() + " to " + context.getSubscriberMethod(),
```
Instead of:
``` java
logger.log(Level.SEVERE, "Could not dispatch event: "
+ context.getSubscriber() + " to " + context.getSubscriberMethod(),
```
It would be fine to include all three in the log, I'm sure.
any update with such issue, very long time since guava 18.0 released.
FWIW, allocation is also a performance issue in J2ObjC. This hits us hardest with autoboxing. But I expect that the collection view caches aren't going to make a dent either way.
Also worth mentioning that J2ObjC's version of java.util.AbstractMap (taken from android) uses the same pattern with "keySet" and "valuesCollection" fields. So our users already need to deal with the lifecycle problem. (We may consider changing that based on the result of this discussion)
Something like:
Range _original = ...;
_original.equals(Range.parse(_original.toString()));
Guava provides `Range.span(Range otherRange)` for getting the minimal `Range` which encloses both `this` and `otherRange`.  A natural thing to want is to determine the minimal span enclosing a collection of `Range`s, but as far as I can tell no method is provided for this.
if you want to implement it yourself, you either have to:
- call `Range.span` repeatedly, one `Range` at a time
- write your own logic to go through the list and correctly deal with closed, open, and unbounded endpoints.  This is what we have done, but it's not particularly simple, and someone trying to implement it could easily make an error.
Within Guava, it would be trivial to implement this using the ordering on the package-private `Cut` object currently used by `Range` to implement `Range.span`.
Yes, I'm looking for the same behavior as if you created a `RangeSet` and called `.span()` on it.  However, I'm suggesting it might be worthwhile to make it its own static method because implementing it with `RangeSet` is somewhat inelegant.
`ImmutableRangeSet.Builder` forbids adding overlapping ranges (which might be present) so we must use `TreeRangeSet` like this:
```
RangeSet<T> rs = TreeRangeSet.create();
for (final Range<T> range : ranges) {
rs.add(range); // no addAll
}
final Range<T> span = rs.span();
```
Code-wise, this isn't bad and could easily wrapped up in a method. But at a glance at least, it looks like under the hood this involves creating a `NavigableMap<Range>` and then applying the rather complex logic of `TreeRangeSet.add()`, which at the very least creates another `Range` object for each input range.
It seems inelegant to be sorting the ranges and creating lots of objects for something which could be done in a single linear pass through the ranges without creating any.  But perhaps the use case is too rare for Guava,
It was more aesthetic than practical.  Repeatedly calling `span` allocates a new `Range` on every call [1], while if you go through the list tracking end points you can avoid creating any objects at all (except the returned answer).  But perhaps the compiler can optimize away the allocation of the temporary `Ranges`, and it is unlikely to be a performance bottleneck, anyway, so I will close the ticket.  Thanks for your all's work on Guava by the way - we use it constantly.
[1] Actually, it happened on every call only in the older version of the code I was looking at. The current version is cleverer and will reuse one if the input `Ranges` if it can.  In the case of a large collection of random `Ranges` this will happen often, though not if they are somewhat sorted, which I'd imagine is a common case.
I was writing a subclass of `SettableFuture` that takes some additional action when `cancel()` is invoked, but _Oops_ the class is `final`...
Marking a class in a general purpose library `final` is a pretty drastic thing to do, so I assume there is a good reason.... ?
If there is no good reason, how 'bout let's make it extensible.
Thanks, didn't realize that. Sorry for the noise.
If you try to split "abc82" with the pattern "(?=\d)" you get [abc, 8].
The last number will be left out of the result.
http://stackoverflow.com/q/30941743/758280
All of the other tests passed.
I think this is a good idea, though it'd be good to warn users that (naturally) the default concurrency level may be different (see andrewgaul/modernizer-maven-plugin@6cc37bd528fbbcf6312eda58a53c307ead560ae8).
For other candidates, see the `com/google/...` entries in [`modernizer.xml`](https://github.com/andrewgaul/modernizer-maven-plugin/blob/master/src/main/resources/modernizer.xml).
At this time Guava needs to be compatible with Java 6. Since diamond is only available in Java 7+, IMHO, I don't think this is a good idea. I think we can think in this when Guava requirements when updated to Java 7.
_Motivating example_: Suppose you want a `Map` with `byte[]` keys, where the keys are compared by array contents (e.g., "deep equals").
You can't used any normal hash-based `Map` implementation because those hash and compare using `hashCode` and `equals()`, which for `byte[]` arrays uses object identity, not array contents. The only option is to use e.g. `TreeMap` and supply a custom comparator. But `TreeMap` requires a lot more memory per entry, provides unnecessary sorting, and moreover this workaround doesn't always work: in some cases, your keys may not have any total ordering at all.
I've encountered this problem repeatedly: I want a `HashMap` of some objects but need it to be based on custom hashing and equality methods.
_Request_: give `MapMaker` the ability to be configured with a pluggable hash/equality delegate, e.g.:
```
public interface Hasher<T> {
boolean equals(T t1, T t2);
int hashCode(T t);
}
public class MapMaker {
...
public void <T> hasher(Hasher<T> hasher);
}
```
This would solve this problem in a nice way.
You could also provide `EqualsHasher` and `IdentityHasher` implementations of the two standard "hashers" already used by `MapMaker`, using them for normal and weak keys, respectively.
OK, thanks. I didn't know about `Equivalence`... should have looked there.
I strongly disagree however with not providing a public way to specify an `Equivalence` to `MapMaker`. Just seems spiteful. Oh well.
I have raised a pull request for this: https://github.com/google/guava/pull/2247
What is the problem?
In [`ImmutableMap`](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableMap.java) class, we have these methods:
``` java
// If the map is an EnumMap, it must have key type K for some <K extends Enum<K>>.
@SuppressWarnings({"unchecked", "rawtypes"})
private static <K, V> ImmutableMap<K, V> copyOfEnumMapUnsafe(Map<? extends K, ? extends V> map) {
return copyOfEnumMap((EnumMap) map);
}
private static <K extends Enum<K>, V> ImmutableMap<K, V> copyOfEnumMap(EnumMap<K, ? extends V> original) {
EnumMap<K, V> copy = new EnumMap<K, V>(original);
for (Map.Entry<?, ?> entry : copy.entrySet()) {
checkEntryNotNull(entry.getKey(), entry.getValue());
}
return ImmutableEnumMap.asImmutable(copy);
}
```
This code is valid but there is an error from JDT:
> Type mismatch: cannot convert from `<Enum<Enum<K>>>` to `<K>`
Before the creation of this issue, I reported the bug in the bugtracker of JDT (issue [here](https://bugs.eclipse.org/bugs/show_bug.cgi?id=469404)). In 2 words, the conclusion was that: "Yes, JDT don't support this usage of Java but there is a better practice". This better practice is explained [here](https://bugs.eclipse.org/bugs/show_bug.cgi?id=469404#c3):
``` java
private static <K extends Enum<K>> ImmutableMap<K, V> copyOfEnumMap(EnumMap<K, ? extends V> original) {
return copyOfEnumMap((EnumMap<K,?>) map);
}
```
I tried some tricky solutions but, unfortunately, this solution can't be applied in your project. So I come to notify you that your project can't be compiled by JDT.
The documentation for `ImmutableList.of()` states the following:
> Returns the empty immutable list. This set behaves and performs comparably to Collections#emptyList, and is preferable mainly for consistency and maintainability of your code.
One notable difference between `ImmutableList.of()` and `Collections.emptyList()` is that the former throws an `UnsupportedOperationException` on `clear()` while the latter does not. Should that be considered behaving "comparably"?
Similarly for `ImmutableMap` and `ImmutableSet`.
EDIT: I also noticed the documentation says "Returns **the** empty immutable [list/map/set]." I suppose that's a mistake?
Regarding the singleton return value, I would say it should either be documented clearly or not at all.
I must disagree. `Collections.emptyList()` doesn't have to return a singleton. Assuming it does, `ImmutableList.of()` doesn't have to emulate that property. Assuming it does, "the" is a very obscure way of referencing that.
When the method `AbstractMapBasedMultiset.add(Integer, int)` is invoked with a negative number as second argument, an `IllegalArgumentException` is thrown.
Example:
```
HashMultiset<Integer> multiset = HashMultiset.create();
multiset.add(1, -10);
```
This behavior is reasonable, but not specified in the Javadoc comment of the method. Do you think it should be described in the Javadoc?
I'm using `ImmutableMap` for building structures that I can then automatically serialize to JSON, like the following adapted from http://json.org/example:
``` java
Map j = ImmutableMap.of(
"id", id,
"title", title,
"debug", "on",
"window", ImmutableMap.of(
"title", "Window title",
"name", "window_1",
"width", 500,
"height", 500
)
);
```
Coming from Python where JSON can be used in source code as-is, the above is a very nice alternative in Java land and I couldn't think of a way to make it any better, syntax-wise. However, I hit the limit of the maximum 5 key-value pairs of `ImmutableMap::of`, and then I had to use rather ugly workarounds (with `Builder` or alternatively splitting a big Map up into two and joining them together again...).
I fully understand that there is no variable arguments overload like in `ImmutableSet::of` -- you couldn't guarantee at compile-time that the number of `ImmutableMap::of` arguments is even (to form key-value pairs), it would fail at run-time, and we don't want that.
I also understand that there probably is some resistance in providing a high number of overloads. However, I still think the limit of 5 entries is [too low](https://stackoverflow.com/q/9489384/60982). And resorting to `Builder` is just plain ugly in some cases. I therefore propose to raise the number of overloads to 10, as this should cover most use cases and will create less headache for users. On the implementation side it is a trivial change and I don't see any problem.
line of code (.build()), and per entry five additional characters. And
from a visual point of view your brain has to ignore more boilerplate
while reading code. So personally I find using ImmutableMap.of a lot nicer.
When you push an api to the point where it feels awkward, then you may be using the wrong tool for the job. For json specifically, there are libraries like [jsonschema2pojo](http://www.jsonschema2pojo.org/) that code generate the boilerplate and then marshall with a json serializer.
_my_ use case and would slow me down considerably while prototyping. I
need to quickly iterate on the json schema and add/remove attributes at
any place while I go along. For that, the ImmutableMap.of is just
perfect. I agree that for production-use or exposing such json objects
or similar. It's just two different use cases.
Refastor mentions hurt my heart :broken_heart:! Open source as a Christmas present :grinning:
Are there regression benchmarks to see how this would affect Android?
I'd been thinking of class loading being impacted by the new methods. But
now that I think of it, Proguard should take care of removing the unused
methods.
This is an example
![image](https://cloud.githubusercontent.com/assets/7517052/15635850/32e26f78-25eb-11e6-9026-abedd7edf09f.png)
It requires List<OwnExecutableInstruction>and List<String> but it gets two objects.
You have closed my issue recently (2489). And that was just an example, where ImmutableMap.builder() doesn't work :) I also want to use ImmutableMap.of to accept more than 5 entries.
`Map <String, Supplier<String>> map = ImmutableMap.<String, Supplier<String>>builder()
.put("one", () -> "supplier1")
.build();`
In some cases, it's desirable to build a more complex error message which does not use simple string placeholder substitution like the current incarnations of `checkNotNull` and `checkArgument` support. So I think it would be nice to have variants which accept a `Supplier<String>` which will return an error message when needed. Eg.
``` java
public static <T> T checkNotNull(T reference, Supplier<String> errorMessageSupplier) {
if (reference == null) {
}
return reference;
}
```
Which would be used like (with a Java 8 lambda for brevity):
``` java
checkNotNull(variable, () -> buildComplexMessage(variable));
```
In my opinion this could still be added to Guava, so that those who are using Java 8 already can use this feature conveniently (Guava's `Supplier` can also be written as `() -> ..` because it's a one-method interface basically, so no need for JDK8's `Supplier`).
But even in Java 7 it could be useful, even though the `Supplier` implementation would be quite verbose, I can imagine cases where such a `Supplier` is instantiated in one place, and re-used in different calls.
I don't think the extra links will make a meaningful difference on Android users. The bulk of the RAM in an Android app is used by high-resolution images!
The number of objects allocated in `LinkedHashMap` is the same as in `HashMap`. Not sure about `LinkedHashMultimap`.
I have this class:
``` java
public class Core extends AbstractIdleService {
protected void startUp() throws Exception {
}
protected void shutDown() throws Exception {
}
}
```
and this unit test:
``` java
public class CoreTest {
private final Core core = new Core();
private final AtomicBoolean started = new AtomicBoolean();
private final AtomicBoolean stopped = new AtomicBoolean();
@Before
public void setupCoreListener() {
core.addListener(new Listener() {
public void running() {
System.out.println("running");
started.set(true);
}
public void stopping(State from) {
System.out.println("stopping");
stopped.set(true);
}
public void terminated(State from) {
System.out.println("terminated");
stopped.set(true);
}
}, MoreExecutors.directExecutor());
}
@Test
public void coreCanStartUp() {
core.startAsync().awaitRunning();
System.out.println("testing started");
MatcherAssert.assertThat(started.get(), Matchers.is(true));
}
@Test
public void coreCanShutDown() {
core.startAsync().awaitRunning();
core.stopAsync().awaitTerminated();
System.out.println("testing stopped");
MatcherAssert.assertThat(stopped.get(), Matchers.is(true));
}
}
```
```
testing started
running
running
stopping
testing stopped
terminated
```
So `core.startAsync().awaitRunning()` returns before the listener for `running` is called. Is that intended and correct behaviour?
Well, bugger. That makes sense. Thanks. :)
To check if a list of strings contains the input string case-insensitively.
List<String> lisr= new List<String>();
list.add("Apple")t
System.out.println("List contains input string");
}
This should print the output "List contains input string"
As a follow up to https://github.com/google/guava/issues/2064, for testing, it would be handy to have
`EvictingQueue.of(1,2,3,4,5)` that would just create a new EvictingQueue of size 5 with the passed in elements.
Something like this, perhaps:
```
class EvictingQueue {
//...
public static <T> EvictingQueue<T> of(Collection<T> elements) {
EvictingQueue<T> ret = EvictingQueue.create(elements.size());
ret.addAll(elements);
return ret;
}
public static <T> EvictingQueue<T> of(T... elements) {
return EvictingQueue.of(Arrays.asList(elements));
}
}
```
When using [hamcrest assertions](http://hamcrest.org/JavaHamcrest/), I was surprised that the following didn't pass:
```
EvictingQueue<Integer> lastFive = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10).collect(Collectors.toCollection(() -> EvictingQueue.create(5));
EvictingQueue<Integer> expected = EvictingQueue.create(5);
expected.addAll(Arrays.asList(6, 7, 8, 9, 10));
assertThat(lastFive, is(expected));
```
Whereas the following did:
```
EvictingQueue<Integer> lastFive = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10).collect(Collectors.toCollection(() -> EvictingQueue.create(5));
EvictingQueue<Integer> expected = Arrays.asList(6, 7, 8, 9, 10);
assertThat(new ArrayList<>(lastFive), is(expected));
```
Of note is that Guava's default concurrency level (4) results in similar performance to a synchronized LinkedHashMap. This is due to the cache's overhead, in particular the GC thrashing from ConcurrentLinkedQueue and a hot read counter. It should also be noted that at the time of development synchronization was slow in JDK5, but significantly improved in JDK6_22 and beyond. This and other improvements help LinkedHashMap's performance compared to what was observed when Guava's cache was in development.
The easiest way to double Guava's performance would be to replace the `recencyQueue` and `readCount` with a ring buffer. This would replace an unbounded linked queue with a 16-element array. When the buffer is full then a clean-up is triggered and subsequent additions are skipped (no CAS) until slots become available. This could be adapted from this [implementation](https://github.com/ben-manes/caffeine/blob/master/caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedBuffer.java).
Given the increase in server memory, it may also be time to reconsider the default concurrency level. Early design concerns included the memory overhead, as most caches were not highly contended and the value could be adjusted as needed. As the number of cores and system memory has increased, it may be worth revisiting the default setting.
#### Read (100%)
| Unbounded | ops/s (8 threads) | ops/s (16 threads) |
| :-: | :-: | :-: |
| ConcurrentHashMap (v8) | 560,367,163 | 1,171,389,095 |
| ConcurrentHashMap (v7) | 301,331,240 | 542,304,172 |
|  |  |  |
| **Bounded** |  |  |
| Caffeine | 181,703,298 | 365,508,966 |
| ConcurrentLinkedHashMap | 154,771,582 | 313,892,223 |
| LinkedHashMap_Lru | 9,209,065 | 13,598,576 |
#### Read (75%) / Write (25%)
| Unbounded | ops/s (8 threads) | ops/s (16 threads) |
| :-: | :-: | :-: |
| ConcurrentHashMap (v8) | 441,965,711 | 790,602,730 |
| ConcurrentHashMap (v7) | 196,215,481 | 346,479,582 |
|  |  |  |
| **Bounded** |  |  |
| Caffeine | 112,622,075 | 235,178,775 |
| ConcurrentLinkedHashMap | 63,968,369 | 122,342,605 |
| LinkedHashMap_Lru | 8,668,785 | 12,779,625 |
#### Write (100%)
| Unbounded | ops/s (8 threads) | ops/s (16 threads) |
| :-: | :-: | :-: |
| ConcurrentHashMap (v8) | 60,477,550 | 50,591,346 |
| ConcurrentHashMap (v7) | 46,204,091 | 36,659,485 |
|  |  |  |
| **Bounded** |  |  |
| Caffeine | 55,281,751 | 47,482,019 |
| ConcurrentLinkedHashMap | 23,819,597 | 39,797,969 |
| LinkedHashMap_Lru | 10,179,891 | 10,859,549 |
Is the "op" a read, update or insert? The latest stuff I did in cache2k only have a bottleneck for the insert operation, which implies structural changes and therefor needs locking. All other operations run fully concurrently. Can you maybe rerun your benchmarks with a cache2k setup I give you?
You can send a pull request to add a new cache type to the [GetPutBenchmark](https://github.com/ben-manes/caffeine/blob/master/caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/GetPutBenchmark.java). I looked at cache2k a while back and am not confident in it being threadsafe, so it may perform well but corrupt itself.
> I looked at cache2k a while back and am not confident in it being threadsafe, so it may perform well but corrupt itself.
Yes, quite normal reaction. I regularly have these concerns, when I look at a code area that I had not touched for some months. I walk through the design and the JMM again and finally find good sleep. So far we had no corruption in production, even for releases marked as experimental.
On my laptop I get the following results, which matches the [Desktop-class benchmarks](https://github.com/ben-manes/caffeine/wiki/Benchmarks) section.
| Benchmark | ops/s (8 threads) |
| :-: | :-: |
| Read (100%) | 8,864,382 |
| Read (75%) / Write (25%) | 8,064,139 |
| Write (100%) | 2,489,101 |
The performance matches what I'd expect from top-level lock, which appears to be how the LRU is implemented. I haven't looked at why writes are slower, since they should take the same amount of time. This may be due to synchronization or  degradation in the custom hash table.
A [quick and dirty hack](https://github.com/ben-manes/guava/commit/0f286172945f7f23d1c2b8f297f9816e918c6bc3) to Guava resulted in up to **25x read performance gain** at the default concurrency level (4).
| Benchmark | ops/s (8 threads) | ops/s (16 threads) |
| :-: | :-: | :-: |
| Read (100%) | 121,808,437 | 260,593,210 |
| Read (75%) / Write (25%) | 34,770,671 | 48,538,555 |
| Write (100%) | 5,064,388 | 6,045,980 |
We can increase the concurrency level (64) for better write throughput, but unsurprisingly this decreases the read throughput. This is because the cpu caching effects work against us. ConcurrentHashMap reads are faster with fewer segments (576M ops/s) and Guava's recencyQueue is associated to the segment instead of the processor. The queue fills up slower, making it more often contended and less often in the L1/L2 cache. We still see a substantial gain, though.
| Benchmark | ops/s (8 threads) | ops/s (16 threads) |
| :-: | :-: | :-: |
| Read (100%) | 40,935,985 | 84,109,039 |
| Read (75%) / Write (25%) | 40,854,227 | 64,462,500 |
| Write (100%) | 6,757,178 | 6,570,233 |
Because we are no longer thrashing on readCounter, the compute performance increases substantially as well. Here we use 32 threads with Guava at the default concurrency level.
| Computer | sameKey ops/s | spread ops/s |
| :-: | :-: | :-: |
| ConcurrentHashMap (v8) | 30,321,032 | 64,427,143 |
| Caffeine | 1,558,302,420 | 533,181,707 |
I have been advocating this improvement since we first began, originally assumed that we'd get to it in a performance iteration. After leaving I didn't have a good threaded benchmark to demonstrate the improvements, so my hand wavy assertions were ignored. There are still significant gains when moving to the Java 8 rewrite, but these changes are platform compatible and non-invasive.
I don't know why I even bother anymore...
Updated the patch so that unit tests compile & pass.
This method exists to warn callers of `compare(Boolean, Boolean)` and
`compare(boolean, boolean)` with a deprecation warning.  Using the
private access modifier would still allow callers to use the generic
`compare(Comparable<?>, Comparable<?>)` method.
It would be great if it were possible to ignore null values received in the ComparisonChain class.
I solve this problem by using the Optional class, but it would be better to use a condition to ignore null values of comparison
I have a class "MyClass" that is filled from a sql query. It has 3 String fields: equip, family and shift. That class implements Comparator<MyClass> and I use ComparisonChain that compares equip, family and shift, in that order.
Well, the query returns some null values for Equip, of 100 elements, 5 has null values for equip. So the ComparisonChain throws a NullPointerException.
So, I use a Optional<String> to replace the null values with empty, just to continue the comparison correctly.
But, if the ComparisonChain has the ability to test null values before compare the values, this doesn't throws the NullPointerException, and it doesn't break the code.
I don't know, but I think that with a boolean parameter passed to constructor to define if the ComparisonChain needs test for null values before it do the comparison. And with this our code will be less.
Yeah, that solution is good. I just wanted to simplify the third parameter, but it's ok.
Thanks my friends! ;)
pull from head
sorry, this is my wrong operation.i just want to pull from google/guava 's master to my fork
The [code.google.com Guava homepage](https://code.google.com/p/guava-libraries/) tells people to come here at GitHub instead, yet key information for new users was missing from the README.
I guess signing the CLA isn't necessary for simple documentation changes? (According to CONTRIBUTING.md, _code_ contributions require it.)
@jonikarppinen This is a bot of google. So hopefully you do what the bot said :)
@jonikarppinen, googlebot isn't a human user. It only responds if you post a new message w/ the text "I signed it!" (without the apostrophes). :)
I like to create new collections using static classes like Maps, Lists, Sets, but guava missies some types of collections. For example WeakHashMap. Do it's done for some purpose?
Guava should improve sorting. in a way that the every type of list is supported. like right now ArrayList are supported. it should the same with CopyOnWriteArrayList.
Yes, I know about that. See here's an example.
I am making an application. which contains heavy real-time updates. so it uses more memory and guava's collection is more fast than androids built-in.
So i can use ArrayList to sort, No Matter but i did try that, Takes huge amount of memory and time. It always gives Fatal-Exception of Non-Thread safe operations. See after sometime i tried CopyOnWriteArrayList to avoid non-thread safe operations. But you can't Sort them with Collections it will generate UnsupportedOperationException.
So making more loops in actual code is more costly and while theres no Guava usage need then because we can use CopyOnWriteArrayList for no Exceptions and can sort with iterators. if it's durable so i can suggest that guava can implement Sorting for More ArrayListTypes inbuilt.
Thanks.
When using `Throwables.propagate` with a method that throws `Exception` or `Throwable`, using it properly requires some boilerplate to avoid swallowing `InterruptedException`. An example of such a method is `MethodHandle.invoke`. While it is true that such a method is very unlikely to throw `InterruptedException`, the pedant in me requires handling it correctly. It would be nice if this check could be added to `propagate`.
``` java
try {
method.invoke();
}
catch (Throwable t) {
Thread.currentThread().interrupt();
}
}
```
I would like to add more checks which can be applied on the [Preconditions](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/base/Preconditions.html) class. These checks would include:
- checkBlank(String)
- checkNotBlank(String)
- checkEmpty(String/Collection)
- checkNotEmpty(String/Collection)
All of these would throw an IllegalArgumentException if the check fails. Would it be acceptable to expand Preconditions to these new checks? I would be happy do to the pull request if so.
Thanks @lowasser for the clarification. We have noticed a lot of "cookie-cutter" code patterns around some of these checks (in some cases doing multiple function calls within the precondition), which is why I wanted to suggest adding these.
For empty / blank checks, I was considering failing the check if what was supplied was null, by throwing an IllegalArgumentException in that scenario.
I assume the checkEmpty(String) / checkNotEmpty(String) is also not wanted? Ex. checkNotEmpty would have to be non-null and length > 0.
OK, well I will go ahead and close this out. Thanks for the feedback.
Make the JavaDoc more clear about what happens in cases of equivalence.
That's a fair point, and maybe it should be removed completely.
The JavaDoc had already mentioned this for the second method (which takes a user supplied equivalence class comparator), and it was confusing to me for not only what you mentioned, but also it wasn't clear to me at first what it meant by "returned in the difference".
When I use the builder and put multiple entries into the map, the capacity keeps getting resized. I know the desired capacity before hand, so should be able to construct an immutable map of the correct size, and avoid this performance tax.
The builder already has a package private capacity constructor. I can not find documentation as to why this is not public (https://code.google.com/p/memory-measurer/wiki/ElementCostInDataStructures may have explained, but it is no longer available).
Thumbs on this suggestion. Yeah by defining the initial size cosf of adding the each entry in a map will be reduced in time complexity in expanding the bucket
This would be really useful. And same thing goes for all other Immutable\* classes.
Having the ability to to specify the capacity for builders when known a priori would be very beneficial for us.
Verified #196 is a duplicate of my request. Closing this issue.
So I found a minor bug while browsing the source in IntelliJ and figured, heck, why not fix it? So I forked guava, built it, made my change, pushed and created a pull request, complete with affable wit.
https://github.com/google/guava/pull/2045
The CLA bot wasn't happy. I suspected it was because I signed the CLA under javajosh@gmail.com, but my `git config user.email` was a different email. So I changed the value, reverted, created a new branch 'javajosh' and merged my change from master, pushed, and crafted a new pull request. Yet this did not, apparently, correct the problem:
https://github.com/google/guava/pull/2046
The check is done on line 166, so the first check is redundant.
The check is done on line 166, so the first check is redundant.
I assume I just signed away my first-born. Well, you can have him, Google.
I signed it!
Looks like this shaves 9+ minutes in total off the build and about 3 per sub build
I signed it!
It would be helpful to have a method to convert a `Map<String, String>` to `Properties` to use when interacting with APIs that require it. For example, the JDBC `Driver.connect()` method takes a `Properties`.
``` java
public static Properties toProperties(Map<String, String> map) {
Properties properties = new Properties();
for (Map.Entry<String, String> entry : map.entrySet()) {
properties.setProperty(entry.getKey(), entry.getValue());
}
return properties;
}
```
@kluever yes, exactly
That call is flagged as a warning in IDEs and other tools, since calling underlying Hashtable methods can corrupt the Properties object. Also, having the method allows using it as part of an expression without needing two additional statements.
Would you consider reopening this?
* avoid warnings about calling type-unsafe methods on `Properties`
* allow using the result as an expression
Ok.  Hello, I was reading through the set of tests at https://github.com/google/guava/blob/master/guava-tests/test/com/google/common/base/StopwatchTest.java , and I noticed there are two tests that appear to do the same thing - testElapsed_millis() and testElapsedMillis(). Is this expected? Could one test perhaps be an old test under a different naming convention? From the history it looks like they were added independently.
The contribution guide recommends creating an issue as the first step, so I thought I would ask.
GitHub suggests that both functions are only called from guava-gwt/test/com/google/common/base/StopwatchTest_gwt.java . Would it be appropriate to create a pull request to remove one of the tests? (Or of course, feel free to simply remove one yourself if the workflow is easier; I just wanted to ask)
Cheers!
@kluever Hey, fantastic! :) Thanks for the fast reply. Wasn't trying to assign any blame; just asking questions ;)
Thanks very much!
@kluever Hello again,
Thanks very much for the fixes :)
Reading through the tests it seems like there might still be some possible duplication - `testStop_new()` and `testStop_alreadyStopped()` seem to be doing mostly the same thing. Would you be interested in a pull request to combine those two tests? I can create a new issue for that if you prefer.
I also noticed that the `StopwatchTest` class starts with
```
private final Stopwatch stopwatch = new Stopwatch(ticker);
```
, but according to the `Stopwatch` class docs, the `Stopwatch()` style constructors are deprecated. Should the `StopwatchTest` class be using the `createUnstarted()` interface to create its private variables instead?
Lastly, some tests - such as `testElapsed_multipleSegments()` - have multiple uses of numbers where they check things like "9 + 25 should equal 34". Would it be appropriate/would you be interested in a pull request to use some variables for those, to make sure that matching numbers will always be the same?
e.g. rather than
```
ticker.advance(9);
..
ticker.advance(25);
..
assertEquals(34, stopwatch.elapsed(NANOSECONDS));
```
something like
```
long firstAdvance = 9;
long secondAdvance = 25;
assertEquals(firstAdvance + secondAdvance, stopwatch.elapsed(NANOSECONDS));
```
Would that improve maintainability? Or just make it more unreadable? I tried to find a preference in the [Google Java Style doc](https://google-styleguide.googlecode.com/svn/trunk/javaguide.html) but perhaps I'm missing something.
Thanks for your time, let me know if you have thoughts.
Aha! Thanks for the fast reply. I had assumed that your commit of 08a3fbf meant that https://github.com/google/guava/blob/master/guava-tests/test/com/google/common/base/StopwatchTest.java was back to being HEAD revision code. If you've already sorted out `testStop_new()` and `testStop_alreadyStopped()` then awesome.
Thanks!
Why can't I do that myself wrapping my ideas over `ClassPath.from(...).getResources()`, by iterating and checking the URL? Because for a few `ResourceInfo` entries from the JDK, the `url()` method cannot be invoked without generating a `NullPointerException`. This starts to be a lot of undocumented features for my use case.
Would it be possible to specify a notion of "exactly the specified `ClassLoaders` or URLs" (like `jar:` and `file:` urls)? Then with filters and mapping, it's rather trivial for us to extract whatever resource we really want. To be honest, what I'd really want is a modern and efficient `ResourceFinder`.
After the initial tests that I mention in the first sentence of the OP, I totally understand the scope of `ClassPath` and I totally agree with the concept. That's why I don't request an extension of it, but rather a complement to it which focuses on resources in general instead of classes in particular.
`ResourceInfo.getName()` doesn't say in which "context" the resource is. I'd have hoped to filter the resources by checking `ResourceInfo.url()` to filter only the one that I wanted, but as I mentioned, several resources on the JDK throw `NullPointerException`; I can filter them out too, that's not a big deal, but it starts to be a completely other framework on the base of that class. This is why I requested that this "framework" is integrated in Guava, with the functionalities similar to `ResourceFinder`.
Of course, I can do the loops and find exactly what I need. This is not about that: I'm already doing something like that at the moment. This request is to have a well thought API to easily access ressources from `ClassLoaders` or URLs, without the above-mentioned issues that are now present in `ClassPath` regarding resources.
Well, technically, I was playing around with `ClassPath.getResources()` to understand its full scope and how its result could help me in order to remove my dependency to [`Apache xbean-finder`](http://tomee.apache.org/dev/xbean-finder.html) (if you don't know what `ResourceFinder` is, you should really check this page). I first checked `ResourceInfo.getName()` which gives me the name relative to the jar or the class path. Ok. But I had duplicates (because of the parent classpath). So I tried printing the result of `ResourceInfo.url()` to find which jar I was using then a `NullPointerException` happened. I filtered those `NullPointerException` out and started to have something correct, but I had to play with strings a lot instead of a simple `ClassLoader` in order to find my own resources.
This is where `ResourceFinder` helps a lot. It does all that but... in a kind of bad way: the API is clearly suboptimal and barely understandable and the documentation is spread all over the web (the best I could see was [this stackoverflow answer](http://stackoverflow.com/a/7237152/180719) and there are functionality that miss like resource-pattern matching or filtering (though Java 8 helps a lot now). Also, there is that "functionality" that itches which is that a resource holder is removed if it cannot read something once in it.
My conclusion is that `ClassPath.getResources()` is a work in progress and can be made much more efficient if it were decoupled from `ClassPath` into its own API which could be extended in some formidable way.
I was playing with `ClassLoader.getResources()` and I expected more of it. The main issue is NOT that exceptions are thrown, but rather that `ClassLoader.getResources()` is too focused on the whole classpath (workarounds exist as you mentioned). I expected it to be similar to Apache's `ResourceFinder` or at least to enable me to go in that direction, I was wrong.
Why did I check that method? Because ResourceFinder is useful but has a bad API and has lots of issues in its implementation and I'm therefore looking for an alternative.
In that regard, the current `ClassPath.getResources()` is only a step in that  direction.
- providing a better java.util.ServiceLoader
- providing list of ResourceBundles
- getting rid of resource descriptors (files that only list the available resources)
- searching for resources rather than finding them
- unifying a filesystem and jar file in a single API for resources
Ok, here are some examples I want to show based on my own implementation (not yet completely functional, but it's a work in progress).
``` java
ResourceLocator assetsLocator = new ResourceLocator.Builder()
.root("/") // All the lookups will prepend this (so, it's possible to use subfolders as default).
.classLoader(getClass().getClassLoader()) // Search in *this* classloader first for exact names
.addJar(Paths.get("/location/to/assets.jar")) // Add a jar to search into
.addJars("/location/to/plugins/*.jar") // Allows the usage of wildcards to grab all the files at once.
.build();
// Just locate one resource, the first that is found.
Optional<URL> img1 = assetsLocator.locateResource("/img/img1.png");
ImmutableSet<URL> messages = assetsLocator.locateResources("/i18n/*/Messages.properties");
// Locate the /META-INF/MANIFEST.MF of each .jar files.
ImmutableSet<URL> manifests = assetsLocator.locateResources("/META-INF/MANIFEST.MF"); // Will look in all the selected jars to find them.
ImmutableSet<URL> whatever = assetsLocator.locateResources(/* use a Guava or Java 8 Predicate<String> here, the name should be given to the predicate, not the complete URL. */);
// Replace the annoying java.util.ServiceLoader so that we don't instanciate the services.
// It is not possible with ClassPath if the jar file is not yet loaded.
ImmutableSet<Class<? extends Plugin>> pluginClasses = assetsLocator.locateImplementations(Plugin.class);
// Not only allow to locate but also to load resources. ResourceLoader should be an interface with a few "by default" implementations.
Optional<Properties> myProperties = assetsLocator.loadResource("/myProperties.properties", PropertiesLoader.utf8Loader());
```
Note: the wildcard matching should be the same as [`FileSystem.getPathMatcher(String)`](http://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getPathMatcher-java.lang.String-).
Well, it's because my application is an extensible server. The user can download and add plugins dynamically from the network at runtime. At launch, I don't know the plugin names (so they are not in the classpath) and I need to perform several lookups, one for each "pluggable" component. Such a tool would allow that rather easily. Think of this use case as an improved `java.util.ServiceLoader` because it doesn't need to be in the classpath yet, it doesn't instanciate (yeah for Guice) and it doesn't lose time looking where the developer knows it doesn't need to look into.
Finally, I have to admit that I have a small grudge about `ClassLoader.getResources()` because it still returns an `Enumeration`, but that's all accessory ;)
As Ben suggested, if you know the URLs that your resources might come from,
one option is to make a throw-away URLClassLoader with those URLs (and a
null parent). You could feed that to ClassPath or (if you know the resource
names) use ClassLoader.getResources() directly on it. I think it would be
easier, for me at least, to understand your use case if you could explain
the ways in which this would fall short for it.
2015-04-21 2:38 GMT-07:00 Olivier Grgoire notifications@github.com:
> Why aren't all the jars in the classloader in the first place?
>
> Well, it's because my application is an extensible server. The user can
> download and add plugins dynamically from the network at runtime. At
> launch, I don't know the plugin names (so they are not in the classpath)
> and I need to perform several lookups, one for each "pluggable" component.
> Such a tool would allow that rather easily. Think of this use case as an
> improved java.util.ServiceLoader because it doesn't need to be in the
> classpath yet, it doesn't instanciate (yeah for Guice) and it doesn't lose
> time looking where the developer knows it doesn't need to look into.
>
> Finally, I have to admit that I have a small grudge about
> ClassLoader.getResources() because it still returns an Enumeration, but
> that's all accessory ;)
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2038#issuecomment-94721790.
After more tests, it wouldn't fall short (bar the NullPointerException that I cannot explain).
Why does `ClassPath` exist in the first place (before it had the `getResources()` method)? To ease getting classes from a package.
The use case here is the same, but generalized to all types of resources located in a specific set of containers (directories and jars) loaded on the fly; to ease the access to those resources by matching their name and returning their URL. One could think of it like a read-only FileSystem, but for resources where names matter for search but where only the URL are unique.
The cherry on the top would be the possibility to have wildcards to match names (just like `FileSystem.getPathMatcher()`) and maybe a transformer to facilitate transforming the resources into usable objects using a `ByteProcessor` or an interface similar to `ResourceLoader<T> { T load(ByteSource); }`.
I re-created a basic implementation (because at work, we have our own non-free proprietary implementation) of what I'd expect here: https://github.com/ogregoire/fror-common/tree/master/src/main/java/be/fror/common/resource
This one uses Java 8, and the ClassPath class (because I didn't want to lose too much time rewriting my own resource scanner). I also added a basic glob implementation. When I had the idea of returning a `Stream`, I got rid of the `ResourceLoader` since mapping could easily be done from a `Stream`. The `NullPointerException` issue is taken care of.
The implementation will probably change over time as I improve it, but you have the basic idea.
I've updated the class to show a basic implementation of how this class can replace ServiceLoader. The test is currently working but I have a lot of issues with the `ClassLoader` management.
Also, I reintroduced the `ResourceLoader` to handle the `IOException` properly without being a real hassle for the user.
Since this, 2 years ago, I found [Reflections](https://github.com/ronmamo/reflections) which does all this extremely well, though its API is really lacking the good guidance you guys have been consistently offering. If you're looking for a way to close this issue, I believe Reflections is the answer.  Uncorrect hashCode() implementation at com.google.common.base.Absent and com.google.common.base.Present - for example if hashCode() of reference at Present return 0 then it hashCode() equal Absent.
example: Optional.absent() has same hash code as Optional.of(0.0) or Optional.of(0)
Some tests in `LongMathTest` test about nothing as they use `ALL_INTEGER_CANDIDATES`. For example, `expectedSuccess` in `testCheckedAdd` is always true.
In some cases, I know that there will be at most one value for some key in a multimap, and it is pretty annoying to get the value out by the iterator and then check hasNext() and get by next(), especially if the multimaps are nested in each other.
could we wrap it and provide a method on Multimap
public Optional<V> getFirstValue(K key);
Just return the first Value by Iterator or Absent.
Similar to XMLNode.getFirstChild()
Currently, `FluentIterable.from` is not variant in its `E` parameter. I present my use case for `from` being covariant in its type parameter:
```
Map<String, ListenableFuture<String>> futures;
ListenableFuture<?> otherFuture1;
ListenableFuture<Object> otherFuture2;
// won't compile
Iterable<ListenableFuture<?>> allActiveFutures = FluentIterable.from(futures.values())
.append(otherFuture1)
.append(otherFuture2)
.filter(Predicates.not(Predicates.isNull()));
// wait for all fs to finish
```
I would like to be able to declare `FluentIterable.<ListenableFuture<?>>from(futures.values())`, but that's not currently possible. Instead, I have to do this:
```
FluentIterable.from(Collections.<ListenableFuture<?>>unmodifiableCollection(futures.values()))
```
As a side point, `Iterables.unmodifiableIterable` is not covariant either, whereas `Collections.unmodifiableCollection` is...
`Range` implements it, so it would be natural if `RangeSet` also does.
Apache Commons IO had a FileMonitor; that was based on polling files from a background thread.  I just published something similar, but mine is based on the modern Java 7 JDK's WatchService instead, see http://blog2.vorburger.ch/2015/04/java-7-watchservice-based.html; DirectoryWatcher etc. src currently part of https://github.com/vorburger/HoTea - if this is of any interest, do let me know here; no offense taken either if you close this as N/A.
@ronshapiro @cgdecker I'm still alive and if there's any interest for this, would be willing to raise a PR proposing to contribute a starting point for such a thing based on (above) from what I had done in https://github.com/vorburger/HoTea/tree/master/ch.vorburger.hotea/src/main/java/ch/vorburger/hotea/watchdir - I'm sure it would deserve to be torn apart, but could be starting point to kick this off.  Because Guava's collection classes (e.g. `ImmutableList`) do not override `spliterator()` they inherit the default implementation which has a characteristics of `SIZED` and `SUBSIZED`. This means that they cannot be used for parallel processing with ForkJoin.
Expected behavior: `Immutable*` should provide a more efficient `spliterator()` implementation.
I found posts going back 1-2 years talking about adding Java8 support in the near future: http://www.reddit.com/r/java/comments/1y9e6t/ama_were_the_google_team_behind_guava_dagger/cfjd2qi and https://groups.google.com/forum/#!topic/guava-discuss/fEdrMyNa8tA
Is there an open issue tracking this work?
Is there a short-term workaround I can use in the meantime?
> The primary issue is Google internal?
I don't understand the question.
> As it stands, for essentially all immutable collections, a good implementation is
>
> IntStream.range(0, collection.size()).mapToObj(collection.asList()::get)
This won't do because `spliterator().characteristics()` will return `ORDERED | SIZED | SUBSIZED`. It is missing `IMMUTABLE`.
> The Google internal Comment was a statement, not a question.
Agreed. I thought that this was being used for parallelization but it looks like it is not. So for now I don't have a concrete use-case for this characteristic.
> That should still be an adequate substitute for most use cases I can think of...
Okay, but it is worth noting that the only characteristic it adds over the default is `ORDERED`. That said, it is useful for clients that wishs to jump to the end of a list: http://stackoverflow.com/a/29553490/14731.
`Iterables.transform` and `Iterators.transform` are declared like so:
```
public static <F, T> Iterator<T> transform(Iterator<F> fromIterator, Function<? super F, ? extends T> function);
public static <F, T> Iterable<T> transform(Iterable<F> fromIterable, Function<? super F, ? extends T> function);
```
`Suppliers.compose` is declared like so:
```
public static <F, T> Supplier<T> compose(Function<? super F, T> function, Supplier<F> supplier);
```
These 3 methods are conceptually doing the same thing - taking values out of a 'producer' object (iterator/iterable/supplier) and lazily transforming them using a function. So they should all look the same, and in particular, have arguments in the same order.
To make them consistent, I suggest that `Suppliers.compose` is deprecated in favour of the following method:
```
public static <F, T> Supplier<T> transform(Supplier<F> supplier, Function<? super F, ? extends T> function);
```
- Transformation is a mapping from A  B to F&lt;A&gt;  F&lt;B&gt;, where F is a functor (e.g. Iterable, List, Iterator).
- Composition is the result of combining A  B and B  C (which gives A  C).
However, Supplier&lt;A&gt; can be treated as both a function of type ()  A and a functor. This means that:
- Suppliers.compose should definitely not be deprecated, because Supplier is a function.
- Suppliers.transform would make sense.
Sometimes it is necessary to replace line endings in some text with platform line endings. One way to do it is to call CharSource.readLines() and then pass the returned list to CharSink.writeLines(). While this   solves the problem, this is not very efficient, because it allocates an intermediate ImmutableList which can be huge.
It would be nice to have a method CharSource.writeLinesTo(CharSink), which does the same job without allocating an intermediate list.
Hi, decided it will be nice to have an Optional version to the get methods of Iterables.
Also as suggested here https://github.com/google/guava/issues/1742 but with a minor difference:
Both methods will return Optional.absent if the position is grater then the requested index and will also return Optional.absent if the value in the requested index is null.
thoughts ?
I signed it.
Sure you could do
Optional.fromNullable(Iterables.get(iterable, index, null));
```
optionalGet(list , 4, myDeafultValue)
```
But it reduces readability when all you need is
optionalGet(list , 4)
```
Debugging a code with this line
Optional.fromNullable(Iterables.get(iterable, index, null));
```
Will make you enter `iterables.get` implementation to understand the null value.
:thumbsup: I agree with gotenxds.
Request for Longs.toByteArray and Ints.toByteArray (maybe others?) to add overload accepting a byte[] argument to avoid the new byte[8] allocation.
Ah yep, thanks!
On Mon, Apr 6, 2015 at 9:20 AM, Colin Decker notifications@github.com
wrote:
> Agreed, this is what ByteBuffer.putLong(long) is for.
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/2023#issuecomment-90129591.
the javadoc for ExplicitOrdering says it will throw a ClassCastException if any elements are not in the explicit list defined for the ordering.  However, this depends on the comparator actually getting called.  In the case of sorting a list with a single item that is not present in the explict ordering list, an exception is not thrown because the underlying call to Arrays.sort will not call the comparator for a 1 item array.
Maybe is intential.
I have that:
``` java
Properties properties = new Properties();
properties.put( "key" , null );
// I know its impossible. It should show the problem
// Im not sure why?
...
Map propertiesMap = Maps.fromProperties( properties );
```
Actual impl:
``` java
@GwtIncompatible("java.util.Properties")
public static ImmutableMap<String, String> fromProperties,    Properties properties) {
ImmutableMap.Builder<String, String> builder = ImmutableMap.builder();
for (Enumeration<?> e = properties.propertyNames(); e.hasMoreElements();) {
String key = (String) e.nextElement();
builder.put(key, properties.getProperty(key));
}
return builder.build();
}
```
The `properties.propertyNames()` is the problem. It throws a NPE.
The `properties.stringPropertyNames()` would be return a empty keySet().
I suggest adding (possibly infinite) generators to the Iterators class. The idea is to have an Iterator presenting a possibly infinite sequence of values, generated on the fly a generator function so you don't have to keep all of that in memory at once.
Two use cases are provided as unit tests:
a) some kind of endless computation
b) iterating over possibly infinite input.
I've signed it now.
On Wed, Apr 1, 2015 at 12:27 AM, googlebot notifications@github.com wrote:
> Thanks for your pull request.
>
> It looks like this may be your first contribution to a Google open source
> project, in which case you'll need to sign a Contributor License Agreement
> (CLA) at https://cla.developers.google.com/.
>
> If you've already signed a CLA, it's possible we don't have your GitHub
> username or you're using a different email address. Check the information
> on your CLA https://cla.developers.google.com/clas or see this help
> article on setting the email on your git commits
> https://help.github.com/articles/setting-your-email-in-git/.
>
> Once you've done that, please reply here to let us know. If you signed the
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/pull/2020#issuecomment-88271134.
Found it, at last. There was a wrong email address in the commits. I
authored everything myself.
On Wed, Apr 1, 2015 at 12:30 AM, googlebot notifications@github.com wrote:
> We found a Contributor License Agreement for you (the sender of this pull
> request), but were unable to find agreements for the commit author(s). If
> you authored these, maybe you used a different email address in the git
> commits than was used to sign the CLA (login here
> https://cla.developers.google.com/ to double check)? If these were
> authored by someone else, then they will need to sign a CLA as well, and
> confirm that they're okay with these being contributed to Google.
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/pull/2020#issuecomment-88271614.
Guice depends on Cache, RemovalListener, RemovalNotification, etc....
@sameb I think this can be closed, as it was done already in https://github.com/google/guava/commit/f79d64fa7dd2adc19e29cbef6cd98ad106d1692a
The project [memory-measurer](https://code.google.com/p/memory-measurer) was removed. Guava's documentation link [Footprint of JDK/Guava data structures](https://code.google.com/p/memory-measurer/wiki/ElementCostInDataStructures) is 403 (Forbidden).
I wanted to verify my [analysis](https://github.com/ben-manes/caffeine/wiki/Memory-overhead) using [jamm](https://github.com/jbellis/jamm). Using OpenJDK's [Java Object Layout](http://openjdk.java.net/projects/code-tools/jol/) will be the best, but due to its immaturity it isn't as easy to quickly script.
There's a broken link to this page in the sidebar still.
Sorry, "the sidebar" isn't very helpful, is it?  At the bottom of the [_Wiki_ sidebar](https://github.com/google/guava/wiki) there's a link titled "Footprint of JDK/Guava data structures" that points to `http://code.google.com/p/memory-measurer/wiki/ElementCostInDataStructures`.
Please fix the `ImmutableSortedMultiset::naturalOrder` generic type so that classes that are subclasses of classes implementing `Comparable` can be used.
Here is a snippet showing the issue:
```
public class ImmutableSortedCollectionsComparison {
public static void main(String[] args) {
ImmutableSortedSet     <MySubComparable> sortedSet      = ImmutableSortedSet     .<MySubComparable>naturalOrder().build();
ImmutableSortedMultiset<MySubComparable> sortedMultiset = ImmutableSortedMultiset.<MySubComparable>naturalOrder().build();
}
}
class MyComparable implements Comparable<MyComparable> {
@Override public int compareTo(MyComparable o) { return 1; }
}
class MySubComparable extends MyComparable { }
```
The line of the `ImmutableSortedSet` will compile nicely, but the one of the `ImmutableSortedMultiset` won't.
Here's the faulty signature of `ImmutableSortedMultiset::naturalOrder`:
```
public static <E extends Comparable<E>> ImmutableSortedMultiset.Builder<E> naturalOrder()
```
And here is the expected signature:
```
public static <E extends Comparable<?>> ImmutableSortedMultiset.Builder<E> naturalOrder()
```
Which will then be similar to the working `ImmutableSortedSet::naturalOrder`:
```
public static <E extends Comparable<?>> ImmutableSortedSet.Builder<E> naturalOrder()
```
Add a method that transforms a list of functions to a function which returns a list:
``` java
public static <I, A> Function<I, List<A>> allAsList(Iterable<Function<I, A>> list)
```
Alternative way to get AssertionError instance in com.google.common.util.concurrent.GeneratedMonitorTest, since
public AssertionError(String message, Throwable cause)
does not exist in Java 6 yet.
I thought I have signed the cla, but only after I created the pull request.
Is that the reason, or do I need to sign a different one?
There exists a null `OutputStream` with `ByteStreams.nullOutputStream()`. It would be nice to have the counterpart `ByteStreams.nullByteSink()` that has methods that would specifically not do anything.
The use case I have is the following:
I have files for which I want to compute the `HashCode` and only that. So I'm using this code:
```
try (HashingInputStream in = new HashingInputStream(Hashing.sha1(), Files.newInputStream(path))) {
while (in.read() >= 0) { /* do nothing */ }
return in.hash();
}
```
Ideally I want to read those bytes but not doing anything. This code is great, does it as expected, but it is not really understandable at first glance that I'm actually skipping all of those. I checked some alternatives, like `ByteStreams.copy(in, ByteStreams.nullOutputStream())` or `ByteStreams.read(in, NullByteProcessor.INSTANCE)`, with `NullByteProcessor` doing what you think it does, but those always call several methods. So, how to wrap that null read properly?
I saw that `ByteSink.writeFrom(InputStream)` exists and I thought that maybe a `NullByteSink.writeFrom(InputStream)` is the exact proper way to wrap the `while (in.read() >= 0) { /* do nothing */ }` loop.
If it were implemented, I don't really know where I'd put that NullByteSink: in `ByteStreams.nullByteSink()`? In `ByteSink.nullByteSink()`? Your call ;)
No, I had not seen that. And it will be absolutely perfect for me, thanks!
However, that's a bit something I find awful with Guava. All the functionalities are available, but are nowhere to be found. For instance, I'm using paths using Java 7-8 nio, so I'm naturally drawn to use something common between those API and what I know of Guava, the streams. Once I have the streams, well I couldn't find any solution. I had checked both [HashingExplained](https://code.google.com/p/guava-libraries/wiki/HashingExplained) and the [`c.g.c.hash package`](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/hash/package-summary.html) and none of those ever mentioned [`Files.hash(File, HashFunction)`](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/io/Files.html#hash%28java.io.File,%20com.google.common.hash.HashFunction%29) Of course, going the good old "File" way solves this, but I kind of try avoid using files ever since I use Java 7, like a lot of people, to be honest, as I can see on StackOverflow.
I have the answer to my use case yet I leave the ticket open, so if you think about nice other use cases of the null `ByteSink`, just keep it open.
@kluever No need to apologize. Guava is extremely well done and thought. Indeed the documentation is sometimes a bit lacking, but there's nothing to apologize for. ;)
It would be very useful if testlib supported Java 8 collections. This might be done with an extension module or, where possible, reflective invocations. For example Map's compute and merge functions.
From time to time I have to traverse tree-based data structures where starting point are multiple root nodes  e.g. traversing files with TreeTraverser.breadthFirstTraversal(dir1, dir2, dir3) with one single call.
One could sometimes create a single virtual root node and skip this node but it feels like a work-around.
I am not quite sure what is your use case, and how to reproduce the issue.
Would you please put the problem in plain English with an example?
Let's say you have a tree-based data structure like UI components where each component can be a container of children components.
My use case would be to travers several independent trees uniformly
`List<UIComponent> uiComponents = Lists.newArrayList(page1, page3, page5);`
e.g. in breadth first traversal
```
Optional<UICompontent> greenButton =
treeTraverser.breadthFirstTraversal(uiComponents)
.firstMatch(greenButtonPredicate)
```
or like my directory traversal example
`Iterable<File> logFiles = fileTraverser.breadthFirstTraversal(apacheLogDir, mysqlLogDir, ...);`
I hope this use case is clear now and not pure invention. Is there a better approach I overlooked?
Right. It is a better overview but where exactly the problem strikes? When that odd thing happens? Thanks.
Current TreeTraverser methods breadthFirstTraversal(T), postOrderTraversal(T) and preOrderTraversal(T) require a **single** root node.
I need something like breadthFirstTraversal(Iterable<T> roots), postOrderTraversal(Iterable<T> roots) or preOrderTraversal(Iterable<T> roots).
The concat(...) approach provided expects order for pre-order iteration.
```
Traverser t = Traverser.forTree(n -> yourChildrenMethod(n));
Iterable nodeList = Iterables.concat(
t.depthFirstPreOrder(page1),
t.depthFirstPreOrder(page3),
t.depthFirstPreOrder(page5));
```
Given breadthFirst(...) example would iterate as follows:
but requested order should be:
1. page1, page3 and page5
2. 1st level of page1, 1st level of page3 and 1st level of page5
3. 2nd level of page1, 2nd level of page3 and 2nd level of page5
4. and so on
Please reopen this issue again.  I ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.
(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)
Here's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0
To clarify a bit:
`public static <T> Iterator<T> concat(
final Iterator<? extends Iterator<? extends T>> inputs)`
_is_ gc friendly if and only if the given iterator is gc friendly.
The other `concat` methods are backed by `ImmutableList.iterator()` which doesn't allow `concat` to be gc friendly.
That's not a bad idea for this specific example's use case... this example's use case was a bit simplified though to try and clearly isolate and illustrate the `concat` issue.
But the larger issue still stands: the helper `concat` methods aren't gc friendly.
I should have specified this in the initial comment: the guava concat runs out of heap space, whereas my suggested modification does not.
I've added an example that more clearly isolates the gc unfriendliness of `concat`.
To easily visually compare elapsed times with different orders of magnitude, please overload the method `Stopwatch::toString()` with `Stopwatch::toString(TimeUnit)` (or something similar) where we can then pass a specific `TimeUnit` which allows us to see actual differences.
The current implementation is very nice to see how much time a portion of code took to execute, but if we want to compare, it'd be nice to normalize the TimeUnit.
My use case is the following: I have a hundred time measures and I often have orders of magnitude of difference between those:
```
A took 12.34 ms
B took 23.45 s
C took 34.56 ms
```
And then we're ask ourselves "oh wait, was B "ms" or "s" ?" And we gotta check again. Oh, so B was (roughly) 500 times faster than A.
If I always select the same `TimeUnit` (milliseconds in this case), I can have this:
```
A took 12.34 ms
B took 0.023 ms
C took 34.56 ms
```
Then it's really clear that B took a fraction of time of what A used.
A comment in Guava's code for `toString()` also mentions `Too bad this functionality is not exposed as a regular method call`. Which seems to mean that someone else also kind of needed a similar behavior.
I see the point, and if we start to add the precision and the RoundingMode as parameter, it starts to be a lot of parameters. Well the idea is here, I trust the team to find the best way to add this if this idea is retained.
Instead of implementing TreeTraverser.children(T) in anonymous classes each time a function that retrieves children from each node could be handy also.
What about this static method at TreeTraverser
``` java
static <T> TreeTraverser<T> fromFunction(final Function<? super T, ? extends Iterable<? extends T>> descendants) {
}
```
and a possible implementation as proposal.
``` java
/**
* @see Traversers#fromFunction(Function)
*/
static final class TreeTraverserFromFunction<T> extends TreeTraverser<T> {
private final Function<? super T, ? extends Iterable<? extends T>> descendants;
TreeTraverserFromFunction(final Function<? super T, ? extends Iterable<? extends T>> children) {
descendants = checkNotNull(children);
}
public Iterable<T> children(final T root) {
@SuppressWarnings("unchecked")
final Iterable<T> checkedIterable = (Iterable<T>) descendants.apply(root);
return checkedIterable;
}
public String toString() {
return "TreeTraverser.fromFunction(" + descendants + ")";
}
}
```
+1
I see this has been completed now (at least to some extent).
Does any more work need to be done on this (like doing a lambda version of `BinaryTreeTraverser`)? Or can this issue be closed now?
Yeah, we still need to do it for BinaryTreeTraverser too.
On Sat, Sep 24, 2016 at 11:43 AM, Jonathan Bluett-Duncan <
notifications@github.com> wrote:
> I see this has been completed now (at least to some extent).
>
> Does any more work need to be done on this (like doing a lambda version of
> BinaryTreeTraverser)? Or can this issue be closed now?
>
> 
> You are receiving this because you commented.
> Reply to this email directly, view it on GitHub
> https://github.com/google/guava/issues/2006#issuecomment-249380776, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/AA5Cl867VAMPT1_BRLFPAn9vfXNb73M3ks5qtW9UgaJpZM4DxV_S
> .
##
Kevin Bourrillion | Java Librarian | Google, Inc. | kevinb@google.com
https://code.google.com/p/guava-libraries/wiki/CachesExplained#Features
"So, for example, iterating through cache.entrySet() does not reset access time for the entries you retrieve."
should probably be
"So, for example, iterating through cache.asMap().entrySet() does not reset access time for the entries you retrieve."
should probably be
```
InternetDomainName.from("bucket.s3.amazonaws.com").topPrivateDomain()
```
```
InternetDomainName.from("a.b.c.com").topPrivateDomain()
```
works just fine
thanks! I'll close this then
@cpovirk Guava compiled with GWT 2.6.1 dependency cannot be used by gwt.-maven-plugin 2.7.0 Any idea when GWT 2.7.0 will be supported? Thank you
it works fine with a full compilation but not with dev mode and super dev mode ; I have this exception :
``` java
[INFO] com.google.gwt.dev.jjs.InternalCompilerException: Unexpected error during visit.
[INFO]  at com.google.gwt.dev.jjs.ast.JVisitor.translateException(JVisitor.java:111)
[INFO]  at com.google.gwt.dev.jjs.ast.JVisitor.accept(JVisitor.java:130)
[INFO]  at com.google.gwt.dev.jjs.ast.JVisitor.accept(JVisitor.java:122)
[INFO]  at com.google.gwt.dev.jjs.ast.JTransformer.transform(JTransformer.java:1056)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.transform(GenerateJavaScriptAST.java:2515)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.transformExpressionStatement(GenerateJavaScriptAST.java:695)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.transformExpressionStatement(GenerateJavaScriptAST.java:514)
[INFO]  at com.google.gwt.dev.jjs.ast.JTransformer$JRewriterVisitor.visit(JTransformer.java:730)
[INFO]  at com.google.gwt.dev.jjs.ast.JExpressionStatement.traverse(JExpressionStatement.java:41)
[INFO]  at com.google.gwt.dev.jjs.ast.JVisitor.accept(JVisitor.java:127)
[INFO]  at com.google.gwt.dev.jjs.ast.JVisitor.accept(JVisitor.java:122)
[INFO]  at com.google.gwt.dev.jjs.ast.JTransformer.transform(JTransformer.java:1056)
[INFO]  at com.google.gwt.dev.jjs.ast.JTransformer.transformIntoExcludingNulls(JTransformer.java:1076)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.transformBlock(GenerateJavaScriptAST.java:578)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.transformBlock(GenerateJavaScriptAST.java:514)
[INFO]  at com.google.gwt.dev.jjs.ast.JTransformer$JRewriterVisitor.visit(JTransformer.java:622)
[INFO]  at com.google.gwt.dev.jjs.ast.JBlock.traverse(JBlock.java:91)
[INFO]  at com.google.gwt.dev.jjs.ast.JVisitor.accept(JVisitor.java:127)
[INFO]  at com.google.gwt.dev.jjs.ast.JVisitor.accept(JVisitor.java:122)
[INFO]  at com.google.gwt.dev.jjs.ast.JTransformer.transform(JTransformer.java:1056)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.transform(GenerateJavaScriptAST.java:2523)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.transformMethodBody(GenerateJavaScriptAST.java:812)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.transformMethodBody(GenerateJavaScriptAST.java:514)
[INFO]  at com.google.gwt.dev.jjs.ast.JTransformer$JRewriterVisitor.visit(JTransformer.java:829)
[INFO]  at com.google.gwt.dev.jjs.ast.JMethodBody.traverse(JMethodBody.java:81)
[INFO]  at com.google.gwt.dev.jjs.ast.JVisitor.accept(JVisitor.java:127)
[INFO]  at com.google.gwt.dev.jjs.ast.JVisitor.accept(JVisitor.java:122)
[INFO]  at com.google.gwt.dev.jjs.ast.JTransformer.transform(JTransformer.java:1056)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.transformMethod(GenerateJavaScriptAST.java:787)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.generatePrototypeDefinitions(GenerateJavaScriptAST.java:2330)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.generateTypeSetup(GenerateJavaScriptAST.java:1833)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.transformDeclaredType(GenerateJavaScriptAST.java:641)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.transformDeclaredType(GenerateJavaScriptAST.java:514)
[INFO]  at com.google.gwt.dev.jjs.ast.JTransformer.transformClassType(JTransformer.java:95)
[INFO]  at com.google.gwt.dev.jjs.ast.JTransformer$JRewriterVisitor.visit(JTransformer.java:670)
[INFO]  at com.google.gwt.dev.jjs.ast.JClassType.traverse(JClassType.java:140)
[INFO]  at com.google.gwt.dev.jjs.ast.JVisitor.accept(JVisitor.java:127)
[INFO]  at com.google.gwt.dev.jjs.ast.JVisitor.accept(JVisitor.java:122)
[INFO]  at com.google.gwt.dev.jjs.ast.JTransformer.transform(JTransformer.java:1056)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.transformProgram(GenerateJavaScriptAST.java:1202)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.transformProgram(GenerateJavaScriptAST.java:514)
[INFO]  at com.google.gwt.dev.jjs.ast.JTransformer$JRewriterVisitor.visit(JTransformer.java:918)
[INFO]  at com.google.gwt.dev.jjs.ast.JProgram.traverse(JProgram.java:1252)
[INFO]  at com.google.gwt.dev.jjs.ast.JVisitor.accept(JVisitor.java:127)
[INFO]  at com.google.gwt.dev.jjs.ast.JVisitor.accept(JVisitor.java:122)
[INFO]  at com.google.gwt.dev.jjs.ast.JTransformer.transform(JTransformer.java:1056)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST.execImpl(GenerateJavaScriptAST.java:3014)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST.exec(GenerateJavaScriptAST.java:2795)
[INFO]  at com.google.gwt.dev.jjs.JavaToJavaScriptCompiler.compilePermutation(JavaToJavaScriptCompiler.java:378)
[INFO]  at com.google.gwt.dev.jjs.JavaToJavaScriptCompiler.compilePermutation(JavaToJavaScriptCompiler.java:272)
[INFO]  at com.google.gwt.dev.CompilePerms.compile(CompilePerms.java:198)
[INFO]  at com.google.gwt.dev.ThreadedPermutationWorkerFactory$ThreadedPermutationWorker.compile(ThreadedPermutationWorkerFactory.java:50)
[INFO]  at com.google.gwt.dev.PermutationWorkerFactory$Manager$WorkerThread.run(PermutationWorkerFactory.java:74)
[INFO]  at java.lang.Thread.run(Thread.java:745)
[INFO] Caused by: java.lang.NullPointerException
[INFO]  at com.google.gwt.dev.jjs.ast.JMethod.getQualifiedJsName(JMethod.java:118)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.createStaticReference(GenerateJavaScriptAST.java:1707)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.dispatchToStatic(GenerateJavaScriptAST.java:886)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.transformMethodCall(GenerateJavaScriptAST.java:874)
[INFO]  at com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST$GenerateJavaScriptTransformer.transformMethodCall(GenerateJavaScriptAST.java:514)
[INFO]  at com.google.gwt.dev.jjs.ast.JTransformer$JRewriterVisitor.visit(JTransformer.java:835)
[INFO]  at com.google.gwt.dev.jjs.ast.JMethodCall.traverse(JMethodCall.java:246)
[INFO]  at com.google.gwt.dev.jjs.ast.JVisitor.accept(JVisitor.java:127)
[INFO]  ... 52 more
[INFO]                [ERROR] at MapMaker.java(116): MapMaker$ExpiringComputingMap.setTimeout(new MapMaker$ExpiringComputingMap$1(this, key, value), LongLib.toInt(this.expirationMillis))
[INFO]                   com.google.gwt.dev.jjs.ast.JMethodCall
[INFO]                [ERROR] at MapMaker.java(116): MapMaker$ExpiringComputingMap.setTimeout(new MapMaker$ExpiringComputingMap$1(this, key, value), LongLib.toInt(this.expirationMillis))
[INFO]                   com.google.gwt.dev.jjs.ast.JExpressionStatement
[INFO]                [ERROR] at MapMaker.java(107): {
[INFO]   MapMaker$ExpiringComputingMap.setTimeout(new MapMaker$ExpiringComputingMap$1(this, key, value), LongLib.toInt(this.expirationMillis));
[INFO] }
[INFO]                   com.google.gwt.dev.jjs.ast.JBlock
[INFO]                [ERROR] at MapMaker.java(107): {
[INFO]   MapMaker$ExpiringComputingMap.setTimeout(new MapMaker$ExpiringComputingMap$1(this, key, value), LongLib.toInt(this.expirationMillis));
[INFO] }
[INFO]                   com.google.gwt.dev.jjs.ast.JMethodBody
[INFO]                [ERROR] at MapMaker.java(42): com.google.common.collect.MapMaker$ExpiringComputingMap (extends LinkedHashMap implements ConcurrentMap)
[INFO]                   com.google.gwt.dev.jjs.ast.JClassType
[INFO]                [ERROR] at Unknown(0): <JProgram>
[INFO]                   com.google.gwt.dev.jjs.ast.JProgram
[INFO]             [ERROR] Unrecoverable exception, shutting down
[INFO] com.google.gwt.core.ext.UnableToCompleteException: (see previous log entries)
[INFO]  at com.google.gwt.dev.javac.CompilationProblemReporter.logAndTranslateException(CompilationProblemReporter.java:106)
[INFO]  at com.google.gwt.dev.jjs.JavaToJavaScriptCompiler.compilePermutation(JavaToJavaScriptCompiler.java:459)
[INFO]  at com.google.gwt.dev.jjs.JavaToJavaScriptCompiler.compilePermutation(JavaToJavaScriptCompiler.java:272)
[INFO]  at com.google.gwt.dev.CompilePerms.compile(CompilePerms.java:198)
[INFO]  at com.google.gwt.dev.ThreadedPermutationWorkerFactory$ThreadedPermutationWorker.compile(ThreadedPermutationWorkerFactory.java:50)
[INFO]  at com.google.gwt.dev.PermutationWorkerFactory$Manager$WorkerThread.run(PermutationWorkerFactory.java:74)
[INFO]  at java.lang.Thread.run(Thread.java:745)
[INFO]             [ERROR] Not all permutation were compiled , completed (0/1)
```
Yes : https://github.com/gwtproject/gwt/issues/9259
About exception in my last comment, the error is caused by jsinteropmode. I have forgotten to drop this config. Last guava snapshot seems to be functionnal with gwt 2.8. When can we hope a release ?
Thanks
Are there any plans to release an RC? GWT 2.8 is just around the corner (RC2 was recently released), and due to a Guava dependency I'm unable to upgrade/test the new version at the moment (well, I'll give a try with a snapshot, but an RC or final release would be nicer).
If you are in Java 8, you could write this as
```
cache.asMap().getOrDefault(key, value.getFoo());
```
The only negative with that version is that it can't be lazy by accepting a `Supplier`.
In JDK8, the entrySet view supports additions which the previous version did not. The existing tests fails due because it assumes that all collection views either support additions or disallow it. An addition through the key or value views would not make sense, while the entry view easily supported. Due to the testlib feature set not being able to distinguish the different features that the views may support, this test is not forward compatible as is.
This was discovered when using testlib to validate the `Cache.asMap()` view which should provide similar semantics except serialization support. The following additions have to be added for JDK8, but it would be nice if the features could be specified for the applicable views to avoid disabling tests.
``` java
.suppressing(
// Suppressed due to entrySet() view supporting additions, while the keySet() and
// values() views do not. The Guava tests are unable to understand this rational.
CollectionAddTester.class.getMethod("testAdd_unsupportedNotPresent"),
CollectionAddAllTester.class.getMethod("testAddAll_unsupportedNonePresent"),
CollectionAddAllTester.class.getMethod("testAddAll_unsupportedSomePresent"))
```
Interesting, that commit suppresses those tests for `OpenJdk6MapTests`, whereas I copied from `TestsForMapsInJavaUtil` which does not. What is the rational for the duplication between the two and is the latter enabled?
It **can** support the add contract, but you're right that there is a bug! It should be delegating to `putIfAbsent()`, which is how I implemented it. It appears that there is a typo in OpenJDK which passes `false` to the internal put's `onlyIfAbsent` method. That bug exists in Doug's CVS repo so it should be reported.
Closing as it appears to be my mistake of borrowing from the wrong test class.
The two CacheLoader.from methods can be variant in their generic arguments like so:
```
public static <K, V> CacheLoader<K, V> from(Function<? super K, ? extends V> function);
public static <V> CacheLoader<Object, V> from(Supplier<? extends V> supplier);
```
I also think that `from(Supplier)` should take a `K` parameter, so it can be used for any variable taking a `CacheLoader<K, V>`:
```
public static <K, V> CacheLoader<K, V> from(Supplier<? extends V> supplier);
```
Created a CHANGELOG in the root directory. With proper formatting the app could also read from this file and view the changes within the app. Changelog should be updated with each pull accept. Also, as main developers release updates to the code other contributors will now be able to see the change in the changelog.
So first of all, this should be CHANGELIST.md.  Much more useful as a markdown file.
Second, I'm not sure this file adds much value, as a placeholder.  It doesn't include the massive back-fill of change log information, and doesn't provide much structure so it's not really a pull request so much as a documentation request (which is fair, but that's an issue, not a p/r)
Also, we have so much coming out from internal commits, and google's internal commits are usually unique, meaningful changes with a reasonable commit description, that it is nearly certain to be just as valuable to automatically crib the descriptions from the list of commits and use that as a first-draft log of changes.  Maintaining one manually and incrementally may be worth it, but I'm not convinced.
@cgdecker - any opinions?  I'm not sure what you had in mind for release changelogs.  My personal feeling is that we take the full list from the last release and trim it into a changelog.  I do like the idea of demonstrating the delta, the additional features/changes/etc.
Appreciate your detailed explanation. I do feel that a changelog that users can quickly skim to see new additions is important. Now as far as actual implementation obviously that does not matter as much to me as the actual active devs.
fyi, you should consider using [Github releases](https://github.com/blog/1547-release-your-software) instead of a changelog.
Wouldn't be useful to have collections that can fire events every time an element is added or removed? I can contribute code for generic collections and lists.
I wasn't aware of it. That library contains only observable lists, not collections too. But adding other observable collection types will make sense to be added there. So I will close the issue.
Currently, guava-testlib only tests collections using ZERO(0), ONE(1), and SEVERAL(3) collection sizes. I have a collection implementation that switches its internal representation at 10 elements. I would like to use testlib to test my collection around that switching point, but I can't at the moment.
You could include a LOTS or LARGE size that test up to (say) 100 elements. A lot of collections have got specific implementations for small-ish numbers, then once it gets to 100 elements most degenerate into a general implementation for any number of items.
Testing up to 100 would also test things like internal array resizes - ArrayList has got a default size of 10, HashMap a default size of 16, and the current code doesn't test the array resizes of those classes. And it wouldn't take too long to run as well, 100 is not that much in the grand scheme of things.
:(  Is it planned to add to Preconditions methods checkNotNull, checkState, checkArgument with 1 or 2 arguments for string template instead of using varargs only?
for example:
public static void checkState(boolean expression, String template, Object arg1) {
if(!expression) {
...
}
}
So new Object[] will be created only if expression is false but not each time method is called.
Cache objects currently do not have a method of introspecting on the current "weight" value.  I am replacing an implementation of a cache that is just a synchronized LinkedHashMap.  In my current implementation of the cache, I'm keeping track of the weights of things being stored and exposing that as a metric about my cache.  This is the _only_ feature of my current implementation that is not covered by Guava's Cache.
From looking at the code, it seemed relatively easy to just create another method parallel to `size()` to handle this case so I just went ahead and did it.  The guidelines do state that API changes should start as an issue, but I didn't realize that until I had already done this and it is such a simple fix, it doesn't bother me if it gets thrown away (as long as I do get some method of introspecting on the current weight value ;) ).
Also, I updated unit tests as I could find ones that seemed relevant, but I will admit that I didn't read and comprehend all tests, so I might've missed a good place to add some more verification of the weight computation.  Let me know if there are other tests to update and I'll be happy to.
If you think this is going to work, let me know and I'll make sure to get a CLA.
It seems to be failing when trying to generate the gwt source.  I'll see if I can repro the failure on my local machine and try to fix, but any pointers to what might cause the gwt compilation to fail would be helpful.
Ok, on my local machine, I cannot seem to download com.google.guava:guava:java-source:19.0-SNAPSHOT
Looks like it is not in sonatype-nexus-snapshots
So, it's failing, but for a different reason...  I guess I'll wait on fixing that until the discussion of whether this API change could even be considered has happened.
The predecessor, [ConcurrentLinkedHashMap](https://github.com/ben-manes/concurrentlinkedhashmap) introduced the concept of weights and provides a `weightedSize` method. That may be a simpler migration path. (Note: currently moving to Github due to Google Code shutdown)
The JDK8 rewrite, [Caffeine](https://github.com/ben-manes/caffeine), exposes additional inspection including the weighted size through the `Policy` abstraction. That project is maturing quickly but not yet released.
@ben-manes So, are you suggesting that instead of using a `Cache` in my code I use `ConcurrentLinkedHashMap`?
Can't really use something that isn't released yet :)
I'm offering it as an option as your changes may not be accepted and you would have to wait for the next release if they are. If all you need are the basic features of its predecessor, then its a reasonable option. The old wiki is in the Github wiki branch since the migration didn't move it over properly.
That would be nice, but it throws a `NullPointerException`. Below is the stack trace (using guava-18.0.jar).
```
Exception in thread "Main Thread" java.lang.NullPointerException
at com.google.common.base.Preconditions.checkNotNull(Preconditions.java:210)
at com.google.common.collect.NaturalOrdering.compare(NaturalOrdering.java:34)
at com.google.common.collect.NaturalOrdering.compare(NaturalOrdering.java:26)
at com.google.common.collect.ByFunctionOrdering.compare(ByFunctionOrdering.java:46)
at com.google.common.collect.NullsLastOrdering.compare(NullsLastOrdering.java:44)
at java.util.Arrays.mergeSort(Arrays.java:1270)
at java.util.Arrays.mergeSort(Arrays.java:1282)
at java.util.Arrays.sort(Arrays.java:1210)
at com.google.common.collect.Ordering.sortedCopy(Ordering.java:817)
```
using the following class
```
public class A  {
public static void main(String[] args) {
List<A> as = Lists.newArrayList();
as.add(new A("a"));
as.add(new A("e"));
as.add(new A("c"));
as.add(new A("a"));
as.add(new A("b"));
as.add(new A("f"));
as.add(new A("d"));
as.add(new A(null));
System.out.println(
Ordering
.natural()
.onResultOf(new Function<A,String>(){
public String apply(A a){
return a.a;
}
})
.nullsLast()
.sortedCopy(as));
}
A(String a) {
this.a = a;
}
private String a;
}
```
I git it to work.
Is this documented anywhere? Also, what is the logic in arranging it this way. In other cases the logic is the inverse. For instance, with regard to `natural` the `nullLast` that follows it does not throw exceptions, so why would it do that here. Is there some rule of thumb for this.
Thanks. I think I got it now.
When I import Guava in Eclipse using the m2e plugin, the test will be run using Oracle JDK 6. The error then matches the one listed above for "Oracle JDK7".
In this case, the `ResourceInfo` object contains two URLs, the first of which will be used by the test:
- `jar:file:/home/myusername/tools/jdk1.6.0_45/jre/lib/ext/sunpkcs11.jar!/META-INF/JCE_RSA.RSA`
- `jar:file:/home/myusername/tools/jdk1.6.0_45/jre/lib/ext/sunjce_provider.jar!/META-INF/JCE_RSA.RSA`
The system classloader, on the other hand, returns this URL:
- `jar:file:/home/myusername/tools/jdk1.6.0_45/jre/lib/jce.jar!/META-INF/JCE_RSA.RSA`
On the other hand, when I simply run the test using Maven 3.3.1 and Oracle JDK jdk1.8.0_40 on the command line and attach Eclipse as a debugger, the "Oracle JDK8" error listed above is reproduced.
The `urlsFromLoader` contains the following URLs:
- `jar:file:/home/myusername/tools/jdk1.8.0_60_b08/jre/lib/ext/jfxrt.jar!/META-INF/INDEX.LIST`
- `jar:file:/home/myusername/.m2/repository/org/easymock/easymock/3.0/easymock-3.0.jar!/META-INF/INDEX.LIST`
- `jar:file:/home/myusername/.m2/repository/org/objenesis/objenesis/1.2/objenesis-1.2.jar!/META-INF/INDEX.LIST`
While `urlsFromClassPath` only contains:
- `jar:file:/home/myusername/tools/jdk1.8.0_60_b08/jre/lib/ext/jfxrt.jar!/META-INF/INDEX.LIST`
Just making sure, is it documented somewhere whether for time based and size based eviction can be combined? Or are they mutual exclusive? So far, I haven't found anything saying whether it should be possible or not, but maybe I've just missed it?
Yes they can be combined. Unless stated in CacheBuilder, the features can be mixed together.
Great. Thanks!
Nah, that's probably enough.
JDK `Executors` provides several tool methods to create `ThreadPoolExecutor` and `ScheduledThreadPoolExecutor`. But these methods are not flexible. But if build up `ThreadPoolExecutor` and `ScheduledThreadPoolExecutor` from nothing, it will be a little complex.
Apache Camel has a `ThreadPoolBuilder` but it is complex since bind with `CamelContext`.
So I create a simple builder to create `ThreadPoolExecutor` and `ScheduledThreadPoolExecutor`.
ImmutableList contains following code since version 15.0
private static final ImmutableList<Object> EMPTY =
new RegularImmutableList<Object>(ObjectArrays.EMPTY_ARRAY);
Here is the minimal test case I could create. It hangs intermittently.
```
public static void main(String[] args) throws Exception {
new Thread() {
public void run() {
ImmutableList.of();
}
}.start();
Thread.sleep(1);
Class.forName("com.google.common.collect.RegularImmutableList");
}
```
The problem is not just theoretical - we've hit the real deadlock in a large production deployment.
The inherited doc should be overridden and mentioned that containsValue works in O(1) time in contrast to O(N) with a normal HashMap.
The javadoc for #inverse should mention that it always returns the same Inverse instance and thus saving the Inverse as a separate instance variable is not mandatory to reduce overhead.
Is this issue approved?  Thi is an updated version with the CLA email that updates the whole codebase with the eclipse formatter that Google provides.
Hi,
I have applied the eclipse formatter using the Google configuration for Java projects available at https://code.google.com/p/google-styleguide/source/browse/trunk/eclipse-java-google-style.xml
Is there another formatter configuration for this project?
Thanks!
Done :)
Perfect, thanks for recovering my text and answer my questions :)
Reverts (at least in part) a number of changes made to jdk5-backport-v17.0-post to make it more compatible with code built against jdk5-backport-v14.0.1-post, specifically AOSP code. The reverted changes added back methods that had been present in v14 (deprecated and not) and since been removed. The intent is to allow AOSP code that built against v14.0.1 to also build against the compatibility version of v17.0 without modification (or with minimal atomic modifications). That will make upgrading itself easier and will allow other changes such as removing usages of deprecated methods to be done in stages.
Reverts (at least in part) a number of changes made to jdk5-backport-v17.0-post to make it more compatible with code built against jdk5-backport-v14.0.1-post, specifically AOSP code. The reverted changes added back methods that had been present in v14 (deprecated and not) and since been removed. The intent is to allow AOSP code that built against v14.0.1 to also build against the compatibility version of v17.0 without modification (or with minimal atomic modifications). That will make upgrading itself easier and will allow other changes such as removing usages of deprecated methods to be done in stages.
The function returned by Functions.forMap is like a limited read-only map. So it should be able to accept more inputs.
This is similar to `java.util.Collections.unmodifiableMap`, which has the following signature:
`public static <K,V> Map<K,V> unmodifiableMap(Map<? extends K, ? extends V> m)`
For example, the following is only possible by wrapping the input map:
``` java
Map<Integer,String> map = ...;
Function<Number,CharSequence> f =
Functions.forMap(Collections.<Number,CharSequence>unmodifiableMap(map));
```
Fair enough, thanks for the reply.
...and assume the identify function.
Thanks. A default of identity seemed likely to be useful, but it's no big deal.
Our use case is:
- we have a Set<X>, a small number of which need to be remapped to some other value (whilst retaining the original X).
- we create a Map<X, X> using the identity function, then immediately override the values of the ones that need remapping.
Perhaps there are better ways of doing this anyway.
NP, thanks for the rapid response.
FWIW, I'm targeting Java 6, which can't infer the type parameters of Functions.identity(), and have to do the annoying dance of having to supply redundant parameters explicitly, which is probably what sparked my desire to sort this.
Any plans to take this out of beta?
Any news on this one? Thanks.
Would be keen to use these in non-`@Beta`. Are there any plans?
This is a feature request where the cost may far outweigh the benefit, and I understand that, but I ran into it and think it would be right in principle, if difficult in practice.
Iterator<Bar> deserialize(DatabaseConnection conn) {
return Iterators.transform(conn.fetch(), new Function<Foo, Bar>() {
@override public Bar apply(Foo foo) {
Bar.deserialize(foo);
}});
}
Context:
1) conn.fetch() returns an ImmutableList<Foo>
3) A Foo is smaller than a Bar, so you can keep ImmutableList<Foo> in memory, but you can't keep an ImmutableList<Foo> in memory while you operate on each Bar.
The result is that, instead, we copy the ImmutableList into an array and then create an Iterator that in each call to next() nulls out that slot in the array.
It would be awesome if ImmutableList's Iterator allowed earlier elements in the list to be garbage.
I don't know much about how ImmutableList is implemented.
In a naive singly linked list, I would expect the iterator to have this property. Would that be a reasonable expectation?
All I'm saying is:
1) this property is desirable
2) you could implement ImmutableList having this property
3) it would be nice for future changes to ImmutableList to made with 1 and 2 in mind.
Nope, and that's why we've created ForgetfulArrayIterator. I just thought you might want to know of a time I used a collection and it wasn't the best thing ever.
What collection class should I use for reading through things once?
Does Queue do that? It looks like Queue.iterator() doesn't remove elements from the queue, just lets you peek at them.
It sounds like you think mine isn't a popular use case (i.e., a Collection that lets you stream over immutable data once, letting what you have already seen be garbage). I wanted to offer the feedback that the implementation was doing something the interface didn't seem to require, leading to surprise on my part.
.toString() method returns  "InternetDomainName{name=**domainORtldORwhatever**}" Should not simply return the **domainORtldORwhatever**?
Example code:
System.out.println(owner.toString());
Print:
What I expect is:
I'm using:
<dependency>
<groupId>com.google.guava</groupId>
<version>18.0</version>
</dependency>
Thanks!
Yeah, deleted my comment when I realized Storm 0.9.2 was overriding with Guava 13. Pardon me.
I have the same problem , storm is overriding guava with a older version. Is there any solution to this problem? @chethan Is this Apache Storm, or another Storm? :)  This is not really a feature request, nor a bug report, but more of a request for comments.
I'm sure that everyone is well aware that using Guava on Android is challenging due to the size of the library. Resolving this problem by splitting up Guava into components is a massive endeavor, and something that the team may not be willing to do.
Given this, can we get clarification on the status of making Guava easier to use on Android? Is it considered a non-issue due to Proguard? Is it something being considered for future releases? If so, which release?
Thank you.
Any progress on this? I want to split classes in com.google.common.collect into categorized modules.
This plugin seems to be good for use with android gradle project. https://github.com/vRallev/jarjar-gradle
Thanks for letting me know!
jarjar will be integrated in new Jack and Jill tool chain. More info at: http://tools.android.com/tech-docs/jackandjill
For list processing, `Optional` and `Objects` Lightweight-Stream-API is good alternative.
It is tiny and has similar API to Java 8.
https://github.com/aNNiMON/Lightweight-Stream-API
I started [miniguava](https://github.com/ypresto/miniguava) project for smaller library size..!
If someone is new to guava, it'd be helpful to have more information in README.md. I tried to add some more information in README.md. Source I took information from: https://code.google.com/p/guava-libraries/
NullPointerTester already knows the concept of a ExceptionTypePolicy.
However, the field "policy" is always set to a default value.
This patch adds an option to overwrite the policy to
Hmm, Travis breaks because of an unrelated error:
testLargeNumberOfInsertions(com.google.common.hash.BloomFilterTest): Java heap space
Apparently _even more_ heap space is necessary. See this commit from yesterday: fa24bad4e4ca19c18294062da539cdc78837efa2.
@cgdecker Yes, that makes sense. To be able to depend on guava-testlib is fine, too.
 We are using `checkArgument(!Strings.isNullOrEmpty(xyz))` a lot, which is why this addition would be really great. I know it's called NullPointerTester and not PreconditionsTester or something, but if you have it internally, could you 'publish' it? :) Solid point. I agree kevinb9n. I guess this should be closed then?  Given that the main purpose of DeadEvent is logging/debugging, I think that this simple string representation could be useful.
When decoding Base64/32/16 data an exception is thrown if an invalid character is found:
BaseEncoding.java:501:
``` java
int decode(char ch) throws IOException {
throw new DecodingException("Unrecognized character: " + ch);
}
return decodabet[ch];
}
```
The exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.
Interesting topic. I've seen issues with `String.format` and the default locale several times in production code, most recently today. I think it's a problem worthy of Guava's help.
I would like this. Not as `Strings.format`, though. Although different, when skimming over code this can easily get unnoticed.
I couldn't find how a `natural()` [`Ordering`](http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Ordering.html) orders `null`s if not calling if `nullsFirst()`/`nullsLast()` is not called. https://code.google.com/p/guava-libraries/wiki/OrderingExplained didn't give me anything either.
Will the ordering thrown an NPE, or will it default to `nullsFirst()`? Should probably be documented.
Let me know if I've missed something.
Ah! Thank you for pointing out my blindness... ;)
Please see https://github.com/google/guava/blob/master/guava/src/com/google/common/primitives/Booleans.java#L235.
Isn't Java 6 available?
If it is, should that comment be removed?
Should the method be removed? (It is private and only used in a single place).
Thank you for your answer.
Can something like this be merged?
Glad I could help.
Maybe [this](https://github.com/google/guava/blob/master/guava/src/com/google/common/base/Strings.java#L76) is also of interest.
```
Tracing compile failure path for type 'com.google.common.collect.Maps'
[ERROR] Errors in 'jar:file:/Users/mg/Documents/Grails/GGTS3.6.3/buddyis-mobile/lib/guava-gwt-18.0.jar!/com/google/common/collect/super/com/google/common/collect/Maps.java'
[ERROR] Line 592: Type mismatch: cannot convert from Comparator<? super capture#175-of ? super K> to Comparator<? super K>
```
```
Jan 10, 2015 1:24:49 AM com.google.common.util.concurrent.ServiceManager <init>
WARNUNG: ServiceManager configured with no services.  Is your application configured properly?
com.google.common.util.concurrent.ServiceManager$EmptyServiceManagerWarning
at com.google.common.util.concurrent.ServiceManager.<init>(ServiceManager.java:194)
at com.google.common.util.concurrent.ServiceManagerTest.testEmptyServiceManager(ServiceManagerTest.java:346)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:606)
at junit.framework.TestCase.runTest(TestCase.java:168)
at junit.framework.TestCase.runBare(TestCase.java:134)
at junit.framework.TestResult$1.protect(TestResult.java:110)
at junit.framework.TestResult.runProtected(TestResult.java:128)
at junit.framework.TestResult.run(TestResult.java:113)
at junit.framework.TestCase.run(TestCase.java:124)
at junit.framework.TestSuite.runTest(TestSuite.java:243)
at junit.framework.TestSuite.run(TestSuite.java:238)
at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:83)
at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:35)
at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:115)
at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:97)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:606)
at org.apache.maven.surefire.booter.ProviderFactory$ClassLoaderProxy.invoke(ProviderFactory.java:103)
at com.sun.proxy.$Proxy0.invoke(Unknown Source)
at org.apache.maven.surefire.booter.SurefireStarter.invokeProvider(SurefireStarter.java:150)
at org.apache.maven.surefire.booter.SurefireStarter.runSuitesInProcess(SurefireStarter.java:91)
at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:69)
Jan 10, 2015 1:24:49 AM com.google.common.util.concurrent.ServiceManager$ServiceListener failed
SCHWERWIEGEND: Service  [FAILED] ha
Running com.google.common.util.concurrent.UncaughtExceptionHandlersTest
Jan 10, 2015 1:24:53 AM com.google.common.util.concurrent.UncaughtExceptionHandlers$Exiter uncaughtException
SCHWERWIEGEND: Caught an exception in Thread[Thread-779,5,main].  Shutting down.
java.lang.Exception
at com.google.common.util.concurrent.UncaughtExceptionHandlersTest.testExiter(UncaughtExceptionHandlersTest.java:42)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.009 sec
at java.lang.reflect.Method.invoke(Method.java:606)
at junit.framework.TestCase.runTest(TestCase.java:168)
at junit.framework.TestCase.runBare(TestCase.java:134)
at junit.framework.TestResult$1.protect(TestResult.java:110)
at junit.framework.TestResult.runProtected(TestResult.java:128)
at junit.framework.TestResult.run(TestResult.java:113)
at junit.framework.TestCase.run(TestCase.java:124)
at junit.framework.TestSuite.runTest(TestSuite.java:243)
at junit.framework.TestSuite.run(TestSuite.java:238)
at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:83)
at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:35)
at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:115)
at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:97)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:606)
at org.apache.maven.surefire.booter.ProviderFactory$ClassLoaderProxy.invoke(ProviderFactory.java:103)
at com.sun.proxy.$Proxy0.invoke(Unknown Source)
at org.apache.maven.surefire.booter.SurefireStarter.invokeProvider(SurefireStarter.java:150)
at org.apache.maven.surefire.booter.SurefireStarter.runSuitesInProcess(SurefireStarter.java:91)
at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:69)
Running com.google.common.util.concurrent.UninterruptibleMonitorTest
Tests run: 16, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.378 sec
Running com.google.common.util.concurrent.WrappingExecutorServiceTest
...
Tests run: 597008, Failures: 16, Errors: 0, Skipped: 0
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO]
[INFO] Guava: Google Core Libraries for Java ............. SUCCESS [16.834s]
[INFO] Guava Testing Library ............................. SUCCESS [25.873s]
[INFO] Guava GWT compatible libs ......................... SKIPPED
[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 6:20.103s
[INFO] Finished at: Sat Jan 10 01:24:53 CET 2015
[INFO] Final Memory: 47M/549M
[INFO] ------------------------------------------------------------------------
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.7.2:test (default-test) on project guava-tests: There are test failures.
[ERROR]
[ERROR] -> [Help 1]
[ERROR]
[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.
[ERROR] Re-run Maven using the -X switch to enable full debug logging.
[ERROR]
[ERROR] For more information about the errors and possible solutions, please read the following articles:
[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException
[ERROR]
[ERROR] After correcting the problems, you can resume the build with the command
[ERROR]   mvn <goals> -rf :guava-tests
```
Here it is:
```
Running com.google.common.base.StopwatchTest
Tests run: 20, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.011 sec <<< FAILURE!
```
Note that I compile with Java8.
```
Failed tests:
testToString(com.google.common.base.StopwatchTest): null expected:<0[.]000 ns> but was:<0[,]000 ns>
testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>
testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>
testSimpleAcquireReturnValues(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>
testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>
testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>
testWarmUpWithColdFactor(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.75, R1.26, R0.76, R0.30, R0.20, R0.20, R0.20, U0.20, U4.00, R0.00, R1.75, R1.26, R0.76, R0.30, R0.20, R0.20, R0.20, U0.20, U1.00, R0.00, R0.20, R0.20, R0.20, R0.20, R0.20, R0.20, R0.]20]> but was:<[R0[,00, R1,75, R1,26, R0,76, R0,30, R0,20, R0,20, R0,20, U0,20, U4,00, R0,00, R1,75, R1,26, R0,76, R0,30, R0,20, R0,20, R0,20, U0,20, U1,00, R0,00, R0,20, R0,20, R0,20, R0,20, R0,20, R0,20, R0,]20]>
testWarmUpWithColdFactor1(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.20, R0.20, R0.20, R0.20, R0.20, R0.20, U0.34, R0.00, R0.20, R0.20, R0.20, R0.20, R0.20, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,20, R0,20, R0,20, R0,20, R0,20, R0,20, U0,34, R0,00, R0,20, R0,20, R0,20, R0,20, R0,20, R0,20, R0,]20]>
testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>
testWarmUpAndUpdateWithColdFactor(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.75, R1.26, R0.76, R0.30, R0.20, R0.20, R0.20, U4.20, R0.00, R1.75, R1.26, R0.76, R0.20, R0.10, R0.10, R0.10, U4.10, R0.00, R0.94, R0.81, R0.69, R0.57, R0.44, R0.32, R0.20, R0.10, R0.10, R0.]10]> but was:<[R0[,00, R1,75, R1,26, R0,76, R0,30, R0,20, R0,20, R0,20, U4,20, R0,00, R1,75, R1,26, R0,76, R0,20, R0,10, R0,10, R0,10, U4,10, R0,00, R0,94, R0,81, R0,69, R0,57, R0,44, R0,32, R0,20, R0,10, R0,10, R0,]10]>
testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>
testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>
testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>
testInfinity_BustyTimeElapsed(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.00, R0.50, R0.]50]> but was:<[R0[,00, R0,00, R0,00, R0,50, R0,]50]>
testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>
testInfinity_WarmUpTimeElapsed(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,00, R1,]00]>
Tests run: 597008, Failures: 16, Errors: 0, Skipped: 0
```
Does this helps you?
I used the following in my gwt.xml file:
```
<inherits name="com.google.common.collect.Collect"/>
```
```
Tracing compile failure path for type 'com.google.common.collect.Collections2'
[ERROR] Errors in 'com/google/common/collect/Collections2.java'
[ERROR] Line 201: The method and(Predicate<capture#14-of ? super E>, Predicate<capture#15-of ?>) is undefined for the type Collections2.FilteredCollection<E>
[ERROR] Line 206: The method and(Predicate<capture#16-of ? super E>, Predicate<capture#17-of ?>) is undefined for the type Collections2.FilteredCollection<E>
Tracing compile failure path for type 'com.google.common.collect.Maps'
[ERROR] Errors in 'com/google/common/collect/super/com/google/common/collect/Maps.java'
[ERROR] Line 2244: The method and(Predicate<capture#263-of ? super Map.Entry<K,V>>, Predicate<capture#264-of ? super Map.Entry<K,V>>) is undefined for the type Predicates
[ERROR] Line 2343: The method and(Predicate<capture#265-of ? super Map.Entry<K,V>>, Predicate<capture#266-of ? super Map.Entry<K,V>>) is undefined for the type Predicates
Tracing compile failure path for type 'com.google.common.collect.Multimaps'
[ERROR] Errors in 'com/google/common/collect/super/com/google/common/collect/Multimaps.java'
[ERROR] Line 1691: The method and(Predicate<capture#83-of ? super K>, Predicate<capture#84-of ? super K>) is undefined for the type Predicates
[ERROR] Line 1954: The method and(Predicate<capture#105-of ? super Map.Entry<K,V>>, Predicate<capture#106-of ? super Map.Entry<K,V>>) is undefined for the type Predicates
[ERROR] Line 1735: The method and(Predicate<capture#87-of ? super K>, Predicate<capture#88-of ? super K>) is undefined for the type Predicates
[ERROR] Line 1779: The method and(Predicate<capture#91-of ? super K>, Predicate<capture#92-of ? super K>) is undefined for the type Predicates
[ERROR] Line 1940: The method and(Predicate<capture#103-of ? super Map.Entry<K,V>>, Predicate<capture#104-of ? super Map.Entry<K,V>>) is undefined for the type Predicates
[ERROR] Aborting compile due to errors in some input files
```
I created a sample project. You will find it here: https://github.com/confile/GuavaGWT-Java8-Test
I have no idea but you should keep the `-strict`.
Here is a demo project for this issue to be reproduced: https://github.com/confile/gwtGuavaTest2
I am using the latest GWT2.7SNAPSHOT with JAva8 Update15 on OSX.
Great thank you!
Here is a demo project for eclipse which reproduces this error:
https://github.com/confile/GWTQueryJava8Test
Great
Currently `FluentIterable<T>` has `#from(Itearble<T>)`
Quite often I need to have an instance of it from some collection like `Collection<? extends T>`
It could be nice to be able to pass such collection to `FluentIterable#from`
`public static <T> FluentIterable<T> from(Iterable<? extends T> foo)`
Similar constructions works for me in many cases
Yes. Thanks. I figured out I could change my code to use `? extends'  in many places. This works but makes java code a bit ugly
This is an easy to reproduce bug. Running the following code throws an exception.
``` java
String ff = "us-east-1.amazonaws.com";
InternetDomainName domain = InternetDomainName.from(ff);
System.out.println(domain.topPrivateDomain());
```
> Exception in thread "main" java.lang.IllegalStateException: Not under a public suffix: us-east-1.amazonaws.com
>   at com.google.common.base.Preconditions.checkState(Preconditions.java:197)
>   at  com.google.common.net.InternetDomainName.topPrivateDomain(InternetDomainName.java:424)
>   at   *****.main(MyTestJavaClass.java:8> 9)
>     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
>     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
>     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
>     at java.lang.reflect.Method.invoke(Method.java:606)
>     at com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)
You are so right. Sorry for not noticing that ...
At line 91 of LineBuffer, it should be better to call line.setLength(0) instead of creating another StringBuilder(). Maybe add a length limit too:
```
private static final int MAX_LINE_LEN = 0x1000; // 4K
/** Called when a line is complete. */
private boolean finishLine(boolean sawNewline) throws IOException {
handleLine(line.toString(), sawReturn
? (sawNewline ? "\r\n" : "\r")
: (sawNewline ? "\n" : ""));
// line = new StringBuilder();
if (line.length() > MAX_LINE_LEN) {
line = new StringBuilder();
} else {
line.setLength(0);
}
sawReturn = false;
return sawNewline;
}
```
My concern was not only about the GC but the copies due to increasing capacity. I believe the initial      capacity for a new StringBuilder is almost always wrong given file lines. 16 characters is just too low, maybe not for configuration files but we are still using the default constructor. In addition to that, files tend to have equal or similar line lengths, reusing the builder is probably a better strategy to ensure right capacity.
I should report back with some tests. I believe this is a low priority micro optimization if at all, feel free to ignore unitl I come back with noteworthy results.
Presently, a constant function is provided in the `Functions` class with a type signature as follows
``` java
public static <E> Function<Object, E> constant(@Nullable E value)
```
Personally, I think that a type signature as follows would be superior
``` java
public static <Q, E> Function<Q, E> constant(@Nullable E value)
```
It's probably not trivial to introduce such a change without triggering a compilation error here or there. Still I think it might be worth considering.
Here's my specific use case. I'd like to have an interface that returns a `Function<A, B>`. I'd like to have a dummy implementation of that, which always returns the same (constant) value. Naturally, I can build my own constant function easily (which I did), and yet it seems odd that I would need to do that.
There are no doubt many plausible workarounds (as it were, I am quite content with mine). It is also a very minor issue. I simply felt it noteworthy that a workaround would seem to be required in the first place. Please do feel free to close it if it isn't worth your time.
As "solutions" go though, my proposal would be to make `ConstantFunction` generic in the parameter type as follows:
``` java
private static class ConstantFunction<D,E> implements Function<D, E>, Serializable {
private final E value;
public ConstantFunction(@Nullable E value) {
this.value = value;
}
public E apply(@Nullable D from) {
return value;
}
[snip]
```
and either change or provide an alternative to `constant(T val)`:
``` java
public static <D, E> Function<D, E> constantD(E value) {
return new ConstantFunction<>(value);
}
public static <E> Function<Object, E> constant(E value) {
return new ConstantFunction<>(value);
}
```
Though again, I do agree that this is generics cosmetics, and perhaps not worth the possible API change/extension.
Thanks for your explanation and time.
I find that I have a ton of `public static final Joiner` declarations for `,`, `.`, and `space`.  I even found one `COMMA_JOINER` in `Predicates` class.
``` java
public static final Joiner EMPTY_JOINER = on( "" );
public static final Joiner COMMA_JOINER = on( "," );
public static final Joiner DOT_JOINER = on( "." );
public static final Joiner SPACE_JOINER = on( " " );
public static final Joiner TAB_JOINER = on( "\t" );
public static final Joiner LF_JOINER = on( "\n" );
public static final Joiner CRLF_JOINER = on( "\r\n" );
```
As the only reason for forbidding negative tolerance is that it's an obvious error, I can't see how it applies to `-0.0`. OTOH I can't imagine any sane tolerance formula producing negative zero.
Still, forbidding it violates the common expectation that equal things behave the same.
And return the future that is passed to the method.
This will remove the need for intermediary variable when submitting a list of tasks.
Here is the use case;
``` java
List< ListenableFuture< SomeGenericResult< Type1, Type2, Type3 > > futures = new ArrayList<>( );
for ( Callable<Boolean> task : tasks )
{
executor.submit( task ),
new FutureCallback<SomeGenericResult< Type1, Type2, Type3 >>(){...}
)
);
}
ListanableFuture< List< SomeGenericResult< Type1, Type2, Type3 > > > listFuture = Futures.succesfulAsList( futures );
```
Without the fix, there has to be a variable inside the loop, which adds to clutter:
``` java
List< ListenableFuture< SomeGenericResult< Type1, Type2, Type3 >> > futures = new ArrayList<>( );
for ( Callable<Boolean> task : tasks )
{
ListenableFuture<SomeGenericResult< Type1, Type2, Type3 >> future = executor.submit( task );
future,
new FutureCallback<SomeGenericResult< Type1, Type2, Type3 >>(){...}
)
futures.add( future );
}
ListanableFuture< List< SomeGenericResult< Type1, Type2, Type3 > > > listFuture = Futures.succesfulAsList( futures );
```
`ListenableFuture` allows for delayed decision making.  This article explains it nicely -> https://code.google.com/p/guava-libraries/wiki/ListenableFutureExplained
Here is the main point of the article:
> The most important reason to use `ListenableFuture` is that it becomes possible to have complex chains of asynchronous operations.
Note, that you need `ListenableFuture`, not `Future` to derive this benefit.
See my example.  During the **FAN OUT** part of my computation, I want to be able to add it to the list of `ListenableFutures` without having to declare an intermediary variable (I think this is a rather common occurence).  Because `ListenableFuture` is generic, and the computational result may be generic, this intermediate variable declaration may be rather cumbersome, and not providing any functional/semantic meaning.
Basically, I am only asking that `addCallback` method follows a common `Builder` pattern, where the object that is being built is returned, instead of `void`.
Changed result type in the example from `Boolean` to mouthfull `SomeGenericResult< Type1, Type2, Type3 >`.
`AsMapView` (as returned by `Maps.asMap`) is not `Serializable`. As I can see, there's no fundamental reason why it shouldn't be serializable, if the set and function are (a lot of the functions returned by the `Functions` methods are indeed serializable). This applies to the subclass `SortedAsMapView` and related class `NavigableAsMapView` as well
The unmodifiable ones are Serializable, the modifiable ones are not, except for `TransformingSequentialList` and `TransformingRandomAccessList` (that I could find)...
I came up own Map impl that will not stores multiple Values, if it equals, and avoid duplicating of data. (just store only one of them).
Description of map impl is available on  (http://stackoverflow.com/questions/27472712/compact-java-util-map-implementation)
The question is : how to use this map for caching results , or is it possible at all?
**Background:** I have a use case where I need to implement/override `equals(...)` method for a class holding `Double` fields. Since `Double` rarely can be compared directly I'd like to make a fuzzy comparison between my class instances using some tolerance.
**Issue:** [`DoubleMath#fuzzyEquals(...)`](http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/math/DoubleMath.html#fuzzyEquals%28double,%20double,%20double%29) would be a useful utilify method for doing my comparison. The issue is, it doesn't support nullable doubles.
**Proposal:** To remedy this I have put together a utility method that solves this for me:
``` java
public class Doubles {
/**
* Like {@link DoubleMath#fuzzyEquals(double, double, double)}, but supports nullables.
*
*            first nullable element
* @param b
*            second nullable element
* @param tolerance
*            absolute difference tolerance. See {@link DoubleMath#fuzzyEquals(double, double, double)} for details.
*/
public static boolean fuzzyEquals(Double a, Double b, double tolerance) {
if (a==null && b==null)
return true;
else if (a != null && b != null)
return DoubleMath.fuzzyEquals(a, b, tolerance);
else /* (a != null ^ b != null) */
return false;
}
}
```
**Additional:** It could also be debatable if fuzzy comparison should be done in an `equals(...)` implementation. In my case, I think it's fair to say it is.
Good call on the transitivity there... Anyhow, I have no strong feelings about this but feel free to discuss it. Sounds like it's not that much of a common issue at Google...
In our project we want to create our own custom version from the EventBus. The EventBus supports this by overriding the method **void dispatch(Object, EventSubscriber)**.
We want to place our EventBus in our own package but the EventSubscriber is package protected. So we can not place our EventBus in it's own package without copying a lot of classes from guava.
Is it possible to make EventSubscriber public or use a public interface?
@cgdecker, are you saying that `EventBus` should not be extended by users at all? It would be good to document that.
(This would be unfortunate, though. We have an internal `SequentialEventBus extends EventBus` implementation that ensures that all listeners have received an event _E_<sub>i</sub> before any listener receives the subsequent event _E_<sub>i + 1</sub>. It's used in an application in which relatively few events are fired and where some subscribers post events themselves. `SequentialEventBus` gives a receiver _R_ of event _A_ the guarantee that all other interested subscribers have seen _A_ before _R_ posts a follow-up event _B_. This guaranteed ordering of events simplifies reasoning about the system.)
> 1. Deprecated non-beta APIs will be removed two years after the
>    release in which they are first deprecated.
while https://code.google.com/p/guava-libraries/wiki/PhilosophyExplained#Non-Beta_APIs states
> Deprecated non-beta APIs will be removed eighteen months after the release in which they are first deprecated.
Is it 18 or 24 months?
Will do! :+1: for quick fix!
Ordering throws a IncomparableValueException if there is a mismatch between the ordering and the list to be ordered. This exception is package-local, which results in one not being able to catch it, instead one has to catch ClassCastException, which leads to messy code.
The case in question is as follows:
I have a web-GUI where one of the things the user can do is create a list of entites, and view these as a HTML table. It also has the possibility to delete specific rows, as well as drag-and-drop functionality in order to rearrange the ordering of the list. Upon rearranging the rows, the id's of the enitites are posted in an ordered list. On the server side I want to load the list as it sits in the database, and then order them according to the list of id's, and then save it to the database. For this I use Guava's Ordering.
But, since multiple users can manipulate the same list at the same time, one user could delete a row  while the other one is rearranging, which leads to a mismatch between the supplied id's, and the stored state from the database. In these cases, I would like to present the user with an informative error message stating that one should refresh the page, in order to get the GUI in sync with the database.
To achieve this I need to catch the exception that indicates a mismatch between the two lists sent to the ordering, and the exception being thrown when this happens is IncomparableValueException. But, since this is not public, I can not catch it, and am left with catching ClassCastException (a much wider and more general exception) instead. The result would probably be the same if it was an actual ClassCastException (the user has to refresh), but imho it's good practice to catch as narrow exceptions as possible.
Given that `Range` is serializable, shouldn't its type parameter `C` be bound to `Serializable` too?
``` java
Range<C extends Comparable & Serializable>
```
I understand, thanks for the explanation.
I have several use cases that involve transforming the values held by Ranges and RangeSets.  In particular, I often have a `Range<LocalDate>` and need a `Range<Integer>` (where the latter represents a range of years) or the inverse.  While it's possible to manually extract the endpoints and construct a new Range, ideally there would be some cleaner standard way to do this.
I currently have several Function generator methods that I use which works reasonably well.  Hopefully this example will help trigger discussion, I'm happy to contribute the backing code if this pattern in fact seems desirable.
```
/**
* Returns a function which transforms the endpoints of a range using the passed function.
* Take note that losses of precision can change ranges, e.g. [1.2..1.9) => [1..1)
* becomes an empty range.
*/
public static <S extends Comparable<? super S>, E extends Comparable<? super E>>
Function<Range<S>, Range<E>> rangeTransformer(Function<S,E> f)
/**
* Returns a function which canonicalizes a range, then transforms the endpoints using
* the passed function.  Useful for broadening ranges, e.g. [1..2] => [1..3) => [1.0..3.0),
* which is difficult to define in non-canonical form.
*/
public static <S extends Comparable<? super S>, E extends Comparable<? super E>>
Function<Range<S>, Range<E>>
canonicalizedRangeTransformer(Function<S,E> f, DiscreteDomain<S> domain)
/**
* conjunction with the rangeTransformer() methods.
*/
public static <S extends Comparable<? super E>, E extends Comparable<? super E>>
Function<RangeSet<S>, RangeSet<E>> rangeSetTransformer(Function<Range<S>,Range<E>> f)
```
This can then be used to (reasonably) concisely define a transformation on Ranges and RangeSets, without needing to worry about as much boiler-plate.
```
public static final Function<Range<Integer>, Range<LocalDate>> YEAR_RANGE_TO_LD_RANGE =
canonicalizedRangeTransformer(new Function<Integer, LocalDate>() {
public LocalDate apply(Integer year) {
// By canonicalizing first, we can safely always return Jan 1st
// The range [2000..2002] becomes [2000-1-1..2003-1-1) which is equivalent.
return new LocalDate(year, 1, 1);
}},
public static final Function<RangeSet<Integer>, RangeSet<LocalDate>> YEAR_RANGESET_TO_LD_RANGESET =
rangeSetTransformer(YEAR_RANGE_TO_LD_RANGE);
```
> The direction that we were moving on that thread was requiring a separate transformation function for each endpoint.
I explored the same thought when I first needed these transformations, and really wanted to avoid needing to define my own `RangeTransformer` or similar class.
1. Lossless Transformations: where two types map one-to-one, such as `String` <=> `CharSequence`.  There's little to say here, it really makes sense to make these sorts of transformations easier.
2. Expanding Transformations: where the original type maps one-to-many destination types (e.g. `Integer` => `Double` or `Integer`(year) => `LocalDate`).  This is a little odd, because there needs to be some sort of canonical destination value defined, such as the first day of the year.  I see two options, either explicitly canonicalize the Range like I do above (and so `[2000..2002]` becomes `[2000-1-1..2003-1-1)`, or implement #1551 so that the range bounds can be restored internally (`[2000-1-1..2002-12-31]`).  I could be mistaken, but I believe canonical Ranges can always be safely expanded to a more precise type without requiring separate handling for each endpoint.
3. Lossy Transformations: where the original type maps many-to-one destination type (e.g. `Double` => `Integer` or `LocalDate` => `Integer`(year)).  This is the tricky one, since it's not totally clear what something like `[2.5..3.5]` should become.  The consistent option would be to treat it just like a lossy cast, so `[2..3]`, but that "feels" wrong to me.  Alternatively we could fail-fast in such a case and only allow Ranges that can be safely cast both ways.  This might be a little more painful to use, but it also might be less error-prone.  Currently, I've implemented the lossy cast for `LocalDate` => `Integer`(year), but that's clearly not ideal (e.g. `[2000-12-31..2001-1-1]` becomes `[2000..2001]`, going from two days to two years).
Perhaps it would be sufficient to always canonicalize the original range, and just document that lossy transformations risk losing data?
I think Lossless Transformations should be implemented first, since they don't require separate logic for upper/lower bounds, the implementation logic should be fairly simple, and they would greatly simplify what is otherwise a very painful operation for the user.
Currently, the simplest way to implement it externally that I have found is to check whether the lower/upper bounds exist, extract the lower/upper endpoints & BoundTypes for the bounds which do exist, "cast" the endpoints, and then call either Range.range, Range.upTo, Range.downTo, or Range.all depending on which bounds exist, and pass the "casted" endpoints and extracted BoundTypes back in.
Which is ridiculous when all you're trying to do is call .getBytes(UTF8) on the endpoints that exist, to convert from a Range<String> that is easy for the user to specify, to a Range<byte[]> that is not, but which is the only Range type the underlying system will accept.  Currently, any Range can be canonicalized to `[closed, open)`, however there is no easy way to transform a Range into other bounds (notably `[closed, closed]`).  At a minimum, I would suggest providing a `closed()` method that attempts to return a fully closed Range, the same way `canonical()` does.  I can attest I have used this behavior heavily.
Even better, I would think, would be a generic way to rebound a Range however the user needs.  I'm less certain about the use cases for other bounds, but the code to properly rebound is tricky, and in particular would be easier and cleaner if it had access to the Bounds inside Range.
I have a need to select the most recent `n` elements from a list that I know is ordered; for instance, to display data from the last ten years, in a (potentially long) list of data ordered by year.
For existing Lists it's tedious but not complicated to write out:
```
list.subList(Math.max(list.size() - n, 0), list.size())
```
though I'd argue the cleanliness of a simple `.tail()` method is still a nice win over the above.  More valuable however is providing support for arbitrary Iterables, in order to avoid creating a copy of the whole data stream simply to take a small sublist.  I imagine many users (myself included) simply absorb the cost of the full copy rather than take the time to implement a circular buffer or similar memory-efficient solution.
I understand that this issue is about a new method for getting the tailing/last/trailing N elements, but if anyone hits this page while searching for a method to find THE last element, as I just have, then FYI  com.google.common.collect.Iterables's T getLast(Iterable<T> iterable) is what you are looking for (it's optimized for List).
Just to mention that a302923027 makes `EvictingQueue` a little more efficient for this use-case, but it's still not as discoverable or intuitive as a method on `Iterables` would be.
Along the lines #418: ability to start()/stop() a service a few times seems very common
Not being able to restart the service somewhat defeats the point and forces to reimplement a lot of the same boilerplate (as mentioned in #418 ensuring only one running)
Maybe AbstractService needs to be modified or new recipe added (RestartableService) since this is a recurring usage
The functionality part is the same as in #418 (by mathias.bogaert and piotr.findeisen)
I found several Service(s) in our code base, but none could use AbstractService
ability to start()/stop() a service a few times seems very common
Not being able to restart the service somewhat defeats the point and forces to reimplement a lot of the same boilerplate (as mentioned in #418 ensuring only one running)
Maybe AbstractService needs to be modified or new recipe added (RestartableService) since this is a recurring usage
@cpovirk I am not collaborator so (based on [1]) i cannot reopen issues -- please reopen #418 for us
[1] http://stackoverflow.com/questions/21333654/how-to-re-open-an-issue-in-github
In a couple of places, in using the `com.google.common.reflect` library, I've found that it would be helpful to have a method like `public abstract java.lang.reflect.Executable getExecutable()` on the `Invokable` class. Currently I have to maintain my own internal mapping from `Invokable -> Executable` in certain situations, which is not ideal. It can be difficult to interact with other existing APIs, too.
The only issue I can see with this is that it could break compatibility with users' code if they've subclassed Invokable for some reason. If this is important, a way round it would be to just have a non-abstract `getMember()` method on `Invokable` (or `Element`) which by default just returns `this`, and which can be overridden by `MethodInvokable` and `ConstructorInvokable` as appropriate. Having to cast at the use site would be better than nothing.
Thanks,
Ah of course, thanks, that makes sense! Interesting reading on issue #1738.
How about just the `getMember` method on `Element`, then, so we can cast to figure out if it's a `Method` or a `Constructor`? This would be backwards compatible with earlier Java versions, and if the time comes when it becomes appropriate, the method could be overridden in `Invokable` to return an `Executable` for better Java 8 support.
...Though it would be understandable if you would not be willing to commit to _any_ new changes, backwards compatibility preserving or not, until you had a full forward plan.
Yeah sure, though I'm sure it's pretty boring :). I don't think it's because any functionality is missing, anyway. I can also do what I need to do without this, it's just slightly more of a faff in places.
The first place I'd use `getMember` is in an implementation of some methods to find overload candidates for a given method name and parameter and return types, then find the most specific. It's not a big deal here, just would make the internals a little neater since we have to map our result back to an Executable to match the public API.
The second is in the API for the inference implementation I mentioned I'm doing in another issue. I have, e.g.:
```
public Type[] inferTypes(Executable executable, Type result, Type... parameters)
```
and:
```
public <R> List<TypeToken<?>> inferTypes(Invokable<? super T, ? super R> invokable, TypeToken<R> result, TypeToken<?>... parameters)
```
and I would just like to be able to implement the latter by forwarding to the former.
Well fair enough, no biggie.
In the second case, yeah, it's either a case of flipping it and doing some
the world haha...
Since you mention `Invokable.from(Executable)`, though, that would actually
be a nice alternative to the current minor boilerplate of figuring out
which to call between `Invokable.from(Method)` and
`Invokable.from(Constructor)` ;).
Cheers
On 3 December 2014 at 17:41, Ben Yu notifications@github.com wrote:
> Was about to do it then realized an awkward API design issue.
>
> Invokable today implements Member. So it seems weird for it to also expose
> getMember(). getExecutable() would be less weird. But...
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/1902#issuecomment-65453224.
Would be useful for usecases like:
Right now it should be written as
```
}
}
```
Java 8's Optional has `orElseGet(Supplier<? extends T> other)` which doesn't return Optional.
Hello @cgdecker , I did fixed this issue but with a little duplicate codes :) , because I tried to avoid adding new methods .
and because I am new in github , I don't know if I should create new pull request or referenced this issue from the commit is enough .
Thank you :)
A workaround fro this particular issue is to use withKeyValueSeparator(Splitter.on("=").limit(2)).  When using reflect.ClassPath.from(ClassLoader classLoader), if the classloader involved has loaded classes from a local file containing spaces, a URISyntaxException will be thrown from ClassPath.java line 294.
This bug is caused by the line above it: `uri = entry.toURI();` which apparently doesn't work as expected when the URL in question contains spaces.
There are two code paths that reach into the scan(URI,ClassLoader) function.  One of them can be easily replaced with a URL based solution but the other one which flows from: `for (URI uri : getClassPathFromManifest(file, jarFile.getManifest())) {` seems more difficult.
I created a [fix](https://github.com/OverclockedTim/guava/commit/8cf877043172a2e2840d9daad54b3fbd4779d5fb) that makes this work in my environment (appengine devserver on Windows).  I can verify that it works in my live tests but it fails some JUnit tests that currently exist.  I am not certain that those tests are valid, but since it does fail I won't submit this as a pull request.
Unfortunately I've spent a day on this and it is now working for my company so I probably can't spend any more time on it, but hopefully the commit listed above is helpful!
I think there is some questionable logic in the way assignability is calculated in `TypeToken`. I'm assuming the method `isAssignableFrom` is intended to have the same semantics as `Class.isAssignableFrom`, i.e. check whether an assignment would be a widening conversion. Currently, we have the following behaviour, as an example:
```
TypeToken<? super Comparable<String>> superComparable; // ...
superComparable.isAssignableFrom(TypeToken.of(String.class)); // returns false!
```
But if we have a reference of any type which satisfies `? super Comparable<String>` it should be assignable from a reference of type `String` quite happily, and therefore represent a widening conversion, should it not?
Looking into it I think the 'problem' - if it is a problem and not just my misunderstanding of the intent of the method - is expressed by this comment, from line 793:
```
// Foo, SubFoo, <? extends Foo>, <? extends SubFoo>, <T extends Foo> or
```
Whereas the way I see it, it should be:
```
// Foo, SubFoo, <? extends Foo>, <? extends SubFoo>, <T extends Foo> or
// else if "to" is <? extends Foo>, with no lower bounds, the assignment will always fail.
```
Though this description is insufficient if the wildcard has both lower _and_ upper bounds (other than Object), but you see what I mean. I guess my implementation would just be:
```
return isAssignable(from, supertypeBound(to)) && isAssignable(from, subtypeBound(to));
```
Am I making sense here?
In the case you are talking about, where the `TypeToken<? extends Comparable<String>>` is actually a `TypeToken<MyComparable<String>>`, the part of the code I'm talking about doesn't get reached anyway so it doesn't matter. Specifically I'm talking about the case where the `runtimeType` member is an instance of `WildcardType`, in which case the following is called:
```
private static boolean isAssignable(Type from, Type to) {
if (to.equals(from)) {
return true;
}
return isAssignableToWildcardType(from, (WildcardType) to);
}
// ...
}
```
eventually propagating down to the bit of code/comment I referenced in the original issue comment.
If this is not supported, it would be better to throw an exception than to get it wrong imo... but unless other code relies on the current behaviour it is an easy fix.
The place I'm finding this issue can be reduced to the following example, which is very much an analogue of a real world scenario so I do think a fix would be valuable:
```
// Token for a consumer:
TypeToken<Consumer<? super Comparable<String>>> literal = new TypeToken<Consumer<? super Comparable<String>>>() {};
// Reference for accept method of Consumer:
Invokable<Consumer<? super Comparable<String>>, ?> accept = literal.method(literal.getRawType().getMethod("accept", Object.class));
// Token for type of the method parameter (? super Comparable<String>):
TypeToken<?> boundedLiteral = accept.getParameters().get(0).getType();
// Can we assign a String to the method parameter type? This should return true!
boundedLiteral.isAssignableFrom(TypeToken.of(String.class));
```
It's not that it exactly 'matches' in the sense you're talking about, it's that it's _assignable_ to it. If 'to' is a supertype of Foo, then you should be able to assign a 'SubFoo' instance to a reference of that type.
```
Iterable<? super Comparable<String>> it;
Iterable<String> strings = null;
// Type mismatch: cannot convert from Iterable<String> to Iterable<? super Comparable<String>>
```
```
// returns true:
new TypeToken<Number>() {}.isAssignableFrom(new TypeToken<Integer>() {});
// because we can do this:
Number num;
Integer integer = null;
num = integer;
// but not this:
Iterable<Number> nums;
Iterable<Integer> ints = null;
nums = ints;
```
```
? super Foo foo = subFoo;
```
Sure, but you can have something like:
```
Consumer<? super Number> a = null;
a.accept(new Integer(0));
```
Which is effectively assigning an `Integer` to a reference of type `? super Number`.
I maintain that my interpretation of the rule makes more sense, and is more consistent with other behaviour, than the current implementation.
Another way to look at it is to define isAssignableFrom as: "every possible type matching 'from' is assignable to every possible type matching 'to'."
Or in the above case: "every possible type matching `? super Number` is assignable from every possible type matching `Integer`".
Or more trivially: "every possible type matching `Number` is assignable from every possible type matching `Integer`".
I mean, imagine if you _could_ do:
```
? super Foo foo = subFoo;
```
or
```
Object foo = (? super Foo) subFoo;
```
You would expect that to work, right?
TypeToken and Invokable currently have great support for reflective examination of generic types, but I think there are some blind spots when it comes to generic _methods_ which fall neatly within the scope of the library.
Consider the (fairly pointless looking) method:
```
<T> T getItem(Collection<T> c);
```
Querying the return type and getting a TypeToken over a java.lang.reflect.TypeVariable isn't that useful in most contexts. A client isn't likely to know what to do with type 'T' without doing some further manual investigation.
What would be nice is a rough analogue to the `<X> TypeToken<T> where(TypeParameter<X> typeParam,  TypeToken<X> typeArg)` method from the TypeToken API. Obviously the design would have to be a little different, since an Invokable can't be parametrised over the generic method type parameters so we can't magically capture them in a TypeParameter in the same way we do there.
But essentially it'd be nice if we could do something like this:
```
Invokable<?, ?> getItem = ...; // whatever
getItem = getItem.withTypeParameters(String.class); // varargs method expecting a class/TypeToken per generic method parameter
```
to get a reference to the parametrised method with the parametrized signature (if that is a concept which makes sense):
```
<String> String getItem(Collection<String> c)
```
Or maybe even just:
```
TypeToken<?> wildcard = ... // pass an unbounded WildcardType to `TypeToken.of` I guess
```
giving an invokable over the parametrized signature:
```
<?> ? getItem(Collection<?> c)
```
This way we could do a few more useful type checking tasks in serialisation libraries and the like out of the box.
Of course my ideal wish list feature would be:
```
getItem = getItem.inferTypeParametersFromArguments(new TypeToken<List<String>>() {});
```
to give an Invokable over:
```
<String> String getItem(Collection<String> c)
```
though I suppose this would require an implementation of the entire Java method type inference rules, which is far from trivial, and probably asking too much when this is a bit of a niche feature!
Cheers,
Hi, thanks for the quick response.
I'm not _necessarily_ talking about type inference - this would be nice to take it a step further, but as you say, lots of complexity for a feature without that many use cases. Mainly I'm just talking about _explicit_ parametrisation with given types.
In other words, rather than automagically resolving the type variables in the type expressions [A, B, C] for some [x, y, z], simply check whether a given exact substitution for those type variables is valid wrt their bounds.
It's perhaps still non-trivial to verify the requested parametrisation is valid, but I had thought that it would be the same task as `where` already performs in TypeToken... Looking at it though, it seems you don't actually perform any checking on the validity of the parametrisation here, since you can just rely on getting it free from the compiler. (Which is very cleverly done, btw!)
Looks like, as you say, the only way to achieve this atm is to pull in a dependency on javac or JDT or something... and faff around with syntax trees and stuff most likely. Fun!
Thank you, this makes sense and has given me a starting point. I will do as you describe and try to use the TypeResolver and isAssignableFrom to implement something along these lines. I will come back to reopen this issue, or to open another one, if I am successful in a way which might be useful for other people as a contribution.
Cheers,
FWIW, for anyone still watching this, I've started implementing the type inference rules myself according to the spec for Java 8. It doesn't actually seem _that_ difficult now I've gotten a little way into it, just a fair bit of work.
I'm working using your reflection stuff without pulling in any other dependencies, and I've tried to design the API in a way which I think fits neatly with what you currently have. Assuming I do actually finish this and it's up to your standards, is there any chance you'd consider merging it in?
Great, TypeParser and Types will come in handy for me, thanks. And I'll let you know when the type inferrer is done all the same, even if it will just live as a stand-alone project.
Hi, if you're interested the type inferrer is pretty much done now. There were too many edge cases and new types involved with inference which weren't compatible with your library (infinite types, intersection types, type variables with upper and lower bounds, etc.), so I just reimplemented the features I needed and got rid of the dependency. It wasn't that much more work really, as the type inference algorithm effectively gives you a lot of it for free (though likely many times slower in some cases... it's not quick... thankfully this isn't an issue for me).
Anyway, the library lives here https://github.com/StrangeSkies/uk.co.strangeskies under the uk.co.strangeskies.reflection subproject. If you want to take a look, TypeLiteral and Invokable provide most of the useful functionality.
As per I can see on the docs (https://code.google.com/p/guava-libraries/wiki/CommonObjectUtilitiesExplained), the documentation is still using _Objects_, when it should say _MoreObjects_ (Objects it's deprecated on the 1.8 version). How can I fix this minor issue?
Thanks!
Cool. Thanks a lot! :+1:
I previously posted in 'guava-discuss' offering to contribute some code I wrote for sorted iteration streams:
In keeping with Guava's 'CONTRIBUTING.md' document, I didn't provide any code to look at when I posted to 'guava-discuss', but because I didn't get any response either, I'm going to try dangling some code. =)  Here's what my code looks like, committed in a fork of the Guava project:
The short rationale from the previous post follows:
> In some work at my company, I've developed a few small classes that deal with "Sorted Set" streams in Java - the idea is that these are iterators (potentially very large or infinite) of Comparable items in strictly increasing order.  They may represent search results (in our case, streaming from a Mongo DB back end), arrival times of events, or similar.
>
> With such streams, it is possible to define composition operations Intersection and Union, while keeping the lazy iteration semantics of Iterators, and also playing nicely with transformations like Guava's Iterators.filter() and Iterators.transform().
>
>
Thanks,
-Ken
Thanks for the reply - no worries about taking a while, I've led several OSS projects and I know that's just how it goes. =)
I'm not sure how often such a thing is called for "in the wild" - I just know that I've written essentially the same utilities several times in several different languages over the past 15 years for a host of radically different situations.  This time, I decided to try to put it somewhere I'd always remember where it is - and the JVM / Guava seemed like a good place. =)
The way I use this code right now is in boolean searches - a user can specify criteria that, behind the scenes, hits multiple data sources. An `AND` is translated to an `intersection()`, an `OR` is translated to a `union()`.  This lets me cleanly separate the atomic back-end searches from the boolean logic.
Another use case would be a monitoring situation, sort of an "if-this-then-that" thing: show me events that satisfy `A AND (B OR C)` or whatever, as they occur forward in real time.  Since they're implemented lazily, they can check requirements as events arrive, rather than tying the logic to the event receiver.
Perhaps the "flavor" of such a thing is closer to Scala or similar, but I'm sure Java & Guava have a wider audience, so it might be the sweet spot of "utility x ubiquity" as you say.
So is this officially rejected, or just stalled?  Wondering if I should find a different home for it.
hi, i think`com.google.common.util.concurrent.Striped` is a great tool, but why i couldn't use its `lazy` method to custom the supplier?
`Striped<L>` is a generally useful class that could be used for a fair number of things, including custom lock implementations. It would be good if this was accessible.  as TODO comments said to remove null boilerplate in CaseFormat.java . then I re-run CaseFormatTest test to ensure it passed .
Affected Files:796
Google Java Style guide (version of March 21, 2014):
http://checkstyle.sourceforge.net/reports/google-style/guava/
All violations are thoroughly rechecked, but some very occasional false-positives could be present.
Detailed report (match of each Google Java Style rule to Checkstyle):
http://checkstyle.sourceforge.net/google_style.html
How to run (command line):
```
~ $ cd /var/tmp
/var/tmp $ git clone https://code.google.com/p/guava-libraries/
/var/tmp $ wget -O checkstyle-6.1-all.jar http://downloads.sourceforge.net/project/checkstyle/checkstyle/6.1/checkstyle-6.1-all.jar?r=&ts=1416082535&use_mirror=tcpdiag
/var/tmp $ wget https://raw.githubusercontent.com/checkstyle/checkstyle/master/google_checks.xml
/var/tmp $ time java -jar checkstyle-6.1-all.jar -c google_checks.xml -o checkstyle-report-guava.txt -r guava-libraries
real    2m55.599s
user    3m12.596s
sys 0m1.056s
```
PS: all work was done during Google Summer of Code 2014
> Our hacked-up version of checkstyle that we use inside Google misses a ton of things
Why not to contribute Google's fixes over Checkstyle to Checkstyle ? :)
> 926 ParameterName
> 263 LocalVariableName
Pelase update a Google Style Guide.
> 185 SingleLineJavadoc
from style guide "The single-line form may be substituted when there are no at-clauses present," . So all one line javadocs that have atclauses are not allowed.
So please fix Google Style Guide. and lets switch off that rule or update it.
> 185 EmptyBlock (empty catch block)
Googe Style Guide need to updated to clearly state under what names and comments inside it will be allowed to have empty block. After that we could update Rules to cover them.
> 926 ParameterName
Googles Java Style Guide should be updated
```
<module name="Checker">
<module name="SuppressionFilter">
<property name="file" value="{path}/checkstyle_suppression.xml"/>
</module>
...
</module>
```
checkstyle_suppression.xml :
```
<suppressions>
<suppress checks="JavadocMethod"
files=".*_CustomFieldSerializer.java"
/>
</suppressions>
```
> since the developer is allowed to use judgment about when the documentation would "have nothing useful to say" and is allowed to skip it in that case
JavadocMethod Check have option minLineCount="2", we could extend it to value you think in general mean self explanatory method. If that is not an option please confirm switching off that Check.
But my advice is NOT switch it off, as developers can miss meaningful javadocs easily and developer will spend extra 1 min of this time to describe a method in javadoc. 1 minute is not critical time during development or before merge to target branch, but that time save you from other more sad mistakes.
> 307 Indentation
checkstyle_suppression.xml :
```
<suppressions>
<suppress checks="Indentation"
/>
</suppressions>
```
> 263 LocalVariableName
ok, it is matter of your code standard, just change style guide.
> 185 SingleLineJavadoc
completely reasonable, but guide is not exact - so guide have to extended to be more precise.
> 185 EmptyBlock (empty catch block)
We could create special Check to do validation base on comment inside and base on name of variable. Checkstyle could not distinguish test code and production code so that allowance by name will be applied to all code.
Are you agree ?
> 80 WhitespaceAround
> However, most of them are "catch... {}" and I think the error will have to be reported in different language or users will be very confused. ("Empty blocks may only be represented as {} when not part of a multi-block statement (4.1.3)")
Checkstyle have ability to change message in configuration, example - https://github.com/checkstyle/checkstyle/blob/master/src/main/resources/google_checks.xml#L40, so we could make it like:
WhitespaceAround: '{' is not followed by whitespace. Empty blocks may only be represented as {} when not part of a multi-block statement (4.1.3)
Are you agree ?
@kevinb9n , it will also bee good to clarify what code is preferable (discussion at https://github.com/checkstyle/checkstyle/issues/533):
```
boolean same = Util.<Integer, String>compare(p1, p2);  // Generic preceded method name
```
vs
```
boolean same = Util.<Integer, String> compare(p1, p2);  // Generic preceded method name, extra space between
```
will be good to put that in style document to resolve any further discussions.
Empty Catch Block is implemented and released in Checkstyle 6.4, report was updated - "Last Published: 2015-02-28  | Version: 19.0-SNAPSHOT"
http://checkstyle.sourceforge.net/reports/google-style/guava/
in case you need to regenerate report please use that simple steps: https://github.com/checkstyle/checkstyle/wiki/How-to-generate-Checkstyle-report-for-Google-Guava-project
FYI:
so the only item that is left to be done by Checkstyle team is "4.8.6.1 Block comment style", but will be addressed in next release.
New options "ignoreInlineTags" and "ignoredTags" for Single Line Javadoc were added and released in Checkstyle 6.8.
<b>ignoreInlineTags</b> allows inline tags (such as {@code}, {@link} etc.) to be put in a single line javadoc. Report generated with Checkstyle 6.9 over Guava 19.0-SNAPSHOT with this option switched on shows a lot less violations: <b>53</b> (http://vladlis.github.io/reports/google_style/) against <b>227</b> (http://checkstyle.sourceforge.net/reports/google-style/guava/). So it makes sense to extend the Style Guide (http://google.github.io/styleguide/javaguide.html#s7.1.3-javadoc-at-clauses) and make it more precise in order to allow inline tags. Some googlers already reported that issue at https://github.com/checkstyle/checkstyle/pull/1545, but to change config with new option we need to have update in Google Java Style first.
<b>ignoredTags</b> could also be used if some tags, for instance @see, were allowed by the Guide in a single line javadoc.
CommentsIndentationCheck was introduced and reliased in Checkstyle 6.12. The Check covers the section [4.8.6.1 Block comment style](http://checkstyle.sourceforge.net/reports/google-java-style.html#s4.8.6.1-block-comment-style) from Google Java Style Guide. Report generated with Checkstyle 6.12 over Guava 19.0-SNAPSHOT with CommentsIndentationCheck shows [11 violations](http://checkstyle.sourceforge.net/reports/google-style/guava/).
So, Google Java Style Guide was covered by Checkstyle as much as it was possible. See [Google's Java Style Checkstyle Coverage](Google's Java Style Checkstyle Coverage).
> 926 ParameterName
guide is updated - https://google.github.io/styleguide/javaguide.html#s5.2.6-parameter-names
> 263 LocalVariableName
Clarification issue request was created to style project - https://github.com/google/styleguide/issues/214
> 185 SingleLineJavadoc
Single-line javadoc is explicitly allowed by 7.1.1.
confirmation request - https://github.com/google/styleguide/issues/215  The expected output is `amazonaws.com`, but an `IllegalStateException` is thrown.
Context:
Attempting to implement a queue that can buffer data at any incoming rate, but meter the output to a steady stream.  However, unless using the `warmupPeriod` constructor of RateLimiter, the throttling doesn't seem to kick in immediately.
In the following example, the output of the queue (as throttled by RateLimiter) allows three items to slip through unthrottled (note the identical time stamps of A, B and C):
```
10:27:21.603 Thread 11: A
10:27:21.603 Thread 11: B
10:27:21.603 Thread 11: C
10:27:22.072 Thread 11: D
10:27:22.575 Thread 11: E
10:27:23.076 Thread 11: F
```
Code to reproduce:
``` java
import java.util.Arrays;
public class Main {
public static void main(String[] args) throws InterruptedException {
RateLimitedQueue<String> rlq = new RateLimitedQueue<String>(2);
Thread.sleep(1000);
for (String element : Arrays.asList("A","B","C","D","E","F"))
rlq.add(element);
}
}
```
``` java
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.LinkedList;
import java.util.Queue;
import com.google.common.util.concurrent.RateLimiter;
public class RateLimitedQueue<T> {
public final RateLimiter rateLimiter;
public final Queue<T> queue;
private final int permitsNeeded = 1;
public RateLimitedQueue(double maxEventsPerSecond) {
rateLimiter = RateLimiter.create(maxEventsPerSecond);
queue = new LinkedList<T>();
}
public void add(T value) {
queue.add(value);
if (readerThread == null || !readerThread.isAlive()) {
readerThread = new Thread(new QueueConsumer<T>(this, permitsNeeded));
readerThread.start();
}
}
public void queueProcess(T data) {
SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss.SSS");
System.out.println(sdf.format(new Date()) + " Thread " + Thread.currentThread().getId() + ": " + data);
}
}
```
``` java
public class QueueConsumer<T> implements Runnable {
final private RateLimitedQueue<T> rlq;
final private int permitsNeeded;
QueueConsumer(RateLimitedQueue<T> rlq, int permitsNeeded) {
this.rlq = rlq;
this.permitsNeeded = permitsNeeded;
}
public void run() {
while (!rlq.queue.isEmpty()) {
rlq.rateLimiter.acquire(permitsNeeded);
rlq.queueProcess(rlq.queue.remove());
}
}
}
```
Yes, without the sleep it does throttle as expected.  I do think it would be useful to have a mode of operation where there's a guaranteed minimum spacing between granting permits to constrain the catch up behavior (up to and including eliminating it entirely).  It wasn't until I incorporated the RateLimiter into an application with long UI pauses between data bursts that I noticed this.
In my use case, I'm trying to add and/or remove a number of marker pins on Google Maps in bulk and it seems to work more reliably if the UI thread is given a momentary break between successive API calls.  (On reflection, a simple timer might be a viable alternative here.)
guava's HtmlEscapers just escapes known entities (double quote, open and close angle bracket, and single quote, that's pretty much it). It does not escape a bevy of other 'suspect' characters, including crazy unicode takes on angle brackets which some well-intentioned browser may try to interpret as actual angle brackets (if such browsers exist, then that would mean `HtmlEscapers` currently has security-critical bug in it, ouch!).
I admit I haven't done the complete research on this, but on general security principles, shouldn't HtmlEscapers whitelist a select few characters (tab, space, enter, and most alphanumerics in ASCII, and that's about it), hardcode a select few character to entity mappings, and `&#` escape everything else?
While we're here, the HTML docs refer to using `&#` encoding to encode `code points`. That sounds like it means that a surrogate pair in a java string should be encoded as a single code point. Just about every existing escape library doesn't get that right.
Some basic research:
- Spring's HtmlEscapers equivalent works broadly like guava's, but has a MUCH longer list of known entities. [source code](http://grepcode.com/file/repo1.maven.org/maven2/org.springframework/spring-web/4.0.6.RELEASE/org/springframework/web/util/HtmlUtils.java#102), [list of supported entities](http://grepcode.com/file/repo1.maven.org/maven2/org.springframework/spring-web/4.0.6.RELEASE/org/springframework/web/util/HtmlCharacterEntityReferences.properties).
- Apache commons has multiple different classes that can do it, and they are implemented differently. StringEscapeUtils works similarly to spring's ([source](http://commons.apache.org/proper/commons-lang/apidocs/src-html/org/apache/commons/lang3/StringEscapeUtils.html)), but there's also Entities, which escapes everything above 0x7F as well as a few hardcoded characters. It does not handle surrogate pairs well, nor does it escape suspect ASCII characters such as 'bell', 'backspace', 'NULL', delete, etc. ([source](http://grepcode.com/file/repo1.maven.org/maven2/commons-lang/commons-lang/2.6/org/apache/commons/lang/Entities.java#Entities.escape%28java.io.Writer%2Cjava.lang.String%29)).
- The SGML spec seems to suggest that for example characters with codes 128 through 159 **may not be used at all**, yet the HtmlEscapers code doesn't escape these. ([source](http://www.w3.org/TR/REC-html40/sgml/sgmldecl.html)).
I'm willing to contribute a patch (with a whitelist and surrogate pair handling), but would like confirmation that the guava team feels that the current implementation of HtmlEscapers is security-wise rather iffy, i.e., that this patch is needed in the first place. There's also the tricky issue of context. For example, in normal HTML, there's no need to turn quotes into `&quot;`, and if you're in a CSS or javascript section inside an HTML document, you need very different escaping rules, so in some ways the problem 'please escape this string for me so I can put it in an HTML document' _requires_ a context, but for many programmers they simply don't know what context they wish to escape for.
This OWASP html escaper code does most of the things I covered, including being based on a whitelist model, numerically escaping _anything_ not explicitly trusted. [source](https://code.google.com/p/owasp-esapi-java/source/browse/trunk/src/main/java/org/owasp/esapi/codecs/HTMLEntityCodec.java)  this strongly suggests guava's HtmlEscapers is a security issue waiting to happen.
When dealing with hex encoded input, I have to handle both lower and uppercase input. Since decoder ist strict, I would have to `String.toLowerCase()` the input before passing it to the decoder, which is another copy process.
Nicer would be `BaseEncoding hex = BaseEncoding.base16().ignoreCase();`
An example would be hex encoded hashes from the web. - But my usecase is a more general utility class which supports encoding itself to hex and decoding hex values to instances of itself. I don't want to make people think about this issue.
This is only a minor inconvenience, but it does violate the principle of least astonishment. I was expecting it to work, but I had to go back and fix it once someone actually used the method with uppercased input.
So maybe the default behaviour could be to ignore the case, and only be strict if either `.lowerCase()` or `.upperCase()` were used.
Thanks for taking the time :)
Reading the explicitly referenced RFC, the first paragraph in section 8 already states:
http://tools.ietf.org/html/rfc4648#section-8 :
> The following description is original but analogous to previous
> descriptions.  Essentially, Base 16 encoding is the standard **case-**
> **insensitive** hex encoding and may be referred to as "base16" or "hex".
~~So I would go as far as calling this a minor bug.~~
**EDIT:** Well lets say, it warrants an ignoreCase() decoding setting.
commons-codec ignores case, and uses Character.digit(..)
python has a switch to be insensitive, but strict per default
:+1:  if .lowerCase() or .upperCase()  is not specified, makes sense to ignore case sensitivity on decoding.
I think `BaseEncoding.base16().decode(str.toUpperCase())` is perfect
Case doesn't matter when decoding base 16, so it would be nice if it just _worked_ no matter what case the input is. The lowerCase() and upperCase() methods should only affect encoding.
It maybe related to  "[Allow mixed case in from base functions #2669](https://github.com/prestodb/presto/issues/2669)" but only if you limit your scope to strings.  I need to be able to use the encodingStream and decodingStream and I need to be able to accept mixed case input streams for base16 decoding. I can be pretty sure the inputs will be consistent but can have no guaranty  that they will be upper or lower cased  If I need to store 85899345920 data, the amount of space is how much? It should not be 8 \* 8 \* 85899345920? 10 g? Not very understand the meaning of operation.Thank you!!
Hi,
I encountered a concurrency issue between the "get(K key, Callable<? extends V> valueLoader)" and "invalidate(Object key)" methods with a basic (and i suppose a common) usage of the cache which let a stale value in the cache.
Here is the use case:
- The cache is initially empty
- 1 thread is getting a value in the callable with a given key while an other thread is invalidating the same given key
**Thread 1**
``` java
Bean myBean = cache.get(ID, new Callable<Bean>() {
public Bean call() throws Exception {
Bean bean = loadFromDB(ID); // (1)
}
});
```
**Thread 2**
``` java
// Update just one property of the bean in DB
updatePartialDataInDB(ID, "newValue1"); // (2)
// Then, we need to invalidate the cache
cache.invalidate(ID); // (3)
```
The execution sequence order is marked with _// (number)_
After the point _// 4_, I have the old object in _myBean_ variable which is fine.
However, If i try to get again the bean with the identifier ID, I expect to have no value in the cache but a fresh bean reloaded from the DB.
Unfortunately, that is not the case and a stale value is kept in the cache.
``` java
RemovalCause cause;
if (entryValue != null) {
cause = RemovalCause.EXPLICIT;
} else if (valueReference.isActive()) {
cause = RemovalCause.COLLECTED;
} else {
// currently loading
return null;
}
```
Shouldn't a particular process be done before _return null_ ?
Thanks
Hi,
Do you plan to fix this issue for the next release?
If so, do you have an ETA?
This is a blocking issue for us.
Else, should we patch the code meanwhile?
Thanks
Hi,
Speaking of semantics, it's not value that is being invalidated, it's the key. The key is certainly there - and the value is being calculated.
Given that value V(K) is calculated from some other value X(K) (a row in DB, in this sample case), invalidate(K) should mean that any values based on values of X(K) retrieved up to the moment of invalidation are subject for recalculation.
Otherwise, the cache is pretty much useless in a simple case of caching a database row.
The problem does not come from the current pending fetch.
As i said, this is fine to return the not up to date bean at step 4 but this one must not be kept in the cache entry for next fetches.
I'd say this would be the expected behaviour.
> I don't think that's 100% obvious -- I suspect there are cases where you don't want the value-in-flight to be invalidated
@lowasser I'm trying out the implementation in my private fork. I had to revisit some tests, and from what I see, there is no good reason for the current behaviour. Some tests actually assume that the value does not change when the invalidation happens, which contradicts the purpose of invalidation.
All existing tests are currently green, and ones I added too; but I need to add more tests to check subtler consequences of my changes. I can't guarantee that I will do it fast, but if you have time, let me have a try on this one.
This is causing some very serious issues for us.  I would argue that anyone using a lazy-loading cache would expect a happens-before relationship between invalidate and a following call to get, but since it can piggy-back on an existing load operation that fetched data before invalidate was called, that relationship does not exist.
I started poking around in here to try to fix it, but as @lowasser hinted, it isn't trivial.  The main problems are
```
1. Whether to remove the LoadingValueReference, block on it, or somehow mark it as stale; and
2. How to rework the removal notifications
```
This is sufficiently painful that at this point I'm inclined to switch to another library, instead.
@txshtkckr Please see https://github.com/baltiyskiy/guava -- I've went with the "remove LoadingValueReference" approach, firing removal notification for the value when it is loaded. It's generally done, but I'd like to add some tests cases there. There's one known problem (regaring `modCount`) which I need to poke more.
I've put it on a pause now because I don't have much time due to other commitments, but I intend to finish it.
Has there been a consensus how to work around this particular problem? If so, it should be included in https://github.com/google/guava/wiki/CachesExplained  creat method:
![qq 20141105153403](https://cloud.githubusercontent.com/assets/9320176/4914158/8b15dc10-64be-11e4-9d48-9870e165b74f.png)
readFrom method
![qq 20141105153422](https://cloud.githubusercontent.com/assets/9320176/4914159/8b19cd98-64be-11e4-8d1c-d576887a6d23.png)
is there right?
BloomFilter has writeTo method,that i can serialize it to file.but,i found it is slow and the serialized file is to big.i want use Kryo to serialize.but,when i use Kryo,it happed exception.So,how can i replace it?
the exception is Kryo use asm.jar to reflect sum.nio.cs.UTF_8,but there is no access.
I want to use Kryo,because Kryo is very fast and file is small,only 153M.but ,it has 1.2G when i use BloomFilter.writeTo() method  . How can I improve my speed, and makes the serialization files smaller
I am a Chinese, I say relatively poor English, I hope you can understand what I mean
This changeset adds support for [Travis CI](https://travis-ci.org/) as publicly visible means of continuous integration (additionally to the probably internally running CI system at Google).
Travis CI is configured to build Guava with Oracle JDK 7, OpenJDK 7, and OpenJDK 6. Oracle JDK 8 hasn't been added to the list because of the currently unresolved issues with building Guava with Java 8.
In order for this changeset to work, someone with the appropriate permissions on the Guava repository will have to activate the build on Travis CI, see [Activate GitHub Webhook](http://docs.travis-ci.com/user/getting-started/#Step-two%3A-Activate-GitHub-Webhook).
I have signed the Google individual CLA.
The `guava-parent` Maven POM still contains URLs pointing to Google Code for issues and SCM. This changesets updates the respective URLs to their counterparts on GitHub.
I have signed the Google individual CLA.
The function maybe uses like this:
long factorial = Collections.reduce(Lists.newArrayList(1,2,3,4,5), new Function(){
long apply(int x, int y){
return x*y;
}
})
So Guava moved to Github! This is my first (and very small) fix: I spotted improperly closed tag in [ByteArrayDataInput's Javadoc](http://docs.guava-libraries.googlecode.com/git-history/v18.0/javadoc/com/google/common/io/ByteArrayDataInput.html). Should be OK now.
No problem, I've just signed individual CLA.
I was directed here in a discussion of https://issues.cloudera.org/browse/DISTRO-638 ("Cannot install Cloudera Manager Agent if hostname starts with a digit") where the origin of that issue is that Docker generates hostnames as random hexadecimal strings, which do therefore quite often start with a digit. (And they refuse to change that, insisting that it is totally RFC-compliant to start with a digit, as long as there is also any normal letter in the hostname: https://github.com/docker/docker/issues/7756, https://github.com/docker/docker/pull/8194)
I would therefore very much like to see a change of behavior from "fail if first character of TLD is a digit" to "fail if all characters of TLD are digits".
tgpfeiffer there is a patch for that you can even patch it easy your self with simply adding a random letter fixed in front of the container name via editing docker src and making a fork
This should be closed.       Sorry - yes agree totally with that - and deleted original comment when I meant to edit it!!
Hi !
Admitting your sub-class name ends with `Converter`, this "false positive" can be filtered with this rule instead of overriding `hashCode()` in every sub-classes :
```
<?xml version="1.0" ?>
<FindBugsFilter>
<Match>
<Class name="~.+Converter" />
</Match>
</FindBugsFilter>
```
By the way, do you have any idea when this will be fixed ?
Thx
IMHO the `Converter.equals` javadoc is not really useful as 1. it states the obvious and 2. I'd be surprised if anyone has ever overridden it. I'd bet that anyone smart enough to find out that they need to override equals for `Comparator`, `Function`, `Converter`, or alike is smart enough to know that equal objects must behave the same.
This would be a parallel of Class.asSubclass, yes? Something like the following:
```
@SuppressWarnings("unchecked")
public <U> TypeToken<? extends U> asSubclass(TypeToken<U> sub) {
if (sub.isAssignableFrom(this))
return (TypeToken<? extends U>)this;
throw new ClassCastException(String.format("Cannot cast %s to %s", this, sub));
}
```
Hi! It has been a long time, but I think this is exactly what I thought of.
IMHO the term "Subclass" in the method name is misleading, as here we can have any subtype.
E.g.
``` java
TypeToken<? extends List<?>> type = new TypeToken<ArrayList<Integer>> {};
type.asSubclass(new TypeToken<List<Integer>> {}); // this should work
```
Maybe there could be two versions:
`<U> TypeToken<? extends U> asSubtype(TypeToken<U> other)`
and
`<U> TypeToken<? extends U> asSubclass(Class<U> other)`.
Sorry if I got something wrong: as I said it has been a long time.
Thank you.
I'm not sure about other places, but this is definitely already fixed for newHashSet: https://github.com/google/guava/commit/736f404aed944516aba96812ae0eab6781bf869a#diff-7e3112faa0144939dea5de95473cfd55R156
I apologize if I'm badly confused, but Map doesn't appear to define a "iterator()" method as is suggested by the RangeMap docs currently (explicitly in `asMapOfRanges().iterator().remove()` in the subRangeMap doc).
Is iteration in `asMapOfRanges().entrySet().iterator()` guaranteed to be ascending?  Or is there some other way to iterate?
I confirm that a 18.0.1 release including this fix will be really useful.
Currently, any exception thrown inside a @Subscribe-annotated method is lost and that's troublesome for debugging.
Could you please consider search a minor release?
> int i = Ints.tryParse()
Furthermore, users who strive for performance and are willing to pay the price of clarity might want to use specifically dedicated code optimisations anyway to make it even faster (e.g., see previous comment). `Optional<Integer>` sounds rather perverted due to double boxing. But there's `OptionalInt`, which is singly boxing just like `Integer` and more usable.
> Did we have any reservations that tryParse("foo", 10) might look like it's providing a default value rather than a radix?
I can only tell, that it definitely looks like the default value. What about `OptionalInt Ints.parser(radix).tryParse(string)`? It creates a new tiny object holding the radix, but in performance-critical code it can be reused. This way, you don't need a new name and you could also add `int Ints.parser(radix).tryParse(string, defaultValue)` without risking any confusion. @Maaartinus The problem however with `OptionalInt` is it lacks certain key methods which `Optional<Integer>` has built-in, like `map` and `filter`, which arguably makes `OptionalInt` not as easy to use. But, saying that, it's not clear to me which would be more important here: performance or usability.  any plans to address this?
The `loadCount` has a direct relationship with `loadSuccessCount` and `loadFailureCount`, and can be used with `totalLoadTime` (e.g. `averageLoadPenalty`). That helps determine how expensive a miss operation is. By inspecting the hit rate one can better understand how to improve performance (increase the cache size or reduce the load time). The `evictionCount` has a similar relationship.
`putCount` is a metric without much meaning behind it. The cost of creating the entry isn't clear. Other additions along that line of thought might be `invalidationCount` for manual removals of entries. These appear to be metrics that could be captured, but don't carry much weight by themselves. While it might be nice to be baked in, a user can just as easy add a counter after performing the operation.
Ideally users wouldn't manually manage the cache very often. Even if they did, I'm hard pressed to think of how this extra information would be useful from an operational standpoint
Imagine a situation where cache is typically populated with **put**, but sometimes loads data, if there was a miss, Some kind of write-through cache., where value can be loaded, if it wasn't written.
Currently there is no way to find out how many requests was consuming pre-calculated values and how many requests was loaded by cache.
I guess my question is how does that metric (loaded vs pre-calculated insertions) provide operational insights? In what scenarios would you leverage this insight to make improvements?
If I want to minimize number of loads compared with number of puts.
I have submitted a pull request to fix this.
https://github.com/google/guava/pull/2243
`union()`, `intersection()`, and `difference()` were added to `ImmutableRangeSet` in 04a28f4dd8.    The issue got migrated and closed:
https://github.com/gwtproject/gwt/issues/8805
But we now get the same issue with ImmutablList$SubList, mainly because RegularImmutableList.subList now returns that type instead of a RegularImmutableList. Caused by the commit: [cb3a29fb67936c2bc52b1cfee08cedab62950282](https://github.com/google/guava/commit/cb3a29fb67936c2bc52b1cfee08cedab62950282)
While it is possible to add `@Nullable` to `equals` for own code, it may not always be possible to do this for generated code. For example, the AutoValue team decided to not do this (https://github.com/google/auto/issues/73).
Thus I think that `NullPointerTester` should special-case `equals` and behave correctly whether the annotation is present or not. After all, the JavaDoc of `equals` specifies explicitly that the parameter can be null.
+1
+1
+1 +1              The reason Collections.unmodifiableMap is not a good workaround is because what I want is a simple, reliable map builder. It's too bad this implementation doesn't just work for maps. My use case is columns in a database table, some of which accept null values. Why is this not legit? @orbfish I think it's because, unfortunately, `null`s cause far too many bugs in real-life applications, and the Guava team wants to avoid that. (Programmers forget all the time that `null` can be assigned to variables of object types in Java, which causes unexpected `NullPointerException`s).
`Optional` is a little bit better, because at least it's explicit about the potential case of an instance being "absent" (which `null` is sometimes used to represent). But it's not a complete solution to the problem for various reasons.
I think what we really need here are "nonnull" types, which are types where `null` is _not_ a valid value. Unfortunately, there are no plans yet by Oracle to investigate such types in OpenJDK AFAIK, and I doubt Oracle will begin investigating them until some point after [Project Valhalla](http://openjdk.java.net/projects/valhalla/) (Value Types) reaches its conclusion, as Project Valhalla is hideously complex and may very well affect everything in the Java language, meaning it would be very difficult for Oracle to do other large-scale language investigations at the same time (like looking into "nonnull" types or a similar solution).
Just thought I'd express my personal thoughts on this matter. :) Even if Oracle decides to rewrite their database, I'm in a situation where we would not be able to redo all the tables. It's frustrating - I understand why nulls are not desirable, but I'm still finding Guava handy enough to use a lot, but opinionated in such a way that I'm having to write an entire wrapper library around it to deal with reality. Unfortunately, I find that I don't have time to rewrite Jdbc for this project. ;) I'm trying to create a map of database columns to values. Some of these values need to be null (real null, not Optional "null"). I implemented my code with the Guava immutable map builder, and found that it failed at runtime due to null values. So I'm writing another map builder to do this. I've also found that some of MoreObjects is very useful, but only if I wrap it in a null-safe version (again, for database interaction, not for a case where I can replace null with Optional).
I'm curious (in a kind way) as to why you can't simply use either of Java 8's streams or Guava's functional constructs (or even using `Optional.ofNullable` manually) to "map" each `null` value from your database column into a `java.util.Optional` or Guava Optional before storing it in your immutable map. First 2 questions:  I could store an Optional in the map - but I'd have to render that back to a map with nulls before feeding it into JdbcTemplate.
Last question:  ease of use. I want my code to be more readable. Heres what I do:
```
public static final Object JDBC_NULL = new Object();
```
Then in your calling code you can say this:
```
Object cell = map.get(columnName);
if (cell == JDBC_NULL) {
...
} else {
...
}
``` I think most people find Java's map initialization to be unbeautiful. Here's an interesting comparison (rather than me spending 15 minutes writing out the legacy version):
Otherwise, you have 2 options: instantiate a `LinkedHashMap` and populate it manually (as @lowasser already suggested), or create your own null-friendly map builder (which would look pretty but require quite a fair bit of testing I imagine!) As I said above, I wrote another map builder. More intuitive for anyone else who needs to use it, I think. This class would be extremely useful if Guava devs let the developer be responsible for his own code. Instead we're forced to write another map builder because people are afraid that devs will not check for null... c'mon. There are plenty of 3rd party code that happily works with nulls in maps (at least as values). I find builder pattern elegant and would like to use guava's ImmutableMap for this purpose but I can't, shame. Null is a normal object state in real-world programming and few are the cases you don't want to check for them. I would agree with you if this class removed lots of code, but it instead just force me to not check for nulls - just an if. And just because of an if - a convenience, like you said - people using Guava are forced to write duplicated code just to fit some null values that may come in.
But for what I've seen here we're better just doing it the old way. I've learned to code without `null`, I write so much less code, not "just an if" less. An `if` is usually 3 lines, but it blocks you way beyond you can imagine. I write less code because I don't check for null, I inline/stream much easier.
The Guava devs have said they will not change `ImmutableMap` to support `null`. Well, nothing forbids you to write your own null-friendly collections with Guava-inspired builders, make them available and forge a community around them.
I'm personally very happy with the choices, you aren't. A line must be drawn somewhere to make the project go further. I'm sorry you're not (yet) on the same side of the line; maybe the inventor of `null` can make you [change your mind on `null`](https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions)? That's triumph of ideology over real life, i.e. what the current state of Java as a language and ecosystem is. Just to clarify: I don't need convincing that my life would be easier without `null`. But a lot of existing code deals with nulls in maps and IMHO it's unfortunate choice to not provide at least a separate implementation with `null` support. As I've said null is a normal object state in real-world programming and we need to deal with it. You are happy with not having to write checks, good, but from "my side" I'm forced to pick the ImmutableMap and create a duplicated class with support for nulls, and this is simply not acceptable because, I repeat, null is a perfectly normal state of an object in real-world programming and therefore just saying "don't use nulls" is not justifiable. But as I said, I don't expect the devs to change their mind, so I'll just keep it the old, duplicated, way. @Ryaryu Could you clarify for me if you want an immutable data structure that can contain `null` elements, or an immutable data structure that _filters_ out given `null` elements at construction time? @jbduncan Can contains null values. If you filter the null elements at construction time you defeat the purpose of the devs since you'll be forced to use containsKey unless you traverse the key set, right? I want to be able to react the way I want to null values in the map, for this reason I am simply duplicating the class with null support nowadays. > If you filter the null elements at construction time you defeat the purpose of the devs since you'll be forced to use containsKey unless you traverse the key set, right?
Not so AFAICT.
I realise I was a bit unclear in what I was asking, apologies!
What I meant to ask, with regards to null-filtering, was if you wanted an immutable map where, during construction time (using, say, a builder), if a given entry (key-value pair) has a `null` key or value, then the map builder should simply not insert the key-value pair into the end-result map, and it should do so silently (as in it should not throw a `NullPointerException` or equivalent).
If we take what I meant to ask above, then `null` values shouldn't even exist in the end-result map (since they'd have been effectively _filtered_ out before the map was created), so by my understanding checking for the existence of `null` values with `containsKey()` shouldn't be necessary. But anyway, it's clear to me now that what you're really after is an immutable map with potentially null values. Thanks for clearing things up for me! > What's wrong with the workaround of using Collections.unmodifiableMap on a mutable map?
Will unmodifiableMap produce concurrent modification exception if I modify underlying map while iterating this unmodifiableMap? If yes then its not a workaround at all
upd: yes it does throw That's what I needed too! Ended up having to write my own.
On Thursday, April 27, 2017, Jonathan Bluett-Duncan <
notifications@github.com> wrote:
> But anyway, it's clear to me now that what you're really after is an
> immutable map with potentially null values. Thanks for clearing things up
> for me!
>
> 
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/1782#issuecomment-297714687>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AHTqdqZr9Rq6mc8UuOoh4wFkXRgxvtF4ks5r0JmZgaJpZM4C1jsV>
> .
>
Sorry @jrtom looks like I never replied to you. I can't have a special null
object, because this is being passed into jdbc, where a null value means a
null column in the database, which is sometimes needed. For this reason, I
need null values - in terms of the database, they're valid, not a coding
On Mon, Dec 26, 2016 at 5:44 PM, jrtom <notifications@github.com> wrote:
> @orbfish <https://github.com/orbfish>, you don't need to create a whole
> new wrapper library. You can either create a special Null object (if you
> <https://github.com/kak> suggested. The latter would cause you to
> explicitly handle null objects in your code, which seems like a good thing.
>
> 
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/google/guava/issues/1782#issuecomment-269252310>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AHTqdkrMZphGcZ2z2Uz6-YCFhxEh8GR-ks5rMF9XgaJpZM4C1jsV>
> .
>
This basically makes ImmutableMap useless for me. @nitehawk42 Have you tried any of the suggestions above, like replacing `null` with a special "null" object or using `Optional` wrappers?  A high quality RangeTree structure would be useful for genomic work.
I've also run into this issue, currently you can't use a RateLimiter in a unit test using a fake Ticker.  I don't think this is a duplicate; the referenced "duplicate" seems unrelated.  That one was a bug, this one is a feature request, one I'd like to see. Hmm but how would you _unregister_ a subscriber?
The register method could return somekind of ID and internally track subscribers, but that seems like a not so minor change... Hmm, a fair point, but if you wanted to be able to unsubscribe, you could just put the lambda in a variable.  Or even just use the normal, more verbose way of defining a subscriber.  And in many of the circumstances I've subscribed lambdas to things, before, I simply never unsubscribed them; they were active for the entirety of the program.  The id mechanism does sound useful, but not strictly necessary. > ...but if you wanted to be able to unsubscribe, you could just put the lambda in a variable.
How would putting it in a variable allow you to do that? Presumably the same as a normal object;
```
Consumer<String> callback = (String s) -> System.out.println(s);
eventBus.register(callback);
// Later
eventBus.unregister(callback);
```
Not quite as tidy as
`eventBus.register((String s) -> System.out.println(s));`
but better than the 7-10 line current alternative.
Granted, this might cause confusion if somebody's trying to register a subclass of `Consumer<T>` but they don't want to register the `accept` method.  I guess you could overload the `register` method specifically for `Consumer`s, or even just have a separate method, though that's a little annoying. > Presumably the same as a normal object;
>
> Consumer<String> callback = (String s) -> System.out.println(s);
> eventBus.register(callback);
> // Later
> eventBus.unregister(callback);
> ```
That makes sense to me. Thanks for the clarification!  I'm not sure about this example:
```
public void bla(List<Blub> list) {
checkThat(list).describedAs("list has to be not null and not empty").isNotNull().isNotEmpty();
}
```
I'd rather see:
```
public void bla(List<Blub> list) {
checkThat(list).describedAs("list").isNotNull().isNotEmpty();
}
```
The library can surely handle a little string concatenation to produce a meaningful error message with this much information.
(This is also my main beef with Preconditions.check methods in general. I can only choose between two equally unacceptable options: (a) checkNotNull(value), which as a library user, doesn't tell me which parameter was null, or (b) checkNotNull(value, "value is null"), which forces me as a library developer to say what I'm checking twice, plus adding a caveat that someone has to update both in sync, or introduce an incorrect error message. FWIW, my other beef is that it throws the wrong exception. If I wanted a NullPointerException, I could just not check the parameter!)
There is no class called 'UninterruptiblesTest'.
Am I missing something? or was this class deleted?
I would also like to see this implemented. One of the ideas I have is to generate bit sequences of k bits set out of total n bits and then the combinations simply correspond to k bits that are 1. Doing this would be much more efficient than going through Collections2.permutations (generates lots of duplicates) or Sets.powerset (limitation of 30 elements)
For my String processing usecase, I adopted this algorithm - it will be universally applicable for generating the bit sequences.
Looks like this was picked up and implemented in Release 23!
https://github.com/google/guava/wiki/Release23
"Set<Set<E>> Sets.combinations(Set<E> set, int size): returns all subsets of the given set that have the given size"   I'd suggest using the following implementation instead (still throwing `ClassCastException`), since `IllegalArgumentException` implies user-error, whereas you're suggesting using this method in cases where the programmer believes this invariant is enforced. This seems like a similar feature to [`Throwables.getCauseAs()`](https://google.github.io/guava/releases/22.0/api/docs/com/google/common/base/Throwables.html#getCauseAs-java.lang.Throwable-java.lang.Class-), which throws `CCE`.
```
public static <A, B extends A> B checkType(A value, Class<B> target, String name) {
checkNotNull(value, "%s is null", name);
if (!target.isInstance(value)) {
throw new ClassCastException(String.format(
"%s must be of type %s, not %s",
name,
target.getName(),
value.getClass().getName());
}
return target.cast(value);
}
```
The existence of `Throwables.getCauseAs()` suggests this might be a good general-purpose addition, but on the other hand `Throwable.getCause()` is a somewhat special case, as there's no way to enforce the cause's type at compile-time.
---
Edit: a standard `(Foo) bar` cast includes the types in the error message ("*java.lang.ClassCastException: Bar cannot be cast to Foo*"), but I think there's still some value in including user-provided context alongside the types in question.  I'm running into these same problems, thought I'm not sure that dropping the queue nature of the event bus is a good idea --I actually rather like it at least conceptually. There are also a couple places where I leverage the queue for a particular feature.
Anyways, the bug me and my company are running into is also in a GUI'd app, where we have worker threads and a UI thread that should be avoided.
This test illustrates our problem:
public void when_using_relatively_simple_chain_of_events_should_cause_deadlock(){
//setup
EventBus eventBus = new EventBus("testing");
SubscriberX subX = new SubscriberX(eventBus);
//act
eventBus.post(new EventA());
//never reach here, deadlock
}
public static class SubscriberX{
private final EventBus eventBus;
public SubscriberX(EventBus eventBus){
this.eventBus = eventBus;
eventBus.register(this);
}
@Subscribe public void doThingsOn(IEvent event){
// and this same phenomena can be expressed in other ways,
// this was just the quickest way I thought of.
SyncingUtilities.runImmediatelyOnFXThread(() -> {
if (event instanceof EventA) {
eventBus.post(new EventB());
}
});
// the key thing to note about this code is that maybe it dispatches an asynchronous job,
// and then attempts to synchronize back-up on the UI thread after its done.
// in this way our subscriber is hopping around between threads
}
}
public interface IEvent{}
public static class EventA implements IEvent{}
public static class EventB implements IEvent{}
}
```
_Our implementation of [`SyncingUtilities.runImmediately()`](https://gist.github.com/Groostav/4a9252d17700f7aabe0e21da10fb52a8)_
So, yeah, this is happening on our codebase with increasing frequency, and I'd like to see a fix.
Requiring Java 7 for now is not a big problem, but the build should detect it and fail immediately with a nice error message if run using Java 8.
> Even if they are compiling from source, is it really major issue that Guava needs JDK 7 to compile? I guess it could be annoying if you're just trying to build Guava in your IDE to experiment with it and your only JDK is JDK 8.
FWIW compiling from sources is important to Linux distributions like Debian and Fedora. This issue is [tracked](https://bugs.debian.org/751544) by Debian as part of its transition to OpenJDK 8. Fedora is already building with Java 8 and applied a [patch](http://pkgs.fedoraproject.org/cgit/guava.git/tree/guava-java8.patch) to work around this issue.
This was fixed a while back in this commit.  The bug was in the test
https://github.com/google/guava/commit/eb68100cc9a30cb7cca03dbe0eebad8d5e76b5b1
Iterables and Iterator can be used when iterating over very large data sets that do not fit in memory so that can easily be more than int.
So I agree this would makes sense to use long here or even BigInteger here.
The original reason this was not done is because it added complexity, was intended for a performance vs functionality sprint, and requires coordination across segments. The smart batching was part of the original design and pushed into the backlog on the internal tracker.
As we wanted to eventually migrate to `ConcurrentHashMapV8`, performing smart batching would require to again fork the hash table which we didn't want to do again. So the JavaDoc was left open ended and an implementation note added to `LoadingCache#getAll()`. That way external implementations could implement it as they see fit and comply to the API.
The only way to add this feature in a decorator model is by a lock per entry or a lock striped array. Doing that with a j.u.c. `Lock` is heavy and other options are inefficient. Unfortunately using intrinsic object locking (aka `synchronized` - `monitorEnter` and `monitorExit`) can't be done efficiently. The language doesn't allow batch synchronized acquisition and release (w/o a recursive hack). The `Unsafe` methods are very slow due to the JVM not optimizing for unverified usages. So this has to be done at the internals of the hash table or very carefully optimized above it. That's a lot of work for a rarely requested optimization, given that the backing store is may be smart as well (e.g. some memcached clients perform request combining).
As Chris said, though, the AsyncLoadingCache can easily support this mode because the future is basically our lock object.
+1 for this.  It's surprising to have stringConverter for every primitive except Booleans.  For symmetry's sake it makes sense there should be one for Booleans, and that it should have the same .toString() / parseX() implementation as the others.  I actually spent a while looking for it, because I was convinced that it must exist and I was just missing it.
I agree Boolean is more special than Integer, but I think the same
arguments apply to Float, Double, and Enum.  Does Doubles.stringConverter
preserve all digits of precision?  Does it use scientific notation or lots
of zeros?  What does it do for null?  Same for Enums.stringConverter - is
it case-sensitive when reading?
You're right to shutdown my symmetry argument, bloated common libs are
are useful for cases where the user hasn't thought a ton about edge case
behavior - they're looking for functional defaults.  If a user cares about
common, it would be nice to have a functional default.
Ned Twigg
Lead Software Architect, DiffPlug LLC
949-264-3433
340 S Lemon Ave #3433, Walnut, CA 91789
On Wed, Nov 5, 2014 at 8:12 AM, kevinb9n notifications@github.com wrote:
> Most users will say "well, logically we figure it should use
> Boolean.valueOf()". But how many of these users could tell you off the top
> of their heads what Boolean.valueOf() does? What does it do for null?
>
> That there is an expectation for it to call method X does not mean that
> people actually expect that behavior, and it also doesn't mean it's the
> safest behavior.
>
> At this point I still stand by my previous points:
>
>    1.
>
>    behaviors they might assume.
>    2.
>
>    you want, which will leave your readers actually knowing what is going on
>    with no surprises.
>    3.
>
>    If this converter does exist, the most conservative behavior is to
>    reject any input but "true" and "false". 95%+ of usages will probably be
>    just fine with that, and the rest, who see an exception, will be prompted
>    to decide what they want. No surprises can lurk undetected.
>
> Btw, as reasons to add a library feature go, for us "symmetry" ranks
> not just seem like it is rounding out a complete set of something.
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/1710#issuecomment-61832350.
Is there any progress on exposing this API? I'd like to configure burst too and the underlying implementation seems to support bursting just fine, it's just not exposed.
Thanks!
I am, too, interested in this.
+1
+1
+1
+1
+1
+1
+1
+1
+1
I seem that the solution is on SmoothRateLimiter.SmoothBursty.
I see that maxPermits = maxBurstSeconds \* permitsPerSecond;
However maxBurstSeconds is hardcode.
I try to extends RateLimiter and add another constructor with maxBurstSeconds parameter.
public class RateLimiterWithCapacity extends RateLimiter {
public static RateLimiter create(double permitsPerSecond, double maxBurstSeconds) {
return create(SleepingStopwatch.createFromSystemTimer(), permitsPerSecond, maxBurstSeconds);
}
@VisibleForTesting
static RateLimiter create(SleepingStopwatch stopwatch, double permitsPerSecond, double maxBurstSeconds) {
RateLimiter rateLimiter = new SmoothRateLimiter.SmoothBursty(stopwatch, maxBurstSeconds /* maxBurstSeconds */);
rateLimiter.setRate(permitsPerSecond);
return rateLimiter;
}
}
```
And work well. Can I pull this requests? or raise any risk problem.
It seems that it really doesn't matter whether you pick the time-invariant option or the permit-invariant option. Either will expose the same useful capabilities.
Can you please just pick one and get it included with the public interface?
My preference is for the option with time-invariant semantics. Maybe with new/updated interfaces like the following:
| Modifier and Type | Method and Description |
| --- | --- |
| static RateLimiter | create(double permitsPerSecond) |
| | Creates a RateLimiter with the specified stable throughput, given as "permits per second" (commonly referred to as QPS, queries per second). This is equivalent to calling create(1, TimeUnit.SECONDS, permitsPerSecond).  |
| static RateLimiter | create(long permitPeriod, TimeUnit permitUnit, double permitsPerPeriod) |
| | Creates a RateLimiter with the specified stable throughput, given as "permits per period". When the rate limiter is unused, bursts of up to permitsPerPeriod permits will be allowed, with subsequent requests being smoothly limited at the stable rate of permitsPerPeriod. |
| static RateLimiter | create(double permitsPerSecond, long warmupPeriod, TimeUnit warmupUnit) |
| | Creates a RateLimiter with the specified stable throughput, given as "permits per second" (commonly referred to as QPS, queries per second), and a warmup period, during which the RateLimiter smoothly ramps up its rate, until it reaches its maximum rate at the end of the period (as long as there are enough requests to saturate it). This is equivalent to calling create(1, TimeUnit.SECONDS, permitsPerSecond, long warmupPeriod, TimeUnit warmupUnit) |
| static RateLimiter | create(long permitPeriod, TimeUnit permitUnit, double permitsPerPeriod, long warmupPeriod, TimeUnit warmupUnit) |
| | Creates a RateLimiter with the specified stable throughput, given as "permits per period", and a warmup period, during which the RateLimiter smoothly ramps up its rate, until it reaches its maximum rate at the end of the period (as long as there are enough requests to saturate it). |
| double | getRate() |
| | Returns the stable rate (as permits per period) with which this RateLimiter is configured. |
| void | setRate(double permitsPerPeriod) |
| | Updates the stable rate of this RateLimiter, that is, the permitsPerPeriod argument provided in the factory method that constructed the RateLimiter. |
| long | getPeriod() |
| | Returns the permitPeriod in nanoseconds with which this RateLimiter is configured. |
+1     I could use a parse method to do the opposite of a custom Escaper. And I mean this in a generic way, not for parsing URL's or URI's as the author initially requested.
I have some custom encoding of arrays in an i18n bundle (in a GWT application) and I want to unescape the texts between the split characters. (But again just a simple use case, their might already be alternative solutions)  Hi, I am interested in trying this.
Has anyone started working on it? Do we agree to use 200 as the max value?
Thank you for the detailed analysis and feedback.
I took a closer look at the class and would have to agree with your assessment.
Then the following could make sense (save a few bytes in case of a small limit)
```
private static final int MAX_PRESIZE_ARRAY_SIZE = 10;
if (!iterator.hasNext()) return Collections.emptyList();
List<String> result = new ArrayList<String>(Math.min(limit, MAX_PRESIZE_ARRAY_SIZE));
do {result.add(iterator.next());} while (iterator.hasNext());
```
This is a feature that I'd really appreciate as well!
+1 from me!
http://antrix.net/posts/2014/codahale-metrics-guava-cache/
The concern with allowing a custom StatsCounter is that foreign code is executed and the cache must guard against abuse.
Some stats incremented under the lock, others in the finally block when the lock is being released. An exception should not leave the cache (or its locks) in an invalid state. This leads to the question of how the cache should handle the counter failing: should the operation be rolled back or the exception caught and logged? If the counter is slow, such as making network calls, this would greatly expand the lock hold times.
I like the idea of allowing custom counters, but tolerating hostile foreign code requires a bit of thought. The easiest and probably most correct would be to have CacheBuilder decorate a custom counter to swallow and log all exceptions thrown.
Ping? My offer to help still stands :-)
It's a pity that this has not been done yet.
In my OSGi project I depend on Guice 4.1, which needs Guava 19.0 and on an Apache library which depends on Guava 15.0.
The Apache library imports Guava packages as [15.0, 16.0) which means it does not resolve in the OSGi runtime with version 19.0, so I cannot simply use maven dependency management to force version 19.0. I worked around the problem by publishing Guava 15 to my artifact repository using  a different group-id.
Any chance the Guava team can look into this for future releases?   +1
+1
I am also interested in this. Would it make sense to start implementing this on my side (and open a pull request) or would this duplicate existing progress?
Regarding "Just offer a TypeToken parser", that's too limited a solution. The functionality provided by `Types.newParameterizedType()` is generally useful.
For example, I came across another use case whereby I needed a method that would "wildcardify" any raw type. For example, for some class `Foo` with 3 generic type parameters, this would return `TypeToken<Foo<?, ?, ?>>`. Of course in general it would work with any `Class<?>` parameter.
The easiest (only?) way to do this was to call `Types.newParameterizedType(rawtype, array)` where `array` is an array of unbounded `? WildcardType` objects constructed manually.
Yep, that's right... didn't think of that.. though that's a little messier, especially when the number of generic type parameters can vary.
FWIW here's what I'm currently doing...
``` java
private static final WildcardType QUESTION_MARK = new WildcardType() {
public Type[] getUpperBounds() {
return new Type[] { Object.class };
}
public Type[] getLowerBounds() {
return new Type[0];
}
public String toString() {
return "?";
}
};
...
/**
* Parameterize the raw type with wildcards.
*/
public static <T> TypeToken<? extends T> getWildcardedType(Class<T> type) {
if (type == null)
throw new IllegalArgumentException("null type");
final TypeVariable<Class<T>>[] typeVariables = type.getTypeParameters();
if (typeVariables.length == 0)
return TypeToken.of(type);
final WildcardType[] questionMarks = new WildcardType[typeVariables.length];
Arrays.fill(questionMarks, QUESTION_MARK);
return Util.newParameterizedType(type, questionMarks);
}
```
However I still would rather see the more general functionality exposed. There are sure to be other use cases that could benefit besides the ones I've come across.
Yes I agree my current solution is a hack... right now there's no other (easy) way to do it. This is of course more evidence that there are functionality holes remaining to be filled. Thanks.
My current use case requiring `WildcardType` is that I'm trying to build a list of all supertypes of a type.
As a side note, a parsing method would be nice to have for it's own reasons. E.g. it would make it easy to serialize a `TypeToken` in an XML document.
> By getTypes() not including wildcard types, do you mean this?
I mean the output of:
``` java
import com.google.common.reflect.TypeToken;
public class xx {
public static void main(String[] args) throws Exception {
System.out.println(TypeToken.of(java.util.List.class).getTypes());
}
}
```
is
```
[java.util.List, java.util.Collection<E>, java.lang.Iterable<E>]
```
which does not include `java.util.List<?>`.
Thinking about this more I realize now that `java.util.List` a not sub-type of `java.util.List<?>` - it's the other way around. So that behavior is correct. Earlier I thought `getTypes()` might be an easy way to "wildcard" a type (e.g., generate `TypeToken<List<?>>` from `List.class`) but that is not the case.
Here's a little more background: the code I'm working with is attempting to track types using `TypeToken`, which works great. In order to maintain type safety, it is also trying to follow a "no raw types" rule that states there should never be any raw types - all tracked types are genericized. But another requirement is that it allows a user to specify a type at runtime by providing a `Class` object. When that occurs, in order to follow the rule, that type needs to be converted into its genericized equivalent in a type-safe manner. This is when the "wildcarding" operation is needed.
Just wanted to add that a `TypeToken parse(String)` method would be useful to me. [Joda-Convert](http://www.joda.org/joda-convert/) provides a standard way to convert an object to and from a string (for JSON/XML etc). Being able to do this with `TypeToken` is desirable (as it can already handle `Class`).
I also happen to think that the API should also provide a public `newParamterizedType()` is some form. For example, I'd like to be able to store in a database the TypeToken `Foo<Bar>`, but using two columns, one for `Foo.class` and one for `Bar.class`. While putting it together again using a `parse()` method would work, a `newParamterizedType()` would be more obvious. And yes, I understand the risks of creating stupid types.
Just wanted to add that public `newParamterizedType()` is what I need too. It seems all reasons where already given and the proposed `parse` method sounds just cool. However, manually constructing `"List" + "<" + "String" + ">"` just to get it parsed sounds awkward.
If the `Types.newParamterizedType()` in Guava is not as public-ready as the one already public in Guice, why don't you copy/move that one into Guava? It's seems that the Guava is THE library for all Java shortcomings, not Guice.
Alternatives to throwing in Guice into the projects are using Apache `TypeUtils` or Spring 4 `ResolvableType`. Either way, it just doesn't seem right when using `TypeToken` API to have to go to another library (Guive, Commons Lang or Spring) just to construct equivalent of `TypeToken<List<String>>` where "List" and "String" are given at run-time.
PING.
2.5+ years and still waiting for `Types.newParamterizedType()` to be made public... can we get some resolution to this?
To summarize: **there are legitimate situations where we need to convert a raw class (represented by a `Class` object) back into its generic type (represented by a `TypeToken` object) using caller-supplied type parameters (represented by `Type` objects).**
This is exactly what `Types.newParamterizedType()` does.
It's there. It's useful. _Let's do this!!_
I have an abstract base class in my codebase which has a method that should be protected, but we have tests that want to access it. Essentially I want to mark it
```
@VisibleForTesting(visibility = Visibility.PROTECTED)
public final void doSomething() { ... }
```
but right now, I can't. Instead, I've left a comment:
```
// This method should only be called by tests and subclasses
@VisibleForTesting
public final void doSomething() { ... }
```
but that feels more easily ignored, plus I can't ever expect static analysis tools to help me detect it if those come online later.
I suspect there may be pushback, like: You should instead be writing your tests differently so they interact with a test subclass that exposes this method publicly, or something. Of course, it's doable, but because of much of the existing code, it wouldn't be trivial - it would involve punching holes in a bunch of nested classes.
Well it looks like my comment on 2/15/2015 about this no longer being an issue was incorrect :(
liberal use of Futures.withTimeout triggers some pretty rough behavior relative to this since it internally cancels the timer future in the common case (no timeout), and even in the timeout case the cancellation cause is not particularly useful.
So a 'harmless' refactoring of a ScheduledExecutorService to a ListeningScheduledExecutorService will greatly increase the cost of Futures.withTimeout due to this line
https://github.com/google/guava/blob/master/guava/src/com/google/common/util/concurrent/Futures.java#L937
Cancelling the timer futures is a bit of an optimization itself since for a ScheduledThreadPoolExecutor with the removeOnCancel policy set it is likely to save memory in the common case.  So it would be unfortunate to remove that call to 'timer.cancel()' since it may increase memory pressure.
1. just remove the cancellation cause mechanism (other futures don't have it :/)
2. allow global static configuration so servers can set it in canary/test environments or maybe temporariliy to help debugging (maybe use a System property?)
3. All threadlocal static configuration so individual 'cancel()' callers can disable the behavior.
I was mostly thinking that the threadlocal would solve the ForwardingFuture case. (and i agree that it isn't a great solution anyway)
Of course the ideal solution would be to add an overload of cancel to ListenableFuture
`boolean cancel(boolean interrupt, @Nullable Throwable cause)`
and then we could (with some work) make it always do the right thing.  With java8 default methods we could even add it in a (mostly) backwards compatible way.
Re: ForwardingFuture  would we always have ForwardingFuture implement CancelableWithCause or maybe that would just be up to the user.  If it was opt-in i think that would solve your concerns ( ForwardingCancelableWithCauseListenableFuture.?.. ugh)  for usability we would really want a single interface type to pass around (ala RunnableFuture) so users/libraries could avoid a bunch of instanceof casts, but that is also annoying :/
Re: Android I don't really remember why i cc'd those guys  probably some long lost in person conversation.  I'll reach out to them and see if they want to comment.
I'll play around with the CancelableWithCause approach, see what it looks like.
You should totally update the Caches Explained wiki to mention this API! :100:
Any examples on how to use asyncReloading?
I'm using CacheBuilder with Spring cache.
Presumably it's automagically creating a default LoadingCache somewhere along the way to the @Cacheable but it'd be nice to configure a cache that does async reloading without having to override CacheLoader.reload()   For unit testing a method that takes a {Char,Byte}{Source,Sink}, what is the recommended way to do so without writing to disk?
Do teams write their own one-off implementations or is there an internal Google impl that isn't pushed publically?
Any progress on this topic?
I have accepted the CLA and will work on a patch.
I worked on it but it never went into a pull request :(
- Make the Builder itself Iterable, so that it can be added to its own addAll-Method.
- Add another addAll-Method overload to ImmutableCollection.Builder which accepts any ImmutableCollection.Builder.
I was wondering, why is `stream.collect(Collectors.collectingAndThen(Collectors.toList(), ImmutableList::copyOf))` the same efficiency as `ImmutableList.copyOf(stream.iterator())`?
It sounds like the first approach requires building an array, then copying the array into an `ImmutableList` whereas the second approach only builds the array once.
I see, thanks for the help =)
I don't think that's 100% true. ImmutableList.copyOf(stream.iterator()) is [more efficient](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L249-L255) for the special case of an iterator yielding only 0 or 1 elements, where it avoids allocating the intermediary ArrayList.
+1
Would love to see this added into the core guava codebase.  Any traction on this yet?  Should TreeMultimap.create(TreeMultimap) be a new method in API?
Like in TreeMultimap.create(Multimap)
-> natural order
or like in java TreeMap(SortedMap)
IMO TreeMultimap.create(TreeMultimap) should be a new method with specification like in java TreeMap - new TreeMultimap with ordering from other TreeMultimap.
Pull request:
https://github.com/google/guava/pull/2498
The problem is that the test creates eden-space strong-reference garbage. This will be collected by a minor collection, whereas soft references requires a major collection. The correct way to do this is to classify the generated garbage as soft references in order to force a major gc. As the eviction is performed in LRU order, it should keep creating garbage until a flag reference was cleared, meaning that the cache's contents must have been evicted too.
The following test passes with both [Caffeine](https://github.com/ben-manes/caffeine) and Guava caches.
``` java
@Test(dataProvider = "caches")
@CacheSpec(values = ReferenceType.SOFT, population = Population.FULL)
public void evict_softValues(Cache<Integer, Integer> cache, CacheContext context) {
context.original().clear();
awaitSoftRefGc();
cleanUp(cache, context, 0);
assertThat(cache.size(), is(0L));
}
static void cleanUp(Cache<Integer, Integer> cache, CacheContext context, long finalSize) {
// As clean-up is amortized, pretend that the increment count may be as low as per entry
for (int i = 0; i < context.population().size(); i++) {
cache.cleanUp();
if (cache.size() == finalSize) {
return; // passed
}
}
Assert.fail("Expected an empty cache but has size: " + cache.size());
}
static void awaitSoftRefGc() {
byte[] garbage = new byte[1024];
SoftReference<Object> flag = new SoftReference<>(new Object());
List<Object> softRefs = new ArrayList<>();
while (flag.get() != null) {
garbage = new byte[Math.max(garbage.length, garbage.length << 2)];
softRefs.add(new SoftReference<>(garbage));
}
}
```
FYI, soft reference tests must be run sequentially and cannot use the G1 garbage collector. The first not surprising and is to avoid breaking tests that run in parallel due to out of memory errors. The second is because G1 does not provide a deterministic LRU eviction (cross region) which is much more efficient than a stop-the-world major collection, but breaks a simple detection scheme like the one above.
The best way to do this is to use `-XX:SoftRefLRUPolicyMSPerMB=0` to force soft references to behave as weak references, thereby allowing the test to safely assume a GC will clear the reference. This means running the test through the build can be reliable, but a note on the unit test has to be added for anyone running the test through their IDE.
Hi,
None of the guava methods, like Ints.tryParse nor Longs.tryParse cannot parse any non-ascii characters. There is no inconsistency here either, since Ints.tryParse in the end calls Longs.tryParse.
So as far as I can tell, not a bug.  ImmutableTable was made serializable in 5562218b96f0b262deb5c0d2288c1bcc339dbbb2.
As mentioned above, ContiguousSet.range() only works on bounded Ranges, however.  If either end is unbounded, this isn't sufficient.
Right, just like the existing behavior in `Range.canonical()`, unbounded endpoints should be left alone.
@cpovirk Are you planning to pursue this? Yes, that's why I'm interested :)
I think I can either move or delete all JDK emulation under Guava except this one though  it is not critical.  I think a sufficient and detailed explanation has been provided on the SO link for the same.
http://stackoverflow.com/q/19074393/28465
"Determines whether a character is a breaking whitespace (that is, a whitespace which can be interpreted as a break between words for formatting purposes)."
A filter construction described in a 2014 paper [1] allows for removal. The Cuckoo Filter is an alternative to a Bloom Filter that leverages partial key cuckoo hashing and a fingerprint/bucket structure.
[1] [Cuckoo Filter: Practically Better Than Bloom](https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf) Bin Fan, David G. Andersen, Michael Kaminsky, Michael D. Mitzenmacher
I think we can make CharMatcher.retainFrom() not require a negated matcher. This would eliminate the need for allocating a new CharMatcher each time it's called.
If the above is okay, please assign this issue to me.
+1
Please close this as the easiest solution would be to port the implementation from [Caffeine](https://github.com/ben-manes/caffeine), which doesn't appear to be worth the effort.
I'm still finding this issue in v18, Android platform. I only detected this because there was a NumberFormatException while trying to parse it to Long.
```
static long readFileAsLong(String path) {
String s = "0";
try {
s = Files.toString(new File(path), Charsets.UTF_8);
Log.i(TAG, path + ": " + s);
} catch (IOException e) {
Log.e(TAG, "Failed to read file" + path);
}
long l = 0;
try {
l = Long.parseLong(s);
} catch (NumberFormatException e) {
e.printStackTrace();
}
return l;
}
```
Had to trim the string to get the code working.
tried to reproduce the issue with the file
[test.txt](https://github.com/google/guava/files/617702/test.txt)
String s = "0";
try {
s = Files.toString(new File("../test.txt"), Charset.forName("UTF-8"));
} catch (IOException e) {
}
long l = 0;
try {
l = Long.parseLong(s);
System.out.println(l+1);
} catch (NumberFormatException e) {
e.printStackTrace();
}
yet no parsing error and I get the proper result.. could you please provide the file you are using?
EDIT:
I also went through unit tests and com.google.common.io FilesTest.testToString() is a good enough test that should prove there is no defect and the method behaves correctly.    Is this functionality is there already? How you guys are achieving it. I'm making few unnecessary calls which is not necessary since I can reload the entire config data into the cache.   +1
I'm currently implementing my own interface on a lot of my classes in a very similar manner:
```
public interface Funnelable {
}
```
I would very much appreciate this facility being exposed. I have need of large, reproducible hashes. I currently maintain a nearly identical class to accomplish this.
I don't have a strong opinion on that, though I agree that "concatenatedHashFunction" is a little long winded. What about simply "concatenate", or possibly "concatenatedHash", which would be in line with "goodFastHash".
I was looking for this today and was quite surprised it isn't present. Using or() after transform() is sufficient, but it would be a nice addition to the standard.
I'm actually wondering why this hasn't been fixed already given that Java 8 is out.
According to the [mailing list](https://groups.google.com/forum/#!msg/guava-discuss/dvz6EbPSat4/G6NkN8IY3KQJ) the issue was Java didn't have lambdas and thus it was awkward.
With RxJava and various other monadic style libraries I have gotten used to "staying in the monad". It is such a trivial change. I hope it gets in soon.
Would you accept a PR implementing this? I would consider this "fixed" now that `com.google.common.base.Optional.toJavaUtil().flatMap(...)` exists... We need it on Android. Our minSdkVersion is 16 so we can't use java.util.Optional yet and won't be able to for several years. @zergtmn On a sort of side note, if all else fails, then there at least exists Atlassian Fugue 2.x, which is Java 1.6 compatible and provides an `Option` type which works a bit differently to Java 8's or Guava's `Optional`, but otherwise has higher order functions like `flapMap`. On a tangental note I didn't know `toJavaUtil` was added.  I am curious how  v22 is going to backport to JDK6 with the JDK8 reference.
That is going to be interesting dealing with dependency management of that. If possible maybe make a new namespace or something? Maybe com.google.common8 or something. This is probably discussed on the mailing list but my embarrassingly lazy googling did not find anything.
*EDIT* Ah I see how as it was done with JDK5. Artifact rename and then I guess if you depend on some other project you just exclude the JDK6 dependency (or do provided in maven parlance).   Mmhhh, as already mentioned by [sameb](https://github.com/google/guava/issues/1444#issuecomment-61352265) when most people read _subtypeOf_ they assume a real subtype like Integer -> Number or Closeable -> AutoCloseable and _NOT_ Number -> Number. I would suggest renaming to _assignableTo_ as it was already proposed.
This eliminates the question sub-class vs. subtype and if there is a predicate for `subtypeOf` why isn't there a `supertypeOf` predicate?
Why not remove just the @Singleton annotation, which causes the problem, and leaves the @Inject? At least Guice users will have to only set the scope to this class if they need that.
in any case the annotations were removed and adding custom bindings for ServiceManager et.al. in your container should be straightforward
There's currently a TODO in `SubscriberRegistry.getAnnotatedMethodsNotCached()` to error out in case of a generic parameter. Maybe that should be extended to include parameterized types.
Well, for half a second I indeed got my hopes up ;-)
While I agree on the general idea of using a `Map` in a single element cache, I fear that this scenario will always lead to the developer using a wrapper to avoid that other developers store the map somewhere.
Alternatively, using the forwarding decorator that delegates `get` to `getAll` would provide this customization.
Is there a plan on implementing this? I think changing FluentIterable to do the Collection optimization is a safe and worthwhile change, and does not need to be held up by discussions about further reorganizations.
Would a pull request be useful to get this forward? I am not sure because it's such a small change but I could probably create one if wanted.
"Should" and "are" are two different things.`ImmutableSorted*.orderedBy` does **not** and will not accept `Ordering<? super T>`, as discussed in #1030. As a result, in order to create a builder for an `ImmutableSortedSet`sorted by `toString`, you have to use this monstrosity:
`ImmutableSortedSet.orderedBy((Ordering<MyType>)(Ordering<?>)Ordering.usingToString())`
Ah... I missed that part, probably because it was buried in the middle of a long comment with no code formatting. It's still not as pretty as just being able to use `ImmutableSortedSet.orderedBy`, but I guess it will have to do.
Also there are the Object.wait methods. I am guessing they are also used quite frequently.
I can make a PR, would this be something that will be added?
I'm curious if there are plans to push this out as we've written our own.
FYI you don't need a helper method to one-line this pattern (as long as you trust `initCause()` to return `this`), e.g.:
```
throw (NumberFormatException)new NumberFormatException("Failed to parse '" + number + "'").initCause(e);
```
It seems there is a significant demand for this, see e.g. most currently http://stackoverflow.com/questions/29747912/, but also the older, but massively popular http://stackoverflow.com/questions/513600/ and http://stackoverflow.com/questions/12786902/.
The standard answer is to use `String.format()`/`MessageFormat` if you care about readability and flexibility, then to use a `StringBuilder` if you need performance.
In the 90% of cases, this is good enough.
In the rest, under the assumption we don't need the flexibility of `String.format()`, a simple concatenation/`StringBuilder` can be hideous.
As of now (2015/05) and to my best knowledge, the current best is slf4j `MessageFormatter`, but its API could definitely be improved.
> It's longer than...
>
> `check(expression, MyCustomRuntimeException::new);`
>
> ...but at least some of the value of the proposed method would be the ability to provide a message,  which you can't normally get with a method reference.
What about
check(expression, MyCustomRuntimeException::new, message)
and
check(expression, MyCustomRuntimeException::new, format, args...)
The method reference can be used as a `Function<String, RuntimeException>` and that's AFAIK all you need. It assumes a single string argument constructor and you providing the formatting in the second case.
+1 for point 2. We have a utility class like that in our code base:
public final class Exceptions {
...
/**
*
* <p>This method is especially useful in combination with {@link
* java.util.Optional#orElseThrow(Supplier)}.
*
* @param format The exception message's {@link String#format format string}.
* @param args Any values to be plugged into the format string.
* @return A non-{@code null} {@link Supplier}.
*/
@FormatMethod
final String format, final Object... args) {
}
...
}
```     e.g. http://stackoverflow.com/questions/30877790/guava-splitter-for-splitting-on-space-special-character-digit and/or any other splittings where a lookahead/lookbehind is needed otherwise
+1 for adding `isEmpty()`; I just ran into a case where I could have used it.
2015 update: Apache jclouds uses `RandomByteSource` for all its test inputs.  This is really what I was going after with this feature request:
https://github.com/jclouds/jclouds/blob/master/core/src/test/java/org/jclouds/utils/TestUtils.java#L39
I actually don't mind the way this is done with the means of the JDK:
``` java
new FilterInputStream(stream) {
public void close() {
// explain yourself here
}
};
```
It seems it is done in Guava 20.0 - based on http://google.github.io/guava/releases/20.0/api/docs/com/google/common/base/Throwables.html#propagate-java.lang.Throwable-
I second this thought of adding a removeCallback method.  In my project, we too have a situation, where a large background task is being done on background.  UI uses a callback to track the updates on the future.  But if the activity is paused or destroyed,  the UI has no need for the callback.  But since callback cannot be removed,  it triggers when the UI is not visible, there by causing problems and occasionally crashes.      I have this [implemented](https://github.com/ben-manes/caffeine) and would appreciate API design feedback.
There are more reasons why this is preferred than was previously listed. An immediate one is how a weighted cache would handle an empty future. The obvious answer is to give the weight 0 (never LRU evict) and update it when the future materializes. That handling is more than one should expect in client code, and there are many other small quirks that become similarly problematic.
My implementation uses `CompletableFuture` and defaults to `ForkJoinPool.commonPool()`. The `AsyncLoadingCache` provides a `synchronous()` view of a `LoadingCache<K, V>` that handles all of the operations down to the `asMap()` view by either filtering incomplete/failed futures or blocking until the future completes for a synchronous write (like `put` vs `computeIfAbsent` would). The stats, removal on failure, etc. is handled by chaining completion handlers onto the future.
A nice benefit is that bulk load is much smarter because we have a direct future to play with. The synchronous caches perform non-blocking bulk loads and clobber anything that appears since. Instead we can insert futures that proxy to the bulk computation, so the load only happens once. This is something we wanted to do in Guava, but never got to.
Like you said, weak and soft values are not supported. The future is not counted towards size- or time-based eviction until it completes successfully, at which point its considered a fresh entry.
In the future it may be useful to allow the user to decide if failures should be removed automatically. The reason is because user-based negative caching breaks the load/failure statistic as the return value would have to be an Optional<V> so the
cache always sees a success. However that flag is messy because the synchronous view would still hide the failed results, so it feels hacky. What is intuitive, useful, and correct is open for discussion..
Any feedback on the API and design decisions would be great!
I added an `AsyncCacheLoader` to [compliment](http://static.javadoc.io/com.github.ben-manes.caffeine/caffeine/2.2.0/com/github/benmanes/caffeine/cache/Caffeine.html#buildAsync-com.github.benmanes.caffeine.cache.AsyncCacheLoader-) `CacheLoader` when building an `AsyncLoadingCache`. This provides a more convenient hook for defining an async computation, e.g. returning the future produced by another library. This came out pretty clean by extracting the default async adapter methods from `CacheLoader`, so that `CacheLoader` extends `AsyncCacheLoader`. The lambda builder method `(key, executor) -> future` is a nice compliment while not losing the convenient `key -> value` version.
I have a use case as well. I want to define custom annotations to be used in conjunction with @Subscribe, which allow to define IF the event will be passed to the handler method or not (i.e. filters). Package-private methods are really harmful in my humble opinion. Why not make them protected? Or, at least provide some hooks for the event dispatching.
I would be willing to do the work to split up Guava, provided that it would be accepted. We have a small library that could use `com.google.common.base.Utf8`, which depends only on annotations and preconditions.
We prefer to minimize the dependencies of our library. Right now, we're resorting to copying in the Utf8 method implementations in order to avoid pulling in all of Guava, but I would really prefer to depend on a subset of Guava, instead.
We had to remove Guava from the dependencies because in old Android phones (Froyo) the dex merger doesn't work ;(
I would also like this. Let's add votes to this as more people want it.   So, is it fixed? I.e., do we have common joiners defined by framework?
Perhaps something like Joiners.onSpace() ... will be useful.
Here's okio's bytestring class: https://square.github.io/okio/1.x/okio/okio/ByteString.html
Re: Justin's concern, with the existence of protobuf-java-util depending on both Guava and Protobuf, I don't think the two versions would be a big concern. (There can be a util for conversion between ByteString types, and Guava's ByteString can be an abstract class like Protobuf's, allowing wrapper implementations in either direction.)
Re: andreas' comment, agreed too that the JDK should have a concept of an immutable byte view, but I think third-party prototyping and resulting widespread adoption can be a good way to motivate and guide JDK development (see Joda date types, Guava Optionals and functional utils, etc., FluentIterable patterns now incorporated in Stream, etc.).
Out of curiosity, what's the process (if any) for this kind of work?
This related issue (#1562) is still open  but it's quite old
ImmutableTable was made serializable in 5562218b96f0b262deb5c0d2288c1bcc339dbbb2.
Does anyone know what the state of this is? This seems very useful and I'd be interested in taking a stab at it if no-one is. I imagine it would be something similar to getAllAddresses in Apache Commons SubnetUtils: http://svn.apache.org/viewvc/commons/proper/net/trunk/src/main/java/org/apache/commons/net/util/SubnetUtils.java?view=markup
:+1:       +1 and went with `net.jodah:expiringmap` for now
+1
+1
+1
I think providing this feature in O(1) time with a clean API that does not detract from the existing one is a potentially difficult problem. In almost every algorithmic design I can think of, the approach could be served equally well by an external library decorating the cache.
The simplest O(1) approach is to rely on the `maximum size` constraint. For large caches (like memcached) they augment this with a sweeper thread to proactively discard expired entries. The more general approach requires an O(lg n) algorithm to retain a sorted order. As we've tried to avoid managing our own threads, only use O(1) algorithms, and not be excessively opinionated in how to use the cache this is a little difficult to resolve.
The first step is arguments for why variable expiration is useful in a general library. Most cases we came across then and now use a fixed time for domain-oriented caches. The variable were for specific applications, e.g. http caching, where different data commingles into a single, large cache. Justifying this feature as a common case is needed before considering the implementation details.
The second step is whether the algorithm benefits from the internal mechanisms used by the cache (periodic maintenance). If not, e.g. the lazy O(1) approach, then the feature can easily be contributed as a decorating library. That then side steps the next problem of how to evolve the API cleanly.
I should amend the above since @lowasser referenced this ticket on SO and, as hinted to in my '14 comment, the approach I keep asking myself about is a hierarchical / hashed [wheel timer](https://pdfs.semanticscholar.org/0a14/2c84aeccc16b22c758cb57063fe227e83277.pdf). This is the scheme used by kernel timers by using hierarchical clocks where a hand points to a bucket and an entry is marked with the number of rotations before expiring. This "approximated timer" scheme works because expiration is best effort and not exact. The hierarchical version is O(m) / O(1) time (where m is small) and would fit well into the cache's periodic maintenance.
This is the only approach I could see making it into the cache as a native feature. Unfortunately I still don't see a nice way to evolve the API (Cache and CacheLoader) to feel natural.
Could we perhaps create a new interface and not evolve the existing API?  It would be a special type of cache.
> Unfortunately I still don't see a nice way to evolve the API (Cache and CacheLoader) to feel natural.
Wouldn't something similar to `Weigher` do? Maybe
```
interface Expirer {
long expireAt(K key, V value, long lastWritten, long lastAccessed);
)
```
maybe with methods determining if it's to be called after write and/or access.
For comparison, jsr107 (JCache) has a version of this called [ExpiryPolicy](http://static.javadoc.io/javax.cache/cache-api/1.0.0/javax/cache/expiry/ExpiryPolicy.html?is-external=true). It uses `null`, a sentinel value (zero), and exceptions as alternative return values to the duration. It does not provide the context (key, value, metadata) due to not wanting to fetch that information if the entry is not in local memory.
I think variable access expiration could be problematic, depending on the implementation details. It may also be the less useful variant and might not be worth supporting. So I might argue that this would be a `expireAfterWrite` with a function similar to your proposal.
I am starting to work on this and feedback would be appreciated.
The goal of the `Expiry` interface is simplicity and to avoid object allocations. We could make it return either a duration or point-in-time, which would be in nanoseconds.
interface Expiry<K, V> {
long expireAfterCreate(K key, V value, long currentTimeNanos);
long expireAfterUpdate(K key, V value, long currentTimeNanos, long expirationTimeNanos);
long expireAfterRead(K key, V value, long currentTimeNanos, long expirationTimeNanos);
}
```
The duration approach would have the following characteristics:
- The duration may not be zero or negative, meaning that it has be re-evaluated to be expired (as it would interact poorly with loaders).
- An entry can be made eternal by returning `Long.MAX_VALUE`
- To avoid updating the expiration time on a read or update, you can return
`expirationTimeNanos - currentTimeNanos`.
The point-in-time would behave instead as,
- The new expiration time may not be less than the current time, meaning the entry has already expired.
- An entry can be made eternal by returning `currentTimeNanos + Long.MAX_VALUE`
- To avoid updating the expiration time on a read or update, you can return `expirationTimeNanos`
---
Implementation-wise, this will be done using a hierarchical timer wheel ([prototype](https://github.com/ben-manes/caffeine/blob/master/caffeine/src/main/java/com/github/benmanes/caffeine/cache/TimerWheel.java)). This allows add, remove, rescheduling, and expiring to be performed in O(1) time. Instead of using a O(lg n) priority queue, it uses a hierarchy of ring buffers, where each slot represents a time span (second, minute, hour). As the wheels rotate, the entries in the buckets are expired or rescheduled. This cascading effect amortizes the penalty and all operations are run during the cache's maintenance operation.
![timer wheel](https://cloud.githubusercontent.com/assets/378614/24584125/5f57609a-1717-11e7-9252-d0a83a8bc399.jpg)
> An entry can be made eternal by returning `currentTimeNanos + Long.MAX_VALUE`
Note that the sum is negative, lone `Long.MAX_VALUE` should do. You can consider any time above e.g., `Long.MAX_VALUE / 2` as "never" (as there's no practical difference between allowing expiration duration up to 146 or 292 years).
I guess, after an operation (create, update, or read), the corresponding method gets called. I wonder how their results compose. Does the last returned result win? Technically no, but practically yes. `Ticker` uses `System.nanoTime()` which states,
> The value returned represents nanoseconds since some fixed but arbitrary <i>origin</i> time (perhaps in the future, so values may be negative).... The values returned by this method become meaningful only when the difference between two such values... is computed.
I am also leaning towards a duration API since that is consistent with the builder, e.g. `expireAfterWrite`.
And you're right, the last value wins. Otherwise we'd want an exclusive lock on the entry for reads to ensure atomicity. `expireAfterRead` (like access) has limited value as it is not about data freshness but lifetime (e.g. a session token). @ben-manes You're right, I forgot about how `System.nanoTime()` works.
The duration API could possibly be simpler:
```
interface Expiry<K, V> {
long expireAfterCreate(K key, V value);
long expireAfterUpdate(K key, V value, long currentDuration);
long expireAfterRead(K key, V value, long currentDuration);
}
```
as you usually don't care about the current time. This is questionable and `currentDuration` probably needs to be computed. That's a good point on the API. My concern is that the duration may be a delta from a timestamp of an external resource. For example, basing it from a database row's `creation_date` with a 1hr TTL before a hard refresh is required. An example is a Google Maps geocode cache, which can only be held for 30 days by the license.
In these cases you need the current time to calculate with. A call to `nanoTime` or `currentTimeMillis` can be expensive under contention, so minimizing is a good practice in hot paths. Also `currentTimeMillis` can fluctuate by going backwards in time, so hopefully a call wouldn't accidentally violate a response by returning a zero/negative duration.
But perhaps I'm complicating the API by leaking optimizations? It is more important for an API to be elegant than fast. Per Josh Bloch's rule,
> Consider the performance consequences of API design decisions, but dont warp an API to achieve performance gains. Luckily, good APIs typically lend themselves to fast implementations. ```
interface Expiry<K, V> {
long expireAfterCreate(K key, V value, long currentTime);
long expireAfterUpdate(K key, V value, long currentTime, long currentDuration);
long expireAfterRead(K key, V value, long currentTime, long currentDuration);
}
```
Do you think this is the best compromise or that `currentTime` should be dropped altogether. I agree that `currentDuration` is more useful than the previous `expirationTime` field. > Do you think this is the best compromise or that `currentTime` should be dropped altogether.
I'd keep it, assuming you're sure you can always provide it for free.
> I agree that `currentDuration` is more useful than the previous `expirationTime` field.
In v3.0 I may need to drop it. One of the nice things about Guava is the internal baking period to catch these mistakes that an independent OSS library may make.  A use case for having both could be "always give me the latest value for this key, but if no one is accessing it, expire it".
How is this going along? Is there a timeframe as to when a fix can be expected?
@cpovirk I have had a go at this in https://github.com/google/guava/pull/2615. I wonder if you or someone else in the Guava team would have the time to review it?
Oh, it looks like #2086 proposes a very similar fix to mine! I now wonder if my fix covers all the possible edge cases...
Please see [TinyLFU: A Highly Efficient Cache Admission Policy (2015)](http://arxiv.org/pdf/1512.00727.pdf), which I co-authored.
My summary of this issue:
Though other libraries have `Either<A,B>` already, see this [SO post](http://stackoverflow.com/questions/26162407/is-there-an-equivalent-of-scalas-either-in-java-8).
+1; we are waiting on an external HTTP service and need to control how long we wait before giving up.
Another +1 here. We run a bunch of tasks with deadlines, and this would make managing the deadlines a lot easier.
Having a mechanism to dynamically lookup the public suffix list would be awesome. Please consider doing it.
Thank you.
I've been working on a simulator so that an evaluation can be made. **What I primarily need help in is acquiring trace data so that we can make an informed decision.**
The [simulator](https://github.com/ben-manes/caffeine/wiki/Simulator) is multi-threaded, uses either a synthetic or trace file data source, has simple interfaces for adding new policies and trace formats, writes a report of the stats to the console or file, and is driven entirely through a [configuration file](https://github.com/ben-manes/caffeine/blob/master/simulator/src/main/resources/reference.conf).
The simple eviction and admission policies are implemented and I hope to start on the more advanced ones soon. It is easy to capture additional statistics and for now I've kept it to the simple case of a maximum size. Adding weights, expiration, and coherence support shouldn't be too difficult but I thought they should be added after most of the policies were complete. It would also be useful to track the average eviction penalty, e.g. CLOCK-based policies have O(n) worst case evictions.
For example using the [Wikipedia request trace](http://www.wikibench.eu) yields the report below. First we see the upper bound due to compulsory misses (`Unbounded`) followed by the theoretical bound (`Clairvoyant`). We see that using an admission policy (`TinyLfu`) can cheaply give us near optimal efficiency, but other traces will highlight its weak temporal locality (making it good for secondary caches, but not as a primary cache's policy). We then see that 2Q style policies, which all advanced policies tend to follow, provide a close approximation. Finally we see that the sampled policies can, by mere luck, sometimes beat their strict versions. We can conclude that a member of the 2Q family (which includes LIRS and ARC) will probably be the approach to adopt.
Kevin's original proposal was to generalize this as a tool that developers could run to size their caches. This was back during the transition from soft reference collection to a maximum size as the preferred approach. I'm not sure how useful that would be, but it would be a fairly trivial enhancement.
``` bash
 Policy                       Hit rate  Requests    Evictions  Time    
 opt.Unbounded                85.90 %   10,430,564  0          6.759 s 











 two-queue.TwoQueue           55.57 %   10,430,564  4,601,748  6.642 s 





 linked.Clock                 47.80 %   10,430,564  5,444,026  6.721 s 





 sampled.Fifo                 41.87 %   10,430,564  6,062,579  18.82 s 




Executed in 30.36 s
```
@kevinb9n
After exhaustive evaluation, the two best algorithms are LIRS and EdenQueue. The problem with [LIRS](https://github.com/ben-manes/caffeine/blob/05308d87f696b32b22ec0b249c1063834d4fe63b/simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/LirsPolicy.java) is that it requires 3x the cache size to reach its full potential, where 2/3rds are non-resident entries (evicted keys). This incurs a lot of complexity, in addition to it being a non-trivial algorithm to implement correctly.
[EdenQueue](https://github.com/ben-manes/caffeine/blob/8f0379f0e7706c9b2796aa913e0c154d4d13d18a/simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/two_queue/EdenQueuePolicy.java) (name in flux) is my design based on TinyLfu. It uses an small LRU window that evicts to a main LRU queue, guarded by an optimized TinyLfu admission policy. I wrote a [4-bit CountMinSketch](https://github.com/ben-manes/caffeine/blob/8d7ccddd8120c556e7aaae096ba5fcdbe3b905cf/simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/sketch/FrequencySketch.java) that is both memory and cpu efficient. This is used for retaining the frequency history and requires 1 long per unit of capacity (16 counters). The hit rate is near optimal across the board, is simple, has a low footprint, is O(1), and does not require retaining evicted keys.
Having talked to Doug about this, we think its the right approach to move forward on.
My use-case would also benefit from thread safety on Bloom filters. I'm rate limiting connections and the underlying framework (Netty) is multithreaded. Merging filters doesn't help in this case because the threads need to see the same data. Having stale data violates the "no false negatives" aspect of Bloom filters and makes Guava's Bloom unsuitable for my application
I could use synchronization, but having profiled Bloom it is apparent that most of the processing on my system is generating the hash. The way Bloom works now- hashing is done on a single core. I find this silly since the Guava's hash functions are specifically designed to be stateless and thread-safe.
Since ~90% of CPU time is tied up in hash calculation, Bloom should scale nicely using striped locks. I'm fairly familiar with the Bloom code and can submit a patch for thread safety if desired.
Has it been tried out yet? I have a use case for a utility that observes a rate, not for logging, not for metrics. We get events and based on some specific rules we discard events - one of the rules being the rate at which it happens - if something happens too sporadicaly, we drop it.
Now, of course, we wrote the class, it worked, and a year later we discovered that the design was completely wrong and that it creates hundreds of thousands of objects and when let running for a long enough time, eventually kills the application.
This is not an easy problem and it's easy to get wrong, so a well-tested utility might be useful to the broad public.
I've been wondering about a class like this recently too.
I think it may prove to be a nice compromise between `CharMatcher` and regexes when one needs something more powerful than matching on a single `char`, but also doesn't want their [99 problems to turn into 100 problems](https://xkcd.com/1171/). :wink:
1. `iterable.iterator().next()`*: there is a first element (i.e. it isn't an empty stream)
2. `Iterables.getLast(iterable)`: there is a last element (i.e. it isn't an empty stream or an infinite stream)
3. `Iterables.getOnlyElement(iterable)`: there is one and only one element (i.e. it isn't an empty stream or a stream with multiple elements)
In the case of getLast we can't check a java.util.Iterator to see if it is infinite or not.
If there were a way to check an iterable's precondition that it has a last element without iterating through all of the elements then I suspect that this would certainly be done but there isn't.
As such, doesn't it make sense to check all the preconditions even for getOnlyElement?
If not, then should `Iterables.getOnlyElement(iterable)` be removed from the guava library and moved to guava-testlib?
\* as recommended in `Iterables.getFirst(Iterable<? extends T> , T)` as `Iterables.getFirst(Iterable<? extends T>)` is not provided
Why was it preferred to add `of(E[])` over `of(E...)` ? for methods under test that take an Iterable<E>, why wouldn't you want to just call the method with `FluentIterble.of(foo, bar, baz)`, which is much closer to the type that you want (Iterable)?
Yes, I get it there's always that method out there somewhere that will do the same thing - i.e. `Arrays.asList(foo, bar, baz)` also implements Iterable, but it's a mental hoop to remember it, or understand why it was used as a reviewer.
Certainly that mental-tax, however small, is worth not having to pay and choosing `FluentIterble.of(foo, bar, baz)` would be instantly intuitively obvious to everyone who sees it and stick in their minds more easily the next time they need to make an Iterable quickly for testing
I should point out that it was done this way for `Iterators` and I don't see why not also `FluentIterable`.
http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/Iterators.html#forArray(T...)
Somewhat frustrating this hasn't been added. @scr FWIW I've found https://github.com/jOOQ/jOOL to be pretty nice, and generally either a) have the methods/overloads I expect, or b) the maintainer is pretty open about adding methods/overloads as requested. FWIW/YMMV.
Unfortunately GWT doesn't have java.util.stream support yet, so I'm using old-school Guava transform/etc. with lambdas until I can just use jOOL for both client- and server-side.
Is there any plan to fix this in the near future? It is really incovenient :(
Thanks!
List<String> elements = Lists.newArrayList();
elements.add("DEF");
String str = Joiner.on("','").appendTo(new StringBuilder("'"), elements).append("'").toString();
Apparently, there are considerations about migrating to Java 8 for further releases. In that regards, can't this ticket be reopened with exclusively Java 8 as extra argument, since predicates are now more easy to write/use than ever, and also more widespread?
```
List<String> list = ...
String parameters = ...
String value = checkArgument(list::contains, parameter, "%s is not registered", parameter);
```
```
String value = checkArgument(list.contains(parameter), "%s is not registered", parameter);
```
This can't work: `parameter` is not known as parameter to `checkArgument` and you can't return it. That's the point of this request, I believe.
I think this would be nice to have.
I think it will be useful function.
I like julianhyde's solution. I also rolled my own, which is nearly identical, though he has better factory methods. one difference is that his concatenates an immutable list of lists, whereas mine is a live-view of the meta-list as well, so whole lists can be added and removed (given proper synchronization) real-time.
https://github.com/friendswithbenny/fwb-alj/blob/master/src/main/java/org/fwb/alj/col/ConcatList.java
+1  I just copy and paste Closer and find `Closeable`  replace to `AutoCloseable`, and rename Closer to `AutoCloser` :smile:
Why is it such a problem to add this fix? That won't break any backwards compatibility and it is pretty straightforward
However, it's worth noting that the Guava team are currently in the process of [upgrading Guava for **Java 8**](https://groups.google.com/forum/#!topic/guava-discuss/ZRmDJnAq9T0) (they will keep a Java-6-compatible version around for Android), which would implicitly make it Java-7-compatible too, so hopefully we won't have to wait too long for `com.google.common.io.Closeables` to accept `AutoCloseable`s.
Since the latest version requires Java 8 this should be reopened. Also pretty please adjust Closer. Thanks!  @gissuebot , thanks for that explanation of why Guava chose "optional" instead of "provided". FWIW, I've had a long, hard thought about which way to go with our own libraries regarding JSR 305. As you note, they will both have the same effect. But it seems to me that semantically "optional" fits better for us. Think about it this way: why would consumers want JSR 305 annotations at runtime? They may may have a tool that does post-compile analysis. Or maybe the consumer wants to produce documentation based upon the JSR 305 annotations. The tool would need access to these annotations.
Ah, but you might say that the tool will _provide_ them. Yes, but I think that Maven's "provided" gives the expectation that there _must_ be some container providing them (e.g. servlets, as you mentioned). In this case, even the "provided" part is "optional". I therefore think that "optional" provides the closest semantics; they won't be included unless users want them --- they aren't "required but automatically provided by a container".
In your explanation you indicate that "optional" is used to choose among "several sets of bytecode". But that's not always the case; perhaps you are confusing "optional" with "having an option among choices, and you must choose one". There are many use cases of "optional" for which things are entirely optional: if the dependency is present, something happens; otherwise nothing happens.
Would you mind kindly clarifying the purpose of your comment above for me? >  Guava has had both a compile-time and runtime dependency on JSR305 annotations since 31st June 
I've been reading https://stackoverflow.com/a/24264330/421049 and doing some intense research in https://stackoverflow.com/q/45596949/421049 and thinking long and hard on how best to include JSR 305 in our own library, based on Guava optionally including it (historically using "provided"). Now you're telling me that Guava has changed its mind altogether and is now including JSR 305 transitively, so that all consumers bring in the JSR 305 dependency automatically? Just so I make sure I'm understanding correctly > Now you're telling me that Guava has changed its mind altogether and is now including JSR 305 transitively, so that all consumers bring in the JSR 305 dependency automatically?
Yes, I believe so.
If [this comment](https://github.com/google/guava/issues/2721#issuecomment-276449030) is to believed, it looks like Guava versions 22.0+ are the ones I'm talking about. (And indeed, the release page for [22.0](https://github.com/google/guava/wiki/Release22) confirms this. :smiley:)
(On a side note, it also occurs to me that Guava changed their dep on JSR305 from "provided" to "optional" some time between when this issue was closed and when 22.0 was released, as according to https://github.com/google/guava/commit/0e29934933f33379de953727171f7ca1ec616a58, the dep was last set to `<optional>true</optional>` as opposed to `<scope>provided</scope>`. I'm unclear on when they made that change, though. :thinking:)
Am I right to understand that (1) you're on a Guava version older than 22.0 and (2) you're trying to make sure you have an explicit compile-time _and_ runtime dependency on JSR305?
> Am I right to understand that (1) you're on a Guava version older than 22.0 and (2) you're trying to make sure you have an explicit compile-time and runtime dependency on JSR305?
You're right about the first part, but the reason why I'm investigating this has nothing to do with not getting JSR 305 in a project. Rather we have our own libraries which use JSR 305, and I am debating whether to make _their_ use of JSR 305 optional or not; I was using Guava's experience to help guide my own decision.
After much reading, researching, and contemplating, I was ready to make a final decision and settle on using `<optional>`, even though Guava (I thought) had settled on `provided`. Now Guava's latest move throws everything into doubt again. It seemed pretty evident to me that `<optional>` was the right way to go, because users may want to use our general library without pulling in another dependency (as with Guava). And finding out that Guava had switched to `<optional>`, too, was somewhat of a validation of my decision. But now why is Guava throwing out "optional" altogether? Does it have something to do with moving towards Java 9 modules, which may not support optional-ness? This new turn of events has confused me again. Oh, here is why they are non-optional now: https://github.com/google/guava/issues/2721
But interestingly that issue has to do with a _separate_ set of annotations, not the JSR 305 annotations. > But interestingly that issue has to do with a separate set of annotations, not the JSR 305 annotations.
Yes, that's right. But IIUC the whole conversation on that issue, I believe it was (or still is) applicable not only to those specific annotations ([error-prone](https://github.com/google/error-prone)'s annotations, I believe), but to all "optional" and "provided" annotations in general.
I'm pretty sure that it was because the issue applied to all "optional"/"provided" annotations that Guava depended on, rather than just error-prone's annotations, that the Guava team decided to make all of Guava's annotation deps "compile" scope. And unfortunately, Java 9 throws in a whole _other_ can of worms, with regards to Guava's dependency on the JSR305 annotations specifically. Because of how JPMS modules work, it may prompt the Guava team to drop JSR305 altogether or adopt a different annotations library.
See issue https://github.com/google/guava/issues/2960 for the gory details. :( Yeah, I saw that, but didn't quite understand the details. I'm not yet up to speed on Java 9 modules. Sheesh, why couldn't they have simply finished JSR 305 and made it part of Java? (Trying not to go into a rant here.)
Well thanks for all the info --- be sure to add anything else you think of. I'm now in a holding pattern deciding which way to go with JSR 305 in our own library. @garretwilson You're very welcome! And I'm very sorry to hear that I inadvertently made things more confusing for you.
I wish you best of luck, and I hope you can come to a reasonable conclusion in the near future!
I'm not sure if there's anything else to add, but I'd recommend that you follow #2960 so that, even if the details go over your head, you have some consensus to refer to if it reaches a solid conclusion. :) > "present at compile time but not at runtime."
meaning "present at _users' compile time_ but not at users' runtime". That's an interesting state of affairs --- it's like a scope Maven doesn't provide. But as I [mention](https://github.com/google/guava/issues/2721#issuecomment-340509193) in #2721, it's unclear whether such a scope would really be needed. Anyway, thanks for helping make this clearer! It will help me come to a decision of what to do in my own library. Cheers!   I like this idea. Any thoughts on an API?
FYI, we're doing this in OkHttp. I'm hoping to get something that solves most HTTP use cases, including IDNs.
https://github.com/square/okhttp/issues/1486
Maybe a good place to start is the target spec.  RFCs 2396 and 3986 are good candidates. Android's Uri and Java's URI do 2396. However 3986 is listed as obsoleting 2396.
Whatwg has a spec for URLs, which I think Jesse is targeting in OkHTTP.
Thoughts?
The WHATWG spec is the best yet, but it's still not exactly consistent with what the browsers do. And the browsers themselves aren't consistent with each other. I ended up doing a lot of research, including this:
https://docs.google.com/spreadsheets/d/1BgGAhJ5WE3JBsATeudamiBzxmgEhwkfcFqQmPx8qrkc/edit#gid=0
Wow, that spreadsheet is terrifying! Well, given the multitude of specs and inconsistent behavior, maybe it's wise to divide the problem:
- Allow different types of URIs by creating a base Uri that's intended to be extended.
- Support additional specs by isolating encoding and decoding into its own class(es).
Here's a 50Kft sketch:
```
/**
* Spec independent. Can be extended for other URIs such
* as URL, MAILTO, or LDAP.
*/
String getScheme()
String getAuthority()
...
UriBuilder<T extends Uri>
T build();
UriBuilder<T extends Uri> scheme(String scheme)
UriBuilder<T extends Uri> authority(String authority)
...
/**
* Spec specific.
*/
UriCodec<T extends Uri>
T decode(String uriString)
```
Nah, my policy has been to just write one good URL that does what you want. Nobody wants to decide between Firefox parsing mode and Chrome parsing mode, they just want something that's going to work.
For example, today I'm doing the first steps towards IDNA mapping.
https://github.com/square/okhttp/pull/1612
The WHATWG spec is good, but it isn't perfect. There are a few edge cases where it disagrees with what the browsers actually do.
@cpovirk , other than following the WHATWG spec, any thoughts on what would make a good URL library? Maybe some tough learnings from the multiple implementations that you already have?
You're right - Jesse is very wise :)
google.common.net has several classes that could be used within a more general URL class (eg HostAndPort).  Would you be open to additional sub-URL classes? For example: QueryParams, PathSegments, etc?
QueryParams could be a good start. If there's even a very, very, very small chance, I'd be happy to open an issue to bounce a design and, if it moves forward, write a patch.
You're all too kind. @ericedens please grab OkHttp if that's sufficient for you. If it's too much, extracting HttpUrl into its own standalone thing is also possible. Though I don't think _I'll_ do that, you're welcome to. There's been non-zero demand.
+1
+1
+1
I'm also interested in creating Inet6Addresses from ipv4-mapped addrs (without copy/pasting half of InetAddresses).
Makes sense not wanting something so specific in-tree, but would a patch flipping ipStringToBytes to protected be accepted?
haven't found `Consumer<T>`:(
I am facing the same issue with cached calls to database. The status of the issue is accepted. Are there any news about the developpement of a solution?
This should work properly in the [rewrite](https://github.com/ben-manes/caffeine/blob/master/caffeine/src/test/java/com/github/benmanes/caffeine/cache/RefreshAfterWriteTest.java#L122). There should probably be variants of these tests for the async cache, though. A bulk refresh is not supported yet.
I have still the same problem. Automatic refresh calls only load and not loadAll.
[main] INFO com.jcabi.aspects.aj.NamedThreads - jcabi-aspects 0.22.1/58f97a9 started new daemon thread jcabi-loggable for watching of @Loggable annotated methods
[main] INFO com.dichotomia.tests.guava.CacheLoaderExample - #loadAll('[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]'): '{0=0, 1=1, 2=2, 3=3, 4=4, 5=5, 6=6, 7=7, 8=8, 9=9}' in 162,75s
[main] INFO com.dichotomia.tests.guava.CacheExample - #getAll([[010)]): '{0=0, 1=1, 2=2, 3=3, 4=4, 5=5, 6=6, 7=7, 8=8, 9=9}' in 17,07ms
[main] INFO com.dichotomia.tests.guava.CacheLoaderExample - #load(0): '0' in 30,96s
[main] INFO com.dichotomia.tests.guava.CacheLoaderExample - #load(1): '1' in 17,88s
[main] INFO com.dichotomia.tests.guava.CacheLoaderExample - #load(2): '2' in 11,85s
[main] INFO com.dichotomia.tests.guava.CacheLoaderExample - #load(3): '3' in 8,43s
[main] INFO com.dichotomia.tests.guava.CacheLoaderExample - #load(4): '4' in 18,06s
[main] INFO com.dichotomia.tests.guava.CacheLoaderExample - #load(5): '5' in 23,26s
[main] INFO com.dichotomia.tests.guava.CacheLoaderExample - #load(6): '6' in 21,23s
[main] INFO com.dichotomia.tests.guava.CacheLoaderExample - #load(7): '7' in 9,26s
[main] INFO com.dichotomia.tests.guava.CacheLoaderExample - #load(8): '8' in 7,80s
[main] INFO com.dichotomia.tests.guava.CacheLoaderExample - #load(9): '9' in 7,87s
[main] INFO com.dichotomia.tests.guava.CacheExample - #getAll([[010)]): '{0=0, 1=1, 2=2, 3=3, 4=4, 5=5, 6=6, 7=7, 8=8, 9=9}' in 12,03ms
For my side this is documented as [#7](https://github.com/ben-manes/caffeine/issues/7) to support bulk refresh. I'm wrapping up v2 and not sure if this will make it.
@kevinb9n Is it possible to make that document public?  I'm interesting in working on non-BMP support for CharMatcher.  I assume the plan is something like:
- Add
``` java
public boolean matches(int codePoint) {
if (codePoint >= 0 && codePoint < Character.MAX_VALUE) {
return matches((char) codePoint);
} else {
return false;
}
}
```
- Override that method in all the built-in matchers
- Change uses of `String`/`CharSequence` to iterate by code point instead of by `char`
@cgdecker, any update with such issue. how about the 19.0 release plan,we could not be waiting for that since 18.0.
Thank you Google for exposing all our email addresses on migrating from Google code to Github.
The old issue (that can still be seen on the [web archive](https://web.archive.org/web/20160111155842/http://code.google.com/p/guava-libraries/issues/detail?id=960)) has all our email addresses mildly anonymized.
On copying over the issues from Google code the @gissuebot has decided to helpfully expose the full email addresses.
I'd been wondering at my sudden uptick in spam. This is the only place where I can find my email address clearly publicly posted. So thanks Google for not considering privacy when coding up the migration bot :disappointed:
Can this be considered again? The standard API would require instantiating BigDecimal to do rounding with special modes.
I guess a big concern over such a method is double's inability to represent rounded decimals. Maybe two variants can be added with one ignoring any inaccuracies and another throwing if output cannot be meaningfully represented?   Looks like not much has progressed on this issue for a couple years? Would be nice to more easily implement the `HashFunction` interface as an end user. Specifically, I'd like to be able to use it with "HmacSHA1", which would put it in a similar league with `MessageDigestHashFunction` (but with a key, so if implemented guava side it might look something like `Hashing.hmacsha1(byte[] key)`)
What about doing it in a two steps manner? First deprecate the method and create a new one `readFullyOnSteroids` then in a later release rename `readFullyOnSteroids` to `readFully`?
Sorry to reply after that long, but once again I was in need for this instead of the current state and, having forgotten about it, found this issue again.
Why is it important to keep the binary compatibility?
I understand that binary compatibility is a nice-to-have feature, but not a deal breaker. Guava makes incompatible changes with each release; why is this any different from those changes?
Today, there are already [several "classnotfoundexception" questions on SO](http://stackoverflow.com/search?q=[guava]+is%3Aquestion+classnotfoundexception) where the go-to answer is "upgrade your library", and people are recompiling anyways.
In regards to the "2 extra lines of code", I disagree: it's 2 lines of code multiplied by the number of times it is used. I read some parsing classes we have here and we're at ~300 usages on a medium-sized project (~50k loc). The workaround that was implemented was a static-import method which does what @lowasser described. And it's rather ugly (static import, extra parameter, function-style instead of method-style), but less than the current state. So no, it's not only 2 extra lines of code.
2015-11-05 19:38 GMT+08:00 Olivier Grgoire notifications@github.com:
> Why is it important to keep the binary compatibility?
>
> I understand that binary compatibility is a nice-to-have feature, but not
> this any different for the the binary compatibility?
>
> Today, there are already several "classnotfoundexception" questions on SO
> where the go-to answer is "upgrade your library", and people are
> recompiling anyways.
>
> In regards to the "2 extra lines of code", I disagree: it's 2 lines of
> code multiplied by the number of times it is used. I read some parsing
> classes we have here and we're at ~300 usages on a medium-sized project
> (~50k loc). The workaround that was implemented was a static-import method
> which does what @lowasser https://github.com/lowasser described. And
> it's rather ugly (static import, extra parameter, function-style instead of
> method-style), but less than the current state. So no, it's not only 2
> extra lines of code.
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/934#issuecomment-154037535.
##
_ _
Hello,
In the light of a new "Guava for Java 8" version to come (which forces a recompile given that several classes _will_ be deleted), I respectfully ask that this issue is reconsidered.
Thanks!
I just bumped into this as well -- patches accepted?
> HTTP status codes are extensible. HTTP applications are not required to understand the meaning of all registered status codes, though such understanding is obviously desirable.
- http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1
Supporting extensibility could happen in creation and/or consumption. Twitter uses a few nonstandard 4xx codes to signal throttling and rate limiting errors. For example, the class should be able to do something useful when asked to interpret the nonstandard 429 from 'HTTP 429 Too Many Requests'.
In the meantime, more and more possible uses of this have appeared in our project, and for several we cannot use the Set version. So please expose this.
I believe [`Lists.cartesianProduct` was added in 19.0](https://github.com/google/guava/wiki/Release19#commoncollect).
There are so many real world use cases for enum ranges and discrete domains:
- Calendar months (JANUARY, FEBRUARY, ...)
- Days of week (SUNDAY, MONDAY, ...)
- Task priorities (MINOR, MAJOR, CRITICAL, BLOCKER)
- Permissions  (READONLY, MODERATOR, ADMINISTRATOR)
:+1:
+1
+1
+1 +1 +1 +1    @cgdecker, is there currently any interest in implementation of this enhancement?
One particular reason where I wanted this several times was in a test. Writing the indexOf-loop, or even the splitter is fine when you're going to test it, but if I want to assert in a test that number of occurrences in a string produced by code under test is correct, I would like to avoid putting logic in my test to verify that.
Why isn't this added yet?! This is a no brainer Is this still being rejected? I can add this if there's interest.  Another reason to do this, now, is so we have a version of this functionality that's not tied to _our_ Supplier interface (we should use only java.util.function.Supplier for it).
I would also like to see a "refreshing" Supplier memoizeWithExpiration - that simply maintains the existing value if an exception occurs during refresh.
I just coded a single-element refreshOnWrite cache that is wrapped by an anonymous `Supplier` instance. I think I wrote just as many comments explaining what I was doing and why, as I did lines of code.
I have a set of config data based on the locale and I would want to cache that entire data in the memory and keep refreshing it periodically without activating the server.
Is there a way I can achieve this using this library?
I am doing it by adding reload method and calling updateAll to one particular locale within it. But it doesn't look clean according to the library functions. How can I get functionality. Do you suggest any other library for such cases? I kept it simple, I guess (perhaps naive, but we'll see)
public interface ResettableSupplier<T> extends Supplier<T> {
void reset();
}
public static <T> ResettableSupplier<T> resettableMemoize(final Supplier<T> source) {
class ResettableMemoizingSupplier implements ResettableSupplier<T> {
private volatile Supplier<T> memoized = Suppliers.memoize(source);
public T get() {
return memoized.get();
}
public void reset() {
memoized = Suppliers.memoize(source);
}
}
return new ResettableMemoizingSupplier();
}
I try to avoid this anyhow in favor of a better 'bigger picture' solution, but that's not always possible in a legacy context      I have a similar requirement. However, simply respecting the order in which subscribers are added to the bus would be sufficient for my needs. At first blush, it would appear to be as simple as using a `LinkedHashMultimap` for `subscribersByType` instead of `HashMultimap`.
an example at least showing how to create that custom hashfunction would be great.
As I discussed in https://github.com/google/guava/issues/334#issuecomment-269697414, I believe the functional interfaces in Java 8 have implemented this idea now, and as Guava 21.0 (which depends on Java 8) will be released soon, I think this issue can be safely closed.
Although, having said that, I've just remembered that there's a plan to release an Android-specific port of Guava around Guava 22.0's release. This port cannot depend on Java 8, so there might be worth in effectively porting the methods on the Java 8 functional interfaces to a class in `guava-android`.    What about SourceCodeEscapers ?
https://code.google.com/p/guava-libraries/source/browse/guava/src/com/google/common/escape/SourceCodeEscapers.java?r=08fb8bc14dff5e928840d4e95176b1279bb4ea58
Can anyone upload a project demonstrating this problem? My attempts to reproduce it have failed.   Is there a reason an EventBus can't have both a custom identifier and a custom exception handler?
I just wanted this for the exact same purpose mentioned by **_kasperni**_.
Just FYI, Java 9 introduced a method `Objects.requireNonNullElseGet(T obj, Supplier<T> supplier)` that does exactly what you need  I would like this, as well, to nullify an `Optional<Thread>`'s `Thread` after it's completed.
I had an example use case for this function today: clone org.springframework.security.core.context.SecurityContext and set it as current while executing a background task in a thread pool. This data structure is Serializable, so it can be saved into a servlet session, the concrete classes implementing these interfaces could be different and the data structure could be mutable, so I would like to make a copy, and doing so via serialization looks like the simplest approach.
What about this issue? I recently stumbled upon [this implementation](https://code.google.com/p/guava-libraries/source/browse/guava/src/com/google/common/pool/?name=refs/remotes/gcode-clone/pool) by Louis Wasserman. Isn't this implementation a good one? I  tested it with load and it performed okay. Some features are missing, naturally, but it's a great start, isn't it?
Its use on Android which hasn't even fully supported all of the Java 7 APIs
will artificially limit it for years.
> out of curiosity, given java 6 has been eol'ed for almost 3 years, at what
>
> 
> Reply to this email directly or view it on GitHub
> https://github.com/google/guava/issues/683#issuecomment-77657042.
Extended support for Java 6 ends in December 2018, [according to Oracle](http://www.oracle.com/technetwork/java/eol-135779.html).
and that aside, i'd still like to see this as part of the library even if i have to call `close` myself.
+1 for seeing this in a future version, however that may be.
@lowasser Louis, are there any plans to release the pooling mechanism any time soon? Like maybe this year? Your implementation looks very promising!
any progress?
Any update on this?    I am also looking forward for java util functionality like one from groovy [List#transpose](http://docs.groovy-lang.org/docs/next/html/gapi/org/codehaus/groovy/runtime/DefaultGroovyMethods.html#transpose%28java.util.List%29) or scala [List#zip](http://www.scala-lang.org/api/2.10.3/index.html#scala.collection.immutable.List) .
Would still be nice to have this...
At the moment, this may be possible, but very clunky/awkward to implement, especially if you really only needed it as a one-off.
While this issue is old I wanted to add my use case for this feature - request/response pairing.
I have a batch function that takes a collection of requests and returns a collection of responses, in order. I want to be able to do something taking both the request and response together as a pair (not a Pair) and this seems to satisfy that use case for me.
Iterable<Request> requests = ...
Iterable<Response> responses = batchRequest(requests);
Iterables.forEachPair(requests, responses, (req, res) -> doSomething(req, res));
```
@cpovirk
For the interleave component, I have written a custom Iterator that I've been using for my own personal use that can interleave 2-N iterators of varying sizes. I'm not sure if this is something that would be desired in the core library - if so I could do a pull request. Also if that's the case, it would probably need some style/name changes to better fit the Guava code base.
/**
* An Iterator implementation which interleaves elements from the given iterators.
*
* Iterators do not need to be the same length.
*/
public class InterleavingIterator<T> extends AbstractIterator<T> {
private final Queue<Iterator<T>> queue;
public static <T> InterleavingIterator<T> ofIterators(final List<Iterator<T>> iterators) {
return new InterleavingIterator<>(iterators);
}
public static <T> InterleavingIterator<T> ofIterables(final List<Iterable<T>> iterables) {
final LinkedList<Iterator<T>> iterators = new LinkedList<>();
for (final Iterable<T> iterable : iterables) {
iterators.add(iterable.iterator());
}
return new InterleavingIterator<>(iterators);
}
private InterleavingIterator(final List<Iterator<T>> iterators) {
this.queue = new LinkedList<>(iterators);
}
protected T computeNext() {
while (!queue.isEmpty()) {
final Iterator<T> head = queue.poll();
if (head.hasNext()) {
final T result = head.next();
queue.offer(head);
return result;
}
}
return endOfData();
}
}
```    Would love if this patch could be merged...
I also needed the functionality.
I have applied that patch and created a pull request:
https://github.com/google/guava/pull/2100
I've started an implementation that matches exactly, not based on regex, but I guess it can easily be improved.
It can be seen here: https://gist.github.com/ogregoire/8c95bd3ab7c7e670a5012caad47125e3
JDK 8 introduced [`Duration`](https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html) class for `java.time` package, so I guess this issue is obsolete. On the other hand it does not integrate with `java.util.concurrent.TimeUnit` but uses its own `ChronoUnit` and currently there's no official way (in JDK 8) for converting between these two ([there will be in JDK 9](https://bugs.openjdk.java.net/browse/JDK-8141452), though).
Is there an ETA for when this might get into guava? I note that kryo, zookeeper, and kafka all have their own implementations of ByteBufferInputStream
java.nio.file is not available on android.
Any news on this?
Just because some people use hammers to hammer in a screw doesn't mean we shouldn't have hammers.
Something like this would have been useful in the case where you've implemented the Decorator pattern, and you might either pass in a particular ConcreteComponent or an associated ConcreteDecorator, but must specify a parameter type of Component.
You might have a wide variety of ConcreteComponent implementations, each of them having some number of associated ConcreteDecorator implementations.  Since they all, at the end of the day, extend Component, you have to accept a Component, but for a given method you may only want to permit a specific ConcreteComponent and any of its associated ConcreteDecorators.  Any updates on this? @kevinb9n can you link to what a "Partition" is?
Hi team, is there finally an implementation in guava yet? If yes what its called.  Isn't Guava running on Travis CI now?
It may be worth keeping this issue open until https://github.com/google/guava/issues/2686 is resolved, but then again maybe not... Heck, it may be worth getting Guava to run on the [TeamCity public server](https://teamcity.jetbrains.com/). Checkstyle currently does this.  Aren't you gonna merge this one? Waiting since 31 Oct 2014 and highly anticipated
My common sense tells me, that skip should come with inject for symmetry.
```
injectBefore(anotherIterableToInject, wherePredicate);
injectAfter(anotherIterableToInject, wherePredicate);
```
I think these `takeWhile` and `dropWhile` methods should be added to `com.google.common.collect.Streams` as well.
Oracle are planning to add `Stream.takeWhile` and `Stream.dropWhile` methods in Java 9, so these methods would also act a sort of intermediate measure for those who won't be able to use Java 9 immediately upon or shortly after its release.  :+1:
would love to see this!
Searching for this functionality in Guava and found this issue.  My use case is taking a key space over a dataset that was previously partitioned into n ordered partitions and wanting to repartition (redistribute?) it into a smaller number of partitions k as evenly as possible.  Very sad to see it was closed and just 15 days ago.
Someone had posted why one cannot use the https://commons.apache.org/proper/commons-io/apidocs/org/apache/commons/io/FileUtils.html#byteCountToDisplaySize(long) method.
Actually that does the opposite of what I want. If your answer is 1.4GB it simply rounds it off to 1GB as indicated in the Javadocs. This is absolutely not okay if you are showing the heapsize, remaining memory etc in a UI/admin pane etc. You simply cannot ignore 400MB in a rounding error. That is about 28% of the actual value.
This library is what I'm using:
https://github.com/JakeWharton/byteunits
Up. This functionality might be very useful for POJOs.
Almost 5 years gone. Since previous decision. Maybe you want change it?
ability to start()/stop() a service a few times seems very common
Not being able to restart the service somewhat defeats the point and forces to reimplement a lot of the same boilerplate (as mentioned in #418 ensuring only one running)
Maybe AbstractService needs to be modified or new recipe added (RestartableService) since this is a recurring usage
same topic on StackOverflow http://stackoverflow.com/questions/8976367/restartable-service-using-guava
The proposed solution on SO does not seem to fit.
If the Service injected in a couple places and has to be singleton (common for web-service like usage). So deleting and creating it opens up opportunity for bugs
How about something like this: https://github.com/okigan/guava/commit/8f51b155f9ce5c60236b9a9bfdc6ca5f8bf5e51d
> Could you provide a concrete usecase of where you would like to use this?
> Scenario: running a process that's hosts one or more guava based services.
For management purposes you need to be able to stop/start one or more of the services
(for example, configuration needs to be updated).
Also we can think of services in linux system and it's start/stop/restart lifecycle management.
> Would 'reset' be a method on Service? just abstractservice (and the other abstract service base classes)?
> Depends how far we want to take it
>
> Would we add a new State enum?
> I dont see a need for that, just the need to transition from TERMINATED to NEW
>
> Ability to query how many times it has been restarted (generation count)?
> Also don't see the need for that, it's insufficient for debugging...
>
> What happens if you call reset() and the service isn't in a terminal state?
> Seems like nothing -- reset is a transition from TERMINATED to NEW only
>
> Would we want services to be able to 'auto restart'?
> Seems this cannot be done in a clear way, the service failed to start and if the cause
> it still there we'll get an infinity loop (or that requires a smarter backoff/restart mechanism)
> In case of failure/termination you want to leave in a state that can be investigated,
> auto-restart would delete that
>
> I think the change to AbstractService will probably be significantly larger than the proposed
> Does not have to be AbstractService (i did that to emphasize the scope of changes needed).
> This could be a new ResetableService which would avoid backward compatibility issues (but again @Beta is there)
Please review response above.
> Since if we aren't modifying Service or AbstractService then it doesn't need to be a guava feature at all
Service implementation strongly recommends to use one of the provide implementations (with which I agree, as it is relatively tricky to get it right)
> there is the question of how it would interact with things like ServiceManager.
At the time of my original request I have not used ServiceManager yet, and now see that it is
useful for managing several services. So, (in my mind) that clarifies that the method should be part of
Service interface and ServiceManager would call it as well (for all managed services)
> (re)transition through the NEW and STARTING states buy you?
To ensure consistent startup/initialization (avoid logic for first vs consecutive starts)
> Is it interacting with some other infra that is generically monitoring the services?
right, the decision to reset/start should be external to the service/services
Would a RestartableService wrapper like [this one](https://gist.github.com/vladdu/b8af7709e26206b1832b) work as an alternative?
(ex. if 'delegate' is implemented by subclass of AbstractService it will not be able to restart)
The delegate doesn't restart, but a new one is created and started. The restartable wrapper "keeps up the appearances", so to speak.
Missing from the gist is the handling of listeners. One might want to call 'running' and 'failed' multiple times, if there is some kind of initialization/finalization. Some listeners might have global state and aren't fit for getting called more than once. This is application-dependent and I think that it would need some kind of extension to Listener to cover all cases.
@vladdu maybe that's not bad then (I am ok not to cater to listeners with global state)
In case anyone is interested, I have updated  [the gist](https://gist.github.com/vladdu/b8af7709e26206b1832b) so that it really works. I haven't included the obvious NeverRestartPolicy and AlwaysRestartPolicy classes.
I am using this in a real project and it seems to work ok.
One thing that remains unclear is how it would behave with multithreaded listeners.
Thanks @vladdu. This is really useful. Wish this was somehow implemented in the core library.
What about changing/updating the states ?
Curren lifecycle is Service.State.STOPPING to Service.State.TERMINATED.
We can define it like: Service.State.STOPPING to Service.State.STOPPED.
And another one: Service.State.TERMINATING to Service.State.TERMINATED.
So when service stopped, it just stop, but not terminated. So calling start again will the service again. But calling a terminate() function will terminate the service, current stop behaviour.
I think a better way of handling this is to have a `ServiceRestarter` that you pass a `ServiceProvider` this will handle the re-instantiation of the service when the service crashes.
I implemented a modified version of @vladdu's solution here:
https://github.com/WPIRoboticsProjects/GRIP/blob/master/core/src/main/java/edu/wpi/grip/core/util/service/AutoRestartingService.java
And here is it's respective test
https://github.com/WPIRoboticsProjects/GRIP/blob/master/core/src/test/java/edu/wpi/grip/core/util/service/AutoRestartingServiceTest.java
**DISCLAIMER**:
This solution may not be technically correct and may have deadlocks.
If you find one please leave an issue on the project.
Hello all, I would like to bump this topic up with a simple, related pull request I created (https://github.com/google/guava/pull/2164), seeing how often this is requested.
I think it's obvious there's a problem and that it should be tackled. I see two simple solutions.
The first one is described in the commit message:
```
e.g. we have a value, but if it's not set, we want a default
(though the same can be true for the default).
Unfortunately this method wasn't called `defaultIfNull`, but `firstNonNull`,
This commit tries to solve that, by *making* it a search,
and letting the users decide which approach they want
```
The second one could be to deprecate it again, and add one with the same impl, named `defaultIfNull`.
(ps: slightly related: https://github.com/google/guava/pull/2163)
Issue #1345 is related.
Does this issue even need to be open now?
[`java.net.Socket`](https://docs.oracle.com/javase/7/docs/api/java/net/Socket.html) has implemented `Closeable` since Java 7, and Guava itself will start requiring Java 8 soon in 21.0.
(I know that an Android port will be created around the time Guava 22.0 will be released, but I believe the Android port will only support Java 7+? And I believe `Socket::close` was added in Android API level 1 anyway.)  Any progress on this? Won't Guava help us read a BOM?
Any Progress on FluentPredicates and FluentFunctions?
I think this issue is now resolved with the introduction of the `java.util.function.{Predicate, Function, ...}` functional interfaces in Java 8, and with `com.google.common.base.{Predicate, Function, ...}` now extending those interfaces.
For example, [`Predicate`](https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html) has the "fluent" methods [and](https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html#and-java.util.function.Predicate-), [or](https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html#or-java.util.function.Predicate-) and [negate](https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html#negate--), which I think fulfill the OP's original request, as one can now write the following quite easily:
com.google.common.base.Predicates.in(collection).negate().and(Objects::nonNull);
```
Therefore I believe that this issue can and should be closed now. :)  @kevinb9n Can we please decouple these two unrelated issues?
1. Add `Ordering.explicit(Iterable)`
2. Ability to specify handling for unknown values
The first one could be implemented right away. My use-case is needing to invoke `Ordering.explicit(Queue)`. The code in question is very performance-sensitive (invoked millions of times) so ideally I want to avoid converting the `Queue` to a `List` per invocation.
@cpovirk I must have missed something then. Where in the code do you depend on the input being a `List`? As far as I can tell, you simply invoke a for-each loop on it, which means that an `Iterable` or `Collection` input would result in identical behavior without needing to copy the input to a `List` beforehand.
@cpovirk To clarify, the main reason I am angling for `Iterable` is because I want to pass in a `ConcurrentLinkedQueue`.
Another approach (if you want to prevent the method from accepting non-ordered collections) would be to add a private method that consumes `Iterable` and then overload `explict()` for all known types (including `ConcurrentLinkedQueue`) which delegate to the `Iterable` method. This would have the advantage of retaining backwards compatibility.
@cpovirk Thank you for clarifying. So I agree, we should have a `Collection` parameter instead of `Iterable`.
I think having a method like maxSizeLimited in Lists to create and return such a ForwardingList will be a nice addition. I guess it's a case that is often encountered.
Looks like this should be removed from the [idea graveyard](https://github.com/google/guava/wiki/IdeaGraveyard#create-a-map-from-an-iterablepair-iterablemapentry-object-alternating-keys-and-values-or-from-listk--listv), now that it's been implemented:
> create a map from an Iterable<Pair>, Iterable<Map.Entry>, Object[] (alternating keys and values), or from List<K> + List<V>
>
>TODO(kevinb): fill in
>
>Note that we may still add ImmutableMap.copyOf(Iterable<Entry>).  Any progress on this issue?
https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html
Even with Java 8, there seem to be some methods missing:
...
long LongMath.sum(int[])
BigInteger BigIntegerMath.sum(long[])
...
Using `IntStream::sum` sounds like a bad idea in case it might overflow one day and you might spend the next one chasing the bug.
int[] ints = ...;
long sum = Arrays.stream(ints).mapToLong(i -> i).reduce(0, LongMath::checkedAdd);
``` Likewise, for `BigIntegerMath.sum(long[])`, something like this should work:
long[] longs = ...;
BigInteger sum = Arrays.stream(longs).mapToObj(BigInteger::valueOf).reduce(BigInteger.ZERO, (a, b) -> a.add(b));
``` @jbduncan Agreed. I guess, your `sum(int[])` is as fast as it can get (note that you need no `checkedAdd`), but your `sum(long[])` is probably much slower than slicing the `long` into two `int`s, accumulating each into a `long` and using `BigInteger` for the final result only. @Maaartinus
> Agreed. I guess, your `sum(int[])` is as fast as it can get (note that you need no `checkedAdd`)...
Am I right to think that it's because a `single` long is large enough to hold the sum of an `int[Integer.MAX_VALUE]` where all elements are equal to either `Integer.MAX_VALUE` or `Integer.MIN_VALUE`?
Regardless, I think that `LongMath::checkedAdd` would almost certainly be needed when dealing with Streams with more than `Integer.MAX_VALUE` elements (which aren't common at all, I imagine). But then again, in such a situation, I imagine mapping and reducing to a `BigInteger` would be more sensible than reducing to a `long` anyway.
> ...but your `sum(long[])` is probably much slower than slicing the `long` into two `int`s, accumulating each into a `long` and using `BigInteger` for the final result only.
I'm a bit lost but very curious by what you mean here. Can you give me a code example? > Am I right to think
Yes, the minimum value is `> Integer.MAX_VALUE * Integer.MIN_VALUE > -2**62`, which fits, the maximum value is slightly smaller in magnitude.
---
> a code example
```
long high = 0, low = 0;
for (long x : longs) {
high += x >> 32;
}
return BigInteger.valueOf(high).shiftLeft(32).add(BigInteger.valueOf(low));
```
There may be tons of errors.      But.... What happens with Android (Android still doesn't have Java 8) or others frameworks without Java 8?
exactly... on Java 8 i am using the language but where i can't use java 8 i would want to rely on 3rd party libraries, like guava...
@ekovacs : I guess they have stopped this because they are migrating to Java 8 in Android N.
I have not found a decent way to fold in Java 8 ;)
A simple workaround is to use a mutable list to store intermediate results. Example:
```
List<String> temp = new ArrayList<>(expectedSize);
// populate "temp" ...
ImmutableList result = ImmutableList.copyOf(temp);
```
I assume that this will result in better performance than using `ImmutableList.builder()` for the same operation.
The downside, of course, is that this doesn't provide fluent syntax.
+1  We've been waiting for this for a while.  Any movement?
+1, any status on this?
+1 Excited to hear about an update!
+1 Please put this in the next release.
Looks like some things landed in master, so maybe in Guava 24.0 release TBD?
- [`ImmutableList.builderWithExpectedSize`](https://github.com/google/guava/commit/7928bbe079303c54373453353c9ef2cd7de9365e): https://github.com/google/guava/commit/7928bbe079303c54373453353c9ef2cd7de9365e
- [`Immutable{Map,BiMap}.builderWithExpectedSize`](https://github.com/google/guava/commit/8158909d7bda9f98a4576f89eb5fd88cb12c2bd6): https://github.com/google/guava/commit/8158909d7bda9f98a4576f89eb5fd88cb12c2bd6
- [`ImmutableSet.builderForExpectedSize`](https://github.com/google/guava/commit/d7501abccbd666a8db4dff77fa110c801a094c75): https://github.com/google/guava/commit/d7501abccbd666a8db4dff77fa110c801a094c75  We do have a couple concurrent multimap implementations internally, but they come with warnings like this:
>> Which implementations are you talking about please ? I really need ConcurrentMultimap in my use case I don't mind worse performance....  Nobody needed this since 2015?   > The "enumerate" idea is one we considered and rejected long ago; there's no need for it, "int i = 0; / i++;" works just fine.
Unless you are using i while creating an anonymous inner class, in which case i needs to be final.
Of course, you can create a final int within the loop to store the current value of i, but that's even more crufty. I guess the real problem is that you'd need to support something like Pair?    I needed a kind of "unique list" as well and struggled to implement something I was happy with. As pointed out above, a UniqueList breaks Collection utility methods like sort and shuffle. But I also realized that I really didn't need to use indices in these collections much at all. Because their are not duplicates, I could refer to the position I wanted in the list by the element itself.
So with some hesitation, I ultimately gave up on it being a "List" at all and created a new type of Collection. This collection doesn't present the user with index-based access. My collection has methods getFirst() and getLast(), but then methods like getBefore(e) and getAfter(e), to return the elements before and after the specified element. It also has addBefore, addAfter, removeBefore, removeAfter, all of which accept element arguments.
For my primary implementation of the interface, I effectively re-implemented a LinkedList but with the addition of a HashMap mapping elements to its bucket in the list. So I get constant-time contains, insert, and remove. One of the benefitsI get by _not_ implementing List is that I don't worry users might use the slower index-based operations that come from the linked list implementation.  There was a request for use cases.
I started to use the Trie in apache commons4 collections to use in lookups of longest matching prefix. Its not uncommon with rules based on phone number prefixes.
Next is to do the same but for IP networks, almost like a routing table. Apache commons4 4.0 doesnt allow me to create a patricia tree on other types though. But I guess limewire is almost doing this, but refactoring has made the codebases diverge.
The lookup tables will have around ~100k entries, and there about 100k lookups per second.
