- write it longhand
(One other note about `@Nullable`: We can't use type annotations yet because we currently make our "Android" branch available to Java 7 users. This may rule out some libraries' nullness annotations.)  The problem with special characters? Or just that it doesn't work with Java 9 at all? If the latter, it should be fixed in [23.1](https://github.com/google/guava/releases/tag/v23.1). How are you constructing the `ClassPath` instance?  I don't think it makes sense to start tagging particular issues for particular events/hackathons, but we're always open to receive contributions. Hackathoners are welcome to check the issue list and see what speaks to them!  /cc @jrtom (semi-graph/tree related) What specific use cases do you have in mind for these data structures--that is, what problems are you trying to solve that require them?
Some (pseudo-)code snippets might be helpful to get your ideas across. @liach I understand that they're sorted _sets_, or maps (not lists), with the added ability to retrieve an item given its position in the ordering.
Do you have an actual application for which you need to compute the median and other quantiles, and that's a significant performance bottleneck that needs improvement?  What are you computing the median of?  How many data points do you have, to a rough order of magnitude? (Mostly right now I'm just trying to understand the details asked for here: https://github.com/google/guava/wiki/HowToContribute#ubiquity-provide-concrete-use-cases )  The `java.class.path` system property is useful as input to `URLClassLoader`, among other things. It would be good to have a common method somewhere to parse it.  Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
```java
class TestGuavaADatabase {
void add(TestGuavaA a);
void remove(TestGuavaA a);
Set<TestGuavaA> getAll();
TestGuavaA getById(long id);
TestGuavaA getByCode(String code);
```java
Rollback to Guava 18.0 "solves" it.
Gradle 3.3
Eric
Thanks @cpovirk , @breyed, @gengjiawen
Eric
Eric  https://google.github.io/guava/releases/21.0/api/docs/com/google/common/collect/ImmutableSet.html#toImmutableSet--
> Also, why not just distribute the Android version of guava as an AAR, and not as a JAR?
> sufficient to, in and of itself, note guava-jre and guava-android as
It sounds like what we have is supposed to work (or at least `ImmutableTable.Builder#Builder`, perhaps?), but [javadoc8 doesn't understand it](https://bugs.openjdk.java.net/browse/JDK-8031625). Oddly, it looks like javadoc9 doesn't understand it, either.... Maybe I'm doing something wrong. Hmm, no, I was doing something wrong, though I'm not 100% sure what it was :) I'll see if I can at least get it to work with javadoc9 now. OK, the code that we currently have in Github works under javadoc9. We can't switch to the new code without breaking our internal builds (which use java9 with -Xdoclint) -- and, it appears, breaking javadoc9. The easiest solution here is probably to wait for our switch to using Java 9 for our open-source builds.  Thanks for your pull request.  It looks like this may be your first contribution to a Google open source project. Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).
- AtomicDouble we're trying to leave as close to upstream as possible
On Wed, Aug 9, 2017 at 11:36 AM, Paul Alexander Bilokon <
> Dear Guava developers,
> // TODO(lowasser): consider exposing this
> <https://github.com/notifications/unsubscribe-auth/AB8SUNR3PbXwIQioYNyZ3eD8Vy878eF6ks5sWdHqgaJpZM4OyQjh>
kak
The main issue I have with this is that we already have several different versions of our Javadoc (normal Guava, android, GWT...) and this would be combinatorial with that, so we'd need a no-beta version of _each_ of those as well. It would be nice if there were some way to set filters on what you see to exclude `@Beta` APIs, but as far as I know Javadoc doesn't provide anything like that. #2657 is the issue for the BetaChecker. I'm going to close in favor of that.  Sounds like something @lowasser might be interested in taking a look at.  In the past we've actively resisted "nickel-and-diming" Preconditions: providing lots and lots of special methods for lots and lots of special precondition checks.  Internal helper utilities are different; we have lots of those that we don't think merit public API.
This is a tangent, but it *kind of* does, in the form of
(Arguably even the current behavior is "tolerable," but really what I mean is that it's sad but only about as sad as lazy views often are, which is why we've soured on them :) I guess my underlying feeling here is that I wish that we didn't have to make the code even marginally more complicated (basically, "things like calling `getDeclaringClass` :)) to micro-optimize performance for people who are using an API that's generally micro-performance-hostile... if that makes any sense. So I like the "clever" thing.) PSA: since I got assigned, I am implementing the long thing. I think we should in general reserve the right to iterate more than once if we _really_ want, but I the current code is smelly and worth fixing independent of that -- e.g., it could produce maps with null values under concurrent modification -- and I certainly view one-time iteration as a good thing overall. (Well, OK, I suppose it does mean that users may come to rely upon it, but Louis is adding a test so that we don't break them unintentionally, and I doubt we'd really have a reason to ever change the behavior back in this case.) And thanks for the report, even though I have spent half this thread playing devil's advocate :)  > I wonder why @cpovirk explicitly excluded Monitor in his search query at issue #2785.
The fact that TreeTraverser is expected to be replaced suggests to me that we're unlikely to change it at this point, but that's not my call.
We'd considered some other names for a non-deprecated version -- "legacyMd5," etc. -- but we were worried that it it would suggest that the method doesn't really implement "real MD5." (In fact, we have a "brokenFoo" method internally from a case in which the original implementation of "foo" was incorrect :)) I think we're mostly happy with the idea that people can suppress the warnings when necessary. (And I'm glad we have a workaround for Scala. I'm entertained that it didn't occur to me to write the workaround in Java :)) If it's causing people additional trouble, though, we'd like to hear about it.  We currently don't for reasons documented in https://github.com/google/guava/commit/6d8771908c8eb77f8478fb772fcad090a902884f.
We haven't open-sourced this yet because it's in a somewhat weird position: it's a library that is usable anywhere, but its design is built around the expectation of compiler support from Error Prone to make sure you got the checked exceptions right.  Without Error Prone, it's just wrapping checked exceptions in a runtime exception that's a little dressed up.  It sounds like this shouldn't be too difficult to deal with just by switching to a sentinel value, but if someone wants to send a pull request it'd probably get done more quickly.  Otherwise I'll try to take a whack at this...soon-ish.  Merged, thanks. I ended up tweaking some things:
- changed the empty-string test to test with a valid radix. In your version, it's hard to see that it's failing because of the empty string and not because of the invalid radix  The goal here was to fix https://github.com/google/guava/issues/2721. Evidently "compile-only" doesn't actually make the annotations available at compile time to projects that compile against Guava, and that causes problems for people who compile with all warnings as errors. But if making the dependencies required at runtime causes problems, too, we'll have to figure out what to do. Are they causing problems for you, or is it just surprising that we made this change? They used to be `<optional>true</optional>`, and that's what caused #2721. It's possible that `<scope>provided</scope>` would fare better; I don't know. I just tested with `<scope>provided</scope>`, and it reintroduces #2721 :(
So I'm not sure what you mean by "it returns null for (1,3)", since it should throw in that case.
That said, I recall that in our previous research, our implementations of some of these methods were faster.  Long term, the preferred solution would probably be to upstream our implementations, but I'm not certain if we should actively recommend transitioning.  These methods each say, "Values are compared as if by Double.equals(java.lang.Object)." Does that cover it?  Interesting idea, but the downside is that every invocation would require the conditional to be executed, regardless of whether it can use the shortcut or not.
What you describe is similar to the reason why @Bezier89 proposed the `ValueGraph` type in the first place; he wanted to have non-unique edge values, and using `Equivalence` objects or similar to manage this does make the code kind of ugly-looking.
Going a bit wider still: the definition of your topology seems a bit weird.  Specifically, I'm not sure why "x happened before y induces an x->y edge" makes for an interesting graph.  Can you say more about what you're doing with this graph, and how you decided on your model?
(This is probably way more detail than you were expecting to come out of this conversation, so if you'd like to take this to email, LMK and we'll figure that out.)
sense in many ways for classes to own their own details of how they are
On Sun, May 7, 2017 at 10:27 PM, Trejkaz (pen name) <
> Patch Links:
./com/google/common/escape/CharEscaper.java
./com/google/common/escape/UnicodeEscaper.java
./com/google/common/io/CharSource.java
./com/google/common/io/CharSink.java
We're *allowed* to do that, because TreeTraverser is `@Beta`, but it is something we still try to avoid when we can. In general, we have learned to tolerate the ugly double-cast-and-suppress construct as long as it's something that is needed only infrequently.
wouldn't hurt, I'm terrified to hear that people are serializing Guava
worried about creating any impression that Guava tries to work correctly in
this kind of environment.
I think the problem arises only when people override methods. As an extreme example, suppose that an author has created a `ForwardingTransformingList` that overrides all getters and setters to apply a function to each value before/after forwarding. The only thing the author wouldn't override would be `size()`, since transforming individual elements doesn't affect size. If we suddenly start forwarding `spliterator()`, then its users start seeing the untransformed items when they use streams.
assertTrue(InternetDomainName.from("foobar.bid").hasPublicSuffix());
assertTrue(InternetDomainName.from("foobar.xyz").hasPublicSuffix());
assertTrue(InternetDomainName.from("foobar.loan").hasPublicSuffix());
assertTrue(InternetDomainName.from("foobar.win").hasPublicSuffix());
Is there any chance that you're calling `isPublicSuffix` rather than `hasPublicSuffix`? Or might you have a copy of Guava from a few years ago, before those suffixes were added to the list? Tentatively closing, but if you can find a way for us to reproduce this, please do reopen.  Thanks. We decided a while back that we weren't going to protect against outright malicious callers, so we let through this possible attack and a few others.
> LongUnaryOperator
> LongUnaryOperator
> LongUnaryOperator
> kagedLibrariesForBrandAFastBuildDebug'.
> classpath 'me.tatarka:gradle-retrolambda:3.2.5'
be something you need to do differently to convince it you really meant
>> to be compiled, unknown interfaces are java.util.function.BiConsumer
>> to be compiled, unknown interfaces are java.util.function.BiConsumer
>> to be compiled, unknown interfaces are java.util.function.BiConsumer
>> to be compiled, unknown interfaces are java.util.function.BiConsumer
>> to be compiled, unknown interfaces are java.util.function.BiConsumer
>> to be compiled, unknown interfaces are java.util.function.BiConsumer
>> to be compiled, unknown interfaces are java.util.function.BiConsumer
>> to be compiled, unknown interfaces are java.util.function.BiConsumer
>> to be compiled, unknown interfaces are java.util.function.BiConsumer
>> to be compiled, unknown interfaces are java.util.function.BiConsumer
>> to be compiled, unknown interfaces are java.util.function.BiConsumer
>> to be compiled, unknown interfaces are java.util.function.BiConsumer
>> to be compiled, unknown interfaces are java.util.function.BiConsumer
>> to be compiled, unknown interfaces are java.util.function.BiConsumer
>> to be compiled, unknown interfaces are java.util.function.BiConsumer
>> to be compiled, unknown interfaces are java.util.function.BiConsumer
>> to be compiled, unknown interfaces are java.util.function.BiConsumer
>> to be compiled, unknown interfaces are java.util.function.BiConsumer
>> to be compiled, unknown interfaces are java.util.function.BiConsumer
>> to be compiled, unknown interfaces are java.util.function.BiConsumer
>> to be compiled, unknown interfaces are java.util.function.BiConsumer
>> to be compiled, unknown interfaces are java.util.function.BiConsumer
>> to be compiled, unknown interfaces are java.util.function.BiConsumer
>> to be compiled, unknown interfaces are java.util.function.BiConsumer
>> to be compiled, unknown interfaces are java.util.function.BiConsumer
>> to be compiled, unknown interfaces are java.util.function.BiConsumer
>> to be compiled, unknown interfaces are java.util.function.BiConsumer
>> to be compiled, unknown interfaces are java.util.function.BiConsumer
>> to be compiled, unknown interfaces are java.util.function.BiConsumer
>> to be compiled, unknown interfaces are java.util.function.BiConsumer
>> perator
>> perator
>> to be compiled, unknown interfaces are java.util.function.BiConsumer
>> to be compiled, unknown interfaces are java.util.function.BiConsumer
>>     buildTypes {
>> classpath 'me.tatarka:gradle-retrolambda:3.2.5'
issues:
with the change.
forks of Guava to only differences of implementation, and APIs that are
different signatures bring a new kind of trouble....
> change, because a Guava Supplier is a Java Supplier.
> Guava. (We are much more aggressive about deletion inside Google, largely
@jbduncan I'm not sure what problem you're referring to, exactly.  How does the MutableGraph spec differ from what you think it should be?
$ javap -v -cp guava-23.3-jre.jar com/google/common/collect/Multiset | grep -A 1 CompatibleWith
> The compiler cannot determine if the missing annotation has the meta-annotation `@Inherited`. This can cause problems for annotation processors.  @rohit5ram, in the absence of a correct implementation of compareTo, TreeMultiset will display undefined, unpredictable behavior like clear() mysteriously not working.  There is no way of dealing with this other than using a correct compareTo implementation as @jbduncan describes.  @shengxuanyi's comment actually *demonstrates* this: that if you substitute in a class with a correct compareTo, the code will work.
of usage builds up.
> Stream<T>. Maybe Guava could provide a utility for this?
> why I think it would be beneficial for Guava to add it instead of just
allocation. I'd be reluctant to add this method to Guava because I just
written, but I held them back from Guava for what proved to be an invalid
reason (I think). They will very likely be in Guava 22. I'll find out if
> Yeah, well, Comparators
> Soooooo, how busy are you on a scale from 1 to 10? Guava needs your sweet,
```java
Coming back to the original question: @ogregoire, another option that you could use would be to populate the graph with the final node objects, but:
This is not an unreasonable thing to want to do, but I'm not sure that it's sufficiently broadly useful for us to include it in Guava.  Closing this for now; if someone wants to chime in and say "hey, I want that too" then we can reconsider.
If this is a false positive, I apologize. Please reopen the pull request, and we'll have a look.  Where are you seeing an `UnsignedShorts` class?  I'm not seeing it at a glance.
So on the one hand, I agree that helping people remember this can be useful, but on the other hand, I worry that if we try to say this everywhere, but miss a few places, people might interpret that as "oh, we don't have to worry about that here". @nirsoffer I think that this is one of those issues that would really best be fixed with a compiler warning (or other static analysis tool) if it's detected that you've defined equals() but not hashCode() (or the other way around).  I am a big fan of writing and updating documentation, but I'm not sure that this is a problem that can be fixed with documentation.
(And I've made this mistake too.  :) ) FWIW, Error Prone has a static analysis warning for this already: http://errorprone.info/bugpattern/EqualsHashCode @kluever Well, there you go then.  :)  I should have checked Error Prone first.  I've put this into Guava's API review queue.  I've put together a different implementation, though, that avoids quite so much redundant copying.  I'll keep this thread updated on the status of the API review.  Perhaps better suited for `common.primitives`? I'm not sure...any thoughts on this @cgdecker and @lowasser ? My thoughts are that it really should not be a common case that users'
has gone a bit amiss if that's happening a lot.
> to be erroneous behaviour?
> Its compare of "BB-second" and "CC-third" objects:
i read the code,found that guava **only** use key hashcode and size to identity bucket,when identify same bucket,it may return the wrong lock.
@saikiran939
We didn't do so in Guava 20.0 because there are some dependency issues (and related architectural issues) that we haven't worked out yet, but we are actively working on those issues.
I intended Mug to be a niche library for things that seem to have potential but don't quite make Guava's "utility * ubiquity" bar.
If Guava gets a BiStream or something of that kind, Mug BiStream will be deprecated in favor of Guava.
I'd also volunteer to work on adding BiStream in Guava if the librarians aren't already working on it or plan to (and if the idea itself is approved). I see mostly just two main possibilities: `BiStream`, or we embrace `Stream<Map.Entry>` as the common idiom, despite its flaws, and add bits of help here and there to make that less painful. I can't see introducing a `Pair` or `Pair`-alike at this stage, and I can't really see just doing nothing about this either.
```java
```java
took a nose dive.
off the happy path it gets hostile fast.)
Nice of you to say, kartoffelsup, thanks.
Basically, you have a somewhat different mutate API, and you keep track of node depth inside the implementation: you either add a root (which is at depth 0) or you add a "child edge" to a node (which gives the child depth 1 + the parent).
@liach I'm not sure what benefit you would expect to get from having a DirectedAcyclicGraph type (note that we don't even have a DirectedGraph type :) ).  In particular, I can't think of any new method signatures offhand that such an implementation would have.
@liach I'm not sure what you are referring to here when you say "a list", and even less sure what you mean by "Provide a list to check whether the order of a list is possible".
@liach Your proposals are quite specialized.   I would be surprised if there were very many people that would need what you're describing, so they're probably not a good fit for `common.graph`; while I'm generally in favor of code re-use, that sounds like something that I would expect users to write for themselves.
@liach I can't think of a single occasion in which I've ever seen someone working with DAGs want to be able to answer the question "can the nodes in this DAG be traversed in this order?".  So, yes, it's a  question that you could ask, but that doesn't mean that it's something that's generally useful.  :)
So that's an approach that we could take, but I'm not yet convinced that it's the right thing to do.  Whether this added complexity would be worth it would depend on how widely used it would be.
@liach Technically we could, but we're unlikely to because we want to continue to be able to support Java 7, and we'd like to avoid drift between the Java 8+ and Java 7 versions.
@liach Not sure exactly what you're proposing.  Are you suggesting a utility class with methods for graphs that are presumed to be acyclic (so they don't need to call `Graphs.hasCycles()`)?
@liach You're right, I'm not sure what I was thinking.
Thanks for filing a separate issue.
Well, I'm just reopening this issue to let the people at guava decide... It is a very minor issue, anyway.
(with `RecursiveDeleteOption` and `InsecureRecursiveDeleteException`)
I wonder if we have other Java-7-exclusive classes that we've been holding back? Probably few if any.
Heh.  I'm at least partially responsible for that change in upstream JDK, so it's appropriate we apply those simplifications to Guava now...
This error always indicates that Guava is on your class path multiple times.
bundling Guava in unaltered form, which is a no-no. And in this case, it's
Guava 11.0 or older, almost five years out of date. Try "jar tf"ing all
> Having this same problem. Just updated my version of Guava to the latest,
> > https://github.com/notifications/unsubscribe-auth/AB5_YdjsPrXBTAmDPNB1zHA4yabHTZ8Yks5qtAWqgaJpZM4KFLRN
I'm not sure what you mean here? iterator() should be returning a fresh iterator every time, so the FI should be empty if and only if if a fresh iterator doesn't have a single element.
1) yes. generally Guava is "nullergic" and throws a NPE when passed a null reference.
"It's a binary-incompatible (but source-compatible) change. That said, it looks like Ints.tryParse and Longs.tryParse are both @Beta, so we're allowed to make binary-incompatible changes to them. We might still break people who ignored the @Beta policy, so we'll have to weigh that against the gains. Alternatively, we could add CharSequence overloads. That would make the API look a little bigger and scarier than it is, so I guess every approach has some small pros and cons."
Hmmm.  I'm looking at this, it's a little weird because this would be a (unique, AFAICT) example of a map that doesn't support put (what would the semantics even be if it overlapped an existing entry?) but does support setValue in its entries.  Thoughts?
Why is this repository necessary.  Guava is itself available through repo1,
> https://github.com/notifications/unsubscribe-auth/AAUN4lucl2WOv3KgMR8xAN4-mhX7Ir4Bks5qXi-bgaJpZM4JQck1
-kak
> https://github.com/notifications/unsubscribe/AAhPOTWdbkEAN6ALwgVJZ7saoKw4xS8kks5qQ29QgaJpZM4JB38I
> https://github.com/notifications/unsubscribe/AAhPOWEBcQFgrahiMecFdkqTRR5jKA2vks5qL48sgaJpZM4I2ArG
We have a way of doing this, but it requires a slightly different approach:
I think that its reason for existing is pretty much exactly "to support its weird API." Maybe there are cases in which an array-backed "normal" `Table` would come out ahead in memory usage, though. Sadly, I suspect that they'll be rare enough that we don't add such a thing.
Also, @cowwoc, I don't believe your claim about java.util is actually true.  `new ConcurrentHashMap<>(myHashMap)` fails if `myHashMap` has null keys or values, and the same with `Collectors.toConcurrentMap`.
This doesn't sound like the right place for your issue; "accounts" don't really have anything to do with Guava.
https://github.com/google/guava#important-warnings
Naming is tricky, as you point out. `cellKeys`?
We are hoping to extend that Error Prone check to catch Guava classes like
to revert to an if/throw something has gone terribly wrong".
When I see circuitous things like this being done, I feel (more) sad that
That said: that's an artifact of the Java implementation of `ReentrantReadWriteLock`, that the read and write locks don't actually hold references back to the shared lock object they came from.  And it makes `lazyWeakReadWriteLock` almost useless.  So I think the proper thing to do is, in fact, to return not a `ReentrantReadWriteLock` but a thin wrapper that makes sure the read and write locks hold references to the `ReadWriteLock` they came from. https://github.com/google/guava/commit/957c1a5455508120d224f6d0d8f3bf8afa3630f0 RE: `public`: We've gotten requests before for "`Striped` but without the striping" (internal issue 4197198). It's probably worth another look, given the bug found here. The hard part is probably the API. Ideally it would fit closely with the API for `Striped`, but it's not actually striping, so the name doesn't make sense, nor does the extremely rarely used `getAt(int index)` method (which we might replace with `lockAll` and `unlockAll` if not for those non-lock and read-write-lock use cases...) or the related method `size()`. Maybe the right approach would have been a `LockMap` class with `stripedReadWriteLock`, `perObjectReadWriteLock`, etc., with some of those returning a `StripedLockMap` subclass with the index/size-based methods. That might work, but I'm not sure when it will reach the top of our priority list :( But it still seems more likely than just exposing the lock, given that the lock is fairly straightforward to write yourself.
RE: extending: I suppose I can imagine some hit to performance from the extra types (and/or indirection). My guess is that it won't matter much in comparison with the overhead that people expect when using especially a read/write lock. Also, I'm not sure we have that option for `Condition`, since `newCondition` in `ReentrantReadWriteLock` requires access to the private `sync` field, so we either do all `Forwarding*` types or else we mix subclasses and forwarding (which is not really "wrong" but a little weird). I'm not necessarily inclined to support the fix in the JDK, actually?  Like..."must work when used via weak references" is not generally a thing that implementations specify or are written for.  I'm not sure ReentrantReadWriteLock is any more special than the many other APIs that may or may not work when used via weak references.
Is the @Beta annotation causing you problems? @jpangamarca Noted.  It is possible that we may end up exposing that functionality differently if we end up integrating it with common.graph, but if your main concern is that we might end up removing it entirely, I'd say that's rather less likely.  :) Calling this closed because `TreeTraverser` is going to be deprecated in favor of the new `Traverser` class in `common.graph`.  (Unfortunately, if you care about the @Beta status, the new API is likely to be in beta for a while.)  We should see what we do elsewhere.
Sorry for being vague and ominous.
Sure, that would be terrific.  @ooxi seems to have covered it: Guava is Apache 2 licensed, and you would just need to follow the restrictions of that license.
was another minefield.
The principled thing to do is to never submit a `FutureTask` to an `Executor`, instead viewing it only as an implementation tool for people who are writing an `ExecutorService` from scratch. A more pragmatic compromise that I'm considering for elsewhere in Guava is to submit a `FutureTask` to an `Executor` _if_ it's an `ExecutorService`... but none of that helps you here :(
messed up with Lists.transform(); it was an accident, and got baked in that
Remember that the goal of adding wildcards is "to ensure that all callers
with _filtering_. And note that only some upcasts work; if we wanted
We could, of course, have gone the other way and opted for promiscuous
wildcards everywhere, and we actually sunk dozens of hours into a quest to
figure out which of these two philosophies was the "right" one. Then we
definitely not kidding when it says this is the most controversial aspect
> I noticed recently that MutableGraph was split away from Graph, so I was
> Has the Guava team considered the advantages and disadvantages of both
<artifactId>jsr305</artifactId>
Common interfaces like `Consumer` are useful primarily because of the APIs that require them. Since Guava doesn't have `forEach` or similar methods, libraries can declare their own `Consumer` types and get basically the same functionality.
@tavianator I'm only referring to your post -- you said yourself "It also requires Java 8's type inference; write Collections.<Number>unmodifiableList(ints) on Java â‰¤ 7."  So wouldn't that imply that Java <= 7 users would be required to insert explicit type arguments?
Good catch that `unmodifiableSortedMultimap` doesn't have this behavior. Very strange. I looked the the CL review, and it seems that the goal here might have been just to avoid casts, even at the loss of functionality (which the author acknowledged in a comment in the code).
That seems odd -- can you post reproduction instructions?
There won't be any progress on this until we've completed the Guava for JDK8 transition.
It looks like your `FakeTime` class is trying to do too much. You could keep a `ticker` instance internally, and then expose it via a `ticker()` method on your class.
- `NumberFormat` might not be supported by [j2cl](https://twitter.com/tbroyer/status/665562267174481921).
Path segments can contain `@`:
These are non-standard headers, but if they are very "common", then I think we should include them. We'll need to dig up some good reference links for the javadocs.
Yes, `volatile` saves the day.
>    - *M* guava/src/com/google/common/math/IntMath.java
> Patch Links:
CharMatcher.is('a')
@fge Like I said, it would be nearly impossible for us to normalize complex chains of `CharMatchers`.
This is surely useful to you and to some other users, but I think it's fundamentally no longer just an "intersection," and it's hard to explain what it is without saying "This makes sense only if you consider all empty ranges to be equivalent." That's fine, but I don't think it belongs in Guava itself.
(The specific reason that it's in my crosshairs is that it will become a little weird under GWT if we remove `Future.get()` from GWT in favor of making people call `Futures.getDone()`. It should still be able to work, and it will be weird only if you're writing a `Forwarding*Future` on GWT specifically (hopefully rare), but it's extra complexity for us, including testing complexity, since we can't use our usual reflection-based `Forwarding*` tests there.)
.putBytes(getSecretBytes())
> I'd like to request the addition of a Tree
> stable version of Guava, would appreciate.
> > I'd like to request the addition of a Tree
> > future stable version of Guava, would appreciate.
@jbduncan, a couple of things about your last post.
@liach It depends on which definition you use for "tree"; it's not a settled question in graph theory.
@liach If we were going to support trees at all, yes, we probably would.
to be out of beta.
On Thu, Mar 3, 2016 at 9:28 AM, jpangamarca notifications@github.com
> it's marked with the Beta annotation. I read about Beta APIs
`Verify` is still labeled `@Beta`  In fact, I think some people were just talking about this today.
- note that those have different ordering behavior from normal ImmutableMaps (insertion order); is that a doc thing, or actually worth splitting off a different API?  (Technically, it's consistent with ImmutableSortedMap...)
I'm not sure what this adds, on a couple levels:
We might not be using it anywhere else (in public Guava, at least), except:
How is Guava involved in this?
do {
For example they may be somehow involving both a released Guava and a
snapshot Guava the same time.
> I suspect 1ef638f
> versions of Guava. (After all, I don't think that 1ef638f
We don't know much about Gradle, but our own Maven builds seem to work fine.
A casual search for "\u2025" internally shows a number of people who are totally doing exactly the thing we wish they weren't.
From some internal code:
negative input rather than guessing at what behavior is "most sensible."
@mardibiase
Hmmm.  It's not entirely clear to me whether throwing on equals(collectionContainingNull) is actually allowed by the spec, even in cases where e.g. containsAll is permitted to throw.
Also for these MediaType additions, the hard work isn't adding the constants, but rather writing the javadocs, and digging up the proper citations for the javadocs.
> Eviction works with primitive, but cache doesn't work
@yuhanz, what that information tells me is that `weakKeys()` is a bad idea for your use case.  Garbage collection based caching just doesn't make sense for your problem.
@yuhanz, it sounds like you would be better off with `maximumSize` or some other size-based constraint, then.  All the details of how `weakKeys()` works pretty much inevitably follow from what weak references are and how they're implemented in the Java language.
@eaftan Have the error prone folks thought about this? (This annotation would be fairly worthless without enforcement...also "subpackages" really aren't a thing in Java...they're just different packages as far as the language is concerned)
The problem is `expectUnchanged`, which doesn't document the `KNOWN_ORDER` requirement and is unsurprisingly used in various places that it shouldn't be.
The `Splitter` API has been part of Guava since 1.0, and has been fairly stable (it's non-`@Beta` at this point). I'm somewhat doubtful that this use-case is popular enough for us to start expanding the API at this point.
Usually we're able to strip out that stuff, but since it's being constructed in a static block, it's a little more difficult. Since it's not hurting anything, I'm inclined to leave it as-is.
It's not clear what you mean?  If Guava doesn't report any error, then what
> Guava doesn't report any error.
Chris, any thoughts on whether these would be useful in Guava?
(I do wonder what's happening to the `StackOverflowError`....)
Sorry for the additional delays. I've submitted the fix (52b5ee6), which will be in Guava 20. Thanks again for the report.
This seems out of scope for Guava.
So in code like
Foo foo = foo.next(); // 3
But maybe that returns false?
@GwtIncompatible
@osundblad I still don't understand how you're getting `null` back from `Doubles.tryParse(null)`. What version of Guava are you using?
This is definitely a compiler issue, but it may be WAI even for the
> this with guava 16, then thinking it may have already been fixed it
never thought it would be an appropriate abstraction to expose. It's very
> But, if code that wanted to use Guava could use Cuts directly, it could
We've submitted #2594, which shows that the first test passes rather than fails as suggested in the original post. If you believe there's a bug here, can you clarify what it is?  Thread safety is a tricky subject, and I believe this logic is working as intended: the intention is to take a snapshot of cache activity, which may be racy.  See e.g. the Javadoc for AbstractCache.cacheStats():
@ben-manes, SimpleStatsCounter is already using a Striped64-based implementation for each of its individual counters.
Louis said: "Racyness is probably OK here, and done so for performance reasons. We should beef up the documentation though."
I'm not sure why you would expect this test to pass?  Guava does not guarantee a specific eviction policy  that would specify which items would be evicted.
Given that, I'm in favor of adding this (and `asCharSource(Charset)`).
>   @Nullable
Marking WAI.
We are sympathetic to the need for an interface, but we think new types of probabilistic sets can be developed and published separately from Guava.
@bdupras I personally don't have a need for that feature (I filed the issue on behalf of a user).
https://groups.google.com/forum/#!topic/guava-discuss/bwimfMksFWg
Random rng = new Random();
I don't know whether it was the original intent, but "sporting" isn't necessarily wrong here:
https://en.wiktionary.org/wiki/sport#Verb
FYI, while we think "sporting" was intentional, it's not a very clear word to use, so we are changing this to use the word "with" instead.
Thanks for the Amazon link. However, since it's not an official standard, I don't think we should add it.
much in guava/ itself.  We'll eventually get around to these packages and
Incidentally, does this mean that you use `ContiguousSet.intersection`, or did you come across the bug some other way? I ask because I see that `intersection` has found zero users in its four years of existence inside Google. Perhaps we should deprecate and eventually remove it. (We'll still take the fix in any case.)
`ContiguousSet` probably does deserve more users than it has. It would be nice to promote it a little more somehow.
@cpovirk, I'm a little confused about whether or not we need the GWT code in here; I don't see anything along those lines internally?
Background: Our GWT setup in Guava was weird: Some of the GWT files were autogenerated from the "server" sources, and others were manually written. But the autogeneration happened internally before we push our code to Github, so it was tricky to tell which is which. Nowadays, we don't do the autogeneration, so I think that the only GWT code left is "important" GWT code (well, aside from the *_gwt.java test files).
But this is a weird case: Because `ImmutableList` has a serialization proxy, `readObject` should never be called. The only case in which it can be called is the case in which a malicious user imitates a serialized `ImmutableList` that doesn't use the proxy. In that case, `readObject` serves to block this attempt, keeping the attacker from thwarting `ImmutableList`'s immutability guarantee. (This is covered in Effective Java, item 78 in the second edition.)
This method is quite possibly the right thing for your use case, but I would predict that it would be hard to add to Guava without encouraging misuse.
--- a/guava/src/com/google/common/collect/ImmutableMultimap.java
+++ b/guava/src/com/google/common/collect/ImmutableMultimap.java
+  @Override
"Alternative" "fix" that would not be very helpful in practice:
--- a/guava/src/com/google/common/collect/AbstractMultimap.java
+++ b/guava/src/com/google/common/collect/AbstractMultimap.java
@Override
@Override
I'm still trying to reproduce this without pulling in the whole of Guava.
@jbgi , for what reason do you build with JDK6? We might be able to find workarounds, but I would be worried that we'll miss cases unless we invest a fair bit of time in hunting them all down.
Guava's README on the front page specifies
@Override
We explicitly decided long ago for Guava to not get into the specialized primitive collections business.
Bnd-LastModified: 1408992499326
Bundle-Description: Guava is a suite of core and expanded libraries that
mon.primitives,com.google.common.collect,com.google.common.escape";vers
google.common.primitives,sun.misc";version="18.0.0",com.google.common.e
,com.google.common.primitives";version="18.0.0",com.google.common.xml;u
rimitives,javax.annotation";version="18.0.0",com.google.common.annotati
Tool: Bnd-1.50.0
down.  (Additionally, the Guava team doesn't own the project with that
...which would be very bad.
I'm not sure I follow, FWIW, why the collection's reference to the view
I think this should go in the Preconditions javadoc.
`InterruptedException` is a particularly good example of how this can get ugly, thanks. I do expect that we'll do something about this eventually. It's just blocked behind a number of other things :(  I do feel weird that the `Callable` version calls the `Runnable` version. It's not what you'd expect of a pure "decorator." As far as I know, though, submitting a `Callable` should still work. Are there cases in which it gives undesired results?
Now I'm confused: `delegate.schedule(Callable, ...)` appears to be returning a `Future` with the correct value. It sounds like you're saying that it doesn't do so for certain delegate executors. What kind of executors do I need to reproduce this problem? I would expect any executor, upon a call to `delegate.schedule(runnable, ...)`, to call `runnable.run`, which should be enough to get the proper return value.
From our own javadocs:
It's also not _entirely_ clear to me that this is something that should be changed, weird though it may be. What's the value in calling `getIfPresent` for a key on the same thread that already called `get[Unchecked]` on it?
jbduncan got the Error Prone team to successfully adopt Appveyor: https://github.com/google/google-java-format/commit/1961e6a7b4d252027d4bc428a8223cfa9eee67f9
This change violates the spec of Set.hashCode().
It falls back to super.equals(otherSet), which does use Sets.equalsImpl.
This does bring up the fact that many DiscreteDomain implementations
avoid all the damned boxing.
If this is a false positive, I apologize. Please reopen the pull request, and we'll have a look.  Guava-testlib is a wonder in most cases, but it's missing the most important part: the documentation. So even if the larger ticket #1705 takes care of this, please at least add the Javadoc online.
Are we calling this part of the job done now that we have a front-page "guava-testlib" link, or do we want the badge, too?
This seems deeply weird to me, and I really don't get why you think this is better than long if-else chains.  Maps are generally expected to have efficient get methods, which are outright impossible here.  Simple if conditions seem more readable and efficient here.
But:
**Background**: Most Guava data structures has a `builder()` method to instantiate a builder and it seems that's the default way of constructing/finding a builder.
We are working on some internally. Once they're ready, we should publish them in Guava. I don't know if there's a standard way to do this with Maven.
This issue here should stay focused on the integration of your idea into Guava.
I'm going to take a look at the details of this and try to have a concrete response for you soon. I will say that my initial inclination is that this isn't something we want to do in Guava: I think reuse of buffers is a bit of a fraught issue and one that should be explicitly under the user's control, which would really require a different API design than our libraries currently have. But again, I'll try to respond more specifically soon.
encoder.write("ab".getBytes(US_ASCII));
>       encoder.write("ab".getBytes(US_ASCII));
I think I recall similar discussions in the past around streaming escapers and perhaps in other contexts.
"which is now done in the guava fixture" What does this mean?  It's not 100% clear what fix you have in mind.  Is it just a simple Math.max in the size method?
Duplicate.
No, this is WAI; the intention is to test equality of the predicate by testing equality of the collection, and the test accomplishes that.
Note the `Q==` written after `other text to be written`.
Can you give us more details about what specific UnsignedShorts methods you would personally need?
Dupe of https://github.com/google/guava/issues/1911.
taking advantage of the new"diamond" syntax http://goo.gl/iz2Wi.
> At this time Guava needs to be compatible with Java 6. Since diamond is
> only available in Java 7+, IMHO, I don't think this is a good idea. I think
And it looks like it's present at Guava HEAD. It will be in version 19.
@throws IllegalArgumentException if {@code occurrences} is negative, or if
I'm not sure I understand why you consider the builder approach an ugly
> is a very nice alternative in Java land and I couldn't think of a way to
2   53% N
3   28% N
4   15% N
6   5% N
9   2% N
I note that ImmutableList and others go to 11 even though the advantage in
going further is much less (a varargs form takes over after that).
> 1 N
So do we want to follow that precedent and turn this up to 11?
I'm not sure what benchmarks you have in mind?
This may prove to be useful once Guava requires Java8, so we're leaving it in the research category.
There are two threads involved:
I always feel weird about the use of the factory method name "of" for a _mutable_ collection type. It seems wrong when what you're really expressing is just "_initially_ containing" -- and in this case it's something a bit less than that. (Ironically, it was a mutable collection type (EnumSet) that created that naming precedent in the first place.)
Going to close this as WAI
CopyOnWriteArrayList<String> cowal = ...;
Collections.sort(cowal);
> Throws:
> Patch Links:
Dupe of https://github.com/google/guava/issues/196
From the `Properties` javadocs (emphasis my own):
`but I had to play with strings a lot instead of a simple ClassLoader`
Optional.of(emptySet) colliding with absent() is pretty sad.
only happen via dumb luck.)
@cgdecker now that we have java8 specific code, should we bring this to API review?  This will absolutely be part of Guava as soon as we support Java 8, but I'm not sure there is much we can do until then?
> is 403 (Forbidden).
> due to its immaturity it isn't as easy to quickly script.
kak
So can someone explain why this single character change didn't make it for Guava 19 rc1?
Sorry about the lack of documentation. It's tough for us to mention every single API in the "Guava Explained" wiki.
@kluever I believe I proposed a `nullByteSink` at some point but we decided not to do it unless there was some need for it.
@nymanjens @jrtom FYI^ I'm not sure what it is that you expect the behavior of this proposed method to be.  I would guess that you would expect the output `Iterable` to be the concatenation of the independent traversal  starting from each of the supplied root nodes.
Note that `AssertionError(String, Throwable)` is not part of Java 6. We'll have to decide how important it is. As noted in #2012, we theoretically don't care about the version of Java required to _build_ Guava, only that required to _run_ it. However, we might benefit from Java 6 compatibility in our tests, since it could make them easier to run on Android.
I was asked internally whether it's possible to release a Guava compatible with both GWT pre-2.8.0 and GWT 2.8.0. I said:
> Suppressing a test in TFMIJU means that that test _shouldn't_ pass for any
> The whole thing is just weird. If there was an existing value for that key,
SomeAppThread:
SomeAppThread:
derivedFuture.cancel(true);
The FriendsOfGuava wiki page (https://code.google.com/p/guava-libraries/wiki/FriendsOfGuava) mentions another library, Glazed Lists, that can do this.  It's not immediately obvious what Guava can do to improve on solutions that already exist through other libraries?
Is this #1926 again? @cgdecker @fluentfuture @lukesandberg
I pinged @lukesandberg to investigate the possible cause.
Until then, I had hoped that I could restrict my search to classes that involve `clinit` from at least 2 `public` (or `protected`) classes. (It turns out, as expected, that Guava has a lot of cycles that involve non-`public` classes.) But if I restrict myself to cases in which at least 2 of the classes involved are `public`, I miss the `ImmutableList` problem.
On Fri, Feb 13, 2015 at 5:05 AM, Louis-Cyphre notifications@github.com
>   guava-gwt/src/com/google/common/base/Absent_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/base/PairwiseEquivalence_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/base/Present_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/AllEqualOrdering_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/ArrayListMultimap_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/ByFunctionOrdering_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/ComparatorOrdering_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/CompoundOrdering_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/DenseImmutableTable_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/EmptyImmutableBiMap_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/EmptyImmutableListMultimap_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/EmptyImmutableSetMultimap_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/EmptyImmutableSet_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/EmptyImmutableSortedMap_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/EmptyImmutableSortedSet_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/ExplicitOrdering_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/ForwardingImmutableList_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/ForwardingImmutableSet_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/HashBasedTable_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/HashMultimap_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/HashMultiset_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/ImmutableAsList_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/ImmutableBiMap_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/ImmutableEntry_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/ImmutableEnumMap_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/ImmutableEnumSet_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/ImmutableListMultimap_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/ImmutableList_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/ImmutableMultiset_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/ImmutableSetMultimap_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/ImmutableSet_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/ImmutableSortedMap_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/ImmutableSortedMap_CustomFieldSerializerBase.java
>   guava-gwt/src/com/google/common/collect/ImmutableSortedSet_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/ImmutableTable_CustomFieldSerializerBase.java
>   guava-gwt/src/com/google/common/collect/LexicographicalOrdering_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/LinkedHashMultimap_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/LinkedHashMultiset_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/LinkedListMultimap_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/Multimap_CustomFieldSerializerBase.java
>   guava-gwt/src/com/google/common/collect/Multiset_CustomFieldSerializerBase.java
>   guava-gwt/src/com/google/common/collect/NaturalOrdering_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/NullsFirstOrdering_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/NullsLastOrdering_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/RegularImmutableAsList_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/RegularImmutableBiMap_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/RegularImmutableList_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/RegularImmutableMap_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/RegularImmutableMultiset_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/RegularImmutableSet_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/RegularImmutableSortedMap_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/RegularImmutableSortedSet_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/ReverseNaturalOrdering_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/ReverseOrdering_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/SingletonImmutableBiMap_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/SingletonImmutableList_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/SingletonImmutableSet_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/SingletonImmutableTable_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/SparseImmutableTable_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/Table_CustomFieldSerializerBase.java
>   guava-gwt/src/com/google/common/collect/TreeBasedTable_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/TreeMultimap_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/collect/UsingToStringOrdering_CustomFieldSerializer.java
>   guava-gwt/src/com/google/common/primitives/UnsignedLong_CustomFieldSerializer.java
>   guava-testlib/src/com/google/common/collect/testing/AbstractCollectionTestSuiteBuilder.java
>   guava-testlib/src/com/google/common/collect/testing/features/ConflictingRequirementsException.java
>   guava-testlib/src/com/google/common/collect/testing/testers/CollectionSerializationEqualTester.java
>   guava-testlib/src/com/google/common/collect/testing/testers/CollectionSerializationTester.java
> Patch Links:
To be clear, Guava code is currently thoroughly hand-formatted.
> If so, could you explain me why the eclipse formater produces an invalid format and you have decided to build your own formater?
> Then, if I would like to contribute to improve guava, how I can configure my editor formater?
@rpau your comment was posted four times, so I removed the redundant copies but left one in place.  I wonder if maybe someone else was trying to do that at the same time.  Sorry about that.
This use case seems a little odd to me: you're returning a Function that claims to accept Number, but it really only works on Integers, and I believe it throws on other inputs.  Is that really behavior it makes sense to encourage?
- `Converter`: `doBackward`, `doForward`
-kak
And unfortunately those issues are pretty low priority for us, so it might be a while until we revisit this decision.
We're doing a bunch of thinking about how to make Guava better to use on Android, but it's in the very early stages right now so I don't have much to share as far as what exactly we'll be doing. The size of the jar and how effective or ineffective Proguard is for dealing with that is definitely one big thing we'll be looking at.
I consider the internal support to be an experiment we entered into under
a rational reason why different APIs should throw different exceptions in
- `Strings.rootLocaleFormat`: for easy static import
Oh, like in #1940, right? Sorry. I submitted a fix internally, but we haven't pushed it out yet. I'll do so now.
a warning (and use a - gasp! - raw type!), but this is just the sort of
This same issue affects many dozens of Guava methods, and we didn't want to
On Wed, Dec 17, 2014 at 11:06 AM, apogrebnyak notifications@github.com
>   futures.add(
>     Futures.addCallback(
>   Futures.addCallback(
On Thu, Dec 18, 2014 at 8:57 AM, apogrebnyak notifications@github.com
oh, you just want it to be chainable.  Sorry i totally misunderstood the FR.
My initial reaction was "sure, why not?" since it's `@Beta` (though we do sometimes avoid minor changes that have a chance of breaking users who use `@Beta` APIs where they shouldn't) and since minor convenience can add up.
Oh, wait, it's weirder than that :( `CompletableFuture.whenComplete` returns a future that...
- fails with the exception from the `BiConsumer` if there is one. If not...
warning:
This can lead to surprising behavior, so serializing the returned list is _not
@Override
As you note, a fuzzy `equals()` implementation has a potential problem: It will violate the [transitivity requirement](http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals%28java.lang.Object%29). This can lead to badly behaving collections and other problems. That's enough to discourage us from using `equals()` as a reason to add this method.
One other (smaller) difficulty: To add this, we'd need to name it. `fuzzyEqualsNullable`? I'm not sure that we have precedent for this naming question.
It looks like this was deliberate as a result of issue 780?
- It would be weird to get view behavior (via `subList()`) if the argument is a `List` and copy behavior if it isn't.
@eamonnmcmanus
We've always wanted to keep Guava backward compatible with previous versions of JDK, which is now giving us dilemma in issue 1738.
Discussion here: https://groups.google.com/d/topic/guava-discuss/FuyKu3oF_PQ/discussion
I don't understand why it should be like that? If 'to' is a supertype of Foo, how does SubFoo match?
it = strings;
Can FooEnum be assigned to Enum<?> ?
Can FooEnum and BarEnum be assigned to Enum<A> and Enum<B>?
Yes, if A=FooEnum and B=BarEnum
Can FooEnum and BarEnum be assigned to Enum<A> and Enum<? extends Enum<A>>?
Thanks for bringing this up, and sorry for the delay in responding. I don't think any of us have had a chance to look into this in much detail, but we'll try to soon. A big question for us would be whether the utility x ubiquity of this API is high enough to warrant adding to Guava. At a glance, it seems useful but I wonder (based on 0 research) how commonly it would be needed. Also concerning to me is the fact that it has a requirement (strictly increasing order for each component stream) that can't be checked when you create the merged stream, but instead could cause a failure later, possibly elsewhere in the code where it's not easy to trace back to the source of the problem.
Our hacked-up version of checkstyle that we use inside Google misses a ton of things -- well, as I guess you can see -- because we're hyper-averse to false positives, and because we've never put quite _enough_ effort into it.
That said, the state of Guava is not _quite_ as bad as this report initially makes it look. :-)
740 JavadocMethod
307 Indentation
A _couple_ real mistakes here, but mostly we need to exclude LongAdder and Striped64 from checkstyle runs because we intentionally left them in Doug Lea's style.
263 LocalVariableName
185 SingleLineJavadoc
157 JavadocParagraph
Once again these all look like they should be fixed. However, most of them are "catch... {}" and I think the error will have to be reported in different language or users will be very confused.  ("Empty blocks may only be represented as {} when not part of a multi-block statement (4.1.3)")
Also, we used this term "at-clauses" without defining it, which was bad of us. It refers to the separate _sections_ that start with @param, @return, @throws, etc. It does not refer to _inline_ usages of @code, @link, etc., so even regardless of the above, this line shouldn't be warning anyway:
We should document burstiness better so that it's not surprising. Do you also need a way to turn it off?
###### Unicode angle brackets
###### Escaping everything but a whitelist
I suspect that the big question here is whether such characters are valid Unicode characters, or maybe whether they're part of valid UTF-16 in Java Strings. The encoding issues here are messy, so I'll skip them for the time being.
###### Conditional escaping of `'<>`
Thanks for the comments. I'm closing for now, but if you find any examples of browser weirdness in practice (or if I missed replying to part of your post), please do let us know!
Actually, whether about Guava or not, questions like this belong on
Hmm, I've never used Kryo. Perhaps this bug should be filed against their project though?
The writeTo/readFrom custom serialization formats that we provide have been sufficient for our needs. Without a concrete proposal of what needs to change to support Kryo, there's no action to be taken here.
LGTM
AbstractLoadingCache says:
But this is simply not true; get(Object, Callable) is not defined in AbstractLoadingCache, and in AbstractCache it throws UnsupportedOperationException.
As I was attempting to say, Guava could only really do this by letting you use an anonymous class, since you can't use lambdas until Java 8, and the anonymous class would be so verbose that your code would be shorter if you wrote it the "normal way."
or even more pedantically
Questions:
It would be awesome if guava had a method that takes variable object arguments.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String key;
New idea:
tomas.za...@ï»¿gmail.com, discouraging imagination stifles innovation and creativity
@Override
@Override
@Override
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;artifactId>guava&lt;/artifactId>
@@
@@
The "problem" is the override in Converter:
to Converter, thanks.
higher scope
> sub-classes :
>     <Bug pattern="HE_INHERITS_EQUALS_USE_HASHCODE" />
I have coded a solution to this in https://code.google.com/r/craigwi-guava/.  The tests don't pass and so I'm not sure what to do about them.  It would make sense to change the eviction unit test to account for this change, but that hasn't been done yet.
Under what sorts of circumstances would the relative size of the segments vary significantly?  I'm having a hard time visualizing when this would happen other than a deliberate hash attack.
You can read more about these cases here: https://groups.google.com/forum/#!msg/elasticsearch/HZj2AR16oss/812kgZb8FhMJ and https://groups.google.com/forum/#!msg/elasticsearch/42qrpYRJvsU/IPArEH8KSYQJ.
Ah, I see. So first things first: if each entry was on the order of say ~1 mb or less, this would point to a bad hash function (or hash attack).
Re using AtomicLong, if this is anything more than an interlocked increment or compare exchange at the hardware level, that definitely would be the wrong thing to do.
The LongAdder is indeed interesting and inspired me to use a different approach for my requested feature.
I pushed the new approach to https://code.google.com/r/craigwi-guava/.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1854#c11) posted by **Maaartinus** on 2014-09-25 at 05:06 AM_
Concerning the AtomicLong, you could reduce the contention by updating it only when currentSegment.totalWeight has changed significantly since the last update, i.e., let's say by more than 1/8 of the segment capacity. This way you'd maintain an approximation of the total weight within this precision and you could ensure that no eviction takes place before the cache reaches 7/8 (instead of 1/segments.length) of its capacity.
http://en.wikipedia.org/wiki/Bcrypt
"A Future-Adaptable Password Scheme" by Niels Provos and David Mazieres (USENIX, 1999)
http://www.openbsd.org/papers/bcrypt-paper.ps
http://codahale.com/how-to-safely-store-a-password/
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1849#c4) posted by **Maaartinus** on 2014-09-25 at 12:55 AM_
I'm not saying that it doesn't belong to Guava, I'm just saying that it doesn't belong to the hash package. No HF is a KDF and vice versa.
Guava version 18.
Please add these overloaded methods:
I am having Guava loaded by shared classloader inside Tomcat and every webapp can register into static singleton EventBus waiting to incoming events. Problem is that it looks like that EventBus from shared classloader is unable to free registered methods when webapp is undeployed.
Ivos
`Using Guava version 17.0
class cz.bedla.guava.MemoryLeak loaded by sun.misc.Launcher$AppClassLoader@1d6535bf
Test using ordinary Guava
onEvent(guava.Callback$Event@edea70b)
`Using Guava version 17.0
class cz.bedla.guava.MemoryLeak loaded by sun.misc.Launcher$AppClassLoader@5fab9dac
onEvent(guava.Callback$Event@c063ed4)
`Using Guava version 17.0
class cz.bedla.guava.MemoryLeak loaded by sun.misc.Launcher$AppClassLoader@5fab9dac
onEvent(guava.Callback$Event@2aae2481)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1837#c1) posted by **Maaartinus** on 2014-08-27 at 03:18 PM_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1837#c2) posted by **bedla.czech** on 2014-08-27 at 07:13 PM_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1837#c4) posted by **Maaartinus** on 2014-08-30 at 07:44 PM_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1837#c6) posted by **bedla.czech** on 2014-08-31 at 07:08 AM_
Example (throws Exception):
I feel like if we were to do this, it should be a magic view method, which I think would be feasible, just somewhat tricky?
Sorry forgot to include: Guava version 1.17.
I checked the front-page of Guava and no, there is no link at all to the testlib javadoc. I played a bit with urls and couldn't find any url for the testlib javadoc.
I agree that equals() is worth special-casing.
Would it be interesting to have something like Debounce and Throttle functions in Guava?
I could try to send a pull request if you guys thing it would be usefull to Guava to have those.
Right now, this is pretty hard and requires dancing around the black box that the event bus is (https://github.com/groupon/jesos/blob/master/src/main/java/com/groupon/mesos/util/ManagedEventBus.java).
When rolling out an upgrade to a cluster of Guava powered instances there's a risk that local caches will expire within the same time.
[1] https://google.github.io/guava/apidocs/com/google/common/collect/Range.html
[2] https://code.google.com/p/guava-libraries/wiki/RangesExplained
Augh! How terrible.
3. Take advantage of more annotation and a more sophisticated type system (typically the Checker Framework). (Or, in some cases, introduce extra interfaces to Guava with different annotations on each.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1812#c8) posted by **dharkness** on 2014-07-22 at 01:36 AM_
When calling topPrivateDomain() on a domain that ends with .ET - Ethiopia or .ZM - Zambia   I get an IllegalStateException stating that the domain is "Not under a public suffix".
.ET - Ethiopia and .ZM - Zambia is on the public suffix list and should return true.
example : http://www.ethiotelecom.et
This is the code:
How can it be? It comes from Galaxy S3 4.4.4
Guava 17.0
That's pretty strange. The UOE is clearly coming from here:
one guava
Why one device? Or it's a rare bug and it was just an accident?
I really have no idea... I don't know much about proguard myself. For Guava 17's original source code, what happened should be impossible. So at the very least I don't think this is a problem with Guava itself. What exactly is causing it, though, I'm not sure.
catch (NullPointerException e) {
The culprit seems to be this code:
When converting a caml case String to Upper snake case the desired handling would be to consider the accronym (aka substring of only upcase caracters) as a single word. Instead the converter treats all consecutive upcase caracter as a single word.
(guava 17)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1783#c2) posted by **abecc...@mantano.com** on 2014-06-18 at 12:12 PM_
Forget about this, it might broke for sure existing usage, and a found a way around by having a pre-treatment where i convert acronym to real camel case using the following pattern:
&nbsp;&nbsp;/(?<=\p{Lower}|\A)(\p{Upper}+)(?=(\p{Upper}\p{Lower})|\Z)/  (groovy string)
If there is any interest I can contribute it; I have a CLA on file with Google but not specifically for the Guava project if that matters.
https://github.com/croco-bio/croco-api/blob/master/src/de/lmu/ifi/bio/crco/intervaltree/IntervalTree.java
The Interval classes used in the above are much less carefully designed than Guava's Range though, and so I see significant gain in having a RangeTree that various projects might all depend on.
Typically the apis I'm trying to test with this issue follow this pattern:
5. Something else
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1762) created by **matthias.kegele** on 2014-05-23 at 07:36 AM_
Perhaps this can be seen from different point of views: performance vs. code-style...
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1762#c4) posted by **matthias.kegele** on 2014-05-26 at 09:34 AM_
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1757) created by **bpan.mit** on 2014-05-16 at 05:53 PM_
I tried to install guava, but when I did "mvn install", I saw this:
Tests in error:
[INFO] Guava Maven Parent ................................ SUCCESS [  0.270 s]
[INFO] Guava Unit Tests .................................. SKIPPED
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1757#c2) posted by **bpan.mit** on 2014-05-16 at 06:04 PM_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1757#c3) posted by **bpan.mit** on 2014-06-02 at 01:35 AM_
https://github.com/parboiled1/grappa
foo.someOtherMethod(event);
Then whenever you want to register a Foo, you just do:
It's a mess.
- I found it to be somewhat flaky when run as part of Guava, even though it ran reliably internally. I'll be committing a fix/workaround shortly.
Related to issue #ï»¿784.
Can't you use either Collections2.permutations and Sets.powerSet and then filter out the results that aren't of size k? Might not be very fast for large collections, but...
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1746#c4) posted by **Maaartinus** on 2014-06-03 at 08:46 PM_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1746#c6) posted by **Maaartinus** on 2014-06-05 at 03:12 AM_
@Override
"tableHandle must be of type HiveTableHandle, not %s",
@Override
The only way to make the same Guava compile against both Java 7 and Java 8 would be to add a version of the new Java 8 AnnotatedType interface on the bootclasspath in Java 7, because getAnnotatedBounds has AnnotatedType[] as its return type.
This is not impossible, but would require noticeable changes to the way Guava is built, which we are investigating internally and externally.
(Louis, I assume that you're aware that we once had a crazy guava-bootstrap project around for dealing with an incompatible ExecutorService change? We could probably do the same here if we enjoy craziness :) Naturally that doesn't solve any problems with the internal build.)
I am going to do a little experimentation.
Sorry I misunderstood. Are you saying that someone under JDK 8, tries to use a Guava jar compiled under JDK 7?
That's a possibility I didn't think of.
Now thinking about it, how much better is it for us to hack up the dynamic proxy solution only to throw a different exception than NoSuchMethodError, when user could just use a pre-compiled jar?
For me, dynamic proxies have always been a future-proof way of implementing interfaces where you are not sure if they will later acquire new methods, and having explicitly-defined behaviour when any such methods are called. The need for this is much reduced starting with Java 8 and the introduction of default methods, but unfortunately default methods were not used in TypeVariable even though there is an obvious default implementation for the new method (return an empty array). Explicitly defining the behaviour in this way is in contrast to blithely allowing the JVM to throw a NoSuchMethodError [whenever](https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.4) it feels like it.
Regarding this compatibility issue, my preference is to leave it as is. If the user never calls getAnnotatedBounds() and JDK never calls it on their behalf, then using a JDK 7 guava jar is equivalent; if user does call it, UOE or NoSuchMethodError would basically tell user the same thing: "You can't do it". There is no chance this method is ever called in production either way, so I really don't care that much about the exception type.
return newArtificialTypeVariable(
public GuavaAnnotatedType[] getAnnotatedBounds() {
as(GuavaAnnotatedType[].class, proceed());
interface GuavaAnnotatedType {
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1735) created by **marcboga...@telenet.be** on 2014-04-22 at 01:33 PM_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1735#c2) posted by **marcboga...@telenet.be** on 2014-05-11 at 05:48 PM_
Would you like to add a multirator in Guava ? A multirator (named choosen in 5 minutes) is an iterator that encapsulates other iterators. I gives the next element based on the next elements of the other iterators.
@SafeVarargs
@SafeVarargs
@Override
@Override
@Override
for (final PeekingIterator<E> pi : iterators) {
@Override
for (final PeekingIterator<E> pi : iterators) {
if (smallest.compareTo(elt) > 0) {
What do you think about this multirator ?
Thierry
for (final PeekingIterator<E> pi : iterators) {
There appears to be some confusion, based on the fact that the doc of "set" does not use the word "atomic," but it is used for several other methods.
...it's a slippery slope. Where do we draw the line?
"I think Boolean is legitimately a special case, because of the greater variety of different rules different users will want or even expect, plus the fact that it's pretty easy to hand-roll whatever exact rule you want.
I also looked a handful of Converter&lt;String, Boolean> implementations that have been checked into the Google code base and found:
Most users will say "well, logically we figure it should use Boolean.valueOf()".  But how many of these users could tell you off the top of their heads what Boolean.valueOf() does? What does it do for null? "FALSE"? "tRuE"?
1. Boolean is a special case compared to the others because there is a much greater variety of behaviors users might want, and a much greater variety of behaviors they might assume.
2. It's also special because it's easy to hand-roll the precise behavior you want, which will leave your readers actually knowing what is going on with no surprises.
Btw, as reasons to add a library feature go, for us "symmetry" ranks pretty close to dead last. It's one of the things that's very different about Guava from many other libraries. Every feature has to pay for itself, not just seem like it is rounding out a complete set of something.
https://groups.google.com/forum/#!msg/guava-discuss/h_j4LrW98TE/Kkig916NHxIJ
Dimitri: is there any reason why we originally held this method back from public Guava?
As you can see, especially "maxBurstBuildup" is awkward to describe. It specifies it as a quantity of time, not permits (in the sense "maximum burst of 10 permits"), because then its meaning remains invariant even if the user calls setRate() and switch to a different rate limit.
the guava-gwt artifact does not declare Import/Export packages.
https://groups.google.com/forum/#!topic/guava-discuss/qg2R5mp6x7Q
I'm beginning to wonder if we should just release a UriBuilder that has the correct behavior in Guava and leave the one inside Google with the old behavior.
200 is arbitrary (and so would any value we'd place there). Are you just trying to protect against someone passing an insanely large number to limit()?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1689#c3) posted by **rhvarona** on 2014-03-04 at 12:37 AM_
@eamonnmcmanus What if we called .trimToSize() before wrapping + returning the ArrayList?
(For "split into N groups," see issue 451.)
**Labels:** `Type-Other`, `Package-General`
FIY, I'm waiting for an answer on https://issues.apache.org/jira/browse/ARIES-1159 before going further.
We think of bundling guava with our web application framework, where backwards compatibility for customer code is very important, but because all package exports always change in the major version, we couldn't update guava with a new release of our product, as customer code/bundles would always break. If package export versions for the packages that don't get an incompatible API change (most of them afaics) would not get updated, this problem would be greatly reduced to those cases where it actually is necessary to adapt client code.
However, phrase "Specifies a listener instance that caches should notify _each time an entry is removed_ for any reason." isn't 100% accurate to me, because notification doesn't occur _at once_, but as part of "routine described in docs", so whole sentence should be IMO rephrased. I don't know if you feel the same - if not, don't hesitate to close this issue.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1668) created by **hsaqallah** on 2014-02-14 at 07:48 AM_
I'm using Guava 16 in my project and having problems with GlassFish 4.0
[INFO] +- junit:junit:jar:4.11:test
[INFO] +- org.mockito:mockito-all:jar:1.9.5:compile
[INFO] +- opensymphony:sitemesh:jar:2.4.2:compile
The same error is happening with guava 15.0.x and 16.0.1
If GlassFish bundles its own guava, any idea how I can fix this issue?
Looks like there are a number of people dealing with similar issues.  I found this glassfish bug that may help.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1668#c3) posted by **hsaqallah** on 2014-02-15 at 07:24 PM_
However, with a complex key like this the hit rate and number of evictions goes up dramatically, e.g.:
It seems that if you put in a complex POJO as a key, something goes wrong in the Cache internals and we consistently get a hit rate of ~33%, never more. Very weird that it is always so consistent.
I admit, it is a bizarre issue. Any suggestions on what we may be doing wrong are welcome.
@Override
@Override
Unfortunately due to the proprietary nature of the application I am very limited in what type of code I can post.
Please close as invalid.
there is a magic number in the CharaMatcher : WHITESPACE_MULTIPLIER = 1682554634
**Labels:** -`Type-Addition`, `Type-Other`
Guava is a  brilliant libraries . so many wizrds in it .  so i start off Deliberate practice with guava line by line .
It would be very helpful for Guava to include a BigDecimalMath class mirroring the appropriate behavior in BigIntegerMath, in order to provide tested and robust implementations of common mathematical operators.
@Override
hashCode = hasher.hash();
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1652#c2) posted by **Maaartinus** on 2014-03-20 at 05:45 AM_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1652#c5) posted by **Maaartinus** on 2014-03-24 at 01:53 PM_
I don't know if this is even possible, but it seems like it should be...
The special case for the first item in the list seems odd (is the raw "List" type really a sub-type of Iterable&lt;E>?)
I'm guessing all of this is impossible for some reason I don't understand or it would already be there....
I know the dependency is kinda weird. But ignore that for a moment, if you had Guice's Types.newParamterizedType(), would you still have needed toGenericType()?
Exposing newParameterizedType() would work. I don't currently use Guice, so that option would be inconvenient. Seems like guava should have it's own version for completeness' sake, though that's a matter of opinion I suppose.
Okay. Whether it's possible to use Guice was what I was curious to know.
I'm torn between the two options:
I'll run this idea internally by others and see if I can convince enough people. If anything, I suspect a question could come up as "what is the user **really** trying to do through creating the wildcard type?". If you could provide some more information behind this use case, that might help.
It lacks type bounds checking, but delegates to Guava for the Type implementations.
FWIW, we've had this internally for about 6 years (the Android version is nearly a copy of the Guava version), but until we have tooling to support this, it doesn't seem particularly useful.
@eaftan Any chance we could get error-prone to support (check) the visibility field?  _[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1634) created by **zolyfar...@yahoo.com** on 2014-01-15 at 05:32 PM_
This class could be named Cleaver since this word is an auto-antonym tha means join/split.
We thought about the connection between these two classes, but felt the correspondences between "similar" features of Joiner and Splitter were actually much more tenuous than they first appear.
NB: I was torn between labeling this issue Type-Defect and Type-ApiDocs. Went with the former as I think a code fix is to be preferred over a documentation fix.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1630#c2) posted by **Maaartinus** on 2014-01-08 at 07:50 PM_
case INTERRUPTED:
throw new IllegalStateException(
&nbsp;&nbsp;&nbsp;&nbsp;exception.initCause(cause);
RE: `ThreadLocal` use:
if (foo instanceof AbstractFuture) {
But I guess the concern is that, if someone wraps `future` with a `ForwardingListenableFuture` or something, then we lose the ability to set the policy?
Disorganized thoughts:
@Override
throws Exception
@Override
throws Exception
@Override
@Override
@Override
Hello guava team,
Is such a feature planned for a future guava release?
Unfortunately, it does not work with locks and we
There is a simple solution to that which nicely fits into guava
-Kofemann.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1608#c1) posted by **tomas.za...@intelis.cz** on 2013-12-11 at 03:35 PM_
class FooLock implements Lock {
It's clear, that you shold not add into guava any crap ( that's the reason why we love it). So feel free to close this issue.
I'm not sure I want to close this issue just yet. It's not something we can do in Guava at the moment as a JDK6 library, but I don't want to rule it out entirely, since given the huge desire to do this it _might_ be preferable to create one good implementation in Guava. Maybe.
&nbsp;&nbsp;private Y y;
&nbsp;&nbsp;private B b;
This seems nearly like a dupe of #ï»¿1239...which we closed.
guava-15.0.jar
guava-gwt-15.0.jar
This Method can also be used with guava-collections by defining its own collector based on ImmutableCollection.Builder, but there is one catch:
There are at least three different ways to solve this problem:
- Accept the overhead until guava is JDK8-ready, then roll your own Collector which can access the package-private internal structure of the builder.
Since Guava 15 all these methods are marked deprecated. What is the recommended way to start/stop services (synchronously)?
**Labels:** `Type-Other`, `Package-Concurrent`
https://mail.google.com/mail/ca/u/0/#label/8-java%2Fguava/141e7f32e0596002
I'm filing this as bug.
Currently, Ints.tryParse accepts non-ASCII digits, while Long.tryParse does not. This is both undocumented and inconsistent. The questions are
- Should non-ascii digits be accepted?
- If so, should even mixed numbers like DEVANAGARI_DIGIT_ONE + "" + BENGALI_DIGIT_TWO be accepted?
Affected guava versions: InetAddresses in all up to 15.0
For historical reasons, people have been using the non-standard practice of wrapping checked exceptions in UTE from inside a Function implementation. We can change these existing users to using AsyncFunction which allows checked exceptions to be thrown.
private static Striped<Lock> stripedLock = Striped.lock(CACHE_CONCURRENCY_LEVEL*4);
(By the way, if the non-Guava piece were that simple, I probably would have used a LoadingCache.)  Anyway, it still would be nice to be able to get rid of this extra locking, since the separate locks will add some more contention.
We introduced `Futures.{whenAllSucceed,whenAllComplete},{call,callAsync}`. But we haven't addressed the `List` case, cancellation, or logging configuration. Hacky workaround: Ensure that every failure exception thrown is `equals()` to every other failure exception. You may be able to accomplish that if you control the exception type that's thrown, or you can using `Futures.catching()` to effectively replace any failure with a custom exception.  _[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1518) created by **kak@google.com** on 2013-08-29 at 07:19 AM_
via https://groups.google.com/forum/#!topic/guava-discuss/bwimfMksFWg
creating always given that matchers are likely to have long lifetimes and
matchers used in different contexts, but which then calls .negate() at
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1499#c5) posted by **Maaartinus** on 2013-08-15 at 01:30 PM_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1499#c6) posted by **Maaartinus** on 2013-08-15 at 02:35 PM_
Both of which are inelegant and/or underperforming.
FutureExceptionWrapper ex = null
else
Guava's cache only prefers fifo ordering, but does not require it. By not ensuring that constraint, the CLQ overhead could be reduced.
@ 4 threads
@ 25 threads
Which is patently false.
Anyone know what are the disadvantages of jar sealing?
I wished, Guava caches would provide a possibility to overflow to disk. I wrote my own solution which I summarized here:
http://www.mydailyjava.blogspot.no/2013/07/extending-guava-caches-to-overflow-to.html
Of course, I know that Ehcache offers this feature, but I often prefer Guava caches since they imply much less weight.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1481#c3) posted by **rafael.wth** on 2013-07-22 at 12:15 PM_
However, I understand that this goes away from what Guava caches originally intend. If someone has a similar requirement than me, feel free to use my code.
If it's a conscious behavior, I would suggest some warning into the javadocs.
Guava: 14.0.1
This sort of seems like it ought to be independent of Guava?
We have a usecase which seems, at least from the documentation I've read, to be more corner case but I think is valid and relevant.
On Wed, Jul 3, 2013 at 8:36 PM, null &lt;guava-libraries@googlecode.com>
On Wed, Jul 3, 2013 at 10:30 PM, null &lt;guava-libraries@googlecode.com>
Internally we've called this collapseDuplicates, but I don't see an issue under that name, either.
I don't feel at all clear on this being a good idea, just getting it down.
&nbsp;void writeTo(PrimitiveSink into);
and in Hasher:
and in HashFunction:
(It's not the first or even second thing in Guava that they want to use; I expect they'll hit critical mass eventually.)
-kak
Does Optional#presentInstances do the trick for you?
Does Optional#presentInstances do the trick for you?
Not really, as in, only if I really stretch it:
It sounds like you're asking for what some people would call the monadic bind?
anonymous inner class and by Optional itself?
> <https://github.com/notifications/unsubscribe-auth/AAhPOer0vTeQilh4nVKrS9OLOE_JiB8Oks5rkACEgaJpZM4C1jO5>
> On a tangental note I didn't know toJavaUtil was added. I am curious how
Are there going to be two jars?
Yes, two distinct artifacts.
> That is going to be interesting dealing with dependency management of
lot worse.
If they want to actually use Guava features that aren't present in the
Having a higher-order function that returns an Optional allows for much more aside from merely throwing an exception when the predicate tests false.
T t = bar(o);
But it's the other way around.
(and with expanded javadoc)
@ï»¿orionllmain
Again, instanceof, which I'm trying to avoid
So any war or ear that contains a guava 14.0.1 jar suffers from CDI seeing this and trying to create the bean but failing and thus failing the entire war from loading.
This error is from Glassfish 4.0
Can guava be modified to not use the @ï»¿Singleton and @ï»¿Inject annotations?
**Labels:** `Type-Dev`
BTW I do love Guice, and we have a few products here that use it extensively. But they are still deployed as WARs in JEE containers..
&nbsp;&nbsp;&nbsp;&nbsp;&lt;artifactId>cdi-api&lt;/artifactId>
&lt;/beans>
Gak,
Mind pulling down Guava, adding the annotation and seeing whether or not it works?  It'd be an interesting data point.
TIA.
I rolled back to guava 13.0.1 as a quick workaround ...
I ran a test adding META-INF/beans.xml to guava's jar in a webapp on glassfish 4.0, and it worked fine:
> cat .\META-INF\beans.xml
> jar uvf .\guava-14.0.1-bundle.jar .\META-INF
Can you add an empty beans.xml CDI config file to the guava jar ?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c19) posted by **mr.peter.somogyvari** on 2013-07-01 at 10:36 AM_
I'm in the process of upgrading to GF4.0 too. Anybody has some -not so fishy workaroundish- suggestions if I have a lib which declares guava 14.0 as a dependency?
Try overriding the dependency to use guava-13.1 in the
root pom or ivy.xml - it's likely that whatever library
you're using will run fine with guava-13:
to the guava jar - this kind of thing in ant:
In any case, while this is clearly an issue with CDI, if there's no good workaround that doesn't involve modifying the Guava jar in some way, we'll ensure this isn't an issue in 15.0.
Unfortunately in CDI 1.0 the inclusion of a beans.xml in the guava archive triggers scanning of it for CDI thus (potentially) breaking applications using CDI 1.0
GlassFish: cannot deploy war with google guava lib
We are getting similar error with Guava 15 and JBoss 7
It works fine with Guava 14.0.1.
Removing beans.xml would solve the problem.
Removing beans.xml from the guava-15.0.jar works. Is there however a solution that does not involve editing the jar file?
The beans.xml file in guava references the ee7 (beans_1_1.xsd)
&lt;/beans>
I guess glassfish-3 (also ee6, but no problems) has a different
version of CDI that it doesn't know about ?
Yes, it seems to be impossible for Guava to work out of the box for both CDI 1.0 applications and CDI 1.1 applications, which is a sad state of affairs.
Anyway - I hope you'll consider adding a few lines to guava's build-publish
things easy on all the ivy (sbt, gradle, ant, ...) and maven CDI1.1 users out there.  You can always stop publishing the artifact in the future if it becomes superfluous.  It's not unusual to do that kind of oddball artifact thing - guice publishes a "without AOP" artifact, and then there's the "for GWT", "for Android", "for AppEngine", "for JDBC3", "for JDBC4", "for pre-jdk5", etc variants of higher level things ... the "one ring to rule them all" dream died a while ago ... my precious ... ;-)
I tried to update guava in our application today.
When I try to deploy on glassfish 4, it works fine.
Deploying on glassfish 3.1.2.2 however fails.
&lt;/beans>
JSR-330 annotations have been removed for Guava 16.0, so hopefully there will be no further issues with CDI. Now we'll just have issues when code that was taking advantage of the annotations stops working.
So I hope Guava 16.0 will be out soon, because right now we're stuck on ancient (1,5 years old) version 13...
@ï»¿xaerxess: How are you stuck? Have you tried guava-15.0-cdi1.0.jar (with no beans.xml)?
> It's quite troubling because Guava should remain CDI agnostic and it will be true for version 16.
So, both guava-14.0.1 and (strangely enough) guava-15.0-cdi1.0 _are_ CDI agnostic. They only use JSR-330 annotations. To be clear: CDI itself is the problem here, because its specification prevents the use of libraries that annotate classes with certain JSR-330 annotations.
@ï»¿cgdecker: Thanks for detailed explanation, my wording was a bit unfortunate (regarding Guava and CDI).
So to sum up, in perfect world (with better CDI specification _and_ implementation) there would be no problem with JSR-330 annotated classes in Guava.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c50) posted by **antoine.sabotdurand** on 2013-12-27 at 01:53 PM_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c51) posted by **hsaqallah** on 2014-02-14 at 07:00 AM_
Guava 16 and 16.0.1 still have the same problem with glassfish 4.0. What am I missing?
What error are you getting?
Is it possible you have more than one copy of guava on your class path?
in a JEE7 Container
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c53) posted by **hsaqallah** on 2014-02-14 at 07:36 AM_
[INFO] +- junit:junit:jar:4.11:test
[INFO] +- org.mockito:mockito-all:jar:1.9.5:compile
[INFO] +- opensymphony:sitemesh:jar:2.4.2:compile
The same error is happening with guava 15.0.x and 16.0.1
Unless GlassFish 4.0 is including its own guava.
Glassfish bundles its own Guava.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c55) posted by **hsaqallah** on 2014-02-14 at 07:39 AM_
This appears to be a different issue.  Can you open a new bug?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1433#c57) posted by **hsaqallah** on 2014-02-14 at 07:48 AM_
/*\* Magic numbers have changed! @ï»¿see MagicNumbers */
class MagicNumbersChanged {
Yuriy
Supplier&lt;Optional&lt;T>>
Currently we can have a Cache that does that if our CacheLoader.loadAll() actually loads all, but we need to use cache.getAll(ImmutableList.of("foo")). But a call to the backend will be performed when we call cache.getAll(ImmutableList.of("baz")). This feels awkward.
This gives me fast primary key lookup and range queries on longs in Lucene and Accumulo.
import ...
Random rng = new Random();
&nbsp;\- Adds Javadoc
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1413#c6) posted by **Maaartinus** on 2013-10-17 at 03:33 PM_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1413#c7) posted by **Maaartinus** on 2013-10-20 at 01:36 AM_
Huh?  That issue also says you can write `new ImmutableSortedSet.Builder<Thing>(Ordering.usingToString())` as a workaround which is there for exactly this purpose.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1404) created by **aispina** on 2013-05-08 at 08:43 PM_
I have a sparse VO with a lot of fields of type List. I'd like my toString not to include those lists. Of course, I could code it myself, but it seems like a natural enhancement to guava.
} catch (SomeException e) {
} catch (SomeException e) {
This is part of the larger question of whether the transformation should be applied eagerly or lazily. Admittedly, Guava makes things more confusing than they ought to be: Iterables.transform is lazy; Futures.transform is eager. When the two collide, what should the user expect?
I would hope that Strings.format only allowing %s flags, would not misleading any users, but documentation handles that well enough.
This seems really, really weird to add a method with essentially the same API but strictly weaker capabilities than a JDK method.
Was Preconditions.format needed for something specifically Preconditions-related, or was there something that String.format wasn't giving that Preconditions needed at that moment?  Would anything else (in guava) be able to benefit from that extra bit of functionality?
And overall, it really doesn't have to be public at Strings, if it only makes sense for it to be public at Preconditions (if it makes sense at all to be public).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1389#c4) posted by **Maaartinus** on 2013-04-29 at 07:57 PM_
throw exception;
I believe that what you've proposed would be suited for Throwables, rather than Preconditions, when you propagate other exceptions.
Creating and/or throwing exceptions on some condition may call for something a bit more flexible:
implements Constraint<T, X> {
protected SkeletalConstraint() {}
@Override
@Override
extends SkeletalConstraint<T, X> {
String string
@Override
@Override
@Override
String string
forThrowableOf(IllegalArgumentException.class),
// no-args analogy
Jamie, your solution is definitely more flexible, but it's also a bit more complicated.
Firstly, my constraint was a bit different that the guava Constraint, and could have included an interface before giving you the skeletal implementation:
// this constraint is not satisfied
I would definitely rewrite ConstaintFromFunction, as a lot of what is being done is unnecessary (that was me typing at late hours of the night)...
extends SkeletalConstraint<T, X> {
@Override
@Override
@Override
constraint.accept(someArg);
extends SkeletalConstraint<T, X> {
@Override
throw exception;
What I'm proposing is to have this check built-in into google guava 's Preconditions(see original description of this enhancement). It does fit into it.
@ï»¿Lowas
you'll see around few dozens cases with check for null with subsequent custom exception being thrown
`MyCustomRuntimeException.check(expression);`
`someOptional().orElseThrow(illegalArgument("no results for %s", query))`
<artifactId>guava</artifactId>
To be honest, I don't know if the issue is in the way Guava is configured or if it's in m2e, so I try here first.
So, this is sort of an odd edge-case with maven and types and m2e and the fact that we made the guava artifact a bundle so the OSGI metadata would properly get in.  The issue is that the OSGI bundle type puts out a jar, but maven assumes that the type == the file extension, so there's a mismatched assumption there.  We did that because making guava a default jar type required some really flaky (and sometimes failing) steps to get the OSGI metadata merged in the manifest.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1383#c5) posted by **ogregoire** on 2013-08-01 at 02:58 PM_
// illegal argument
- IllegalArgumentException
- IllegalStateException
- UnsupportedOperationException
} catch (IllegalArgumentException e) {
throw new IllegalStateException(
IllegalArgumentException
-- illegalArgument(...)
IllegalStateException
-- illegalState(...)
NullPointerException
-- nullPointer(...)
-- illegalNull(...)
IndexOutOfBoundsException
-- indexOutOfBounds(...)
-- outOfBounds(...)
AssertionError
UnsupportedOperationException
throw illegalArgumentException(e, "Invalid authority '%s' found in URI '%s', authority, uri);
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1382#c8) posted by **ogregoire** on 2013-04-24 at 09:27 AM_
with the cause being the last parameter (where you wrote that the cause was the first parameter, Louis). It's barely acknowledgeable that we have a cause here as it can easily be mistaken with a parameter of the exception. If it went missing for some reason, a reviewer wouldn't notice much. And it might be only at runtime that the error is seen. On the other hand, if the cause is the first parameter, people notice it. I know it's bad to create factory methods just to switch the order of the parameters, but I believe that in this case, the JDK is wrong, and I've thought that for years, even before Java 5 and the varargs syntax.
Finally, this discussion[1] has some strong arguments against String.format(). Of course, here the context is the logging, which is much more sensitive than the exceptions, but I think that some arguments are solid in this case too.
throw illegalArgument(e, "Invalid authority '%s' found in URI '%s', authority, uri);
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1382#c10) posted by **ogregoire** on 2013-04-26 at 09:02 AM_
ogregoire, why shouldn't it throw the exception (and still keep the exception as the return type)?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1382#c12) posted by **ogregoire** on 2013-04-26 at 09:31 AM_
The pain is in creating the exception because
class [Exceptions|Throwables] {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String format,
// TODO
throw illegalArgument(e);
// TODO
throw illegalArgument(e);
@Override
throws Exception
throws Exception;
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1372#c3) posted by **tomas.za...@intelis.cz** on 2013-11-26 at 01:55 PM_
I can understand that desire, but I'm somewhat concerned that that's easily confused with some measure of the "size of the ranges," e.g. that a RangeMap with a Range from 1 to 42 would have size 42, or something along those lines.  Thoughts?
would using a DiscreteDomain be to obfuscating?
DiscreteDomain&lt;Integer> domain;
Updated pull request with more idiomatic Guava code:
Apache Commons IO has CloseShieldOutputStream and CloseShieldInputStream that have the same effect, but I prefer Guava and would think this is a worthy addition.
Possibly wait to do this until a version of Guava that requires JDK 7, since it's easier for users to do the right thing when they have multi-catch available.
// imports
I don't know why I feel it's weird (maybe just that the method name doesn't make it clear enough why one wants to do it).
Quick Reference: http://www.angelikalanger.com/GenericsFAQ/FAQSections/Features.html
Doesn't the FAQ only refers to "types with wildcards" as not concrete? Am I missing the piece where it also excludes Future&lt;T>?
I used "concrete" loosely; I didn't make that as apparent as possible. Is there a term that fits what I described? Namely, raw classes or parameterized types with no wildcards or type variables, or, at least, a method (or a few) that allow for query of whether wildcards or type variables exist.
// perhaps TypeTokens would suffice as arguments...?
That example is contrived, but I hope that it conveyed the point well enough.
containsAnyOf(Class.class, Wildcard.class)
containsAnyOf(Class.class, Wildcard.class)
? // true, Wildcard.class.isInstance(?)
isWildcard()
&nbsp;// from WildcardType
isWildcard() - getType() instanceof WildcardType
getUpperBounds would allow walking through WildcardType and TypeVariable bounds without introspection from the user.
&nbsp;&nbsp;&nbsp;visitWildcardType(WildcardType type) {}
Basically, different subclasses need different traversal strategies:
&nbsp;&nbsp;visitWildcardType(type) {
&nbsp;&nbsp;visitWildcardType(type) {
/// End points are classes
&nbsp;&nbsp;visitWildcardType(type) {
&nbsp;&nbsp;&nbsp;&nbsp;wildcardTypeVisited(type);
But it may still be counter-intuitive to some: When I see Map&lt;K, V>, I may think that K and V are the atomic leaf nodes because syntactically their bounds don't appear in the parameterized type.
visitWildcardType(t) {
I'm no security expert, nor have I mastered the security/crypto APIs in the JDK.  The resulting code usually leaves me wondering if I made some fundamental error that would be obvious to a security guru.  Plus it tends to be hard to read.  E.g. Cipher.doFinal makes me deal with checked exceptions that seem impossible in certain contexts.  It's also not thread-safe, which is a pain.
http://docs.oracle.com/javase/7/docs/api/javax/crypto/Cipher.html
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1361#c2) posted by **pawel.kr...@hush.com** on 2013-09-04 at 09:53 AM_
- internal bug 5324489
- https://groups.google.com/d/topic/guava-discuss/6E61UxtwErw/discussion
I think that a Cache&lt;K, Future&lt;V>> is a misleading idea. It just makes too
many things surprising.
complete mess.
> general way that soft/weak references are surprising. It's not obvious to me
> Future&lt;V> is different than Collection&lt;V> in this regard.
> problem which makes makes things even _more) surprising
There are various other concerns:
- Is asMap a map of Futures or just of values?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1350#c3) posted by **bahri.gencsoy** on 2013-12-13 at 08:56 PM_
There are several known forks of EventBus out there, and it's not unreasonable at all to do your own.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1346) created by **adigulla** on 2013-03-20 at 05:45 PM_
Please add this to Guava: http://blog.pdark.de/2010/05/28/type-safe-object-map/
I actually sort of like this, but in a variant form: the key should have no additional String parameter, and should use reference equality:
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1346#c5) posted by **adigulla** on 2013-05-05 at 02:42 PM_
I don't like it much. It deviates quite a bit from the Map API that we're used to. But it might be a case of "reject great new idea because of tradition".
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1346#c8) posted by **adigulla** on 2013-09-07 at 06:27 PM_
- Options / preferences to distinguish between int, boolean and String values.
Most probably almost everyone uses Guava's base classes; but others may not use the math classes, or the event bus, or the I/O classes. I can see a clear advantage in not having to bundle unused classes inside a completed application.
One could use Pro guard or other tools to 'trim' the final jars; but why do this in every project if it could be done inside Guava itself?
I think these constants would be useful in Guava as well.
Joiner.on(' ')
+1 from me, but my motivation is to use both Guava and Protobuf, and have them work better together.  e.g. Have ByteString implement ByteSource; return ByteString instead of defensive byte array copies in Guava, etc.
Many of the guava Immutable collections have a cute trick where they have specializations for zero (EmptyImmutableList) and one (SingletonImmutableList) element collections. These specializations take the form of subclasses of ImmutableList, to go along with the "Regular" implementation and a few other specializations like ReverseImmutable, SubList, etc.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1268#c4) posted by **ogregoire** on 2013-01-28 at 05:12 PM_
Unlike say, C++, every non-final instance method in Java is potentially virtual - that is, polymorphic dispatch is the default.  Naively implemented, these calls are brutal for performance - partly because the dispatch requires some indirection but _mostly_ because they aren't inlined.  Once a method isn't inlined you lose all sorts of optimizations involving the caller and callee, so it is really the "granddaddy" optimization that enables the rest of the optimization family to kick in for hot code with method calls. It's worth noting that the fast cases for my benchmark take between 0.6 ns and 0.9 ns per call, which is exactly 2 or 3 cycles (3.33 GHz box), which is pretty amazing given that there are a dozen bytecodes or more involved in each loop.  The JIT has done a good job!
Class Hierarchy Analysis (CHA):
OK, so the key points about CHA based devirtualization:
Yeah I guess the ImmutableAsList stuff can definitely cause issues too, but as you point out it all comes down to inlining: if the methods of the class that takes Iterable in the constructor are small enough to inline into callers, different users of that class shouldn't be impacted too much.
At least in the ImmutableSetAsList case, the caller shares some responsibility because he is passing in different types as input in the first place.
@ï»¿lowasser, keep in mind that this whole issue is a tiny slice of the larger performance problem.  We have a benchmark (that needs review) that shows certain characteristics for _runtime_ performance for a certain invocation pattern.  In general, we've made the choice to prioritize memory consumption over CPU for both the raw # of bytes in the heap and the overhead of GC.  We haven't even started the discussion about CPU cost relative to any possible memory implications.
If it's a deliberate design decision, then cool... but from an outside view, it seems pretty incongruous with the rest of the library. If it was just an oversight, I'd like to submit it as a suggestion for future releases.
True, a couple things intersect to make this confusing:
- We don't document "@ï»¿throws NullPointerException if parameter is null" anywhere in Guava. Instead, we annotate the packages with @ï»¿ParametersAreNonnullByDefault.
In general in Guava, parameters that are not annotated with @ï»¿Nullable will throw a NPE if passed a null reference.
derived classes:
Thanks for the suggestion, &lt;secret Googler>, but I'm going to say no, unless a strong counterargument emerges.
Maybe this could have a place in the GuavaExplained wiki documentation ?
long awaitNanos(long nanosTimeout)
boolean awaitUntil(Date deadline)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1204#c3) posted by **ogregoire** on 2012-11-15 at 01:31 PM_
No, I would like this change because DoubleMath.fuzzyEquals() is practically not suited for floats.
Plus, I'll add the "strangeness" to have to add _Double_ in imports in float-only classes is tickling me.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1204#c4) posted by **Maaartinus** on 2012-11-15 at 02:53 PM_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1204#c6) posted by **Maaartinus** on 2012-11-15 at 08:51 PM_
But you did _not_ fix it, 'cause the idea itself is totally wrong. When dealing with floats or doubles, there's (nearly) always some error and this error is (nearly) always much bigger when floats get used. This error can be upper-bounded and when this bound is low enough, the computation is usable. Whenever you depend on the exact value of the error, it's plain wrong.
fyi,
Let's also perhaps comment on the strange relationship between these two in their javadocs (e.g., why would it ever make sense to use both in the first place).
In retrospect, we should have done this in the first place, but now it would require a serious migration effort.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1193#c2) posted by **Maaartinus** on 2012-11-07 at 04:09 AM_
String regex = "(?=o)|(?<=o)";
Note that String.split works correctly here, but Guava splitter drops the last o.
String regex = "(?=Oo)|(?<=Oo)";
works correctly in Guava. That's because offset >= toSplit.length() logic doesn't get triggered above.
Guava does not follow this precedent, and I think we're right to make that decision.
There are plenty of other quirks that I'll bypass, such as:
Then we get to the interesting ones:
fob
ECMAScript also does the questionable thing in which splitting the empty string returns 0 elements (regardless of the value of |limit|, as far as I can tell), but we can look past that. At least it doesn't have magic trailing-empty behavior for negative |limit| :)
It's possible that the ECMAScript spec's detailed algorithm could be of help to us in our implementation. Then again, I thought I was already more or less happy with Louis's reimplementation, at least setting aside these weird issues that I don't think are worth worrying about anymore.
(3) is what Perl does, but the inconsistency is difficult to explain. I assume it was more of an accidental choice or a result of implementation convenience.
(4) is what nothing does, and it's inconsistent.
(I see an in-JavaScript implementation of String.split (StringSplit) in Chrome's v8 engine. I am too lazy to examine its behavior in detail (nor did I look at the C++ Chrome implementation beyond seeing that it had sentence-by-sentence comments from the spec), but it cites the same spec section as the C++ Chrome implementation. Additionally, I tested a few simple regular expressions in Chrome, and I see the behavior that the spec promises.)
&nbsp;&nbsp;Javascript: '1 2 3'.split(/ /, 2) = ['1', '2']
&nbsp;&nbsp;Java: "1 2 3".split(" ", 2) = ["1", "2 3"]ï»¿
Every once in a while, someone asks us for suggestions of things to work on in Guava. I usually float this as one of the possibilities. No one has taken the bait yet :)
- Guava Byte/LineProcessor - boolean processLine(String), T getResult() - you get a callback for each row/segment of data and are expected to have a returned accumulator
@Override
@Override
@Override
@Override
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1171#c3) posted by **tomas.za...@intelis.cz** on 2014-02-13 at 09:02 AM_
IMHO accepting issue would make Guava usage easier for those who cannot move to JDK8 now yet.
In reply to lowas/#ï»¿1: The issue with your proposal is that the function then needs to take into account getting a null value, which is a little annoying.
**Labels:** `Type-Dev`
(note the linked sonatype issue page 404s...)
@Override
@Override
@Override
@Override
@Override
@Override
@Override
throw new IllegalStateException("No right");
@Override
@Override
@Override
@Override
@Override
@Override
throw new IllegalStateException("No left");
@Override
@Override
@Override
@Override
But my main point is this:  What makes Either useful in functional programming is a combination of the error-handling, monads (let's ignore that), but also _pattern matching_.
but that is also less than ideal because the enums cannot hold a value, so we cannot protect against misuse of res.left() and res.right().
where fold is a function that takes two lambdas, one invoked if it is Left, the other invoked if it is Right.
class MyFoo {
https://bitbucket.org/atlassian/fugue/src
By the way it works WITH Guava, not replace it, right?
CÃ©dric
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1146#c3) posted by **amojobim** on 2013-03-01 at 02:59 PM_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1146#c4) posted by **blackduck.joe** on 2013-03-04 at 07:33 PM_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1146#c7) posted by **pouyou.fr** on 2014-01-16 at 05:00 PM_
We had to implement this behavior ourselves now, so +1 for having this in guava
Also had a requirement for this; it would be great to see this in Guava.
Waiting for a better solution from Guaua library, we are heavily relying on workarounds.
For instance, using Guava 11.0.2 the valid domain "miele.pm" fails
Of course we could fork the Guava code to add this additional flexibility but we'd prefer not to.
I don't think static state would be an okay thing here -- or anywhere in Guava -- but maybe there's room here for a builder or something for a pattern set?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1115#c2) posted by **nelqor** on 2012-08-20 at 03:52 PM_
But I am not sure how it is fitting for Guava.
I suspect that the superclass policy is going to be library-specific at best.  Users who want Spring's policy are probably best served by using its methods.
Constructing guava caches from strings has been a useful feature, however it does not allow the enabling of stats monitoring (in order to activate stats monitoring, you need to call .recordStats() on the CacheBuilder) and I see no reason for it not to be possible to enable stats recording when constructing a builder from a string.
Yeah, wasserman beat me to it.
And yes, I do realize that the timing of my filing such a minor suggestion is indicative of a ploy to claim ownership of issue #ï»¿1111. Rest assured it was entirely coincidental.
1. Lay claim to issue #ï»¿1111
&nbsp;&nbsp;throw new CorruptedFileException(e.getReadBytes());
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1111#c4) posted by **Maaartinus** on 2012-08-17 at 09:28 PM_
throw new EOFException();
I agree with Maaartinus' interpretation, actually.  I...think that might be a bug?
http://dhruvbird.com/lfu.pdf
Before we play with alternate eviction policies, we need to develop a means for evaluating the impact of the different policies.
https://groups.google.com/d/msg/guava-discuss/LV0oLNFpnAU/pp40shiiBKMJ
I use a Guava LoadingCache, hidden in a ResourceCache.
I am always nervous about unwrapping exceptions that are more than a level deep or that come from APIs not specifically designed to wrap exceptions (roughly, anything but InvocationTargetException and ExecutionException).  Such details are usually not well specified in documentation, and of course the compiler is of little help in type-checking, so relying on this feels fragile.  Granted, I'm not aware of any specific cases in which this has caused a problem, but maybe that's because most people seem to have the good sense not to do it most of the time (apparently including you) :-P
if (e.getCause() instanceof ResourceException) {
Semantics I am looking for:
http://metrics.codahale.com/getting-started/#counters
> About making BloomFilter a Predicate... umm. That feels a little weird, I'm not
> doesn't know what a BloomFilter is, doesn't make it very obvious what
> BloomFilter#apply does (which side can err), unlike #mightContains, which is a
than
That said, I wonder if the funky bootstrap technique we used to make Java 5/6 compatible might be applicable here.
-Should it return an Optional?
varargs suck, but there are lots of internal usages!
gak to investigate all varargs methods.
https://code.google.com/r/tomaszpancho-bloom/source/detail?r=404c8dd129abacbf114f2aff27af738767f10058
https://code.google.com/r/tomaszpancho-bloom/source/detail?r=7c552aa969d73def97cdfca4d16e7a368ff23390
Pancho
Dimitri?
short-sighted we were!
I meant to label this as an enhancement.
That being said I can easily go into candy land with enhancements like: Joiner.onFirst('') and Joiner.onLast(", or ") ... so that I can do "'1','2', or '3'"
&nbsp;&nbsp;&nbsp;return Joiner.on(',')
BetterAppendable&lt;A> ba = new BetterAppendable(A a); // where &lt;A extends Appendable>
I'm not ruling out the idea of an API in Guava that can handle CSV writing and parsing (it's actually something I'm kind of interested in, having experimented with writing one a while back), just saying that I don't think Joiner is the right place for something like that.
The reason I prefer this is that most of the classes in Guava are semi idempotent.
I find the Joiner somewhat disturbing in that it will take a String and/or Appendable.
I think all Appendable mutations should be in separate classes like my BetterAppendable.
Not to get to pedantic but I'm comparing it to Haskell where there is a strict separation. Pure functions can't do bad things and therefore are "more" guaranteed to be threadsafe. That is a function could never operate on an appendable (with out some monad transformation).
But this is Java...
Actually my way is way more flexible and powerful.
FileWriter fw = new FileWriter(new File("concatwithsep.txt"));
That said, any _major_ changes to the Joiner API will require considerable debate and discussion, and I think it's more likely we'd end up with an entirely new, separate API than making that sort of major change to one of the stablest APIs in Guava.
The reason I keep bringing this up is that I work with very large amounts of data. So most of my algorithms work with Appendable's and Iterators and not Strings and Collections. Although I am sure it won't happen I don't want to see the escaper API
Oh I didn't see he (@ï»¿yo..) proposed adding a method transformValues(). I suppose yes you could do that with Function (although it seems rather against the contract of Function).
@jingwei027git and if the list is empty, it returns the string `''`, which is most likely an unwanted feature.
Notice that even Guava's JavaDoc recommends using bitset:
Wasserman.louis I did not know about BigInteger.testBit() and you obviously are more versed (and probably smarter) than me on BigInteger. I'll have to look at the JDK core more closely.
I know Joshua Bloch is the Jesus of Java and he's probably right.
Might be worth exploring.
http://www.dishevelled.org/bitset
http://www.dishevelled.org/bitset/apidocs/index.html
Sure it works but it looks a little bit foreign if you have several preconditions:
P.S: an alternative would be to overload checkAgrument.
whats with this?
@Immutable
@Immutable
But that's even more complicated than the original solution.
"even more complicated" ?!
is more complicated all together than
to say nothing of more complicated predicates.
Perhaps that is a problem that should be addressed at some point. This seems to be a Google-internal restriction, because the rest of the world sees Guava as one artifact. Isn't there a way to work around this problem?
Alternatively: could Preconditions be moved to another package? Because I'd think Preconditions should be aware of the most important Guava data structures.
Did you never thought "Hum, why I have to interrupt the flow with that checkAgrument line?"
I would only use checkAgrument like checkNull.
But I'm not wedded to them, and I'm not satisfied that this is the right way to do things.
and it seems unreasonable that someone would be messing around with the Predicates.
Do any other members of the Guava team have an opinion?
as an alternative to the current
yes, to use checkArgument like checkNotNull
@ï»¿louis
that with the Range was a faux pas. Sorry.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1038#c27) posted by **Maaartinus** on 2012-06-23 at 09:37 PM_
GeoPoint(double lat, double lng) {
Unfortunatelly, you probably want to say something like "X must satisfy P" for a general predicate (e.g., "isEven", "isEmpty", "hasParent"), which is inappropriate for "[-180..180]". So in order to make the generated messages comprehensible, an "instanceof Range" test (introducing the cyclic dependency), or a class name test, or a very different formulation is needed.
I like the idea of having checkArgument(predicate,T) return T because it gives you the ability to call off of it, but it's also a little unclean
Hmmmm.  Truth (used in Guava for testing) essentially provides fluent assertions in tests; I wonder if it could be coopted here.  That said, it probably wouldn't return the value being checked.
Emily: I don't understand your example. Also, "LATITUDE" is an awkward name both for a predicate as well as a range.
Being able to provide my own handerfindingstrategy would allow me to use the guava event bus implementation, without the above limitations.
the quote from a guava team member seemed to conflict with the "Research" status of this issue. But I'm excited to hear that you are considering allowing custom handler finding strategy in event bus!
Just like  f.vanlan...@ï»¿1hippo.com I also had to use a split package and fork, but this is definitely not a good solution...
I don't yet have an opinion on whether this is worth adding to Guava or not, but perhaps other folks might.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1029#c8) posted by **blackhc@google.com** on 2014-03-27 at 04:31 PM_
AutoClosable only came into existence in 1.7 and is outside of scope for Guava at the present moment.
However when Guava moves to 1.7 Closable extends AutoClosable so this should be a trivial change then.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1020#c2) posted by **aklitzing** on 2012-05-31 at 10:25 AM_
If you're _not_ on Java 7...I don't think we can feasibly add 29 additional overloads to every Guava method that expects a Closeable.  =/  We have to draw a line somewhere, I think?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=1020#c11) posted by **aklitzing** on 2012-06-01 at 08:35 AM_
As of 12.0, Guava is still using FindBugs 1.3.9 and specifically the JSR 305 annotations artifact. FindBugs 2.0.0 has been out for many months now and as their website says:
**Labels:** `Type-Dev`
Guava's use of JSR-305 is a bit of an edge-case in maven, with respect to scoping and optionality of dependencies.
Guava's use is about halfway in between, and is still different.  We use findbugs to provide an annotation whose bytecode does NOT have to be present at runtime, and if needed, will be provided by some other means.  But we're not choosing from multiple options, and we're not necessarily running in the container.  In our case, either mechanism behaves in exactly the same way.
Just to summarize from #2721: We want "present at compile time but not at runtime." But `optional` (and probably `provided`?) means "present at _Guava_ compile time but not at _users'_ compile time or runtime."  _[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1010) created by **em...@soldal.org** on 2012-05-23 at 04:42 PM_
I would appreciate an aggregation method in Guava. I made my own utility class years ago, before Guava era. Let me share some observation from its usage and from reading the https://groups.google.com/forum/#!topic/guava-discuss/NfE09gFfPjU/discussion :
Doe
+Joe
Roe
+Jane
My dream Guava API for this would then look like
@ï»¿tomas, I think there are two different things going on here.
- grouping by HashFunction (?)
- grouping by Comparator (contiguous or not)
- combinations of the above
- grouping by HashFunction (?)
- grouping into chunks of K / grouping into K chunks
"- K chunks in N is tricky as you will have to judge the size of the iterable before figuring out how big a chunk should be"
Sorting by equivalence feels iffy to me, although I guess theres nothing strictly speaking wrong with it if its made strict? o_O
Tangentially I found that Iterable&lt;Iterable&lt;T>> isn't really feasable if you wish to do it as a view of an Iterable, so you end up either producing a copy of the entier iterable or a copy of the particular grouping within the iterable.
// potentially higher, lower, ceiling, floor
// potentially unique indexing
// potentially higher, lower, ceiling, floor
Questions:
We want to do this, but there are numerous challenges.
I noticed the possibility of this approach back in Issue 536, but I couldn't think of a good reason to be sneaking around the Java API like that.  Can you convince me that this is useful enough to be worth the clutter?
Then again, if I could rewrite the API from scratch, I think it'd make sense to get rid of all the automatic IPv6->IPv4 conversion, but I have no idea if anyone's relying on the current behavior.
Note: Wicket also gives a warning when have the following code:
&nbsp;&nbsp;&nbsp;&nbsp;COMMA(','),
&nbsp;&nbsp;catch (SomeException e)
2. Use your custom class.  (I'm hesitant to put it in Guava as described above, but you may judge its benefits to outweigh its downsides in your particular use case.)
3. Use an Iterator&lt;ValueOrException> or Queue&lt;ValueOrException>, where ValueOrException is some custom class containing, well, you know...
However, I might be interested in experimenting a little bit with a version/implementation of the alternative interface you mention, out of personal interest mostly. Do you have any more details about the requirements you have in mind?
Any comments on the above? Is any of it worth sketching out in code?
For the exception type, we could go a couple directions:
I hesitate to say "Code is up" because I admit that I've gotten far enough behind on other stuff that it will be hard to prioritize this, but this remains something that we should give serious attention to... at some point.
That's exactly why that class is called PrimitiveSink instead of just Sink. :-)
I've also thought a bit about differentiation from other abstractions, in particular BlockingQueue and Iterator. Here's what I think would distinguish Producers from the above:
- size(), contains(), etc., also don't make sense.
http://okmij.org/ftp/Streams.html (Oleg Kiselyov, who is generally credited with developing the abstraction)
Hmmmm.  I wonder if CharMatcher is @ï»¿Beta because of changes like https://github.com/google/guava/commit/4077f6011814ef7db2a36671864beed21034ecdb which are necessary to keep CharMatcher in sync with the latest Unicode standards.
So what is keeping this as @ï»¿Beta?  I thought that we discussed this internally at one point, but I can't find email, so it may have been in a meeting.  Maybe Kevin knows?
Ideally, Guava should notify the methods regardless of permissions (ideally they should be private in my opinion, to prevent direct calls.)  Furthermore, if marked private, unused code warnings on the methods should be removed automatically without requiring the author to further annotate the method.
public class GuavaEventBus {
Why would you pass random objects with no subscribable methods to register?
But this sounds like a fairly specialized case - I would think most people would want it flagged as an error if they explicitly try to register something but actually under the covers nothing gets registered.
> Why would you pass random objects with no subscribable methods to register?
So I'm not suggesting that this behavior is of no use to anyone. But _I_ do think this is a rather specialized case. Maybe it should be supported with its own method (with a name that clearly indicates its non-complaining nature).
should cause an exception (but it does not):
If you want to round to a specific number of decimal points, you absolutely must use `BigDecimal` from start to finish; if you ever have an intermediate `double` you risk [nasal demons](http://www.catb.org/jargon/html/N/nasal-demons.html).  _[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=951) created by **gilroy** on 2012-03-30 at 02:42 AM_
I guess the reason that these are hidden is because they trigger an interesting question: What hash function do you try to implement? We would like to have a more comprehensive offering/variety of algorithms, perhaps you have a useful suggestion to make?
We place a high value on making it as difficult as possible to shoot yourself in the foot.
I'm not sure where you got that impression, Louis.  Two of my frequent utterances are
@cgdecker said: "I'm thinking it's not binary compatible: "Changing the result type of a method, or replacing a result type with void, or replacing void with a result type, has the combined effect of deleting the old method and adding a new method with the new result type or newly void result (see Â§13.4.12)."
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=932#c5) posted by **yaniv.kunda** on 2013-09-24 at 01:39 PM_
Prefix/suffix customization may seem unnecessary for temp dirs, but those are sometime examined while debugging, and can be useful in such scenarios.
an enum?
...or something completely different.
Hi! Thanks for all your great work on Guava.
That said, I can see a few variables here:
Is there a reason for not exposing this yet? Do you expect breaking changes?
That said, I look at the ordering (as distinct from "the ordinals," somehow) as an exception, at least in some cases.  Java kind of encourages this, too, by making enum classes implement Comparable (though it's not clear that this was the right choice).  I've been known to do something similar to this...
There's still a question of whether that would happen often enough to make the DiscreteDomain worthwhile, but I'd tend to view the cost of a new DiscreteDomain as pretty low, so I'm +0.5 on this, at least to see whether it would be used.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=909#c3) posted by **daniel.yokomizo** on 2012-02-24 at 11:36 PM_
It's not an essential feature (in every project I have dozens of small classes that I would love to see in Guava :), but yesterday I wrote it again so I thought about putting it here.
I can see the similarity with Haskell's Enum typeclass, and the weekday/month application does seem appropriate for a DiscreteDomain.
There are Multisets and Multimaps.  Why not Multitables?
That said, markaf, I can think of another solution for your specific case: use a normal Multimap, but combine the first two fields into a composite key.  It doesn't sound like you need to view the rows or the columns of that table, you just want to look up on multiple keys at once.
assylias
Do the previously mentioned workarounds not work for you?  I still have a tough time imagining this having enough demand to get added to Guava.
Right now, I've got some ugly code around:
Table&lt;sourceParameterIndex, targetParameterIndex, Set&lt;CandidateParameters>>, but I'd love for Multitable to be part of Guava.
But having said that, I don't personally need that kind of fancy queueing functionality- the first API would meet my needs just fine.
- limit(cycle(element), count) <= not elegant
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=886#c2) posted by **ogregoire** on 2012-01-27 at 02:12 PM_
**Owner:** wasserman.louis
assert 1 == count("axx", "xx");
assert 1 == count("axxa", "xx");
assert 0 == count("xaxa", "xx");
https://groups.google.com/group/guava-discuss/browse_thread/thread/cea923625cf9edb6
(The Splitter approach is neat.)
&nbsp;&nbsp;&nbsp;private String s;
I'm not sure if I would put any of the three approaches count, indexOf or span in Guava.
interface BeefySupplier&lt;T> extends Supplier&lt;T> {
mindas, have you seen Suppliers.memoize?
&nbsp;&nbsp;public static Bar get(Baz baz) {
&nbsp;&nbsp;return DUMMY;  // Cannot return null
So Ugly, I know. I cynically use its "should get() be run now?" logic without anything else that has to do with a cache.
Not sure if this should be its own issue...but... I just recalled that one of my earliest "guava-like" classes was resettable variants of MemoizingSupplier and ExpiringMemoizingSupplier.
**Owner:** wasserman.louis
Mindas, what you describe _seems_ like something that should be filed separately.
Perhaps we need to make this more clear in the javadocs somehow though?
&nbsp;&nbsp;&nbsp;@ï»¿Beta
Cheers, Aled
Martin:
but here too I'm not sure what the standard practice is when obtaining a
would at least cost an extra volatile write on every refresh (or resort to
Unsafe).
here could help, especially since the behavior is inconsistent with
I know Optional is relatively new and that somehow invalidates my argument of well anchored code; I don't have an argument against that.
From my point of view, it's strange to filter a single item.
Foo foo;
Optional&lt;Baz> baz = Optional.of(foo)
// form via FluentPredicate
Optional&lt;Baz> baz = FluentPredicate.from(compose(in(allowedBarNames),Bar.NAME_FUNCTION))
Offtopic note: I filled issue https://github.com/google/guava/issues/1171 for similar reason.
&nbsp;&nbsp;Optional&lt;User> user = userDao.findByEmail(email);
&nbsp;&nbsp;Optional&lt;User> user = userDao.findByEmail(email);
&nbsp;&nbsp;Optional&lt;User> user = userDao.findByEmail(email);
In general I am really liking the guava library.
Adrian
Please feel free to reuse anything for Guava you might find useful.
http://codahale.com/how-to-safely-store-a-password/
http://code.google.com/p/jbcrypt/
bcrypt stores the salt and hash as a String.
http://en.wikipedia.org/wiki/Bcrypt
http://www.mindrot.org/projects/jBCrypt/
I wonder how difficult it would be to take a given HashFunction and iterate it n times.  That'd be my preferred way to address this issue.
"It's easy to get carried away and try to combine different hash functions, hoping that the result will be more secure. In practice, though, there is very little benefit to doing it"
http://en.wikipedia.org/wiki/PBKDF2 or bcrypt
http://en.wikipedia.org/wiki/Bcrypt.
> cryptographic hash function such as SHA256.
Using Guava 10.0.1 and GWT 2.4
Interestingly, in Guava r09, everything worked. I wonder what changed?
- a few others for which there is probably no rhyme or reason (probably some were specifically requested)
The usual solution to this problem is to declare RPC interfaces in terms of a specific type, probably ImmutableMultimap&lt;Foo, Bar>. Then the client needs code only for ImmutableMultimap and any classes used on the client side, not for every Multimap implementation in the classpath. So we certainly can add more serializers, but we're placing a small burden on them. (It can be hard to figure out why GWT download size increases, so the problem, while easy to fix in many cases, can be difficult to track down, especially for someone not familiar with the intricacies of GWT serialization or with the changes in a new version of Guava that he may not even realize he's using.)
I am finding myself writing increasingly complex functions these days, the introduction of Guava and the use of the Function/Functions methods for accessing data is proving to be very useful.
I have been working on an implementation of a similar mechanism before I stumbled upon the guava one. Basically it does the same thing but uses weak references to the registered objects. The motivation behind it was that in a spring environment I wanted to use bean post processor to register the listening beans. Since a bean might have a different scope and might be short living I don't want to end up having all the objects prevented from being garbage collected. And I do not want to leave the burden of unregistering objects to other developers. I like the idea of the contract: Add the listener and as long as it exists it will receive events. If the listening objects dies then it will be removed from bus. It seems that this is kindof easy to handle from a user perspective (but a little tricky to implement, especially in concurrent environment).
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=807#c22) posted by **tadas.subonis** on 2012-07-22 at 10:05 AM_
You can check it out here: https://github.com/bennidi/mbassador
Sorry, for that "cross marketing" here but I see that other people have the same needs as I do and are thus not able to use the guava version of event bus. Besides, I love the guava library and have been using it in production for a while now.
Since my dialogs are confined to a few controllers, it's not out of the question to wrap their usages in something like
What was my surprise when I saw that no OutputSupplier factory methods exist in Guava except for those in the Files class. It really felt like there is a whole part of the I/O API that is completely missing.
Well, I wrote BAOS and CAW, sorry for that. My real need is the next part of the sentence. Here's my use case.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=806#c4) posted by **ogregoire** on 2011-11-30 at 09:17 AM_
would it be possible to add the code that google has written for escapers into guava
https://google.github.io/guava/apidocs/com/google/common/xml/XmlEscapers.html
https://google.github.io/guava/apidocs/com/google/common/html/HtmlEscapers.html
From what I've been told, the API needed significant cleanup before it could meet Guava's standards.  I don't know if we have a time estimate, but it'll make it out eventually.
It's on our list of goals for Guava 15!
https://google.github.io/guava/apidocs/com/google/common/html/HtmlEscapers.html
https://google.github.io/guava/apidocs/com/google/common/net/UrlEscapers.html
https://google.github.io/guava/apidocs/com/google/common/xml/XmlEscapers.html
kofemann.
Not knowing if an object was registered in the eventbus, causes some problems down the road.
http://groups.google.com/group/guava-discuss/browse_thread/thread/80e04c168b18a3d3
I think you're getting at two separate issues here.
isReceivingEvents in particular is tricky.  What if the event bus got GC'd?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=784#c19) posted by **Maaartinus** on 2012-10-04 at 04:55 PM_
@ï»¿rc.poison:
Also complains not being able to find javax.annotation.Nullable
guava 10.0.1, gwt 2.4.0, java se 1.6
javax.annotation.Nullable is available from JSR 305, which is listed as a Guava dependency in the Maven POM:
&nbsp;&nbsp;"/GwtGuava/src/com/test/gwtguava/GwtGuava.gwt.xml":
That said, I think it would be helpful to have a clear and consistent instruction from the Guava team. Since we've heard that we don't need that jar, we assume there's something wrong. But if all that's needed is to get the jar, just making that explicit would be helpful (as well as, perhaps, a link to the jar?)
As far as additional metadata... I think this is where we run into different people using different technologies. Some of us are using Ant, some Maven, some use OSGi... I doubt there is a one-size-fits-all solution.
Victor,
**Labels:** -`Priority-Medium`, `Priority-High`
Victor,
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c29) posted by **dusan.maliarik** on 2012-03-07 at 11:54 AM_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c32) posted by **dusan.maliarik** on 2012-03-07 at 12:13 PM_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c36) posted by **gentijo** on 2012-05-27 at 05:28 AM_
Mac (Lion)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=776#c37) posted by **gentijo** on 2012-05-27 at 07:19 AM_
We're using Guava 11.0.2.
Pre-populating a cache is a common use case for loading static data from a database. This would also be specifically useful where lazy loading is not ideal. Please see http://stackoverflow.com/questions/7915016/pre-load-values-for-a-guava-cache for a specific case where this would be useful.
@Override
@Override
While Cache has getAll
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=775#c8) posted by **mar...@aie.pl** on 2012-01-04 at 11:02 AM_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=775#c10) posted by **mar...@aie.pl** on 2012-01-04 at 04:16 PM_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=775#c12) posted by **mar...@aie.pl** on 2012-01-04 at 08:35 PM_
https://groups.google.com/d/msg/guava-discuss/-DHg4Hi4sQE/HmlhQd8nkowJ
It's very unclear what if anything needs to be done here.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=775#c20) posted by **mar...@aie.pl** on 2012-11-09 at 11:42 PM_
MichaÅ‚
I would love to replace our implementation of a synchronous event bus with the one from Guava. They do pretty much the same thing except for one notable difference: Ours propagates exceptions that happen during event handling since event handling must occur in the same database transaction as the code that raised the event. Is there any chance to make this configurable (flag/subclassing)?
I concur that it's not at all clear how the semantics of this would work, due to the lack of ordering on handlers.  Would all the other handlers still be called?
1. Distribute the events in arbitrary order, as we do today.
whether any handler threw an exception? That would work for me since on
...I can think of one major way this can go wrong: what happens if a subscriber to Object fails?  Then it'd post a SubscriberFailedEvent or whatever, then it'd receive the SubscriberFailedEvent and fail again, and would do an infinite loop.  We might have code that specifically breaks this loop by ignoring failures on failures -- whenever a subscriber fails when it processes a SubscriberFailedEvent.  I dunno.
As a strawman of an alternative, what if callers could specify an exception handler for a specific listener at register-time?  Applications that truly want all their listeners to see everyone's throwables can just pass the same one to every call.  Applications that don't use this behavior would never provide a handler.  It also makes the recursion behavior application-controlled: crazy applications can register the handler as the handler for the handler.
The extreme version of this would actually introduce an observer interface for the exception handler, but that seems inconsistent.
(Yes, I realize that DeadEvent is arguably a violation of the principle I describe above.  I'm thinking about how to fix that.)
Louis: my opinion on all of your questions is "no."  I imagine the exception handler being just another handler that accepts HandlerMethodThrew; if nothing else, this greatly simplifies faking exceptions during testing.  We should start with as narrow an interface for HandlerMethodThrew as possible -- we can always add more properties later if users require them.  Because the exception handler is passed in per-register-call, users can always allocate new ones for each object if required (essentially partial application of the full many-input exception handler function).
Then you just have to change EventBus.java to throw your own custom RuntimeException (or use Throwables.propagate() if you don't care what the wrapped exception is).
@Override
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=766#c55) posted by **liska.jakub** on 2013-10-18 at 07:12 AM_
public class RDSEventBus extends EventBus {
throw new IllegalStateException(e.getCause());
@ï»¿peter.prikryl: Note that by using package-private parts of the eventbus package, you're going to be broken in Guava 16.
import edu.uams.domain.TirEvent;
public class AysncTraumaEventBus extends AsyncEventBus {
@Override
@Override
@Override
logger.info("Let's dispatch Aysnchroneous Trauma Event:"+ ((TirEvent) event).getResultMessage());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws IllegalAccessException, IllegalArgumentException,
MethodAccessor ma = methodAccessor;             // read volatile
ma = acquireMethodAccessor();
Maybe it is related with Reflection thing.. I don't know, but EventBus just doesn't know what target to invoke..
FYI, these methods would definitely go into common.math, not common.primitives.
Exactly; this is the kind of thing Optional is good at (and will perhaps get even better at).
Holder seems like something that might be useful in some cases, but if people decide they should use that for code involving multiple threads where it isn't appropriate that would be a problem.
use r09 guava,
show follow error:
You probably have a google-collections jar on your classpath as well as Guava. Make sure to remove that.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;artifactId>guava&lt;/artifactId>
Maybe you should use a newest version of Guava.
https://code.google.com/p/guava-libraries/
A bunch of Guava code is catching Throwable; in particular, MapMaker.StrategyImpl.compute in some probably older version of the library (I see no such inner class now). This is always dangerous, and in particular calls to ThreadDeath (from Thread.stop) should not be intercepted as if they were regular exceptions. Example patch (but a new utility methods in Throwables might be warranted):
--- a/guava/src/com/google/common/collect/MapMaker.java
+++ b/guava/src/com/google/common/collect/MapMaker.java
-        Throwables.propagateIfInstanceOf(t, ThreadDeath.class);
Of course it is better avoided, but it is the only hope to halt a runaway thread stuck in unknown foreign code. The only problems I have encountered with it are due to code catching Throwable.
We will review and evaulate our instances of 'catch Throwable'.  I know we've put a lot of thought into issues like these but mistakes might certainly have happened.
It would be great if guava could have a Serializables.clone(Serializable) method or similar
Sorry, I don't feel this is a good fit for Guava.
The simple approach in the original comment won't always work, for example in an environment with multiple class loaders, such as an app server. I showed how to make it work [here](https://weblogs.java.net/blog/emcmanus/archive/2007/04/cloning_java_ob.html). But it's very expensive and I'm inclined to agree with @kevinb9n that Guava is not a good place for it. Here's what I wrote there:
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=683) created by **kohanyi.robert** on 2011-08-10 at 06:03 AM_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=683#c3) posted by **hcey...@batoo.org** on 2012-03-20 at 02:38 AM_
I am desperately in need for this in guava as currently I am using commons-pool which performs really bad.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=683#c6) posted by **kohanyi.robert** on 2012-03-30 at 04:02 PM_
I think that what you've described is just a special kind of pool, which could throw when a client returns a leased object.
Pools that "replenish" their resources if their number drops below a limit are special pools too, which wouldn't throw if clients try to returns taken objects. Instead they would reuse the returned resources (or destroy them when they're full).
I am interested in pursuing this project for srs bsns.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=683#c14) posted by **ogregoire** on 2012-07-11 at 01:28 PM_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=683#c15) posted by **ogregoire** on 2013-01-23 at 10:24 AM_
I am a big fan of the guava libraries.
It supports 2 apis:
Ben
ABQ - 13.5M/s
As far as this actual issue goes, I would expect significantly more work to be required before adding my implementation to Guava, with a specific emphasis on experimenting with replacing existing pool implementations with this interface and seeing what problems arise?
The best alternatives are:
> Anyway, most of Guava's com.google.common.collect.Xxxs.newXxx() methods
@ï»¿yo...@ï»¿nwsnet.de :
Of course there is not an explanation about why this idea was rejects, but in the case of the Graveyard idea, both elements (key and value) are already being passed in. I am referring to a case were the key and value are calculated based on some input.
I wouldn't have said anything normally, but it struck me that if I didn't, you wouldn't know that just a day after one person mentions it, another is also looking...
acooke,
What about that case? I'm not sure what you're driving at.  That's either appropriate for issue 56, or you should be doing it explicitly -- especially in case of IOExceptions.
List&lt;String> b = [ "fee", "fi" ];
and maybe padded with null as well ? Like partition but with multiple inputs iterator.
However, the name "zip" seems to be generally understood as something else (namely pulling a single element from all iterators at once and returning a tuple whose length equals the number of iterators). [I see this has already been pointed out on the mailing list.] "Interleave" is fine, though.
BTW, this seems quite similar to `partition`, but somewhat the other way round.
@ï»¿amer: names and ages have to have compatible type, in your case it would be just Object. The way interleave is proposed to work won't enable you to filter people easily. For your use case it is more reasonable to either create a Person class and create an iterable of people by iterating over names and ages and instantiating Person objects from them. Other choice is to do the same without a new class, by using a Map.
@ï»¿yo.gi: Look at this:
Pair in Guava r09 - com.google.common.collect.Maps#immutableEntry
Triple in Guava r09 - com.google.common.collect.Tables#immutableCell
Those are specializations of a tuple (as suggested by literature), but they have different semantics than what we need here (no maps, no tables). Reusing them would violate the principle of least surprise, IMHO.
@ï»¿yo.gi: You are right, they can be pragmatically used as tuples and triples, but they were not intended to be, their semantics - meaning - is different. The problem is, that in Java, it is probably not possible to do anything more sensible.
For the record: "jagged, sparse matrix" makes me totally think of Guava's table implementation.
I have an implementation of this. I wonder if submitting the code for review is worthwhile given the age of this issue...?  Is the feature considered too esoteric for inclusion into Guava?
I also agree that the case is more compelling for 983. Then comes the question of consistency within the guava APIs (why is none available here, and not there, etc)
(Reported by estaub2).
I would consider Primitives.bytes() but leave the *8 to the caller for bits.
Please provide the same functionality as UnsignedBytes, but for shorts. My specific use-case is calculating CRC-16 values.
Louis,
"Completeness' sake" is...a dangerous phrase.  (There have been things that I personally added to Guava for "completeness' sake," and now consider mistakes.  I don't trust it.)
**Owner:** wasserman.louis
- guava Ints.tryParse(String) returns Integer maybe null
- guava Ints.tryValueOf(String, defaultValue) returns int
- or guava Ints.tryParse(String, defaultValue) returns int
- primitives is smaller and faster
- Guava command don't like nulls :)
Agree with amer...
amertum and yo.gi hit the main points:
- "tryParse(input, 10)" does look a lot like it's passing in a radix.
public class Strings {
&nbsp;&nbsp;&nbsp;&nbsp;private Strings() {
Possibly related:  bug 383
I think something might need to be done in this area but we need to mount a small research project to understand exactly what, and that is probably not high-priority at the moment.
Thiago.
- toString()
- as well as conversions to any alternate TimeUnit
Wouldn't such a Duration type be well suited for Guava?
nicely into Guava, I think.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=631#c4) posted by **ogregoire** on 2011-05-23 at 10:51 AM_
Louis -- awesome!
Except for the fact that it would be different to what the java.util.concurrent library methods currently use, but that shouldn't, in my opinion, prevent Guava from doing it better.
This is the strangest thing: it seems sensible to drop the "short" requirement, but if I do, I can't for the life of me think what to name the class!  It feels very wrong to poach a name from Joda.  I mean, we could call it ElapsedTime?
Is anyone actively working on this issue.
Otherwise I would consider making an implementation myself, and submitting it to Guava as a proposal.
Questions:
But it might be interesting as well to make a list of all Guava classes that could benefit from it.
@ï»¿Immutable
public long toNanos();
public long toMicros();
public long toDays();
It's still mildly sad that pre-Java8 users (e.g., Android) don't have a solution here.
It would be nice if the Throwables class supported sneaky propagation (a la Project Lombok's @ï»¿SneakyThrows annotation).  This would mean that checked exceptions would be treated as if they were runtime exceptions without wrapping them.
But what benefit would you get from a new method in Guava?  There is already the simple option:
@ï»¿Deprecated
Sneaky propagation is an opt-out of the checked exception paradigm.  If it's something you're not interested in, feel free not to use it.
I suggest the name "sorted" to be a bit pythonic. Also, it emphasize on the fact that a new list is returned instead of the one given in parameters.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=583#c3) posted by **ogregoire** on 2011-03-29 at 06:39 PM_
This RFE may be closed, sorry for that.
_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=578) created by **julien.baillagou** on 2011-03-22 at 01:31 PM_
I was searching in Guava API a method to list recursively the files contained in a directory and I didn't find one.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=578#c2) posted by **julien.baillagou** on 2011-03-22 at 07:47 PM_
The depth and restrict features may be cool!
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=578#c3) posted by **asafdav2** on 2011-03-22 at 08:40 PM_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=578#c6) posted by **ogregoire** on 2011-03-23 at 08:37 AM_
ogregoire
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=578#c8) posted by **ogregoire** on 2011-03-23 at 09:00 AM_
This is awfully OS-dependent, and extremely tricky to do correctly in the presence of symlinks and other weird edge cases.  I'd bet that any implementation we could come up with would have at least a dozen weird cases in which it fails.  -1 to trying to deal with this in Guava.
But the natural thing for another library to do would just be to provide the method themselves, rather than try to hook into Guava somehow.
Yes, it is a kind of
Any way it is just an idea. Any enhancements form guava developers are welcome.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=538#c5) posted by **daniel.yokomizo** on 2011-02-01 at 10:46 AM_
It's a useful data structure that is not so easy to implement by itself, and that is very useful in algorithmics, such as in the graph theory, for instance.
I don't care too much about the "Partition" name, but I do care about the rest. Make a guy with a weak spot for graph algorithms happy - otherwise I'll go and whine to Robert Tarjan himself. Seriously. (Ok, perhaps not that seriously, but seriously, I'll be sad, this is a gem of a structure, lets preserve that).
I swear, I have a weaker spot for graph algorithms than you, and my biggest soft spot of all is for data structure gems!
Btw, I was quick to play down the "Partition" name, but I think it's quite good (the other good names would be "Class" and "Set", obviously poor choices in this context :)).
I like the sound of the (very different from what I had been thinking!) direction you guys are taking this.
They disappear at the discretion of the garbage collector :)
Now, inelegant brute-force connected components:
doesn't use.  Try it yourself: once Partitions have been combined, they're
is all Multimaps.index() cares about.
Louis
I don't understand who you are responding to and what is "not true", could you clarify?
doesn't use.  Try it yourself: once Partitions have been combined, they're
is all Multimaps.index() cares about.
Louis
What appears to be more problematic is:
I wonder what the community thinks of this issue.
Here is a straw API to play with:
https://github.com/lowasser/guava-experimental/commit/e84cb02604ca5115d76004e56c5034b7356e5853#diff-1
Now that Partition is getting a fair amount of usage we will look into improvements here.
- "disjoint set" doesn't work as a name for this thing, because "set" (singular) makes it unclear what the disjointedness refers to, and it doesn't capture the fact that the parts must span the original set.
It seems to me that the root cause is in Guava not being added to any CI system. If I am wrong - please publish information where is CI for Guava. If I am right please configure some publicly available CI (for example Hudson).
&nbsp;\- different exception handling
// from the RetryException
This is clearly a nontrivial problem.  I am curious if this is the best way to solve it...
Clearly, we'd prefer something like this in guava as opposed to our codebase, so really excited about progress we can make here.
personally, I like the customizability of comment 11
@Override
return client.getBucketACL(bucketName);
@Override
return "getBucketAcl()";
This would be useful for me too, but so as not to make this a "me, too" post, here are a few links to others who have implemented this sort of thing, which can be used reference for a Guava version (which is what I'd prefer):
https://github.com/rholder/guava-retrying - not Guava but built on top of Guava; hence the name
throws InterruptedException
(possible other names: limitFrom and skipUntil)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=477#c4) posted by **daniel.yokomizo** on 2011-01-13 at 10:05 PM_
(But I appreciate this comment is slightly off topic.)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=477#c24) posted by **Maaartinus** on 2013-07-27 at 06:39 PM_
Felix Rabe
Felix Rabe
- Maven groupId = info.magnolia
**Owner:** cbe...@google.com
Say you're breaking up a List to display in a table or whatever.  Right now we say "Want to break into N columns?  Great, here you go!  Want to break into N rows?  Sorry, you're completely 100% out of luck on that."  It seems a little inexplicably inconsistent to me.
Say you have items ABCDEFGHIJ.
&nbsp;ABC
&nbsp;GHI
&nbsp;AB
&nbsp;GH
&nbsp;&nbsp;ABC
&nbsp;&nbsp;GH
&nbsp;&nbsp;IJ
Yep.  The behavior Kevin describes is _not_ possible to do with Lists.partition alone.
Louis, how about transpose(partition(list, groups)) then. If this is wrong too, don't make me pull pen and paper, figure it yourself! :-) (in the meantime, let me join the club of people doing the math wrong with this problem, I guess?)
Because it's a different story.
1) it orders elements differently:
ABCDEFGHIJ
ABCD
EFGH
after transpose:
AEI
BFJ
CG
@ï»¿Hannes, I don't have any idea how it would handle jagged sublists -- that's why I'm -1-ing on the addition of a transpose in the first place, because its semantics are tricky to define.  ;)  And yes, we are (a subset of) the Guava maintainers, and Kevin specifically is the Guava lead.
Guys, one more time: nobody suggested adding a transpose() in guava. Geez! :)
If you confuse "description" with "implementation", there is just no way of understanding what I'm talking about - I talk about the first, and I get replies as if I was talking about the second. So, everyone, please ignore my comments from #ï»¿30 and below, and carry on normally :)
I'm afraid I just don't see this as commonly needed enough to go in Guava.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=450#c1) posted by **yogy.namara** on 2010-10-16 at 02:37 PM_
If this is too radical, then just check for empty string on the part directly.
Would Guava be a good place to implement this functionality? Perhaps in the Strings or Bytes classes?
b) hopefully, Guava will sooner or later be the reason why I no longer have to use commons/lang and commons/io
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=428#c5) posted by **ogregoire** on 2011-02-15 at 10:48 AM_
&nbsp;&nbsp;UNIT, KIBI, MEBI, GIBI, TEBI, PEBI, EXBI;
&nbsp;&nbsp;UNIT, KILO, MEGA, GIGA, TERA, PETA, EXA;
We've still got a list of issues to work through on this API internally, and unfortunately we haven't prioritized doing so...so unfortunately it'll be a while till this API hits public Guava.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=428#c18) posted by **mar...@aie.pl** on 2012-09-05 at 09:14 AM_
I wonder if annotations would help make the reflection-based approach more viable?  @ï»¿ToStringField and/or @ï»¿ToStringField("fooBar") and/or @ï»¿NoToString?  On the other hand, this might not be worth the extra code noise.
Reopening on request from okigan.
AbstractService then it doesn't need to be a guava feature at all.  Also,
there is the question of how it would interact with things like
api, what does having the service (re)transition through the NEW and
the code
&nbsp;&nbsp;&nbsp;&nbsp;String var4 = "aaa";
String aaa = Objects2.firstNonNull( var1,var2,var3,var4 );
Maybe we can put some similar methods on the GUAVA
2. Has varargs
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=384#c10) posted by **asafr@google.com** on 2013-04-30 at 08:02 PM_
Asaf
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=367#c10) posted by **Maaartinus** on 2012-06-29 at 09:40 PM_
guava-io r03 from maven repository
uname -a
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=359#c2) posted by **ikaraszi** on 2010-11-19 at 12:58 PM_
the Guava libraries.
&lt;/snark>
maintain a library that uses Guava, and there are some Windows users of my
UTF-8-BOM
&nbsp;&nbsp;&nbsp;&nbsp;(2) it belongs in the JDK not Guava
Google Data API has a solution which could be moved to Guava:
Null())
Fluid_, perhaps - one character shorter, aye?  Or perhaps Flow_.  Maybe even Flo*, if
The "Fluent" moniker seems to have some traction, and the original metaphor for that
moniker seems to explicitly include the notion of "Flow"; I'm not particularly fond of
"Flow" is a noun or a verb, not an adjective which can describe something.
"FlowPredicate" does not read naturally (to me, anyway) and saving 2 characters doesn't
it. I imagine he's looking for something more on the lines of Ordering.
You mean, something more like:
transformation methods appended.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=334#c7) posted by **daniel.yokomizo** on 2010-03-10 at 07:58 AM_
In my Collections Framework I use (using the equivalent guava names):
filtered/transformed/etc with both keys and values.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=334#c9) posted by **daniel.yokomizo** on 2010-03-10 at 10:09 PM_
That horse is out of the gate.
These are the slowest horses ever!
I need also ordering other non-explicit elements such as
throws IncomparableValueException when the T value is known
throws IncomparableValueException when the T value is UNknown
So we'd like to use Ordering.explicit([WHITE_RABBIT, GRAY_RABBIT], [SMALL_RABBIT,
BIG_RABBIT])
There are two independent issues here; handling unknowns, and handling equality.
As I have just run into the problem with handling unknown values I am interested in helping with a fix.
still dynamic.
internanl array can be way above the maximum limit of the list, and never
TooManyElementsException could be raised. It would also be throws when some
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=329#c2) posted by **ogregoire** on 2010-02-23 at 04:52 PM_
about ISE)
Negative points of that class:
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=320#c5) posted by **daniel.yokomizo** on 2011-01-28 at 10:55 PM_
Also consider varargs Entries, consider Builder.
Also for Multimaps please :
I also request similar addition but for Multiset, please vote issue #ï»¿1189 too :-)
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=320#c29) posted by **adomma...@axian.com** on 2014-06-26 at 12:07 AM_
Varargs?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=309#c2) posted by **gpampara** on 2010-01-06 at 05:21 AM_
Could you please elaborate at what the complexities are?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=309#c4) posted by **ogregoire** on 2010-01-06 at 03:03 PM_
alternatives.
As for what to do in the case of overflow, I think ArithmeticException seems
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=309#c17) posted by **ogregoire** on 2011-10-19 at 12:43 PM_
I still think the simplest most obvious win here is just to add IntMath.sum(int[]) and friends.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=309#c27) posted by **emoro...@griddynamics.com** on 2012-06-26 at 01:13 PM_
EnumMultiset
HashBiMap
TreeMultimap
TreeMultiset
and instead only serialize memento-style objects -- but that can become
unwieldy very often.  For situations when mementos are impossible, we've
This doesn't seem like it belongs in Guava to me.
r.from = Math.min(r1.from, r2.from);
r.to = Math.min(r1.to, r2.to);
return acc;
that this kind of functional programming stuff has never been our core focus.  The
@Override
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c17) posted by **qualidafial** on 2012-04-09 at 05:33 PM_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c26) posted by **qualidafial** on 2012-07-10 at 08:46 PM_
The nicest thing about anything that takes closures is that they translate well to the function composition world, that we're already seeing partly with Guava, and will be even more when Java 8 Lambda comes along (syntax sugar to write the FoldFunction). Project Sumatra and proposed Java 9 parallelism also uses this.
So, you see these as FP only, despite their clear correlation to list processing? Guava has few tools for processing collections, why not add some more if people need them? Or it's like: "It's our library, we don't want this stuff. People use it and request some features? Fork 'em!"
Finally, do Guava developers have any reasons to not to add fold() and stuff, other than ideological (because they think almost every list processing idiom is FP only)? "Open source" not only means that sources are open (pretty obvious, huh), but also means some cultural things - like sharing ideas, receiving requests and implementing some useful stuff, you know. Position like "I don't need that, so nobody does" seems kind of strange here.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=218#c38) posted by **Lord.Laraby** on 2014-03-26 at 11:42 PM_
Louis, to me option 2 clearly jumps out as "better than the other two".
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c25) posted by **Maaartinus** on 2013-01-06 at 09:21 PM_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c27) posted by **Maaartinus** on 2013-01-07 at 08:26 PM_
https://dl.dropbox.com/u/4971686/published/maaartin/guava/collect/ImmutableListBuilderMemoryAllocatedMeasurer.java
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=196#c30) posted by **Maaartinus** on 2013-01-31 at 01:14 AM_
Concerning the builder syntax, there are two equally bad possibilities:
Java7 syntax improves this.
Our job before adding new APIs to Guava is to make damned sure the benefits will outweigh the costs, and we may actually get there. I guess I'm just explaining why this is not a no-brainer and why it is taking us some time.
"I look forward to seeing what comes in Guava for this" -- please note that it's very likely _nothing_ will come of this in Guava.  If I can find it, I have an old post somewhere that explains why I think it's not an especially tractable problem.
Please do elaborate!
Some are add-only, some not.
Bear in mind that ImmutableBiMap is insertion-ordered, and that insertion-ordered
_mutable_ bimaps can be kind of confusing because their key set and value set don't
is ambiguous and easily introduces bugs
Java 8 introduces some new weirdness with the varargs Lists.newArrayList(). If you call Lists.newArrayList(null), then javac7 would resolve the varargs method. javac8 reports an error:
error: reference to newArrayList is ambiguous
reimplementing all the time in various languages are zip and enumerate from
Python.
http://www.juripakaste.fi/jitertools/ . They operate on Iterators and
presumably because of the cleanup that Pair still needs.  I hope our goal is to
CountingIterator, either, which is fine with me, since it requires you to keep a
reference to the Iterator, meaning that it won't work in a foreach.  Your
a special object better.  getIndex() is clearer than getFirst() (or is it
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=35#c3) posted by **juri.pakaste** on 2007-11-05 at 08:25 AM_
forest of <<>>s and type names miles long.
confusion with the old school Enumerations. It does feel like the obvious name,
Additionally, Groovy allows passing more than one index to a list:
&nbsp;&nbsp;groovy:000> xs = ["zero", "one", "two", "three", "four"]
&nbsp;&nbsp;groovy:000> xs[[0, 2, 3]]
Doing this in Java seems to be quite cumbersome. To solve it with Guava, I'd expect either a method similar to `Iterables.get(Iterable<T>, int)`&nbsp;except that it'd take multiple position arguments, or a method like `Iterables.withIndex`&nbsp;that yields `Iterable<Pair<Integer, T>>`&nbsp;which I then can combine with `filter`&nbsp;and `Predicate<Pair<Integer, T>>`&nbsp;to extract the elements at the requested positions.
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=35#c10) posted by **emilchacko** on 2010-11-30 at 11:28 AM_
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=35#c13) posted by **g.e.dejong** on 2011-03-13 at 11:17 AM_
TreeSet/etc., you must re-engineer the appropriate comparator that can be
This idea needs a lot more thought.
[erratum]
base. It will probably be in a future Guava release.
throw IllegalArgumentException if there's anything they don't like about
The nice thing about this restriction is that a UniqueList can be viewed as
throwing an exception.)
several additional methods.
Good to know. No help needed, really, it's just that our internal users have not seemed to find UniqueList very
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=13#c12) posted by **Koyote130708** on 2010-09-13 at 04:18 AM_
It's a pity that Josh couldn't foresee this problem.
Koyote, I don't understand.  I'm saying there's nothing WE can do to make Collections.sort(uniqueList) work.  You're claiming there is?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=13#c17) posted by **Koyote130708** on 2011-02-10 at 08:59 AM_
@Override
@Override
@Override
@Override
@Override
Collections.shuffle(ul); // doesn't work
Collections.reverse(ul);
Collections.swap(ul, 0, 4);
Koyote13, I think the set() method you propose would be confusing... People would not expect elements to switch positions when they attempt to set an already stored element! For example:
// "D" was switched to the 4th position instead of being replaced by "A" !?
_[Original comment](https://code.google.com/p/guava-libraries/issues/detail?id=13#c20) posted by **Koyote130708** on 2011-02-12 at 06:15 AM_
kevinb I'm not sure if that's "corrupting" other data.
interface UniqueList&lt;T> {
// ... etc, all those methods that can trip
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multiset<?> m = (Multiset<?>) c;
It would be really, really (really) helpful if we could collect, here, a good variety
la/filters/IPList.java .
&nbsp;2) Storing a Kademlia DHT's internal structure.  This is probably a very specific
afraid it may be some time before I can look at breaking into new territory. But, I
Disclaimer: I don't know much about Tries.
2. What the caller wants to see doesn't look like a Map at all, but something much
You hit the nail on #ï»¿2 with the CharSequence version.  Trie's I've encountered
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean hasPrefix(K prefix);
prefixed by K
The difference is the Trie is directly acting off a K value, which would be the
addresses being composed of bits, CharSequences, phone numbers, etc...)
currently I'm wirting something for my studies and did a bit of research about Tries.
I fall upon a Hash Table performance like Trie called HAT-Trie.
http://crpit.com/confpapers/CRPITV62Askitis.pdf
In my opinion it maybe would be a great advantage to use this Trie.
To completely generalize it, a Trie is kind of a particular way of representing a
whitespace, punctuation removed, handle case insensitivity, etc.) which is also a
pretty much everything out there was character-centric. Once I made the abstraction
&lt;https://github.com/rkapsi/patricia-trie>
&lt;https://github.com/rkapsi/simple-patricia-trie>
The Trie interfaces are maybe useful even if you're not going to use PATRICIA.
So what would it take to make it a higher priority?  Getting more people to star the issue and/or rant and rave?
Or to put it another way, the hardness of designing a trie API to Guava's standards is very high -- it's such a general structure! -- and it isn't very widely applicable.
I was trying to be cynical in regard to ranting and raving and was implying people making a strong use case for it actually :)
I just wanted to get a better idea into what provoked priority in Guava.
NLP people would love to see a trie in Guava. :)
I'd be very interested in a Trie implementation in guava. I use hadoop and need to filter the incoming data by a large set of strings, on the order of 2 million strings. Right now I have a file containing these strings, one per line, that each mapper reads into a hashset to do the filtering. The speed performance is fine, it just takes a ton of memory. I've used the exact same approach with the exact same set of strings in c++ and it never took close to the amount of memory that java is using. The strings I'm filtering by have a good deal of common leading characters, I think our memory savings would be significant with a trie. I'd like to see a TrieMap and a TrieSet.
I am presently finding Trie structures very useful in my code generation / dependency injection library.  Scanning classpaths is expensive, and java packages often share long, repetitive package names; couple that with the fact my codegen library descends not just through the package structure, but the class, method, field and annotation structure as well (into a single uber-trie of your module), and a fast, concurrent trie is absolutely vital.
+1 For Trie
Jetty util pkg has some Trie structures if it helps - http://git.eclipse.org/c/jetty/org.eclipse.jetty.project.git/tree/jetty-util/src/main/java/org/eclipse/jetty/util/ArrayTernaryTrie.java
Your means that now all Methods in guava can work on Android?
May divide guava into generic and unique modules be better? Thanks.  Hi I am new to Guava. I just pull the latest code from master, and run 'mvn install -DskipTests' in my local, and I got the following errors:
[ERROR] /Users/ygao/Documents/github/guava/guava-tests/target/classes/com/google/common/primitives/UnsignedLongsBenchmark.class:110: Undefined reference: String com.google.common.primitives.UnsignedLongs.toString(long, int)
[ERROR] /Users/ygao/Documents/github/guava/guava-tests/target/classes/com/google/common/primitives/UnsignedLongsBenchmark.class:111: Undefined reference: String com.google.common.primitives.UnsignedLongs.toString(long, int)
[ERROR] /Users/ygao/Documents/github/guava/guava-tests/target/classes/com/google/common/primitives/UnsignedLongsBenchmark.class:130: Undefined reference: long com.google.common.primitives.UnsignedLongs.remainder(long, long)
Can i get the Class of String?
2. Performance issues in creating exceptions
1. Looks programmers would appreciate it :) , see https://www.google.com/search?q=guava+preconditions+custom+exception&
```java
```java
(BTW, I think I might have misunderstood something, because `module-info.java` is Java 9 specific, right? Would a Java 8 compiler (which I believe is what is used to compile guava-jre) or an Android compiler (for guava-android) happily process it or otherwise ignore it?) It is possible to only compile ```modile-info.java``` in Java 9, so the jar file is still compatible to users who uses earlier Java version.
A maven example:
```kotlin
throw IllegalStateException()
class GuavaStateExceptionTest {
**Problems**
@Override
@Override
@Override
@Override
@Override
@Override
@Override
**code 2:**
I'd like to share the report on API changes and backward compatibility for the Guava library, which I maintain as a hobby: https://abi-laboratory.pro/java/tracker/timeline/guava/
![guava-2](https://user-images.githubusercontent.com/1517837/31373004-03ee7b5a-ada1-11e7-8307-1186db74f83a.png)
![guava-1](https://user-images.githubusercontent.com/1517837/31373005-040f91a0-ada1-11e7-8376-d2a89a917753.png)
Commit 9feba7c949ef9fd2092c05c29dcbe0ddba7a7cf5 of #2846 placed the `Automatic-Module-Name` declaration in the wrong`pom.xml`. As such, Guava still isn't a valid module, which blocks a whole heap of projects from declaring `module-info.java`.
Regarding `javax.annotation.Generated`:
That's not exactly ideal... > ... Spotbugs is a natural choice, since we know it has all the annotations that we want.  ...
This is a problem because `guava-android` is compiled with a Android toolchain, and modern Android toolchains only understand Java 7 syntax and a small subset of Java 8 syntax - not enough to understand type annotations as legal constructs.
```java
```java
I'm trying to find a replacement that has everything I need, but I haven't been able to yet. Perhaps I'll delay switching until the Guava team comes to a solution for this issue in Guava.  Hello,
```java
```kotlin
class TestGuavaA {
public TestGuavaA(Long id,String code, String type, String author) {
private String author;
@Override
Guava 23.0
However, I don't have any idea, how to simulate/test it with a unit test (most probably there's no way even to do that, since it more likely to be a system/end-to-end one)  Removed duplicate tests, unified naming I signed it!  This patch changes `-android` version suffix to `-ga` for Android / Java 7 flavored version of Guava, resolving #2914.
As to `GA` version being considered "better" than plain (non-suffixed) release one - I'm not sure it's clear cut (and might be highly subjective, depending on one's history of exposure to these). When I encounter such versions I try to check the project documentation on their versioning scheme and semantics.
@Override
.field(o -> o._obj, new CustomEquivalence())
@Override
.field(o -> o._obj, new CustomEquivalence())
```java
```java
```java
```java
```java
```java
```java
```java
```java
```java
Edit: On the other hand, that is quite a bit of baggage to add, might as well use https://github.com/mintern-java/primitive. > Edit: On the other hand, that is quite a bit of baggage to add, might as well use https://github.com/mintern-java/primitive.
> well use https://github.com/mintern-java/primitive.
> <https://github.com/notifications/unsubscribe-auth/AAEEEZXdAvDJj3s4jjaXEbot8YXiAtolks5sgZrjgaJpZM4PPEa8>
the only way I can do is to hack, use the bloomfilter instance as a member, and repeat what you do for the bitarray. :(
> gives the solution for Guava 20.0 .
> Eric
@cpovirk, do you have any thoughts on this?  With the progress of Java 8 adoption in Android toolchain, especially the maturity of [desugar](https://developer.android.com/studio/write/java8-support.html#supported_features), the core Java 8 language features (not APIs) are now commonly used in Android development.
I still can't figure out why a BiMap can't be used there.
```java
```java
// Sad that we can't use a BiMap. :(
Could you enlighten me please ? Sad indeed...
Marcin Hi @marcingrabda.
IIUC, it reacts best to phrases like "I signed it!", so for the future I'd suggest trying that. :)  in 2 create functions, with fpp setting it's INT, but given the default one (0.03), it's LONG, what is the point? in fact, by the way, can we expect more than MAX_INT insertion for this bloomfilter implementation? any clarification? @itismewxg Just to be sure, are you talking about BloomFilter or something else? Yes, I mean Bloomfilter,   so, still no answer?  Guava for Android is lacking classes that are provided in Guava for the JRE (notably around support for Java 8 in the immutable collections). The two are not interchangeable.
![guava-oops](https://user-images.githubusercontent.com/28229/29334655-14dc5d96-8200-11e7-8276-ebdd616ef661.png)
- An app targeting android might end up with the JRE version of guava. In that case, someone might mistakenly depend on methods that aren't available in the Android SDK (eg. the `Stream` APIs)
- An app targeting desktop guava might not compile properly because they depend on classes that aren't present in the android flavour.
@cpovirk, I think your understanding of maven dependency resolution isn't quite right. It does a BFS of dependencies, picking the first one that it finds. Thus, even if something like selenium declares a dep on "23.0-server", unless it's "closer" to the build than the one that specifies "19.0", version 19 will be selected. Re: Android. Yes, that's exactly what I'm saying. It's a thorny problem. Re: "guava-server". Not all java implementations are server-side. I think `guava` and `guava-android` are clearer. If you want to really spell out that one version is for the JRE, `guava-jre` seems to more accurately describe the version. Re: "maven dependency resolution" Glad you know about the full horror of how maven selects versions. It's good to have company :)
<artifactId>guava</artifactId>
Yes, that's the aether version I was referring to. I think that https://github.com/google/guava/issues/2914#issuecomment-322818286 properly describes the problems that guava users are experiencing, and is what we should be trying to resolve. Oof, I can see that this is not easy to resolve. Just reading this comment thread is enough to do my head in. :stuck_out_tongue_winking_eye:
1. Use a static version of Guava, and update it periodically.
Selenium is highly customizable, in particular with our "Grid / Server" product. It would be a bit unkind to those users to shade a dependency that may need upgrading in a timely manner... we don't always timely upgrade our guava reference and it can be many months between our releases when we all get busy. @jbduncan: I'm the selenium lead :)
Fortunately, the selenium project had a way of letting maven know that we actually needed version 21 --- it was more than advisory. We set the version range to be _at least_ version 21, but left the upper bound open so that projects that depend on selenium could use a compatible later version of guava too. I think the root problem here is the difference between Java 8 and Android as base SDKs. Java 9 is coming in September, and will widen the gap further.
sufficient to, in and of itself, note guava-jre and guava-android as
> Also, why not just distribute the Android version of guava as an AAR, and
> not as a JAR?
> don't know enough about AAR to say more than that.)
to provide two Guava versions that can be treated equally from version comparison perspective (at least by Maven itself).
In the builders I try to use the Guava immutable collection Builder's wherever possible.
ImmutableMap.Builder<String, FooBar> foobars = new ImmutableMap.Builder<>();
public void Builder addFoobar(FooBar foobar) {
String foobarName = foobar.getName();
throw new IllegalArgumentException("Duplicate FooBar name: " + foobarName);
foobars.put(foobarName, foobar);
throw new IllegalArgumentException("Duplicate FooBar name: " + foobarName);
https://github.com/google/guava#snapshots
// TODO(lowasser): consider exposing this
Paul  In order to minimize the risk of integrating `@Beta`-annotated functionalities (especially in libraries), it would be nice to have API Docs including only the non-`@Beta`-parts of Guava.
```java
@Override
throws Exception
throws Exception;
Using utilities like jOOÎ»'s `Unchecked` tricks like
```java
@Maaartinus That could have a race due to an eviction, for whatever reason. It tiny improvement would be to throw a custom exception with the results and then use `cache.putAll` to insert them. Then the results would be cached and the found set returned.  Add generics with Maps. fromProperties().
```java
throw new Error();
at com.delphix.logger.Logger.getLogger(Logger.java:96)
at com.delphix.session.impl.common.SessionManager.<clinit>(SessionManager.java:23)
```java
@Override
@Override
```java
@Override
@Override
@Override
```java
@Override
@Override
```java
@Override
@Override
@Override
I already prototyped it, but I wanted to have your feedbacks first before creating a possible PR. Do you think it's a good solution? If yes, could it be a good fit for Guava?
```java
return Futures.transform(this, function);
```java
```java
Note: The call to `Futures.transform(..)` is ambiguous as the compiler can't figure out if it's `Function` of `FunctionAsync`. Adding methods named `transformSync(..)` and `transformAsync(..)` would help the compiler (and readability).
These are unchecked exceptions, and so the compiler is of little help, and unexpected things happen when the code is run. Programming in Haskell has spoiled me...
```Java
```java
Exception cause = new Exception();
Exception exception = new Exception(cause);
The manifest inside guava's jar is currently lacking this property.
throw new IllegalStateException("make deadlock");
While I was doing some JMH benchmarks I noticed that benchmarks that were using guava caches stalled completely and/or had very erratic performance during thread contention. Benchmark iterations very often stalled for seconds, minutes or sometimes seemingly indefinitely. It turned out that the cache was the culprit in all cases.
FWIW, I tried replacing the guava caches in the benchmarks with caffeine caches, and all kinds of stalling and erratic performance went away. It should be unrelated due to this bug dealing with new code for Java 8. Your benchmark touches prior code.
<artifactId>guava</artifactId>
@Override
```java
I suppose that's my main concern with migrating Guava to Bazel too early (disregarding potential issues like GWT), because I am primarily a Windows 7 user, and my experience with the Windows distribution of Bazel version 0.4.x on chocolatey.org is that it fails to even install core dependencies like msys2 correctly.
* `guava`
* Something else
@eljobe If the Guava project does not wholly own `com.google.common` and/or it's sub-packages, will this be a problem? Hmm, after re-reading this conversation, I understand now that only the `com.google.common` package needs to be owned by the Guava team?
2. If `com.google.common` _isn't_ wholly owned by Guava, would this be a problem for migrating to modules? I think I may be introducing more confusion than clarity here, but it's worth writing about in a bit more detail because we really only want to make this decision once.
Guava Team
The next observation is that the standard (Java-wide) rule for module names should be that the module name is the super-package name of the project. While this rule handles many cases, it does not of course handle the Guava case, as each package is a sibling.
Looking to the future, there is another way to view the whole problem space however. Each package in Guava is pretty isolated. There are dependencies between the packages, but they form a DAG as far as I can tell. As such, it would be perfectly possible for each package to be a separate module (where the module name is then obviously the package name).
In this scenario, the Guava module would then be an aggregating module that contains no bytecode of its own:
So, either `com.google.common` or `com.google.guava` are reasonable choices derived through different thought processes. While I originally strongly recommended the former, the latter does now have appeal given the description above of internal teams also wanting to use the `com.google.common` module name.
Ultimately, the Guava team must decide as to which of the two world-views of the project describes it best - a single project formed of a coherent set of packages (`com.google.common`). Or an aggregation of relatively separate packages that could standalone, unified under a brand name (`com.google.guava`).
Tests in error:
[INFO] Guava Maven Parent ................................. SUCCESS [  0.140 s]
[INFO] Guava Unit Tests ................................... FAILURE [06:00 min]
```java
```java
In a project of mine, there are legacy uses of `md5` that use it as a convenient non-cryptographic hash function, and these uses cannot be readily eliminated.
My project uses Scala, which doesn't give fine-grained control over compiler warnings. As a result, I either have to silence all compiler warnings, or see lots of deprecation warnings about `md5` usage. Both alternatives are undesirable.
```java
return Hashing.sha1();
else. See Dagger for an example.
```java
```java
```java
* @throws IllegalArgumentException if some property of the element
This maybe seen as a step to reimplementing java.util.function to support throwing exceptions. I'm down with that too. It seems like the norm today is, when using java.util.function stuff with lambdas that throw exceptions, to wrap exceptions in runtime exceptions and unpack at the other side. That's a bad idea and nobody should be doing that. There should be a working alternative and Guava is the place to provide it.
```java
<artifactId>guava-annotations</artifactId>  <!-- first name I thought of -->
``` Will Guava version `23.0` include that extra 4 dependencies?
Guava | Java 8
Similar mapping can be found in UnsignedBytes and UnsignedLongs (and possibly in the yet-to-be-released UnsignedShorts)
In `ImmutableDoubleArray`, documentation ([as of 22.0-rc1](http://google.github.io/guava/releases/22.0-rc1/api/docs/com/google/common/primitives/ImmutableDoubleArray.html)) of the behaviour of `equals(Object)`, `indexOf(double)` and `lastIndexOf(double)` is ambiguous as to the treatment of NaNs.
```java
- `CustomDataClass` is the value class - a blueprint for individual events.
Had a `clear()` method been in the API, then a more invasive rewrite would have been required to have satisfactory performance. In that case a Bloom-1 design would have been appropriate. But most likely the proposal of thread safety would have been rejected as too invasive and not driven by an internal need.  Our own `MoreCollectors` class contains solely collectors which create Guava collections. Now that Guava does have collectors, having these in Guava would be useful.
throw new IllegalArgumentException();
catch (Exception e)
return TEST_BOOLEAN;
```java
```java
@Override
<artifactId>guava-gwt</artifactId>
I signed it! I understand your point however Guava provides Preconditions which have similar idea. Look at the  throwIfInstanceOf:
if (e instanceof MyException) {
throw (MyException) e;
@Override
// private Set<Kingdom> children;
```java
I Create GuavaCache like this:
.maximumSize(guavaCache.size())
By the documentï¼ŒI thought the cleanUp() method can  eliminate entries, my understanding is wrong? Yes I think you're right @pumadong, but I think the document also implies that `cleanUp()` can only eliminate those entries which have expired (that is, those which have existed for 600 seconds or longer since the cache was last written to).
I did a bit of reading (Wikipedia mostly) to see if this was expected behaviour. However, everything I saw pointed towards self-cycles not being a requirement of a transitive closure. I found [two](https://en.wikipedia.org/wiki/File:Transitive-closure.svg) [different](https://en.wikipedia.org/wiki/File:Transitive_Closure.svg) images on Wikipedia that show a closure with no self-cycle, The description on the [Transitive Closure](https://en.wikipedia.org/wiki/Transitive_closure) wiki page itself uses the example that nodes are airports and edges are flights, and the transitive closure is the graph of everything reachable from a node in **one or more hops**.
```java
```java
```java
package guava.optional;
private long code;
Error
[ERROR] ode
package guava.optional;
private long code;
why that, is this a bug? or just i am a stupidðŸ˜‚ ```
// First, Foos get added to the map. Then:
...which throws this from another thread:
InternetDomainName{name=foobar.bid} has public suffix ? false
InternetDomainName{name=foobar.xyz} has public suffix ? false
InternetDomainName{name=foobar.loan} has public suffix ? false
InternetDomainName{name=foobar.win} has public suffix ? false
Original PR + LongAdder
Original PR + LongAdder
Original PR + LongAdder + no-lambda
Original PR + LongAdder + no-lambda
Added the IF. @ben-manes @lowasser
```java
buildTypes {
classpath 'me.tatarka:gradle-retrolambda:3.2.5'
Though this might be frightening, the process is usually easy. It's just annoyingly long sometimes, especially if the build is non-standard (meaning, not Maven or Gradle) or if the usage of Guava is intensive. Admittedly, I hadn't considered the scope of the backcompat issues here.
recently upgraded my local jar of guava from 15.0 to 21.0; but facing issues with encoding.
Code Snipet causing problem is:
> DEPRECATION WARNING:
Bit of rambling ahead...
```java
Guava's BloomFilter is a bit of an odd result. Initially there were claims that a BF was too slow as one would have to use a `SecureRandom` to have a good distribution and dynamically configure `k` hash functions. I jumped in having just written one as interview practice (as impractical and not intended to be viewed) using a normal hash function, bitwise ops, and deriving multiple due to reading [Less Hashing, Same Performance: Building a Better Bloom Filter](https://www.eecs.harvard.edu/~michaelm/postscripts/rsa2008.pdf). Someone else wrote a blog analyzing that proposal, which unblocked the Guava team. But I wasn't involved otherwise past that initial thread and a brain dump over lunch.
That then begs the question of whether Guava wants a fast implementation. The library is best viewed as having clean APIs, excellent code, and good enough for the simple common cases. But when performance and special cases emerge, its best to deviate away. Which leads to your custom implementation being the right approach for you, but may not fit the precedent the Guava team has set.
If @lowasser is interesting in driving this forward iterating on your proposal, then maybe we should dig into the latest research to see what other gems we can incorporate. > The library is best viewed as having clean APIs, excellent code, and good enough for the simple common cases. But when performance and special cases emerge, its best to deviate away. Which leads to your custom implementation being the right approach for you, but may not fit the precedent the Guava team has set.
@Bean
@Bean
_Guava CacheBuilder is created/initialised with removal listener in a single step then at later point Cache build will be lazily created._
**But since Guava docs advice to heed configuring a builder
But the Comparators Javadoc says:
- [Strings](https://github.com/google/guava/wiki/StringsExplained)
- Joiner
- Splitter
- CharMatcher
- Charsets
```java
```java
BiMap<Foo,Foo> specialFoos = ...
where this issue is the only reason why `specialFoos` is a `BiMap`.
// long running IO;
```java
This code:
```java
```java
```java
for (Foo foo : foos) {
```java
return foos.stream()
.map(this::convertFooToBar)
```java
return foos.stream()
.map(this::convertFooToBar)
```java
```java
```java
```java
Hmm, I wonder if the fact that `Interval` works with only `Integer`s is what allows it to implement `RandomAccess`. I've not thought hard about this yet... Are not all discrete domains enumerable? I realize that Guava only currently defines discrete domains for `Integer`, `Long`, and `BigInteger` but what would be an example of a discrete domain for which you cannot know how to offset, etc.? Yes, I agree that a default implementation as you described would be "Very Bad" but a new `abstract C offset(C start, long number)` method could be defined on `DiscreteDomain` (`long` similar to `abstract long distance(C start, C end)`). I see that Guava allows you to create [your own DiscreteDomains ](https://github.com/google/guava/wiki/RangesExplained#your-own-discretedomains) so this would be a breaking change... è†œæ‹œå¤§ç¥ž... > è†œæ‹œå¤§ç¥ž...
It does not happen on all of my modules that use Guava.  But I haven't narrowed-down which Guava class is involved.
The warnings are shown only when I include `Xlint` along with either of `showWarnings` or `showDeprecation`.
So, I don't know if there is a bug in maven compiler plugin, or in Guava's `ImmutableTable` or what.  But I really shouldn't be seeing these warnings.
[javac] .../guava.jar(com/google/common/collect/Multiset.class): warning: Cannot find annotation method 'value()' in type 'CompatibleWith': class file for com.google.errorprone.annotations.CompatibleWith not found
````java
public class GuavaTest {
```java
``` The "Cannot find annotation method 'value()' in type 'CompatibleWith'" warning still appears with guava-22.0. Adding error_prone_annotations-2.0.19 to the dependencies helped. Update on my comment: When compiling with guava-22.0 and jdk-1.8.0_31 the warning appears without the error_prone_annotations-2.0.19. With jdk-1.8.0_131 no errors, even without the error_prone_annotations jar. I'm confess I don't yet everything that's going on here, and I'm afraid "just include the dependencies" may ignore some of the subtleties.
And lastly, does this even apply to the JSR 305 annotations? Do the JSR 305 methods even have any such methods that some tool would try to find at compile time? (Again, knowing the specifics of what tool was trying to access that method might make some of these answers more apparent.) Thanks, @cpovirk . This is really interesting. I wonder if `javac` is really doing the correct thing here. It doesn't seem be following the spirit of [JLS 13.5.7](https://docs.oracle.com/javase/specs/jls/se8/html/jls-13.html#jls-13.5.7), which says, "Adding or removing annotations has no effect on the correct linkage of the binary representations of programs in the Java programming language." (See the [great answer](https://stackoverflow.com/a/46882631/421049) to my [question](https://stackoverflow.com/q/45596949/421049) on Stack Overflow.)
So it's a really interesting situation from a technical standpoint. From a semantics standpoint, I haven't made a final decision but it still seems more appropriate to me (see further [discussion](https://github.com/google/guava/issues/1018#issuecomment-340202085) in #1018) to make the JSR 305 dependency `<optional>` in our own library, and let the few people it affects (if anyone) explicitly include the JSR 305 dependency themselves.
The details are above my level of understanding.
Hi @shengxuanyi
//and so many fields
@Override
@Override
@rohit5ram, could you perhaps explain to us what sort of ordering you're trying to achieve with these `Item` objects in your `TreeMultiset`? (For example, least-to-greatest ordering by `priority`, greatest-to-least ordering...)
```java
```java
Hope this helps! Hi @jbduncan
Can you please refer @shengxuanyi comments above @Maaartinus @lowasser  Is that the reason for clear() not able to work? The existing code is able to insert all the values into the set. If the priority is same then it's overwriting the old object. Hence I avoided and inserted it again.
```java
@Override
```java
```java
I see no problem in this API. @guai I can't speak for @lowasser, but I think the main problem with an API that returns `{List}Iterator` is that if one needs to go through (or traverse over) the elements in the `{List}Iterator` more than once, or in a different order (like reverse order), then the only option is to _copy_ the elements in the `{List}Iterator` into an intermediate data structure, like an `ArrayList`. Understandably, this copying wouldn't be memory or time efficient.
I don't like the assymetry here. Its like a blind spot. Some useful class was written but I cannot use it. Hi @guai,
```java
Instead of
* the name is confusing as it returns `ImmutableSet`, not `ImmutableEnumSet`
6. Multisets again; please, consider adding following methods returning Collectors**:
Thank you! What about `Suppliers.memoize` family (or any `Funtions` and `Suppliers` stuff) - will there be any changes there? I know it's a bit different case, and supplier::get should work there, I'd just like to know if there will be any overloads / migrations there. Thanks for clarification!  I'm a BIG fan of immutables in Guava. ImmutableList, ImmutableMap, etc.
However, some packages might not want to swallow ALL of Guava just to provide immutable APIs.
Further, there are issues with Guava versioning.
If we had a guava-immutable module that we can just depend on which ONLY had the immutable collection support this would solve that problem.
> Further, there are issues with Guava versioning.
What sort of issues are you referring to? How would splitting Guava up into numerous (presumably interdependent) packages make version-hell easier?
Regarding your solutions 1 and 2, while I didn't think of them (it's the first time I work with graphs), they don't seem very Guava-esque because option 2 doesn't allow immutable node objects and option 1 isn't very flexible.
@Override
```  Random string generator and unit tests I signed it! Hi @havlip18, have you taken the time to read the [contribution guidelines](https://github.com/google/guava/blob/master/CONTRIBUTING.md) yet? ðŸ™‚ General remarks:
* The nomenclature is rather odd considering it's Guava.
```java
## What alternatives can I use?
### Guava one-liner
The casting is rather obvious, but using Guava, I don't expect to cast very often, actually. There are lot of tools that help us avoid this. Once more we have to declare the expected return type when all I want is to split `String`s.
### Optimized (?)
``` Hmm, I admit it's not entirely clear to me what it is you want to do here @memimy2015.
```java
```java
Streams.zip(
// ...or a mutable one.
``` @jbduncan Should be the first one, or you won't pass lists as arguments. Hi @liach, could you explain further why you think it should be the first one? I ask as I'm struggling to understand your explanation of "or you won't pass lists as arguments". If it is the type below, then the method would be named `cartesianMerge` like `Lists.cartesianProduct`. Although you can also add `cartesianMerge`, though it would be used very rarely. For cartesian merge, you can use two iterables to iterate and get products. But for the two lists, they need the `size()` method to ensure a merge can be done.  > If it is the type below, then the method would be named cartesianMerge like Lists.cartesianProduct.
```java
Guava version is 20.0.
is this expected behavior?
public class GuavaTableTester {
@Override
@Override
public GuavaTableTester() {
Maybe that should be called out as a caveat for HashMultiset and its friends - as other people may be caught unawares. The part I'm referring to is, for instance, here:
And yes, I know it was a braindead violation of the contract by me - but it might be worth noting that equals() is not the only thing that is called in these cases (unlikely Collections.frequency which seemed to not care).
Providing these collectors in Guava would be a matter of convenience.  Users could implement functionally-equivalent collectors themselves, but I think most users would not do so.  I think `enum`-specialized collections are underused and that it is worthwhile to promote their usage and remove friction / barriers to entry.
```java
```java
```java
Maybe this should be its own issue? I am not sure what the correct fix would be. Any input would be much appreciated! @tli2 Oh, gross!  I hadn't considered that `ImmutableSortedSet` and friends might "inherit" these methods.
```java
```java
public static PrimitiveIterator.OfInt emptyIntIterator();
public static PrimitiveIterator.OfLong emptyLongIterator();
TreeBasedTable: O(R*C) (linear time)
I do not understand what you mean by "mitigate". :confused:  Views should be invalidated if the backing table is modified. The reason for this is that they should hold direct references to the internal data structures so the subtable is actually smaller than the real table, thus providing faster access times.
A subtable at (100, 100) should have the same performance (NOT complexity) as one at (1, 1), given that both have the same size. Maybe this is a very specialized use-case after all... Sorry.  It is one important issue need to be fixed to support most cases which values may contain the separator.
```java
throw new InterruptedException();
I find this to be very surprising behavior since almost any other Java method that is named `tryDoStuff(timeout)` can be reasonably expected to satisfy _at least one_ of the following postconditions when it returns normally:
(Guava version: 19.0)  Hi, guys! I have some problem with method construct in ImmutableSortedSet class, cause I've received every time n-1 elements after build ImmutableSortedSet.
Hi @MrNikita, are you trying to show us in your screenshots above that the element at index 2 (which starts off as "CC-third") is somehow being overwritten with "AA-last", which you believe to be erroneous behaviour? @jbduncan yes, this behavior is result of overriding "E... contents" parameter inside this method, here:
Its compare of "BB-second" and "CC-third" objects:
Ridx511ask@pong27runner.exmple.onmicrosoft.com  In order to minimize the risk of integrating `@Beta`-annotated functionalities (especially in libraries), it might be nice to have a tool that we integrate in the compilation process and that produces warnings when a `@Beta`-annotated functionality is used.
@Nullable String b;
Even though issue is closed..just a thought why can't we use two Striped locking instances (one for A related locks and second for B related locks) ?
Out of curisoity, why does `ImmutableTable` and various other collection implementations in Guava implement `Serializable`?
@jrtom Is a JUNG re-release still in the works?  `Graph.successors()` returns nodes in an undetermined order which makes it difficult to use `Graph` as a rooted tree where the ordering of the children is important (e.g. something similar to XML) with a schema that orders some elements).
```kotlin
Thanks for your review jbduncan.  I know googlebot's a bot -- I think the gears are turning on the corporate CLA.
Here are some ideas on implementation:
```java
```java
banana
pear
By my understanding, one of the reasons for this is that `for` loops are easy for the Oracle Hotspot JVM (and presumably other JVMs) to optimise away in non-obvious situations, and Caliper encourages its users to use `for` loops to benchmark code many times (this is done differently in JMH, which uses annotations and special optimization-defeating trickery instead), so Caliper benchmarks are more likely to report incorrect timings and thus are less reliable.
Paolo
```java
// Additional Stream variants of factory methods where possible.
// with the current element of the other side
// Instead of collectors:
It's not clear to me what the relationship between Guava and MÂµG is, so is it worth keeping this issue open now? `Streams.zip` and `Streams.forEachPair` already handle a good part of my use cases for `PairStream`. However, one relatively large class of use cases is still missing: zipping over the entries of a map. With having `zip` and `forEachPair` for streams in Guava, it really feels like an omission that the JDK provides only `forEach` for maps and not `zip`.
it result in violations by IntelijIdea:
![screenshot- upgradetoguava20](https://cloud.githubusercontent.com/assets/812984/20042839/f168ad4a-a435-11e6-9ed8-d08c6b8a8778.png)
I had big doubts that they consider such update, so came to guava team first.
@liach Yes, sure I will, but before I would like that a Google member or guava contributor check if my approach is correct in order to proceed. Thanks.
It's not used anywhere else, so can be `private`.
@Sharon-Ko Did you perhaps mean to talk about Multi**map** rather then Multi**set**?
Could it be that latest Guava-GWT 20.0 jar was not packed with all the needed sources?
the issue occur when ImmutableList is included in gwt's serialization
the issue occur when ImmutableList is included in gwt's serialization
- `{@requiredTo}` in Quantiles.chooseNextSelection
What does the Guava team think of this request?
Admittedly it only applies to DAGs, and I've not had a proper read through it, so I don't know the efficiency of the algorithm discussed, but it looks like it was written relatively recently (2007 I think), so I wonder if it would have useful information for you.
Well, those are just derived from the nature of DAG. I actually want to ask @jbduncan how DAG would be used in his project, since he proposed this first.
So I'm very sorry to say that I don't actually have anything useful to say @liach :/
I mention topological ordering because it is based on DAG. I will open a separate issue.
We were never taught the term in our lectures at university, and I don't remember coming across it in any computer science literature I've read. We always used the phrase "if and only if" instead, so I thought "iff" was a typo too until I searched it up a few days ago. So I'm not surprised at all by @m-berling's confusion on this.
@Override
@Override
private Range<K> range;
As Louis says, `NavigableMap` is [documented](docs.oracle.com/javase/8/docs/api/java/util/NavigableMap.html#subMap-K-boolean-K-boolean-) to "_throw an IllegalArgumentException on an attempt ... to construct a submap either of whose endpoints lie outside its range._" and the `Maps`/`Sets` methods simply delegate to the appropriate `NavigableMap` methods. I'd agree it'd be reasonable for `NavigableMap` to silently accept wider view ranges rather than fail, but that's the existing behaviour.
last master commit GUAVA-GWT not work.
2.8.0-rc3 and guava 20.0-rc1
This suggests that the greek mu is preferred:
From my perspective, we can just as easily receive the _opposite_ report tomorrow. This is why I looked up the unicode.org guidance, and found that we are following that. It seems like this should settle it, to me.
@yecril71pl Please explain how we should know that there aren't users out there today with a terminal that does support the current character but not the one you suggest? That would produce the aforementioned opposite report.
On Thu, Oct 6, 2016 at 10:44 AM, Gili Tzabari notifications@github.com
> your attention to https://bitbucket.org/cowwoc/guava-jdk8/ which I
@jbduncan The main feature I was trying to propose by opening this issue was offering a builder design pattern for Collectors in order to improve readability. I think this is one of the main features that sets my API apart from others.
collect(GuavaCollectors.multimapFrom(Integer.class).
The presentation links under Learn about Guava don't work.
So they're not supported....could they be?
I found these comments slightly confusing. (I also wonder whether you removed `sameThreadExecutor` internally, since it's scheduled for removal in August 2016, but I guess it means in "when Guava 20 is out".)
Thanks ! i just use Guava for the first time, and didn't know that Constraint(s) are suppose to be non-public . i just saw someone had use them before, Ok, forget it. Again, really appreciate for your reply!
Oh okay, I didn't realise you were a first-time user of Guava!
(On a side note, I find it curious that you saw someone use `Constraints` before.
What caused this?CDH or the version of guava?Can sm help me?
which version of cdh you are using?
Ensure that unpredictable names are used for temporary files and that files are created in a secure directory with appropriate permissions. Using mkstemp() is a reasonably safe way to create temporary files. It will attempt to create and open a unique file based on a filename template provided by the user, combined with a series of randomly generated characters. Note that mkstemp() is safe if only the descriptor is used and the returned filename is not used in a subsequent function call with extra privileges. Using mkstemp() does not completely eliminate race conditions but does provide better protection than other methods
Does that mean one should look for an Alternative API in case security is a concern for the project?
Has Guava been tested with any of the early-access Java 9 and/or Jigsaw releases yet?
Guava's usage of Unsafe always has a fallback if any problem occurs.
> look into, as Guava currently uses sun.misc.Unsafe in a number of places,
> which by my understanding would prevent Guava from being used in
The main pain I encountered while doing this was that the tools used in the maven build can't handle Java 9 yet, so I can't actually make a build of it immediately.
...makes me realise I'm not so sure what "this implementation" refers to.
Adding checkPositive MathPreconditions before using value of x in ceilingPowerOfTwo and floorPowerOfTwo methods.
I think this code:
Should perform a Null check, like:
About the backwards incompatibility:
more flexible:
I this morning mvn downloaded updates for guava-gwt-20.0-SNAPSHOT.
Since, this error appears now :
@spirylics https://github.com/google/guava/issues/2547
But this raises an exception, even though I could do:
Strange, `TreeMap.Entry.setValue(V)` **is** supported, at least Oracle Java.
Different Error Cases:
Is something wrong with the signatures of `Builder`?  If so, I don't see it.
test.jar/
Instead of
Just a thought, interested to hear if you think this is cool (and could be something for Guava).
PS: The  trouble with tribbles, erm AutoValue, is applying it to (badly written..) existing "beans" used in a code base imposes changes e.g. from constructor to builder or factory - that's not always easily possible.
We have upgraded the compilation process to use Java 8 so that default methods can be used. However, we realize that this may not be acceptable. Still, any feedback you can supply would be helpful.
@Override
_2) Negative_
issue:
To achieve this the join method could be overloaded accepting a java.util.function.Fuction<T,R> parameter, with T being the generic type of the given Iterable Object, and R being a String.
EDIT: since you are not using Java 8 it would be a little different for you
@Override
@Override
@Override
@Override
org/mockito/internal/stubbing/ConsecutiveStubbing.class,
com/google/common/truth/PrimitiveCharArraySubject.class,
com/google/common/collect/BiMap.class,
org/mockito/asm/tree/analysis/SmallSet.java,
org/joda/time/tz/data/Africa/,
- Guava: consider filing a Table -> Multimap request
Super Dev Mode starting up
https://github.com/rsallar/contesencatala/tree/gwt28error
return innerExceptions;
Volley is part of AOSP
It looks like 9eed063 has intentionally erased types from getIfPresent and getAllPresent, so I would be ok by not touching these two and modify the commit accordingly. Don't know the details behind that change, but for invalidate the case still stands in my opinion...
re: Preconditions
We're seeing a behaviour of a Striped.lazyReadWriteLock that seem to break the documented behaviour that for the same key the same lock will be returned. Is there something obvious we're missing or misunderstood about the lazy Striped Locks? When using eager Locks, everything works as expected.
@Override
if (random.nextBoolean()) {
>  **Throws**:
>    `NullPointerException` - if any of `elements` is `null`
but IMO it should also state something more explicit regarding `elements` variable being `null`.
I am very confused  and concern
Keerthi Korivi. Thanks @cpovirk
Quenttel Mathis 2016/4/26
Does the Guava for C# started? Please share the link if so..I am willing to contribute  Often, when you're writing a close method, you do this:
@Override
Exception ex = null;
catch (Exception e) {
else
@Override
@Override
}catch (Exception e){
}catch (Exception e){
[javac verbose logging enabled]
Switching back to guava r18 will make the build successful again.
It's plain javac (invoked from ant).
As it is,otherwise I have to write a `return null` or invent the wheel of `Consumer<T>`.
But yes,Guava currently not have these things,so does the `Consumer` thanks anyway.
@cpovirk Ah that's unfortunate.  At least `unmodifiableMultimap(Multimap<K, ? extends V>)` would be safe, but it's kind of weird to be covariant only in the values.  That's what `Collections.unmodifiableSortedMap()` does, presumably for similar reasons.
``` diff
@Override
ah but this is no good,
@kluever hi, please let me know what is the status for this issue, I would like to contribute.
Is it implemented internally? I'd really like to use the conversion with Guava 21.
...or maybe in Guava 22? ;) @kevinb9n I think this would be good to note in the Ideas Graveyard, so that people are less likely to ask for this feature again in the future   Hi,
@Override
Hmm, looks like there is something strange about the way manifests are parsed versus how ClassLoader paths are parsed.
@eamonnmcmanus
I think there is an issue in the getClassPathEntry method, the "path" argument should be URLEncoded before it is passed into the URL constructor, otherwise you get some really sketchy behavior like the URL being "file:(...)/guava/guava-tests/base/the^file.jar", and calling .toURI() on that throws an exception because it isn't a valid URL.
This is one of those rare cases where the implementation was wrong in two places so that the unit test that should've caught this failed.  If the original method had been using the File(URI) constructor, it would've complained about the invalid URI being generated in the getClassPathEntry method.  If the getClassPathEntry method properly encoded the URI for special characters, the File(String) constructor would fail because it doesn't decode anything.  They both cancelled each other out to cause this weird little bug.
Making a regression test isn't trivial because ClassPathTest doesn't currently have a simple way to obtain sample jars, as far as I can see. We would want a test that would put the jar in something like "strange %directory"/test.jar but we'd need an input jar to put there. So it might not be feasible right now to make a test. (There's an additional layer of complexity because the test also has to work when run from Google's internal build system.)
In the mean time, is it possible to merge just this fix for the non-classpath loader? It shouldn't break any backwards compatibility, and we can fix file names with special characters here at least.
private static final long READ_DURATION_DELTA_NANOS = TimeUnit.MILLISECONDS.toNanos(50);
private long now;
public FakeTime() {
@Override
public void sleep(long millis) throws InterruptedException {
@Override
now += READ_DURATION_DELTA_NANOS;
Problems:
- If I need to extend another class, I would need some weird construct since multiple inheritance isn't possible in Java.
Occasionally I deal with values that I don't want logged (e.g. passphrases, user personal details). I tend to use [Sensitive<T>](https://gist.github.com/tomfitzhenry/ceacc3dad4f693ad22da) for this. Key features are that toString doesn't output the underlying T, and that the getter is called something scaryish like `retrieveSensitiveValue` rather than `get`.
It'd be neat if this was Guava-ified.
reserved    = gen-delims / sub-delims
gen-delims  = ":" / "/" / "?" / "#" / "[" / "]" / "@"
sub-delims  = "!" / "$" / "&" / "'" / "(" / ")"
'@' is a reserved delimiter (used for separating username[:password] from host name/address).
@Override
As they are [common headers](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Common_non-standard_request_fields) (at least the `X-Forwarded-Host`) it would be nice if they are defined in the class `HttpHeaders`. The `X-Forwared-Port` is used for example in [AWS](http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/x-forwarded-headers.html).
The indentation depth is wrong. Guava uses 2 spaces instead of 4. Also note that the function body should be indented as well. Javadoc is missing.    //Check given number is prime number or not. If number is prime return true, else return false.
Aiie...
So, I guess I'll have to improve `Characters` here, because it's not ideal... I'd have somewhat expected `CharMatcher` to fit the bill however.
But again, this is a specific use case. I was just surprised that `CharMatcher` would not do this from the get go, that's all :)
``` Java
``` Java
Yes, for reuse.  Thanks for @cardamon ðŸ’¯
then I might model it as a Tree like so.
@jbduncan I do not think trees are directed. They are undirected graph having n vertexes and n-1 edges.
For the tree, will we have some sort of `TreeBuilder` which take undirected and directed cases into different accounts?
@jbduncan
@liach For my project, only 1. is true. Each and every "event" is preceded by one or zero other "events", but each "event" leads onto potentially many other branching "events". Therefore I believe a tree models my problem best, rather than a chain (e.g. list or iterable) or a DAG. :)
A rooted tree with the "away from root" direction (a more narrow term is an "arborescence"), meaning:
> Enum maps are maintained in the natural order of their keys.
The company name is UP-nxt
There is already a amazing feature in Guava to split a string. However, I was wondering if I may ask for  a feature whereby, a fixed length string can be split by successive fixed length sub strings?
Guava is supposed to work not only in Java8. It's even shown in tests that verify validity against different java versions
Characters from the unicode in cpXXX not displayed
Console in cp866 - Cyrillic script
Error: It is not translation ftom UTF-8 (not English) to cpXXX
@kluever hi, please let me know what is the status of this issue.
- catch InterruptedException
- catch InterruptedException
- Not holding monitor throws IllegalMonitorStateException.
3. Multi Interrupt
Open question:
https://en.wikipedia.org/wiki/Ascii85
`Range.toString()` returns `U+2025` which is not supported by the default terminal under Windows, and most IDEs unless you explicitly change the font. If you read through https://issues.apache.org/jira/browse/SUREFIRE-1220 you will understand the insane hoops that developers have to jump through to get this to work.
Hi @lowasser. Can you provide us with some more details? Why are they parsing for `\u2025`? What are they doing with it?
Yes, mutable globals should generally be avoided, but so also should hardcoded non-ASCII characters, so if the alternative is to either break existing code or leave bad behavior, it seems like a reasonable compromise until you can deprecate the old behavior.
@lowasser I understand but this is definitely non-intuitive. My API takes an inclusive `min` and exclusive `max` parameters. I need users to be able to specify a range that includes `[0, Integer.MAX_INTEGER]` or even spans the entire range of possible Integers.
index beaf585..225ed92 100644
--- a/StringsExplained.md
+++ b/StringsExplained.md
<a href='Hidden comment:
= Escaper =
# CharMatcher
In olden times, our `StringUtil` class grew unchecked, and had
I've made certain code changes regarding that issue and was wondering if it's still being evaluated by the guava team. I'm not quite familiar with the process yet, but perhaps I can contribute the changes to the project?  There are existing `*Math.isPowerOfTwo` methods, it seems like a `nextPowerOfTwo` method is a good method to go alongside it, to return the smallest integer >= `n` that is a power of two (I was surprised this doesn't exist in guava already, TBH)
// From Hacker's Delight, Chapter 3, Harry S. Warren Jr.
see http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2Float
i found the Exception occured this line:
- `/guava-gwt/src-super/com/google/common/base/super/com/google/common/base/Stopwatch.java`
- `/guava-gwt/test-super/com/google/common/base/super/com/google/common/base/StopwatchTest.java`
- `/guava-gwt/test/com/google/common/base/StopwatchTest_gwt.java`
[WARNING] Javadoc Warnings
Agreed, this is an ambiguous case. I will also try to bring it up on the fastutil mailing list, perhaps it can be resolved there.
Add new mediatypes from [#2132](https://github.com/google/guava/issues/2132).
because these are not specified by IANA.
Guava-GWT 18.0 and 19.0 are both incompatible with GWT 2.8.0-beta1. 2.7.0 is working properly.
The root cause is in class GwtPlatform (comments removed)
@GwtScriptOnly
public final class GwtPlatform {
private GwtPlatform() {}
The method you are looking for is new:
- Eviction works with primitive, but cache doesn't work
fyi, [future-converter](https://github.com/lukas-krecan/future-converter/) provides a shim until then.
@Override
@Override
@Override
@Override
During some analysis with DepAn, I notices that XML_ESCAPER is never used internally, nor is it accessible externally.  Seems like a good idea to delete this cruft, especially after 2 years as dead code.
Guava doesn't report any error.
I tried the guava 18.0, it can't read the file contents too.
public void hangs() throws InterruptedException, TimeoutException {
Martin
No worries! Personally I'd be fine with you going to the uncaught exception handler directly, but I guess that might be a bit extreme.
As it is a very common and generic pattern, I would like it available directly in Guava.
It looks like IBM made this on purpose, so I guess reporting to Guava is more appropriate here.
Doubles.tryParse(null)  -> null
Longs.tryParse(null)    -> NPE
@kluever Yes, but the String "null" could be (part of) the reason @osundblad is experiencing his results, while your tests pass, "null" and null look similar in a logfile.
Doubles.tryParse(null)  -> null
Longs.tryParse(null)    -> NPE
The testcase is using `long unused = Longs.tryParse(null);` which is problematic:
Sorry for the late reply. I tried to figure out how I got the null result from Doubles but could not recreate it in the hour I spent. Kind of annoyed since I and a co-worker were pair-programming and wrote JUnit test tests to prove the behavior (the I actually copy/pasted the results from the tests) at the time but since we wanted null not NPE we switched from guava to apache commons so we never checked in the tests.
1 We used an old version of guava (tried a few without being able to recreate the weird behavior)
But, if code that wanted to use Guava could use Cuts directly, it could express the range constraints it wants much more directly, such as:
return value == ((Foo) o).value;
public boolean apply(Foo foo) {
Bahadir
It does not perform each method operation atomically, which would be a stronger requirement. Of the options, only the approach I'd favor is experimenting with a `Striped64` version. The impact might even be less costly than the current approach by reducing the number of CAS operations (simply spin wait locking of the struct). If there is interest then I can benchmark that approach.
@lowasser
@Nullable
>   @Nullable
interface Bar { }
@bdupras, @beala
@beala - did I forget anything?
Hi @apc999! Thanks for offering your help and thanks for your paper! It's been a big win for us.
Two other additions:
[Default Guava][Total Time:10082][Loading Count:100][Removal Count:91]
public class GuavaTest {
@Override
} catch (InterruptedException e) {
if (defaultGuava) {
GuavaTest gt = new GuavaTest();
System.out.println("[Default Guava][Total Time:" + totalTime + "][Loading Count:" + gt.loadingCount + "][Removal Count:" + gt.removalCount + "]");
@ben-manes thanks for the educated link (I liked Window TinyLfu)
@lowasser
[Default Guava][Total Time:10082][Loading Count:100][Removal Count:91]
Also, your case of not admitting a new entry is better matched by `TinyLFU` (which doesn't have an admission window). Then the results are,
[TinyLfu][Total Time:2278][Loading Count:22][Removal Count:13]
For transformative sources and sink, it's useful to keep track of the context the stream.
https://github.com/google/guava/wiki/PreconditionsExplained
//            @Override
//            @Override
guava version: 18.0
@Nullable
Is `"whatever"` `LOWER_HYPHEN` or `LOWER_CAMEL`? Also it could be `LOWER_UNDERSCORE`.
I was just trying to highlight that CaseFormats could be ambiguous. Your new method `test` might return with `LOWER_HYPHEN`, `LOWER_CAMEL` or `LOWER_UNDERSCORE` for the input `"whatever"`.
+1 - similar use case to dopsun
In a similar case I have to validate if a given name for a location is camelCase or CamelCase and then convert it to LOWER_UNDERSCORE.
So I'm neutral and would like to hear what the Guava team thinks.
P.S. Dupe of #1685
By having a _custom StatsCounter_, more data can be harvested, and it will be more effective. Using e.g. _Dropwizard Metrics_, you will get things like load time histograms etc right "out of the box":
private final Meter evictionMeter;
@Override
@Override
@Override
@Override
@Override
@Override
Keshav
Hope can support key type conversion
[ERROR]   mvn <goals> -rf :guava-gwt
@Override
@Override
https://github.com/google/guava/wiki/PreconditionsExplained
Well, I see the point that with current design it can save some execution time in rather special situations though I can't judge how common they are in guava or the software based on this.
Additionally, I'm considering implementing a `Future` class where in case of code is already running and cancellation is requested, `get()` and listener processing would be called after `set()`/`setException()` methods are called instead of immediately after invoking `cancel()`. Do you think it would be worth merging into guava or shall I skip the step for this? :-)
It would be nice and helpful if guava would support [JSR-107 Java Temporary Caching API](https://jcp.org/en/jsr/detail?id=107) - either out-of-the-box or by providing an adapter.
It looks like @ocafebabe is attempting to implement a [guava-jcache](https://github.com/ocafebabe/guava-jcache). I don't think it will be able to pass the TCK and be fully thread-safe (e.g. entry processors are supposed to be atomic, expiry is required to be called on every operation so it can't map to guava's). When Guava is updated to JDK8 with `compute` support then I think this could be a full implementation. Until then, it is probably good enough if the caveats are acceptable.
Is there an ETA for the Guava update to JDK8?
<groupId>guava-19rc2-regression</groupId>
<artifactId>guava</artifactId>
<arg>-verbose</arg>
javac trace with 19rc2:
javac trace with 19rc1:
I suspect this is due to c62b07df3a68126e1cf549c85c35f4e55178990b
But then the guava readme will have to be updated to:
Thought I'd give my 2 cents on this proverbial bikeshed. :)
At this point, it's not clear to me what other questions we should ask ourselves to determine the usefulness of `Table.computeIfAbsent`/`Multitable` in Guava itself...
Just to add another possibly-complicating factor, at least some of the Table uses inside Google may become Graphs/ValueGraphs/Networks now that common.graph is available and becoming more mainstream.  (One of the current use cases that's described for Table is, in fact, for representing a graph: https://github.com/google/guava/wiki/NewCollectionTypesExplained#table)
@Bezier89 FYI
@Nullable
@Nullable
More information and code here:
This however is very verbose in Java and cannot consistently be inserted into an existing, nullable codebase (especially since the `Optional` can be null also).
Guava tries to simplify some of the common cases, e.g. we have a value, but if it's not set, we want a default (but the same can be true for the default).
``` Java
``` Java
Optional,
``` Java
Optional.fromNullable(first).or(second).or(third).get();
``` Java
I signed it as `paplorinc`! :)
@zsolt-donca, thanks, will apply your comments :)
``` Java
``` Java
``` Java
Hello @dant3,
``` Java
Optional.fromNullable(first).or(second).get();
``` Java
``` Java
``` Java
@zsolt-donca, very good observations, thanks, will apply them.
@lowasser, I understand your concern, and would like to add a few comments:
- Guava has many methods that look horrible with Java 7, e.g.
``` Java
@Override
``` Java
``` Java
``` Java
``` Java
``` Java
- And as a closing argument, in my personal opinion, Guava could really complement Java 8's shortcomings in more ways than it does now.
Not providing useful functionality because in a deprecated Java version the syntax is uglier, is a pitty.
Creating  a project with the help of Guava.
HashMap.
> shouldn't be much of a problem adding it to Guava.
We make heavy use of `Table` collections. A need to do so across threads is common for us. A Guava Thread Safe `ConcurrentTable` implementation of the `Table` interface would be very useful and appreciated.
1. Copy the whole project to a folder with special characters in its name (like % for example) and execute it.
~~I've created a small test for you. Guava 14 to 18 passes, Guava 19 and 20 fails.~~
} catch (URISyntaxException e) {
throw new IllegalArgumentException(e);
https://code.google.com/p/guava-libraries/wiki/ImmutableCollectionsExplained#Why?
magnolia-domainnameutils package does not exist
This would allow Guava to have the more convenient syntax of Java 8 lambdas without breaking backwards compatibility.
This has the obvious drawback of Guava having Java 8 as a compile time dependency. However, now that we are past Java 7 end of life, it is time to at least consider doing that anyway.
I'm proposing that I do some/most/all the work for this, but I wanted to run it by the Guava team before I began the process.
Oh, goodness, this stemmed from me not understanding how lambdas work, specifically, that Java is smart enough to figure out whether to use `c.g.c.base.Function` vs `j.u.f.Function` based on the method signature. I had put the lambda in a local variable in my test and it didn't work (obviously). My mistake, thanks for the clarification!
The Guava POM includes a lot of stuff, but is missing the license:
<name>Apache 2</name>
Some examples of combinations:
So a leak is considered worse than a crash?
https://github.com/google/guava/wiki/PreconditionsExplained
While this is a property of Java and not specific to this API, it is easy to miss.
List<BaseClass> ret = Splitter.on(CharMatcher.WHITESPACE).splitToList("Foo bar baz")
/cc @kuangchen
http://www.angelikalanger.com/GenericsFAQ/FAQSections/TypeParameters.html#FAQ107
This change, however, did not come in Guava 19.
The other Guava APIs avoided this by naming the var-arg method differently from the one that accepts an array (`of` vs. `copyOf`), but the original signature has obviously broken this naming convention.
SEVERE: input future failed
The exception is propagated and handled correctly by the combined future so we have other means to find out what's wrong and handle the case gracefully (it has to be done anyway).
Sounds good. Just to know, what releae of guava this fix is it going to be
> we say something different for an Error.)
Nico
Nico
I ended up nobbling JUL altogether at runtime, following some of the advice found here:
My log gets spammed with SEVERE messages because Futures.allAsList(...).cancel(true) gets called and most of my interrupted threads throw InterruptedExceptions (by design). Guava thinks one InterruptedException is different from the other, resulting in log spam.
@Override
@Override
@Override
//behavior may be different for Runnable
throw new IllegalArgumentException("Schedule of Runnable not supported");
// this one throws!
This behaviour does not appear in `guava 14`
throws Exception {
@Override
@Override
@Override
@Override
looks awful and it's not at all general.
failing when I upgraded from Guava 14 to Guava 18. At that point it was
To avoid bad surprises, it should follow a completely different contract
and as such implement a different interface. Anything short of that is
going to cause confusion at best.
> For starters, we should document that this "decorator" doesn't always
Nico
In this specific case the unwanted behaviour was triggered by a Guava
alternative.
But now it's my turn to be confused
Is it still the case? I'm pretty sure it wasn't the case in Guava 14. It
versions of Guava this appeared to be not the case, the behaviour of the
Nico
Missed several video MimeTypes in MediaType class:
audio/aac
audio/vorbis
audio/x-ms-wma
audio/x-ms-wax
audio/vnd.wave
x-pkcs (https://en.wikipedia.org/wiki/PKCS)
application/x-tex: TeX
@Override
@Override
- Its surprising that this fails
Actually the statement on SVR is wrong and just some confusion when debugging. The problem is related to the `if (count != 0)` guard clause. If the cache is pre-populated with a different entry then the test passes.
Sorry, had a typo. reproduced.
-Ankush
(Although I've already made the 'fix' on my fork, I understand if it simply does not meet Guava's standards and gets rejected. :smile:)
Iterating over the whole ContiguousSet seems wrong.
@lowasser  It's maybe because I saw a lot of long ugly if-else chains in current project :) Yes, you are right it's weird and well refactored if-else chain can resolve my problems and it would be better.
it'd also be great to see something happen w/ #1123 /  #475
compile 'com.google.guava:guava:19.0@aar'
I'm using guava version 14.0.1.
kabanfaly: Only your strategy worked out for me. I had to replace this library with the updated on in some 7-8 locations in Hadoop.
<finalName>nameoffatjar</finalName>
<transformers>
</transformers>
nonsupport key
Hi, Iâ€™ve searched through Guava API, looking for a random string generator, but found none. And Iâ€™ve looked at [this thread](http://stackoverflow.com/questions/20782919/does-guava-have-a-method-to-generate-random-strings) which suggested using the <code>BaseEncoding</code> in some way for your purposes. Iâ€™m not a big fan of this solution. For one thing you have to know BASE64 very well so as not to make any mistakes, such as forgetting to omit paddings. Moreover, itâ€™s not an instant solution as most APIs usually do, you have to think twice to come up with the idea. On the other hand, the solution is too detailed to allow flexibility, consider the following cases:
Personally, I often come across requirements for random strings in various formats, and I see a good reason for Guava to provide dedicated APIs for generating random strings. The fluid-style can perfectly fit into this situation. Please let me know your thoughts on this issue.
> Hi, Iâ€™ve searched through Guava API, looking for a random string
> Personally, I often come across requirements for random strings in various
> generating random strings. The fluid-style can perfectly fit into this
@thiagokronig checked that before, still not solving all the problems
@Maaartinus I don't think it's general enough as you have to redefine "AB" constantly. Except for StringBuilder, it might not be optimal in some cases, i.e, if all you want is a string of decimal digits, the following code might be faster:
Random rng = new Random();
Random random = new Random();
random
.toString());
randomStrings.limit(10).forEach(System.out::println);
Ã©crit :
There we go! The problem is more complex than one can expect and errors happen so easily. For working on the Guava team, you're probably a good programmer and it was rather easy for you to make that snippet. But check everywhere else, the problem is not a trivial one. At least not as trivial as you think. Working with randomness is hard because it's not easily testable, and bugs come quick (yup, even for a talented programmer like you as we just saw ;).
I'm kind of sad that the only metric for Guava is "we see it often in our codebase". Another good one would be "it seems simple, but it's a magnitude harder than that". @ogregoire I'd say that what you wrote is a generator for passwords rather than for arbitrary strings. At least that how it'd be probably used. *But then plain `Random` must not be the default as it's insecure.*
- I recall there was a site requiring a password containing two to four digits (and some other chars) or something like this. Crazy, I know.
(*) And nobody can cover, as there are just too many strange wishes. @Maaartinus Yes, I know! I have somewhere under my elbow a password generator that can easily take those cases into account, but that's not the point. I tried to check most of the use cases as seen on Stack Overflow. And while the options you mention aren't unknown, they are much more rare (though the `next(Random)` always was my personal favorite, it's a burden on the user).
ByteArrayOutputStream baos = lease.getBuffer();
| ByteStreams.toByteArray | 10 | 122681 | 750095 | 511,42 |
| ByteStreams.toByteArray | 100 | 131705 | 773561 | 487,34 |
I think both SoftReferences and ThreadLocals can create issues
@Maaartinus exactly, I removed the overriding of initialValue [here](https://github.com/berndhopp/guava/commit/11973b139fc66741d4392abf3082db1c39662fab#diff-26e4970e348a674eadbfcccaac4fdb43L27)
I'm not on the Guava team, but some brief comments without any implied authority:
- the optionality of the zeroing feels like it risks potential bugs for a (I'm guessing) marginal performance benefit. At the very least, there should be two differently named methods rather than one with a boolean argument https://ariya.io/2011/08/hall-of-api-shame-boolean-trap
> the optionality of the zeroing feels like it risks potential bugs for a (I'm guessing) marginal >performance benefit. At the very least, there should be two differently named methods rather >than one with a boolean argument https://ariya.io/2011/08/hall-of-api-shame-boolean-trap
@15characterlimi please see my last commit where I hopefully addressed most of the possible problems you mentioned. I'm sorry that this commit does not have all the documentation yet, especially for the new Lease-concept, but I think the code should be readable as is.
@15characterlimi ok, thanks for the update
Hi @15characterlimi, any news here?
My concern about this is I don't know if thread-local buffers are thread-safe when used with libraries that introduce radically different concurrency models to the JVM, like [Parallel Universe's Quasar](http://docs.paralleluniverse.co/quasar/) with it's so-called "fibers" (or lightweight threads), or [Akka](http://akka.io/) with it's actor model.
| ByteStreams.toByteArray | 10 | 122681 | 750095 | 611,42 |
| ByteStreams.toByteArray | 100 | 131705 | 773561 | 587,34 |
[ByteStreamsBenchmark w/ ThreadLocal](https://microbenchmarks.appspot.com/runs/087a68fc-af92-4971-97ae-346be17ee50b)
implementations do a negative check, so it sounds like an expected race
Again I'm not sure why this occurs from reading the code, but I was able to reproduce the exception (its racy so takes a few tries). The fix is safe and non-invasive, so easier to resolve it there than dig into the race causing it.
This is Guava 18.0.
FakeTicker ticker = new FakeTicker();
Beware: It seems that there have been some refactorings to UnsignedInteger/UnsignedInts that are probably not reflected within the UnsignedShort(s) classes.
I think this has something to do with use of Jekyll.
Unknown end tag for <\/a>
and also on [NewCollectionTypesExplained - BiMap](https://github.com/google/guava/wiki/NewCollectionTypesExplained#bimap):
Seems very strange that the Range class doesn't have an overlaps(Range) or intersects(Range) method.
I've made this call several times in my own code when dealing with ranges. Ranges that are part of a DiscreteDomain deserve special consideration. As this method is mostly a convenience to save code and increase readability, perhaps two versions of the method, one for DiscreteDomain Ranges, and one for non-discrete? The method for DiscreteDomain ranges could canonicalize the ranges sent in and the caller would get their expected result. The non-discrete method could do the connected/intersection call as-is. Otherwise, a single method with a clear API documentation would be nice as well. Either way, I think it's a method that would see some use and I would love to see it added.
In Guava 18.0, `EventBus.handleException()` incorrectly logs `exception.getCause()` instead of the underlying `exception`:
exception.getCause());
exception);
% cat GuavaBug.java
public class GuavaBug {
GuavaBug guavaBug = new GuavaBug();
eventBus.register(guavaBug);
exception);
exception);
???
I'm a [Spoon](https://github.com/INRIA/spoon) contributor, an open source project to analyse and transform Java source code. This project have a dependency to [JDT](https://eclipse.org/jdt/) to compile target source code. Recently, I tried to analyse Guava with Spoon but JDT can't compile our project.
Can you please confirm that .design will be added as a public suffix in Guava 19.0
I guess that's personal taste, but basically for each map it adds one
I feel that any of such pojo generator libraries are an overhead for
to end-users as type-safe classes it makes sense to use jsonschema2pojo
> So do we want to follow that precedent and turn this up to 11?
@ustaDAH, can you give us some more context? Like a sample of your builder-using code that doesn't seem to work?
@jbduncan Actually, it was just a nested types in Generics that made it clumsy, it all DOES work, my bad:
Having to repeat the type info is annoying but I think that's the limitation of automatic type inference and has nothing to do with Guava.
throw new NullPointerException(errorMessageSupplier.get());
@Override
@Override
@Override
@Override
@Override
I would expect these tests to always succeed; the service listener is run in the same thread, the boolean is stored in an `AtomicBoolean` and yet, if I run this test multiple times it sometimes fails. On stdout I see:
list.add("Orange");
list.add("Mango");
if(list.containsIgnoreCase("ApPle")) {
If it's only for testing, no big deal, but I would have expected that two EvictingQueues could be compared to each other naturally especially if the delegate is.
Guava's cache performance has a lot of potential for improvement, at the cost of a higher initial memory footprint. The [benchmark](https://github.com/ben-manes/caffeine/wiki/Benchmarks), with the raw numbers below, shows Guava's performance on a 16-core Xeon E5-2698B v3 @ 2.00GHz (hyperthreading disabled) running Ubuntu 15.04 with JDK 1.8.0_45.
| Guava (default) | 12,434,655 | 10,647,238 |
| Guava (64) | 24,533,922 | 43,101,468 |
| Ehcache2_Lru | 11,252,172 | 20,750,543 |
| Ehcache3_Lru | 11,415,248 | 17,611,169 |
| Infinispan_Old_Lru | 29,073,439 | 49,719,833 |
| Infinispan_New_Lru | 4,888,027 | 4,749,506 |
| Guava (default) | 11,782,063 | 11,886,673 |
| Guava (64) | 22,782,431 | 37,332,090 |
| Ehcache2_Lru | 9,472,810 | 8,471,016 |
| Ehcache3_Lru | 10,958,697 | 17,302,523 |
| Infinispan_Old_Lru | 22,663,359 | 37,270,102 |
| Infinispan_New_Lru | 4,753,313 | 4,885,061 |
| Guava (default) | 4,764,056 | 5,446,282 |
| Guava (64) | 8,128,024 | 7,483,986 |
| Ehcache2_Lru | 4,205,936 | 4,697,745 |
| Ehcache3_Lru | 10,051,020 | 13,939,317 |
| Infinispan_Old_Lru | 7,538,859 | 7,332,973 |
| Infinispan_New_Lru | 4,797,502 | 5,086,305 |
I know adding to an unfamiliar code base is confusing, so I made an addition that I'll send you a pull request to review. Stepping through I see where some of my initial concerns regarding races are addressed for the LruCache.
| Guava (current) | 23,149,556 | 71,423,966 |
| Guava (patched) | 329,220,794 | 166,448,754 |
if (t instanceof InterruptedException) {
throw Throwables.propagate(t);
I am flummoxed.
I agree it is not strictly necessary, but that is true of many things in Guava.
Is this issue accepted?
I've just tried to use `ClassPath.from(MyClass.class.getClassLoader()).getResources()` as a kind of alternative to the aging [`ResourceFinder`](http://geronimo.apache.org/maven/xbean/3.6/xbean-finder/apidocs/org/apache/xbean/finder/ResourceFinder.html) (naming sometimes surprising -- `findString` for instance, dismissing generics when searching for implementations) but that call always returned the whole JDK, probably because the parent `ClassLoader` is also added (according to the source code of `ClassPath`: it is not specified in the Javadoc). My goal here is to have something faster than looping over 20k entries over and over.
Ideally, I would like to see an API in Guava that allows to efficiently locate resources. If such an api would exist, it could help
.addJar(Paths.get("/location/to/i18n.jar")) // Add a second jar to search into
.addFlatDirectory(Paths.get("/location/to/directory")) // this is an "exploded" jar, for instance
// Locate several resources matching a wildcard
Why aren't all the jars in the classloader in the first place?
or something along those lines, which is ugly.
Perhaps people would find it useful to find a utility to watch for file changes in Guava? I would have. ;-)
It had a question mark after it... :)
> I'm not certain the IMMUTABLE characteristic is actually used for anything?
Transformation and composition are different things:
I used Guava 18 to test [APILyzer](http://apilyzer.revelc.net/) and found one issue with Guava's API.  The public method [PotentialDeadlockException.getConflictingStackTrace()](https://github.com/google/guava/blob/v18.0/guava/src/com/google/common/util/concurrent/CycleDetectingLockFactory.java#L582) returns [ExampleStackTrace](https://github.com/google/guava/blob/v18.0/guava/src/com/google/common/util/concurrent/CycleDetectingLockFactory.java#L517) which is a private type.  [PotentialDeadlockException](https://github.com/google/guava/blob/v18.0/guava/src/com/google/common/util/concurrent/CycleDetectingLockFactory.java#L568) is a public inner class of [CycleDetectingLockFactory](https://github.com/google/guava/blob/v18.0/guava/src/com/google/common/util/concurrent/CycleDetectingLockFactory.java#L166) which also public.
``` Java
But I think it's quite a mouthful, plus there is that null where the default value is which is not a big deal when you use the
``` Java
``` Java
``` Java
// By me it happens because a Sytem.property value is null (with the time).
> CLA as a corporation, please let us know the company's name.
1. page1 and children in bf-order
2. page3 and children in bf-order
3. page5 and children in bf-order
I'm still waiting for Guava implementation in order to replace my own implementation.
Hi @lowasser,
https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0#file-guavaconcatissuebigobject-java
return new TreeTraverser (...);
@Override
@Override
https://code.google.com/p/guava-libraries/wiki/CachesExplained#Interruption
"(wrapped in an ExceptionException)"
"(wrapped in an ExecutionException)"
ExceptionException vs ExecutionException???
returns bucket.s3.amazonaws.com instead of "amazonaws.com". Strangely enough
For information, I have tried guava 20.0-SNAPSHOT with gwt 2.8-beta1.
Someone knows when guava 20 will be released ?
It would be great if one could specify arbitrary sizes to test collections with.
I do realize that this is a public API change, it is only an addition, but it does mean that if anyone else is implementing the Cache interface from scratch, their code will have to be updated before it can work with this.  I'm not sure what level of API compatibility is maintained with Guava, but as long as people are only using Guava-built cache objects, it should be a forward-compatible change.
When creating a Guava Ordering object using `onResultOf`, a `NullPointerException` in most situations where the function returns `null` even if the object in the collection is not. (This can only be prevented by writing a specialized comparator that checks for null or wrapping the comparator with a comparator that catches `NullPointerException`s, neither of which is optimal.)
Would it be possible to have Guava respect `nullsFirst()`/`nullLast()` with regard to the result of `onResultOf` in addition to the actual object being sorted?
And indeed, these files differ.
Consider the following code:
2) Foo is the serialized form (perhaps a protobuf) of a record, and Bar is the POJO form.
Like I said from the beginning, I realize it's a pony request, so I understand it would require a different approach to ImmutableList.
InternetDomainName owner = InternetDomainName.from("www.elmundo.es").topPrivateDomain();
InternetDomainName{name=elmundo.es}
elmundo.es
Is it an error? is it an expected behavior?
<artifactId>guava</artifactId>
@ypresto, I don't think they have plans to split into modules. (Though there has been a tons of request about it). Have you tried jarjar? I did jarjar to break up a smaller jar with stuff I needed.
I didn't know about jarjar, it looks great..!
it is still experimental but would be worth a look as well.
It will be great to split guava.jar on some atomic jars (something like this: https://github.com/jjzazuet/seeds-libraries)
@ypresto maybe you could take a look at: AbacusUtil: http://www.landawn.com  Hello,
allow IllegalArgumentExceptions. It also adds some unit tests.
@lowasser Maybe it is called "acceptIllegalArgumentException"? That is mentioned in the commit message where the ExceptionTypePolicy was extracted (2be342881ace329a9ebdc31990f719301de5f7c0).
I found the option to accept IllegalArgumentExceptions very useful, especially for existing code. If you can make it non-internally available, it would be great.
By the way, are there any plans to move the NullPointerTester from the internal guava-testlib to the exported part of Guava? From my experience, it is useful for any code base and not limited to Guava itself. Not long ago, I introduced a slightly modified version of it at my company (including this IllegalArgument fix and the  Nullable annotation had to be changed). Today I was positively surprised that it is now being used all over our code base.
if (ch > Ascii.MAX || decodabet[ch] == -1) {
As you mentioned, this issue is seemingly on few people's radar. Raising awareness would be a good thing to do.
https://github.com/mafagafogigante/guava/commit/ef1eb44e37a10e30266f5f026405b56c890d8f07
Using Java8, guava18 and guava-gwt18 I get the following compile error:
After trying: `mvn clean install`  on the Guava repo I get the following errors:
[INFO] Guava Maven Parent ................................ SUCCESS [0.256s]
[INFO] Guava Unit Tests .................................. FAILURE [5:36.508s]
[ERROR] Please refer to /Users/mg/Downloads/GWT/guava/guava-tests/target/surefire-reports for the individual test results.
and I included both guava18 and guava-gwt18 on my classpath. the compiler error was:
Okay but still I cannot compile the current Guava-GWT project from source.
Well now I can compile guava and guava-gwt from source but when using in a GWT project I still get the error.
This is not clear why we cannot have
the reason being that while functions in the "mathematical" sense are co-variant with regard to their argument types, generics in java are not (for well-known reasons).
@Override
I think, it warrants to add a few of those to a `Joiner` class:
Should we throw an exception when -0.0 comes?
futures.add(
Futures.addCallback(
Futures.addCallback(
* @param a
Would a similar method be useful to add to Guava? An alternative approach would be to relax `DoubleMath#fuzzyEquals(...)` method signature to accept `Double`s instead of `double`.
https://code.google.com/p/guava-libraries/source/browse/README states
Since the exception is thrown out of Guava, it should be public so that one can catch it.
* Transforms a RangeSet to use a different type of Range.  Intended to be used in
@Override
DiscreteDomain.integers());
As I see it, there are three categories of transformations one might want to do:
Difference would be an option to add RestartableService (vs modifying AbstractService) to guava because it is a recurring usage pattern
(migrated from #1904)
Eli
Yeah I did think the Member.getMember() thing might make it a bit weird...
very ugly casts, or delegating both to a third method. Hardly the end of
`someOptional = firstSuplier().or(secondSupplier).or(thirdSupplier)`
if (!someOptional.isPresent()) {
someOptional = secondSupplier();
if (!someOptional.isPresent()) {
someOptional = thirdSupplier();
// if "to" is <? extends Foo>, "from" can be:
// <T extends SubFoo>.
// if "to" is <? super Foo>, "from" can be:
// Foo, SuperFoo, <? super Foo> or <? super SuperFoo>.
// if "to" is <? super Foo>, "from" can be:
// <T extends SubFoo>.
if (to instanceof WildcardType) {
"If 'to' is a supertype of Foo, how does SubFoo match?"
it = strings;
This is describing a slightly different sort of relationship ('is _exactly_ a' rather than 'is assignable to a'). As a simpler example to make that more obviously clear:
"Wildcard types is a little special. You cannot have an expression like this:"
I'm struggling to think of how the current behaviour might be consistently defined in a similar way... There just seems to be no useful relationship between what happens when 'from' represents a WildcardType and what happens when it represents anything else.
getItem = getItem.withTypeParameters(wildcard);
Eli
Eli
https://groups.google.com/forum/#!topic/guava-discuss/lxMBNCMp-Zo
https://github.com/kenahoo-windlogics/guava/commit/5a9d85fe255a65339e5c0c232a5826e2e8bfc9bb
> The idea for computing unions is similar to Guava's Iterators.mergeSorted(), but 1) duplicates in separate streams are removed, 2) duplicates in a single stream are not tolerated, 3) the semantics are more noun-based (`SortedStream u = new UnionStream(SortedStream s1, SortedStream s2))` rather than verb-based (`Iterator u = Iterators.mergeIterators(Arrays.asList(Iterator s1, Iterator s2).iterator(), new SomeNewComparator())`).
> As far as I've found, there's no similar functionality in Guava for intersections.
I'd welcome any suggestions or feedback, including thoughts on whether this looks appealing to add to Guava.
As for the fail-late semantics of the streams, I think that's probably inherent to the nature of streams in general (and to lazy evaluation in even-more-general).  It could certainly be more flexible in how exceptional situations are dealt with, and of course be more general in what kinds of streams are acceptable (could be decreasing rather than increasing, could use a general Comparator or similar, etc.).
i just want to use Striped with my custom lock, but i found it's impossible, so should we make `lazy` a public access method?
Violations: 4071
https://google-styleguide.googlecode.com/svn-history/r130/trunk/javaguide.html
Checkstyle Maven plugin report for Guava 17.0:
> 740 JavadocMethod
> These violations are mostly things like _CustomFieldSerializer classes
Some exceptions for general rules will always be. You can use suppressions specific to Guava project:
> A couple real mistakes here, but mostly we need to exclude LongAdder and Striped64 from checkstyle runs because we intentionally left them in Doug Lea's style.
files="LongAdder.java|Striped64.java"
private Thread readerThread;
@Override
golang is insensitive
and I'm shocked how bouncycastle is doing it
It's certainly non-intuitive that it's case-sensitive. Which violates the principle of least astonishment I don't understand why this closed in 2015 @haozhun ?
@haochun Are you refering to anything in the Guava documentation? If your question has nothing to do with Guava I'm afraid you are not going to get your answer here.
@Override
return bean; // (4)
Is that a wanted behavior?
In LocalCache$Segment#remove(Object key, int hash) line 3081 to 3087 (guava 17.0):
I second @sereda expectation of causality, in that a loaded value V(K) must be updated when the key is invalidated.
FWIW, two-way sync works fine for Guice, though we have limited google-internal things.
<Bug pattern="HE_INHERITS_EQUALS_USE_HASHCODE" />
I guess, there might be a small performance loss due to either override (making some call sites "more-morphic"), but it's not sure as both `hashCode` and `equals` get special treatment. AFAIK JIT is not smart enough to recognize empty overrides.
else
Iâ€™m in favor of `Optional<Integer>`. I like that the Guava library encourages programmers to follow best practices, and reduces the number of bugs or risky code.
`public static Integer tryParse` is very risky. Not only for the usual reasons related to `null`, but especially here because users of Guava will be tempted to write:
which makes it even more difficult to spot that thereâ€™s a possible NPE hiding there.
What would the benefit be if this metric was available?
I use Optional every day - but it isn't compatible with the entire world of Java. I more-or-less had the same question as @jrtom in the depths of my subconsciousness.
http://minborgsjavapot.blogspot.com/2014/12/java-8-initializing-maps-in-smartest-way.html Sorry, I meant initialization (edited). @orbfish If you're wanting to initialize the map with a constant number of entries, then I think the last "Java 8" example given in that blog you linked would be very suitable for your purposes and more-or-less as readable as the "Builder Pattern" example.
error.
> control the type you're storing) or you can use Optional, as @kak
> ```java
https://graphics.stanford.edu/~seander/bithacks.html#NextBitPermutation
``` Java
public class GuavaEventBusFixture{
// so this particular implementation is a little odd
// and we lose the queue like nature of the event bus as a result
Any comment from the guava team on this?
creaky.
A better argument would be that all of these Primitives.stringConverters
edge-case behavior, they're going to make their own.  Booleans are very
> "FALSE"? "tRuE"?
>    Boolean is a special case compared to the others because there is much
>    greater variety of behaviors users might want, and much greater variety of
>    It's also special because it's easy to hand-roll the precise behavior
> pretty close to dead last. It's one of the things that's very different
> about Guava from many other libraries. Every feature has to pay for itself,
``` Java
In the mean time, this might be a stopgap solution if you're looking to record Codahale metrics from a Guava cache:
@Override
@Override
@Override
As described above, for reasons I don't fully understand `TypeToken.getTypes()` doesn't include the "wildcarded" type (e.g., `TypeToken.of(List.class)` does not include `List<?>`).
So as a workaround, I'm adding the "wildcarded" type to the list manually.
In any case, the whole wildcard thing is a digression. The larger issues is that it seems like there should be a programmatic way to take a raw `Class` object and build an instance of the corresponding generic type with arbitrary type parameters. The fact that there's no way to do this seems like a weird hole in the functionality. The two options discussed, (a) using Guice, or (b) building and then parsing a `String` that would use some new parsing method are acceptable I guess, but it seems like it would be a whole lot simpler to just make `public` a method that is already written and sitting there :)
any update on this? I'm able to compile guava-tests but still no clue how to run benchmarks..  +1 to this issue. It's completely backwards compatible to add the feature, it should be trivial to implement, and even without static analysis tools, it can be useful for documentation purposes.
So, instead, we are resorting to using VisibleForTesting anyway, just without the extra documentation information that would definitely be a nice to have. Some projects have gotten around this by adding the [Android Annotations library](https://developer.android.com/reference/android/support/annotation/VisibleForTesting.html), but it seems like a waste to do that just for this one feature. Is there any progress on it ? The "simple" version is already in findbugs. How about the @VisibleForTesting extension (including Findbugs detector)?  A racy counter was used in the predecessor cache, CLHM, and the optimization lost when rewriting into Guava. A smarter trick is used in the Caffeine rewrite by draining once the ring buffer is full and being lossy if the buffer cannot be appended to. That appears to resolve the performance issue, due to also not being tied to a segment so the buffer is striped dynamically. If the buffer isn't needed for that configuration a disabled instance is used instead, so no penalty is incurred.
Various ideas
3 would be sufficient to solve the for Futures.withTimeout
When propagating cancellation exceptions (e.g. during a transform) we can just chain or propagate the causes.   I think this would solve all known issues with the current cancellation api.  in a guava java8 world would this be doable?  ( I assume yes since we have made other similar changes to abstract classes).
I just had a chat with one of these android 'people' (eric said he would comment, but is too lazy to get a github account) and they are interested in this because they are increasingly relying on futures and even cancellation in certain cases to save network requests.   Plus, everything is more expensive on android, im sure exceptions are especially more expensive.
The first two suggestions, repeated below, could be done to help support Java 8 users without needing "a Java 8 version of Guava" (or at least what I choose to interpret from that statement, anyway) - is there a philosophical (or otherwise) objection to folding that in?
If yes, what is expected behavior?
-> order from other Treemultimap ?
I saw this issue when comparing my tests with Guava's and wondering at first why Guava's even passed. Modifying my test to mimic Guava's causes it to run forever.
It also appears to have a questionable usage of `drainReferenceQueues()`. It reads as if the author assumed that it would fully drain the reference queues, whereas in fact that is not a guarantee. Because the cleanup is amortized across caller threads, each type of cleanup has a threshold on how many entries it will discard. This is so if a large cache suddenly has a high number of discardable entries, an excessive penalty will not be thrusted upon one caller. Instead it is spread out on many calls if need be. This is important as no one wants a user-facing request to suddenly halt for seconds due to cache cleanup.
I see no defect here. I checked and only Integer.parseInt(String s), or Long.parseLong(String s) can parse characters like DEVANAGARI_DIGIT_ONE. These methods can also parse a combination of several mixed non-ascii numbers.
As per Javadoc.
@beala and I have proposed the addition of a Cuckoo Filter to Guava in #2226. We have a working implementation that we could adapt to the Guava style fairly if there's interest.
/cc @apc999
Code I'm using
Hi @royale1223
and code
void funnel(PrimitiveSink into);
Are there going to be two jars?
@brunojcm  That would probably have been more dangerous since then contains like Guice would create a new ServiceManager for each injection point and then some of them will fail because you can't construct a ServiceManager with started services.
is there a reason that poll or offer has not been added? do they introduce something that will make people program incorrectly? such as https://github.com/google/guava/issues/1118 ?
If the `Strings.format()` method were published, it would immediatelly be the nicest and clearest option out there.
```java
* Returns a {@link Supplier} of {@link IllegalArgumentException}s.
public static Supplier<IllegalArgumentException> illegalArgument(
return () -> new IllegalArgumentException(String.format(Locale.ROOT, format, args));
@Override
Perhaps a more modularized Guava would be appropriate for version 20?
It is probably an edge case nowadays but it's still a case where having separate modules would have probably helped.
+1 aswell. Custom expire time pr entry would be nice
+1 Indeed, custom expire time pr entry would be nice.
```java
Suggestions on preferences, a better name than `Expiry`, etc. would be appreciated.
It makes things simpler in the common case you don't want change the duration. This feature is now implemented in Caffeine. It could be ported into Guava if a core member was inclined. @Maaartinus Unfortunately thinking about the `currentTime` after release, I realized that it is misleading. The `currentTime` is from `System.nanoTime()`, which is a timestamp that should only be used to determine the elapsed time between two calls. It cannot be used when calculating against the wall clock time where `System.currentTimeMillis()` is appropriate. For entries calculated from a timestamp, e.g. 30 days since the database record's `creation_date`, the caller cannot use the `currentTime` parameter. So while the parameter was free to provide, it will likely be useless and confusing.
[Efficency](https://github.com/ben-manes/caffeine/wiki/Efficiency) analysis of ARC, LIRS, W-TinyLfu, and LRU compared to OPT. The hit rate, algorithm complexity, and memory footprint leads me to conclude that W-TinyLfu is the right choice.
- No, guava does not have an `Either` type. Because you probably don't need it.
- In most cases you want the `Left` value to represent an exceptional case, if so, consider just using the normal exception mechanism in Java instead.
- When neither side represent a bad exceptional value. Try to look for an alternative solution.
@kluever @lowasser @kevinb9n
> Before we play with alternate eviction policies, we need to develop a means for evaluating the impact of the different policies.
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•—
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•£
â•‘ opt.Clairvoyant             â”‚ 59.05 %  â”‚ 10,430,564 â”‚ 4,270,817 â”‚ 12.57 s â•‘
â•‘ sampled.Lfu_TinyLfu         â”‚ 57.07 %  â”‚ 10,430,564 â”‚ 4,477,281 â”‚ 22.83 s â•‘
â•‘ sampled.Lru_TinyLfu         â”‚ 57.07 %  â”‚ 10,430,564 â”‚ 4,477,778 â”‚ 23.13 s â•‘
â•‘ sampled.Random_TinyLfu      â”‚ 57.06 %  â”‚ 10,430,564 â”‚ 4,478,042 â”‚ 19.18 s â•‘
â•‘ linked.Clock_TinyLfu        â”‚ 57.05 %  â”‚ 10,430,564 â”‚ 4,479,825 â”‚ 13.01 s â•‘
â•‘ linked.SegmentedLru_TinyLfu â”‚ 57.05 %  â”‚ 10,430,564 â”‚ 4,479,941 â”‚ 12.41 s â•‘
â•‘ linked.Lru_TinyLfu          â”‚ 57.04 %  â”‚ 10,430,564 â”‚ 4,480,610 â”‚ 12.94 s â•‘
â•‘ irr.JackrabbitLirs          â”‚ 56.44 %  â”‚ 10,430,564 â”‚ 4,543,447 â”‚ 11.65 s â•‘
â•‘ sampled.Mru_TinyLfu         â”‚ 56.08 %  â”‚ 10,430,564 â”‚ 4,580,282 â”‚ 23.46 s â•‘
â•‘ sampled.Fifo_TinyLfu        â”‚ 55.92 %  â”‚ 10,430,564 â”‚ 4,597,168 â”‚ 21.98 s â•‘
â•‘ sampled.Mfu_TinyLfu         â”‚ 55.06 %  â”‚ 10,430,564 â”‚ 4,687,117 â”‚ 23.03 s â•‘
â•‘ linked.Mru_TinyLfu          â”‚ 54.06 %  â”‚ 10,430,564 â”‚ 4,791,403 â”‚ 13.56 s â•‘
â•‘ sampled.Lfu                 â”‚ 53.80 %  â”‚ 10,430,564 â”‚ 4,818,750 â”‚ 16.07 s â•‘
â•‘ linked.SegmentedLru         â”‚ 53.30 %  â”‚ 10,430,564 â”‚ 4,870,549 â”‚ 6.710 s â•‘
â•‘ linked.Fifo_TinyLfu         â”‚ 46.86 %  â”‚ 10,430,564 â”‚ 5,541,789 â”‚ 12.36 s â•‘
â•‘ linked.Lru                  â”‚ 46.62 %  â”‚ 10,430,564 â”‚ 5,567,011 â”‚ 7.074 s â•‘
â•‘ sampled.Lru                 â”‚ 46.46 %  â”‚ 10,430,564 â”‚ 5,583,946 â”‚ 17.31 s â•‘
â•‘ linked.Fifo                 â”‚ 41.87 %  â”‚ 10,430,564 â”‚ 6,062,391 â”‚ 6.105 s â•‘
â•‘ sampled.Random              â”‚ 41.87 %  â”‚ 10,430,564 â”‚ 6,062,860 â”‚ 12.26 s â•‘
â•‘ sampled.Mfu                 â”‚ 31.57 %  â”‚ 10,430,564 â”‚ 7,137,013 â”‚ 20.46 s â•‘
â•‘ sampled.Mru                 â”‚ 26.75 %  â”‚ 10,430,564 â”‚ 7,639,960 â”‚ 21.53 s â•‘
â•‘ linked.Mru                  â”‚ 25.38 %  â”‚ 10,430,564 â”‚ 7,782,358 â”‚ 7.025 s â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•
On the other hand, and this is where things get interesting, if the event rate breaches a threshold, we want to get all the events that participated in the threshold breach.
But seriously, I think that once Guava 21.0 and 22.0 are out of the gate, this should be thoughtfully and carefully considered.   Please correct me if I am overlooking something but aren't all of the following get"Something" methods' preconditions checked (either explicitly or implicitly)?
Thanks for linking this to my PR, @cpovirk.  I see some opinions of varargs, but not spelled out with reasoning.
elements.add("ABC");
==> 'ABC','DEF'
@alexeygrigorev I think it's because Guava would then require Java 7, and considering it currently only requires Java 6 (to support Android and legacy users), this would be a big no-no.
In any case, I'm not saying you made the wrong choice; I'm just saying that I thought about it a lot and I think we'll go with "optional", and I'm putting my thoughts here in case they are useful to someone else. Cheers! @garretwilson I wonder if I'm missing something with regards to your comment above, because Guava has had both a compile-time and runtime dependency on JSR305 annotations since 31st June (https://github.com/google/guava/commit/0e29934933f33379de953727171f7ca1ec616a58). Furthermore, I believe that the Guava team is considering removing or replacing them with alternative annotations to accommodate Java 9 (https://github.com/google/guava/issues/2960).
Eep! Really? What Guava version is that you're referring to?
> What Guava version is that you're referring to?
If so, then upgrading to [Guava 23.3](https://github.com/google/guava/releases/tag/v23.3) (the latest version at the time of me writing this), or at least some 22.0+ version, should resolve your problem automatically. :smile: Wow, thanks for notifying me of the latest developments. So it turns out that Guava had indeed eventually agreed with what I wrote above, I guess, and switched to using `<optional>` rather than a scope of `provided`! That had made more sense to me. But I never knew about that, and nobody mentioned it on the numerous Stack Overflow discussions I mentioned above. Curious. So definitely thanks for alerting me to this.
Uri
String encode(T uri)
My thought was to choose a spec - let's say 3986 - and implement that for Guava. But factor things such that it'd be easy for clients to extend for other specs and schemes.
Ping?
æˆ‘æ˜¯å¦å¯ä»¥ç†è§£ä¸ºguawaä¸ä¼šæˆä¸ºç¬¬äºŒä¸ªJDKï¼Ÿ
> a deal breaker. Guava makes incompatible changes with each release, why is
> http://stackoverflow.com/search?q=%5Bguava%5D+is%3Aquestion+classnotfoundexception
Supporting extensibility appears important:
+1 for something like the Spring Enum mentioned above
I think that a full fledged class with static instances would work best, since it also has support for nonstandard status codes such as 429 Too Many Requests. Also, this way, it would also be able to store the status code and the associated message.
- Cards (JACK, QUEEN, KING, ACE)
+1 to Multitable
We'd really like a multitable, it is outrageous that there isn't one already.
Also: http://stackoverflow.com/questions/17057104/multimap-table-with-guava
@Override
@Override
I think this issue has become... outdated? What's the right word to use here?
I cannot find it on Guava (18)
out of curiosity, given java 6 has been eol'ed for almost 3 years, at what point does guava move on?
On Mar 6, 2015 6:45 PM, "Jae Gangemi" notifications@github.com wrote:
> point does guava move on?
what about a 'guava-extended' library that could offer this type of functionality for those using a newer jdk?
@kevinb9n Then maybe the active approach you described in the second comment is the most appropriate for Guava on JDK 6?
```java
```java
@Override
If I'm not lost in other considerations, I'll try to make this into a guava-like class and create a PR. Any remarks, comments is welcome.
Isn't the picosecond an argument anymore?
The issue is taken care of in https://github.com/diffplug/durian "Durian: Guava's spikier (unofficial) cousin".
(migrated from #1904)
@lukesandberg Happy New Year!
@vladdu interesting, but dont think it solves the OP issue
Guava tries to simplify some of the common cases,
therefore people assumed it's a search.
```java
Should this never be done in guava as Java 8 has exactly the duplicated API?
Many people use guava as a backfill of Java 8 functionality for Java 7-and-earlier projects (like Android).
I'm not sure about choosing the classes according to the result type, but there are already precedents in Guava (e.g., `factorial(int)`). Both methods are rather simple, but getting them wrong isn't too hard either.
Varargs or int/long streams arguments may be better. @Maaartinus With regards to `LongMath.sum(int[])`, I believe one can emulate it for now with both streams and Guava's help, like so. (I've not run this code example through a compiler, so it may need some tweaking, but I hope the idea comes across well.)
```java
```java
long MASK = 0xFFFFFFFFL;
low += x & MASK;
I struggled to name the new kind of Collection. I initially wanted to use "Ordering", but Guava already has something else with that name. I settled on "Chain" for now. I'm open to other name suggestions.
@kluever how about in 2017? :)
