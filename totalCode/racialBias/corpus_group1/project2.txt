  Sounds like a server issue.

Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Please see #2138.  Hi @liuqiyuan,

That looks correct. You can always print out the curl command to debug further.

```swift
let request = Alamofire.request("http://backend.com:8080/user", method: .get, parameters: parameters, encoding: JSONEncoding.default, headers: headers)
    .responseJSON { response in
        debugPrint(response)
    }

debugPrint(request)
```

If you continue to have issues, I'd suggest you open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Alamofire isn't doing anything here. What you're seeing is the debug printout of a Swift Dictionary, which is what you get when you print a `Result<Any>` from `responseJSON` when the JSON is a dictionary. The fact that the request was successful shows that the JSON came back properly.  @anishparajuli555 You've hit a rather prickly use case for us. Right now `validate()` is only intended for simple validation scenarios. As you've seen, it doesn't really work that well for validating something in the response data. In fact, that's a highly inefficient use of it, since the response data may then be decoded twice. At the moment I would suggest any validation you need to perform on the response data be done in a custom response serializer and not `validate`. In the future we'll be reevaluating `validate()`s capabilities and how it fits into Alamofire.  StackOverflow is the proper forum for this issue.  Thanks for the PR, but Alamofire is compatible with both Swift 3 and 4, so we don't need this setting. Also, in the future, please fill out the whole PR template. Thanks anyway!  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  I would suggest using a proxy tool like Charles Proxy to check what you're actually sending vs. what you're seeing in the server logs. We have extensive tests around this scenario so it's unlikely there's an issue within Alamofire. However, if your investigation does reveal an Alamofire bug, let us know and we can reopen this issue.  Thanks for the PR! Before we add another parameter encoding, can you point us to some documentation regarding this standard? To me it seems strange, but if it's already a standard I'd like to learn more.  
## What did you do?
I add Almofire to my project ,and call    
     Alamofire.request(<#T##url: URLConvertible##URLConvertible#>, method: <#T##HTTPMethod#>, parameters: <#T##Parameters?#>, encoding: <#T##ParameterEncoding#>, headers: <#T##HTTPHeaders?#>) and all correct after  I add  realm pod  
 "Extra  argument ''method" Call" error is appeared 
how to solve this problem ?

## Alamofire Environment

**Alamofire version:4.5
**Xcode version:8.2.1
**Swift version:3.1
**Platform(s) running Alamofire:**
**macOS version running Xcode: 10.12.5

  You don't seem to be using the `backgroundManager` you setup to actually download the file you want. Plus, for file downloads you should use the `download` API, not the `request` API. Also, be aware that Alamofire currently cancels all outstanding tasks when the manager is `deinit`d, which will happen if your app is killed in the background. If this occurs, you may want to set up your background downloads outside of Alamofire, as we don't currently handle that case well.  The `result` you get in the `multipartFormData` version of `upload` is not the result of the request but instead the result of the multipart encoding process, so it contains nothing about the network request yourself. If you want to detect the networking errors you need to do so in the `responseJSON` of the `upload` value you pull out of the `success` case.

In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Thanks for the PR! However, this is, in fact, functionally different, as it will return the same queue for each QoS level, not generate a new one like the original code. Since the intent here is to let the system manage what queues it gives us, this would fundamentally alter the behavior of this API. For that reason we won't be merging it. Cheers! :beers:  Swift 4 is supported by Alamofire 4.5.  Thanks for the PR! However, before we merge, it would be a good idea to make this encoding a little more elegant, as empty username or password fields aren't usually the best behavior in some scenarios. Can you look into how cURL handles various types of auth and how `URLCredential` conveys them and see if you can come up with a more general solution?  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Alamofire may be able to use `Encodable` types to help create requests. This will require some thought.  Alamofire should support both generic `Decodable` response parsing and specific `JSONDecoder` and `PropertyListDecoder` based response handlers.  Hi @Lves,

I'd suggest you open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Yeah great idea to modify it  Hi @Dschee,

I can say we are certainly planning on adding `Decodable` support to Alamofire 5, possibly even Alamofire 4. We haven't completed nailed that down yet. As for the `Encodable` support, that will take some more investigation. It gets quite complicated when considering different encoding types as well as query parameters vs. the http body.

Once we nail down some more specifics, we'll make sure to update this ticket.

Cheers. üçª @Dschee I've broken this up into `Decodable` and `Encodable` parts in #2180 and #2181 respectively. We can move discussion and other ideas to them. I've also created an Alamofire 5 project to track our design and implementation of new features for the next version.  Hi @ranlor,

Would you mind sending us a sample project that reproduces the issue? Looks like it's a leak from the system. Unfortunately that means there's nothing we can do about it. Good news is that the leaks appear to be gone under iOS 11. Thanks for the report! Cheers! :beers:  Your mobile developer should be able to answer those questions already. However, here are some high-level answers:
1. No, there is no automatic retry. That has to be implemented manually. A simple error is returned by the system, which Alamofire returns as part of the response closures in that case.
2. Alamofire wraps underlying errors returned from the `URLSession` networking layer provided by the system. It also produces a few convenience errors produced by, say, a failure to decode JSON that aren't covered by the system.
3. Our documentation is extensive. Check our [README](https://github.com/Alamofire/Alamofire/blob/master/README.md) as well as our inline documentation in the source code.
4. There's no such thing as "trapping" for iOS (or Swift in general). There is an extensive error handling section in our README that any developer using Alamofire should read. Alamofire provides a thin convenience wrapper over the network APIs provided by the system, as I said, and provides a `Result` type useful for asynchronous programming that encapsulates a the response state.

In general, while Alamofire provides a convenience wrapper around the system network APIs, as well as other tools to make it easy to follow best practices when making requests and handling responses, it's up to the individual developer to determine how it will integrate with their overall application. Poor handling of network responses will lead to poor app behavior no matter the networking library used. If you have any other questions about best practices in using Alamofire, let us know.  Hi @mafer-bc,

I'd suggest you open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others. Awesome!  Can you please provide full details including: versions of Xcode, Alamofire, Swift, CocoaPods, OS, etc? What platform are you trying to build against (iOS, macOS, tvOS, watchOS)? What version of iOS is the iPad running and which model of iPad is it? The more info you can provide us the better. Also, would it be possible for you to submit a sample project? Might help us narrow down the problem. This is a duplicate of #2164, please move any addition input to that issue.  Hi @goktugaral,

First off, I'd suggest you read through the entire [Security](https://github.com/Alamofire/Alamofire#security) section of the README. That should walk you through everything you need to know to get this up and running. If you still have questions afterwards, then I'd suggest you open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

If you do end up finding the documentation lacking after getting things working, please consider putting a pull request together to help those out in the future.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others. @dvertovsek Please stop replying to closed issues. If you have an issue you consider a bug, please file it separately and attach a test project for us to look at.  

Hi @TannerS,

- https://github.com/Alamofire/Alamofire#uploading-multipart-form-data

In the future, I'd suggest you open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  ?  This is really only useful for CocoaPods, who are still deciding what to do with Xcode 9. We'll update this file if needed, if we need to publish a Swift 4 version to CocoaPods. Thanks anyway! üçª   We've seen errors like this previous for Xcode 9 beta 1. Clear your derived data and try again. #2142 was similar. Re-opening @jshier...we'll need to dig in here a bit to see what's going on. @AtomicCat @crucibond Is this still an issue for you with Xcode 9 beta 2? After investigating this further, I can replicate it on a variety of project configurations. Manually integrated and CocoaPods integrated projects fail the same way, but only on tvOS. My test projects for iOS or macOS work fine. I suggest we all file bugs with Apple and attach a test project. I'm guessing something might be wrong with the Foundation framework on tvOS. @AtomicCat What is the issue number of the bug you filed? I'd like to duplicate it. I was successfully able to run my test project using Xcode 9 beta 3, so I believe this issue has been resolved @AtomicCat @crucibond.   Hi @pete183,

This is not currently possible, but is something we're looking to improve upon in Alamofire 5. For now, you'll need to create your own `URLEncoding` type that uses the delimiters you need.

Best of luck! üçª  I supplied an answer, but that question really has nothing to do with Alamofire.  Hi @kingxt,

You need to specify a destination on all platforms other than iOS. This is clearly called out in our [documentation](https://github.com/Alamofire/Alamofire#downloading-data-to-a-file). If you only want to get the data, then you should use `request` instead of `download`.

Cheers. üçª  Hi @santhoshs5,

You'll need to create your own custom `URLEncoding` type that encoded the array however you need.

Best of luck! üçª  Hi @stealdre,

I'd suggest you open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Thank you for all the detailed information here @couchdeveloper. After much deliberation, @jshier and I have decided to back out the change and have done so in fb76d834.

Thanks for the help! üçª  I'm not sure what you mean. This can be treated like any other request failure error if you want, or you can do some other custom logic. If you don't care that you're getting empty or nil data, you can either manually ignore the error in your response handler, or write your own `ResponseSerializer` that handles all of the errors just the way you want. Hi @HWSTS,

I'd suggest you open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  @Suksal If your server doesn't support download resumption, no `resumeData` will be saved. Also, not all failures can be resumed from, so your expectation is incorrect.  The Swift compiler still isn't the greatest when it comes to error diagnostics. I usually adopt a rule of "when it doubt, check the types", as type mismatches are the most common cause of bad diagnostics.  Make sure you're using the latest Xcode version with a clean environment, as this isn't an issue we see.  Thanks for the PR! However, we won't be merging it, as [RFC 7231, 6.3.2](https://tools.ietf.org/html/rfc7231#section-6.3.2) states that `Created` responses should contain the item(s) created, as simple best practice. We strive to support best practices where we can in Alamofire, so adding this code as an expected empty response isn't a good idea. Thanks though! :beers:  Thanks for taking the time to put this together @mayurdzk. We won't be merging this into the README though b/c we're planning on adding direct support for Xcode 9 much sooner. Therefore, we won't need separate CocoaPods instructions!

Thanks anyways! üçª  After some investigation, it appears that turning `POST` requests into `GET` requests for 301/302 responses is fairly standard behavior and something Apple handles at the core of their networking system. If you can, updating the backend service to return a 307 response should preserve the `POST` request. Otherwise, perhaps the backend can handle the load balancing internally and no expose it to the request? I suggest opening an issue with Apple if you'd like this default behavior. Otherwise you could try and recreate your `POST` request in the redirection delegate method you're already using, but Alamofire provides no support for such a thing.  Hi @bsarrazin, thank you for putting this together. Unfortunately, we're not going to be moving over to Fastlane or prebuilt frameworks right now. For more info, please refer to #383 and #588.  great  There is now an `xcode9` branch up that can build Alamofire for both Swift 3 and 4, so you can give it a try!  Hi @Arun30sep,

You need to encode the JSON as a body part to the multipart form data. I'd suggest you open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire` to get help with this. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Alamofire will never support synchronous methods. We have examples of uploading files in our documentation. 

In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Most likely you just need to clear your derived data. Otherwise, are you actually using the `stream` APIs through Alamofire or not?  @linqingmo Thanks! üçª 

@burakgunduztr At the moment we're not supporting Alamofire 4 under Swift 4. You should be able to use Alamofire 4 built using Swift 3.2 in a Swift 4 project. However, if you're using CocoaPods to integrate Alamofire, it likely doesn't handle the distinction yet. There is now an `xcode9` branch up that builds Alamofire 4.5 in a hybrid mode for Swift 3 and 4. Give it a try.   @ParanoiaWan @KarlZeo Alamofire builds under Xcode 9 beta 1 just fine in Swift 3.2 mode. In addition, you can use the Alamofire framework built in 3.2 mode in an app that builds using Swift 4, according to Apple, so a Swift 4 port isn't strictly necessary at the moment. If you really want to build Alamofire using Swift 4, the required source changes are very minor. We'll be announcing our future plans soon!

@Vinzius Thanks! üçª   A brief investigation indicates that this crash may be caused by a `nil` value for the `Data` passed into the delegate method. Then, when it tries to bridge the `NSData?` to `Data`, it crashes because of the `nil` value. Just speculation right now. @blixt Do you happen to know what requests are causing this? Or is it all requests for your app? Perhaps you're getting nil data back from the server somehow? No, this is a bridging issue from the Objective-C code of `URLSession` and Swift. As you can see, it's apparently trying to bridge an `NSData?` to `Data`, which will never work if the value is `nil`. Either they have an underlying bug that's returning `nil` when it shouldn't, or they need to update the bridging of this API. Please file a bug with Apple (and post the Radar number) and / or Swift (and post the SR link) so we can get them to look at it. In the meantime we'll see if there's anything we can do to prevent this. No, as you can see in the crash log, it's due to bridging from Objective-C to Swift with an unexpected `nil` value. I spoke with a `URLSession` engineer at WWDC and he said it was likely an underlying bug where `URLSession` was returning `nil` unexpectedly. 

@bhaveshbc @gneil90 @ibarisic05 To that end, please file bugs with Apple and post the numbers here so that we can file a bug for Alamofire itself and cite all of your bugs. That way we have the best chance possible to get Apple to fix it.  @blixt I'm not sure what gave you the impression that we didn't investigate this, but we have. The crash log is clear and the response from the Apple engineer was as well. Given the irregular nature of this bug, it's not really surprising that you're only seeing it for certain requests. Without a reproducible test case, it's difficult for us to investigate this beyond the crash reports from others. However, we are continuing to look at it, which is why I've left the issue open.

If anyone else is seeing this crash, posting a crash log and attempting to create a reduced test case would help a lot with our investigation as well as reporting the bug to Apple. It is, and it would be helpful to Apple as well, so be sure to add it to your bug report. Do you have any iOS 9 crashes (do you support it?)? Also, it's good that this shows up on iOS 11, as Apple may actually fix it then. @blixt For any of your sessions, do you change the number of simultaneous connections at all? Any idea how big the responses might be? I'm trying to setup a test app that executes many requests in parallel, so I'd like to match your behavior. @blixt Thanks. Do the crashes seem limited to any particular devices or other unique configuration? @gneil90 
I'm... surprised that works. I thought I had tried it before but got a compiler error. Now if only there was a way to disable that warning...  Sorry, there's not a lot we can do to debug your CI setup.  We use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  That's Swift 2 code, so please update. Double check your closure types as well.

In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Hi @AniOSDeveloper,

We do not have any examples that use the stream APIs. I'd suggest you open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. You may also have some luck googling around on Stack Overflow directly.

Best of luck! üçª  Thanks for the PR! However, we're not going to merge it. As you said, there is no real standard for URL encoded collections, so adding levers to for every possible encoding is unfeasible. Creating your own encoding that does this is straightforward, and we'll look into enhancing `URLEncoding` in the future so that this sort of customization is easier.  Hi @EJSohn,

Thank you for putting this change together...much appreciated! üçª

Unfortunately, we will not be accepting this change into Alamofire for a couple reasons. First off, it doesn't work. You can only modify the `URLSessionConfiguration` before it is applied to a `URLSession`. After it has been set, the mutation of it no longer applies.

Additionally, we want to keep the top-level APIs as lightweight as possible. We don't want to introduce any new parameters into those APIs unless absolutely necessary. Instead of adding a timeout property, you should either set it on the `URLSessionConfiguration` when you are setting it up, or you should set the value directly on the `URLRequest` and use the `Alamofire.request(urlRequest)` API.

Cheers. üçª  Hi @c204303,

> 1. How do I solve this?

I'd suggest you open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests. I'd also suggest you add more detail to the question you ask. Right now you haven't posted much more than it used to work, and now it doesn't. It's pretty unlikely that anyone will want to, or be able to help you troubleshoot such little information.

> 2. Is it possible to use Alamofire 3 with Swift 3.

No it is not.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Hi @howaisi,

Most likely the issue is that you've misspelled `parameter`. It should be `parameters` instead. In the future, I'd suggest you open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Thanks for the PR! This looks like a nice little cleanup! Cheers! üçª   Thanks for the PR! However, we won't be merging it, as responses are unnecessary for our README and distract from the actual content.   Check out our [Security section](https://github.com/Alamofire/Alamofire#security) in our README for info about customizing your security settings.

In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  That curl option uses the `Range` HTTP header to request a range of bytes from the server. You can add the header to your requests yourself but Alamofire provides no direct support for it, as it's rare to need to request specific byte ranges. 

In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Yes, you'll need to properly encode Korean characters for the URL. I suggest you review their [documentation](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/URLLoadingSystem/WorkingwithURLEncoding/WorkingwithURLEncoding.html) on the subject. 

In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  All UIKit operations must be performed on the main queue, so your `reloadData()` call should be inside `DispatchQueue.main`, not `.global()`.

In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Overriding the `ServerTrustPolicy` is something that only needs to be done rarely and shouldn't be done at all without considered thought. In addition, we try to keep our top level APIs limited to the most common cases so it doesn't grow too far out of hand. This API is best where it is now.  That closure is strictly used for the successful read of data from a request. It's not intended to do any error handling. We'll be reevaluating our closure and stream APIs for Alamofire 5.  Your issue is likely the fact that `URLCache` doesn't have a functional empty initializer, so `URLCache()` returns a cache that can't actually store anything. I suggest you initialize it the documented initializer.

In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Yes, that's a bug that will be fixed as part of our 4.5 release.  @d0ye Changes to the `configuration` of an already initialized `URLSession` have no effect, per Apple's documentation. If you want a custom timeout, either set the value on your requests, or create a custom `URLSession` with a custom configuration, as outlined in [our documentation](https://github.com/Alamofire/Alamofire#session-manager).

In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Sorry, we're not responsible for Xcode's autocomplete issues. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  You'll need to provide us with more details for us to do anything here. What version of Xcode, Alamofire, and OS are you running this on? What is the content of the exception that was thrown there? Hi @OldCrab,

There's not enough info to go on here. We'll need a sample project that can demonstrate the issue and then we'll happily look into it further. I'm going to close this issue out until we get enough info to action an investigation or a sample project.

Cheers. üçª  Thanks for putting this together @Lutzifer! üçª  Hi @HuangWei201703,

Your URL string needs to conform to RFC 2396, otherwise Apple will not instantiate it. If you provided that URL directly, then you need to percent escape the query string values when it includes unicode characters. In the future, I'd suggest you open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  This is exactly what our `ResponseSerializer` protocol and various `*ResponseSerializer` types are for. Please read our [documentation](https://github.com/Alamofire/Alamofire#custom-response-serialization) which outlines how to write a custom response serializer. I also have a [gist](https://gist.github.com/jshier/f356bfb5b6dc634b67b14ddb75bd7279) I wrote which is the generic response serializer I wrote which wraps Argo, for generic type serialization.  If the certificate was pushed to the device and accepted by the user, it should be part of the default evaluation chain automatically, so Alamofire shouldn't need to do anything. Is that not the case? Note that iOS 10.3 changed the way certificates are accepted by users, so you'll need to make sure it's active. We do not have direct support for client certificates in Alamofire at this time. You have a couple options. The first is to set the `taskDidReceiveChallenge` override closure while the other would be to subclass the `SessionDelegate` and override the task challenge API.

Once you've done that, you'll need to check for if the challenge's protection space auth method is `NSURLAuthenticationMethodClientCertificate`. If it is, then you'll need to build a `URLCredential` from your certificate and pass that off to the completion handler. This [thread](https://stackoverflow.com/questions/40335827/client-certificate-and-nsurlsession) walks you through the basics.

Best of luck! üçª  As you saw, validation handlers aren't intended to be used outside of the `request.validate().response()` chain. If you want custom validation once you've processed a response, creating a custom response serializer and / or using a `RequestRetrier` will accomplish what you want much more easily. We'll work on updating the documentation to reflect this fact.  Thanks @mtrudel! üçª  You'll need to ensure you're properly linking the Alamofire framework into your project. Or use a dependency manager.

In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  For now you'd be limited to `ServerTrustPolicy.customEvaluation((_ serverTrust: SecTrust, _ host: String) -> Bool)` case, as you'd be able to use the TrustKit APIs in that closure. We hope to redesign these APIs for Alamofire 5, both to increase their capabilities and abstract them away enough to work on Linux.

In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Thanks for the PR!  Hi @agnosticdev,

IMO, the jumpbar is pretty clear as to the separation by simply reading the names of the test cases. The MARKs are added to make it easier to read the jumpbar quickly. Is that not sufficient? We've used that approach in many places throughout the tests to split them up. The MARKs you've added here really just duplicate what's already in the name of the test case. I'd also argue that if we were to make such an addition, we'd need to make it throughout the test suite for consistency.

On a different note, we're going to be restructuring the entire test suite at some point in the near future. When we do that, we'll certainly take a pass at making the test case names as clear as possible and using MARKs where applicable.

Thanks anyways. üçª  Closing this issue out in favor of #2091.  Unfortunately that error comes from the underlying security library we use for the various SSL utilities, so there really isn't anything we can do to improve it ourselves. What we may be able to do is wrap it in higher level error so there's a bit more information available to you. 

Development of Alamofire 5 hasn't started yet. In the meantime I suggest you add handling for that particular error if you need a special error message.   Thanks for the PR! However, we don't support Objective-C interop in this library, so why would we want this? Secondly, if we were to do this for one error type, it seems like we should do it for all of them.  Without a strong case for why this needs to be done, I'm going to decline this PR. Thanks anyway!  Latest Carthage is 0.20.1. You should probably update.

Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  From looking around, it seems that issue popped up again in iOS 10.3. There doesn't seem to be a workaround. File a bug with Apple mentioning your error.

In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  From Apple's documentation, you will only get resumption if:
```
A download can be resumed only if the following conditions are met:

The resource has not changed since you first requested it

The task is an HTTP or HTTPS GET request

The server provides either the ETag or Last-Modified header (or both) in its response

The server supports byte-range requests

The temporary file hasn‚Äôt been deleted by the system in response to disk space pressure
```

As for killing the app, I'm not sure why you'd expect anything different. When you kill the app the system doesn't have a chance to prepare your resume data, as downloads occur in a temporary area and are then moved when the download is complete.  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Thanks for the example project. I'll give it a shot on my iPhone 4S. One immediate issue is your use of `responseData`, which will read the entire contents of the file into memory. A bad idea on low memory devices. So the crash isn't on file move but during file read into memory. That's why you see the file moved when you relaunch. Yeah, I'm getting a crash with:
```
Downloader(198,0x1f421000) malloc: *** mach_vm_map(size=888762368) failed (error code=3)
*** error: can't allocate region
*** set a breakpoint in malloc_error_break to debug
```
which is an allocation failure. I'll try again without the `responseData` usage and see if it makes a difference. I think it will. Yes, using just `response` let the download complete successfully. We'll look into if there's anything we can do to make `responseData` safer for downloads, but ultimately it's up to developers to make sure they don't try to allocate an inordinate amount of memory at once.  Thanks for the PR!  Hi @MMizogaki, thank you for taking the time to put this together...much appreciated! üçª I made a few modifications to your PR and pushed them up in a356cc24 while maintaining your attribution. These changes will go out as part of the AF 4.5 release.

Thanks again! üçª  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  It supports Swift 3.1 right now.   Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  I suggest you look at what you're actually getting and check the differences between your Postman request and the one you're making from code.

In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Thanks for the report! @cnoon, any clarity here? Hi @GaryDUK,

The server should not be redirecting on a `POST` or `PUT` for security reasons. Please see #2149 for more information.

Cheers. üçª  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Hi @ericdesa,

Thanks for putting this change together...much appreciated! This will be part of the AF 4.5 release shortly.

Thanks again! üçª  Hi @webmaster128, thank you for putting this change together! üçª

After some debate, we've decided to accept this PR and use `curl -v` moving forward. If anyone finds it to be a bit much, then you can always switch back to `curl -i` when pasting back into terminal.

Thanks again!  Hi @fanglichun,

You must provide a [download destination](https://github.com/Alamofire/Alamofire#download-file-destination) on iOS if you are trying to download the image to a file. If you just need the image data, then switch over to the `Alamofire.request` API instead.

In the future, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Hi @megifernanda,

I'd suggest you open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Hi @rajeshsonu,

I'd suggest you rebuild your `upload` call here again using Xcode's autocomplete functionality. Just plug in each closure one-by-one. You can also use our [test suite](https://github.com/Alamofire/Alamofire/blob/master/Tests/UploadTests.swift#L240-L690) for reference as to what could be wrong.

In the future, I'd suggest you open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Thanks for the report! However, I can find no documentation in [RFC 7231](https://tools.ietf.org/html/rfc7231#section-5.3.5) that officially states these combinations. Can you point us to any? Otherwise it seems likely we'd need maintain a static map of possible combinations to acceptable ones, which isn't likely something we want to do. Hi @simonliotier,

Thank your detailed report here...much appreciated. What we all need to keep in mind is that while your use case does not want to receive `fr-US`, others may. You can always convert `fr-US` to `fr-FR` on the server side to do a proper mapping, but you'd never know how to reverse `fr-FR` to what the user actually has their locale set to which is `fr-US`.

Alamofire only sets the `Accept-Language` by default, but you're more than welcome to override it for your particular use case. I don't feel that it would be correct for us to try and make the user's locale more generic.

Cheers. üçª  If the underlying `URLSessionUploadTask` never produces an error Alamofire will never return one. Are you perhaps using a background session? That will give you different error responses than a foreground session.

In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Alamofire requires no changes to build without warnings under Swift 3.1.  Using the Router pattern from our documentation it's trivially easy to set timeout values on a per-request basis. This should allow you to set a reasonable timeout for a given request while keeping all others at the 45s default. Otherwise you can check the particular error returned to see whether its a timeout or a response error. 

We use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  No problem, it's a Travis issue (still). @MarcoSantarossa We're still reviewing changes for our 4.5 release, we'll likely review and merge soon. Thanks for putting this together @MarcoSantarossa...much appreciated! üçª I've made a few small tweaks to your PR and have pushed it into `master` in 68f4eb3f while maintaining your attribution. This change will go out shortly in the AF 4.5 release.

Thanks again!   Thanks for putting this together @dusek...much appreciated! üçª  #2025 has been merged. Apparently `httpbin.org` made this change on their side.  It's likely you're blocking the main queue in some way, but there's no way to know without some code to looks at. If you can post the code that causes this issue, we can take a look. A sample project would be even better.  Alamofire fully supports IPv6, just like the underlying frameworks. When this comes up it's usually something along the lines of 1) a reachability check performed before requests failing, which is an antipattern and should be removed, 2) misconfiguration of the reachability API (make sure to use just your domain name, no scheme), or 3) the API endpoints you're talking to not supporting IPv6 themselves. Also, AFAIK, there are no changes in this regard for iOS 10.3.


In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Thanks for the report! We'll take a look! A PR would be great! Closing this issue out in favor of #2060. Please direct all further comments to #2060. üçª  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  @Silvering You'll need to rebuild all of your dependencies and your app with the latest version of Xcode so that all of the built frameworks are using the same version. How to do so depends on how you integrate Alamofire.

In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Even with Photos permissions you can't directly access files outside of your sandbox.

Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  In my view this is redundant, as JSON is, by definition, already UTF-8. Using it with any other encoding is non-standard and not supported by Alamofire or the underlying `JSONSerialization` API it uses for JSON. @cnoon, what do you think? Thanks for putting this together @2h4u! 

I agree that this should be added since JSON defaults to UTF-8, but can also be encoded in UTF-16 and UTF-32. There are some good details in this [thread](http://stackoverflow.com/a/9254967/1342462) and you can also check out [RFC 7158 - Section 8.1](https://tools.ietf.org/html/rfc7158#section-8.1) for more info.

I've made some additional changes to your PR @2h4u and pushed them into `master` in c8700ac7 while maintaining your attribution. This change will ship in the next release.

Thanks again! üçª @cnoon From RFC 7158:
```
Note:  No "charset" parameter is defined for this registration.
           Adding one really has no effect on compliant recipients.
```
As mentioned in the SO thread you linked, servers interested in supporting UTF-16 or -32 can just check the first four bytes of the response to determine both the encoding and endianness (which can be either big or little), or any other standard algorithm for the same result.

So it still seems redundant. Just as a heads up here, after much deliberation, @jshier and I have decide to revert this addition from the AF 4.5 release. I just pushed up the reverted commit into `master` in fb76d834. The main reasoning is that the `charset` parameter is not defined and there are already ways described in detail in the links posted on this thread on how to determine the encoding.

Thanks everyone for all their help on this particular issue. Cheers. üçª Also, please refer to the write-up in #2157 for more info.  You can't do this with a single request unless your server wraps up directory contents into a single file for your automatically. You'll have to get the directory contents and download each file individually or perhaps come up with a solution on the server.

We use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Looks like this was taken care of #2031. Thanks anyway! Cheers! üçª   Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  @ryanzl @LaurentiuUngur Can you both please post the code that causes this leak? Better yet, please post sample projects which replicate these leaks so we can investigate. @Afsarunnisa Those `_NativeDictionaryStorageImpl` leaks are from the underlying Swift libraries themselves, and are fixed in Xcode 8.3 / Swift 3.1.

@ryanzl @LaurentiuUngur If you could retest using Xcode 8.3, we can see if any of the leaks were underlying issues or false positives fixed in the new version. If they do appear, please upload a project that replicates the leaks you see and we'll look into it. Thanks for confirming @ryanzl...I'm going to go ahead and close this issue out for now. Please feel free to add additional info if you continue to see issues on Xcode 8.3 and we'll happily re-open and investigate further.

Cheers. üçª  Rather than doing this strictly at the `Request` (or subclasses level), I'd do it at the `URLRequest` level. That, combined with a router (perhaps a `pagedResults` route), should be able to give you the sequence of `URLRequests) needed to get all of the pages. Making them sequentially using the standard Alamofire APIs should be pretty straightforward after that.

We use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Thanks for the report! Yes, you must be careful when using background sessions, as Alamofire doesn't currently do any validation of usage for background vs. foreground sessions. We'll be reevaluating background `URLSession` usage through Alamofire in the future.  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others. Mostly likely you need to follow our documentation regarding how to customize the headers sent in the request. Neither of the methods implements in the original post would work how you'd expect. Besides which, the easiest way to see what could be wrong is to use a proxy tool like Charles Proxy to intercept your requests and see exactly what they look like.  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Thanks for the PR! Good catch! Cheers! :beers:  Looks like this was taken care of by #2031. Thanks anyway! Cheers! üçª   Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  The `response.response?.statusCode` is the HTTP status code in the response. If you never receive a response it will be `nil`.

We use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Update to Alamofire 4 and these APIs are much safer. Otherwise ensure your URL is properly encoded before attempting to request it.

We use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  No, you don't need to set a delay.

We use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Response handlers are called on the main queue as a convenience, as the most common usage is updating UI or view controller state, which needs to be on the main queue. If you don't want that behavior, you can pass a queue to `response` which is used to dispatch your completion handler and manually call back to the main queue if necessary. All other Alamofire work is already on background queues, per best practice.

As for your tests, I suggest using [`XCTest`'s asynchronous capabilities](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/testing_with_xcode/chapters/04-writing_tests.html) to properly test it, rather than using manual group management. `XCTest`'s asynchronous testing works fine with Alamofire, as that's what we use to write our own tests.

The `Timeline` behavior is intentional, as performing work in the completion handler is considered part of serialization process. We'll be reevaluating these APIs for Alamofire 5, so we may be able to change something then.  There is no direct conversion for such a setting. It depends on what you're actually trying to do. I suggest you evaluate your requirements and go through [our parameter encoding documentation](https://github.com/Alamofire/Alamofire#parameter-encoding) and see where your requirements can be met. You may need a custom parameter encoding, depending on your particular situation.

In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  There is nothing in Alamofire that treats different cell networks any differently. Also, your parameters are both redundant, as those are the default values, and wouldn't work in the first place, as the `URLSessionConfiguration`s can't be modified once they're part of a `URLSession`.

We use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Can you be more specific? There are some known leaks that show up that are false positives (some of which are fixed in Xcode 8.3 / Swift 3.1), but unless you provide a detailed report there's nothing we can do here. What versions of Xcode, Swift, and OS are you using? Can you post the leak report? I'm closing this issue for now. If you can provide some documentation for this issue, I'll gladly reopen it.  There isn't much for us to do here. Make sure your optimization and SDK levels match and you're using the latest Xcode and Alamofire versions. If you can create a test project that reliably replicates the issue we may be able to investigate further. Otherwise this looks like a low level issue from Apple's side. I'm closing this report for now, but please comment with a test project if you get this to reliably reproduce.  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Looks like you got it fixed in the Moya issue. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Unfortunately Alamofire relies on the underlying system frameworks to return these errors. If the error contains no additional information there isn't much we can do about it. Also, this is the only error Alamofire sees on failure as well, so to add more information we'd have to implement all of the same validation we rely on the underlying frameworks for ourselves. Obviously that's a bad idea, so I don't think there's much we can do here. Feel free to open another issue if you find something specific we can implement to help. Cheers! üçª   Thanks for the report. I agree that should be something that handled more elegantly, as it makes sense to me that an attempt to pin to certificates from the app bundle should expect at least one certificate. We'll be refactoring `ServerTrustPolicy` for Alamofire 5 and should be able to make such a change then.  @cnoon Can you look into this? Hi @reitzig,

Thank you for putting this issue together. I agree with you that this is an unfortunate requirement. We will be relaxing this rule in AF5 since it cannot be done in a backwards compatible way right now. We've added the issue to our Trello backlog and will be fixed in AF5 which will ship roughly in October 2017.

> Until then, you'll need to subclass and implement your own solution as a workaround.

Cheers. üçª  `Default*Response` and `*Response` are not related because they're just different enough to not be the same type while we didn't want to make them class types, so as to keep the value semantics.

We'll be taking another look at response handling for Alamofire 5. In the mean time it looks like your protocol should be pretty easy to implement yourself.
 We may make them visible once actually start Alamofire 5 planning and development.  We'll take it into consideration. However, given the lack of support from `URLSession` directly and the mismatch with how most developers use Alamofire, it will be low priority.  I'm not sure why you block the main thread like that when `XCTest` has asynchronous waits, but it's fairly well known that you shouldn't block the main queue. Using `sync` there is even more dangerous for production code. If anything ever calls that code using `sync` as well you'll get a deadlock. I suggest you update your testing code to use expectations and waits. 

In any case, we'll be reevaluating the various queue usage and the `MultipartFormData` APIs for Alamofire 5. The queue you reference there is the background queue used internally by Alamofire, so it can never be the main queue. So while there's a risk of deadlock if we were to sync back to it from within the closure, it's easy to see it isn't, as we have visibility into our of our usage of that queue.   Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  @davidseek You need to setup your `URLSessionConfiguration` by creating a new instance. Modifying values on the current configuration doesn't have any effect, as per Apple's documentation. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  There's is nothing built into Alamofire to do this. Also, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  There doesn't seem to be anything Alamofire related here. I will say that having JSON body data in `.get` requests can cause issues in some servers, so make sure you're properly creating the requests you need.

Otherwise, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Yes, this is a known false positive. If the declaration of the `NSLock` is moved to the top of the `SessionManager` file, I've heard that "fixes" the leak. I also believe this false positive is fixed in Xcode 8.3 / Swift 3.1, which will hopefully be released soon. But you can take a look at that in the meantime. We've already filed a radar for this issue @xmollv and it was closed out as a duplicate.  Aside from the occasional warning against casting optional parameters to `Any`, it works just fine to pass optional values in `Parameters`. However, you're right, it should likely be an actual optional value there. However, such a change wouldn't be backward compatible with current use and so will have to wait until Alamofire 5. I've added it to our backlog for that work. Thanks.  Thanks for the PR! Looks good! Cheers! üçª   Thanks for the PR! While this could just be a change to `var`, preserving `let` semantics is better. Cheers! üçª   How big of a file are you downloading? Is it happening only on certain devices or all of them? What versions of iOS, Alamofire, and Swift are you using? I've been able to successfully test large file downloads using a background `SessionManager`. Your issue may stem from your `responseData` usage, as doing so reads the entire downloaded file into memory, which may cause a failure to read it from disk. Using `response` instead, and checking if the `DefaultDownloadResponse`'s error is `nil` will let you take action when the download completes without attempting the read the file into memory.

A few things to note:

1. Alamofire doesn't reconnect to your background session if your app is killed, so you'll lose track of progress and the `response` handler. You'll need to handle that yourself.

2. Your `timeoutInterval*` properties aren't doing what you think they are. Timeouts are only used for the time between server responses, not for the total duration of the download. Keeping those at the default values should work fine.

3. Checking for reachability before making a request is an anti pattern and Apple specifically says not to do it.  Thanks for the PR! Looks good! Cheers! üçª   Thanks for the PR! A nice little change. Cheers! üçª   You can create a custom `ParamterEncoding` that's similar to `URLEncoding` but encodes parameters using whatever method you want. Our documentation [outlines how to proceed](https://github.com/Alamofire/Alamofire#custom-encoding).  Thanks for the report! You're saying that, even if the cert has been installed and trusted on device that SSL connections won't work? I hope that's a bug, otherwise tools like Charles won't work without ATS workarounds. @rsaeks Thanks for keeping on top of this. I'm closing now that the issue seems to have been resolved. Please let us know if anything changes.  If you haven't noticed yet, Xcode's Swift support breaks a lot, leading to issues with syntax highlighting and autocompletion. I suggest you clear your projects Derived Data and start clean.

Also, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Thanks for the PR! However, we won't be landing it, as the types are unnecessary. However, it did prompt me to fix another issue, which as fixed in #2058. Thanks! üçª   `.authenticate` is meant as a response authentication mechanism and is not part of the request chain. Most header authentication is not intended to be used that way. Plus, there are several different header authentication methods available to users, with no real good default implementation. So there's really no way for this suggestion to work well. However, we will reexamine the authentication flow in both cases for future versions of Alamofire.  Hi @LupoDiRoma,

First off, thanks for filing an issue on Stack Overflow. Next time please post a link if you end up having to open the issue on our GitHub project.

Overall, there's nothing in Alamofire that is causing the delay you're seeing. We have 1000s of apps shipping with Alamofire that do not have this problem that fire many requests at app launch or foreground event. We've also seen this type of issue filed before, and it always ends up being something in the client implementation that is a bit off.

The only thing I can see in your code sample here that seems a bit odd is that you're calling `resume` on your `task` which is technically the `request` vended by the session manager. Did you purposefully set `startRequestsImmediately` to `false` on your session manager? If yes, then the `resume` call is necessary, if not, then you should remove it. I don't think this is part of your problem, but I noticed it and thought I'd point it out for you.

Other than that, I'd suggest you remove portions of your app to simplify the use case as much as possible, or create a separate test app that just calls your login functionality to isolate what the delay could be caused by. I know this is quite a bit of work, but it's sometimes necessary to figure out what the underlying issue actually is.

Best of luck! üçª  Hi @TofPlay,

This type of feature does not exist in the core Alamofire library. In AlamofireImage, we have the concept of a reordering queue allowing you to specify whether the queue has LIFO or FIFO behavior. You could very easily extend this queue to support priorities as well. Now monitoring bandwidth limitations would be a bit trickier but could also be done. You'd need to specify the allowed bandwidth on a request, then monitor the returned content size and cancel the request if it gets too large. You could look at the `stream` implementation on `Request` to get an idea of how this could be done.

Best of luck! üçª  Good catch here @pbartolome...thanks for putting this together! üçª  Answered on Stack Overflow.  Other than suggesting you create a custom singleton instance of `SessionManager`, as outlined in our docs, rather than modifying the default, there isn't a lot of Alamofire here. Perhaps you'd have better luck asking this question on  [Stack Overflow](https://stackoverflow.com) and tagging `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  FYI, this can be set at the `URLSessionConfiguration` level, though I don't know how useful it would be with a typical RESTful backend.  @cnoon Perhaps you can answer this? Hi @reitzig,

Great question here as there is tons of complexity around streaming big chunks of data up to a server. 

To start off, how do you envision the `OutputStream.write` method to work if it doesn't write to RAM or to the file system? I don't see how that's possible offhand, but maybe I'm missing something obvious. To be able to convert all the body parts into an output stream, you actually have to write the data into the output stream which is either going to be loaded into memory (RAM in a buffer) or written out to disk.

Now as for directly streaming the data from multiple body parts from various locations (file, in-memory, input stream, etc.) one could create a subclassed `InputStream` that reads data on-the-fly from the `MultipartFormData` object. This is the approach that was used in AFNetworking. This approach is a very hacked together solution that barely works in AFNetworking. When we went to try to build a similar type of approach in Swift, `NSInputStream` couldn't even be subclassed as it through compiler errors. I believe that issue has since been resolved, but the complexity around the low level bridging required is something that we decided to avoid at the time and couldn't even implement if we wanted. After Mattt and I had a very long conversation about it, we both decided it was best to try to use an in-memory solution for small payloads and move to an on-disk solution for larger ones.

Now that I believe you can actually subclass `InputStream`, it should be possible to create a `MultipartFormDataStream` or something like that that subclasses `InputStream` and reads the data on-the-fly for each read. This is something that I haven't had time to investigate myself but would be awesome to have in Alamofire. I think it would probably be as simple as adding a `stream` or `inputStream` property to the `MultipartFormData` object that vended the custom subclassed stream with all the appropriate implementation. If you wanted to take this one I think it would be a really good addition. If not, then at least you have the history of why the feature is currently designed as it is.

Just let me know what you think here @reitzig. I'd be happy to help try and guide you through the implementation more in-depth if necessary, but I don't have time right now to build out the feature myself. I'm going to leave this issue open for a few days for you to get back to us with your thoughts and we'll decide from there.

Cheers. üçª Hi @reitzig,

I'm going to close this issue out for now. If you're still interested in reviving this effort, please feel free to open a PR.

Cheers. üçª  Also, reading the code of the library itself can go a long way to filling in any misunderstanding or confusion you may have from the documentation. 

Like the compiler (and the documentation) says, using `upload(data, string)` isn't going to work, not least of which is because you need the `to` label for the destination. `upload(data, to: "https://httpbin.org/post")` works just fine.

For typical REST usage, `request` is what you need. Something like `request("https://httpbin.org/post, method: .post, parameters: parameters, encoding: JSONEncoding.default)` will work just fine. 

If you have actual examples of inaccurate documentation, feel free to open a new issue pointing it out specifically.  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Can you upload a sample project that replicates this leak? Also, what version of Xcode and what OS are you seeing this on?  There's nothing immediately obvious that's causing a crash, but from the stack it's probably in your retrier, as I assume you're doing some sort of auth handling there. But from your code I have a few recommendations:
1. Don't modify the default `SessionManager` every time you make a request. Create a new `SessionManager` in a singleton or the like and use that customized instance for every request to your API. This should prevent a lot of configuration and `URLSession` churn when making requests. The `default` `SessionManager` isn't really designed to be used like this.
2. I'm not sure what you're trying do with your timeout handling, but calling `invalidateAndCancel()` on the default `session` isn't necessary for anything. Once the `SessionManager` is `deinit`'d it will cancel anything outstanding for you, not that that's usually necessary.
3. Your error handling in general can be simplified down to creating your `errorMessage`, nothing else you're doing there is adding anything.
4. I'm not sure why you're using a `responseObject` method there when you're not creating a generic return type from the JSON. Take another look at our documentation to see how much more useful a generic `response` method is over just returning the JSON from the response. I'm not entirely sure why you're seeing that crash. If you're using an adapter / retrier, that's one possible avenue as @jshier mentioned. If you're not, then I would assume it's something odd to do with the challenge being answered after the request has already timed out.

I think a different question to answer here is how are you authenticating against Kerberos? I don't see any auth logic in your code sample. Possibly one approach would be rather than waiting for the request to issue a challenge, you could require the user to enter their credentials before issuing the request at all. Anyways, trying to think outside the box a bit.

I'm going to go ahead and close this issue out. If you comment back with more info that warrants additional investigation from @jshier or myself, we'll happily re-open and continue.

Best of luck! üçª  By default Alamofire doesn't do any determination of success or failure by response code, due to the huge variety of desired behavior there. You can either put such logic in your custom response serializer, if you write one, or add a `validate()` call to your request chain.  Alamofire defaults to this behavior to allow developers the flexibility of adding whatever sort of behavior they want for different error codes, as a single default behavior may not be wanted or desired by everybody. It also forces the developer to handle such situations in the way that's most appropriate for their app. If you want such a behavior our documentation outlines how to do it.  This isn't an Alamofire issue, we're just the first framework alphabetically. 

In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  @adasoft-dev Well, first of all, you're not even trying to encode your parameters correctly, so it's not surprising your Alamofire request doesn't work. I suggest you review our various `ParameterEncoding` types to see if any would work for you. Second, the various parameters types supported by Alamofire by default are there because they're most common, not as an exhaustive list of possible types. If you need to move beyond them, generating your own request, like you've done, and using Alamofire to issue is directly support. Also, generating requests using the router pattern, or creating your own parameter encoding are both outlined in our documentation.  Hi @vietstone,

Thanks for putting this PR together...much appreciated! With that said, I don't really see the use in duplicating the entire task state at the request level. Could you speak to that a bit? I think we'd all need a really good reason to justify adding this logic into Alamofire when you could simply use `request.task.state` instead.

I'm going to decline this PR for now. If you have a good justification for this and we decide to re-open the PR, then we'll need documentation and tests before we merge the PR in.

Thanks again! üçª  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  This is tracked in #1896.  I suggest you reference Apple's documentation.  why are you using: self.apiserver.alamoFireManager! instead of importing Alamofire and using 
Alamofire.download.  I suspect its this manager class that you have created that is causing the extra complexity, instead of saving time.  Error messages like this usually mean that there's a type mismatch in the function being called, whether in parameter types or attributes like `@escaping`.

 In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  [Removed due to resolution in Swift] Hi @AliTariqPL - it was down to the way the api was taking the url query parameters for me.  The easiest way is to print out the request url before its called and run it through a browser/ Rest client to surface the problem.  
  Hiya- its not really clear, can you share an example/ simple project to demo the issue?
 @XueChenChen This code has changed in Alamofire 4, I suggest you update. There's also better error handling around request generation as well in that version.   `upload` is intended for file upload, you don't need to use it otherwise. Your initial function call was also generally incorrect. That's an example of using `upload` with a `.post` method type. You can use the same method just fine with `request`, as our documentation shows. `upload` and `download` are intended for files, not general REST usage.  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  AFAIK, CocoaPods still doesn't support framework dependencies for framework targets. You could try importing your framework into your app as a development pod, I've seen it work that way.  I would try change to change your Json object to single quotes - and also unwrap the image data in case thats causing issues
 Error 3840 means that the response wasn't proper JSON, so you need to investigate that further.

Also, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Hi @djmadcat,

Thanks for putting this PR together...much appreciated! Unfortunately though, we won't be accepting this set of changes at this time. The `@escaping` was left out of the property declarations on purpose because closures captured as properties are `@escaping` by default. As far as I can tell, `@escaping` and `@nonescaping` should only be used in function parameter declarations.

If you could point us to some documentation that states otherwise, then we'll be happy to reconsider this change.

Thanks anyways! üçª Now that's what I call a justification @djmadcat! I really appreciate the thoroughness of that reply, not to mention I learned a thing or two along the way...much appreciated. üçª  Like @NikKovIos said, you can access the response data from the request's delegate. You'll need to run your decoding again, potentially, but it should be easy, especially if you've already separated your custom parsing into your own `ResponseSerializer`. 

We'll look into enhancements for `RequestRetrier` for the future.  Yes, you should not have the scheme on the string you're checking for reachability.  I've seen leaks like this before, they're usually a false positive or something from the underlying Swift standard library, so there's a not a lot we can do about it. It will likely be fixed in a future version of the tools.  This is a false positive. Every `SessionManager` will appear to leak it's `NSLock`, and just the lock. Moving the variable declaration to the top of the class fixes it.  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Can you clarify your use case? Signing certain requests vs. others is a pretty straightforward use case that can be handled using an adapter or a router, so what's your issue? Unless the signing depending on keys returned by previous requests it seems like a router would be an ideal way to handle this. My basic question is why can't accomplish what you need with Alamofire's current capabilities. Can you please explain your use case in more detail? Which can be easily done using the [request router pattern](https://github.com/Alamofire/Alamofire#routing-requests) outlined in our documentation. If that doesn't work for you, please explain why in as much detail as possible. You still haven't outlined in any detail what it is you're trying to do here. I'm not sure why you insist on using a request adapter for this, but if you follow the router example in the README it should be pretty clear. Just add an additional parameter based on the route and use it to sign your requests. Since you haven't outlined what signing your requests looks like I can't really help you any further until you do. Hi @SanjoDeundiak,

My apologies for just catching up on this thread now. Your initial assessment is correct in that you would need to use multiple session managers with multiple adapters to easily accomplish this. This is exactly what we do in a large networking library we've built at the company I work at. In ours you create a separate session manager and adapter / retrier for each authentication system you use. It also gives you the ability to customize each session manager based on the needs of that authentication system. Works great!

I'm curious as to why you feel this isn't elegant? At some point, you have to make a decision as to what type of authentication you're going to use for your request. IMO, that should be made way before actually making that request in a big networking library. You don't want to have to make that decision when you're actually calling your request, you'd much rather do it when you define the request and how you actually call it as @jshier mentioned either in your Router pattern (not preferred here), or by assigning the request to be made on a specific session manager whose adapter handles the authentication (preferred).

Another option would be to use a single session manager and adapter, then inspect the request to decide which type of authentication to apply to it, but this seems like a much worse alternative to me. Generally you should only need to call at max a handful of different authentication schemes so using a session manager and adapter / retrier per authentication scheme works out fairly well.

As for attaching an adapter to a request, I've been thinking through this quite a bit and while I do believe it would be possible, it seems messy. Why would I want to define my authentication scheme for each request when I could define it at the session manager level? As I mentioned before, most apps don't use that many authentication schemes, so why add more complexity to creating a request? On top of this, it seems problematic to allow session managers (potentially multiple session managers) to be hopping all over the place calling into adapters and retriers in an inconsistent way. By attaching them to a single adapter / retrier, you certainly limit your scope for testing purposes.

With that said, it's probably possible though to switch the adapter / retrier pattern over to being a per-request type of design, but I don't see the merit there over attaching them to the session manager. Separating your auth per session manager has many other advantages that IMO outweigh the flexibility of attaching them to the request.

Hopefully that helps clarify things here. I'm going to go ahead and close this issue out, but feel free to continue the conversation.

Cheers. üçª  Please don't create new issues just to tell us to look at an existing issue.  `URLRequest` is the Swift-ified version of `NSURLRequest`, new in Swift 3. You use it instead of `NSURLRequest`/`NSMutableURLRequest`.  No, that's just Apple's shitty documentation. It's supported on all systems Swift 3 supports, as it's part of Swift 3, not Apple's libraries.  `NSURLRequest`/`NSMutableURLRequest` are no longer necessary as part of the upgrade to Swift 3. The new `URLRequest` type is a native Swift type that works like other Swift types, which works much better in Swift.  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Can you post the leaks output or the lines it points to as responsible? While a demo project would be appreciated, being able to examine the leaks you've seen would be helpful in the meantime. The lock leaks are a false positive. As for the background leaks, I'm not sure what's happening there, but it looks like you're leaking the world almost. If you can get a test project to us that would greatly help with our investigation. @unusuallyreticent Thanks for the investigation, it helped narrow this down quite a bit. It turns out that, when the `taskDidComplete` closure is set, AF isn't calling it's own `TaskDelegate`, which means we lose all of the machinery in there that takes care of task completion. So not only would it leak but any `response` handlers attached would never be called. I've put up a tentative fix on the `bug/1938` branch, pull it down with CocoaPods and see if it works for you. I still need to add some tests but it should fix the issues you're seeing. Hey everyone,

Sorry for being late to the party here. @jshier and I discussed the changes that he put up in the `bug/1938` branch. I'm not surprised that fixed the issue for you @unusuallyreticent. You have to be very careful right now with the session override closures to make sure you don't shut off some of the functionality.

The change that @jshier made is switching that `taskDidComplete` closure over to a hook instead of an override. After quite a bit of debate, we realized that there shouldn't be any harm in this change since it was impossible to get the queue resumed without a huge amount of work. Therefore we're fairly confident this change won't break any clients out there now.

We're going to look to unify the override closures in AF5 or just remove them completely with the goal being to make sure their usage is clear and not easy to mess up. There is enough inconsistency right now that it can lead to issues like you experienced.

As for the NSLock leak, I've actually filed a radar against that specific leak and it was closed as a duplicate. That is not something we can do anything about right now unfortunately.

I've pushed up @jshier's bug fix into the `master` branch in d64afca3 and it will go out as part of the Alamofire 4.4.0 release here shortly.

Cheers. üçª  If you take a look at [our documentation for `validateCertificateChain`](https://github.com/Alamofire/Alamofire#validating-the-certificate-chain) you can see that it won't work will self-signed certificates. Setting that to false will likely fix your issue.  We are making good progress towards getting Alamofire building on Linux (checkout the `linux` branch to see) but we've run into a big issue. Aside from a few constants and other minor changes that can be worked around, the Linux version of Swift is missing the `Security` framework from Apple's platforms entirely. So all of the functionality that Alamofire's `ServerTrustPolicy` depends on does not exist on the Linux platform. There are a few options here:

1. Refactor Alamofire to decouple `ServerTrustPolicy` from `SessionManger`. This will be a bit of work (meaning time) and will mean the the Linux version doesn't have any SSL verification beyond what `URLSession` provides.
1a. In addition to decoupling `ServerTrustPolicy` and `SessionManager`, abstract `ServerTrustPolicy` enough that Linux devs could implement it themselves using whatever dependency they wanted.
2. Adopt an external dependency for Linux to provide said features and abstract the `ServerTrustPolicy` to use either implementation depending on the running platform.
3. Similar to 2, but also replacing the implementation of `ServerTrustPolicy` on Apple platforms to use the dependency on all platforms.
4. Nothing. No port of Alamofire to Linux until the Swift team can provide a useful dependency that comes with the language or default Swift installs.

Personally I lean towards 1, as we've always worked to not have any external dependencies in Alamofire. However, this would be a major refactor and may not ship until Alamofire 5. 2 or 3 have the benefit of being a behind the scenes change but would likely be even more work than whatever changes we want for AF5 and so may take even longer.

However, we wanted to open this discussion up to public feedback to gather input and suggestions from the community before we choose a path and move forward. Not AFAIK, but they are working on server side libraries that may cover some of the same things. Whether those would be suitable for what we need I don't know and it's unlikely those libraries will be usable until after WWDC this year. I'm going to email the Swift users list and see if anyone wants to add anything. That is certainly something we're hoping to avoid. We'd like to avoid any dependency as well, so we may just refactor and abstract `ServerTrustPolicy` at the same time so anyone who's interested could provide their own implementation of the functionality on Linux. The only explicit interaction Alamofire has with SSL is through the `ServerTrustPolicy`, which can be used the validate the certificate chain or pin a certificate. If you don't enable one everything is handled automatically through `URLSession`. Under Linux it would be the same thing. We'd just like to have community buy in on whatever solution we choose. `URLSession` supports the standard SSL validation that's required. `ServerTrustPolicy` goes beyond that by allowing for cert and public key pinning, revocation checking, and others. It's in progress, given that we haven't rectified the dependency on `ServerTrustPolicy` yet. It's up only for public review and perusal.  I've added option 1a based on @SlaunchaMan's suggestion. @IOOI-SqAR Thanks. That sort of framework is what we would need but I doubt it will be production ready very soon.

At this point it looks like we're going to abstract `ServerTrustPolicy` behind a protocol and offer an implementation on Apple platforms. Eventually we may be able to offer a cross platform solution using the planned Swift Security framework, but until then making it protocol based will at least allow non-Apple platforms to build their own implementations even if we don't ship it.

I'll leave this issue open for now, to track the progress, but it doesn't look like this work will happen until Alamofire 5 this summer.  Most likely this is a false positive or underlying Swift issue, but in the case that it isn't it appears to be triggered in your code, not Alamofire's. Alamofire only shows up in the call stack because the leaking code was called during response serialization. Perhaps letting Swift manage the intermediary array in your `initArrayFrom(data:)` method would help?
```swift
class func initArrayFrom(data: JSON) -> [ReservationSchedule] {
    return data.arrayValue.map(ReservationSchedulre.init(data:))
}
```
As an aside, the leak mentioned in the SwiftyJSON issue is different from the one your reported in your StackOverflow question, and is a false positive.  @gperdomor You can clean up your response parsing by using `guard`s in that statement. But really you should be writing a custom serializer to better encompass your logic, as I demonstrate in [this gist](https://gist.github.com/jshier/f356bfb5b6dc634b67b14ddb75bd7279) or as you can see in our documentation. I also suggest not using so many implicitly unwrapped optionals, you'll get unexpected crashes that way.   Hi @akkuprin,

This is not a change that should be part of Alamofire itself. The `$` character is a supported ASCII character which [should be supported](http://stackoverflow.com/a/4410331/1342462) by servers. Here's a quick example of sending headers with `$` embedded in both the header fields and values.

```swift
func testDollarSignsInHeaders() {
    let expectation = self.expectation(description: "request should succeed")
    let headers: HTTPHeaders = [
        "foo": "b$r",
        "currency": "$for$dollars",
        "$momoney$": "$$$cash$$$"
    ]

    Alamofire.request("https://httpbin.org/headers", headers: headers).responseJSON { response in
        debugPrint(response)
        expectation.fulfill()
    }

    waitForExpectations(timeout: 20, handler: nil)
}
```

What you should do instead in this case is pre-encode your headers before adding them to Alamofire. If they need to be escaped, it needs to be you who does this because Alamofire can't know whether or not you need to actually escape the `$` symbol.

Thanks anyways! üçª  This doesn't seem like a good idea, as any API call you make before pinning the public key could be intercepted and an malicious hash returned. I'd be very careful here @sagarpatkar with this type of approach as @jshier mentioned. Accepting new certificates from the server to use for future request pinning is a pretty big security risk, even when cert pinning that original request.

With that said, you should be able to use TrustKit with Alamofire if you override the challenge closure and evaluate the certificate chain using TrustKit. This would allow you to evaluate the cert chain returned by the server against an HPKP pre-generated hash even though we don't directly support that in Alamofire.

Cheers. üçª  It's not built into the top level APIs but you should be able to pass a `URLRequest` through two different encodings with no issue. I'd recommend encapsulating such logic inside a [router](https://github.com/Alamofire/Alamofire#routing-requests) as described in our documentation.  Hi @WillBishop,

There's an example right in the [README](https://github.com/Alamofire/Alamofire#download-file-destination) on how to do exactly this.

If you continue to have issues, I'd suggest you open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Hi @donpironet,

You're calling the method incorrectly. Instead, you should use:

```swift
self.request("someurl", method: .post).responseJSON { response in
    debugPrint(response)
}
```

If you continue to have issues, please read through the [README](https://github.com/Alamofire/Alamofire/blob/master/README.md), then I'd suggest you open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Alamofire does no string encoding of it's own, it just uses `JSONSerialization` to create the `Any` value from the returned JSON. This may be something strange with `print` or even something with your server's response.

Also, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Closing this to move discussion into #1935.  Hi @zhukexiang,

The `destinationURL` is not cleaned up by Alamofire unless a new file is downloaded to replace it. If you're certain it was successfully placed there by Alamofire, then I'd suggest looking through the rest of your code to see what could be going on.

If you continue to have issues, I'd suggest you open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Thanks for the report. This may or may not be related to the extension issues. While I see a different in the response of the two session types, both eventually return an error, though the background session took longer. With my internet offline, the foreground session returned:
`FAILURE: Error Domain=NSURLErrorDomain Code=-1009 "The Internet connection appears to be offline."`
The background session returned:
`FAILURE: Error Domain=NSURLErrorDomain Code=-1001 "The request timed out."`
I'm not really surprised they respond differently, as background sessions are pretty different.

Here are my communicators:
```swift
struct Communicator {
    
    static let shared = Communicator()
    
    let manager: SessionManager = {
        let policy: [String : ServerTrustPolicy] = ["httpbin.org" : .pinCertificates(certificates: ServerTrustPolicy.certificates(), validateCertificateChain: true, validateHost: true)]
        let configuration = URLSessionConfiguration.default
        configuration.httpAdditionalHeaders = SessionManager.defaultHTTPHeaders

        return SessionManager(configuration: configuration, serverTrustPolicyManager: ServerTrustPolicyManager(policies: policy))
    }()
    
}

struct BackgroundCommunicator {
    
    static let shared = BackgroundCommunicator()
    
    let manager: SessionManager = {
        let configuration = URLSessionConfiguration.background(withIdentifier: "com.jonshier.AlamofireTest.ShareUpload")
        configuration.httpAdditionalHeaders = SessionManager.defaultHTTPHeaders
        configuration.sharedContainerIdentifier = "group.com.jonshier.AlamofireTest"
        
        return SessionManager(configuration: configuration)
    }()
    
}
```
Perhaps you just need to wait a little longer? Hi @ened,

Background sessions have completely different behavior as @jshier eluded to. They have all sorts of internal handling for retrying failed requests over super long periods of time in situations where there are challenges, redirects and especially connectivity errors. What you're seeing right now is that when connectivity is lost, the background session's request won't actually throw an error. It will wait until the `timeout` specified on the `URLRequest` is reached before returning the timeout error as @jshier pointed out.

If you MUST use background session downloads and you need to tell the user more abruptly when connectivity is lost, you could use the `NetworkReachabilityManager` to cancel the background request or you could shorten the `timeout`. I think I'd recommend shortening the timeout for now and seeing if that can get you where you need to be. But keep in mind that in other parts of the world (especially China) there can be significant connectivity lag that could trigger false / positive failures if you shorten it too much.

Best of luck! üçª @quhaoran007
If you've seen the WWDC sessions or read the updated documentation for the `URLSession` changes in the new OS versions you've seen that they introduced the notion of delaying requests while waiting for connectivity. Turns out, background sessions had this functionality all along, and that's what you're seeing here. Unfortunately Apple hasn't really documented all or even any of the other behavioral differences you might see in background sessions, so there's not a lot of help we can provide at the moment. We do hope to improve our background integration some time this year.  Yes, background sessions are still background even if your app is in the foreground. They don't change behavior. The way Apple explained it when introducing the `waitingForConnectivity` functionality is that your timeouts only apply once the session has been able to reach the server once, at which time the request timeouts would take effect. If the device is offline when the request starts, the request timer will never start as the background session waits for connectivity. 

Unfortunately there's not a lot we can do here, as background sessions are largely a black box. They have a variety of different behavior that isn't documented. I suggest you rethink how you're making requests and consider how you want to be using background sessions, as they're really only designed for downloads or uploads you need to continue even if the app is suspended in the background.  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Thanks @fulldecent...that was definitely wrong. I had to tweak your changes a bit and pushed them up into `master` in f3e250ab while keeping your attribution. This should go out shortly as part of the Alamofire 4.3.0 release.

Thanks! üçª  Thanks for the report, we'll look into this. This may or may not be related to #1851. @nickvelloff @0xc00010ff I was able to create a project which uploaded images from disk from a share extension. Initially, when declaring the `SessionManager` locally, I was getting the uploads cancelled as well. However, moving my `SessionManger` into a singleton so that the reference stays alive allowed my uploads to complete. Now, I don't know how long the share extension process stays alive after posting, but it was offscreen for a few seconds before the upload finished without completely killing the share process. 
```swift
struct BackgroundCommunicator {
    
    static let shared = BackgroundCommunicator()
    
    let manager: SessionManager = {
        let configuration = URLSessionConfiguration.background(withIdentifier: "com.jonshier.AlamofireTest.ShareUpload")
        configuration.httpAdditionalHeaders = SessionManager.defaultHTTPHeaders
        configuration.sharedContainerIdentifier = "group.com.jonshier.AlamofireTest"
        
        return SessionManager(configuration: configuration)
    }()
    
}
```
But in general, yes, a `SessionManager` needs to live as long as its transfers do, if only because, when it's `deinit`d it cancels its outstanding tasks. This is, perhaps, technically incompatible with background sessions, but it should suffice for any scenario where the containing process lives long enough.

I'll keep this issue open for now to see if this solution works for you. I agree here with @jshier's assessment. The only thing I'd like to add is that I'm not sure if you're extension will be relaunched in the background once the transfer completes after it has been terminated by the OS. I would assume it would, but I'm not positive. You'd have to test this on a device to know for sure with an upload that was big enough to make sure the extension was actually shut down.

Another approach here would be to have the client application make the request on your extension's behalf if you can't get the background sessions working correctly with the extension. Background sessions certainly work correctly in the app, but may have different behavior in the extensions. Just something else to consider.

I'm going to close this issue out for now since there's nothing actionable here for the AF team. Feel free to continue to comment on this issue and we'll happily re-open if anyone finds anything that needs further investigation.

Cheers. üçª @nickvelloff Do you have any documentation you can point us to regarding the lifetimes and environment of extensions? I'm not sure what you're talking about here. Using a singleton (or any long lived instance) just ensures that the `SessionManager` doesn't cancel the requests until much later. It's still `deinit`d when the extension is exited. But yes, Alamofire would need some fundamental behavioral changes for background sessions to support this sort of use properly. Not the least of which is not cancelling background tasks when the `SessionManager` is `deinit`'d. We'll take a look at this more in the future.  I'm closing this. If someone in the community wants to help out @TannenBiff, then feel free to continue the conversation through this issue.  Hi @Bouke!

Without more detail on your "typed requests", I think you can accomplish what you want much more simply by following the patterns we lay out in our `README`. I'm guessing that you've been able to get your response methods working, which is great, so I'll focus on your request methods. 

Rather than subclassing, perhaps you can start by extending. In my current project I've created a couple protocols to help encapsulate the routing and parameters of each request. It's easy to hook this into Alamofire with the following extension:
```swift
extension SessionManager {
    
    func request<T: URLRequestRoutable>(_ parameters: T) -> DataRequest {
        return request(parameters.route)
    }
    
}
```
By combining this with a [`Router`](https://github.com/Alamofire/Alamofire#routing-requests) or some other sort of `URLRequestConvertible`, a proper `ParameterEncoding` to generate your SOAP requests, and a custom `ResponseSerializer` to generically serialize your responses, you should be able to accomplish what you need with subclassing at all. 

Does this give you an idea of a different approach to take?
 What I was trying to point out is that your wrapper is largely unnecessary and really goes against the grain of Alamofire's architecture, which you've already felt. Everything you're doing is already doable using the protocols and functions built into Alamofire. Now, I'm not really familiar with the requirements of a SOAP API (thankfully), but looking at your code, you need just a few things. But first, some general design philosophy.

As you noticed, chaining is at the core of Alamofire's design philosophy for the top level APIs. The ability to pipe a single request through multiple response serializers, or generally, any request to any supported serializer is key to the success of the framework. This is also one of the reasons why Alamofire's various `*Request` types are not generic. Fundamentally the request you make shouldn't impact the type you serialize from its response. This way you can chain whichever response serializers onto the request you want and all of them will take the same response data and return whatever types they need. The `Request<T>` type you've shown has really nothing to do with the various requests types used by Alamofire.

So, like I said, there are few things you specifically need here. Protocols for your requests and responses (perhaps `SOAPEncodable` and `SOAPDecodable`).  A `ParameterEncoding` generate your requests (usually inside a router of some type), or some combination of `SOAPEncodable`, a router, and a `ParameterEncoding`, let's call it `SOAPActionConvertible`. Also, a generic response serializer, `SOAPSerializer<T>` would serialize the responses. Then you'd ultimately have extensions, like I've show, that would result in functions like this:
```swift
func perform<T: SOAPActionConvertible, U: SOAPDecodable>(_ action: T, completionHandler: @escaping (_ response: DataResponse<U>) -> Void) -> DataRequest {
    return Alamofire.request(action).responseSOAP { response in
        completionHandler(response)
    }
}
```
Where `responseSOAP` is a generic extension to `DataRequest`:
```swift
func responseValue<T: SOAPDecodable>(completionHandler: @escaping (_ response: DataResponse<T>) -> Void) -> Self {
        return response(responseSerializer: SOAPSerializer(), completionHandler: completionHandler)
    }
```
Then, you'd generate your `SOAPActionConvertible` types and your `SOAPDecodabe` types based on your WSDL. You can then use this single path through Alamofire to perform your requests.   The HTML you received probably contains information about the error the server is returning. I suggest you investigate that.

Also, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Hi @liangquandeng,

I'd suggest you open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Hi @Ingibjorg,

It looks to me that your app is running out of memory. I would venture a guess that you're making a data request to a resource that is too large to download in-memory. If this is the case, you should switch over to using a DownloadRequest so the data is streamed to disk rather than being stored in memory. You're app is only allowed so much memory and things like download giant images or small videos to your in-memory store using `Alamofire.request` instead of `Alamofire.download` can quickly get you into trouble.

Hopefully that helps get you going in the right direction.

Cheers. üçª  Hi @monish152,

I'd suggest you open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Hi @faisalrasbihan,

The only obvious issue I see if that in both cases of getting a new access token you're calling `completion` with a value of `false`. It should be `true` when `accessToken` is not `nil`. Other than that, I don't see anything obvious. It's most likely an order of operations issue or you have threading issues in you `retrieveNewToken` logic or `retrieveNewToken` is being called multiple times. You'll just need to continue to debug further.

If you continue to have issues, then I'd suggest you open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  @cyberdude This looks fine. Is there someplace where changes like this are tracked? I'm not seeing anything in the SPM docs about it being required now.  Hi @yjb94,

If there's no content-length being returned for that image URL, then progress reporting won't work. iOS defaults to `-1` when it doesn't know what the total image size will be.

If you have further questions, then I'd suggest you open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Hi @sathamkhussain,

I'd follow @sahandnayebaziz's advice here and open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Can you post the code that's causing the crash, along with the versions of Alamofire, Xcode, the operating systems you're seeing the crash on? @suniljakhar we need a working example here that demonstrates the issue in order to continue to investigate. I'm very doubtful here that the issue is Alamofire itself, however, I want to give you the opportunity here to have us help you investigate further. We just need to do your part and give us more to work with.

I'm going to leave this open for a few days for you to get us more info. What do you mean by you created a `URLSessionDownloadTask` and then you use `moveItem` and everything is working fine? Does that mean you created an example that doesn't use Alamofire and there are no memory constraint issues like you're seeing in Alamofire? @jshier would you be able to investigate this issue to see what's going on? @suniljakhar I've created a test project using Xcode 8.2.1, Alamofire 4.3, and an iPhone 4S running iOS 9.3.5 (only other iOS device I have) and I can't reproduce your crash. I was able to successfully download a 1.4GB file on the device and move it to my documents folder. Please retest using the latest versions of Alamofire and Xcode. If you still get a crash, please post the crash log. @cnoon Only other thing I can think of is an iOS 10 issue, do you have an older iOS 10 compatible device to test with? I'm in the process of acquiring one but it'll be a week. Hmmm...I might @jshier. Could you post your sample project here so I have it just incase? We could also just try the sample project on a newer device running iOS 10 and monitor the memory usage. It shouldn't have to crash for us to be able to detect a memory spike. Here's my test project, though it has a lot of different test bits, and my original download file was local, since the sites I found that do simple test file downloads were pretty slow. 

[AlamofireTest.zip](https://github.com/Alamofire/Alamofire/files/802400/AlamofireTest.zip)
 @suniljakhar I've run my test project on an iPhone 5s running iOS 10.2.1 and it worked without issue. I'm closing this issue, as we can't reproduce it. If you come up with a test project that reliably reproduces the issue, let us know.  Hi @appmagnetics,

Most likely the issue is due to you converting your data types over to Objective-C, then trying to implicitly covert them to `Any`. Instead, get rid of your `NSNumber` and `as AnyObject` casts and things will probably start working.

If that doesn't fix things up, then I'd suggest you open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Error 3840 is `JSONSerialization`'s way of telling you that it didn't receive valid JSON. Most commonly this is caused by the server returning an HTML error page of some kind.

Also, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Alamofire isn't that big of a library and should only take a few seconds to build. However, the cost of supporting prebuilt binaries isn't that big, assuming we can get our TravisCI setup to do it automatically. That refactor likely won't be easy, as we don't have anything like it at the moment. Luckily Carthage does have some documentation for it.

@cnoon I'm marking this up for now and assigning to us both. Let me know if you don't think we should do it, otherwise I may be able to get around to it eventually. That's rather absurd as it takes less than 10 seconds on my local machine.  Hi everyone,

Thanks for the healthy discussion here and the willingness to help get things implemented. I feel it's very important for everyone to read through #588 before reading the rest of my reply. 

I still feel like this is a slippery slope that I'm not willing to dive into just yet. The Alamofire team spends a tremendous amount of time on CocoaPods and Carthage build issues. We've managed to narrow down some of the Carthage issues, I'm sure, by not supporting this in the past per [Apple's recommendation](https://developer.apple.com/swift/blog/?id=2).

IMO we're still not that far from where we were in the Swift dependency management world when #588 was initially filed. I think we'll still run into Swift compatibility issues as soon as we start deploying those pre-built binaries. Once Apple starts shipping the swift runtime as part of the OS, I'd be much more keen on supporting this feature. From what I've been able to find there are alternative ways to grab pre-built binaries from your own hosted solutions to use with your CI instances.

Once Apple starts shipping Swift with the OS, we will look to re-open this issue and get it implemented. But until then, let's hold off.

Cheers. üçª  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  As you can see, this is a CocoaPods error. It should be taken care of in 1.2 (it is for me), but there's nothing for Alamofire to do here.  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Make sure your version of CocoaPods is updated to at least 1.1, as previous versions didn't know about the `SWIFT_VERSION` setting, but after 1.1 it will use the project's setting for the Pods and should work fine.  A `401` error is the standard `Unauthorized` HTTP error code. However, Alamofire does not provide a translation of codes to standard descriptions, mainly because it wouldn't be that useful for most people and also because some servers use different response codes to mean different things. Plus, not all possible codes have good descriptions.

If you want you can wrap the errors returned by Alamofire in your own errors, which gives you a chance to add your own descriptions to be printed. I've used that behavior myself. Would that accomplish what you want? It's easiest if you're already using your own custom `ResponseSerializer` and could be a good reason to create your own (they're straightforward). It hasn't been updated for Alamofire 4, but [this gist](https://gist.github.com/jshier/f08f08e05d994b5bdc7d) should show you what I mean. As you can see, at each step of the process I wrap the possible errors in different cases of my own `Error` conforming `enum`. Then within that `enum` you can parse out the errors and provide your own `localizedDescription` for them. Yes, the particulars of the generic serialization are up to your implementation. In my example I'm using the Argo library to decode my JSON responses, hence the use of its `Decodable` protocol. If you don't already have custom serialization you may want to start simple and just duplicate the existing `responseJSON` function, but with your own error handling. Custom response serializers really start to shine when you create your own generic decoding into strong types, as [demonstrated in our README](https://github.com/Alamofire/Alamofire#custom-response-serialization). @jshier Hi- I have hit a brick wall with this. Have spent ages googling for the answer - and it seems a lot of people are just as confused as I am.  Would be massively greatful for some more  guidance. 

It seems that the implementation that is done in the Readme does not match up with the implementation. in 'ResponseSerialization.swift' file.  

I have tried copying the current implementation for ResponseJSon, renaming it to "ResponseJsonSimple" and adding a switch statement to the error code however the only property that xcode says is has is error.localized Description.  I can't seem to get the error codes to add them to the return statement. 

Here is the Gist: https://gist.github.com/grantkemp/bb00419f8a84c2698d56fcf64b127ba0

Can you run through the exact steps I should follow in order to add these custom error codes in for these common error codes like 404, and 403.  It feels like something that should be quite basic to add in - and a common use case.  Ignore what I said above.  I think I have cracked it.  I also think I might be in love with Custom Serializers..  Even though I haven't fully got to grips with them - I really see the promise now..  Very painful getting to this point- but it was completely worth it.   These don't seem to have anything directly related to Alamofire. I suggest you report these crashes to Apple and see what they say. Also, asking a question on StackOverflow will get more eyes on these issues than you'd get here. I'm closing this, but please let us know if you learn anything more about this apparent increase in crashes on iOS 10.2.  @Dschee I appreciate your work on this. However, I'm not sure this scenario is common enough to need top level APIs dedicated to it. Once Alamofire usage has reached this level of complexity (covering an entire JSONAPI setup), users should really be adopting a variation of the `Router` pattern. This can fairly easily cover the scenarios you require by using multiple encoders. Ultimately, it seems like there are few options here:

1. Add top level API for encoding both URL and body parameters into a request, as demonstrated in this PR.
2. Add a specialized `ParameterEncoding` conforming type that can take both url and body parameters as well as their encodings and generates a request.
3. Both 1 and 2.
4. Nothing, and let users add their own particular implementations.

I think perhaps 2 is the way to go if we want to support this, as I really don't think this is common enough to need the additional complexity of adding and refactoring the top APIs for it.

@cnoon, what do you think? I'm not particularly sold on any solution (or not) here. Hi @Dschee,

Thanks again for your efforts here. We greatly appreciate new ideas on how to make improvements. @jshier talked it through while we like some of the ideas here, we don't think they have a place directly in Alamofire for a couple different reasons.

The first reason is that the top level APIs are designed for convenience for the common use cases. We try to have as few as possible to make it easy to decide what you're looking for. As soon as you start adding query parameters, query encoding and http body parameters in the same top level APIs, you're outside of the normal cases for sure. So that's the first problem. We don't want another top level API. Not to mention a top level API that needs two more parameters.

The second problem is that even if we did allow the API with the additional parameters, it's really easy to misuse the encodings. If you mix up either of the encodings or the parameters you're in trouble and it won't be very easy to debug what's going on. For example, if you accidentally use `URLEncoding.default` for your query parameters (which I believe you did you your PR), you're in for a world of hurt with a `.put` or `.post` because the parameters will be encoded in the body in those cases then potentially replaced by the body parameter encoded data.

Overall, we don't really want to add another top level API, and if we did, it would need to be very difficult to misuse.

Thanks again. üçª  Unfortunately, at no point in the request process do we have a chance to change the headers added by the `URLSessionConfiguration`. Additionally, changing the `URLSessionConfiguration`'s `httpAdditionalHeaders` on a per request basis is a bad idea for many reasons, not least of which is the difficulty of keeping such a thing thread safe. As we suggest in our README and Apple does in their documentation, you should set `httpAdditionalHeaders` at the time you create the `URLSessionConfiguration`. If you need headers that aren't always in requests I suggest you do so at the time you create your `URLRequest` or using a `RequestAdapter`.  Thanks, we'll take a look @Dschee. However, you can already accomplish this by using the `URLEncoding` `ParameterEncoding` on the `URLRequest` and then passing that `URLRequest` into `request()` as you're doing, where the body will be `JSON` encoded. So really this is just a slightly more convenient version of that. Perhaps a more general solution would be to create a `ParameterEncoding` that can take sets of encodings and parameters and applies them to a request all at once? Hi @Dschee,

Thanks for taking the time to put this together. I'm afraid this addition isn't something we'd like to have in Alamofire. It is confusing to parameters going into both your `QueryURL` and into the top level APIs.

With that said, feel free to use this all over in your own projects. There's nothing wrong with doing what you are doing, it could just lead to misuse and confusion among the AF community.

Thanks again. üçª  Your code samples seem to be identical.

However, we've seen this before, as some servers don't like `bodyData` in `GET` requests. Make sure you're using the correct parameters encoding for `GET` requests on your server.  @reshadf Agreed, we should add SPM directions to our `README`. However, I wouldn't suggest using it if you're developing for Apple platforms unless you're prepared for the integration burden it presents. @reshadf @indrajitsinh @AndrewSB 
I've opened #1898 to add brief instructions to the README, let me know what you think. I really don't think SPM is very useful at the moment, but our current integration works and I was able to create a simple test project pretty easily. Resolved by #1898.  Anything you're comfortable with. I took care of it myself, but small issues like #1871 are a good place to start. Also, documentation editing is a good way to introduce yourself to the codebase without having to worry about writing code. Thanks for the interest!  As you can see in the header documentation, this error is returned when the response unexpectedly return nil or zero length data. I suggest you investigate.

However, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  @ssam2000 It seems likely you've got an issue with creating your requests. However, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  @cnoon designed this API, but I believe it was to match the previous `enum` implementation and assist people in transitioning to the new version. It also establishes the general pattern of convenience static properties for preset values. You're right, these could (and likely should) be singleton values, rather than generating a new one every time, but that rather minor refinement can be made at any time. @cnoon, anything to add? Closing this for now. @cnoon, if you have anything else to add please do so.  A good idea. I've opened #1880 to take care of this.  It sounds like you tried to upload just a framework or something else.

However, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Issues like this aren't generally Alamofire specific issues. I suggest you redo your Carthage integration and go from there. Otherwise, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com).

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  It looks like the server isn't properly returning an `Expected-Length` value for HTTPS requests. You can confirm this by inspecting the headers returned for your request. I suggest reaching out to the server administrator to see if they can fix the issue. If you can find an issue in Alamofire itself, please open another issue and we can investigate.  @SkyMatt70 It sounds like you may not have the appropriate version of Alamofire installed. Perhaps there's an old build product around?

@laurent-humbert Make sure all of your types are appropriate (perhaps drop the `responseJSON` until the rest compiles), as it may just be a bad compiler error. 

However, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com).

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Awesome...thanks @ulugbekrozimboyev! üçª  This PR modifies the `DefaultDataResponse` and `DefaultDownloadResponse` initializers to be `public` instead of `internal`. This allows you to rebuild the responses if necessary in client code to do things like wrap the `error` in your own custom error or modify the server data or possibly inject a missing header, etc. The main use case is to wrap the `error`.

This PR also adds convenience properties to the `DataResponse` and `DownloadResponse` structs for accessing the `value` and `error` in the result. Both of these computed properties are merely for convenience. @groue I think the functional approach your PR creates is great, and I'm sure many developers will be comfortable there, but there is an argument for the straightforward use of an initializer. Depending on whatever else there doing, one approach may be more readable than the other or fit better with their other code.  Thanks for the feedback @groue! I agree with @jshier that both are useful. Apologies for your PR being left out there without feedback. We got pretty busy with the holidays and haven't been able to keep up with all the great work coming in.  Thanks @brow! üçª  Hi @yigitserin,

First off, AF 4 will not crash with an invalid URL string, but AF 3.x and below certainly will. In AF 4, we now throw an AFError.invalidURL error in the response handlers.

Secondly, you should use the built in URLEncoding in Alamofire, `URLComponents` and `URLQueryItem`s  or use the percent escaping APIs to ensure your URLs are properly encoded. If you have issues using any of these approaches, then I'd suggest you open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  If you look at [the source](https://github.com/Alamofire/Alamofire/blob/master/Source/SessionDelegate.swift#L112), the screen shot you've posted doesn't match, so your Alamofire installation is out of date. Update and it should work fine.  As you can see [in the source](https://github.com/Alamofire/Alamofire/blob/master/Source/SessionManager.swift#L56), `defaultHTTPHeaders` is a `static` method, not an instance one.

Your error is usually due to some type mismatch that the Swift compiler can't give a good diagnostic about.

In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com).

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.   You're likely falling afoul of some URL encoding issues, as your server may not expect raw Korean in the query.

Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. Feel free to open another issue if you find a reproducible bug in Alamofire.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Right now the best way to accomplish that is to put such error handling inside your response serializer. That way you can share code between your normal response handling and the special error handling. We're hoping to revisit the `validate` vs. `response` functions in the future, but for now this should work. Attaching the response body to the error is unlikely to happen, as the data could very large, even if we refactor the `validate` vs. `response` handling. I suggest you look into customizing your response serializer. This error is used for any response code outside the valid range, which could be customized in ways we can't anticipate, including use in a backend system that includes large responses, intentionally or not. There is no single standard practice here so we must be conservative when offering default behaviors.

Like I said, customizing the response handler is appropriate place to put this logic for now. Our response handling is [well documented](https://github.com/Alamofire/Alamofire#response-handling), even for [custom cases](https://github.com/Alamofire/Alamofire#custom-response-serialization).  Hi @sonysum,

I'd suggest you open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  I've verified this is in fact a bug. Should be a simple fix. I just put up PR #1864 to address this issue. I'm going to close this issue out. Please direct all future comments to #1864. Thanks @ejensen for filing! üçª  The `URLSession` APIs have a max concurrent limit of tasks being executed. It is set to 4 per host by default on iOS. See the [`URLSessionConfiguration`](https://developer.apple.com/reference/foundation/urlsessionconfiguration/1407597-httpmaximumconnectionsperhost) docs for more info.

Cheers. üçª  Hi @adrianbrink,

What I'd suggest here is that you turn off the pinning for now just to try to get things working. If you do, can you get calls through? Can you make calls from the Today Extension to something like `httpbin.org`?

I haven't tried to use Alamofire in a Today Extension, but everything should work properly. The most common issue we see with cancellation errors is that the session manager is going out of scope. Are you positive yours isn't being deallocated?

Is there any chance you could post a sample app? I can't really help you investigate further without one. Could either of you answer my questions above? There's not anything we can do without some more information. @subhajit1609 I've tested your scenario with the `ServerTrustPolicy` and it worked fine. It's possible your issues stems from the fact that your policy URL includes the scheme, which it shouldn't. Remote that and it should work correctly. 

@adrianodiasx93 I've tested your scenario and I was receiving the `-999` error when I was trying to pin a certificate that wasn't in the proper format. If you've downloaded a certificate as a `.pem`, you need to convert it to `DER` format before being able to pin against it. Once I did that I was able to run request from my app and today extension using the same setup.

It seems like both of these issues come down to a misconfiguration of certificate pinning, so I'm closing this issue. If either of you can come with a specific Alamofire issue we'll be glad to take a look. Just create a new issue with an example project.  This is just the way things work on Apple platforms with the `Authorization` header. The reason (we think) that Apple doesn't automatically pass that header through is that some servers will reject the redirected request if it contains the `Authorization` header and shouldn't.

We actually already have a [test](https://github.com/Alamofire/Alamofire/blob/master/Tests/SessionDelegateTests.swift#L418-L470) for this behavior as well as the implementation for how to modify the session delegate to actually pass that header through. If you implement something similar to that logic in your app, you should be good to go.

Cheers. üçª  There's no logic that I'm aware of to stop `JSONEncoding` in a `GET`. Here's what the `encode` method on `JSONEncoding` looks like in Alamofire 4.2.0.

```swift
public func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -> URLRequest {
    var urlRequest = try urlRequest.asURLRequest()

    guard let parameters = parameters else { return urlRequest }

    do {
        let data = try JSONSerialization.data(withJSONObject: parameters, options: options)

        if urlRequest.value(forHTTPHeaderField: "Content-Type") == nil {
            urlRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")
        }

        urlRequest.httpBody = data
    } catch {
        throw AFError.parameterEncodingFailed(reason: .jsonEncodingFailed(error: error))
    }

    return urlRequest
}
```

Am I missing something?  This is most likely due to some issue you have in your logic @sergiocg90. Many of us have apps shipped on AF 3.5.1 and aren't seeing this issue. Any chance you could post some sample code for us to better understand how you're making requests? The top of your crash stack, which contains `assertionFailed` and `StaticString` almost alway indicates the forced unwrapping of a nil value. In your code there are a variety of locations that could be causing that, so I suggest you audit your code for implicitly unwrapped optionals and make it a bit safer. Symbolicating your crash stack properly would probably help you find it as well. In any event, if can narrow the crash down to something caused by Alamofire and can create a sample project that replicates the issue, feel free to file a new issue with the sample project. Until then, there isn't enough here to narrow down a cause, but there's enough in the code you posted for me to say that it likely isn't caused by Alamofire itself.  Sounds like some local setup issue and not something directly related to Alamofire. I'm going to close this issue out for now, but feel free to continue to discuss here.  Thanks @zhongwuzw for putting this together. I made a small tweak and pushed it up into `master` in 05c9bcdc. It will go out in the 4.3.0 release most likely. Thanks again! üçª  Hi @black-lotus,

The `response` method signature has changed. Just comment out your old code and use auto-complete to rebuild your logic. Please check out our [AF 4 migration guide](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%204.0%20Migration%20Guide.md) for more info. 

If you continue to have issues, then I'd suggest you open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  It is possible to set the concurrent count on a `URLSessionConfiguration` to 1 using the `httpMaximumConnectionsPerHost` property, but that's still not going to be what you want. It won't have enough thread safety for you to deal with JWTs.

Instead, you should check out our `RequestRetrier` example in the [README](https://gist.github.com/cnoon/fa26a5059ecddfb6756a#requestretrier). It breaks down all the thread safety needed to refresh your JWT and restart the requests. While that example doesn't handle all the cases needed for thread safety, it certainly gets you started in the right direction. We use a VERY similar design with our internal networking library at Nike that's built on top of the `RequestAdapter` and `RequestRetrier` protocols.

Cheers. üçª  The general fix for this issue is to ensure all of your dependencies have a `SWIFT_VERSION` of `3.0` and not the `3.0.1` that Xcode 8.1 may have entered. We'll update the Alamofire projects to make sure they work, but if you're using CocoaPods, setting your main project to `3.0` should set all of the pods to that version as well. There's nothing to change here for Alamofire, as I've verified that it builds fine in Xcode 8.2. Ultimately the solution here is to edit your app project files and replace every instance of a `SWIFT_VERSION` of `3.0.1` with `3.0`.  Closing with the same response as #1839.  There's no rfc spec around collection URL encoding. What you're seeing in Alamofire is our default implementation. If you need the indices, you'll need to create your own custom `ParameterEncoding` to add the indices. This can be accomplished by using the `URLEncoding` implementation as a guide.

For more info on creating a custom `ParameterEncoding`, please refer to our [example](https://github.com/Alamofire/Alamofire#custom-encoding) in the README. For more info on the current `URLEncoding` implementation and reasoning, please refer to the [docstrings](https://github.com/Alamofire/Alamofire/blob/master/Source/ParameterEncoding.swift#L62-L69).

Cheers. üçª  Hi @Insofan,

It works fine when things are setup correctly. If you're having trouble with autocomplete, I'd suggest you take your question to [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. Someone should be able to help you get to the bottom of your issue. Most likely you need to clean your project and possibly delete DerivedData. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  We'll certainly look into this and get back to you @Khalian. Thanks! üçª Hi @Khalian,

I've just created an `Alamofire/Alamofire` chatroom with public permissions and I've just invited you to it. I'm going to add the badge to the README as well. We'll see if it ends up getting some use or not. Thanks for the suggestion!

Cheers. üçª  I'm researching what `flatMap` does to the `Result` types of other languages, but for now this use looks fine.

One thing I would also like to see, even if it's not strictly part of the functional paradigm, are closures which can access the `Result`'s error without transforming them. I've defined the following extensions in my last few projects:
```swift
@discardableResult
func onSuccess(_ success: (_ value: Value) -> Void) -> Result {
    if case let .success(value) = self { success(value) }
    
    return self
}

@discardableResult
func ifSuccess(_ success: () -> Void) -> Result {
    if isSuccess { success() }
    
    return self
}

@discardableResult
func onFailure(_ failure: (_ error: Error) -> Void) -> Result {
    if case let .failure(error) = self { failure(error) }
    
    return self
}

@discardableResult
func ifFailure(_ failure: () -> Void) -> Result {
    if isFailure { failure() }
    
    return self
}
```
I think something similar could be helpful, perhaps in combination with `.mapError` and `.flatMapError` or something.

@cnoon Any input here? My main concerns with `dematerialize` vs. `unwrap` are 1) translation between other `Result` types in Swift and ours, namely antitypical/Result, which already use `dematerialize`, and 2) supporting the symmetrical operation of `materialize`, which I'm not sure works well if it's just `wrap`. But that's fine.

We want this functionality, we just have to iron out the naming and how far we want to go. Because while it may be about better response handling for you @groue, making it easier to use `Result` in any scenario is a good idea. Thinking about it more, it would probably help interop if we used `wrap`/`unwrap` and let antitypical/Result use `materialize`/`dematerialize`, so I think I've just convince myself we're good there. Mostly naming at this point, as we want this functionality. We're already using a `Result` type, so its existence is beyond question, so this is mainly about what other functionality it should have. Hi @groue,

My apologies for not getting back to you sooner. I wanted to make sure I had time to dig through this before giving you some direction. üòâ 

I think you're right on point here. The only thing I've found that I "think" is incorrect is this code sample from your original post. Wouldn't this return `Int` or throw rather than returning a `Result<Int>` from the `unwrap`?

```swift
func f(_ data: Data) -> Result<Int> { ... }
let result: Result<Data> = ...
result.flatMap { try f($0).unwrap() } // Result<Int>
```

> Just making sure...

## Unwrap vs Dematerialize

As for unwrap vs. dematerialize...I'm much more of a fan of unwrap. Much more straightforward. Sounds like that's where all of you have landed anyways, so yay!

## Factory Method vs Initializer

As for the factory method or initializer, I'd vote initializer just like you posted in your last example.

```swift
let result = Result(value: { try Stuff(json: json) })
```

## Steps to Getting Merged

Now there are a few things we'll still need to get into this PR to get it merged.

### Result initializer

As mentioned before, let's get this added along with tests.

### Tests

Could we get tests for the `DataResponse` and `DownloadResponse`? You can just throw them into new test cases in the `Response.swift` for now.

> We're going to reorganize the test suite here at some point.

### Documentation

Let's also get the documentation added to the README. I think you need to be extra careful here though in regards to threading. You're example you posted is nice and convenient, it could be a huge bottleneck for large payloads being serialized on the main thread.

```swift
func getStuff(_ completionHandler: @escaping (DataResponse<Stuff>) -> Void)) {
    Alamofire.request("https://httpbin.org/get").responseJSON { response in
        completionHandler(response.flatMap { json in try Stuff(json: json) })
    }
}
```

While convenience is great, bad performance due to lack of understanding of what's running where is the last thing we want. Please be careful to point out these types of considerations when putting your documentation together.

Once you get the PR updated, please rebase on top of `master` (just to catch up) and we'll work to get this merged as part of the Alamofire 4.4.0 release.

Thanks again for all the hard work here and again our apologies for this being as delayed as it has been. üçª Okay @groue, I just squashed your PR down and made a few formatting and documentation tweaks and pushed it up into `master` in 7f8fe9c7 while maintaining your attribution. We can't thank you enough for all your great work here and persistence given the fact that it took us a long time to get this feature added in. I think it all paid off very well though given the final result.

These changes will ship as part of the Alamofire 4.4.0 release here shortly.

Thanks again! üçª  Hi @jakjothi,

Could you provide more data? Is it a specific type of request you're making? What version of Alamofire are you using? What does your `Podfile.lock` say? I've never seen anyone report that generating the metrics can fail, so I wonder if there's something unique that you're doing that is producing the issue.

Like I said, any more info you could provide could really help. Right now there's just not enough info to go on. If more people do end up having this issue though, we could make task metric generation optional in Alamofire. Okay @jakjothi, could you please give me a very clear, very descriptive breakdown of exactly what you're doing with the time settings to produce this error? The more description the better. Also, do you see this issue when you don't mess with the time settings? Since the core issue here seems to have been resolved in iOS 10.2, I'm closing this. Definitely something from the underlying networking frameworks here. If this crash recurs with the latest Alamofire and SDK version, please let us know.  Hi @payalbaldota,

I'm not really sure what to tell you here. We have [tests](https://github.com/Alamofire/Alamofire/blob/master/Tests/DownloadTests.swift#L485-L544) that verify cancelling a download and resuming it works as expected in Alamofire 4.x. I'd check out that test to see if you can identify what you may be doing wrong in the cancel / resume logic.

If that doesn't help, then I'd suggest you take your question to [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Hi @LYM-mg,

I'd suggest you open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  As [noted in our documentation](https://github.com/Alamofire/Alamofire#modifying-the-session-configuration), adding `Authorization` headers at the session level is not recommended. However, we'll investigate whether we need change anything. I was unable to replicate your results with this simple test:

```swift
let communicator: SessionManager = {
    var headers = SessionManager.defaultHTTPHeaders
    headers["Authorization"] = "Token"
    
    let configuration = URLSessionConfiguration.default
    configuration.httpAdditionalHeaders = headers
    
    return SessionManager(configuration: configuration)
}()
    
let goodSite = "https://httpbin.org/get"
let badSite = "https://httpbin.org/get"

communicator.request(goodSite, encoding: JSONEncoding.default).responseJSON { response in
    print(response)
}

communicator.request(badSite, parameters: ["key" : "value"], encoding: URLEncoding.default).responseJSON { response in
    print(response)
}
```
Both requests kept the `Authorization` header.

In any event, there's nothing Alamofire can do to the headers added through `httpAdditionalHeaders`, which is why we and Apple recommend adding the `Authorization` header a different way. 

Also, see my code for a more proper way to add custom headers to the `URLSession` while keeping the headers Alamofire generates for you, like `User-Agent`.  Thanks @muescha! üçª  Your observations are completely correct here @cmyers78. We've also found that challenges are not supported with background configurations. This is most likely so the daemon doesn't need to call back to the app each time a challenge is issued. This is not an Alamofire limitation, but a URL session one. If you'd like to see this behavior change, then I'd suggest filing a radar with Apple.

Cheers. üçª  Any support for `keep-alive` would come from the underlying `URLSession` APIs. Look into how to set it up there and applying those findings to Alamofire should be straightforward. Alamofire has no specific code for `keep-alive` support from the server. All of that would come from the underlying `URLSession` implementation, which should have support for it automatically, as it's part of the `HTTP` standard. Feel free to open a new issue if you run into any issues you can trace back to Alamofire. Otherwise, sites like StackOverflow or Apple's dev forums would be good sources of support for the underlying `URLSession` in regards to `keep-alive`. Yes, the Swagger code gen tool that's built on top of Alamofire is pretty poor quality and doesn't use Alamofire correctly in many ways. (The version built on top of AFNetworking has issues as well.) Modifying the generated code isn't really a solution, but perhaps you can modify the generator itself?  `eTag` is part of the underlying `URLSession` APIs used by Alamofire and we don't expose any high level APIs to interact with them directly. If you need direct control, I suggest you look into how they're normally exposed to the `URLSession` APIs and how they work in general. Supporting them should really be automatic or as simple as attaching a header like any other. Feel free to open a new issue if you run into issues that may be Alamofire bugs, otherwise general support from something like StackOverflow will probably answer the questions you have.  It depends on the `RequestEncoding` that you're using. If you're using `JSONEncoding` with a `GET` request, your parameters are being encoded into the `bodyData` as `JSON`, which sets the `Content-Type` header. If that's not the behavior your server expects, change `ParameterEncoding` you're using for those requests.  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Hi @WataruSuzuki,

Could you provide a detailed writeup of this set of changes, the problems you were trying to solve and how the tests verify the behavior? The more detail the better. This will not only be for our own knowledge, but for those in the future to refer back to this ticket.

Thanks! üçª Hi @WataruSuzuki,

First off let me apologize for taking so long to go through this. Your patience is appreciated. I can also say that I'm very glad I waited until I had enough time to go through this throughly. The tests took me forever to understand exactly what's happening across all the versions of all platforms.

With that said, thank you so much for your efforts here on this PR. It's greatly appreciated! I've picked this PR apart into a bunch of different commits to test all the functionality and for my own understanding. Here's a breakdown of what I've added and modified in this PR.

- 22fec473 - Added TLS evaluation tests for revoked certs for no policy and default policy.
  - Contributed by me
- 52fc15e1 - Added revoked evaluation server trust policy to check for revoked certificates.
  - Contributed by you (refactored a bit by me)
- e8282c98 - Added server trust policy tests for revoked evaluation with varied host validation.
  - Contributed by you (refactored revocation flag by me)
- 74f64733 - Added TLS evaluation tests for revoked evaluation against revoked certificate.
  - Contributed by you (tweaked by me slightly with revocation flag)
- 2fd49975 - Updated TLS tests for tvOS 10.1 and added expiration test for revoked evaluation.
  - Contributed by me

What I was amazed to find is that it appears Apple has started enabling automatic revocation testing in the latest platforms (iOS 10.1+), but the test suite is so finicky that I had to disable the tests. Thankfully on all platforms, enabling revocation testing directly does result in consistent behavior.

Through most of my testing, I think you really want to weigh the tradeoffs of using `kSecRevocationUseAnyAvailableMethod` and `kSecRevocationRequirePositiveResponse` depending on what type of certificates you have deployed. If you have certs signed by a valid certificate authority, I think I'd recommend using the more secure `kSecRevocationRequirePositiveResponse`. You'll see in the ServerTrustPolicy tests that I switched over to the `kSecRevocationUseAnyAvailableMethod` flag since all the certs being tested were self signed which will always fail when trying to hit the server since they're not deployed.

> Sadly the documentation here is terrible and isn't very helpful. Take what I said above with a grain of salt. That's my best guess interpretation of all these tests and the limited documentation I could find.

Overall, thank you so much for bringing the revocation testing to our attention and going the extra step to implement it. I think this is a great addition to the Alamofire core library and we really appreciate you taking the time to put this all together. Great work!

Just FYI...these changes will ship as part of Alamofire 4.3.0 here shortly.

Cheers. üçª  This should be working correctly. How are you checking that the headers are sent properly? Relying on the server response isn't enough, you should use a tool that can show you the raw request sent (like the `curl` output of the `request.debugDescription`) to see whether the headers are actually being attached. This behavior works correctly @aronmoles, we have several tests ([test1](https://github.com/Alamofire/Alamofire/blob/master/Tests/RequestTests.swift#L59-L74), [test2](https://github.com/Alamofire/Alamofire/blob/master/Tests/SessionDelegateTests.swift#L418-L470)) verifying this behavior. Many of us also have libraries built on top of Alamofire that pass common headers through all the time and everything works as expected.

If you continue to have issue, then I'd suggest you take your question to [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. There someone can help you investigate further. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  There are many ways you could solve this. One of the simplest would be to use `.validate`, as described in [our documentation](https://github.com/Alamofire/Alamofire#response-validation) to ensure the response type is an image rather than the type of the error page.  You need to figure out what your server expects for a parameter encoding during a `GET` and use the included `ParameterEncoding` type to encode your requests, or write your own if none of our provided encoders meet those requirements.

Also, if you all could post what types of servers you're connecting to, it would be interesting to see what servers/configurations can't handle body data in `GET`s. Okay everyone,

Just to clear the air here, you can absolutely send JSON parameters on a `GET` request with Alamofire if you really need to. Here's an example of it in action.

```swift
func testJSONParametersAreSentInHTTPBodyOfGetRequest() {
    let parameters: Parameters = [
        "key1": "value1",
        "key2": "value2"
    ]

    let expectation = self.expectation(description: "Get should succeed")

    let request = Alamofire.request("https://httpbin.org/get", parameters: parameters, encoding: JSONEncoding.default).responseJSON { response in
        if let body = response.request?.httpBody, let json = String(data: body, encoding: .utf8) {
            print("JSON sent in httpBody: \(json)")
        }

        print("Response: \(response)")

        expectation.fulfill()
    }

    debugPrint(request)

    waitForExpectations(timeout: 10.0, handler: nil)
}
```

Now, whether your server actually supports this or not is a different story. As you can see in the example, `httpbin.org` does not accept the parameters in the `httpBody` with a `GET` request. However, the data is still sent along with the request.

99.9% of the time your server will support `URLEncoding` instead. However, there are some servers out there that do require the parameters to be sent as JSON in the `httpBody` of a `GET` requests, but this is pretty rare and is generally only used in really complicated cases.

For more info, please see #1847 and #1530. Hopefully that helps clarify things a bit.

Cheers. üçª  You need to specify the `destination` closure. Otherwise the file isn't moved out of the temp directory and you don't have access to the data outside of your sandbox after the `SessionDelegate` API is called. See our [README](https://github.com/Alamofire/Alamofire#download-file-destination) for more info.

I just pushed up ffaa0718 which updates the README to hopefully make this more clear.

Cheers. üçª  You can't use frameworks using Swift 2.3 and 3.0 in the same project. Make sure your project is set to use Swift 3.

Otherwise, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Thanks for the work here, this is really interesting. We'll take a look and see how we'd like to integrate this sort of task.  Hi @skydivedan,

Given that the `AVAssetDownloadURLSession` must be initialized with a background configuration, I'd recommend steering clear of Alamofire for this logic right now. The current design of Alamofire makes it quite difficult to work with background sessions in any useful way if your app is being backgrounded and will be woken up when the app has been terminated in the background. There's no way to rewire up the closures you attached previously.

As to your more specific implementation issue, none of your tests will work because background sessions do not work in test suites as of Xcode 8.2.1. We've had to disable all our background session tests in Alamofire because of this bug. This has been the case with all the Xcode 8.x releases which our team pointed out to the Apple engineers at WWDC but it still has not been resolved.

I pulled down your project and ran the test and I see the same issue you're running into. I can't really explain why that `as?` check doesn't work. What I'd try at this point is to create a sample app that runs essentially the same test since the background session stuff doesn't work in test targets. I would guess that you'll have more luck there.

I've added a task to our Trello backlog to investigate this more for AF5. This is something that I think could be useful in Alamofire core, but we need to come up with a better design and strategy for background sessions in general before adding support here.

I'm going to close this issue out for now, but if you would be so kind as to post your findings back here if you make any headway I'd greatly appreciate it. Then we may be able to use some of your findings if we decide to implement this directly into Alamofire in the future.

Cheers. üçª  Could you provide some more detail here @AndrewSB? What exactly would you like to discuss? What exactly is holding you up from the Moya perspective?  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Handling of `204` (and `205`) response codes are done at the `ResponseSerializer` level. If you need to customize that behavior, you can write your own type that conforms to the `ResponseSerializer` protocol. However, the core of the `Result` type (and others) are the notion that requests either succeed or fail and do not fall into some strange third state. That's a fundamental part of Alamofire's response architecture and won't be changed. I suggest you just add special logic to your `.success` case to handle the `204`s unless you want write your own `ResponseSerializer`. I'm not sure what you're talking about here. There is no `default` case when using Alamofire's `Result` type. Or are you implementing some sort of switch around the `HTTPURLResponse` received as part of the `DataResponse`? While you can use that value, it's much better make use of the `Result` that's returned instead. What's your actual calling code?  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  Thanks for the report, we'll try to get this fixed soon. üçª  @jshier any chance you could take a look at this? I remember we had some issues with this in the past. Looks like they crept back in. @benediktreichert Looks like a regeneration was all it needed. It should be working now.

@cnoon Were there any doc related changes you wanted to make? Looks like we're good here, as it was an internal CocoaDocs issue as far as I can tell. No Alamofire changes needed.   I just verified that this change is not necessary in Xcode 8.2. If there is something that I'm missing here, please let me know. For now though I'm going to close this out.

Thanks anyways! üçª  While I question the need to do you own testing on a class Alamofire provides, since we already have testing for it, thanks for the report. We'll investigate. Cheers! üçª  Thanks for letting us know @SlashDevSlashGnoll. You are absolutely right, it was not set up correctly at all. Upon further investigation, we realized we never should have made the class `open` in the first place. This is not a feature that we really want people customizing. Therefore, I moved it back to a `public` ACL in 779930c3.

If you need to "proxy" the functionality for testing, you'll want to create a proxy protocol and have the `NetworkReachabilityManager` conform to it. Then you can customize everything you need for your own internal testing.

This change will go out as part of the 4.3.0 release here shortly. 

Thanks again! üçª  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.  We'd need more code context to be sure, but unexpected cancellation is usually caused by your manager going out of scope and being deallocated, causing any active requests to be cancelled. However, that doesn't appear to the the case here. Without more context it's hard to be sure. Hi @gaoshanyu,

I think you're misunderstanding how cancellation and resumeData work together. Just because you cancel a request does not mean that `resumeData` will be generated. It is only generated if iOS is at a point where the resume data can actually be generated. For example, if the request hasn't received a response and started receiving the stream of data, then iOS won't generate resume data for the request.

In these cases, you need to hold onto the resume data if it was generated, or simply restart the entire request if it doesn't exist.

Hopefully that helps clarify things.

Cheers. üçª  The appropriate place to set these values are on your `SessionManager`'s `sessionDelegate` property, not the individual delegate classes.  If you can find a way to replicate this issue beyond that one device, we'll be happy to take a look. Otherwise it seems like an issue with that device or a bug in Apple's underlying networking implementation.  Thanks @lucatorella! üçª  `Download` and `Data` tasks from the underlying `URLSession` APIs are siblings, no descendants, so it makes the most sense for our requests types to do the same.   Which type of authentication? It's a known limitation of Basic-Auth that there is no standard for encoding usernames or passwords beyond the `ISO-8859-1` character set. Therefore, server and client implementations differ on accepted character sets. Alamofire is limited by Apple's underlying network library in this regard.  Most likely you need to update your CocoaPods specs repo by do a `pod repo update` or updating Alamofire using `pod update Alamofire`.   We're most likely going to decline this PR, as allowing the swapping of `SessionManager`s could break the entirety of Alamofire, but we are interested in exactly what extension points are desired here. That way we can evaluate where such extension should be happening.   Good call @pontus-andersson! I made some small formatting tweaks to your PR and pushed them into `master` in ab0c7679 while keeping your attribution.

Thanks again! üçª
  Hi @noear,

When you get redirected, you can get the original URL from the `response.request` and the redirected URL from the `response.response`.

``` swift
let redirectURLString = "https://www.apple.com/"
let urlString = "https://httpbin.org/redirect-to?url=\(redirectURLString)"

Alamofire.request(urlString).response { response in
    let originalURL = response.request?.url
    let redirectURL = response.response?.url
}
```

Hopefully that helps answer your question. If Google Translate utterly failed me and I didn't answer your question, please translate into English so we can better understand.

Cheers. üçª
  Okay @rastersize, thanks for making the time to put this together! 

I squashed your changes, made a few minor tweaks and pushed them into `master` in commit 19e5012a. I also removed your change to make the `AdaptError` public. That error should definitely not need to be public which led me to investigate some more as to why you thought you needed to do that.

Once I dug in more, I realized that throwing an `Error` in the adapter wasn't working quite right. The retrier was being called correctly, but was being sent the `AdaptError` instead of the underlying error like it was supposed to. The idea is that if you throw an `AuthenticationError.expiredAccessToken` in your adapter, then the retrier error will also be an `AuthenticationError.expiredAccessToken`. You should NEVER see an `AdaptError` in any of the public Alamofire APIs. If you do, it is a bug. I've fixed the underlying issue and added tests to ensure everything is working properly in d2826a11. This should resolve the need for you to ever need the `AdaptError` to be public.

If there's still something I'm missing here, please don't hesitate to reach out. This logic is brand new and it's possible there's still a kink or two. I "think" at this point the logic should be pretty solid. Regardless, if you see anything that seems a bit odd, just assume it is and please file an issue. On a different note, these changes should be released within the next few days.

Thanks again! üçª
  Hi @bschron,

I'd suggest you open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @soxjke,

I'm sorry that your use of Alamofire led you to a rejection with Apple. In Alamofire, we've strived to support the same functionality as Apple does in their [Reachability](https://developer.apple.com/library/content/samplecode/Reachability/Introduction/Intro.html) example app which **IS** IPv6 compliant as is clearly called out in their [README](https://developer.apple.com/library/content/samplecode/Reachability/Listings/ReadMe_md.html#//apple_ref/doc/uid/DTS40007324-ReadMe_md-DontLinkElementID_11). There's a lot of history around this particular logic and it being IPv6 compliant in #1228.

We've also tried to clearly call out exactly what you're calling out in this ticket in our [README](https://github.com/Alamofire/Alamofire#network-reachability) section covering reachability. It is important for anyone using the Alamofire reachability system to understand how it should be used, and we've tried to do our best with that in the documentation. Unfortunately, we can't "make" everyone read the documentation before they start using Alamofire and that can lead to these types of issues.

If you don't mind me asking, did you read the documentation about reachability before implementing it? If yes, was it not clear? Is there something else we can do better there? We don't want anyone to get rejected, but there are legit uses of the zero address approach so we'd rather not remove it.

Cheers. üçª
  You need to define `destination` on all platforms except macOS. Otherwise you won't be able to access the file's data since it is outside of your sandbox. Moving it into the Documents directory before you use it should work fine.

Cheers. üçª
  Any particular reason you aren't using the `MultipartFormData` support built into Alamofire already? That would certainly make this much easier for you. As for your image count issue, I have no idea. There's nothing that Apple is going to do with the above request to make it "not work". The only thing it "might" do is kill your app because you are using too much memory, although that does not sound like the case here.

You'll need to debug with your platform to see why sending 2 images works and 3 doesn't. There's no kind of limit specifically in Alamofire to stop you from doing this.

Best of luck! üçª
  Good observation @rastersize. You have some really good suggestions here and I agree that all your assumptions are correct. I'm actually working through essentially the same exercise you are right now for my company's network stack. I have a few different ideas here on what you can do.

## Solution

First off, I think the correct solution here is to override the `Request` `request` property in the subclasses by doing something like this:

``` swift
class DataRequest: Request {
    open override var request: URLRequest? {
        let taskRequest = super.request

        guard taskRequest == nil else { return taskRequest }
        guard let originalTask = originalTask as? Requestable else { return nil }

        return originalTask.urlRequest
    }
}
```

This will give you access to the upcoming `urlRequest` when the task is actually created which should solve your problem. I'll try and get that put together today into a PR for you to try it out.

## Other Approaches

### Different Session Managers

What I'd also suggest you think about is using a different `SessionManager` and `Adapter` / `Retrier` per authentication system. That way you don't actually have to inspect the incoming request if it's coming into your `Retrier`. You just know that it needs to be refreshed since that request is paired with your retrier.

### Pass the Host through the Error

If you don't want to split them up like that (that's how I'm doing it in our library), then you will need to pass the host through with your `missingAccessToken` (maybe consider `expiredAccessToken`?) error like you posted. That will certainly work for now until I can get the `request` properties overridden. 

Would that be something you'd like to take on and put in a PR for? I'm pretty swamped right now and might struggle to get the changes made today. I'd really appreciate if you could take a stab at this if that would be possible. We'll need to override the Data, Download and Upload Request properties and then write some tests to verify they work as expected.

Cheers. üçª
 Closing this issue out since PR #1792 has been submitted. Please direct all further comments to #1792.

Cheers. üçª
  You could use Alamofire's parameter encoding in this case, but it's certainly overkill. If you don't have any user provided data and you know `data` is properly URL encoded, then you can just build your URL exactly as you are.

If you need to encode `data` prior, then it's probably easier to use `URLComponents` and `URLQueryItem` to do the escaping. It also saves you an Alamofire dependency.
  You need to use `www.apple.com` as the host. It gets all screwed up when you throw the scheme in there.

Cheers. üçª
  Alamofire 4 supports Swift 3 and has for months.
  You cannot at the moment. We're bringing back iOS 8 and macOS 10.10 support in Alamofire 4.1.0 which should release today or tomorrow due to Apple removing Swift 2.3 support sooner than we expected.

Cheers. üçª
  This issue is fixed in the `master` branch and will be released shortly as Alamofire 4.1.0.

Cheers. üçª
  We have several [integration tests](https://github.com/Alamofire/Alamofire/blob/master/Tests/DownloadTests.swift#L133-L175) that verify this behavior works correctly @liudanking. I can't see anything obvious off-hand as to what's not working here, but I'd definitely look at that example for guidance.

If you continue to have issues, I'd suggest you either open a question on Stack Overflow, or you post up a sample project that demonstrates your issue so we could help you debug the problem.

Best of luck! üçª
  Hi @samirae,

I'd suggest you open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @llliang,

I'd suggest you open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  This PR reverts back to deployment targets of iOS 8.0 and macOS 10.10 due to Apple dropping Swift 2.3 support post Xcode 8.2. We still need to update some of the documentation to support this change, but all the test suites are passing on all supported platforms. Great catch @jjulian! Fixed in a352f1fb.
  We added such a feature in Alamofire 4, please read our [documentation about it](https://github.com/Alamofire/Alamofire#adapting-and-retrying-requests) if you'd like more information.
  Wouldn't the low latency itself be an indicator that it came back from cache? I suggest you ask this on [Stack Overflow](https://stackoverflow.com), you'll likely get better ideas there.

Cheers. üçª
 @Khalian I just realized that, if you're running on the latest OSes, the `URLSessionTaskMetrics` contained one each response will have the information you're looking for. See our [Migration Guide](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%204.0%20Migration%20Guide.md#task-metrics) for more info.
  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Your custom manager is being deallocated when it goes out of scope, leading the request to be cancelled and the response nil. Ensure you're keeping a reference to your manager somewhere, such as a singleton, like the `default` `SessionManager`.
  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  That depends entirely on why the server is returning a 500 response, you'll need to get more information there.

We use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  The generic error parameter was removed from the `Result` definition because all underlying errors from the Apple frameworks and Alamofire itself are captured as the `Error` type (a change required by Swift 3). So you can still use your custom error type just fine, you just have to extract it by casting to the appropriate type when you want to interact with it. I'm guessing with the appropriate generics it will still work.

Otherwise, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Yes, you need to keep a reference to the manager you're using, as when it falls out of scope and is `deinit`d all of your pending requests are cancelled, leading to the error you see.

We use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Thanks for helping @eimantas. Cheers! üçª 
  Hi @DrAma999,

First off, there's no way we will be porting Alamofire 3.x to Swift 3. That wouldn't make sense for us to do and would be a huge amount of work. Instead, we've decided that we're going to add support for iOS 8 and macOS 10.10 in Alamofire 4 since Apple is going to deprecate Swift 2.3 sooner than we thought. Please see #1774 for more info.

I'm going to close this issue out. Please redirect all further comments to #1774.

Cheers. üçª
  These types of compiler errors are usually caused by type issues, so double check the types of all of your parameters.

However, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Thanks @julien-c! üçª
  Alamofire does not currently support `multipart/mixed` formatting @tylerlong. It's in our backlog, but is not very high on the priority list unfortunately. If you end up making some progress here and would be interested in pushing it back into Alamofire, we'd certainly be open to that!

Cheers. üçª
  Errors like this are usually caused by the `SessionManager` you created falling out of scope and being `deinit`d, causing your requests to be cancelled. Keep a reference to it, like the singleton used by the `Alamofire` methods, and it will work just fine.
  I would suggest creating your own response serializer that does that string remapping for you, as [outlined in our documentation](https://github.com/Alamofire/Alamofire#custom-response-serialization).

Please note that we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  This is the same leak as seen in #1717. It's likely an underlying Swift library leak that we can't do anything about but we're investigating.
  Sorry, @amjad401 but we can't diagnose integration issues like this, Stack Overflow is the best place for these types of issues.
  @CompassCanJV You shouldn't need to point to a specific tag, `pod 'Alamofire'` should work just fine. 

In general, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @kakilan,

You can't load that much data into your app at once. You're app is being terminated by iOS because you're running out of memory. Instead, you need to add the video to the multipart form data using a URL. That way the data is streamed into a temporary file before it's uploaded to the server.

``` swift
if let video = self.avPlayerItem?.asset as? AVURLAsset {
    multipartFormData.appendBodyPart(
        fileURL: video.URL, 
        name: "video", 
        fileName: "video", 
        mimeType: "video/mp4"
    )
}
```

Cheers. üçª
  @dipsvaishnav By your errors it's clear you're either trying to build Alamofire using Xcode 7 or Xcode 8 using Swift 2.3. Update your Xcode or switch your project to the appropriate version.
  See #1367 for our reasoning as to why we dropped iOS 8 support.
  @preraksola Please review our [Security](https://github.com/Alamofire/Alamofire#security) documentation, as it should have the info you need to allow self signed certificates.
  Without more info, it's hard to tell what's going on here. Most likely though, this error indicates an issue with the response from the server, at a lower protocol level than Alamofire has anything to do with. 

Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @michallaskowski, we're looking to tag AF 4.1.0 on Monday at the latest.

Cheers. üçª
  There isn't a lot Alamofire can do for you here aside from supporting automatic request retries and adaptation. There are a variety of frameworks out there for building asynchronous architectures. It just depends on what other features you may want. But this isn't the place for overall app architecture questions, unfortunately.

Perhaps asking this question on [Stack Overflow](https://stackoverflow.com) would help.

Cheers. üçª
  I'm going to close this issue out since #1735 has been merged. The 4.1.0 release will be released shortly. Thanks for everyone's patience here.

Cheers. üçª
  Can you point to any sort of standard the defines the behavior we should see with this?
 Hi @xspyhack,

Thank you for all the information here. I didn't realize this was such a problem in China. While I completely understand your approach, this is a bit too specific for us to put directly into Alamofire. What I'd recommend instead is subclassing the `ServerTrustPolicyManager` and creating a mapping between your certificate hostnames and ip address it maps to. Then use the ip address to define the policy to use for evaluation. Here's a quick example of how this could work:

``` swift
class IPServerTrustPolicyManager: ServerTrustPolicyManager {
    let hostToIPMap: [String: String]

    init(policies: [String: ServerTrustPolicy], hostToIPMap: [String: String]) {
        self.hostToIPMap = hostToIPMap
        super.init(policies: policies)
    }

    override func serverTrustPolicy(forHost host: String) -> ServerTrustPolicy? {
        guard let ip = hostToIPMap[host] else { return nil }
        return policies[ip]
    }
}
```

Then you can use it like so:

``` swift
class BaseTestCase: XCTestCase {
    func testPolicyManager() {
        let manager = IPServerTrustPolicyManager(
            policies: [
                "192.168.0.1": .performDefaultEvaluation(validateHost: true)
            ],
            hostToIPMap: [
                "*.example.com": "192.168.0.1",
                "test.example.com": "192.168.0.1",
            ]
        )

        let sessionManager = SessionManager(serverTrustPolicyManager: manager)

        // TODO: make some requests...
    }
}
```

Hopefully that all makes sense. Please let me know if that won't actually work for your use case, but I'm pretty confident that it will.

Cheers. üçª
 Okay @xspyhack I think you want to read between the lines here a bit. My example was simply showing you how you could start to provide a more robust lookup system. These use cases are way outside of what Alamofire has committed to supporting directly, but Alamofire does not stop you from being able to handle these cases.

You'll need to create a custom `ServerTrustPolicyManager` to allow you to map the `host` to the `ServerTrustPolicy` that you want to use. This might be pretty complicated in your use case. From there, you need to customize the evaluation as necessary by toggling certain evaluations. For example, `.performDefaultEvaluation(validateHost: false)` would probably be what you're looking for. Although you obviously have to be REALLY careful about these types of things since you can really be opening yourself up.

You could also switch over to using your own custom evaluation based on your use case. Overall, you have all the tools in front of you. Alamofire will not support such a complex use case directly, but it absolutely supports the ability for your to extend the base functionality to accomplish this.

Best of luck! üçª
  Hi @ricardopereira,

Thanks for opening up this issue. I've just pushed up 9688b16f into `master` which automatically removes the temp file from disk after the upload completes. This will be part of the Alamofire 4.1.0 release which should be out by Monday.

If you're not using the latest version of Alamofire, you could manually delete the file like so in a `response` handler.

``` swift
Alamofire.upload(
    multipartFormData: { multipartFormData in
        multipartFormData.append(unicornImageURL, withName: "unicorn")
        multipartFormData.append(rainbowImageURL, withName: "rainbow")
    },
    to: "https://httpbin.org/post",
    encodingCompletion: { encodingResult in
        switch encodingResult {
        case .success(let upload, _, streamFileURL):
            upload.responseJSON { response in
                debugPrint(response)

                // This is how you can remove the file
                if let streamFileURL = streamFileURL {
                    do {
                        try FileManager.default.removeItem(at: streamFileURL)
                    } catch {
                        print("Failed to remove stream file at URL: \(streamFileURL) - error: \(error)")
                    }
                }
            }
        case .failure(let encodingError):
            print(encodingError)
        }
    }
)
```

Cheers. üçª
 Great call @ricardopereira! I just pushed up e68bfdcc which will automatically delete the temp file in the event of a failure. Unfortunately there's no way to do this in the 3.x version of Alamofire.
  We're not seeing this issue anywhere. From the linked SwiftyDropbox report, it looks like the crash is actually occurring in `DispatchQueue`'s `init` method, with some sort of `objc_msgSend`. We'll investigate.
 This is not something we've been able to reproduce on our end with our Alamofire sample app running iOS 10.1.1 on device against Xcode 8.1 in a release build. At this point, we're going to need someone to post up a sample project that demonstrates the issue since there's nothing else we can do here. We can't reproduce the issue no matter how hard we try.

I'm going to close this issue out for now. If someone can post more information or a sample project, we'll happily re-open and investigate further.

Cheers. üçª
  Looks like an underlying issue in the Swift standard library, likely what we saw in #1686. We'll investigate and decide what to do. @cleverliz Could you provide more info? Alamofire version, optimization settings, device, etc. A full stack trace that we can use in a report to the Swift project would be great too. 
 Hi @cleverliz and @WishWei, we have been unable to reproduce this crash on our end at all. Would either of you be able to create a sample app that reproduces the issue? Without it, we don't have anything else left to investigate. I've tried debugging this in the simulator and on a device with varying optimization levels to no avail.

I don't want to submit a bug to the Swift project until we have a way to definitively reproduce it on our end first. If you could provide us with a sample project, then we'll be happy to investigate this further.

I'm going to close this issue out for now. If you provide more info, then we'll happily re-open and investigate further.

Cheers. üçª
  As @phoney mentioned @JunDang, just comment out the closure and rebuild it using the new AF4 syntax. For more info, please refer to the [migration guide](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%204.0%20Migration%20Guide.md#data-request---complex-with-url-string).

In the future, I'd suggest you open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Sorry, no SOAP support in Alamofire. I'm truly sorry if you have to use such a service.

We use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  This PR fixes the one new warning in Xcode 8.1 that was due to the new handling of optionals implicitly cast as `Any`. It also adopts the new project settings suggested by Xcode.
 This looks @jshier! üçª
 There aren't warnings in the project anymore. You must have something else going on. Possibly clean and wipe derived data? What are you seeing as an error @Harmonium? Screenshot? What version of Xcode are you running? We only support Xcode 8.1 currently. If you're running a beta that is producing those errors, then that's the problem. There are no warnings using Xcode 8.1 and the latest Alamofire release. If you see any new ones, please open a new issue with the exact warnings you're seeing and the lines in Alamofire that trigger them Cast them as `Any` and be done with it or put them into string values that are then printed.  Thanks @carlosmcevilly! üçª
  We're going to need a lot more context here. What OS? What does the call site look like? Can you create a demo project that replicates the issue? What's the full crash stack? Why does that screenshot show so many threads?
 We don't need your exact code, but an example of your calling code would be very helpful, especially showing how you're doing the polling, so we can try to replicate your issue. That would be the biggest part. 

Running with additional diagnostics enabled may help you narrow it down, like the thread sanitizer or memory sanitizer, to ensure there isn't some other issue occurring here. It would be unusual for something in Alamofire to trigger a `EXC_I386_GPFLT` error.
 Thanks for getting back to us @dmontay. üçª
  This will be fixed once #1735 is merged.
 I'm going to close this issue out since #1735 has been merged. The 4.1.0 release is forthcoming.

Cheers. üçª
  Sorry, this isn't meant as a public API, just a convenience internal to Alamofire. You can replicate the effect by using `DispatchQueue.global(qos: .utility)`. I've updated the migration guide in #1736.
  There is no `JSON` type in Swift. If you want to return your own `JSON` type or one of the various `JSON` types from third party libraries, you can do so by creating a custom response serializer, as [our documentation lays out](https://github.com/Alamofire/Alamofire#creating-a-custom-response-serializer). 
  Thank you everyone for helping each other out here. In the future I'd suggest moving this type of question to Stack Overflow. I'm going to go ahead and close it out for now since there's no actionable Alamofire issue here.

Please feel free to continue your investigation here.

Cheers. üçª
  You need to update your spec repo: `pod repo update`. Or just run `pod update`.
 You can follow those directions to diagnose your issues. Most likely the specs repo is a bit overloaded at the moment and GitHub is timing it out. 
  This looks more like a CocoaPods issue and we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com).

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
 It's not a problem with Alamofire, many people can install from CocoaPods just fine. You need to update your specs repo. 
  That's incorrect, that file is only necessary for projects publishing podspecs with Swift 3 code. For pod consumers, CocoaPods uses the Swift version defined in your project to set it for the Pods project. 

@nikkibeats Makes sure you're using the `*.xcworkspace` file created by CocoaPods and not your `*.xcodeproj`.

If that doesn't work, I'm sorry but we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Thanks @ILI4S...much appreciated! üçª
  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  I am having an issue with my HTTP request using Alamofire. When I try to reproduce the issue with the XCode debugger it does not crashes but when I archive the app and run the .ipa file on my iPad with ios 10.0.2 I always get a crash.

This is an example of a call that crashes when running the arhived app:

```
#static func loginOnServerUrl(serverURL: String, user: String, password: String,
        successCallback: ((JSON) -> Void)? = nil, failureCallback: ((Error) -> Void)? = nil){

            let params = [
                ApiParams.ACTION : "login",
                ApiParams.LoginParams.USER : user,
                ApiParams.LoginParams.PASSWORD : password,
            ]

        Alamofire.request("http://\(serverURL)/AppSrv", method: .get, parameters: params).responseJSON { response in
                switch response.result {
                case .success(let value):
                    //JSON raiz
                    let json = JSON(value)

                    for (key, value) in json.acceptingSigleValueAsArray {
                        log("\(key) : \(value)")
                    }


                     if let successCallback = successCallback {
                         successCallback(json)
                     }


                case .failure(let error):
                    log(error.localizedDescription)
                    if let failureCallback = failureCallback {
                        failureCallback(error)
                    }
                }
            }
    }
```

This is one of the crash logs I am getting:

```
Incident Identifier: ****
CrashReporter Key:   *****
Hardware Model:      iPad5,2
Process:             ****
Path:                ****
Identifier:         ****
Version:             1.42 (1.2.3a)
Code Type:           ARM-64 (Native)
Role:                Foreground
Parent Process:      launchd [1]
Coalition:           ****


Date/Time:           2016-10-21 10:16:08.9811 +0200
Launch Time:         2016-10-21 10:16:06.2504 +0200
OS Version:          iPhone OS 10.0.2 (14A456)
Report Version:      104

Exception Type:  EXC_BAD_ACCESS (SIGSEGV)
Exception Subtype: KERN_INVALID_ADDRESS at 0x000000059480bec8
Termination Signal: Segmentation fault: 11
Termination Reason: Namespace SIGNAL, Code 0xb
Terminating Process: exc handler [0]
Triggered by Thread:  0

Filtered syslog:
None found

Thread 0 name:  Dispatch queue: com.apple.main-thread
Thread 0 Crashed:
0   libswiftCore.dylib              0x0000000100e19b6c 0x100c38000 + 1973100
1   myapp                           0x00000001000c4d88 static ServerManager.(pingOnServerUrl(serverUrl : String, successCallback : (Int64) -> ()?, failureCallback : (Error) -> ()?) -> ()).(closure #1) (ServerManager.swift:0)
2   Alamofire                       0x00000001003aca84 specialized DataRequest.(response<A where ...> (queue : DispatchQueue?, responseSerializer : A, completionHandler : (DataResponse<A.SerializedObject>) -> ()) -> Self).(closure #1).(closure #1) (ResponseSerialization.swift:0)
3   libdispatch.dylib               0x00000001889f1200 _dispatch_call_block_and_release + 24
4   libdispatch.dylib               0x00000001889f11c0 _dispatch_client_callout + 16
5   libdispatch.dylib               0x00000001889f5d6c _dispatch_main_queue_callback_4CF + 1000
6   CoreFoundation                  0x0000000189b15f2c __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 12
7   CoreFoundation                  0x0000000189b13b18 __CFRunLoopRun + 1660
8   CoreFoundation                  0x0000000189a42048 CFRunLoopRunSpecific + 444
9   GraphicsServices                0x000000018b4c5198 GSEventRunModal + 180
10  UIKit                           0x000000018fa15628 -[UIApplication _run] + 684
11  UIKit                           0x000000018fa10360 UIApplicationMain + 208
12  myapp                           0x00000001000bf024 main (AppDelegate.swift:16)
13  libdyld.dylib                   0x0000000188a245b8 start + 4

Thread 1:
0   libsystem_kernel.dylib          0x0000000188b36a88 __workq_kernreturn + 8
1   libsystem_pthread.dylib         0x0000000188bf936c _pthread_wqthread + 1452
2   libsystem_pthread.dylib         0x0000000188bf8db4 start_wqthread + 4

Thread 2:
0   libsystem_kernel.dylib          0x0000000188b36a88 __workq_kernreturn + 8
1   libsystem_pthread.dylib         0x0000000188bf936c _pthread_wqthread + 1452
2   libsystem_pthread.dylib         0x0000000188bf8db4 start_wqthread + 4

Thread 3:
0   libsystem_pthread.dylib         0x0000000188bf8db0 start_wqthread + 0

Thread 4:
0   libsystem_pthread.dylib         0x0000000188bf8db0 start_wqthread + 0

Thread 5:
0   libsystem_kernel.dylib          0x0000000188b36a88 __workq_kernreturn + 8
1   libsystem_pthread.dylib         0x0000000188bf936c _pthread_wqthread + 1452
2   libsystem_pthread.dylib         0x0000000188bf8db4 start_wqthread + 4

Thread 6 name:  com.apple.uikit.eventfetch-thread
Thread 6:
0   libsystem_kernel.dylib          0x0000000188b1816c mach_msg_trap + 8
1   libsystem_kernel.dylib          0x0000000188b17fdc mach_msg + 72
2   CoreFoundation                  0x0000000189b15cec __CFRunLoopServiceMachPort + 192
3   CoreFoundation                  0x0000000189b13908 __CFRunLoopRun + 1132
4   CoreFoundation                  0x0000000189a42048 CFRunLoopRunSpecific + 444
5   Foundation                      0x000000018a550b1c -[NSRunLoop(NSRunLoop) runMode:beforeDate:] + 304
6   Foundation                      0x000000018a57160c -[NSRunLoop(NSRunLoop) runUntilDate:] + 96
7   UIKit                           0x000000019038ac7c -[UIEventFetcher threadMain] + 136
8   Foundation                      0x000000018a64e50c __NSThread__start__ + 1024
9   libsystem_pthread.dylib         0x0000000188bfb860 _pthread_body + 240
10  libsystem_pthread.dylib         0x0000000188bfb770 _pthread_body + 0
11  libsystem_pthread.dylib         0x0000000188bf8dbc thread_start + 4

Thread 7 name:  com.apple.NSURLConnectionLoader
Thread 7:
0   libsystem_kernel.dylib          0x0000000188b1816c mach_msg_trap + 8
1   libsystem_kernel.dylib          0x0000000188b17fdc mach_msg + 72
2   CoreFoundation                  0x0000000189b15cec __CFRunLoopServiceMachPort + 192
3   CoreFoundation                  0x0000000189b13908 __CFRunLoopRun + 1132
4   CoreFoundation                  0x0000000189a42048 CFRunLoopRunSpecific + 444
5   CFNetwork                       0x000000018a22fcec +[NSURLConnection(Loader) _resourceLoadLoop:] + 336
6   Foundation                      0x000000018a64e50c __NSThread__start__ + 1024
7   libsystem_pthread.dylib         0x0000000188bfb860 _pthread_body + 240
8   libsystem_pthread.dylib         0x0000000188bfb770 _pthread_body + 0
9   libsystem_pthread.dylib         0x0000000188bf8dbc thread_start + 4

Thread 0 crashed with ARM Thread State (64-bit):
    x0: 0x0000000170246c30   x1: 0x0000000170246c30   x2: 0x0000000000000008   x3: 0x0000000188b7c250
    x4: 0x0000000100e099a4   x5: 0x0000000100df14f8   x6: 0x0000000000000065   x7: 0x0000000170287c78
    x8: 0x000000059480bea8   x9: 0x0000000ffffffff8  x10: 0x0000000000000001  x11: 0xbaddc0dedeadbead
   x12: 0x0000000000000177  x13: 0x0000000000000177  x14: 0x0000000100be6a30  x15: 0x0000000000000000
   x16: 0x0000000100e19b54  x17: 0xb000000000000003  x18: 0x0000000000000000  x19: 0x0000000000000000
   x20: 0x0000000100e94060  x21: 0x00000001ae195ef8  x22: 0x000000017046cf40  x23: 0xb000000000000003
   x24: 0x0000000000000000  x25: 0x0000000000000000  x26: 0x0000000000000004  x27: 0x0000000100be6a30
   x28: 0x0000000170246c30   fp: 0x000000016fd46b60   lr: 0x00000001000c4d88
    sp: 0x000000016fd46870   pc: 0x0000000100e19b6c cpsr: 0x20000000
```
 I am getting EXC_BAD_ACCESS(code=1, address=...) in ResponseSerialization.swift (line 159)

`(queue ?? DispatchQueue.main).async { completionHandler(dataResponse) }
`
 same as
https://github.com/Alamofire/Alamofire/issues/1637
 By default, frameworks integrated using CocoaPods get an optimization level of `-O`, whereas Swift apps now default to `-O -whole-module-optimization`. Perhaps this mismatch is causing issue? I make all of my pods have whole module optimization by using this post install hook:

``` ruby
post_install do |installer|
  installer.pods_project.targets.each do |target|
    target.build_configurations.each do |config|
      if config.name != 'Debug'
        config.build_settings['SWIFT_OPTIMIZATION_LEVEL'] = '-Owholemodule'
      else
        config.build_settings['SWIFT_OPTIMIZATION_LEVEL'] = '-Onone'
      end
    end
  end
end
```

Let us know if this fixes the issue for you.
 Finally was same of https://github.com/Alamofire/Alamofire/issues/1637
I solved it by setting the Release optimization level to same as the main target (`Fast, Single-File Optimization`)
 Hi @Tindi 

Inside XCode>project settings>Build Settings. Try to find the keyword 'optimization'. 
Then change the value for key 'Optimization Level'>'Release'. You have to put the same level in your project target and in the module Alamofire.

For testing that it works correctly run your app with 'Release' scheme (same as when it is uploaded to AppStore).

![upload](https://cloud.githubusercontent.com/assets/10388796/20560380/56b77320-b179-11e6-9981-30076202f234.jpg)
  Thanks for the report! I can see the same leaks you are. However, they appear to be in the underlying Swift libraries and not strictly from Alamofire's code, so I don't think there's much we can do about it. But I'll look into it further.
 These are also leaks that aren't detected by the Instrument's Leaks template, so I'm not entirely sure they're real. 
 I've been able to detect @hammyhamza's leaks using the Leaks instrument now (strange). However, I don't see anything like what @windyit08's screen shot shows. @windyit08, can you open a new issue with those leaks, if you can trace them to Alamofire's code? When you do, please state what OS, version of Alamofire, and version of Xcode you're using.

I'm not sure there's anything to do here, as these leaks seem to be in the Swift core libraries. @cnoon?
 @jshier and I chatted in Slack about what to do here. He's going to file a bug with the Swift project.
 @jshier could you file this bug when you get a chance? I want to make sure we get this filed with the Swift team. Hopefully they'll be able to fix it.
 I've confirmed from other projects that this is a false positive from the leaks tool. I'm working to see if I can workaround it like they did by reordering the variable declarations as well as filing a bug with Apple. I can no longer replicate these leaks using Xcode 8.2. Please, anyone who saw such leaks, please retest using the latest tools and open a new issue if you believe you've found a new leak.  No, Alamofire supports the same compression formats as the underlying `URLSession` networking APIs, which I don't believe includes Brotli.
  Sorry, we use our GitHub project for bug reports and feature requests. In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  The below head request was throwing following error   

**responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.inputDataNilOrZeroLength)**

```
  Alamofire.request(AppConstants.musicFileURL + musicFilename, method: .head, parameters: nil, encoding: JSONEncoding.default, headers:headers)

            .responseJSON { responseStr in

                print("HEAD \(responseStr)")

                //print FAILURE: responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.inputDataNilOrZeroLength)

                guard responseStr.result.isSuccess else {
                    return
                }
        }
```
 Thanks for the report! HEAD requests are just rare enough to get through our testing in this instance. We'll work on an update this weekend.
 @jshier has put together #1775 to address this issue. We're not going to pull this PR into the Alamofire 4.1.0 because we still have some backwards compatibility issues to work out. However, I'd like to close this issue out and have everyone redirect all further comments to #1775.

Thanks everyone! üçª
  Yes, it appears `lldb` prints the raw string, making it unusable in the terminal. You can either strip the raw newlines or use: `expr print(request.debugDescription)` to get usable output. Unfortunately there's no flag (that I know of) for `lldb` to print the "rendered" version of a string.
  There's no real list of all possible underlying network errors like the one you posted. Those errors don't come from Alamofire but the underlying `URLSession` networking APIs. You can take a look at `URLError` to see all of the cases possible, but Apple doesn't provide a simple list that I know of. Alamofire's errors all live in [`AFError.swift`](https://github.com/Alamofire/Alamofire/blob/master/Source/AFError.swift).
  @joedaniels29 Looks like you're trying to build for an OS which doesn't support `URLSessionStreamTask`. Update your project to meet the minimum deployment requirements of Alamofire 4 and it should work.
  I'm sorry, but there's no data structure in Swift which allows duplicate keys like this, much less JSON encoding which does the same. In fact, [RFC7159](https://tools.ietf.org/html/rfc7159#section-4) states `The names within an object SHOULD be unique.` So there's nothing for Alamofire to do here.
  Thanks for the report, this definitely looks incorrect. We'll try to get a fix out this weekend.
 This will be fixed when #1723 lands.
  There is no `swift3` branch anymore, Swift 3 compatibility was released as part of Alamofire 4. Update your `Podfile` and then run `pod update`.
  This will be addressed in #1722.
 This has been merged into `master`.
  @honbolau The Swift Package Manager is a bit of a moving target right now, especially if you're using development versions instead of the one included with Xcode. We're going to need a lot more information to properly diagnose an issue here. Like @skyline75489 said, check #1544 for up to date directions.
  I'm not sure I understand what you want Alamofire to do here, @grantkemp. Swift has no order preserving dictionary type, and even if it did, `JSONSerialization` wouldn't understand it, so there's no way for Alamofire to preserve ordering in the parameters passed in. In that case, I would suggest creating your `URLRequest` ahead of time or creating your own `request()` function that operates on whatever order-preserving collection you come up with. 
 @grantkemp Anything more to add here? I'm still not sure what you're asking for Alamofire to provide here, as custom body encodings can already be done in a variety of ways.
 @grantkemp If you have something more concrete to suggest or, better yet, a PR, feel free to comment. Otherwise I'm closing out this issue for now.
  @hzektser Errors like that usually indicate some sort of syntax error in the function being called. I recommend double checking the call to make sure all of the types and labels match up.

However, like @skyline75489 said, these types of questions are best suited for [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  @Mapamatician It seems like you have an issue with your local setup, as Alamofire does not produce timeout errors itself, those are from the underlying networking library. But like @skyline75489 said, these types of questions are best suited for [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  @marcusleon @Daltron Support for retry counts was added to `master` recently but has not yet been released officially. Once #1682 has been finalized and merged, we'll do another release. Otherwise yes, you'll need to ensure the retries stop yourself, even after we add the retry count to the framework. I'm closing this for now, but @cnoon, anything to add, give you wrote this feature?
  @travisday If you find any underlying Alamofire issue here, feel free to open another issue. Otherwise, these types of questions are best suited for [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  @yogesh2209  Like @thebluepotato said, these types of questions are best suited for [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Just FYI but that fork doesn't properly workaround any of the issues iOS 8 had, which is one of the reasons we dropped support for it in Alamofire 4. Our recommendation is that anyone requiring iOS 8 support should use Swift 2.3 and Alamofire 3.5.1. See #1367 for more information.
  @fishcharlie This is due to `URLSession` providing authentication handling by automatically retrying failed requests. #1425 is another example of this issue. 
  Looks like this should largely be fixed by [`SE-140`](https://github.com/apple/swift-evolution/blob/master/proposals/0140-bridge-optional-to-nsnull.md). But yes, you can't use `JSONSerialization` (and therefore `JSONEncoding`) to encode Swift collections with nil, you must convert them to `NSNull()`. This isn't any different than previous versions of Swift or Objective-C. If you're suggesting that Alamofire should do this for framework consumers, I'd disagree, as that's a fundamental change in the types passed in which users may not expect. That, combined with the upcoming Swift change, means I don't think there's anything for Alamofire to do here. @cnoon?
 If you want that behavior, you can use `(value as AnyObject?) ?? NSNull()`. That should work until Apple ships Swift 3.0.1 in Xcode 8.1.
 @sssilver Anything more to add here? Like I said, I expect this to become a non issue once Xcode 8.1 ships.
 My main point was that the discussion should become moot once Apple ships Swift 3.0.1 and the language properly handles the conversion for us.
 @sssilver Testing in the Xcode 8.1 GM (which includes SE-140), this code works where it didn't before:

``` swift
let string: String? = "string"
let parameters = ["what" : string]
let any = parameters as Any
func encodeParamters(_ parameters: [String : Any]) {
    do {
        let json = try JSONSerialization.data(withJSONObject: parameters, options: [])
    } catch {
        print(error)
    }
}

encodeParamters(parameters)
```

Previously it would crash in the `JSONSerialization` call. So it look like we're good here.
 Works fine as well, once it's properly typed (can't infer a value type when it's just `nil`).
 No, the compiler still allows optionals as `Any`, but produces a warning, forcing you to explicitly cast to `Any` if you want that behavior. But that only applies for direct declarations: 

``` swift
let string: String? = "string"
let parameters: [String : Any] = ["what" : string]
```

Produces a warning `Expression implicitly coerced from 'String?' to 'Any'`. However, it's not a problem when passing to a function.
  The `.authenticate()` function is proper way to add basic auth credentials, but you can take a look at our [AuthenticationTests](https://github.com/Alamofire/Alamofire/blob/master/Tests/AuthenticationTests.swift) file to see how we test this functionality. First, though, I would check and make sure your requests are being made as you expect and the server is seeing the credentials. 

If you find an issue with Alamofire, feel free to open a new issue, otherwise these types of questions are best suited for [Stack Overflow](https://stackoverflow.com) with tag `Alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
 Were you able to see any request logs to see if the `.authenticate()` method was adding the basic auth correctly? I don't think there's anything for Alamofire to do here, as our authentication support goes through the system libraries, but it would be interesting to know what the exact issue was just in case.
 @danipralea Anything more to add? We'd like to narrow down why this wasn't working, but all of our tests pass. Perhaps your server didn't accept typical basic-auth? I've manually verified Alamofire works correctly, both in our tests and against [HTTPBin's basic-auth endpoint](https://httpbin.org/basic-auth/username/password).
 @danipralea I'm mostly interested in what the request difference was that made your requests not work. That is, what was different between the requests returned by `.authenticate()` and you manual header addition.
 Hi @danipralea,

Have a look at this [authentication test](https://github.com/Alamofire/Alamofire/blob/master/Tests/AuthenticationTests.swift#L112-L141). It demonstrates how to use the `authorizationHeader` API when creating a `Request`.

Cheers. üçª
  Hi @taflanidi, thank you for taking the time to put this together and to state your reasoning. While we understand your point of view, we don't agree that Alamofire should be falling back to other types of parameter encoding when the specified one doesn't necessarily make sense.

In most cases, using JSON parameter encoding for a `GET` is going to be incorrect, but not always. There could be some crazy set of services that decided to deviate from the norm (we've all been there sadly). We want Alamofire to clearly do what it is you're instructing it to do. If a user is saying "I want a GET request with some JSON encoded in the HTTP body", well then that's what we want to them.

Additionally, who's to say that falling back to URL encoding is actually correct? We don't want to allow users to write the wrong code and accidentally get the correct result. This hides the fact that they made a mistake in the first place. Instead, we'd rather error on the side of Alamofire doing exactly what you instructed it to do.

We'd like to encourage everyone to consider using the Router pattern to construct their requests in production applications. This pattern is very powerful in Alamofire 4 with the ability to passthrough construction errors all the way to the response handlers. Because of this, each request should be choosing the appropriate parameter encoding type for the request it needs to make.

Hopefully that helps clarify our opinion here. Please feel free to keep the conversation going if you wish.

Thanks again. üçª
 I'm not sure what you're talking about. `GET` requests with body data work just fine, it's just that the backend server may not expect requests to pass parameters that way. We've never observed or had reports of freezing because of this issue, just servers not receiving parameters. Also, contrary to the AFNetworking serialization architecture, Alamofire's serializers are intended to be simple, single purpose, and for users to switch serialization type based on request, rather than having a single serializer that serve all requests. And like @cnoon said, baking this fallback behavior into the serializers themselves limits the ultimate flexibility of the framework.
 @taflanidi you can create your own custom JSON encoding type that behaves exactly as you would like. This is why we modified the AF4 design to be more flexible when it comes to parameter encoding. While we completely understand your reasoning here, we simply disagree. 

You are also making several contradictory arguments to your own statements here around the design. If you'd like to see things improve in Alamofire, then let's work together on doing so. Simply ranting about bad design and bad code doesn't help you or anyone else. In the future, if you have an idea on how to improve things, please open an issue and let's discuss it before you modify major parts of the framework in something that we ultimately wouldn't agree belongs in Alamofire. We don't want to waste your time and we'd certainly appreciate that you don't waste ours.
  The memory will automatically be cleaned up when there is no longer a reference to it. You don't have to worry about actually releasing it unless you're retaining it with a strong reference in your code.
  Hi @najmul-csebuet,

You're looking for `URLEncoding.default`.

In the future, you should open questions like this on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Please see https://github.com/Alamofire/Alamofire/issues/1544 for a full breakdown of using SPM with Alamofire.

Cheers. üçª
  Sorry, we won't be able to look into this until we have devices with iOS 10.1. In the mean time, can you retest on the latest beta. This looks like it could be an underlying Swift issue.
 I am getting my app rejected due to this issue :C
 @AleyRobotics @pixelfreak @adrimarti I'm sorry, but I can't reproduce this issue at all. Our tests pass on a variety of simulator types with each optimization level. We're going to need to see the calling code that leads to this crash to be able to reproduce it. @pixelfreak You mentioned "using the same parameters", can we get a code sample with those parameters that causes this issue for you?
 @pixelfreak I'm sorry, but like I said, I tried to replicate on both device (iPhone 7, iPhone 4S) and the simulator. Can you put together a sample project that reproduces the issue, even if it's on device?
 Hey everyone,

I'm going to close this issue out because there's nothing for us to really go on here. We have been unable to reproduce this issue through numerous attempts and no one has posted a sample project that can reproduce the issue.

In the future, please provide more information so we're able to help you debug the issue. We want to help, but there's nothing here for us to actually help with.

Best of luck. üçª
  An unexpected error `-999` almost always means your `SessionManager` was deallocated, cancelling any ongoing requests. I suggest you create a singleton value for your custom `SessionManager`, or perhaps just reevaluate if you really need one.
 I would recommend not subclassing unless you need behavior that can't be accomplished using the public APIs. Also, following Swift naming conventions. But yes, a singleton in a type is generally how you'd use a custom `SessionManager`. 

@cnoon Perhaps we need a best practices or common issues section in the README. This, and other issues, come up fairly often. 
  This PR was created to allow errors thrown in the adapter to call the retrier before starting up the request's internal dispatch queue. 
## Problem

The reason this is necessary is if you want to be able to throw an `ExpiredAccessToken` type of `Error` in your `RequestAdapter`. This would allow you to do things like preemptively refresh you token before sending any requests to the server even though the public APIs had already started up the request. The adapter would be able to intervene.

> See #1674 for the a more in-depth explanation of the issue.
## Solution

Okay everyone (especially @jshier), I need a sanity check here. I don't think this is too hackish, but I want to make sure everyone else agrees. This was really tricky to implement since there are so many different things going on.

The biggest decision was whether or not to wrap the errors in the `AdaptError` or not. It all boils down to whether we should call the retrier for things like invalid URLs and parameter encoding failures. IMO, we should not. I feel like calling the retrier in those scenarios could cause all sorts of problems where people are accidentally getting themselves into endless retry scenarios without realizing it.

Instead, I created an `AdaptError` to wrap any `Error` that's thrown by the `RequestAdapter`. This is only used internally by Alamofire to figure out whether the encountered error was actually thrown by the `adapter` or not. If it is an `AdaptError`, extract the underlying `Error` and call the `retrier`. If it isn't an `AdaptError`, then the request isn't going to succeed and just start up the request queue.

We could instead actually expose an `AFError.adaptError` that people are required to throw to get this behavior, but that seems a bit odd and easy to misuse. Instead, I think people are going to want to throw all types of errors from the adapter and we should just wrap them up internally to figure out whether or not we should call the retrier. Once we make that decision, we extract the underlying error and continue on.

I haven't actually built any tests around this yet because I wanted to get everyone's thoughts first. I've dug into the download and upload requests a bit and this is definitely possible to support in a similar manner.

Thoughts?
 cc @jshier and @kcharwood for a sanity check üòâ
 Looks pretty good, though I'm still worried about the growing complexity. I did have some questions about the error and the unwrapping, and how it was being used. I agree with the `AdaptError` solution, it's just the handling I'm concerned with.
 üëç Looks good.
  Thanks @hardikdevios! üçª
  Hi @MarcOConnor,

The issue is with your `handleCallbackWithResponse` API as @hardikdevios alluded to. It most likely needs to take a `DataResponse` instead of a `Response`. Just comment out that line of code and slowly start adding things back in.

For more info, please see #1560, #1597, #1650 and #1661.

In the future, I'd suggest you open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire` for this type of question. We use our GitHub project for bug reports and feature requests.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @Goule,

I'd suggest you open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  You need to update to CocoaPods 1.1.0 (`gem install cocoapods --pre` or using Bundler) for it to properly set the Swift version.

In the future, these types of questions are best suited for [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @hanneshallen,

These are all AWESOME points and you can do "exactly" what you proposed without any changes to Alamofire. It's already all setup to handle this, you just need to implement it. In your `RequestAdapter`, just check if the `expires_in` parameter has actually expired. If it has, throw an `Error`. It can be some custom error you create just for this case such as `CustomError.expiredAccessToken` or something like that.

Then in your `RequestRetrier`, you can check the `error` to see if it's an `.expiredAccessToken` and trigger a refresh. This will make sure the original request is NOT sent and goes immediately to your `RequestRetrier` where you can refresh the access token, then retry the request.

Cheers. üçª
 Interesting...thanks for pointing that out @tholo. Re-opening to investigate further.
 Yep, you're certainly correct @tholo...it's going to take some creativity to make that work. Let me see what I can come up with.
 Okay @tholo and @hanneshallen, please check out #1682. I'd love to get your thoughts.
 I'm going to close this issue out. Please redirect all further comments to #1682.

Cheers. üçª
  Hi @gerrypower,

@hardikdevios is right. You can't use a `responseJSON` serializer with that `status` API because it doesn't return any data. When you do, you'll always get an `Alamofire.AFError.ResponseSerializationFailureReason.inputDataNilOrZeroLength` as @hardikdevios has already pointed out.

The reason your test times out is because you don't have a `asyncExpectation.fulfill()` in your `failure` case. That causes both the `XCTFail` to fail as well as the timeout.

The reason the `204` status call works is that the `responseJSON` handler has logic to handle a 204 or 205 gracefully without failing. They are special HTTP status codes that do not return data so we have special logic in Alamofire to handle them in the default response handlers.

A better way to test this is the following:

``` swift
func testThatShowsSuccessHeadDoesNotTimeOut() {
    let asyncExpectation = expectation(description: "Wait for response")

    Alamofire.request("http://httpbin.org/status/200").response { response in
        debugPrint(response)
        asyncExpectation.fulfill()
    }

    waitForExpectations(timeout: 20)
}
```

In summary, if you don't `fulfill` your expectation in **ALL** cases, you'll always time out. Also, you can't use the default response handlers without receiving an error with no data unless you get back a 204 or 205.

Cheers. üçª
  Hi @Footjy,

There are all sorts of ways you could handle this. I'd start simple and write some check in your `RequestRetrier` that doesn't allow you to run more than say 3 refreshes within a 10 second timeframe. If you do, then stop retrying the request.

Once you get this check in place, you can slowly modify it over time to be more and more robust. If you post a link to the SO question I'd be happy to answer it there as well.

I also just pushed up PR #1681 which adds a `retryCount` property to a `Request` which would allow you to stop retrying a `Request` after it had been tried once or twice. These options should be more than enough to get you going.

If you have other ideas, please don't hesitate to post them. This system is brand new so we don't know all the ways everyone will be using it.

Cheers. üçª
  When I updated to Alamofire v4 I get this error from my file upload function: unresolved identfier Manager

Reading form the docs I can see: Manager is now SessionManager

So I changed the name but now I get the error: SessionManager has no member MultipartFormDataEncodingMemoryThreshold

<img width="918" alt="er1" src="https://cloud.githubusercontent.com/assets/10579811/19119262/7f53ae46-8b1f-11e6-8908-4de0e6f072c7.png">
<img width="910" alt="er2" src="https://cloud.githubusercontent.com/assets/10579811/19119270/83689852-8b1f-11e6-9811-ddc58e4e96e9.png">
  Yep...thanks for the fix @Lutzifer! üçª
  Hi @badeleux,

This is really an awesome question. Let me take a stab at walking you through how you could accomplish this.

## Problem

There's no such policy provided by Apple because it ultimately results in two requests which the `URLSession` APIs just aren't designed to do. However, you can definitely accomplish this behavior, but not the way you are intending.

By default, Apple is going to cache the result of a data request in most cases. I'd suggest reading through the [docs](https://developer.apple.com/reference/foundation/urlsessiondatadelegate/1411612-urlsession) on the `URLSessionDataDelegate` protocol to get familiar with the `willCacheResponse` behavior. In almost all cases, Apple and Alamofire will cache the response in the shared URL cache.

## Solution

Now I've thought through quite a few different ways to do this, and the best approach I could come up with was the following:

``` swift
let request = Alamofire.request("https://httpbin.org/get").responseJSON { response in
    let data = response.data
    // Use data to do whatever you need
}

if let urlRequest = request.request {
    let cachedResponse = URLCache.shared.cachedResponse(for: urlRequest)
    let data = cachedResponse.data
    // Use data to do whatever you need
}
```

This logic isn't quite perfect, but it's close. Let's walk through the three success case scenarios that exist here.

### Scenario 1 (no cached response)

The network request is sent with the default cache policy meaning it will first try to load from the cache if not expired, otherwise it will go hit the network. In the event that there's no cached response, the cache will be checked and it will not return a response, so the request will head to the network to download the response. The subsequent check then to extract the cached response while the network request is in-flight will fail since there's no cached response. Then, once the network request succeeds, the response is cached and you can use the data returned by the server. Yay!

### Scenario 2 (expired cached response)

Now the logic is a bit different when the data is cached and expired. The network request will find the cached response, but ignore it since it's expired and will head to the network to get a fresh copy. The URL request is then used to load the cached response from the URL cache while the network request is in flight. Thus you use the expired data while the request is inflight, then replace it once the network request succeeds. Yay!

### Senario 3 (valid cached response)

The final scenario is that the response is cached and is not expired. Now what's going to happen here is that the network request is going to load the cached response since it isn't expired. But before it is returned, you will actually fall into the URL request logic that directly fetches the cached response and uses it because the network request has to hop a few different queues before it can call your completion closure. Once the hops are complete (nano-milliseconds), your cached response is returned for the network request which is the same cached response you just loaded. You could parse the response twice and use it, or you could add some state tracking comparing the previous data against the new data to make sure they're different. Either way, you have to add your own state tracking there which is a bit of a bummer, but it can be done pretty easily.

---

## Summary

Hopefully that helps shed some light on what's all going on there. You could always implement your own logic to determine whether the cached response has actually expired, but that's going to be really difficult to do while matching the exact same behavior that Apple uses. It's unfortunately that Apple doesn't expose an `expired` Bool on a `CachedURLResponse`. It would certainly make this type of issue much easier.

Again, remember this is just one approach. There are MANY different ways you could solve this problem, but I think this is probably the simplest.

Cheers. üçª
  Hi @JordanOsterberg,

You should wipe `DerivedData` for starters. Then make sure you're running against Alamofire 3.5.1 if you're building against Swift 2.3 and Alamofire 4.0.1 for Swift 3. You also need to make sure you're using CocoaPods 1.1.0-rc.2 which can be installed with `gem install cocoapods --pre`.

Cheers. üçª
  You can use CocoaPods just fine, just using the `3.5.1` version, which is Swift 2.2 and 2.3 compatible.  If you really want to install manually you can download the `3.5.1` tag and use the manual installation instructions from our README. 
  @vishal-algoworks Make sure you transition your main project to Swift 3 before using CocoaPods 1.1.0 to install pods, as CocoaPods uses your project's Swift version setting to set the Swift version for all of your pods. Without that transition your project will trigger Xcode's update warning every time you open the project.

@jorgecasariego Like @hardikdevios said, you'll need to update your CocoaPods spec repo to pick up the latest spec versions, or just run `pod update`, in addition to running CocoaPods 1.1.0. 
  Hi @omidkh68,

My guess is that the issue is actually in your implementation, not in the chained method signature...that looks correct. I'd take @hardikdevios's advice here and just rebuild the method and you'll spot your mistake.

In the future, for questions like this, you should instead open a question on [Stack Overflow](https://stackoverflow.com) and tag `alamofire`. We use our GitHub project for bug reports and feature requests.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @quiKsilverItaly,

The success case is called because that's the success of the multipart form data encoding. It also exposes the actual upload request allowing you to chain onto it. Your `responseJSON` closure should be called eventually, but it may take a while depending on how much data you're uploading. You could add `uploadProgress` and `downloadProgress` closures to the `upload` to monitor the progress more closely.

Cheers. üçª
  Hi @umeshjavastar,

You're validating that the response status code is 200...299 and it's 400. That's why you're getting an unacceptable status code error. Instead of opening an issue for this on our GitHub project, you should instead open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. We use our GitHub project for bug reports and feature requests.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Thanks @hardikdevios. üçª
  Hi @gsujathap, 

These types of questions should be opened as a question on [Stack Overflow](https://stackoverflow.com) with an `alamofire` tag. We use our GitHub project for bug reports and feature requests.

Thanks! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Thanks @hardikdevios. üçª
  Hi @yuchenglin,

You need to remove the `public` ACL declaration and add the `@escaping` to the `completion` closure. In the future, I'd suggest you open a question like this on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. We use our GitHub project for bug reports and feature requests.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
 Don't trust the Xcode autoformatting or converters. Always assume there's an issue there first. It will save you a BUNCH of time at some point. üòâ
  Hi @leizard,

Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @kalvish21,

There's nothing you're missing. You'll need to look at what's going on server-side to troubleshoot. You can also inspect the encoded data by looking at the data blob directly if you manually encode it. You could do that like this:

``` swift
let multipartFormData = MultipartFormData()

multipartFormData.append(UIImagePNGRepresentation(tempImage!)!, withName: "file", fileName: "picture.png", mimeType: "image/png")
multipartFormData.append((UserDefaults.standard.value(forKey: Email) as! String).data(using: .utf8)!, withName: "email")
multipartFormData.append("png".data(using: .utf8)!, withName: "type")

do {
    let encodedData = try multipartFormData.encode()
    print(encodedData)
} catch {
    print("Encountered encoding error: \(error)")
}
```

We have all sorts of [tests](https://github.com/Alamofire/Alamofire/blob/master/Tests/MultipartFormDataTests.swift) around this in the Alamofire test suite. I really doubt there's any issue in Alamofire and the issue is server-side.

I'm going to close this issue out for now. If you post more info here that leads us to believe this could be an Alamofire error, we'll happily re-open and investigate further.

Cheers. üçª
 Could you provide a test demonstrating the behavior?
  Not completely sure what you're getting bit by since I don't have a full file to compile. I'd guess you need to `import Foundation` or remove the `Progress` declaration like this:

``` swift
upload.uploadProgress { progress in
    print(progress)
}
```

Other than that I'd suggest you compile out parts of your declaration and slowly add it back in to find your mistake. We have all sorts of tests around this in the test suite that don't have the issue.

Best of luck! üçª
  I'd suggest you take your question to [Stack Overflow](https://stackoverflow.com). We use our GitHub project for bug reports and feature requests. 

Also, we are not in the business of writing people's apps for them. Nor suggesting how they should build them. Please do some research on your own before asking questions like this.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @Zfr21,

Please read through the [AF 4 Migration Guide](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%204.0%20Migration%20Guide.md). It has all the info you need to get up and running.

Cheers. üçª
  Make sure you are using the latest beta version of CocoaPods which is `1.1.0-rc.2`. You can install the latest beta version using `gem install cocoapods --pre`. Here's an example of a sample project that compiles without issue.
- [PodsTester.zip](https://github.com/Alamofire/Alamofire/files/504696/PodsTester.zip)

If you continue to have issues, I'd recommend opening a question on [Stack Overflow](https://stackoverflow.com). We use our GitHub project for bug reports and feature requests.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @emrekilic,

Check out my [answer](http://stackoverflow.com/a/34193782/1342462) on Stack Overflow.

Cheers. üçª
  Thanks @grosch! üçª
  This is no longer needed with the `.swift-version` file and CocoaPods 1.1.0-rc.2. Thanks anyways! üçª
  Thanks @hardikdevios! üçª
  I'd check out @hardikdevios's suggestion and also our [example](https://github.com/Alamofire/Alamofire#uploading-multipart-form-data) in the README. From there, comment out things until it does compile, then slowly add them back in and you'll find your issue.

Best of luck! üçª
  The `NetworkReachabilityManager` is a simple way to tell what the current reachability status is, but more importantly, when your device reconnects to the internet. When it reconnects, you then know you can start up some previously failed requests that failed because connectivity was lost. There's no system in Alamofire that automatically keeps track of all this and just restarts your requests. That type of logic is left for you to implement.

Cheers. üçª
  Hi @kavoskhajavi,

This type of question is best suited for [Stack Overflow](https://stackoverflow.com). We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
 I'd also recommend you read through the [Background Transfer Considerations](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/URLLoadingSystem/Articles/UsingNSURLSession.html#//apple_ref/doc/uid/TP40013509-SW44) documentation from Apple.
  Alamofire 4.0.0+ is released on Swift 3. The `swift3` branch has been deleted.
  You need to use the CocoaPods 1.1.0-rc.2 release to use Alamofire 4.0.0+. You can install this version using `gem install cocoapods --pre`.
  Sorry @kakilan, there's nothing here to really go on. If you can produce more info, we'll happily investigate further. Sample app? Stack trace with crash description?

Cheers. üçª
 How did you resolve the issue? What Optimization level did you choose?
  First off, you opened this issue in the wrong repository. Secondly, you need to add way more detail here for us to help you investigate.
  Thanks @bot2600! üçª
  You want to use `URLEncoding.queryString` instead. That will leave your `httpBody` intact. I'd definitely suggest reading through the [docstrings](https://github.com/Alamofire/Alamofire/blob/master/Source/ParameterEncoding.swift#L62-L122) for `URLEncoding` to get a better feel for the options available to you.

Cheers. üçª
 What is the empty JSON you would expect to send @ilandbt...let's start there. What would you like to send up to the server. By empty do you mean nothing? I'm assuming not, but have to ask. I would "assume" you're trying to send an empty dictionary `{}`. Is that correct?
 Thanks for posting that @ilandbt...I've found a few issues in your expectations. First off, the JSON you just posted isn't valid. You are encoding arrays as dictionaries which results in invalid JSON. The valid form of the dictionary in your original question is:

``` swift
import Foundation

let parameters: [String: Any] = ["and": [["id": ["inq":["1", "2", "3"]]], [:]]]

do {
    let data = try JSONSerialization.data(withJSONObject: parameters, options: [])

    if let utf8 = String(data: data, encoding: .utf8) {
        print("JSON: \(utf8)")
    }
} catch {
    print(error)
}

// Outputs: {"and":[{"id":{"inq":["1","2","3"]}},{}]}
```

This is certainly your core issue "if" the invalid JSON you posted is actually what you need to send. In case you just posted the JSON wrong, I went a step further to make sure the empty JSON dictionary is actually encoded when using JSONEncoding.

``` swift
func testEmptyJSON() {
    let urlRequest = URLRequest(url: URL(string: "https://httpbin.org/get")!)
    let parameters: Parameters = ["and": [["id": ["inq":["1", "2", "3"]]], [:]]]

    do {
        let httpBody = try JSONEncoding.default.encode(urlRequest, with: parameters).httpBody

        if let httpBody = httpBody, let utf8 = String(data: httpBody, encoding: .utf8) {
            print("JSON: \(utf8)")
        }
    } catch {
        print(error)
    }
}

// Outputs: {"and":[{"id":{"inq":["1","2","3"]}},{}]}
```

As you can see, it outputs the same JSON as the other example and DOES include the empty dictionary.

What I'd recommend is using the `debugPrint(request)` approach to print out the [cURL command](https://github.com/Alamofire/Alamofire#curl-command-output) for the request. That will show you exactly what's being sent to the server.

If you are debugging on the server, then I'd try to figure out if the server is stripping off the empty dictionary although I really doubt it. You could also use the cURL command and something like Charles Proxy to continue to debug.

At this point, this is on you to investigate because Alamofire is working exactly as it should in this case. If you do need to encode the invalid JSON that you posted, then you'll need to implement your own `ParameterEncoding` type because Alamofire does not encode invalid JSON.

If you continue to have issues, please take your question to Stack Overflow.

Cheers. üçª
  You need to switch over to using the new `downloadProgress` API on a `DownloadRequest` documented [here](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%204.0%20Migration%20Guide.md#download-request---complex-with-url-string) in the migration guide and [here](https://github.com/Alamofire/Alamofire#download-progress) in the README. 

Cheers. üçª
  Alamofire 4.0.0 supports Swift 3. The `swift3` branch was removed after it was rebased onto `master`.
  Hi @iosdevben,

I'd recommend opening a question on [Stack Overflow](https://stackoverflow.com) for questions like this. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @J4awesome,

I'd recommend opening a question on [Stack Overflow](https://stackoverflow.com) for questions like this. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Alamofire 3.5.0 requires Swift 2.2 or 2.3 and Alamofire 4.0.0 requires Swift 3.0. If you're installing with CocoaPods, you need to make sure you're running CocoaPods 1.1.0-rc.2 by using `gem install cocoapods --pre`. If you continue to have issues, please take your questions to [Stack Overflow](http://stackoverflow.com).

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  @jshier...could you take a stab at investigating this one? We should be able to debug this in the sample app. @bkrijgsman could you answer the following?
- What type of URL session configuration are you using?
- What operating system are you running on? Is it `macOS 10.11.6`? Or are you running in the iOS simulator?
- Would it be possible for you to submit a sample app demonstrating the issue?
 Could you run instruments over the `iOS Example` app to see if you see the same issues? That might be the best way to start. If that doesn't exhibit the issue, then you could build a sample app after that.  That would also give us way more info to go on. 

Just an idea...
 @bkrijgsman These memory leaks were a result of an underlying Swift runtime issue that was [fixed for Swift 3](https://github.com/apple/swift/pull/2326) but not 2.3. We've landed some workarounds for it and another leak that was found in Alamofire 3.5.1. Cheers! üçª 
  Sweet! Thanks @vishrutshah! üçª
  Thanks @grosch! üçª
  Hi @puhgeh,

To be honest, I don't really understand your question. I'm not sure what you mean by an optional prefix. However, I "may" have an idea, so I'm going to roll with it.

I "think" you're asking why `Parameters` is optional in the `ParameterEncoding` protocol. The reason this is optional is that we treat `nil` differently than an empty dictionary. A `nil` dictionary just simply returns the `URLRequest` with no actual parameter encoding since there weren't any parameters. An empty dictionary is however encoded by setting the `Content-Type` header and sometimes setting the `httpBody` of the `URLRequest` to empty `Data`.

If this was not your question, please rephrase and I'll try again.

Cheers. üçª
 Hmmm...I'd guess you're passing in optional String parameters instead of making sure the `client_id` and `grant_type` are actually strings and not optional strings.
 Actually, the values are probably being passed through string interpolation when being added as parameters, as the `Parameters` type of `[String : Any]` won't accept optional values. @puhgeh Don't run your parameter values through string interpolation just to make them non-optional values, you need to actually unwrap them like @cnoon said.
  Thanks for reporting back @rudian. In the future, please take questions like these to [Stack Overflow](https://stackoverflow.com).

Cheers. üçª
  See #1367 for more explanation.
  @Dbigshooter Are you sure your JSON is properly encoded? It sounds like it hasn't been properly encoded into UTF-8, which JSON requires. In any event, Alamofire doesn't do anything special with JSON payloads, it just uses `JSONSerialization` to decode the `Any` value out of the response data. If you find something that might be a bug in Alamofire, feel free to open a new issue with a sample project or at least a code sample that replicates the issue.

Otherwise, these types questions are best suited for [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  You can encode an `Any` using `JSONSerialization` and get a `Data` value out. Is that what you want? There doesn't seem to be anything Alamofire related here.
 I agree with @jshier, you should use `JSONSerialization` @it99ts. If you continue to have issues, please open a question on [Stack Overflow](https://stackoverflow.com).

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  You need to use the following:

## CocoaPods

You need to use `CocoaPods 1.1.0-rc.2` which can be installed with:
- `gem install cocoapods --pre` 

Then your Podfile should include:
- `pod 'Alamofire', '~> 3.5'`

## Xcode

You should be using Xcode 8 (the official release) and Swift 2.3. Make sure you project is updated accordingly.

## Summary

If you're continuing to run into issues, the last thing you can try is to wipe DerivedData. From there, you'll need to open a new question on Stack Overflow for additional help.

Cheers. üçª
  Thanks @vishrutshah! üçª
  Make sure you are using CocoaPods 1.1.0-rc.2 and that your project is set up to compile against Swift 3. You can install the rc version of CocoaPods using: `gem install cocoapods --pre`.
  There's nothing that Alamofire does to speed up or slow down requests. The only advice I have is to check your network connection and also whether you have the network link conditioner enabled accidentally.

If you continue to have issues, I'd recommend opening a question on Stack Overflow. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Thanks @vishrutshah! üçª
  We're going to need a bunch more detail here @kit24. What type of encoding are you using? What was the previous version where it was working, and which version are you using now? Could you also please provide sample code demonstrating the issue?
 Sweet! Glad to hear it.
  Did you try reading the [Making Requests](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%204.0%20Migration%20Guide.md#making-requests) or [Parameter Encoding Protocol](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%204.0%20Migration%20Guide.md#parameter-encoding-protocol) sections of the [AF 4 Migration Guide](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%204.0%20Migration%20Guide.md)? We spent a tremendous amount of time putting that migration guide together to help you with these types of issues. 

> It's very important that you read the AF 4 migration guide in order to successfully convert your pre-existing Alamofire logic correctly and easily.

What you need to do is to switch over to using the `JSONEncoding` instead. Here's an example of [Manual Parameter Encoding](https://github.com/Alamofire/Alamofire#manual-parameter-encoding-of-a-urlrequest) from the README. All you have to do is switch over to using `JSONEncoding` instead.
  Hi @zhangfogao,

This type of question is best suited for [Stack Overflow](https://stackoverflow.com). We use our GitHub project for bug reports and feature requests. Most likely you're issue is due to a mismatch in CocoaPods version or how you have your project configured.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Make sure you are running CocoaPods 1.1.0-rc.2 and you will no longer need to `post_install` hook.
  Hi @Bigboocheng,

I'd suggest you take this question to [Stack Overflow](https://stackoverflow.com). We use our GitHub project for bug reports and feature requests. We have many people successfully using CocoaPods 1.1.0-rc.2 and Alamofire 4.0.0 together without issue.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Thanks @bakemecookies! üçª
  Thanks for helping out @skyline75489. Try using `responseString`, `responseData` or `response` @alexfigueroa to figure out what the issue is.

Best of luck! üçª
  I'm unable to reproduce the compiler error @CodeEagle, but this addition of the `Foundation` import certainly won't hurt anything. Thanks for the PR! üçª
  Apologies for the response in #1425 @filippovdev. After further investigation, I found that the challenge is actually called a second time. This is the default behavior of iOS. It will always try to continue without providing a response to the challenge. This is clearly documented in the [Authentication Challenges](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/URLLoadingSystem/Articles/AuthenticationChallenges.html) documentation from Apple.

> I'd highly recommend you checkout that article. It walks you through all the reasoning for why challenges work the way they do.

Alamofire follows the exact same logic as Apple when deciding how to handle challenges. If you insist on modifying the behavior (we would recommend you don't), then you will need to override the `taskDidReceiveChallenge` closure with your own custom logic, or subclass `SessionDelegate` and provide your own implementation for the task challenge API.

Again, I would strongly recommend against this since Apple has built a fairly sophisticated fallback system to attempt to fulfill challenges across multiple protection spaces. However, if you feel that the second call MUST be eliminated, you can certainly do so. This just isn't something we're interested in having directly in Alamofire.

Cheers. üçª
  Thanks @abunur! üçª
  I'm guessing this is in an extension on `Request`? Move the extension to `DataRequest` and see if that fixes it.
  Thanks @thebluepotato. @Jayvd, please don't open duplicate issues. It won't help you get your issue resolved any faster.
 Hi @Jayvd,

I put together a little sample app that demonstrates that making an Alamofire request immediately when your app is opened after unlocking does in fact succeed. I don't know exactly what is going on with your app, but it doesn't seem to be an issue with Alamofire directly.
- [Relauncher.zip](https://github.com/Alamofire/Alamofire/files/491428/Relauncher.zip)

> You'll need to set the team to debug the app on a device. 

I'm not quite sure what to tell you from here. You'll need to investigate your own app further to figure out why your requests are failing. 

I'm going to close this issue out since there's nothing that appears to be wrong with Alamofire. If you do end up finding something specific to Alamofire that seems problematic, please post your findings back on this ticket and we'll happily investigate further.

Cheers. üçª
  You need to make sure you migrate your pre-existing project to Swift 3 before you can use Alamofire 4.0. If you need help migrating your project, you should take your questions to Stack Overflow.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Here's a small example of how you can send headers in a request.

``` swift
let urlString = "https://httpbin.org/get"
let headers = ["Authorization": "123456"]

Alamofire.request(urlString, parameters: ["foo": "bar"], headers: headers).responseJSON { response in
    print(response.result.value)
}
```

I would strongly recommend you take the time to read our [AF 4 migration guide](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%204.0%20Migration%20Guide.md). We spent a tremendous amount of time detailing all the changes to make the transition much easier for you.

Best of luck! üçª
  Thanks @YeralYamil! üçª
  We do...it's right in our README for both [Alamofire 3.5.0](https://github.com/Alamofire/Alamofire/tree/3.5.0#requirements) and [Alamofire 4.0.0](https://github.com/Alamofire/Alamofire/tree/4.0.0#requirements).
  Thanks @thebluepotato. @Joanlove526 make sure you're using AF 4 and the latest version of CocoaPods or Carthage. Also make sure to wipe your DerivedData folder.

If you continue to have issues, please seek additional help on Stack Overflow or those particular dependency manager projects.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  This is a duplicate of #1594. I'm going to close this issue out. Please direct all future comments to #1594.
  Thanks @thebluepotato. üçª
  Not sure about the `responseObject` response handler, but the rest should be as follows:

``` swift
Alamofire.request(apiURL + "users", headers: headers)
```

The `method: .get` is now the default.

In the future, I'd recommend opening a question on [Stack Overflow](https://stackoverflow.com) for questions like this. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
 Thanks for helping out @thebluepotato! üçª
  This is a duplicate of #1544. I just commented on that issue as to why the SPM cannot currently compile AF 4.
  Hi @raugustinas,

The code you posted `["Term":]` doesn't even compile. You could pass empty parameters in a `POST` like so:

``` swift
let urlString = "https://httpbin.org/post"
let parameters: Parameters = ["foo": ""]

Alamofire.request(urlString, method: .post, parameters: parameters).responseJSON { response in
    debugPrint(response)
}
```

Cheers. üçª
 Also, in the future, please don't directly tag users on an issue that is opened. It won't help you get your issue resolved any quicker.
  Thanks for the confirmation @michael-mckenna. I'm going to close this issue out.

Cheers. üçª
  There's no longer a `swift3` branch. Instead you want to use:

``` ruby
pod, 'Alamofire', '~> 4.0'
```

Cheers. üçª
  Thank you @ikesyo! üçª

For anyone still having issues, please refer to @ikesyo's solution.
 Wipe your DerivedData folder @amirpervaiz086. If you continue to have questions then you should move your question to Stack Overflow.
  The README has been fully updated for Alamofire 4 and all of our code examples build just fine, so it's not a reliability issue. Please take a look at the [Migration Guide](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%204.0%20Migration%20Guide.md) for some of the renames the framework has gone through. Otherwise, yes, you'll need to read the header documentation, or if browser reading is better for you, the [documentation at CocoaDocs](http://cocoadocs.org/docsets/Alamofire/4.0.0/index.html) is up-to-date with our latest header docs.
  Please see #1367 and #1490.

Cheers. üçª
  This is fixed in CocoaPods 1.2.0, so there should be no need for that workaround anymore.  Hi @MarshallYang,

This type of question is best suited for [Stack Overflow](https://stackoverflow.com). We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  You must use `AlamofireImage 3.0.0` and `Alamofire 4.0.0` along with `CocoaPods 1.1.0-rc.2` if you want to use AlamofireImage on Swift 3. I just created a small sample project demonstrating both working together.
- [AFTester.zip](https://github.com/Alamofire/Alamofire/files/491315/AFTester.zip)

If you are having trouble with the response error documented by @sjmueller...please see his comments to resolve your compilation issue.

Cheers. üçª
  Thanks @leinadoknilik! üçª
  We will not be adding dependencies to Alamofire @pawel-sekara. Please see #1167 for more information.

Cheers. üçª
  For everyone on this thread, especially those blindly up-voting, has anyone actually looked at the Alamofire 3.5.0 release? Seriously, have you looked at the [documentation](https://github.com/Alamofire/Alamofire/tree/3.5.0#requirements)?

It CLEARLY states that Alamofire 3.5.0 DOES support iOS 8. It supports iOS 8, 9 and 10 on both Swift 2.2 and 2.3. Everything that has been requested in this issue is already completely supported.

I'm going to close this issue out since everything has already been addressed.

Cheers. üçª
 No. See #1367 for why.
  Without any details regarding the crash, there's not much we can do here. We'd need the Alamofire, Xcode, and iOS versions at the least, preferably with the crash log. But by just looking at it I'd say you're hitting the implicitly unwrapped optionals when the response isn't quite what you expected. There are 3 crash points in the code you posted alone.
  Please don't spam issues. See #1367 for a full explanation of our decision to drop iOS 8 support.
  This type of compiler error is usually caused by something in your call to `response` no lining up with the compiler's type expectations. I would make sure everything in your codes has the type you think it does.

Otherwise, these types of questions are best suited for [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  `Any` is not `AnyObject` and you cannot use subscripting on it. Just like you has to use `as AnyObject` to access the count, you'll need to do that same to subscript it. But really you should be using a real type and not `AnyObject`.
  @duanyicanyuan Be sure to clear your derived data after doing an update, it seems like maybe you have some build products in there that haven't been rebuilt.

Otherwise, these types of questions are best suited for [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Alamofire 3.5.0 supports iOS 8 - 10 and is compatible with Swift 2.2 and 2.3, as well as Xcode 7.3 and 8.0. 
 Either people are copy pasting comments or this issue is getting spammed. Either way, I'm locking it.
  @cnoon I think you're the best one to handle this.
 Thank you for reporting this issue @amosavian. I've added a test in acc7361c that verifies the behavior works correctly in the official Xcode 8 release on iOS 10 and iOS 9. Looks like the issue has been resolved in the underlying URLSession logic.

Cheers. üçª
 Thanks for letting me know @amosavian. I'm going to re-open and see if I can reproduce the behavior in a sample app since background session configurations no longer work in the simulator in Xcode 8.
 Hi @amosavian,

Thank you for bringing the error to our attention. After much debate, we've decided to leave this out of Alamofire due to the instability of this type of solution. Apple has really made a huge mess here and we're not sure about what all the permutations of various uploads and downloads could actually be. We also wouldn't be able to test any of the logic since the background URL sessions are broken in test targets. Because of all these issues, we're not comfortable taking ownership of such a fragile solution for a black box Apple feature.

With that said, we fully support the approach you've put in place for users that "have" to solve this issue. We just won't be implementing the solution directly into Alamofire. We have updated our docstrings and README in 4af61a69 to reflect the current state of resume data on the latest platforms. Hopefully this gets people started in the right direction.

Thanks again. üçª
 @amosavian Are you able to share the official workaround?
  Yes, the real solution here is to ensure you're running CocoaPods 1.1.0, as it's the only version that knows what to do with the `SWIFT_VERSION` flag. Also, it gets that setting from the target you're linking pods against, so make sure you've updated your project for Xcode 8.
  Thank you everyone for all the detailed information. 

@asynchrony-ringo is certainly correct. The core issue stemmed from the validation closures not marking each internally stored closure as `unowned self`. I've pushed 32b0ae9c into `master` which will be released shortly that addresses the issue. Validation no longer causes the request to leak. Also @StephaneGarnier, the `download` and `upload` progress APIs do not cause any leaks.

## Background

To give a bit of backstory, any closure that executes on the TaskDelegate's operation queue MUST capture a reference to `self`. Without this, the `Request` will actually be deallocated before the closure can be run which will result in no-ops for things like response handlers. The reason for this is that once the `URLSessionTask` completes, Alamofire no longer holds a strong reference to the `Request`. It is released by the `SessionDelegate` as soon as the task completes.

> This behavior is slightly different when using a `RequestRetrier`, but let's assume for now you're not using one.

Once the task completes, the `Request`'s internal operation queue is resumed and the `Request` is released by Alamofire. The only thing still holding a reference to the `Request` at this point is any closure that was dispatched onto the operation queue. GCD holds onto the operation queue (dispatch queue underneath) until all the closures on the queue have completed. Then GCD will cleanup the queue which is roughly the same time the `Request` will be deallocated.

## Alamofire 4

In Alamofire 4, we moved all validation to be stored directly by the `Request` so we can run validations off the operation queue. This allows us to support the `RequestRetrier` before actually starting the internal operation queue in case we need to retry the request before running the response handlers. The mistake we made when we did this was that we forgot to mark the validation closures as `unowned` so that we wouldn't create a retain cycle. The changes in 32b0ae9c remove the retain cycle.

We'll look to get this fix deployed as soon as possible. Thanks again everyone for all your help here.

Cheers. üçª
  Alamofire 3.5 an 4.0 both support tvOS 9, yes.
  Make sure you're updated to the latest Carthage and are running Xcode 8 (and that it's selected as your default Xcode, if you have multiple versions installed). You could also try clearing out your Carthage checkouts and reinstalling.

Otherwise, these types of questions are best suited for [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  @romk1n You can see issue #1367 for our full reasoning behind dropping iOS 8 support. 
  When you update your project to Swift 3, you need to run the conversion tool on your project first (not the CocoaPods, just your project). This is in the Edit menu -> Convert -> "To Current Swift Syntax...". This will update your project to require the Swift version you select (2.3 or 3), in addition to attempting to transition your apps code to that version of Swift as well. Once that's done and your project file has been modified to contain the `SWIFT_VERSION` setting, running `pod update` will use that setting to generate a new `Pods` project integration that uses that setting to set the Swift version for all of your pods. That should fix issues with the `SWIFT_VERSION` setting being required and such. 

However, since this is entirely an Xcode and CocoaPods integration issue I'm closing this issue out. If you have further issues, these types of questions are best suited for [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
 There is not solution beyond what I've described. A project that has properly upgraded to Swift 3, CocoaPods 1.1.0, and Alamofire 4 should build just fine, barring any updates that must be made in the app's code to support the Alamofire 4 changes. Your issues are not with Alamofire, they're with something in your integration process that's preventing Xcode from seeing and building your app and it's dependencies as Swift 3 code. That is far beyond the purview of Alamofire.
  You need to update the Swift syntax of your app to match the Swift 3 and Xcode 8 requirement of Alamofire 4.0. Once that is done, and you do a `pod update` using CocoaPods 1.1.0, it will work just fine.
  Unfortunately this isn't an Alamofire issue, as Alamofire doesn't interact with raw sockets at all. All of Alamofire's networking is done through the `URLSession` APIs, so if there's an issue there I'd suggest opening a bug with Apple.

Otherwise, these types of questions are best suited for [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck!

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  From those errors it appears you aren't using Xcode 8. Alamofire 4 requires Xcode 8. If you need to keep using Xcode 7, please use Alamofire 3.5.0.
 Hi everyone,

I agree this issue was closed pre-maturely without a proper response. With that said, please cut @jshier some slack. He's been plowing through 50+ issues every day since we've released. We all make mistakes from time to time.

As for this particular issue, the problem is that the SPM automatically uses a deployment target of 10.10 which doesn't work with AF 4 since AF 4 requires 10.11+. That's why you see all the `URLSessionStreamTask` errors when trying to compile. 

I've reached out to `swift-users` to see if there's any way to customize this, but from what I can tell, there isn't. I'll file a feature request under the Swift bug reporter if this ends up being the case. If you can actually override it, I'll post back here with instructions.

Cheers. üçª
 So I've spent some time on `swift-users` trying to get to the bottom of how this all is supposed to work and I think I have it pretty much figured out. Although there are still some serious shortcomings, you can at least get things to work. If you follow these steps, you can get things working.

## Using SPM with Alamofire

1) Clone Alamofire locally and tag the `master` branch as `4.0.2`

> This is necessary to pick up a change I made in the `Package.swift` file that hasn't been released yet

2) Create an example project
3) Create a `Package.swift` file for your project similar to the following:

``` swift
import PackageDescription

let package = Package(
    name: "SPMTester", 
    dependencies: [
        .Package(url: "/Users/cnoon/Desktop/Alamofire", "4.0.2")
    ]
)
```

4) Create your `main.swift` file in `Sources`

``` swift
import Alamofire
import Foundation

Alamofire.request("https://httpbin.org/get").responseJSON { response in
    debugPrint(response)
    exit(0)
}

RunLoop.current.run()
```

5) Create a `Configuration.xcconfig` file to override the deployment target

``` bash
SDKROOT = macosx
MACOSX_DEPLOYMENT_TARGET = 10.11
```

6) Generate the Xcode project for your new example

> $ swift package generate-xcodeproj --verbose --xcconfig-overrides ./Configuration.xcconfig --output ./SPMTester.xcodeproj

7) Open the Xcode project, navigate to the project (not target) settings and delete the `MACOSX_DEPLOYMENT_TARGET` setting so the xcconfig value can be picked up by the project
8) Build and run

Here's an example of a small `SPMTester` project that I put together.
- [SPMTester.zip](https://github.com/Alamofire/Alamofire/files/505238/SPMTester.zip)

---

## Summary

Now this is certainly still WAY more painful than it should be, but at least it's actually up and running. Once the community adds more features this process should get easier and easier.
  You can see issue #1367 for a full explanation of why we aren't. 
 That is not why. See #1367 for more details and be forewarned, your fork likely isn't reimplementing the various workarounds we had for iOS 8 bugs.
  You can see issue #1367 for a full explanation as to why we dropped iOS 8 support.
  Please ensure you are using the appropriate version of Xcode for the version of Alamofire you're trying to use. Alamofire 4 requires Xcode 8, Alamofire 3.5 is compatible with both Xcode 7.3 and Xcode 8 with the "Use legacy Swift version" setting set to true.
  Nothing you've posted points to an Alamofire issue. (You should update to Alamofire 3.5, there have been many bug fixes since 3.1). 

These types of questions are best suited for [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck!

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
 I'll just say, I have seen errors like this when I was using CocoaPods to try and embed frameworks inside a framework target which I then used in my main app. CocoaPods can't properly do that right now, so while the autocomplete and stuff may work, the overall build would fail because the symbols weren't properly exported through the various layers of frameworks to my call site in the app. Other than that I think StackOverflow will give you a better chance of finding a fix.
  Alamofire 4 requires Swift 3, which has renamed `NSTimeInterval` to `TimeInterval`. You need to use Xcode 8 to properly compile this project. Please see our README and Migration Guide for more info.
  Yes, `Response` has been split into some specific types. Please see the README and Migration Guide for more info.
  Thanks for putting this together @ThibaultVlacich!
  @qgliu `sharedInstance` has been renamed `default` in accordance with Swift 3's new naming guidelines. You'll find what you want there.
  Yep, it appears we definitely did! Thanks for putting this together @Toldy...much appreciated! üçª
  @xiaopn166 The answer to your question was right there in the CocoaPods output: `Specs satisfying the Alamofire (~> 4.0) dependency were found, but they required a higher minimum deployment target.` Alamofire 4.0 has higher OS requirements than 3.5, so make sure your deployment target meets the minimums specified in our README.

@amolgupta That workaround should not be required if you update to CocoaPods 1.1.0.
  @gcjg Please provide a sample project that replicates what you're seeing. We have many tests, examples, and demo projects that demonstrate that the code you posted does work. If you do, feel free to open another issue with a more in depth analysis and said sample project and we'll be happy to investigate further.

One thing to note, though, is that `JSONEncoding` encodes your parameters as JSON and put it in the `httpBody` of the `URLRequest` created. When used with a `.get` method, the server may not expect this, as `GET` requests usually encode parameters in the URL itself.
 If you can provide a test project that can replicate the behavior you're seeing, feel free to add it to this issue and I'll reopen or open a new issue. Until then, I've verified the scenario you've described works fine, both in our tests and in a demo app I set up fresh. My only point in bringing up the details of `JSONEncoding` was to ensure you knew about this behavior, as some servers don't parse body details from GET requests (like `httpbin.org`). 
  @rakeshbiswalmobileprogrmming There is quite a bit in our README about adding authorization headers or using our `.authenticate()` function. Please read it and I think your questions will be answered.

@cnoon Perhaps this is related to #1553? 
 Hi @Tulleb,

Apologies for not getting back to you sooner. The example @katopz is not the same type of request. That example demonstrates how to use a data task, not a download task. If you don't wish to download the file, you can instead do the following:

``` swift
Alamofire.request(url).responseData { response in
    guard let data = response.result.value else { return }
    let image = UIImage(data: data)
    print(image)
}
```

However, to answer you're original question, you're running into a sandbox permissions issue. We allow you to use the `download` APIs without specifying a `destination` closure for operating systems like `macOS` where you can access files outside of your own sandbox. However, on iOS, you cannot directly access the data of a file that is outside of your sandbox. That's why you are seeing the `.inputFileReadFailed` error.

There are a couple ways you can solve this issue. 

## Option 1

You can download the data using the `request` API as shown above which downloads the image data into memory, not to disk.

## Option 2

You can move the file into your sandbox before accessing the data using a `destination` closure. Here's an example of how to do that:

``` swift
let destination: DownloadRequest.DownloadFileDestination = { _, _ in
    let documentsPath = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)[0]
    let documentsURL = URL(fileURLWithPath: documentsPath, isDirectory: true)
    let fileURL = documentsURL.appendingPathComponent("image.png")

    return (fileURL, [.removePreviousFile, .createIntermediateDirectories])
}

Alamofire.download("https://httpbin.org/image/png", to: destination).responseData { response in
    debugPrint(response)

    if let data = response.result.value {
        let image = UIImage(data: data)
        print(image)
    } else {
        print("Data was invalid")
    }
}

// Outputs:

// [Request]: https://httpbin.org/image/png
// [Response]: <NSHTTPURLResponse: 0x170032940> { URL: https://httpbin.org/image/png } { status code: 200, headers {
//     "Access-Control-Allow-Origin" = "*";
//     "Content-Length" = 8090;
//     "Content-Type" = "image/png";
//     Date = "Sat, 24 Sep 2016 21:34:25 GMT";
//     Server = nginx;
//     "access-control-allow-credentials" = true;
// } }
// [TemporaryURL]: /private/var/mobile/Containers/Data/Application/25612024-9A05-4ED5-AF3B-A98E22DEAD7A/tmp/CFNetworkDownload_fD9sXf.tmp
// [DestinationURL]: /var/mobile/Containers/Data/Application/25612024-9A05-4ED5-AF3B-A98E22DEAD7A/Documents/image.png
// [ResumeData]: 0 bytes
// [Result]: SUCCESS: 8090 bytes
// [Timeline]: Timeline: { "Request Start Time": 496445664.792, "Initial Response Time": 496445665.651, "Request Completed Time": 496445665.655, "Serialization Completed Time": 496445665.655, "Latency": 0.860 secs, "Request Duration": 0.863 secs, "Serialization Duration": 0.000 secs, "Total Duration": 0.864 secs }
// Optional(<UIImage: 0x17008bc20>, {100, 100})
```

You MUST use a destination closure if you need to download the file to disk. The temporary file can only be accessed inside the delegate callback which is handled internally in Alamofire. If you do not specify a destination closure on iOS, the `temporaryURL` will always point to where the temp file was previously stored, but has been cleaned up.

## Summary

So in summary, if you don't need to download the data to disk, then you want Option 1. If you do want to save the file on disk, then you want Option 2.

Cheers. üçª
  @lawgimenez We have quite a few tests and apps using this behavior, so it's unlikely that this is an Alamofire issue. Mostly likely it's an issue with your underlying app code. However, if you can narrow down a cause and create a reproducible test case, feel free to open a new issue so we can investigate further.
  There is something seriously wrong with your build environment if your Xcode can't find the `Error` type. Perhaps your project is set to use Swift 2.3 and you tried to install Alamofire 4? 3.5 is the only version compatible with Swift 2.3.
  @ostatnicky's workaround should not be necessary if you're using CocoaPods 1.1.0, as it adds that setting to your `Pods` project automatically. As with any upgrade of Xcode and dependencies, clearing your DerivedData folder is always a good idea.
  Thanks for providing your test project. It builds successfully for me, as do my own Alamofire-from-CocoaPods test projects. So it just seems to be a general build issue with your environment.

These types of questions are best suited for [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck!

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  You can find a full explanation of the decision to drop older iOS and macOS version in issue #1367. 
 If you wish to use Xcode 8 and Alamofire while targeting iOS 8, please use Alamofire 3.5.0 and Swift 2.3.
  Apologies @radar, it is certainly not our intention to ever publish examples that produce ambiguity compiler errors. We'll look into this and get things corrected. Stay tuned.
 Okay @radar, thank you for your patience here. 

First off, the issue in your code sample is that you need to remove the `data:` parameter when appending the `imageData`. This will compile just fine:

``` swift
let imageData = UIImageJPEGRepresentation(photo.image, 1.0)

Alamofire.upload(
    multipartFormData: { multipartFormData in
        multipartFormData.append(imageData, withName: "unicorn")
    },
    to: "https://httpbin.org/post",
    encodingCompletion: { encodingResult in
        switch encodingResult {
        case .success(let upload, _, _):
            upload.responseJSON { response in
                debugPrint(response)
            }
        case .failure(let encodingError):
            print(encodingError)
        }
    }
)
```

> It is unfortunate that the error message is so bad. Sadly we can't do anything about that. üòî

As for our [multipart form data sample code](https://github.com/Alamofire/Alamofire#uploading-multipart-form-data) in the README, it compiles just fine without ambiguity.

``` swift
Alamofire.upload(
    multipartFormData: { multipartFormData in
        multipartFormData.append(unicornImageURL, withName: "unicorn")
        multipartFormData.append(rainbowImageURL, withName: "rainbow")
    },
    to: "https://httpbin.org/post",
    encodingCompletion: { encodingResult in
        switch encodingResult {
        case .success(let upload, _, _):
            upload.responseJSON { response in
                debugPrint(response)
            }
        case .failure(let encodingError):
            print(encodingError)
        }
    }
)
```

@paulrobinmanson it looks like you have the same issue. You need to remove your `data` parameter in the `append` method, then it will compile correctly.

Cheers everyone. üçª
 @paulrobinmanson you use it the same way as in v3. Tack the `uploadProgress` closure onto the `upload`.

``` swift
Alamofire.upload(
    multipartFormData: { multipartFormData in
        multipartFormData.append(unicornImageURL, withName: "unicorn")
        multipartFormData.append(rainbowImageURL, withName: "rainbow")
    },
    to: "https://httpbin.org/post",
    encodingCompletion: { encodingResult in
        switch encodingResult {
        case .success(let upload, _, _):
            upload.uploadProgress { progress in
                print(progress.fractionCompleted)
            }
            upload.responseJSON { response in
                debugPrint(response)
            }
        case .failure(let encodingError):
            print(encodingError)
        }
    }
)
```
  @Canmmy If you are integrating Alamofire through CocoaPods, make sure you update to CocoaPods `1.1.0` and run `pod update`. Also, remember that you can only use Alamofire `3.5` and Swift 2.3 on iOS 8.
  This is awesome, thanks for putting this together @JustinJiaDev...much appreciated! üçª
  You should make sure you're using CocoaPods `1.1.0.rc.2`, as that version of CocoaPods will generate the `Pods` project with the correct settings so Xcode won't say you need an upgrade. Plus, make sure you use Alamofire 3.5, as that's the only version compatible with Swift 2.3.
  All of the examples in the README, including [the router example](https://github.com/Alamofire/Alamofire#crud--authorization) have been updated to use the new protocol.
  @ka05 Please don't use 3.4.2. The last supported version for iOS 9 and Xcode 7 is 3.5.x. 
  As you can see in our [migration guide](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%204.0%20Migration%20Guide.md#namespace-changes), `Manager` has been renamed `SessionManger`.
  Thanks @glennrfisher!
  There are the `totalUnitCount` and `completedUnitCount` properties you can use. We had to remove the other version of the `progress` API because of a compiler issue and we'll try to add it back once the compiler is okay with both versions.
  You most likely don't want to use the `stream` APIs here, but that's just a guess.

These types of questions are best suited for [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck!

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Absolutely @chunlea...that was completely my fault. We'll have this fixed shortly.
 Hi @chunlea,

Thank you so much for figuring out this was the core issue! I had actually been having this happen to me several times while working on AF4 and somehow I never realized it was actually running the test suite on OS X that was the root problem.

I've pushed up commit 8f370a23 that fixes the issue. We now only write files to the temp directory in the test suite.

Cheers. üçª
  Hi @Urkman,

We have quite a few unit tests verifying this behavior works correctly. I just ran the [`testThatUploadingMultipartFormDataWhileStreamingFromMemoryMonitorsProgress`](https://github.com/Alamofire/Alamofire/blob/master/Tests/UploadTests.swift#L331-L333) test and added the following debug output:

``` swift
// When
Alamofire.upload(
    multipartFormData: { multipartFormData in
        multipartFormData.append(loremData1, withName: "lorem1")
        multipartFormData.append(loremData2, withName: "lorem2")
    },
    usingThreshold: streamFromDisk ? 0 : 100_000_000,
    to: urlString,
    encodingCompletion: { result in
        switch result {
        case .success(let upload, _, _):
            upload
                .uploadProgress { progress in
                    print("Upload Progress: \(progress.fractionCompleted)")
                    uploadProgressValues.append(progress.fractionCompleted)
                }
                .downloadProgress { progress in
                    print("Download Progress: \(progress.fractionCompleted)")
                    downloadProgressValues.append(progress.fractionCompleted)
                }
                .response { resp in
                    response = resp
                    expectation.fulfill()
                }
        case .failure:
            expectation.fulfill()
        }
    }
)
```

What it ended up logging out is the following:

```
Test Case '-[Alamofire_iOS_Tests.UploadMultipartFormDataTestCase testThatUploadingMultipartFormDataWhileStreamingFromMemoryMonitorsProgress]' started.
Upload Progress: 0.0450805914626429
Upload Progress: 0.135241774387929
Upload Progress: 0.135241774387929
Upload Progress: 0.135241774387929
Upload Progress: 0.135241774387929
Upload Progress: 0.135241774387929
Upload Progress: 0.202862661581893
Upload Progress: 0.202862661581893
Upload Progress: 0.202862661581893
Upload Progress: 0.360644731701143
Upload Progress: 0.360644731701143
Upload Progress: 0.360644731701143
Upload Progress: 0.360644731701143
Upload Progress: 0.360644731701143
Upload Progress: 0.360644731701143
Upload Progress: 0.360644731701143
Upload Progress: 0.383185027432464
Upload Progress: 0.428265618895107
Upload Progress: 0.428265618895107
Upload Progress: 0.450805914626429
Upload Progress: 0.47334621035775
Upload Progress: 0.495886506089072
Upload Progress: 0.540967097551714
Upload Progress: 0.540967097551714
Upload Progress: 0.653668576208322
Upload Progress: 0.653668576208322
Upload Progress: 0.653668576208322
Upload Progress: 0.676208871939643
Upload Progress: 0.676208871939643
Upload Progress: 0.766370054864929
Upload Progress: 0.766370054864929
Upload Progress: 0.766370054864929
Upload Progress: 0.766370054864929
Upload Progress: 0.766370054864929
Upload Progress: 0.78891035059625
Upload Progress: 0.856531237790215
Upload Progress: 0.879071533521536
Upload Progress: 0.879071533521536
Upload Progress: 0.879071533521536
Upload Progress: 0.924152124984179
Upload Progress: 0.924152124984179
Upload Progress: 0.991773012178143
Upload Progress: 0.991773012178143
Upload Progress: 0.991773012178143
Upload Progress: 1.0
Download Progress: 0.044996896576347
Download Progress: 0.0888458010403335
Download Progress: 0.13384269761668
Download Progress: 0.178839594193027
Download Progress: 0.223836490769374
Download Progress: 0.268833387345721
Download Progress: 0.313830283922068
Download Progress: 0.359975172610776
Download Progress: 0.359975172610776
Download Progress: 0.404972069187123
Download Progress: 0.448820973651109
Download Progress: 0.493817870227456
Download Progress: 0.538814766803803
Download Progress: 0.538814766803803
Download Progress: 0.58381166338015
Download Progress: 0.763799249685538
Download Progress: 0.763799249685538
Download Progress: 0.763799249685538
Download Progress: 0.763799249685538
Download Progress: 0.808796146261885
Download Progress: 0.808796146261885
Download Progress: 0.898789939414579
Download Progress: 0.943786835990926
Download Progress: 1.0
Download Progress: 1.0
Test Case '-[Alamofire_iOS_Tests.UploadMultipartFormDataTestCase testThatUploadingMultipartFormDataWhileStreamingFromMemoryMonitorsProgress]' passed (1.514 seconds).
```

So from what I can tell, everything is working exactly as expected. If you can produce some failing test that proves otherwise, I'll gladly take a look and re-open if necessary.

Cheers. üçª
  Thanks @a2!
  You need to upgrade to CocoaPods 1.1.0 to properly use Swift pods with Xcode 8.
  @otherbuns Take a look at our [migration guide](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%204.0%20Migration%20Guide.md#parameter-encoding-protocol) you'll see that our parameter encoding methods have radically changed for Alamofire 4. You no longer need to use the ugly `.custom` syntax. Instead you can wrap your encoding logic in a type conforming to `ParameterEncoding`. 
 Hey @kevinlee85, the easiest way to fix your issue is to comment the code out and rebuild it with auto-complete. The error is usually pretty obvious when you do it that way.
  @kthotav You can run `pod cache clean --all` to make sure you'll pull the appropriate Alamofire source. You can also run `rm -rf Pods` from your project directory to make sure CocoaPods properly reinstalls everything. After that your project should build fine.
 @EtienneLem That issue is fixed in the Xcode 8 GM. None of the issues here are Alamofire issues, they all seem related to integration, whether through CocoaPods or not.
  This would definitely be a worthwhile change. We'll need to make it across all three libraries though.
 PR #1520 has been merged. Thanks for putting this together @JustinJiaDev! üçª
  Good catch! Thanks @JustinJiaDev. üçª
  Thanks @thebluepotato. üçª
  Good catch! Thanks for the fix. üçª
  You need to update to CocoaPods `1.1.0` to properly support Xcode 8.
 @Gargo There is no version 4.0 yet, as it hasn't been pushed to CocoaPods. We're working on it now and hope to have it pushed up this weekend.
 AF 4 is now available!
 Installation instructions in the README should not work fine, as we've been able to publish the pod and tag the 4.0.0 release.
 If you're writing a new project and are using Swift 3, use Alamofire 4.0.0, otherwise use 3.5.
 CocoaPods works fine, your installation just seems messed up. But yes, Carthage and manual integration also work fine, as laid out in our README.
 1.1.0 is required if you are using Xcode 8, as stated in our README.
 @Gargo...many of us are now using Alamofire 4 with CocoaPods 1.1.0-rc.1 with the Xcode 8 GM. Our documentation did not match up with the official release for a couple days which certainly caused some people some issues. We're sorry for that. It wasn't our intention to cause confusion. However, that branch was not yet released, so to expect all the documentation to be exactly right is not really realistic.

If you continue to have issues, then as others have mentioned, I'm sure you have an issue with your CocoaPods setup. I'd recommend taking this to Stack Overflow or to CocoaPods.

With all that said, I'm going to lock this conversation down. Several people have tried to help you here and you're not being particularly respectful of their assistance. Please, in the future, use better judgment when asking for help.

Best of luck. üçª

---

# Code of Conduct

The Code of Conduct governs how we behave in public or in private
whenever the project will be judged by our actions.
We expect it to be honored by everyone who represents the project
officially or informally,
claims affiliation with the project,
or participates directly.

We strive to:
- **Be open**: We invite anybody to participate in any aspect of our projects.
  Our community is open, and any responsibility can be carried
  by any contributor who demonstrates the required capacity and competence.
- **Be empathetic**: We work together to resolve conflict,
  assume good intentions,
  and do our best to act in an empathic fashion.
  By understanding that humanity drops a few packets in online interactions,
  and adjusting accordingly,
  we can create a comfortable environment for everyone to share their ideas.
- **Be collaborative**: We prefer to work transparently
  and to involve interested parties early on in the process.
  Wherever possible, we work closely with others in the open source community
  to coordinate our efforts.
- **Be decisive**: We expect participants in the project to resolve disagreements constructively.
  When they cannot, we escalate the matter to structures
  with designated leaders to arbitrate and provide clarity and direction.
- **Be responsible**: We hold ourselves accountable for our actions.
  When we make mistakes, we take responsibility for them.
  When we need help, we reach out to others.
  When it comes time to move on from a project,
  we take the proper steps to ensure that others can pick up where we left off.

This code is not exhaustive or complete.
It serves to distill our common understanding of a
collaborative, shared environment and goals.
We expect it to be followed in spirit as much as in the letter.
  @WERUreo, we're updating the documentation now. Please stop commenting on various issues about it. We're fully aware that the documentation does not "exactly" reflect the current state of the unreleased `master` branch.
 No worries @WERUreo...we've had a long past few days and have been updating docs tirelessly. Unfortunately you bore the brunt of my frustration of users jumping on `master` without understanding what the current state of it is. My apologies.
  Alamofire 3.5.0 only supports Swift 2.3. You need to use HEAD of master for Swift 3. We haven't released Alamofire 4 yet with Swift 3 support.
 We're actively updating the documentation now @WERUreo. Please understand that Alamofire 4.0.0 is not released. If you are looking at unreleased branches, you cannot expect all the documentation and everything to be perfectly up-to-date.
  Alamofire 3.5.0 supports Swift 2.3. If you're trying to build a project using Swift 3, you need to use the HEAD of `master` right now.

Cheers. üçª
  Thanks @lostincode.

In the future, I'd recommend opening a question on [Stack Overflow](https://stackoverflow.com) for questions like this. We use our GitHub project for bug reports and feature requests.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  You're missing the necessity to use the `master` branch for Swift 3 compatibility or `3.5.0` for Swift 2.3, and update to CocoaPods `1.1.0.beta.2` to properly support Xcode 8 (mostly). 
  Thanks @thebluepotato. üçª

In the future, I'd recommend opening a question on [Stack Overflow](https://stackoverflow.com) for questions like this. We use our GitHub project for bug reports and feature requests.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  The `destination` closure signature has changed. You now need to return the `DownloadOptions` along with the URL to allow you to custom how the file is moved.

``` swift
public typealias DownloadFileDestination = (
    _ temporaryURL: URL,
    _ response: HTTPURLResponse)
    -> (destinationURL: URL, options: DownloadOptions)
```
  This PR is an alternate approach to solving the issue identified in #1488. Overall, I think this is a better approach to solving the problem. This allows us to keep the same public APIs, but allow the compiler to catch all the places where the problem wasn't previously identified.

Overall, I don't think it is necessary to keep the `URLRequest` API conforming to `URLStringConvertible`. We don't actually use it for anything anymore and it's misleading and problematic. I actually almost removed it before but didn't have a strong reason to because I hadn't realized what @tremblay did.
 cc @jshier and @kcharwood for review.
 Looks good to me. 
 Awesome, thanks @jshier.
 Thanks for the heads up @adamwaite...we'll get AlamofireImage fixed up as well.
 AFI is a bit out-of-date with AF at the moment. We're wrapping the AF 4 release right now. Once that is out, AFI will be next.
  Hi @steveatinfincia,

Thanks for putting together this issue. It's well thought out and makes a very good case against our current deployment target choices. Let me do my best walk you through being on the other side of this ask.

## Background

Alamofire currently supports 4 platforms each across two MAJOR versions of each of them. It also supports three different versions of Swift, not to mention we maintain three different libraries. All of this put together is a huge effort to maintain and keep bug free. We've managed to do a pretty good job on this front, but it's not scalable if we move to supporting 3 MAJOR versions at the same time.

It's very important for us to keep our MAJOR versions supported bundled together across platforms. What I mean by that is that if we decided to support macOS 10.10, then we should really support iOS 8 since they are more or less the same version of the underlying frameworks. Since tvOS and watchOS (debatable) weren't around then, they don't fall into this camp. This helps keep the supported versions more cohesive and also helps us keep in mind the limitations and bugs in these different versions of the underlying frameworks.

There have been some pretty nasty hacks we've had to put in place to workaround various bugs on some of the older frameworks. We've also had to put in place a bunch of workarounds to get around various differences between the platforms across MAJOR versions. All of this creates a VERY large amount of maintenance headache, especially when it comes to testing. We want to make sure we're providing a top notch library with everything covered (as much as possible) in unit or integration tests. And not only do we want to make sure we have full coverage across our feature set across all platforms and versions, we also want to make sure they all pass and continue to pass!

## Testing

Thankfully we're able to leverage Travis CI for testing which has been a huge help, even if it is a little unstable at times. The biggest gap we have here though is actually when trying to test the macOS builds. We don't have the ability to run the test suite on older versions right now. [Travis-CI](https://docs.travis-ci.com/user/osx-ci-environment/) has amazing support for older versions of Xcode, but not on varying OSX versions. This means that we'd be able to get things compiling, but wouldn't be able to run the test suite against macOS 10.10 which is a super high risk proposition. Especially when that's the oldest platform and the one that we've forgotten the most about.

## Decision

Given all these things, we've decided that it's the best overall decision for the community for us to drop both iOS 8 and macOS 10.10 support in Alamofire 4. Please don't think we made this decision lightly. It actually took us several days to come to a consensus. Now what we also don't want to do is leave users in the dark. This is why we released Alamofire 3.5.0 supporting both Swift 2.2 and 2.3 (not a small task) supporting iOS and tvOS 8-10, macOS 10.10-10.12 and watchOS 2-3. We also managed to get the Travis-CI yaml file working across both Xcode 7 and 8 so we have the coverage in the test suite that we're looking for. This allows anyone out there that needs to support macOS 10.10 or iOS 8 to at least have the option to do so while migrating over to Swift 3.

## Options

Now in the worst case scenario that someone is building a new macOS app in Swift 3 and needs to support macOS 10.10, then they'll need to do so in a fork. I just did it to see what would be required and it would just need availability checks around all the `StreamRequest` support. There are probably some other oddities in the test suite that would need to be addressed as well. But this is really worst case scenario if the Alamofire 3.5.0 release just cannot work for you.

I really hope that helps explain our point of view on this matter. Again, it wasn't an easy decision, but we stand by it being the correct one for the community as a whole.

Cheers. üçª
  Absolutely! Great call @rastersize. This was always the intent, but we missed this change when the GM dropped.

Cheers. üçª
  This is a great catch @tremblay! I don't really like modifying the public API that way though. The core issue is that `URLRequest` conforms to `URLStringConvertible` and I'm really leaning towards removing that functionality for the exact reason you posted. I'm going to try this out and see how it feels. Not sure of all the implications of removing the conformance there.

Stay tuned.
 Man, great catch @tremblay! I just put together #1491 that takes a different approach to solving the same problem. I'd love to get your thoughts there. We spent forever (literally hours) trying to get the public APIs just right and to be consistent across different request types. I think #1491 accomplishes this nicely by simply removing conformance where it isn't necessary.
 Thanks again for finding the issue @tremblay! 

We've decided to go with the approach in #1491 which has been merged into the `master` branch. I'm going to go ahead and close this PR out. If you have any feedback on the approach, please direct all future comments to #1491. We're getting really close to release, so please get your feedback in asap if you have any.

Cheers. üçª
  It will be removed once we officially release Alamofire 4.0.0 @CedricEugeni. We're working tirelessly to wrap up everything to make AF 4 as awesome as possible! We're almost 100% code complete and just need to update the docs. 

Your patience is greatly appreciated. üçª
  Hi @dylan,

II suggest you take this question to Stack Overflow. We use our GitHub project for bug reports and feature requests. I doubt there's anything that's actually wrong with Alamofire. With that said, if that does end up being the case, please post the info back on this ticket and we'll happily re-open and investigate further.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Looks like you're all squared away @adamn. üëçüèº
  Very odd...all our tests prove otherwise here. Could either of you put together a small sample app that demonstrates this issue?
 Perfect, thanks for the heads up @timgcarlson. We'll keep this open until we hear back from you.
 Awesome, thank you both for confirming.

Cheers. üçª
  @cyurtbil Alamofire works fine with the `use_frameworks!` flag, as that's the only way to build Swift pods in the first place. 

However, these types of questions are best suited for [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck!

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  The changes for Alamofire 4 are rather extensive so you'll have to explore a bit until we get the migration guide updated. Once everything is officially released it should be there.
  It's recommended that you use the `3.5.0` tag until we can get it officially released.
  Alamofire 3.5.0 only supports Swift 2.2 and 2.3. We are working on a 4.0 release which will support Swift 3. In the meantime, for Swift 3, use the `master` branch.
  A migration guide is coming but the changes for Alamofire 4 have been extensive. Until the guide is released, checkout the recently landed PRs to see what they are. Namely, there is no longer a `ParameterEncoding` enum but rather a protocol, so you'd use `JSONParameterEncoding` there. For the second, the upload progress methods have been renamed to `uploadProgress` and `downloadProgress` to properly separate them out.
  It's best to use the `master` branch for Swift 3 at the moment and we'll be releasing it as soon as the migration guide is done and CocoaPods can actually publish Swift 3 pods.
  There is an official `4.0.0` release coming with significant changes over `beta.1` and `beta.2`. Until then you can use the `master` branch and continue modifying the plist generated for the framework.
  `3.5.0` is the last of the 3.x line and Swift 2.2/2.3 compatible. `4.0.0` is coming with Swift 3 compatibility. 
 `master` is now the Swift 3 branch.
 Make sure you're using an updated version of CocoaPods.
 The `3.5.0` tag only supports Swift 2.2/2.3. For Swift 3 use `master`. Both build just fine.
 I'm going to close this issue out. The `3.5.0` tag builds just fine with the Xcode 8 GM. If it's not building correctly for you, you don't have things set up correctly. The `3.5.0` podspec is now available in the public spec repo.

Cheers. üçª
  It looks like you're using Alamofire 3.x, so in that case you'll need to create a `.Custom` encoding case and build the http body on your own. We don't support JSON arrays directly in Alamofire since there's no standard around them. But you can easily use a `.Custom` parameter encoding to do it yourself.

Cheers. üçª
  We've just released Alamofire 3.5.0 which is fully Swift 2.3 compatible.

Cheers. üçª
  Thanks for putting this together @nickplee! I ended up merging a more cohesive set of updates from our own @jshier in 418b0fc1.

Thanks anyways! üçª
  This was resolved in 418b0fc1. Cheers. üçª
  Interesting...thanks for reporting @thebluepotato!

Any chance you could put together a unit test or post sample code here that code reproduce the ambiguity warning? I haven't seen this error yet and I'd like to be able to avoid it without having the specify the `Progress` type in the single parameter closure case. I'd much rather get this fixed now since we're looking to release a bunch of things today.
 Cool, thanks for reporting @thebluepotato...we'll certainly dig into it.
 Thank you for opening this issue and providing the failing test @thebluepotato! Much appreciated!

After much investigation, there was nothing we could do that would allow us to keep both variant APIs without having to specify the type on the `progress` closure parameter. Because of this, I decided to remove the `Int64` variants for both upload and download progress. These changes have been pushed in `master` in commit 7925a0a7.

Thanks again for all your help here! üçª
  Hi @MillerJiang538,

This type of question should be opened on [Stack Overflow](https://stackoverflow.com). We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  This PR splits up validation between `Request` subclasses and adds `Data?` or `URL?` parameters to the `Validation` closure.
## Motivation

Previously, the Validation closure only exposed the optional request and response parameters making it difficult to customize validations in inline closures that were not custom extensions in the `Request` class. You didn‚Äôt have access to the actual response data. This was limiting in certain cases where you want to create a custom validation error that includes the error message buried in the server data. The only way you could do this previously was to write an extension on `Request`.

Another limitation was that the `Validation` closure did not expose the `destinationURL` for a `DownloadRequest` incase you needed to inspect the data in some special scenario.

One final reason to change up the design was that all `validate` methods could be chained on any `Request`. This doesn't make sense for `StreamRequest` types.
## Solution

Modifying the validation system to accomplish all the goals stated above meant rethinking the majority of the design and splitting it up between subclasses.
### Data Request

The `Validation` closure exposed on the `DataRequest` class is now as follows:

``` swift
extension DataRequest {
    public typealias Validation = (URLRequest?, HTTPURLResponse, Data?) -> ValidationResult
}
```

By exposing the `Data?` property directly in the closure, you no longer have to write an extension on `Request` to access it. Now you can do something like this:

``` swift
let urlString = "https://httpbin.org/get"

// When
Alamofire.request("https://httpbin.org/get", withMethod: .get)
    .validate { request, response, data in
        guard data != nil else { return .failure(ValidationError.missingData) }
        return .success
    }
    .response { response in
        debugPrint(response)
    }
```

> This will be helpful in those cases where you would like to create a custom error that includes the error message from the server that's buried in the `data`.
### Download Request

The `Validation` closure exposed on the `DownloadRequest` class is now as follows:

``` swift
extension DownloadRequest {
    public typealias Validation = (URLRequest?, HTTPURLResponse, URL?) -> ValidationResult
}
```

The `URL?` parameter allows you to access the response data downloaded from the server and stored in the `destinationURL`. This allows you to inspect the data inside the file if you've determined you need to in order to create a custom error.

``` swift
let fileURL = URL(fileURLWithPath: FileManager.documentsDirectory + "/test_response.json")

Alamofire.download(urlString, to: { _, _ in fileURL }, withMethod: .get)
    .validate { request, response, fileURL in
        guard let fileURL = fileURL else { return .failure(ValidationError.missingFile) }

        do {
            let _ = try Data(contentsOf: fileURL)
            return .success
        } catch {
            return .failure(ValidationError.fileReadFailed)
        }
    }
    .response { response in
        debugPrint(response)
    }
```
### DRY by Design

Since the default validation methods supported in AF are the same between data and download requests, I decided to DRY things up by pulling the validation logic out into a `fileprivate` set of extensions on `Request`. This is very similar to how the response serialization logic was DRY'd up as well.
## Session Manager

I also snuck in commit c46bc01f into this PR that updates the `SessionManager` to leverage the new `TaskConvertible` conformance to generate the `URLSessionTask` instances. This cleans up a bunch of duplicated logic that I should have caught in the earlier PRs. This commit doesn't change any functionality, just DRYs things up a bit.

---
## Summary

These changes allow inline validation closures to be much more powerful, eliminates chaining validation APIs on `StreamRequest` instances, and exposes the `destinationURL` directly to the inline closure. We'll want to update the Validation section of the README to include examples of best practices here.

> We need to make sure people understand they shouldn't parse the response data unless they know they're in a failure case where they want to dig the error message out.
 cc @jshier and @kcharwood for review.
 @cnoon Review complete. Great changes! Just some minor comments.
 Thanks for the review @jshier! All the comments have been addressed, I'm going to go ahead and move this one through.
  Thanks for the PR @dhanushram, but we won't be accepting this change for the same reasons we rejected it in #1056.

Thanks anyways. Cheers. üçª
 My apologies here @dhanushram...I completely misunderstood what you were doing. Too many late nights. I'm going to re-open and investigate further.
 This seems like what Argo had to deal with in properly detecting `Bool` from `JSONSerialization`. Their solution was to [drop down to CoreFoundation](https://github.com/thoughtbot/Argo/blob/841979f8b8341b7818a15e67662157c4580151f1/Argo/Extensions/NSNumber.swift) and use those APIs to properly detect that an `NSNumber` contained a `Bool`. I think that's the solution we need here. We can cast to a a `Bool` then check if it's an `NSNumber`. If it isn't we're good, it's a `Bool`. Otherwise check to see if the `NSNumber` contains a `Bool`.
 Thanks for putting this together @dhanushram...much appreciated! @jshier is certainly right and it required a more robust check. We had to do something similar in Elevate. I've implemented a `fileprivate` NSNumber extension in the `ParameterEncoding.swift` file and leveraged it in the `queryComponents` API. I've also added failing (now passing) unit tests. I pushed up the fix to `master` in 72958d0e.

Thanks again! üçª
  Thank you for the feature request @tobiasoleary!

While I understand where you're coming from, I don't think that's quite how we want to try to handle that case. If validation is failing, then validation is what should generate the error causing your response serializer to not be run b/c an error had already occurred. What this means is that if you encounter a validation error, you should extract the error message from the server data directly in the validation closure. This is not currently possible in Alamofire 3 unless you write an extension on `Request`.

In Alamofire 4, we've made it easier to parse errors out of the server data if necessary by adding the `data` or `temporaryURL` and `destinationURL` to the respective `DataRequest` or `DownloadRequest` validation closures. More details can be found in the [migration guide](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%204.0%20Migration%20Guide.md#response-validation). What this ultimately allows you to do is:

``` swift
Alamofire.request(urlString)
    .validate { request, response, data in
        guard let data = data else { return .failure(customError) }

        // 1) Validate the response to make sure everything looks good
        // 2) If validation fails, you can now parse the error message out of the
        //    data if necessary and add that to your custom error if you wish.

        return .success
    }
    .response { response in
        debugPrint(response)
    }
```

If you do share the exact same response serializer to parse out the error message as you use in the response handler, then you can just reuse the serializer in the validation failure case. In many cases though the payload for the failure will be different than the success so you'd need to use different parsing logic.

Hopefully that helps clarify things and get you pointed in the right direction.

Cheers. üçª
  Issue has been fixed in 72958d0e. Thank you for reporting @dhanushram!
  Fixes #1452 

This PR updates our `User-Agent` string generation to not only fix the issue reported but bring it more in line with [RFC7231](https://tools.ietf.org/html/rfc7231#section-5.5.3) in regards to where the various bits of information live. It now looks something like this: `iOS Example/1.0 (com.alamofire.iOS-Example; build:1; iOS 9.3.0) Alamofire/3.4.2`. This more closely matches the `User-Agent` strings returned by browsers and now includes the Alamofire version.
 Thanks for putting this together @jshier! I made some small modifications (formatting and doc clarification) and pushed commit 68ddac4d into `master` while keeping attribution. I'll also take care of cherry picking this into the `swift2.3` and `swift3` branches right now.
  This PR splits up the `Request` class into `DataRequest`, `DownloadRequest`, `UploadRequest` and `StreamRequest` subclasses.
## Motivation

There were several reasons why the `Request` class could greatly benefit from being split up. 
### Progress

The first reason is that the progress APIs were stomping on each other and were confusing the users. For example, the upload progress behavior was very ambiguous considering that the same `Progress` instance was used to report both upload progress and then download progress after the upload was complete.
### Session Manager Duplication

The `feature/adapter-and-retrier` PR added the `TaskConvertible` enumeration to the `Request` class. Unfortunately, there is a large amount of duplication between the `TaskConvertible` implementation and the `Downloadable`, `Uploadable` and `Streamable` enumerations inside the `SessionManager`. Not only is there duplication, but the `Downloadable`, `Uploadable` and `Streamable` enumerations don't really belong in the `SessionManager` anyways. They're really the pieces required to construct a concrete `Request`.

By splitting up the `Request` into subclasses, we could move the `Downloadable`, `Uploadable` and `Streamable` implementations into their respective subclass and eliminate the duplication with the `TaskConvertible` enumeration in the `Request` class.

In the previous PR where the `TaskConvertible` enumeration was added, the `Downloadable`, `Uploadable` and `Streamable` enumerations
### Response Serializers

Another awesome reason for splitting up the `Request` class is to associate response serializers with a particular request type. For example, right now you can chain a `responseData` closure onto a `Request` that is backed by a `URLSessionDownloadTask` or a `ULRSessionStreamTask`. However, if you do this, what's the behavior? It currently gets really weird in all these cases when you start to consider resume data. 

Also, how does one get the destination URL of a download? Great question, right now it is WAY more difficult than it should be. By splitting up the `Request`, we can extend only certain subclasses to support specific response serializers that are tailored to the underlying type of task. These changes will be coming in a future PR.
## Solution

So now that we have some background as to why these changes would be useful, let's dig into what had to change to make this work.
### TaskConvertible

By pulling the `Downloadable`, `Uploadable` and `Streamable` enumerations into their respective subclasses and adding a `Requestable` enumeration to the `DataRequest` subclass, I was able to get rid of the `TaskConvertible` enumeration and make it a protocol. The protocol now creates a `URLSessionTask` from a session, adapter and queue. This allows the subclassed enumerations to construct the tasks directly without having to do this in the `SessionManager`. This greatly simplifies the `SessionManager.retry` method.
### Progress

The progress APIs have been completely rebuilt from scratch. You can now monitor `downloadProgress` on data, download and upload requests. You can also monitor `uploadProgress` on an upload request. There are variants for both the `Progress` object and the broken out `Int64` values. Each variant can also call the progress closure on a specified queue.

Here's a quick example of how you can use the new APIs.

``` swift
Alamofire.upload(data, to: urlString, withMethod: .post)
    .uploadProgress { progress in
        // Called on main dispatch queue by default
        print("upload progress: \(progress.fractionCompleted)")
    }
    .uploadProgress(queue: DispatchQueue.utility) { bytesSent, totalBytesSent, totalBytesExpectedToSend in
        // Can customize the dispatch queue for background operations if needed
        print("Sent: \(bytesSent), Total Sent: \(totalBytesSent), Total Expected: \(totalBytesExpectedToSend)")
    }
    .downloadProgress { progress in
        // Called on main dispatch queue by default
        print("download progress: \(progress.fractionCompleted)")
    }
    .downloadProgress { bytesRead, totalBytesRead, totalBytesExpectedToRead in
        // Called on main dispatch queue by default
        print("Read: \(bytesRead), Total Read: \(totalBytesRead), Total Expected: \(totalBytesExpectedToRead)")
    }
    .response { response in
        debugPrint(response)
    }
```
#### Download Progress

The download progress is now being tracked in the `DataTaskDelegate`. This allows the data, download and upload requests to leverage it. I debated for a long time as to whether to call this `progress` or `downloadProgress`. I would rather error on the side of verbosity here I think. I ultimately decided upon `downloadProgress` because `progress` is REALLY ambiguous when it comes to an upload request.

> If anyone strongly disagrees here, please voice your concerns. I'm still on the fence on this one, but right now lean towards `downloadProgress` and `uploadProgress` APIs to completely avoid ambiguity.
#### Upload Progress

The upload progress is all managed by the `UploadTaskDelegate` and is only exposed publicly through the upload request subclass. The stream request cannot chain `downloadProgress` or `uploadProgress` APIs because it no longer inherits them.
### Top-Level Stream APIs

I added the top-level stream APIs to `Alamofire.swift` because they were missing. Just wanted to callout that this random change made its way into this PR as well.

---
## Summary

These changes vastly improve the `progress` APIs and open up the ability to greatly specialize the available chained methods for each subclass. This will help avoid confusion and will allow for better customization for each request type.
 cc @jshier and @kcharwood for review.
 @cnoon Review complete. Not much feedback here, looks great!
 All changes have been addressed @jshier. I'm going to merge this bad boy.
  Like @tobiasoleary said, these types of questions are best suited for [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck!

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Thanks for the PR!

First, this is unnecessary, as CocoaPods as of `1.1.0.beta.1` (which you need to be using for Xcode 8 compatibility anyway) will set the `SWIFT_VERSION` of the generated `Pods` project to whatever the target project specifies. Second, it doesn't fix our current issue with publishing the `4.0.0-beta.2` spec, which you can read more about [here](https://github.com/CocoaPods/CocoaPods/issues/5796). To fix that issue requires a change on the CocoaPods side. Once we have a resolution to that issue we'll make the necessary changes, if any. Until then, using the CocoaPods beta works fine for consumers of the framework.

Cheers!
  Thank you for reporting @sureshven. This issue has been resolved in PR #1456 and commit 68ddac4d. It's also been cherry picked into the `swift2.3` and `swift3` branches and will be released very soon.

Cheers. üçª
  You need to use the CocoaPods `1.1.0` beta series.
  This PR adds a couple powerful protocols, `RequestAdapter` and `RequestRetrier`, that open up all sorts of possibilities including:
- Easing `Request` modifications for `Authorization` headers
- Retrying requests that encountered an error with a custom exponential backoff retry policy
- Completely thread-safe refresh systems for web services behind OAuth2 authentication

I'm sure there are all sorts of other cool things you could do with this, but these are the main things I had in mind when putting this together.
## RequestAdapter

The `RequestAdapter` protocol allows each `Request` made on a `SessionManager` to be inspected and adapted before being created. One very specific way to use an adapter is to append an `Authorization` header to requests behind a certain type of authentication.

``` swift
class AccessTokenAdapter: RequestAdapter {
    private let accessToken: String

    init(accessToken: String) {
        self.accessToken = accessToken
    }

    func adapt(_ urlRequest: URLRequest) -> URLRequest {
        var urlRequest = urlRequest

        if urlRequest.urlString.hasPrefix("https://httpbin.org") {
            urlRequest.setValue("Bearer " + accessToken, forHTTPHeaderField: "Authorization")
        }

        return urlRequest
    }
}

let sessionManager = SessionManager()
sessionManager.adapter = AccessTokenAdapter(accessToken: "1234")

sessionManager.request("https://httpbin.org/get", withMethod: .get)
```
## RequestRetrier

The `RequestRetrier` protocol allows a `Request` that encountered an `Error` while being executed to be retried. When using both the `RequestAdapter` and `RequestRetrier` protocols together, you can create credential refresh systems for OAuth1, OAuth2, Basic Auth and even exponential backoff retry policies. The possibilities are endless. Here's a short example of how you could implement a refresh flow for OAuth2 access tokens.

``` swift
class OAuth2Handler: RequestAdapter, RequestRetrier {
    private typealias RefreshCompletion = (_ succeeded: Bool, _ accessToken: String?, _ refreshToken: String?) -> Void

    private let sessionManager: SessionManager = {
        let configuration = URLSessionConfiguration.default
        configuration.httpAdditionalHeaders = SessionManager.defaultHTTPHeaders

        return SessionManager(configuration: configuration)
    }()

    private let lock = NSLock()

    private var clientID: String
    private var baseURLString: String
    private var accessToken: String
    private var refreshToken: String

    private var isRefreshing = false
    private var requestsToRetry: [RequestRetryCompletion] = []

    // MARK: - Initialization

    public init(clientID: String, baseURLString: String, accessToken: String, refreshToken: String) {
        self.clientID = clientID
        self.baseURLString = baseURLString
        self.accessToken = accessToken
        self.refreshToken = refreshToken
    }

    // MARK: - RequestAdapter

    public func adapt(_ urlRequest: URLRequest) -> URLRequest {
        if urlRequest.urlString.hasPrefix(baseURLString) {
            var mutableURLRequest = urlRequest
            mutableURLRequest.setValue("Bearer " + accessToken, forHTTPHeaderField: "Authorization")
            return mutableURLRequest
        }

        return urlRequest
    }

    // MARK: - RequestRetrier

    public func should(_ manager: SessionManager, retry request: Request, with error: Error, completion: RequestRetryCompletion) {
        lock.lock() ; defer { lock.unlock() }

        if let response = request.task.response as? HTTPURLResponse, response.statusCode == 401 {
            requestsToRetry.append(completion)

            if !isRefreshing {
                refreshTokens { [weak self] succeeded, accessToken, refreshToken in
                    guard let strongSelf = self else { return }

                    strongSelf.lock.lock() ; defer { strongSelf.lock.unlock() }

                    if let accessToken = accessToken, let refreshToken = refreshToken {
                        strongSelf.accessToken = accessToken
                        strongSelf.refreshToken = refreshToken
                    }

                    strongSelf.requestsToRetry.forEach { $0(succeeded, 0.0) }
                    strongSelf.requestsToRetry.removeAll()
                }
            }
        } else {
            completion(false, 0.0)
        }
    }

    // MARK: - Private - Refresh Tokens

    private func refreshTokens(completion: RefreshCompletion) {
        guard !isRefreshing else { return }

        isRefreshing = true

        let urlString = "\(baseURLString)/oauth2/token"

        let parameters: [String: Any] = [
            "access_token": accessToken,
            "refresh_token": refreshToken,
            "client_id": clientID,
            "grant_type": "refresh_token"
        ]

        sessionManager.request(urlString, withMethod: .post, parameters: parameters, encoding: .json).responseJSON { [weak self] response in
            guard let strongSelf = self else { return }

            if let json = response.result.value as? [String: String] {
                completion(true, json["access_token"], json["refresh_token"])
            } else {
                completion(false, nil, nil)
            }

            strongSelf.isRefreshing = false
        }
    }
}

let baseURLString = "https://some.domain-behind-oauth2.com"

let oauthHandler = OAuth2Handler(
    clientID: "12345678",
    baseURLString: baseURLString,
    accessToken: "abcd1234",
    refreshToken: "ef56789a"
)

let sessionManager = SessionManager()
sessionManager.adapter = oauthHandler
sessionManager.retrier = oauthHandler

let urlString = "\(baseURLString)/some/endpoint"

manager.request(urlString, withMethod: .get).validate().responseJSON { response in
    debugPrint(response)
}
```

---
## Tests

I've added tests around the `RequestAdapter` to make sure all the `SessionManager` APIs actually  call the `adapter` if set. I also added tests verifying the `retrier` is called when errors occur and that the `adapter` will be called again when the request is retried.
## Internal Modifications

There are several internal changes that are worth calling out to make this work.
### Validations

The first is that `Validation` is no longer run on the delegate's `OperationQueue`. In order to determine whether a `Request` encountered an error, we need to make sure we run all the validations first, otherwise the error won't be set and the `retrier` won't be called. This was a trivial change to implement, but is an important callout.
### TaskConvertible

The `TaskConvertible` enum nested in the `Request` class allows us to store the un-adapted version of the `Request` before it is adapted and turned into a `URLSessionTask`. The `retry` method on the `SessionManager` uses the new `originalTask` property to extract the original urlRequest, adapt it if necessary, then create the new task and apply it to the `Request`. By setting a new task on the `TaskDelegate`, it automatically resets all the data tracked in the `TaskDelegate` as though it is a brand new task.
### SessionDelegate

The `SessionManager` must be passed down to the `SessionDelegate` as a `weak` property in order to allow the `SessionManager` to retry the `Request` from the `SessionDelegate`. I originally had the retry logic in the `Request` class, but it became problematic when trying to figure out how to lock down the task creation on the `SessionManager` queue. While I don't love having to store the parent reference in the child, it's not so bad since it's not exposed publicly and it doesn't result in a retain cycle since it's a `weak` reference. 

> I'm very open to suggestions here on a better approach, but I think this is about the cleanest way to do it.
## README Updates

I've added a `Adapting and Retrying Requests` section to the README to walk users through some of the ways you could use these protocols. I also created a fairly detailed `OAuth2` example to demonstrate how to start to build a thread-safe refresh system that could be shared across multiple session managers.

---
## Summary

Overall I think these are two very powerful protocols that will open up all sorts of possibilities for the Alamofire community. I'd love to see custom `RequestRetrier` implementations for linear and exponential back-off policies for things like background sync operations. Can't wait to see what everyone comes up with!
 cc @jshier and @kcharwood. I'd love to get your guys thoughts here.
 @cnoon Initial review complete. We discussed some of the general issues I had but it looks great otherwise!
 Thanks for all the awesome comments here @jshier. Everything has been addressed at this point so I'm going to merge it in to keep the ball rollin'. üëçüèº
  Hi @tib,

You can speed up your builds using Carthage by specifying a single platform using the `--platform` flag.

``` bash
$ carthage build --platform iOS
```

Now as far as moving to a universal framework, this is not something we're going to do at this time. Until it's officially support by Apple, we'll continue to use our current approach. There are enough edge cases and complexities around testing that the pros do not outweigh the cons in our opinion. This is something that will continue to investigate and re-evaluate. But at this time we'll continue to to use the four target approach in AF and AFI.

Cheers. üçª
  Come on @datomnurdin...how about actually reading the information you just posted?

Please follow the three helpful bullet points that CocoaPods is already giving you. If you continue to have issues, please take you question to Stack Overflow or to the CocoaPods team.
  Hi @SIT3131,

First off, there's not a question here. Secondly, questions like these should be asked on [Stack Overflow](https://stackoverflow.com). We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @iAviatorJose,

This type of question is best suited for [Stack Overflow](https://stackoverflow.com) with an `alamofire` tag. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  @iamjono Thanks for the report. It looks like they've fixed several issues they had with the switch from escaping to non-escaping as the default. We'll be sure to issue a new build when those changes make it into a shipping Xcode. Unfortunately we don't support building Alamofire against development toolchains. Cheers!
  Thanks @donnywals! üçª
  Hi @JustinJiaDev,

Thank you for the suggestions. The reasons why there's currently a mismatch is that we have not updated the documentation for the Swift 3 / Alamofire 4 release. We're still working on some fairly large changes to the library. Once the changes are in, we'll update the documentation and put together an Alamofire 4 migration guide before the release. Until then, you'll need to look at the actual logic in the repo and adjust the code samples accordingly.

Cheers. üçª
  Hi @ptaking,

You're looking for `.ReloadIgnoringLocalCacheData` and `. ReturnCacheDataDontLoad`. Please refer to the [documentation](https://developer.apple.com/reference/foundation/nsurlrequestcachepolicy?language=objc) for more info or this excellent NSHipster [article](http://nshipster.com/nsurlcache/).

In the future, I'd recommend opening a question on [Stack Overflow](https://stackoverflow.com) for questions like this. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  @RahulKatariya Alamofire 4 adopts Swift 3's new `Error` based error handling. What were once `NSError`s in the `NSURLErrorDomain` can now be cast to `URLError`, which has specific codes that cover what you want. I'd suggest that route rather than casting to an `NSError`.
  Thanks @trichner...you'll need to pass a `name` @pangpingfei even if it's just some made up name that the server ignores. It's part of the spec.

Best of luck! üçª
  @cosmo1234 I'm not sure why the printing is relevant here, but the debug output of a dictionary will differ from the representation sent as JSON, that's just how `print` works.

These types of questions are best suited for [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck!

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  You are completely right. I'm working on fixing the issue now.
 I reverted d480f4d8 which is what introduced the issue, then applied the actual change to `SessionManager` in 62e82422 and released it as `4.0.0-beta.2`.

Thanks for reporting this right away!

Cheers. üçª
  @Noobish1, please see #1367 for more info on iOS 8 support. @leebros we won't be merging the `swift3` branch into `master` until the Xcode 8 GM is released.
  We've completely changed the APIs in the `swift3` branch. You'll need to adjust your app code accordingly. Nothing has been officially released, so our documentation is still out-of-date on the `swift3` branch. We're waiting to update it all until we finalize all the code changes.

Cheers. üçª
  Hi @Igor-Palaguta...thank you for the feedback. Your assessment here of the behavior is spot on. We've completely redesigned the download and upload progress system in Alamofire 4. You can take a look at the new updates in our [Migration Guide](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%204.0%20Migration%20Guide.md#download-and-upload-progress).

Cheers. üçª
  Thanks @MainasuK. üçª

We'll be cutting the beta.1 releases shortly once we get the `AFError` PR through. Until then, you can use @MainasuK's solution. You could also point to a specific commit hash on the `swift3` branch rather than the `swift3` branch itself in the Podfile to save yourself from a future breaking update.

Cheers. üçª
 @JaviSoto AFI hasn't been fully updated for `4.0.0-beta.2`, so you'll need to lock your Podfile to the last compatible commit.
  As mentioned in [our documentation](https://github.com/Alamofire/Alamofire#server-trust-policy-manager) you need to keep a reference to manager you've created around somehow. If you don't it will be deallocated once it leaves scope an you'll see your observed behavior.
  @yuweipei If you're having trouble with AlamofireImage, please open an issue on that repository. Thanks!
  So to all of you convinced "the data is gone"...it's not. 

## Response Struct

The data is ALWAYS passed back to you in EVERY response serialization closure as part of the `Response` object in AF 3. Take a look at the `Response` struct:

``` swift
/// Used to store all response data returned from a completed `Request`.
public struct Response<Value, Error: ErrorType> {
    /// The URL request sent to the server.
    public let request: NSURLRequest?

    /// The server's response to the URL request.
    public let response: NSHTTPURLResponse?

    /// The data returned by the server.
    public let data: NSData?

    /// The result of response serialization.
    public let result: Result<Value, Error>

    /// The timeline of the complete lifecycle of the `Request`.
    public let timeline: Timeline
}
```

Is the `data` property not clear? Did anyone think to check it? Notice the `[Data]: 83 bytes` that keep getting printed out when you use `debugPrint` @tylerlong and @gchaturvedi? Come on guys, help yourselves out a bit here...

## Validation

To your last point @tylerlong:

> It does contain some quite useless message like Response status code was unacceptable: 400 which is not the message from the server at all.

How is that "useless"? The error tells you "exactly" what went wrong with the request. You told Alamofire to validate the request, it did and told you why it failed.

## History Lesson

If you don't run validation on the response, you're saying that as long as the request didn't encounter an error, I consider the request a success and I'm going to handle the result in my response serializer. However, the validation APIs exist if you decide that you'd prefer to have Alamofire hand you an error in your response serializer if the response wasn't formatted the way you wanted. This has always been a choice up to the user.

Now at some point in the Alamofire releases, we realized that you always want to have access to the data that came back from the server in a success or failure case for the exact reasons you have all put in here. It can be useful! So as you can see, all the response serializers hand you back the server data directly regardless of what the result type is.

Hopefully that helps.

Cheers. üçª
 @tylerlong...see @tobiasoleary's comment. Also re-read mine again. You're not looking at the `data` property, you're looking at what's being printed out.
  Hi @srinadh588,

There's an example of posting JSON to a server in our README which can be found [here](https://github.com/Alamofire/Alamofire#post-request-with-json-encoded-parameters).

``` swift
let parameters = [
    "foo": [1,2,3],
    "bar": [
        "baz": "qux"
    ]
]

Alamofire.request(.POST, "https://httpbin.org/post", parameters: parameters, encoding: .JSON)
// HTTP body: {"foo": [1, 2, 3], "bar": {"baz": "qux"}}
```

In the future, I'd recommend opening a question on [Stack Overflow](https://stackoverflow.com) for questions like this. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @mattnedrich,

This is not an issue with Alamofire. We have many people using Alamofire with CocoaPods without issue. I'd recommend opening a question on [Stack Overflow](https://stackoverflow.com) for questions like this. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  If you MUST have the `Request` returned from `hackSociety` (bonus points for Mr. Robot refs), then you could create the `MultipartFormData` on your own, encode it, then pass that off to the `upload(data:)` API instead. This would allow you return the `request` immediately rather than having it be an async operation.

Now let me stress here that unless you're dealing with super small payloads, you don't want to be doing this on the main thread. The multipart form data upload APIs are designed to be async because generally they need to be.

Cheers. üçª
  Hi @Shunzi007,

This type of question is best suited for Stack Overflow. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Thanks @kemchenj. üçª

There are a bunch of changes in the `swift3` branch @Urkman. We're working on Alamofire there, so you'll need to dig into each compiler error with the assumption that the APIs may not be the same anymore.

Cheers. üçª
  Hi @filippovdev,

The only way the request will be made a second time is if you're either providing a credential through something like the `authenticate` method, or there's a credential being picked up from the `URLCredentialStorage`. If there's no credential, then the request will immediately fail and won't be retried.

If you absolutely want to disable this functionality, you can, but I'd advise you not to. How you would turn this off would be:

``` swift
let delegate = Alamofire.SessionManager.shared.delegate

delegate.taskDidReceiveChallengeWithCompletion = { session, task, challenge, completion in
    completion(.performDefaultHandling, nil)
}
```

Again, I wouldn't recommend you do this as this will disable other functionality in Alamofire such as the ability to do certificate or public key pinning.
  Methods are now lowercase: you need to use `.post`. 
  You need to use:

```
let parameters: [String: Any] = ["key": "value"]
```

Swift 3 in beta 6 now switches to using `Any` instead of `AnyObject` for most serialization APIs.
  This is intentionally the build number, though I guess the variable name is incorrect. The actual app version is built in the later lines, where we query `NSProcessInfo`.
 @antrix1989 Looking at it again, you're correct. However, both the app version and build number are useful bits of information, so they should likely both be in the user agent. Something like this:

``` swift
let userAgent: String = {
    if let info = NSBundle.mainBundle().infoDictionary {
        let executable = info[kCFBundleExecutableKey as String] as? String ?? "Unknown"
        let bundle = info[kCFBundleIdentifierKey as String] as? String ?? "Unknown"
        let version = info["CFBundleShortVersionString"] as? String ?? "Unknown"
        let build = info[kCFBundleVersionKey as String] as? String ?? "Unknown"

        let osNameVersion: String = {
            let version = NSProcessInfo.processInfo().operatingSystemVersion
            let versionString = "\(version.majorVersion).\(version.minorVersion).\(version.patchVersion)"

            let osName: String = {
                #if os(iOS)
                    return "iOS"
                #elseif os(watchOS)
                    return "watchOS"
                #elseif os(tvOS)
                    return "tvOS"
                #elseif os(OSX)
                    return "OS X"
                #elseif os(Linux)
                    return "Linux"
                #else
                    return "Unknown"
                #endif
            }()

            return "\(osName) \(versionString)"
        }()

        return "\(executable)/\(bundle) (\(version)/\(build); \(osNameVersion))"
    }

    return "Alamofire"
}()
```
 Thanks for the changes @antrix1989! We made some small modifications to your PR and pushed them into `master` in commit [`31b882`](https://github.com/Alamofire/Alamofire/commit/e84a9aae9d6c2b9db68268c51102ad3b0031b882) while maintaining your attribution. Thanks again!
  Hi @shahdhiren,

You absolutely can, but this type of question is best suited for [Stack Overflow](https://stackoverflow.com) with an `alamofire` tag. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  To use Xcode 8, please use the `swift3` branch. If you're using CocoaPods, you must be using version 1.1.0.beta.1.
  Hi @chaocharleswang,

These types of questions are best suited for Stack Overflow with an `alamofire` tag. We use our GitHub project to bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @martinkaplan,

The issue I think you're running into is that Alamofire cannot encode your `parameters` as valid JSON. Most likely something is wrong with your `parameters` dictionary. I don't see anything obvious in the sample code you posted. I also answered the Stack Overflow question you posted about the `NSDate` encoding.

What I'd recommend you do is try to encode that `parameters` object using `NSJSONSerialization` directory to figure out why the decoding is failing. Once you have that figured out, it should just start working in Alamofire.

In the future, I'd recommend opening a question on Stack Overflow for questions like this. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Thanks for putting this together @littleowl. We've completely the port to beta 6 in #1413. Additionally, we won't be modifying the deployment targets for the Alamofire 4.0.0 release.

Cheers. üçª
  If you're trying to validate that you received a `image/jpeg` content type and you actually received `html/text` content, wouldn't you expect the validation to fail?

It seems to me that you enabled content type validation for `image/jpeg`, but then realized it was failing so you wanted to suppress the error rather than figure out why the validation was actually failing.

You cannot comment out that line of logic. It is there for a very good reason. It's saying that if you didn't get any data back, then you shouldn't produce a content type validation error because the content type doesn't apply to the non-existent data.

I'm going to close this issue out as support for now. If you continue to have issues, then I'd suggest you take this question to Stack Overflow.

Cheers. üçª
  We've managed to get all the refactoring done and pushed up into the `swift3` branch in #1413. I'm going to go ahead and close this issue out. Please redirect any further questions or feedback to #1413.

Cheers. üçª
  Please see #1367 for a full description of the Alamofire 4.0.0 and 3.5.0 releases.
  You're likely running into an issue with ATS. Please check Apple's documentation for more details.

These types of questions are best suited for [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  @thomstark This doesn't seem to be an Alamofire specific issue.

These types of questions are best suited for [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  @patricks Using the `ParameterEncoding` `.Custom` should allow you to accomplish this. If that doesn't have the flexibility you require, writing your own method of request serialization isn't that hard, it just requires you to operate outside of the methods provided for you by Alamofire. Take a look at the different `ParameterEncoding` method and you should be able to create your own pretty easily and integrate it into your request creation. Our parameter encoding documentation starts [here](https://github.com/Alamofire/Alamofire#parameter-encoding).
  @mengheangrat Error 3840 is a JSON encoding error, which means there's something wrong with a response you expected as JSON.

However, these types of questions are best suited for [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  We'll be merging the `swfit3` branch into `master` at some point in the future, but not until closer to the Xcode 8 release date.
  Updates the podspec to version 4.0.0 and sets the deployment targets to match the project‚Äôs new deployment targets.

Also fixes a build issue with the iOS Example app.
 Looks good to me @jshier. 
 You cannot use Alamofire 4 with a deployment target of iOS 8.0 @rs10693.
  @mltk96 If you're using Xcode 8, you'll need to update to CocoaPods 1.1.0 beta 1, following the instructions on their site. After that, make sure you're using either our `swift2.3` or `swift3` branch.
 Okay, what version of everything are you using and how are you integrating Alamofire into your project?
  Hi @JourneyWind,

We won't be merging into `master` until the Xcode 8 GM drops. At that time, we'll be releasing both the `swift2.3` branch as AF 3.5.0 and the `swift3` branch as AF 4.0.0. This is our current plan, but we're trying to squeeze in some pretty big changes for AF 4.0 that may cause us to delay slightly.

Cheers. üçª
  Gzip compression is automatically handled by iOS when downloading data from the server if you supply the `gzip` encoding in the [Accept-Encoding](https://github.com/Alamofire/Alamofire/blob/master/Source/Manager.swift#L50) header.

When uploading data, you will need to Gzip the data on your own if you need that functionality. We currently do not support Gzipping data for `MultipartFormData` uploads.

If you do end up building out a solution for this, I'm sure we'd consider adding such a feature to Alamofire directly. The one callout I have is that it will need to use Apple only frameworks if it is going to be part of Alamofire.

Cheers. üçª
  Indeed it would, but the `ParameterEncoding` type supports other encoding methods which wouldn't support `AnyObject` very well. If you need to create more custom encoding types, you'll need to use the `.Custom` case.

Cheers. üçª
  Hmmmm...that's odd. I wonder if we need to add the availability checks back in that I removed. We'll need to investigate more here @Urkman...thanks for reporting. üçª
 This has been fixed by #1401. Create a new issue if you have an further problems.
  Thanks for putting this together @jhudsonWA! It looks like we just missed this in the refactor.
  You'll need to pull from the `swift2.3` or `swift3` branches to compile in Xcode 8, as it only supports those two versions of Swift.
  @ZetrixWeb-iOS As you can see in [our documentation](https://github.com/Alamofire/Alamofire#http-headers), you can add headers to requests very easily. You can also add headers to every request in a `NSURLSession` by modify the `NSURLSessionConfiguration`, as show in our documentation [here](https://github.com/Alamofire/Alamofire#modifying-session-configuration). 
  Current `swift3` branch is up to date with beta 5.
  The `swift2.3` branch is up to date with beta 5.
  It's likely you're issue is the encoding of the data into a string in the source file in the first place. What I'd suggest is perhaps Base64 encoding your certificate, putting the resulting string in your source, and then decoding that into data for the trust policy. 
 @cnoon Perhaps this is a scenario we need to account for in the docs?
 This won't work @mendesbarreto. The `SecCertificateCreateWithData` API only supports `DER` encoded X.509 certificates. It says so right in the [docs](https://developer.apple.com/reference/security/1396073-seccertificatecreatewithdata?language=objc).

> Returns: The newly created certificate object. Call the CFRelease function to release this object when you are finished with it. Returns NULL if the data passed in the data parameter is not a valid DER-encoded X.509 certificate.

If you're going to use cert pinning, currently in Alamofire you'll have to embed the certs in the bundle. There's no other way to do it currently.

Cheers. üçª
  I suppose it all comes down to whether calling `suspend()` on task already in progress disconnects from the server. If it keeps the connection open, it makes sense that other tasks wouldn't start, as the connections are still at maximum. I'll do some investigation, but this is likely an underlying `NSURLSession` issue that Alamofire may not be able to do much about. If you're downloading large files, one option is to use `download` instead of `request` to start the process, when then makes it much easier to resume with partial data already on disk. That way you can just [`cancel(byProducingResumeData:)`](https://developer.apple.com/reference/foundation/nsurlsessiondownloadtask/1411634-cancel) and then resume later, rather than `suspend()`ing the task.

@cnoon Any ideas here? I'm not sure about the behavior of `NSURLSession` here.
 There's no code here to go off. You've speculated a bunch here @jshier on the what-ifs where we have no idea how @ahmad-atef is actually "cancelling" the request. We also don't know if these are download or data requests. Everything you've stated is spot on.

I'm going to close this issue out @ahmad-atef. If you end up getting us some more info, we could investigate further if needed.

Cheers. üçª
  @janhalousek We'll need more information to try and diagnose this. What versions of Alamofire, operating system, and Xcode are you using? 
 Looks to me like it's crashing when the download is complete and executing the `destination` closure to figure out where to move the file. Nothing else to go on here. Doubtful there's an actual issue here with Alamofire. Most likely there's something but implemented in the destination closure.

I'm going to close this issue out since there's nothing else we can do with the info we have.

Cheers. üçª
  @mrubin We've made this change for Alamofire 4, which can see if you use our `swift3` branch. Please give it a try and let us know what you think. If you have any issues with the new APIs as AF4 development progresses, please file another issue.
  The `NSHTTPURLResponse` is actually fairly straightforward, as it will be `nil` if, say, you created a `Request` that wasn't automatically `resume()`d and then `cancel()`d it. There was no response in that case. 

As for the `NSURLRequest`, if the request can't be `encode()`d before being sent to the underlying `NSURLSession`, then it will be `nil`, in which case the `NSURLSession` will return an error and the final `request` will be `nil`.

@cnoon Anything to add?
 The response is also going to be `nil` if you're offline. Then you'll just get a connection error and no response.

The URL request is generally only `nil` when creating stream tasks.
  These types of questions are best suited for [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  You can use `pod 'Alamofire', git: "https://github.com/alamofire/Alamofire.git", branch: "swift2.3"`. 
  @kshysius As part of that error message, the URL you were attempting to upload should have been printed as well. Make sure that URL matches your expectations and that it actually starts with `file:`. That error message is produced by Alamofire when checking to make sure the URL provided is a file URL. However, the logic is provided by the underlying `NSURL` value, so it's highly unlikely there's an issue with that logic. Please investigate and let us know if the URL being passed in was actually a file URL.
 Thanks @jshier...I'm going to go ahead and close this issue out. If anyone ends up posting anything here that leads us to believe there's an issue with Alamofire, we'll gladly re-open and investigate further.

Cheers. üçª
  Thanks for this! Unfortunately I was nearly done with my own version of this update, so I'll have to decline yours. In the future, make sure to also commit the suggested project changes from Xcode and update the iOS Example target.

I ended up adopting your use of `Swift.Error` for generic parameters, but renamed the `Error` struct to `Errors`. Relatively minor, and will likely change with future refactoring but lets us minimize any confusion at the call sites. Also, rather than dropping or changing the expected result of the test I made the test call the function that was really being tested before.

Thanks again! üëç üöÄ 
  Hi @jrlanders,

These types of questions are best suited for [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  @mojidabckuu A good question. It comes down to the fact that a multipart request can be very large and the encoding of this data can take more time than should be spent on the calling queue, so it's offloaded to a background queue. At the same time, Alamofire's `Request` type has no notion of an asynchronous `encoding` state, so there's now way for it to represent it's state before it's request is properly encoded. These two facts lead to the current implementation.

 In order to remedy this, Alamofire would either have to make all request encoding asynchronous, in which case `Request` would have to gain the notion of an encoding state and change it's behavior, or it would have to break different types of `Request` into their own subclasses, in which case only the type returned by the multipart encoding methods would know anything about an asynchronous state. 

We're considering changes along these lines for future updates. However, due to the breaking nature of such a change and all of the other changes that are already planned for Alamofire 4, it's unlikely to happen soon. However, if it's something you'd like to see, we'd consider a PR along these lines after Alamofire 4 is released.
  Hi @zkh90644,

This is something that you need to keep in your own logic. The `URLRequestConvertible` protocol clearly calls out in the documentation that your `NSURL` instances MUST conform to RFCs [1738](https://tools.ietf.org/html/rfc1738) and [1808](https://tools.ietf.org/html/rfc1808) to be used safely inside Alamofire. Since there are MANY different ways to safely escape your URLs, we leave this to the client implementations.

Cheers. üçª
  Hi @maxprig,

Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

Best of luck. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @duraiganesh0,

The problem is more likely that you're getting back a `500`. You're most likely getting back a default error message from the server that just happens to be HTML. You'll want to print out the `data` returned by the server as a string to see if that can help you figure out what you're doing wrong.

In the future, I'd recommend you open questions like this on Stack Overflow. We use GitHub for bug reports and feature requests.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @granoeste,

In approach 1, you need to create a custom `Manager` instance if you want to use custom HTTP headers. You can use approach 2 if you don't mind passing the headers in each `Request`.

In the future, I'd recommend you open this type of question on Stack Overflow. We use GitHub for bug reports and feature requests.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @arnaudlamy,

You need to convert the `NSData` returned by the server to a `String` most likely using `NSUTF8StringEncoding`. Then you can print it out. What you're seeing is how `NSData` objects are always printed out in the debugger, byte by byte in hexadecimal format.

``` swift
if let data = data, serverResponse = String(data: data, encoding: NSUTF8StringEncoding) {
    print("DATA: \(serverResponse)")
}
```

In the future, I'd encourage you to open this type of question on Stack Overflow. We use our GitHub project for bug reports and feature requests.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @kumold,

You need to check the `error` that comes back in the `Response`. It will most likely be a cancellation or timeout error.

In the future, I'd recommend you use Stack Overflow for this type of question. We use our GitHub project for bug reports and feature requests.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  The `swift3` branch now requires Xcode 8 beta 3+. We've made these changes on purpose. Please update to the beta 3 build and everything will work properly.

Cheers. üçª
  Thank you for all the reasoning you put together in this issue @tieleman. 

While we completely understand you point of view (believe me, we have discussed this at great length), we respectfully disagree with this approach. Apple recommends that developers always support the two latest operating systems. With a library as large and widely used as Alamofire, we need to make sure we are continually re-evaluating our tech debt and moving the needle forward while maintaining the best test suite possible. Because of this, Alamofire 4.x (Swift 3 only) will support iOS 9.0+, macOS 10.11+, tvOS 9.0+ and watchOS 2.0+. This allows us to continue to clean up our tech debt and run our test suite against all supported versions.

With that said, we're absolutely committed to still supporting iOS 8.x for some time. The Alamofire 3.x releases will fully support both Swift 2.2 AND 2.3 for the foreseeable future. The Alamofire 3.x versions will continue to receive bug fixes and security patches while the main focus of the team will be on Alamofire 4.x from here until the GM drops. When app developers are ready to embrace Swift 3, we feel that the majority of apps will be leaving behind support for iOS 8 deployment targets ([mixpanel](https://mixpanel.com/trends/#report/ios_9) currently reports iOS 9 adoption at over 92%). Now we realize that not everyone will do this, but we strongly believe that the majority of Alamofire users will. Even if you're one of the few, you do still have options.
1. You can continue to use Alamofire 3.x with Swift 2.3 until you're ready to drop iOS 8.x support. (this is our recommendation)
2. You could fork Alamofire 4.x and drop the deployment target until you're ready to move.

Alamofire is already segmented across three versions of Swift and 2-3 major versions of 4 different platforms spread over 3 different libraries. This is a tremendous amount of logic to support as well as keep the test suites up and running day-to-day while we try to iterate on Alamofire 4. With our small team, we need to draw the line eventually. There are always trade offs, and we've tried to make the best decisions for the community.

We're also working on publishing an Alamofire 4 evolution document with the proposals we'd like to see make it in over the next few weeks. Hopefully between the info provided in this response alongside the evolution doc, our team will have provided enough transparency and guidance to help the community move between Swift and Alamofire versions successfully and without difficulty.

Cheers. üçª
 The recommendation came from Apple in "I believe" WWDC 2014 in one of the bigger talks. I searched around [ASCIIWWDC](http://asciiwwdc.com), but I couldn't find what I was looking for. 

If I do end up tracking it down, I'll be sure to post the link here. If anyone else in the community was at the same talk I was and knows which one it was and could post the info here, it would be much appreciated.
 iOS 10 will be released one week from today. Additionally, anyone running iOS 8 can upgrade to iOS 9 for free, which they should be doing anyway, due to the rather severe security issues patched in 9.3.5. Finally, you can continue using Alamofire with the upcoming 3.5.0 release which will support iOS 8 - 10 by use of Swift 2.3.
 No, targets must be all 2.3 or all 3, due to ABI incompatibility. I think you may be able to run a Swift 2.3 app with a Swift 3 watch app but not within the same app.
 @vfn If you're going to maintain a fork with iOS 8 compatibility, you should also port over the various bug fixes and workarounds that were put in for bugs in for 8.1 and 8.2, as well as proper testing support for them as well.
 I'm going to lock this thread down. We've given many justifications as to why the deployment targets have been set to what they were in several different tickets. Please read through the justifications of all the tickets linked to this one if you're having issues.
  Looks like you've got a code signing issue. The occurrence of Alamofire in your error is merely because it's the first in the alphabetical list of dependencies which failed signing. There is a lot of help on this issue to be found elsewhere online, especially on StackOverflow. Good luck!
  Answered on Stack Overflow.
  Hi @vishnu-mee,

I'd check to make sure your `urlString` is valid and that the request is actually being sent. Then I'd set a breakpoint in your completion closure and also add some logging. If you still have trouble, I'd encourage you to open a question on Stack Overflow. That's really where this type of question should be asked. We use out GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  @flypaper0 This isn't currently built into Alamofire or the underlying `NSURLSession` classes. What is your use case here? We would need a fairly convincing reason to add such a feature when `NSURLSession` doesn't already have it, especially when the use case would be so rare (most requests are never redirected). In the meantime, you can track this information yourself by providing the appropriate closure to your `Manager`'s `delegate`. `taskWillPerformHTTPRedirection` is called whenever a redirect is performed.
 Thanks @jshier.

I'm going to close this issue out @flypaper0. If you have additional questions, feel free to ask.

Cheers. üçª
  Thanks for letting us know @grosch! This issue has been resolved in 913f98a4 where we bumped the deployment targets eliminating the need for the check.

Cheers. üçª
  Hi @thaoth58,

It appears that `NSJSONSerialization` is failing to parse your response into JSON. That's why I would debug on your end. In the future, I'd encourage you to ask these types of questions on Stack Overflow. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
 There's no need to set an encoding value because you don't need to convert to a `String` before using `NSJSONSerialization`. The `NSURLSession` already hands you back a complete `NSData` object from the server which can then be handed directly to `NSJSONSerialization`. There's no need to transform the `NSData` into a `String` before `NSJSONSerialization` gets it.
  As you can see in the error message, you can't use `==` on parameters of `ParamterEncoding` and `ParamterEncoding?`, due to one being optional. Unwrap the optional and it should work fine.
 The `ParameterEncoding` enum does not conform to the `Equatable` protocol because it uses associated values. Creating `Equatable` conformance for a set of associated value cases is a slippery slope. Mainly because you need to decide whether or not to just compare the case, or the associated values inside the case.

With that said, you should be able to use a switch statement instead.

``` swift
let isEqual: Bool

switch (encoding, expectedEncoding) {
case (.JSON, .JSON):
    isEqual = true
default:
    isEqual = false
}
```

Cheers. üçª
 @RafaelPlantard Sorry about that. You can try what @cnoon suggested or something like this:

``` swift
let equalEncodings: Bool = {
    if case .JSON = encoding {
        return true
    }

    return false
}()
```

A bit more compact.
 @RafaelPlantard If all you want to do is ensure that your encodings are the correct type, optionally casting them should work. i.e. `if let encoding = someEncoding as? JSONEncoding`. Otherwise you'd have to implement `==` for all of the types specifically.
  Hi @dahuangfengda, without any sample code to go on here, we can't reproduce the leak you're seeing. I'm going to close this issue out for now since there's not enough information to investigate. If you end up posting a sample project that can reproduce the leak, we'll gladly re-open and investigate.

Cheers. üçª
  This is all handled internally by iOS. The `9037` value is never reported in the `NSURLSession` delegate callbacks. Alamofire doesn't modify any of these values, just simply reports them back in the progress closure.

> If you feel strongly about this behavior, I'd encourage you to file a radar.

Cheers. üçª
  I agree, this has long been an annoyance for me as well. I'll look into getting it done. I think it's something that can be done without making any breaking changes, since it's just a convenience for developers. However, I don't know how this will be impacted by [Swift Evolution proposal 111](https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md) for Swift 3.
 Due to the changes in Swift 3, this isn't something you can actually do. However, we've modified all the `response` APIs in Alamofire 4 to only take a `response` object rather than the four listed above. That should make things easier.

Cheers. üçª
  You'll need to provide more information for us to help here, such as what the "make-table signal" is and how you expect to use it. What behavior are you expecting?
 Custom JSON parsing behavior is outside the scope of Alamofire. I'd encourage you to take your question to Stack Overflow. If you end up finding that there would be some benefit to extending Alamofire with some custom logic, then please feel free to open up a PR at some point and we'll certainly consider it.

Cheers. üçª
  Thanks for the work here @uny, but I was in the middle of this myself. Branch has been updated. Turns out the test failure is only on the iPhone 5 simulator for me, the other platforms expect the original version.
  @grosch We'll discuss what it would take to do this.
 No progress at all @grosch. We have however implemented a new `RequestAdapter` and `RequestRetrier` system to support auth flows like OAuth2. You can check it out in our Alamofire 4 [migration guide](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%204.0%20Migration%20Guide.md#new-features). But this will certainly not ship in Alamofire 4, if at all. We haven't had time to discuss it yet in detail.
 Hi @grosch,

I just looked through your implementation and I think it makes sense. As long as you're able to get the handshake to succeed, you should be good there. üëçüèº

Now as to whether or not we'll be adding direct support for x.509 certs in Alamofire, I'd say at this time we most likely won't add direct support for them. You're the only person that has requested support and it doesn't seem super common in the mobile world. If we end up having more people request support for client certs, we'll certainly reconsider. But for now, we'll leave client side cert authentication up to each client to implement in a manner similar to what you've posted above.

With that said, I've added a card to our Trello backlog to investigate this again in a future release. But if there isn't that much of an appetite from the community for this feature, I doubt we'll end up supporting it since it's a difficult feature to test.

Cheers. üçª
  Hmmm...good question @gordinmitya. 

The only way I know to clear out the `connection pool` you mentioned would be to `invalidateAndCancel` your current `Manager` (and underlying url session), then create a new `Manager`. Then should clear out the connection pool. 

Any chance you can give that a go?
 Awesome @gordinmitya! Glad we got to the bottom of it. üçª
  This isn't an Alamofire issue. I suggest you look at your build settings to find the difference between your Crashlytics builds and the build that is failing. Failing any obvious difference you'd be better off asking this question on StackOverflow, where more people can see it.
  There could be all sorts of issues as to why autocomplete wouldn't work correctly such as indexing is not complete, Xcode cache is corrupt, not installed correctly, machine needs to be rebooted, Alamofire hasn't been compiled in the project, etc.

With that said, it looks like autocomplete is working. Look at the 5th item down...`AlamofireVersionNumber`. That symbol comes from Alamofire. Instead, try some of the methods in our [README](https://github.com/Alamofire/Alamofire#usage).

Best of luck! üçª
  If you are using CocoaPods 1.0, `pod install` no longer updates the spec repo, so you may not see the latest version of pods. You can run `pod repo update` or just `pod update`. As was indicated in the message printed by CocoaPods.
 As the message from CocoaPods states, your pod repo is out of date. Run the command suggested to get the latest specs, in which Alamofire 3.4.1 should be found.
  Hi @ebbnormal,

It was definitely intentional to have `result.value` be optional. The `value` exists in a `.Success` case and not in a `.Failure` case. The property is merely for convenience. You certainly need to handle it being optional.

Cheers. üçª
  Hi @vishnu-mee,

Questions like these are best suited for Stack Overflow. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @girishghoda,

You need to use the `error` to check whether or not the download was successful when using the `download` APIs. Here's an [example](https://github.com/Alamofire/Alamofire#downloading-a-file-wprogress) in our README.

The `data` parameter will only be non-nil when the download fails and resume data was generated. The reason for this because of the way download tasks work with an `NSURLSession`. If you are downloading small amounts of information and need to access the data directly in-memory, then you should probably look at using the `request` APIs instead.

Cheers. üçª
 You need to read the data from the `NSURL` you provided in the `destination` closure.
  Hi @renjithr,

These types of questions are best suited for Stack Overflow. We have hundreds of tests verifying everything in Alamofire is working correctly. I'd also recommend you add a bunch more detail if you would like someone to spend time helping you with your issue.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  According to [Apple's docs](https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSURLSession_class/index.html#//apple_ref/occ/instp/NSURLSession/configuration), changes made to the configuration after session initialization don't affect the current session. To customize the underlying `NSURLSession` with a different configuration, [following the instructions in our documentation](https://github.com/Alamofire/Alamofire#modifying-session-configuration).
  Thanks, but there are already active `swift3` and `swift2.3` branches. 
 The branch certainly does compile with Xcode 8, as there is no other way to update to Swift 3. Have you updated to Xcode 8 beta 2? 
  Thanks, but our `swift2.3` has been updated.
  It could also be a bug with `httpbin.org` not responding to the basic auth request correctly. We'll have to do more testing.
 This is all URLSession here. Alamofire just hands the `URLCredential` off is there's an auth challenge that requests it. I'd file a radar if you would like to see it fixed. I'd also encourage you to try using the authorization header instead which will base64 encode the credentials before applying them to the `Authorization` header.

Cheers. üçª
  Issues of this sort are nearly always due to failing to keep a reference to your `Manager` alive. Usually you'll want a singleton value that lives outside of any view controller or other structure in the app. For more information, questions like this are a good idea for StackOverflow, where you can get implementation help. If you find a bug with Alamofire, feel free to open another issue with a code sample and we'll take a look.
  As you can see, Alamofire doesn't currently support this. We'll keep it in mind for the future though.
  This is a great suggestion. I personally haven't spent much time working with the SPM yet. Would anyone out in the community want to take a stab at this?
 I'm going to close this out for now until we have the bandwidth to properly support the SPM.
  Thanks for reporting this @fer662! I just pushed up b73893d0 which wraps the creation in a serial queue so the creation can't be done in parallel. This will be released as part of Alamofire 4.

Thanks again! üçª
  Changing the values of the configuration in a session that's already active has no effect. According to Apple's documentation on `NSURLSession`:
`Changing mutable values within the configuration object has no effect on the current session, but you can create a new session with the modified configuration object.`

I suggest you create your manager instance and customize its configuration, as [per our documentation](https://github.com/Alamofire/Alamofire#modifying-session-configuration).
 @jshier is absolutely correct here @giulio92. Your code will not end up doing anything. Instead, you need to do what @jshier suggested and either create a custom `Manager` instance, or set the values on each `NSURLRequest` you make, but then you won't be able to use the top-level APIs.

Cheers. üçª
  Alamofire already provides APIs that offer complete control over request and response serialization. What feature would the interceptor paradigm offer that isn't already achievable?
 Given the chainable nature of Alamofire's functionality, you can write those bits of functionality yourself and others can use that code. For instance, you could create a custom request method that adds the header but otherwise just exposes the normal API. A custom validator that contains the behavior you want to delete the token can be chained in as well. 

Given that, I thinks there's still some room for improvement. 
 @tobiasoleary is correct. The concept of the "interceptor" is essentially the combination of the `RequestAdapter` and `RequestRetrier` protocols added in #1450. There is a fairly detailed [example](https://github.com/Alamofire/Alamofire/tree/swift3#requestretrier) in the README right now that demonstrates how you could build an OAuth2 refresh system using it. This functionality will ship in AF 4.

I'm going to go ahead and close this issue out since those changes cover this request.

Happy refreshing! üçª
  Thanks for putting this together @passchaos...I couldn't agree more! I made some changes to your implementation and pushed it to `master` in bb55b866 while maintaining your attribution.

Thanks again! üçª
  Given that this is more of a web browser feature and Apple hasn't already done this automatically, we're going to have to be somewhat careful about implementing this outside of official `NSURL` support. 
 This is not something that we should support in Alamofire. You'll need to modify the URL before passing it into Alamofire so that it is a properly encoded, valid URL. These are the same requirements Apple has with the NSURL APIs.

``` swift
public protocol URLStringConvertible {
    /// A URL that conforms to RFC 2396.
    ///
    /// Methods accepting a `URLStringConvertible` type parameter parse it according to RFCs 1738 and 1808.
    ///
    /// See https://tools.ietf.org/html/rfc2396
    /// See https://tools.ietf.org/html/rfc1738
    /// See https://tools.ietf.org/html/rfc1808
    var urlString: String { get }
}
```

Cheers. üçª
  Hi @kshysius,

You'll need to encode the array (that's actually a dictionary by the way) into whatever data format you wish to add into the multipart form data object. I'd recommend using JSON if you don't know what to use. Your platform team should be able to tell you what they expect. Anyways, once you have it encoded into a data object, you can then use the `appendBodyPart(data:name:)` API.

Cheers. üçª
  I would suggest asking this question on StackOverflow, as this seems more like an `xcodebuild` issue than one with Alamofire, given the sheer number of apps using the framework that are successfully archived every day.
  Hi @gauravds, thank you for putting this PR together...much appreciated!

While I completely agree the whitespace should be cleaned up, I don't agree with some of the formatting changes in this PR. Because of this, I've added a `Cleanup Whitespace` aggregate target to Alamofire that will remove all the extra tabs and spaces at the end of any line. I added the target in 7789baaa and ran it in c5fe5da0. I'll be adding this new target to both AFI and AFNAI as well to keep things tidy moving forward.

Thanks again. üçª
  Questions like this are best suited to StackOverflow. If you create a question and tag it `alamofire`, the whole community can take a look for you. Generally, though, you can add headers by using the `request(_:headers:)` function. See [our documentation](https://github.com/Alamofire/Alamofire#http-headers).
  You probably need to delete `~/Library/Developer/Xcode/DerivedData` to clear out your old build products.
  It's straightforward to create your own `response` function that provides a queue. For example:

``` swift
func responseJSONOnQueue(completionHandler: (response: Response<AnyObject, NSError>) -> Void) -> Self {
    return response(queue: dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0), responseSerializer: Request.JSONResponseSerializer(), completionHandler: completionHandler)
}
```

Of course you could provide your own queue.
  This is also different in iOS 10 as well.
 Thanks for putting this together @marius-serban! I wish I would have done it this way in the first place...would have saved us a bunch of headaches. Anyways, I've made a few small tweaks to this logic and pushed it into `master` in 32ecfd16 while keeping your attribution. I'm also going to make sure these changes get cherry picked into the `swift2.3` and `swift3` branches.

Thanks again @marius-serban! üçª
  # Alamofire - Swift 3.0

The initial migration to [Swift 3.0](https://swift.org/migration-guide/) has been completed, and can be found in the [`swift3`](https://github.com/Alamofire/Alamofire/tree/swift3) branch. Many thanks to the Apple Engineers in the labs at WWDC who assisted with some of the migration issues. :beers:

Please file Github issues for any problems discovered while using this branch.

This branch should be considered a work in progress, and will be updated as future Xcode 8 and Swift 3 seeds are released by Apple.

Official support for Swift 3.0 and Xcode 8 will be not available until the fall when Apple releases both.
## Migration Notes
- Many Foundation types are now value types, instead of reference types. Please audit your code to ensure all references to `NSMutableURLRequest` are now properly handled as `var` and are of type `URLRequest`.
- Due to the Swift 3.0 naming conventions, many Alamofire API parameters that referenced an object in the URL Foundation loading system and began with capital letters now begin with lowercase letters. For example, `URLRequest` parameter names are now `urlRequest` to prevent confusion.
  
  More notes will be added as issues are discovered.
## Radars

The following radars were filed as a result of this migration and are currently being tracked by the ASF team.
- **[26850776](rdar://26850776)**: `CharacterSet` crashes when attempting to remove an item from the set in Swift 3.0
- **[26849668](rdar://26849668)**: `NSURLProtocol` APIs still contain `NSMutableURLRequest` parameter types and do not support the Swift 3.0 value types
- **[26870455](rdar://26870455)**: `NSURLSession` with background configuration does not function on the iOS simulator inside of test targets
## TODO
- [x] Update Project Recommended Settings
- [x] Update Example
- [x] Travis CI Support
- [ ] Update Documentation/README
 Branch has been updated for beta 3.

@dipang90 You likely need to update your version of Xcode 8 to the latest beta. 
 Make sure you do a `pod update` to pull the latest code. Then, if your app has already been converted to Swift 3, you can skip any conversion prompt that comes up. You'll also want to be using the CocoaPods 1.1.0 beta that was released last week, as it knows how to more properly deal with generating Xcode 8 compatible projects.
 The Swift 2.3 branch will most likely be released as Alamofire 3.5.0 and will support iOS 8 - iOS 10 on both Swift 2.2 and Swift 2.3. Alamofire 4.0.0 will only support iOS 9+. Please see #1367 for a more in-depth explanation.
 #1401 has been landed and the `swift3` branch should be fully compatible with Xcode 8 beta 5. Please note, however, that the `swift3` branch has become our Alamofire 4 development branch, so you'll likely see some breaking changes as we develop towards the AF4 release.
 Not for iOS 9, but for 10.10, yes. Latest 2 OS version, as Apple recommends.
 Continue using Swift 2.3, as Alamofire 3 will continue supporting the current versions, just with no new features.
 Not yet, the changes in beta 6 are extensive and will require a bit of work to get right. I'll see if I can get the changes up tonight or tomorrow.
 The `swift3` branch has been updated for beta 6. Be aware there have some refactors, as `Any` is now favored over `AnyObject`.
 We haven‚Äôt updated AFNAI to beta 6 yet @jmbeneUF.
 @jmbeneUF AFNAI has been updated for beta 6. Make sure you integrate it using the `swift3` branch.
 Make sure you've updated your checkout of the `swift3` branch and are using beta 6.
 Ensure you are using the latest CocoaPods beta (1.1.0.beta.1) and clear your derived data.
 @Lawris you need to use beta 6 in order to build the `swift3` branch right now.
 Instead of doing that, which you shouldn't need to, ensure you're using the latest beta and do a `pod update` so that it regenerates your project integration. If that still doesn't work you can do `pod deintegrate` and then `pod update` to redo the integration.
 I'm going to go ahead and close this issue out. Thank you everyone for all your feedback and reporting and especially you @kcharwood üçª for kicking all this off in the first place! We're getting really close to having everything locked down and will be starting on all the documentation updates here shortly.

AF 4 is coming!!! üéâüéâüéâ
 @mychaelgo `Method` has been renamed to `HTTPMethod`, to disambiguate it from the type you're seeing.
  Thanks for putting this together @adrianbrink! I made some small tweaks to your commit message and pulled the change into `master` in a53cc42b while keeping your attribution.

Thanks again! üçª
  Hi @kumangdeal,

That's the standard HTTP 1.1 response format. Looks like you received an `1102` status code from your server (that's not a valid status code) and you did actually receive JSON at the end. Most likely you haven't setup the `Request` quite right. You could use [debugPrint(request)](https://github.com/Alamofire/Alamofire#debugprintable) to help figure out what's different between your Alamofire request and your POSTMAN one.

In the future, I'd encourage you to use Stack Overflow for these types of questions. We use our GitHub project for bug reports and feature requests.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  This PR fixes some of the issues identified by #1312. This is going to need a lot of #availability wrappers, but thought I'd put it up here in case any one was curious how the rest of their code was doing on Swift 2.3
# Code Changed

The following changes were made aligned with the issues in #1312:
1. Explicitly unwrap NSURL as needed. I don't like doing this, but not sure what else to do.
2. Moved to the Enum type.
3. Explicitly unwrap SecPolicy creations. It appears that arrays with nil objects will not bridge to AnyObject's, that CFType expects to be an array.
# Unknown's

I'm not sure what the proper fix is for Swift 2.3. Changing the project file will prevent this project from supporting 2.3 and 3.0 without a branch. I imagine a lot of people will be thinking about the best solution here, the easy quick fix was to change the project file.
# New Test Failures

There are a few new test failures that need further investigation.
1. Three redirection tests are failing
2. testThatUploadingMultipartFormDataOnBackgroundSessionWritesDataToFileToAvoidCrash fails
3. testThatBackgroundConfigurationHeadersAreSentWithRequest fails

Brian
 This is a great start @KingOfBrian...thanks for putting all this together! The `NSURL` changes are really rough. We'll need to spend some time getting familiar with the failure cases of the new optionality to understand if force unwrapping is really the correct solution.
 I had a coworker ask about the nullability at the labs. I'm not sure it's a complete or correct answer, but I thought I'd include it for reference.

```
File reference URLs persist while the file moves. 
Trying to do append or other operations on a file reference URL will return nil if the file has been deleted. 
The only times the NSURL methods can return nil: dealing with reference URLs, or sometimes with an empty path.
```

Honestly the persist while-moving doesn't make sense to be, but it appears a file reference URL has some magic which forced these changes.  Given that this is the case, it appears http/https URL objects don't have this concern. But the 'sometimes with an empty path' doesn't instill too much confidence.
 @brentleyjones I just pushed up a branch named `swift2.3` that uses the `#if swift` macros.

I think its important we do this for the AF 3.x branch so people can easily transition to swift 2.3 if they choose, with the same version of Alamofire.

Obviously, that won't be possible with Swift 3.0 given the huge diff.
 > There are a few new test failures that need further investigation.
> 
> testThatUploadingMultipartFormDataOnBackgroundSessionWritesDataToFileToAvoidCrash fails
> testThatBackgroundConfigurationHeadersAreSentWithRequest fails

@KingOfBrian  Both of these are in relation to a radar I filed. 

```
26870455: NSURLSession with background configuration does not function on the iOS simulator inside of test targets
```
 Thanks for everyone's amazing work throughout this issue...very much appreciated! üçª

We now have our `swift2.3` branch is tip-top shape, building against Swift 2.2 and 2.3. We also have our travis-ci tests running against both Xcode 7 and Xcode 8 properly. At this point, I'm going to go ahead and close this issue out. We'll open new issues if necessary when the next round of betas come out.

Thanks again everyone!
  Turns out there are a few nullability changes that are causing build failures with Swift 2.3.

1 - A number of `NSURL` functions return nullable `NSURL` instead of nonnull. 
2 - `SecTrustResultType` moved to an enum from a collection of global Ints.
3 - `SecTrustSetPolicies(trust, policies)` no longer compiles: `Argument type '[SecPolicy?]' does not conform to expected type 'AnyObject'`
 Branch has been updated for beta 2 compatibility.
 You can pull the CocoaPod from the `swift2.3` branch. 
 `swift2.3` branch has been updated for beta 3, but there are no real changes.
 @Lukaz32 Solution for what?
 Can you be a bit more specific? What errors are you seeing? The `swift2.3` branch should build fine.
 @Lukaz32 That's a known CocoaPods issue. You need to update to CocoaPods 1.1.0.beta.1 and/or Xcode 8 beta 3.
 Thanks everyone for all the great work and investigation throughout this issue. We know have our `swift2.3` branch in tip-top shape, compiling against both Swift 2.2 and 2.3 successfully. We also have our Travis-CI yaml file building against Xcode 7 and Xcode 8 properly in the same branch. We've pulled all the latest changes from `master` in and everything is looking good.

At this point I'm going to go ahead and close this issue out since everything has been resolved. We'll open new issues with the next round of betas if necessary.

Again, thanks everyone so much! üçª
 Yes, no more Swift 2.3 branch. The Alamofire 3.5.0 release supports Swift 2.3 and is what you should be using from now on @tal-sh.

Cheers. üçª
  Hi @rafsouzap,

Not to worry, you have a few options here. First off, let's understand why this is happening.

The `+` character is being percent escaped according to RFC 3986 - Section 3.4 which is well documented in the [escape](https://github.com/Alamofire/Alamofire/blob/master/Source/ParameterEncoding.swift#L205-L218) docstrings. This is the common convention that most services will follow. However, as we're all fairly aware, not all services follow all the standards. üòï

If your server won't accept the `%2B` percent escaped variant, then you can override it by placing that parameter in the URL and not passing it as a parameter. Something like this:

``` swift
let URLString = "https://api.github.com/search/issues?q=repo:repo+is:status+type:pr"
```

This would be your easiest approach. Another option would be to use a `.Custom` parameter encoding, but I think that would be overkill here in this case.
  Luckily Xcode 8 might be able to use Alamofire as-is under Swift 2.3. We will be uploading a `swift3` branch as soon as possible. I have to get the new stuff downloaded first. Plus, I'm not sure how big of a job it will be, considering they've changed how a lot of the Foundation stuff (`NSURLSession` APIs) are imported into Swift. Hopefully the auto migrator will work well.
 Please everyone be patient here. We'll certainly get a `swift3` branch up as soon as possible. Unfortunately this year it's not going to be as easy as it has in the past. We need to make sure we update everything correctly to avoid causing everyone more harm than good. 

> If you find any helpful tips when trying to work through this yourself, please post them here! The more help the better.
 Please see #1316!

üçª 
  Hi @CiniCraft,

You cannot use the `responseData` serializer with the `download` API. You instead need to use the `response` API and check the `error` parameter. Then you need to read the data our of the filePath that you moved the file to in the `Destination` closure. Here's a [link](https://github.com/Alamofire/Alamofire#downloading-a-file-wprogress) to the README that demonstrates how to do this.

Cheers. üçª
  Hi @CelpanDmitrii,

Thank you for putting together this pull request...much appreciated! 

In this case, you'll want to use a `.Custom` parameter encoding since we don't want to change the default behavior. Since there's no documented spec on how to encode collection types with URL encoding, Alamofire uses one of the most common approaches. Anything outside this approach MUST be handled with a `.Custom` encoding. This is documented in the ParameterEncoding [docstrings](https://github.com/Alamofire/Alamofire/blob/master/Source/ParameterEncoding.swift#L41-L47).

Thanks again. üçª
  Hi @girishghoda,

These types of questions are best suited for Stack Overflow. We use our GitHub project for bug reports and feature requests. I'd also encourage you to provide more info when creating the Stack Overflow question, otherwise it is really difficult for people to help you out.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Thanks for reporting this @mrubin. We already have some tests put together around this use case, but not for MultipartFormData requests. I'll add one and see if I can get to the bottom of this.
 Okay @mrubin, I've added a test in 53e25d59 that verifies the `debugDescription` on a `Request` works correctly even for `MultipartFormData` requests. At this point I'm going to close this issue out. If you could provide a sample project (or better yet, a test) that can reproduce the behavior you are seeing, then I'll be happy to re-open and investigate further.

Cheers. üçª
  Hi @jsl303,

I'd encourage you to checkout our [README](https://github.com/Alamofire/Alamofire#usage). It contains all the details you need to chain methods together on a `Request`. In the future, I'd encourage you to ask this type of question on Stack Overflow. We use our GitHub project for bug reports and feature requests.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @remirobert,

In this case, you'll want to drop down a level in the APIs and first construct the multipartFormData. Once you have it encoded, you can then figure out the length of the data, and use that for your header. After gathering all the data, then you can build the request using the `upload` API without multipartFormData.

``` swift
func uploadMultipartFormData() {
    let multipartFormData = MultipartFormData()
    multipartFormData.appendBodyPart(data: imageData, name: "picture")

    var encodedData: NSData?

    do {
        encodedData = try multipartFormData.encode()
    } catch {
        print(error)
    }

    guard let data = encodedData else { return }

    Alamofire.upload(.POST, URLString, headers: ["ContentSize": data.length], data: data)
}
```

Just FYI...I didn't test any of that code. It's purely to demonstrate how you could solve this problem. Hopefully that helps. 

Cheers. üçª
  Hi @kovallux,

Alamofire is going to handle the request the same way that `NSURLSession` does because Alamofire is built ontop of `NSURLSession`. When you say `dataTaskWithRequest` works, what do you mean by that? Could you provide a code sample? That data task will stay open until you actually cancel the request.

Here's an example of how you could use the `stream` api to stream the data directly to a closure that you control to process the image data as it is downloaded from the server.

``` swift
func testMJPGDataFormat() {
    let expectation = expectationWithDescription("Video image should succeed")
    var gatheredEnoughImageData = false
    let imageData: NSMutableData = NSMutableData()

    let request = Alamofire.request(.GET, "http://wmccpinetop.axiscam.net/mjpg/video.mjpg")
    request.validate(statusCode: 200..<400)
    request.stream { data in
        guard !gatheredEnoughImageData else { return }

        imageData.appendData(data)

        print("New data: \(data.length), total image data: \(imageData.length)")

        if imageData.length > 300_000 {
            gatheredEnoughImageData = true
            request.cancel()
            expectation.fulfill()
        }
    }

    waitForExpectationsWithTimeout(timeout, handler: nil)

    print("Final Image Data Length: \(imageData.length)")
}
```

Hopefully this helps give you some ideas on how this could work. I'm going to close this issue out for now. If you end up providing some more info that leads us to believe there's an issue with Alamofire, we'll happily re-open this issue and continue to investigate further.

Cheers. üçª
  Hi @vsching,

You'll want to read up on how the [URL Loading System](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html#//apple_ref/doc/uid/10000165-BCICJDHA) works from Apple. You're question requires quite a bit of background knowledge on how the default URL session configuration works vs. a background URL session configuration. I'd encourage you to open a question on Stack Overflow rather than our GitHub project. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @marxcheckito,

These types of questions are best suited for Stack Overflow. We use our GitHub project or bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
 You can try the sample app I just created for a rdar @cescoferraro [here](https://github.com/Alamofire/Rdar-StringInterpolationMemoryLeak). That makes a request with Alamofire upon launch. You can see if you see the issue there...
 Thanks for reporting back @marxcheckito. üçª
  Hi @borek2,

I just created a test verifying that everything is working as expected.

``` swift
func testDeleteWith204ResponseStatusCode() {
    let expectation = expectationWithDescription("204 should succeed")

    Alamofire.request(.DELETE, "https://httpbin.org/status/204")
        .validate(statusCode: 200..<400)
        .responseJSON(options: .AllowFragments) { response in
            print(response.response)
            print(response)
            expectation.fulfill()
        }

    waitForExpectationsWithTimeout(timeout, handler: nil)

    print("Yay...204 works as expected with responseJSON serializer")
}
```

If this does not demonstrate your use case, then please provide a different example that replicates the behavior you're seeing. We have custom 204 handling in the [JSON serializer](https://github.com/Alamofire/Alamofire/blob/master/Source/ResponseSerialization.swift#L210) which should ensure you receive a `.Success` case when using the `responseJSON` serializer.

I'm going to close this issue out for now. If you provide more info that leads us to believe there may be an issue in Alamofire, we'll happily re-open and investigate further.

Cheers. üçª
  Not really sure what to tell you here. From what I can tell, you're linking very different things together. The dev forums post points to issues with using an `NSURLProtocol` where the AFN issues you linked are crashing due to the CFNetwork implementation of `NSURLCache` from what I can tell. I'm fairly certain the two issues are completely different.

If I were you, I'd follow the Eskimo's advice if you're using `NSURLProtocol`s in your code. I'd also encourage you to consider removing the `NSURLProtocol` implementation altogether. They are fairly clunky these days when integrated with `NSURLSession`. If you're not using `NSURLProtocol`, then you'll need to continue to investigate what's happening. There's nothing here that points to any issue in Alamofire itself, but rather the underlying Foundation and CFNetwork implementations.

I'm going to close this issue out for now. Feel free to continue to add more info to this issue. If we end up finding anything specific to Alamofire, we'll happily re-open and continue to investigate.

Cheers. üçª
 Thanks for the info @xozyain. I would be very surprised if this issue has anything to do with Alamofire. I'm much more inclined to say this is an issue with the core networking logic in Foundation and CoreFoundation. There's nothing obvious in any of the stack traces posted on the AFNetworking [#2866](https://github.com/AFNetworking/AFNetworking/issues/2866) that leads to anything specific to AFN. They're also quite different when you look through each one. For right now, there's just not enough info to go on. 

If anyone finds any repro case or has any idea on what scenario could lead to this type of crash, please post it here and we'll investigate further.

> Please try to avoid just pasting your low level networking stack traces here without any ideas on how they could be caused. It just creates noise. Instead, try to reproduce the issue. If you do post stack traces, please provide descriptions on exactly how you are using Alamofire to at least provide us some context.
  Please see #1289.
  Hi @mrubin,

Great questions. Let me try to clarify for you.

> If I have multiple .responseJSON() handlers installed on a given request, does each one deserialize the JSON from the underlying data?

Each one will deserialize the JSON from the `NSData`.

> Is there any mechanism by which I could pass the deserialized JSON AnyObject along to further responseJSON handlers?

There is nothing built directly into Alamofire at the moment to support this. You would need to build a custom response serializer. @jshier has built a good example of how this could look [here](https://gist.github.com/jshier/f08f08e05d994b5bdc7d). This is also the best way to handle any custom threading model you need to use. The underlying `response` method takes an optional `queue` parameter to allow you to continue running your custom response serializer on whatever `dispatch_queue_t` you want.

Instead of trying to think of how to pass objects between chained request methods, I would encourage you to think of how to split your response serializer into multiple steps like @jshier does in his example.
  Thanks @huy-le! üçª
  Fixes #1269. Updates the user agent‚Äôs OS version to use non-localized sources. It also includes the actual OS name in the string.
 Okay so I've spent some time making sure that we get this exactly right. Here's a few examples of what we get if we don't change anything.

**English**
- Process Info: `Version 9.3 (Build 13E230)`
- User Agent: `appname/bundle_id (1606122225; OS Version 9.3 (Build 13E230))`

**Japanese**
- Process Info: `„Éê„Éº„Ç∏„Éß„É≥ 9.3Ôºà„Éì„É´„Éâ 13E230Ôºâ`
- User Agent: `appname/bundle_id (1606122229; OS bajon 9.3(birudo 13E230))`

**Spanish**
- Process Info: `Versi√≥n 9.3 (Fase 13E230)`
- User Agent: `appname/bundle_id (1606122227; OS Version 9.3 (Fase 13E230))`

**Russian**
- Process Info: `–í–µ—Ä—Å–∏—è 9.3 (–í—ã–ø—É—Å–∫ 13E230)`
- User Agent: `appname/bundle_id (1606122226; OS Versia 9.3 (Vypusk 13E230))`

**Thai**
- Process Info: `‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡πà‡∏ô 9.3 (‡∏ö‡∏¥‡∏•‡∏î‡πå 13E230)`
- User Agent: `appname/bundle_id (1606122228; OS wexrchan 9.3 (bi ld 13E230))`

Therefore, we definitely need to make this change! 

Now what's interesting is that we no longer need to run the `CFStringTransform`. It's not possible to have a non-latin character come through as the app name or the bundle id. I spent some time trying this out, and Apple replaces any non-latin characters in the app name or bundle id with nothing or a `-`. Therefore, we no longer need to run the `CFStringTransform` on this string to be safe. I'll update the PR based on this info.
 Removed the `CFStringTransform` logic in 3591bfac and then rebased.
 Hi @bgerstle,

One of the apps I work on is localized in 20 languages. All I did was drop some log messages into our `AppDelegate` printing out the `operatingSystemVersionString` values and ran it in the different languages posted above as an experiment. 

You can easily add additional localizations to a sample project by adding a new localization in your project's `Info` settings. Here's a [link](http://www.appcoda.com/localization-tutorial-ios8/) to get you started if you haven't done this before. Then you can switch between locales when launching by switching Scheme's runtime language which can be done by `Edit Scheme` -> `Run` -> `Options` -> `Application Language`.

Cheers. üçª
  As soon as your code leaves `callService()`, there is no longer any reference to your `alamoFireManager` variable and it is deallocated, cancelling any pending requests you have. You're also redundantly setting `alamoFireManager` to the `sharedInstance` and then to a newly allocated instance later on.

What the [documentation about custom `Manager`s](https://github.com/Alamofire/Alamofire#manager) doesn't state is that you need to keep the manager around somehow. I like to use a static property in a `struct`:

``` swift
struct APIManager {
    static let sharedManager: Manager = {
        let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
        configuration.timeoutIntervalForRequest = 10        
        return Manager(configuration: configuration)
    }()
}
```
  Wrong project @mQ92. You'll want to file this in the AFI project instead. Also, if you could spend some time properly formatting your question, that would be much appreciated. Also consider whether or not this question should be opened on AFI, or Stack Overflow. We only use GitHub for bug reports and feature requests.

Cheers. üçª
  Hmmm...not really sure on this one @eriktelepovsky. The [tech note](https://developer.apple.com/library/ios/qa/qa1788/_index.html) leads me to believe that the Alamofire project settings are setup correctly.

How did you add the Alamofire framework as a dependency to your app target? Maybe that's more to blame than the project configuration itself.
 Thanks everyone for reporting back here. Due to all the issues everyone is having (myself included with a different weird set of warnings), I'm going to assume this is an issue on Apple's end. I'm going to go ahead and close this issue out for now since it seems we're all pretty sure this isn't an Alamofire specific issue. 

Feel free to keep commenting on the thread. I'll happily re-open and investigate further if anyone finds any specific Alamofire project issue.

Thanks again for all the help everyone! üçª
 I had this on an app as well but it was accepted without issue.
  Thanks for putting this together @lferro9000!
  We will start an official Swift 3 branch once Apple officially releases the Swift 3 tools at WWDC.
  This sounds like an issue with Carthage, not Alamofire. I believe both of those commands should pick up Alamofire 2.0.2. From past experience, I'd say make sure to use the latest version of Carthage. Additionally, you may want to consider moving to Alamofire 3.4. The AF 2.x release is now getting fairly out-of-date given how fast the Swift language is moving.

Cheers.
  Hi @satyamub,

Hopefully #441 can get you started in the right direction. We also have pretty detailed documentation on how to do this in our [README](https://github.com/Alamofire/Alamofire#manually). In the future, these types of questions are best suited for Stack Overflow. We use GitHub for bug reports and feature requests.

Best of luck!

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @chashmeetsingh,

I'd suggest you continue to debug on your end what the actual issue is. If you end up finding a specific issue in Alamofire itself, please provide more info and I'll be happy to re-open and help investigate further. If you need additional help debugging your issue, then I'd suggest you open a question on Stack Overflow.

Cheers. üçª
  Hi @gmarm,

I like the example you put together. It certainly makes the simple cases easier to read and more consistent. I'm a bit on the fence as to whether this belongs in Alamofire itself, but in general, I certainly like the approach!

With that said, I would probably think about changing a couple of things if we were to bring it in. First off, I would create a `URLRequestConfiguration` struct to contain all the values instead of using a `typealias`. That would actually allow you to use default parameters in a bunch of your `Router` cases which would make it even more condensed! üòâ

I'd also encourage you to think about the same concept for download and upload tasks as well. Could the `URLRequestConfiguration` struct handle all the various types of tasks with optional parameters? Possibly.

What's your take @jshier, @AnthonyMDev, @kcharwood?
 It doesn't seem like much of a win to me. 

While it might be easier to work with in some scenarios, it leads to a huge amount of redundancy in others. What if the vast majority of my endpoints use the same HTTP method? It would be duplicated in every case rather than being the result of a single switch default. So it seems like it makes some of the complex cases easier to express, it also makes the simple cases require more boilerplate. The suggestion of a `URLRequestConfiguration` struct would help with that since it can have default values, but really that would only help if those default values happened to coincide with what was actually required.

Readability is also a hugely subjective trait. I find the typical `enum` router to be perfectly readable, as it's rare that I need to know every property of an endpoint at a glance. Rather, I'm usually looking to make sure a particular property of an endpoint is set correctly. And once those values are set, I never look at it again, so it's not code that I read every day.

However, I do think this is a place where Alamofire could be enhanced. Rather than something immediate, though, my thought was to wait until WWDC and see everything Apple is going to do with Swift 3 (most is already revealed, but their presentations can provide good ideas too) and then start working on Alamofire 4 to take advantage of the new features as soon as possible at the core of the framework. Seeing how protocols have advanced could give us a better idea of what we could do in the framework to make it easier for users to create routers, among other things. 

So while I think some users will find this a useful enhancement on top of `URLRequestConvertible`, I don't think it's something to be included in the framework right now.
  Hi @lalitkumarchoudhary,

You should store the `upload` reference as a property that you can call cancel on.

``` swift
class NetworkManager {
    private var uploadRequest: Request?

    func startUpload() {
        Alamofire.upload(
            .POST,
            "https://httpbin.org/post",
            multipartFormData: { multipartFormData in
                multipartFormData.appendBodyPart(fileURL: unicornImageURL, name: "unicorn")
                multipartFormData.appendBodyPart(fileURL: rainbowImageURL, name: "rainbow")
            },
            encodingCompletion: { encodingResult in
                switch encodingResult {
                case .Success(let upload, _, _):
                    uploadRequest = upload

                    upload.responseJSON { response in
                        debugPrint(response)
                        uploadRequest = nil
                    }
                case .Failure(let encodingError):
                    print(encodingError)
                }
            }
        )
    }

    func cancelUpload() {
        uploadRequest?.cancel()
        uploadRequest = nil
    }
}
```

Hopefully that helps. In the future, I'd encourage you to ask this type of question on Stack Overflow. We use our GitHub project for bug reports and feature requests.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @gerdogdu,

You're going to have to be MUCH more specific for us to be able to help you out. You provide the `NSURL` in the `Destination` closure, then Alamofire uses the `NSFileManager` from there to move the file once it's finished downloading. If there is any possible mismatch between the filename you're specifying in the `Destination` closure and the final result, I don't see how that can be an issue in Alamofire.

I'm going to close this issue out for now. If you provide more info to go on, then I'll be happy to re-open and investigate further.

Cheers. üçª
  This is the intended behavior @romk1n. The `.URL` encoding will encode parameters in the URL for certain HTTP methods such as GET and DELETE, and in the HTTP body for other methods such as POST and PUT.

The `.URLEncodedInURL` case was created to support encoding query parameters in the URL for all HTTP method types. All of this functionality is called out in the [docs](https://github.com/Alamofire/Alamofire/blob/master/Source/ParameterEncoding.swift#L41-L50).

Cheers. üçª
  Hi @Dershowitz011,

In the future, I'd suggest you open this type of question on Stack Overflow. We use our GitHub project for bug reports and feature requests.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Thanks for your PR @jlalvarez18. Unfortunately we won't be pulling this in. Please refer to #1273 for more info.

Cheers. üçª
  Hi @startupthekid,

Thanks for the suggestion. This issue has already been discussed at great length in #1167, #1072 and #764 among others. You can easily resolve the issue by namespacing with `Alamofire` in your method declaration.

Cheers. üçª
 Thanks for providing that info @nubbel. üçª

@startupthekid thanks for providing all your info. I will answer each of your questions in turn, but please respect the opinion of the ASF. We always try to do what's best for the community, not just those using Result and Alamofire together.

> 1) The answer you gave is incorrect.

Please cut us some slack. I was referring to the implementation that @nubbel posted. There have been various workarounds posted in the tickets that I linked.

> 2) There have been multiple issues opened about this.

There definitely have, and all the debate in all of them has been healthy, yet ultimately led to the same conclusion. The pros of adding a dependency don't outweighs the cons in our opinion. You're free to disagree, but in the end, it's a decision that the ASF needs to make together. And we have...unanimously...over and over.

> 3) Anittypical's result is objectively better

There is certainly extra functionality built into the antitypical implementation that we've already started working on building into Alamofire. More on this coming later in future PRs.

> 4) Dependencies are a good thing, not bad

This is where we disagree. IMO, dependencies can be good if your team controls them. If they don't, they can be a nightmare. For example, we try to maintain branches for cutting edge Apple releases right after they are announced. By adding a dependency, we limit ourselves to only be able to support anything our dependency already supports. We are also held up by any issues with the project settings or dependency management files of the dependency. As I stated before, if you completely control the dependency, it can be a good thing. If you don't, it can be a huge problem and limitation for your community of users. You mention ReactiveCocoa. If you look at the list of maintainers between ReactiveCocoa and Result, you'll see there's certainly overlap which is exactly what I'm referring to.

Thanks again for putting your thoughts out there. I really appreciate the time you took to craft your argument. Please understand that we're taking your suggestions very seriously. We've had multiple discussions about this particular feature over the past year as a team, and continue to come to the same conclusion.

Cheers. üçª
  Hmmm...not sure on this one @duanyicanyuan. We'll have to investigate. Does anyone in the community have experience using the Reachability APIs on a VPN?
 Hi everyone,

My apologies for not addressing this issue sooner. Thank you for your patience. We've been swamped with Alamofire 4. 

I've managed to get to the bottom of the problem here. The core issue is that you're including the `https://` as part of the host when it should actually be `www.apple.com` as documented in our [README](https://github.com/Alamofire/Alamofire#network-reachability).

I've also spent some time putting together a sample app to test the behavior on a VPN. I've tested it on various VPNs all over the world and it behaves perfectly on iOS 10 as long as you set the `host` correctly. I haven't tested on iOS 9 since I don't have an iOS 9 device at the moment. If someone could test this on iOS 9, I'd appreciate it.
- [Connectivity.zip](https://github.com/Alamofire/Alamofire/files/491459/Connectivity.zip)

Hopefully this helps resolve future issues.

Cheers. üçª
  Great question @onmyway133! We'll have to do some investigation here and get back to you.
 cc @jshier, @AnthonyMDev, @kcharwood 
 Probably not a good idea, as Apple's docs explicitly call out not using the value for parsing. Manually creating the version string from `operatingSystemVersion` seems like a better solution. 
 I agree @jshier. I'll work on putting together a fix.
 I'm going to close this issue out since @jshier has put together a fix in #1292. Please redirect all future comments to #1292.

Cheers. üçª
  You could `debugPrint(response)` in any of the response serializers or optional bind the response data like so:

``` swift
responseJSON { response in
    if let 
        data = response.data, 
        utf8String = String(data: data, encoding: NSUTF8StringEncoding) 
    {
        print(utf8String)
    }
}
```

In the future, I'd encourage you to use Stack Overflow for these types of questions. We use our GitHub project for bug reports and feature requests.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Updated commit message and rebased in f4ccfeda while keeping attribution. Thanks for pushing this up! üçª
  Hi @Tom29,

Good question. Let me try to provide some details.

#### TimeoutIntervalForRequest

The max time interval to wait between server responses before cancelling the request. All session tasks use this value, but it is really designed for tasks running on a default or ephemeral session. Tasks running on a background session will automatically be retried.

> Unless you are using background sessions or download massive payloads, this is most likely the only property you need to worry about.

#### TimeoutIntervalForResource

The max time interval allowed for downloading a request payload. The default value is 7 days. While this can be used for default and ephemeral sessions to specify something like no request should take more than 5 minutes to complete, it's really intended for upload and download tasks running on a background session. Background URL sessions will automatically retry failed tasks behind the scenes until the `timeoutIntervalForResource` is reached. You won't receive a failure until this interval is reached for background sessions.

Hopefully that helps clarify things. 

Cheers. üçª
  If the default collection formatting does not meet your needs, you should instead use the `.Custom` parameter encoding type to create your own. We've opened up the APIs in `ParameterEncoding` to make it as easy as possible to roll your own solution.

Cheers. üçª
  Hi @laddiexu,

I'd suggest you open a question on Stack Overflow to get help you out with your deadlock situation. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @bclausdorff,

Thank you for taking the time to put this together. I'm going to go ahead and close this out since there's nothing we can do here. Please see my reasoning in #1122 for further details.

Cheers. üçª
  This PR opens up the static error methods that @0xced added in #1166.

> It also addresses #1240 and #1258.

While I completely get why @0xced was trying to lock down the ability to create errors with the Alamofire domain that don't use custom AF error codes, it's not really possible to guarantee this no matter how much we lock down the public APIs. Anyone could still create an `NSError` with the AF domain if they wanted, it would just be a bit more complicated to do so.

What types of errors a client should throw is their decision. IMO we should make it as easy for those clients to create errors as we can. It's their decision as to whether they should use the AF domain or their own. Either way, this isn't something that we can (or should) try to enforce. Because of this, I've opened up the new `error` APIs to allow clients to create errors by default under the AF domain, and easily customize with their own if they choose.
 cc @jshier, @AnthonyMDev, @kcharwood, @0xced for feedback
 I think it boils down to whether you think errors created inside custom response serializers should use the Alamofire errors or use their own. Seems like @0xced is definitely of the mindset that anything outside the Alamofire framework should always use a different domain and not use the AF error codes, even if the error code is applicable. I can definitely see and respect that POV.

> This is really the main question to answer. Once we make a decision here, then all the API decisions will be fairly easy to make.

I also get that it's not AF's job to provide convenience APIs for creating `NSError`s. I agree that it's not the job of AF to do this, but it is certainly convenient to allow this. Since we need to do this inside AF quite often, I don't see the harm in exposing this to the public as well. My main point is that we cannot stop people from doing this, so why not provide them the APIs to make error construction easier? 

I could see the argument that we should take out the default parameter value in the second API that takes an `Int` for the error code instead of an `Error.Code`. 

Thoughts???
 I agree that this functionality isn't something Alamofire needs to provide. It's okay to keep convenience functionality internal to the framework, as it reduces the responsibilities of the framework as well as the cost of changing internal functionality. Personally, I dislike using `NSError` at all, as it's not very Swifty, but it's the easiest way to produce error info unless we wanted to vend our own `ErrorType`. It's trivially easy for users to create their own error type and use it in custom serializers, as I demonstrate in [this gist](https://gist.github.com/jshier/f08f08e05d994b5bdc7d). 

So while developers could still creates errors in the Alamofire domain, we don't need to make it easy for them. Also, removing this public functionality will hopefully encourage developers to create their own error types, as I believe is best practice.
 Cool. Thanks for all the feedback here guys. I figured everyone would have a pretty strong opinion on this one. Let's keep the logic as is. I'll go ahead and decline this PR and most likely re-open the one where the README was updated with custom errors.

Cheers. üçª
  Your URL is invalid. It should probably be something like `"https://abc.com/api/v1/search"`. In the future, you should open a question on Stack Overflow instead of GitHub for this type of question. We use our GitHub project for bug reports and Feature Requests.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Thanks for putting this together @ajanauskas...much appreciated! üçª Instead of going this route, we've decided to open up the internal APIs in #1261. I've also updated the documentation to reflect the change. Thanks again.
 Reopening due to #1261 being closed.
 Another approach we could take is to recommend projects use their own error types. Whether that takes the form of something that can be turned into an `NSError` or not is another choice to make, but I think changing the example code to reflect this fact more clearly (i.e without referencing `Error.Code`) would be a good idea.
 I'm with ya @jshier. Would you be able to put something along those lines together?
 I'll try to put something together this afternoon. 
 @cnoon I've created #1273 with a first draft of recommended error usage. This moves away from using `NSError` at all, except from underlying code.
 I'm going to go ahead and close this out @ajanauskas...thanks again for putting this together. Please direct all further comments to #1273.

Cheers. üçª
  I think this is a great improvement @raphaeloliveira...thanks for putting this together! I rebased your change and pushed in master as dae3ed1b while keeping your attribution.

Cheers. üçª
  Sorry but Alamofire 3.3+ requires Xcode 7.3. If you're stuck on Xcode 7.2, use version 3.2.1.
  Let's hold off until we see what's announced at WWDC and what comes with the initial Xcode beta. We certainly want to support this, but it's quite a bit of work to maintain a separate branch for months on end. Once we see what's announced, we'll get a plan together for how we plan to support Swift 3 until the official release.

Cheers. üçª
  `NSCocoaErrorDomain` with code `3840` is a JSON parsing error from `NSJSONSerialization`. So while your backend returned a `200` response code, it did not return valid JSON. 
  Closing as duplicate of #1254.
  Hi @grizzly,

I'm not really sure what is going wrong with your logic, but there were no changes in this area that should have caused a regression. I just put together the following test to verify everything is working as expected:

``` swift
func testResponseJSON() {
    // Given
    let URLString = "https://httpbin.org/get"
    let expectation = expectationWithDescription("GET request should succeed: \(URLString)")
    var response: Response<AnyObject, NSError>?

    // When
    Alamofire.request(.GET, URLString, parameters: ["foo": "bar"])
        .responseJSON { closureResponse in
            response = closureResponse

            switch closureResponse.result {
            case .Success:
                print("SUCCESS")
            case .Failure:
                print("FAILURE")
            }

            expectation.fulfill()
        }

    waitForExpectationsWithTimeout(timeout, handler: nil)

    // Then
    debugPrint(response)
}
```

My guess is that there's something going wrong with your logic causing the success case to not be called. If you continue to have issues, I'd encourage you to open a question on Stack Overflow.

Cheers. üçª
  The singleton `Manager` instance uses the shared cookie store and automatically sends cookies with each response. However, in your case since you're switching domains, you most likely need to send the cookie through a `Cookie` header.

In the future, questions like these should be opened on Stack Overflow. We use our GitHub project for bug reports and feature requests.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Version 3.2.1 works with Xcode 7.2.1.

I suggest installing that pod using this syntax `pod 'Alamofire', '~> 3.2.1'`.
 Do what it says. Though I would suggest running `pod update Alamofire` to make sure you pull everything correctly.
  Hi @jamaalalleyne,

It is not valid to try to encode an `NSDate` using `NSJSONSerialization`. Instead of adding support like this into Alamofire, you should instead encode the date into a string, then pass that string into the parameters argument.

Cheers. üçª
 No, you need to convert the `NSDate` into a `String` using whatever format you need to send to your server, then pass that `String` into Alamofire to encode it into JSON.
  These [tests](https://github.com/Alamofire/Alamofire/blob/master/Tests/URLProtocolTests.swift) demonstrate how you could use an `NSURLProtocol` with Alamofire if you wanted @Yannmm.

Best of luck! üçª
  Nothing in this issue has anything to do with Alamofire. I'm going to close this out for now. If you end up posting more info that leads us to believe there could be an issue with Alamofire, we'll happily re-open and investigate.

Cheers. üçª
  Hi @smoi,

These types of questions are best suited for Stack Overflow. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  If you update to the latest version of CocoaPods, you'll no longer see this issue. The latest version of CocoaPods builds Alamofire with the deployment target specified in the podspec. 

Cheers. üçª
  There is definitely an opportunity here for some more robust handling @saiimons. Let's rope in some of the other team members for some ideas.
 cc @jshier, @AnthonyMDev, @kcharwood 
 What's really interesting is that you can almost do everything you need in the `destination` closure itself. You could clean up the file system directly in the `destination` closure, then if the `move` operation fails, the error is already captured and reported in the `response`.

However, you cannot set your own error if something in the `destination` closure fails. There are a few ways we could do this (none of which I love):
1. Open up the `error` property on the task delegate. I don't think this is necessary, but is always an option.
2. Rethink the `Destination` closure signature to possibly handle this case better. This would not be a backwards compatible change and would have to be done as part of AF 4.
3. Extend `Request` to have an alternative to the `Destination` closure that was more robust. We could introduce this in a backwards compatible way, but it would be clunky. You'd still have to set the `Destination` closure in the `download` API, then chain on the override or something like that.

Thoughts? Other options?
 Right now I lean towards modifying the `destination` closure to throw an error in AF4, but the problem I see with that approach is that it would need to be an `NSError` which we can't enforce with the compiler. 

We could allow an `ErrorType` to be thrown and catch it and convert it to some type of generic destination closure error, but that seems pretty clunky to me.

Thoughts @jshier and @kcharwood?
 We've redesigned the entire destination system in Alamofire 4 @saiimons to account for this use case and many more. For more details, check out the [migration guide](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%204.0%20Migration%20Guide.md#download-file-destinations).

Cheers. üçª
  Hi @grosch, sorry for not getting back to you sooner. I've just opened up #1261 to attempt to resolve this issue. If you could check that out, I'd appreciate it. I'm going to go ahead and close this issue out for now. Please direct all further comments to #1261.

Cheers. üçª
  Make sure you manager isn't being deallocated before the request has a chance to finish.
  You could be getting a cached response back.

These types of questions are best suited for Stack Overflow. We use out GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  You can set it on the [NSURLRequest](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLRequest_Class/#//apple_ref/occ/instp/NSURLRequest/timeoutInterval) or on the [NSURLSessionConfiguration](https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSURLSessionConfiguration_class/#//apple_ref/occ/instp/NSURLSessionConfiguration/timeoutIntervalForRequest) when it is created.

In the future, you should open this type of question on Stack Overflow instead of on our GitHub project. We use our GitHub project for bug reports and feature requests.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  They were deprecated in #1166 to stop encouraging users to create their own errors with the Alamofire domain. The code the @rafalkitta posted will work, but we'd encourage you to use your own custom domain to have a clear separation between the custom errors you're creating and the ones that Alamofire creates.

The solution to fix the warnings is to stop using the `errorWithCode(_:failureReason:)` API and instead create your own `NSError` objects directly.

Cheers. üçª
 @DavidGagne I'd actually recommend that developers create their own `ErrorType` not based on `NSError`, since `NSError`'s `domain` and `code` and rather useless. Instead, an enum, as described in that article, would work well, with each case capturing whatever state it needs to to be able to present errors to the user. But the article does outline an approach that makes this change less painful.
  We're not officially supporting SPM until it has been officially released. If you find a direct issue with our Package file, please submit a PR to help us fix things up!

Cheers. üçª
  Hi @scobbe,

#### Question 1

The reason that `download` works with `NSURL`s instead of `NSData` objects is that `download` is generally used for larger files. If you had to load the large file's data into memory every time to use it, you would certainly run your app out-of-memory. This is why the `download` APIs exist. To allow you to download large amounts of data and stream them to a file rather than have to collect them in memory. This is really the only difference between `request` and `download`. The `request` API does it all in-memory where the `download` API will stream the data to disk.

#### Question 2

This is a great question, and I don't actually have an answer. I've never tried to do it before. It's downloading to the `tmp` directory which is cleaned up by Apple automatically from time-to-time. Therefore, I've never worried about the abandoned files since they'd generally be very small. However, if this works for you, then I'd say roll with it!

Cheers. üçª
  Thanks!
  Hi @sosng,

Thanks for putting this issue together along with the sample project. I'm able to reproduce the leaks you're referring to. They have to do with leaks in string interpolation for building the `debugDescription` strings. I should have a fix in for this over the next few days.

Thanks again for reporting! üçª
 I've opened up PR #1262 to address this issue. Please direct all future comments to #1262.
  You can run up to 4 downloads in parallel on a single session on iOS @zsybupt. Additionally, you can create other sessions by creating your own `Manager` instance. More info in the [README](https://github.com/Alamofire/Alamofire#manager).
  Hi @totomo,

Thank you for submitting this PR...much appreciated! Unfortunately, we cannot accept this PR at this time b/c it's not backwards compatible. I have however added a task to our Trello backlog for Alamofire 4.0 to reinvestigate whether we would like to go this route.

Thanks again! üçª
  Hi @haoxins,

Thanks for submitting this pull request...much appreciated! I completely agree with you, that was not a good header to use as an example. Rather than remove the second header altogether as you have in this PR, I decided to change it to `Accept: application/json` instead in 20bc682d. Thanks again!

Cheers. üçª
  Your concerns here are perfectly valid @racer1988. The problem is that Apple isn't clear on whether apps supporting iOS 8 are going to be held to these same rules. If you check out #1086, you'll see that the reachability APIs don't work correctly on iOS 8 with IPv6. Therefore, I rolled back to the IPv4 APIs for iOS 8. I can certainly undo that change, but that will break reachability for anyone running on iOS 8.

An alternative approach would be to only make the `NetworkReachabilityManager` available to iOS 9 and above, but I'd rather not do that.

I'm going to leave this issue open for now. Maybe the community can help us decide on what the best solution is here.
 cc @kcharwood, @jshier, @kylef, @AnthonyMDev.
 That's exactly what we do now @racer1988 in the [NetworkReachabilityManager](https://github.com/Alamofire/Alamofire/blob/master/Source/NetworkReachabilityManager.swift#L123-L145).
 Unfortunately, it's just a running theory right now @AnthonyMDev...we don't have a definitive answer yet. I tend to agree with @dgatwood, but I'd much rather be certain.
 Pretty sure you posted on the wrong project @cezheng.
 Ah, I misunderstood your original post @cezheng. I didn't realize you were posting a code sample from the Reachability project.
 Thanks for posting all the documentation info @cezheng. That sample code was actually updated by Apple right after this ticket was opened. We need to re-evaluate our implementation based on the new sample code and description provided by Apple. Seems like there are a few opportunities for us to improve our logic.
 I've just opened #1308 which should bring Alamofire inline with Apple's recommendations when it comes to Reachability. I'm going to close this issue out. Please direct all future comments to #1308. Thanks for everyone's help getting to the bottom of this. We really appreciate everyone helping out here!

Cheers. üçª
 My guess is that this has something to do with the Facebook calls. Alamofire 3.4.1 should be fully IPv6 compliant. We have multiple apps in the AppStore right now built with that exact version.
 I reviewed this code with the Eskimo at WWDC and he said it was also good. He also explained that there are all kinds of nuances with connecting to IPV6 networks that could cause a failure.

He said testing the with fake IPV6 network on your mac is NOT a good test. You need to be on a true IPV6 network. I've seen a client where we got rejected for IPV6 and could not repro the problem, but on the WWDC true IPV6 network it was easily reproducible. We tracked it down to it being a problem with one of our API servers that didn't play nice with a direct IPV6 connection. It had nothing to do with our code. 
 How can I remove the reachability check?
I am getting my app rejected by Apple cause of this issue.
 @hellmund Yes you should definitely not be using reachability has a pre-flight check.

It may be best to open up a dev forum discussion and get Quinn involved. I chatted with him about this at WWDC, and there is just a lot of confusion here.
 @hellmund You should also confirm that your backend is accessible through a pure IPv6 network, as we see that a lot, as many backends still require an IPv6to4 bridge for connectivity. Otherwise, recommended best practice is to allow requests to fail and then check reachability to determine your next steps.
  This can certainly happen. The `NSURLSession` APIs are all asynchronous in nature. Calling `cancel` does not ensure the request is actually cancelled before it is able to complete.

Cheers. üçª
  Thanks for this @broccolii. I modified the commit message and pushed into `master` in d3211ea9 while maintaining your attribution.

Thanks again! üçª
  We're certainly very interested in this possibility! Once we get closer to seeing exactly how the linux Foundation is implemented, we'll start investigating how we'll need to modify Alamofire to support it.

Cheers. üçª
 Yes, all Linux discussion is now in #1935.  This is an Xcode issue. Clear your DerivedData and try again. If you have further issues, check StackOverflow for more recommendations. 
  This has been suggested several other times @LuoLee and is not something that we want to modify due to all the other potential issues this could introduce. Please see #755, #1073, #1076, #1098 for more info.
  That would be 3.2.1. Staying up to date is always recommended.
  I'm not entirely sure what issue you're running into, but the destination closure is definitely being called. You can easily reproduce the behavior by adding the following test to a test target that has Alamofire imported.

``` swift
func testDownloadExample() {
    let expectation = expectationWithDescription("destination closure should be called")

    Alamofire.download(.GET, "https://httpbin.org/stream/100") { temporaryURL, response in
        let fileManager = NSFileManager.defaultManager()
        let directoryURL = fileManager.URLsForDirectory(.DocumentDirectory, inDomains: .UserDomainMask)[0]
        let pathComponent = response.suggestedFilename

        expectation.fulfill()

        return directoryURL.URLByAppendingPathComponent(pathComponent!)
    }

    waitForExpectationsWithTimeout(20.0, handler: nil)

    print("Made it!")
}
```

I just verified the `destination` closure is called as expected.
  Thanks @gemmakbarlow! I rebased and tweaked the commit message and pushed in `master` in 743c9fb8 while keeping your attribution. Thanks again!

Cheers. üçª
  Hi @raginggoat,

These types of questions are best suited for Stack Overflow instead of GitHub. We use our GitHub project for bug reports and feature requests. If you tag `alamofire` on your question, I'm sure the community will be able to help you out.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  I'm sorry, but you should seek support through the framework provider. Unless you can narrow some issue down to being an Alamofire bug, there's not much we can do here. If you can't get support there, StackOverflow may be a good place to ask a question about it.

As for the design overall, I don't know what your requirements are, one request at a time is generally a bad idea unless you have some very specific API requirements to that end. 

If you want, post your overall requirements and I can tell you what I'd recommend as far as methods and frameworks, but otherwise there's nothing for Alamofire to do here.
  Removing the header is not a good solution to this problem. If you want `curl` to decompress the response, just pass the `--compressed` flag into the `curl` command and it will decode the `gzip` for you. Unfortunately there is no general solution here, as the mere presence of the `Accept-Encoding` header says nothing about what the server's response will actually be.  
  Hi @janglesdev,

Apologies for the confusion. Thanks for the description. I agree with the majority of your assessment (with the exception of Alamofire being useless without `validate`). Therefore, I moved the `Validation` section above the `Response Serialization` section in the README in b54f0185. I also added a `.validate()` call to all code samples in the `Response Serialization` section. Hopefully that will help someone avoid the same frustrations in the future.

Cheers. üçª
  You need to use Xcode 7.3 to compile the latest version. Cheers. üçª
  Hi @CodeEagle,

These types of questions are best suited for Stack Overflow. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Given the amount of variability between `bash` and `tcsh` quote escaping (amazing how painful this is), there's no one solution that solves this problem correctly. I just spent 2 hours trying to work out a solution to no avail.

While your suggestions do stop throwing errors in `tcsh`, the JSON is not able to be parsed correctly server-side. Coupled with the fact that `bash` is the default shell on OS X, we're going to leave the implementation as is. If you MUST use a `tcsh` shell when debugging, you'll need to modify the cURL output directly before using in your shell.

With that said, I realized there was actually an issue with `bash` output as well where the JSON contained single or double quotes. I've pushed up f443cd8a to `master` to resolve the issue.

Sorry this can't work for both shells. We're certainly open to supporting both, but I don't see how it's possible. If you're willing to spend a bunch of time here trying to figure out a better alternative, by all means.

Cheers. üçª
 Apologies @grosch, I realize now that in my reply I didn't provide nearly enough detail. In your simple example, it certainly works. The problem is when keys or values in the JSON contain single or double quotes. I cannot find any possible combination of escaping that works between both shells because of the differences in the way they escape strings.

If you would really like to see this feature support both shells, then I'd encourage you to find a way to make this [test](https://github.com/Alamofire/Alamofire/blob/master/Tests/RequestTests.swift#L565-L596) work in BOTH bash and tcsh. We could also consider having two different methods for building the `cURL` command. Then possibly a way to set your shell preference on a Request.Shell enumeration or something along those lines.
  Replied @marcmatta. You'll need to provide more info.

Cheers. üçª
 You'll have to troubleshoot with the server team. Unfortunately, there's nothing we can really do to help here @marcmatta.
  Hi @khanshakeeb,

You will need to use Alamofire 2.0.2 if you're still building against Swift 1.2. I'd encourage you to update to the latest version of Swift ASAP because 1) Swift 2.2 is awesome and 2) we have made many great improvements to Alamofire over the past 6-7 months that you will be missing out on.

Cheers. üçª
  If you wish to validate that you got a response code in some range, you must call `validate()`, as noted in our documentation. 
 Without calling `validate()`, you'll see any lower level network errors in there (e.g. internet connection offline, connection lost, connection timeout), or errors when trying to deserialize into whatever `response` method you're using (e.g. JSON deserialization errors). You can add your own validation rules through `validate()`, or if that's not flexible enough, through a custom response serializer. 
  Can you share your request code? It will help us narrow down where in the process you'd have to customize your encoding to get the behavior you want. 
  This has nothing to do with Alamofire, this is how the underlying `NSURLSession` works. If you wish to remove the `tmp` file, you'll need to delete all files within that directory. Although I'm not sure why you'd want to do this given that iOS will purge these directories automatically.

Cheers. üçª
  Hi @dtorreci4ejg,

You most likely need to override the [taskDidReceiveChallenge](https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSURLSessionTaskDelegate_protocol/#//apple_ref/occ/intfm/NSURLSessionTaskDelegate/URLSession:task:didReceiveChallenge:completionHandler:) closure instead. Kerberos challenges are part of the [NSURLAuthenticationMethodNegotiate](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLProtectionSpace_Class/#//apple_ref/c/data/NSURLAuthenticationMethodNegotiate) protection space auth type. The `taskDidReceiveChallenge` should be called as soon as a challenge is issued by the server. It will be called again if the challenge is not successfully authenticated. Alamofire by default will reject the protection space after a failed attempt. However, if you're overriding the default logic, the behavior is up to you.

Cheers. üçª
  Hi @buzzllc,

I can't be certain with the info you provided, but most likely you need to do the following instead:

``` swift
let headers = ["Authorization": "Bearer \(someAuthToken)"]
```

If that doesn't fix your issue, then I'd encourage you to ask a question on Stack Overflow since that's a better place for this type of question. We use our GitHub project primarily for bug reports and feature requests.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  I'm fighting with a leak problem!
Any ideas / fixes ?

iOS 9.0 xcode 7.3

![screen shot 2016-04-21 at 14 59 34](https://cloud.githubusercontent.com/assets/4609982/14709584/b4b79182-07d1-11e6-9126-9c1ee31d4b88.png)

``` swift
class ViewController: UIViewController, getDataDelegate {

   override func viewDidLoad() {
      super.viewDidLoad()
      Services.delegateData = self
      Services.getData()
   } 
   func finishedDownloading(data: Data) {
      //do something...
   } 
}
```

``` swift
import CoreLocation
protocol GetDataDelegate : class {
    func finishedDownloading(data:Data)
}
class Services {
   weak var delegateData:GetDataDelegate?
   func getData() {

        let urlString = API_URL + "url/"
        let headers = self.setHeaders()

        Alamofire.request(.GET, urlString, headers: headers)
            .validate()
            .responseJSON { response in
                switch response.result {
                case .Success:
                    if let value = response.result.value!["data"] as? NSArray {
                       self.delegateData?.finishedDownloading(self.setData(value))
                    }
                case .Failure(let error):
                    print(error)
                }
        }
    }
}
```
 Hi @enricopiovesan,

Could you update your example so it would compile? How are you initializing the `Services` object in the `ViewController`? Is the `getData` method actually a static method?
 Hi @cnoon,

this is the base code, do you need other?

``` swift

class ViewController: UIViewController, getDataDelegate {

   override func viewDidLoad() {
      super.viewDidLoad()
      Services.delegateData = self
      Services.getData()
   } 
   func finishedDownloading(data:Data) {
      //do something...
   } 
}
```

``` swift
import Alamofire
protocol GetDataDelegate : class {
    func finishedDownloading(data:Data)
}
class Services {
   weak var delegateData:GetDataDelegate?
   func getData() {

        let urlString = API_URL + "url/"
        let headers = self.setHeaders()

        Alamofire.request(.GET, urlString, headers: headers)
            .validate()
            .responseJSON { response in
                switch response.result {
                case .Success:
                    if let value = response.result.value!["data"] as? NSDictionary {
                       self.delegateData?.finishedDownloading(self.setData(value))
                    }
                case .Failure(let error):
                    print(error)
                }
        }
    }
   func setData(dictionary: NSDictionary) -> Data {
       let name =  dictionary["name"] as! String
       let color =  dictionary["Color"] as! String
       return Data(name: name, color: color)
   }
}
```

``` swift
class Data() {
    var name: String
    var color: String
    init(name: String, color: String) {
       self.name = name
       self.color = color
    }
}
```
 I modified with a static function, but the problem still persist.

``` swift

class ViewController: UIViewController, getDataDelegate {

   override func viewDidLoad() {
      super.viewDidLoad()
      Services.delegateData = self
      Services.getData()
   } 
   func finishedDownloading(data:Data) {
      //do something...
   } 
}
```

``` swift
import Alamofire
protocol GetDataDelegate : class {
    func finishedDownloading(data:Data)
}
class Services {
   static weak var delegateData:GetDataDelegate?
   static func getData() {

        let urlString = API_URL + "url/"
        let headers = self.setHeaders()

        Alamofire.request(.GET, urlString, headers: headers)
            .validate()
            .responseJSON { response in
                switch response.result {
                case .Success:
                    if let value = response.result.value!["data"] as? NSDictionary {
                       self.delegateData?.finishedDownloading(self.setData(value))
                    }
                case .Failure(let error):
                    print(error)
                }
        }
    }
   func setData(dictionary: NSDictionary) -> Data {
       let name =  dictionary["name"] as! String
       let color =  dictionary["Color"] as! String
       return Data(name: name, color: color)
   }
}
```

``` swift
class Data() {
    var name: String
    var color: String
    init(name: String, color: String) {
       self.name = name
       self.color = color
    }
}
```
 That leak is in `NSJSONSerialization` @josete89, not Alamofire. Given that, I'm going to go ahead and close this issue out. If someone can provide a sample project that demonstrates the leak is actually in Alamofire, then I'd be happy to investigate further.

Cheers. üçª
  Hi @crash-wu,

Your error message is encouraging you to use `options: .AllowFragments` instead of `options: .MutableLeaves`. That will allow whatever valid JSON object that isn't currently a collection to be parsed successfully.

In the future, I'd encourage you to instead open a question on Stack Overflow. We use our GitHub project with bug reports and feature requests.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  I would not recommend subclassing `SessionDelegate` just to add logging. I've been able to get satisfactory logging in my projects by putting it in my custom `response` method.
  Thanks @Piyush08! üçª
  You certainly can use the `request` method to do this, but I would encourage you to use `upload` instead. The reason is that the `request` method progress tracking only reports downloading progress of the response data. It will not report upload progress. 

The `upload` APIs will report the upload progress to the server and do not report download progress of the server's response data. Because of this, I'm sure you'd prefer the `upload` APIs in this situation.

Cheers. üçª
  Hi @kakilan,

I'm a bit surprised that doesn't work. What I would try instead is to set the `NSURLCredentialPersistence` in the `authenticate` method to `.None`. That's the only other thing I can think to do here while keeping your same approach.

``` swift
.authenticate(user: userName , password: password, persistence: .None)
```

If that still doesn't work, you have a few other options.
1. Create a new `Manager` each time you logout
2. Use an `ephemeral` session to avoid the problem altogether
3. Use a base64 encoded basic `Authorization` header that wouldn't get cached

One of these approaches should resolve your issue.

Cheers. üçª
  Hi @keisyrzk,

Are the headers missing when using curl @keisyrzk? That's the only thing we can really suggest to try to help out here. Alamofire does not handle building the [allHeaderFields](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSHTTPURLResponse_Class/#//apple_ref/occ/instp/NSHTTPURLResponse/allHeaderFields) dictionary in the response. That's all handled internally by Apple's APIs.

The only thing we can really do here is suggest you try to reproduce the issue with curl and try to get the results to your server team. Additionally, you could consider why your needing to extract that header in the first place. Aren't you sending up the accessToken already? Why do you need to check the header in the response?

Best of luck! üçª
 Hi @Quintasan, your comments are a bit confusing. Could you please put names to the libraries you are mentioning? Are you saying that you were previously NOT using Alamofire, and things were always working? And now you are using Alamofire and they don't work? 

If that's true, that's still not much to go on...
 @Quintasan I think Christian's point was that merely providing a link to a library doesn't really help us understand your requirements. I think there was also some confusion about whether you were having issues with the request or response.

As far as I understand it, however, you seem to be having an issue where the `access-token` field doesn't appear in the `allHeaders` property of the `NSURLResponse` returned when getting a response. Is that correct? Unfortunately Alamofire has no control over the parsing of the response headers, at that is handled by the lower level networking libraries provided by Apple. You can see if we're getting the appropriate headers through `NSURLSession` by setting a breakpoint in Alamofire where the `NSURLSession` delegate methods are implemented. 
  Alamofire 3.3 requires Xcode 7.3. Update and it will build fine.
  Update to Alamofire 3.3, as that release fixed the Swift 2.2 warnings you're seeing. We do not yet support Swift 3. 
  These were never intended to be used publicly. They are only implemented to allow internal customization of Alamofire handling. You already have the ability to override everything at the session level through the `Manager.SessionDelegate`. If you can come up with some examples of what you can't currently do because of this design, then we'll certainly consider the proposal. But at this time we have no intention of opening up those APIs.

Cheers. üçª
  Thanks for putting this together @0xced!
  Thanks for putting this together @0xced! I made a few small changes to the API and pushed into `master` in c2a282cc while still keeping your attribution. Thanks again!

Cheers. üçª
  Thank you for putting this together @chrisrichards! Your turnaround time was amazing...apologies that ours was not.

I made a few tweaks to your submission and pushed it into `master` in d2b85f43 while still giving you attribution. Thanks again!

Cheers. üçª
  Hi @edopelawi,

Thanks for your PR, but unfortunately we won't be pulling it in. The test passes without this change. By adding the declaration you have added in this PR, you defeat the purpose of the test in the first place. Thanks anyways!

Cheers. üçª
 I just pushed up https://github.com/Alamofire/Alamofire/commit/8d16d492f670a2cb86ff2fe5e707204ac5c92964 to address the Travis CI failures prior to iOS 9.0. If they pass, I'll go ahead and merge them into `master`.
  Thanks for reporting @jerarts!

It looks like we have a bit of a bad assumption in the `CustomDebugStringConvertible` logic. Right now we're extracting all the `NSURLRequest` headers, then the `NSURLSessionConfiguration` headers. Instead, we should collect them in the opposite order and have any duplicates in the `NSURLRequest` replace the previous value since that's the actual behavior when the request is sent.
 Would anyone in the community like to help out to fix this issue? Should be easy to collect the headers then append them to the `components`. We'll also want to write some unit tests to verify this behavior.
 Issue has been resolved in d2b85f43 thanks to @chrisrichards. I'm going to go ahead and close this out.
  Thanks @Mycose! üçª
  You just need to add the `Alamofire` prefix to the `Method` type. That will resolve the issue. The following compiles:

``` swift
public class SubManager: Manager {
    public override func request(
        method: Alamofire.Method,
        _ URLString: URLStringConvertible,
          parameters: [String: AnyObject]? = nil,
          encoding: ParameterEncoding = .URL,
          headers: [String: String]? = nil)
        -> Request
    {
        return request(NSURLRequest())
    }
}
```

In the future, I'd encourage you to ask these types of questions on Stack Overflow. We use our GitHub project for bug reports and feature requests.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  The `Unity4XC` plugin will not cause the build to fail. In order to build Alamofire 3.3.1, you need to use Xcode 7.3, xcodebuild 7.3, and Carthage 0.16. After you have everything updated, I'd suggest wiping DerivedData and the Xcode cache. Then reboot Xcode. After you have all this completed, Alamofire should build properly.
  Hi @shenjiayu!

This seems like a logic issue, not an issue with Alamofire. I'd recommend opening a question on Stack Overflow for this problem. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @marckaraujo,

If you ever have issues getting the syntax right, I'd first check out the unit tests. We have over 300 tests that demonstrate how to use pretty much every single API available in Alamofire. For example, in our [UploadTests](https://github.com/Alamofire/Alamofire/blob/master/Tests/UploadTests.swift), there are 17 tests with 766 lines of code demonstrating how to use the `upload` APIs that you're having trouble with.

In the future, I'd recommend opening a question on Stack Overflow instead of here on GitHub. We use our GitHub project for bug reports and feature requests. It helps us focus on the core features and allows the community to help out with support questions.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hmmmm....we'll need to look into this @Mycose. Is there any chance you could put together a failing test to demonstrate the issue? That would make it much easier for us to troubleshoot.
 Thanks for all the info you provided here. 

We have a fairly large set of `CacheTests` to help verify this type of behavior. If you open up the test suite and run [this](https://github.com/Alamofire/Alamofire/blob/master/Tests/CacheTests.swift#L255-L284) test on iOS 8.x or iOS 9.x and set a breakpoint in the [URLSession(_:dataTask:willCacheResponse:completionHandler:)](https://github.com/Alamofire/Alamofire/blob/master/Source/Manager.swift#L606) method, you'll see that the breakpoint is being called each time.

I then added your `delegate.dataTaskWillCacheResponse` override to the test's `manager` and re-ran. Both the delegate method and the override closure are being called as expected.

The only difference may be that I'm running Alamofire 3.3.1 and you are running 3.2.1. We have made some changes in the 3.3.1 release that fixed some bugs around some of the delegate methods being called, but this particular session delegate method should not have been affected. Additionally, the bugs there should have only affected the 3.3.0 release, not the 3.2.1 release. Either way, I'd encourage you to dig into the tests that I've linked in this comment to see the behavior working for yourself. Then I would update to 3.3.1 and see if that fixes your issue.

If 3.3.1 does not fix your issue, then you'll need to figure out why your logic is different than the logic in the tests. I don't see anything obvious from the code you posted, but that doesn't mean that you don't have something else set that is affecting the behavior that isn't in your example.

At this point, I don't see an issue in Alamofire. All the behavior you've reported is not working seems to be working correctly from what I can tell. Because of this, I'm going to close this issue out for now. If you do still continue to have issues, then please provide a failing test or sample project for us and attach it to this issue. Then we'll gladly re-open the issue and continue to help you investigate further.

Best of luck! üçª
 Cool...thanks for the update!
  First make sure you're running the latest version of Carthage and Xcode 7.3. Also make sure you're `xcodebuild` is updated to 7.3. Then you need to clean the project, wipe derived data and possibly the Xcode cache. If you're still seeing issues, reboot. After all this, you will see that Alamofire 3.3.0 and 3.3.1 do compile successfully with Xcode 7.3. 

> It will not compile with Xcode 7.2.1 and below.

Cheers. üçª
  Thanks @dersvenhesse!
  We made the decision to drop iOS 7 a LONG time ago (as in over a year ago). It does not support frameworks which causes all sorts of issues when maintaining a library of this size. We also cannot test any of the iOS 7 logic without having to maintain two different test suites.

Our general approach will be to maintain Alamofire against the currently released version of iOS and the previous one. At some point after iOS 10 has been released, we'll be looking to remove support for iOS 8.

Cheers. üçª
  This PR removes the `final` keyword from the `SessionManager` declaration. These changes allow advanced users to subclass the `SessionDelegate`, but should only be used when absolutely necessary. A simple example of such a use case would be to use a proxy pattern to emit notifications or log messages when certain APIs are called. The override closures do not allow you to do this and still use the default implementation.

I also added a section to the README detailing the different ways to use the override closures vs. subclassing. Hopefully this provides enough info to allow users to make the best decision for their use case.
 cc @taquitos, @AnthonyMDev, @jshier, @kcharwood, @kylef 
 :+1: On this, though an actual example of improper `subdelegates` usage might be a good idea, if it can be such an issue.
 Okay awesome guys, thanks for all the feedback! I'll go ahead and merge this now and put together another PR with the example of improper usage.
  Try deleting your DerivedData folder and Xcode cache and rebooting Xcode. If this doesn't work, then possibly reboot your machine. Beyond that, make sure you're using the latest version of CocoaPods.

If you continue to have issues, I'd recommend you open a question on Stack Overflow. We use GitHub for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Great question @sealz! 

What you'll need to do for now is to create a custom response serializer that essentially does two passes. The first pass would have to validate the HMAC, if it fails, call the completion with a `.Failure` response. If it succeeds, go ahead and decode the `NSData` however you wish. If the decoding succeeds, call the completion with a `.Success` response, and `.Failure` if it fails.

I've also added an item to our backlog for Alamofire 4 to consider adding the `NSData` value to the `Validation` closure to allow you to do this type of validation with a custom validate method.

Cheers. üçª
  It is part of the [release notes](https://github.com/Alamofire/Alamofire/releases/tag/3.3.0) for 3.3.0. But you're right, the general README and other documentation should be audited to reflect this requirement.
 Apologies for not getting this updated properly with the `3.3.0` release @PattyHarris. This has been corrected in 3b1edd80.

Thanks! üçª
  Hi @timothyarmes,

Given your needs here, I'd recommend using your own NSURLSession and NSURLSessionDelegate, then using Alamofire to help create the `MultipartFormData` objects to upload. This will end up being much easier in the long run because Alamofire currently does not support these complicated background session use cases very well. This is something we'd like to attempt to address in Alamofire 4.

Best of luck! üçª
  We will not be adding a dependency to Alamofire @itchingpixels. This issue has already been discussed in detail in #764 and #1072.

Cheers. üçª
 @itchingpixels All Swift frameworks are automatically namespaced. You can disambiguate by using `Alamofire.Result` or `Result.Result` already. Now, if you aren't using your dependencies as frameworks, there's not much we can do to help you, as frameworks are Swift best practice for independent dependencies. 
 Thanks @jshier, well said.

@itchingpixels, we won't make the `Result` type more difficult to work with in any way for users that aren't using a second `Result` type that conflicts. You MUST understand that point of view. You're suggestions are attempting to make your use case easier without considering the effect it would have on the community. For those not familiar with the `antitypical/Result` library, the Alamofire design would seem very odd.

We're always open to suggestions to make Alamofire better, but it must be better for the community. Not for individuals. Adding a third party dependency to Alamofire that we don't control is certainly not in the best interest of the community. Renaming `Result` to something not result is not in the best interest of the community. Wrapping an additional extension around `Result` is not in the best interest of the community.

Are you planning on telling every third party library out there that they can't create their own `Result` type? It just doesn't seem realistic, nor considerate. This is a common pattern that the Swift community needs to use in various places, especially when async operations are involved. Most likely, these libraries will be creating their own Result types, unless they decide to couple to one of the Result libraries out there. But if they choose one that isn't the one you're using, you still have the same problem.

Please take @jshier's advice and use namespacing when you're working with both types. You could also consider not trying to use the two together.
  I really like this approach @0xced! I made a few alterations to your PR and pushed 8d9f79a8 and 2b91b8fc while maintaining your attribution.

Thanks again! üçª
  There was a bug that was fixed in the `3.3.1` that was causing the `taskWillPerformHTTPRedirectionWithCompletion` closure to not be called @onmyway133. If you update to the latest release, everything should work as expected.

I'm going to close this issue out for now. If this doesn't actually solve your problem, please provide some additional info and I'll be happy to re-open.

Cheers. üçª
  This looks good @0xced...thanks for putting it together! üçª
  Hi @vimask,

This issue is most likely going to be in your custom implementation of the `sessionDidReceiveChallenge` closure, not with any Alamofire specific logic. The error leads me to believe there's a mismatch between your client identity and the cert data your providing back to the server in your credential. You'll need to continue to debug further. I'd also recommend handling the specific type of challenge rather than considering them to all be the same. This [thread](http://stackoverflow.com/questions/26721546/using-nsurlsession-with-nsurlcredentialstorage-and-nsurlauthenticationmethodclie) may provide some useful info.

If you do end up finding any Alamofire specific issue, please provide more info and I'll be happy to re-open and investigate further.

Cheers. üçª
  Not entirely sure what you're asking. Regardless, questions like these are best suited for Stack Overflow. We use GitHub for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Declining this in favor of #1172. Please redirect all future comments to #1172.
  Hi @lucatorella,

Thanks for reporting the issue. After investigation, I realized that test was bad in all sorts of ways. I have rebuilt the test to properly demonstrate how to use an `NSURLProtocol` with an `NSURLSession` in 8e3990b3. The test will fail if you do not use the `NSURLProtocol`, and passes when you do.

Thanks again! üçª
  Hi @grosch,

These types of questions are best suited for Stack Overflow. We use GitHub for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
 Okay everyone, apologies for closing this out prematurely. Moved through the issue too quickly. Reopening.

As you have all clearly pointed out, this is certainly worth investigating further to see if there's a better way we can bubble this back to the user. AFN has been working on a solution for when cert or public key pinning evaluation fails, but I'm still a bit weary of such a change. IMO, if we're going to give custom errors for cert or public key pinning failures, we should certainly do the same for other authorization challenge types.

For anyone that feels strongly, I'd encourage them to first ramp up on the efforts from AFN, just so that you have all the proper context. Then, let's discuss the possible options here in this issue.
- [AFN Background](https://github.com/AFNetworking/AFNetworking/issues/3165)
- [AFN Server Trust Error PR](https://github.com/AFNetworking/AFNetworking/pull/3425)
 @0xced has resolved this issue in #1164. I'm going to close this issue out for now. Please direct all future comments to #1164.

Cheers. üçª
  Everything is working as expected. The original request made by Alamofire (NSURLSession) does not include the credential info. That's why you're seeing the 401 behavior with the cURL command. What happens instead is that the original request is made, then the server issues an auth challenge back to the client. When this happens, Alamofire will provide the credential back to the server, and then the request is successfully made. After the connection has been authenticated, the server trusts subsequent requests. If not, it will issue another challenge and Alamofire will provide it.

Cheers. üçª
  Looks like everything is still working on our end. If you check out this [test](https://github.com/Alamofire/Alamofire/blob/master/Tests/DownloadTests.swift#L162-L255) and print out the expected bytes like so:

``` swift
download.progress { bytesRead, totalBytesRead, totalBytesExpectedToRead in
    let bytes = (bytes: bytesRead, totalBytes: totalBytesRead, totalBytesExpected: totalBytesExpectedToRead)
    byteValues.append(bytes)

    print(totalBytesExpectedToRead)

    let progress = (
        completedUnitCount: download.progress.completedUnitCount,
        totalUnitCount: download.progress.totalUnitCount
    )
    progressValues.append(progress)
}
```

Everything is working properly. You'll need to continue to debug what's going on on your end with your server. Just FYI, Alamofire doesn't do anything special with this value. It's either provided by Apple's APIs or it isn't. Alamofire just passes it on.

If you do end up finding a bug in Alamofire, please provide more info and I'll be happy to re-open this issue and investigate further.

Cheers. üçª
  You'll need to debug the `error` being returned. Since you are not receiving a URL response, that means you're not actually able to hit the server and your request is not being formed properly. You should try using the following to debug further:

``` swift
let request = Alamofire.request(.GET, URL, ...).responseJSON { response in
    print(response)
}

debugPrint(request)
```

In the future, you should open a question on Stack Overflow. If you do end up finding an actual issue in Alamofire, please comment back with more info and I'll be happy to investigate.

Cheers. üçª
  Please update to the latest version of Carthage, Alamofire and Xcode and everything should work as expected. Questions like this are best suited for Stack Overflow. We use our GitHub project for bug reports and feature requests.

Cheers. üçª
 I just used the latest Xcode, latest Carthage and latest Alamofire release and built successfully with no issues.

``` bash
cnoon:~/Desktop/CarthageTester$ carthage update
*** Fetching Alamofire
*** Checking out Alamofire at "3.3.0"
*** xcodebuild output can be found in /var/folders/s7/qpm0b2pn3d56rjlpl7g3_4fh0000gn/T/carthage-xcodebuild.QdM6Sa.log
*** Building scheme "Alamofire watchOS" in Alamofire.xcworkspace
*** Building scheme "Alamofire OSX" in Alamofire.xcworkspace
*** Building scheme "Alamofire iOS" in Alamofire.xcworkspace
*** Building scheme "Alamofire tvOS" in Alamofire.xcworkspace
cnoon:~/Desktop/CarthageTester$ 
```
  Right now we don't have any custom handling of the stream session task delegate APIs in Alamofire. At the moment you'll need to implement event handling yourself. If you end up coming up with some nice patterns that you think may be useful to the rest of the community, we'd love it if you'd take the time to submit a PR back. Even if it is just a set of ideas.

Cheers. üçª
  Also in https://github.com/Alamofire/Alamofire/issues/1136. Thanks @aemengo!
  Hi @veena-experion,

This type of issue is best suited for Stack Overflow. We use our GitHub project for bug reports and feature requests.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Thanks @esokullu!
  You likely pulled down Alamofire 3.3, which is only compatible with Xcode 7.3. Either lock your Cartfile to `~> 3.2.0` or update to Xcode 7.3.
 Thanks @jshier!
  Hi @balazsgerlei,

Thank you for your detailed feature request. I understand that async operations can make things more complicated, but we also don't want to hold up queues (or threads) while the async operation takes place. Since Apple removed the ability to execute synchronous API calls in the `NSURLSession` APIs, you can see that they are forcibly moving in the direction of making network calls asynchronous. We aren't interested in moving backwards to replicate the `NSURLConnection` APIs.

With that said, we have made some improvements to make the concept of thread-safety and synchronous calls easier. In 4c7bf391, we added the `queue` parameter to all the response serializers making it really easy to make a request, and specify the queue to call when it is complete. This is essentially a synchronous API if you handle the response on the same queue that you made the request on. The nice thing is that it allows the queue to process other things with the request is being made.

While I understand synchronous APIs may make things easier, they could also make things much worse. We will not be adding synchronous APIs to Alamofire, but we will continue to try to make the async APIs easier and easier to use.

Cheers. üçª
  Not sure exactly what your issue is, but most likely you just need to clean and wipe derived data and possibly the Xcode cache. If you are still experiencing issues, then I'd suggest you open an issue on Stack Overflow. We use the GitHub project for bug reports and feature requests.

Cheers. üçª
  Hi @taquitos, my apologies for not getting back to you sooner.

Your use case here is completely valid, and is definitely something that you can't do with the current implementation. Essentially you'd like to be able to proxy a `SessionDelegate` API or two somewhere to perform some additional operations, yet still be able to use the default logic. The problem is that you can't actually do this with the basic closures or even the closures with completion.

Now I'm not entirely sure I follow what you're attempting to do in your PR, but I do have a simple solution here. I have been debating this for quite some time, and I think it might just be time to do this. If we remove the `final` signature on the `SessionDelegate`, users are free to subclass the `SessionDelegate` and proxy the delegate APIs as much as necessary for the use case. Here's what that "could" look like:

``` swift
public class SessionDelegate: 
    NSObject, 
    NSURLSessionDelegate, 
    NSURLSessionTaskDelegate, 
    NSURLSessionDataDelegate, 
    NSURLSessionDownloadDelegate 
{
    // All the current implementation...
}

public class CustomSessionDelegate: Manager.SessionDelegate {
    public override func URLSession(
        session: NSURLSession, 
        dataTask: NSURLSessionDataTask, 
        didReceiveData data: NSData) 
    {
        print("I received some data!")
        super.URLSession(session, dataTask: dataTask, didReceiveData: data)
    }
}
```

This would give a power user complete control over the process if they really needed. What I also like about this is that you can still use the more convenient override closures without having to subclass which is generally what you'd do in most cases. IMO, this seems like the best approach. Let's see if we can gather some feedback from some of the rest of the Alamofire team.

cc @jshier, @kcharwood, @kylef, @AnthonyMDev 
 The `misuse` I was referring to @AnthonyMDev was around the `subdelegates` and making sure they're still created and deallocated appropriately. I really hesitate to make them public. I just opened #1172 which should address all the concerns in this issue.

I'm going to close this issue out for now. Please direct all future comments to #1172.
  Thanks @ludoded! üçª
  Thanks for reporting @rmarczynski. It looks like @kcharwood has a fix in for this issue already in #1141. I'm going to close this issue out for now. Let's direct all further comments to #1141.

Thanks again! üçª
  If you post a link to the Stack Overflow question, I can help point you in the right direction there.

Cheers. üçª
  No, since that feature is only available in Swift 2.2. 
  You need to update to Xcode 7.3 to build Alamofire 3.3.0.
  @jschmid - this should not be a MAJOR version upgrade according to semver. @phroggyy - you are absolutely right, this info should have been included in the release notes. That has been corrected in fad7390a. Hopefully that helps clarify the reasoning for going with 3.3.0 instead of 4.0.0.

Cheers. üçª
  Hi @LuoLee,

Xcode 7.3 is now required for the latest Alamofire 3.3.0 release. The README has been updated accordingly to reflect that.

Cheers. üçª
  Alamofire 3.2.1 does not support Swift 2.2. Please use the `swift_2.2` branch until we release 3.3.0.

Cheers. üçª
  http://stackoverflow.com/a/34193782/1342462
  Hi @gitunhub,

These types of questions are best suited for Stack Overflow. We use our GitHub project for bug reports and feature requests.

Best of luck. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Alamofire 3.2.1 is not Xcode 7.3 compatible. For now, you'll need to use the `swift_2.2` branch. We're aiming to have out a release today that resolves this issue.
 Quit Xcode, clear derived data, wipe your Xcode cache, then relaunch. That should fix everything up. Sometimes you also need to reboot your machine as well.
  Alamofire does not yet build on Xcode 7.3. This is something we are aiming to resolve today. For now, you can use the `swift_2.2` branch.

Cheers. üçª
 Alamofire 3.4.0 builds against Xcode 7.3.
  Thanks @nickskull, we're hoping to get these fixes incorporated into Alamofire today and a release cut.
 Thanks for putting this together @nickskull...much appreciated! I made some slight variations to your changes and pushed them up in 38606315 while still giving you attribution. I made some other modifications in 22c81a3b to the Travis yaml file. I still don't have all the Travis problems worked out, but everything is looking good locally across all platforms.

Thanks again! üçª

> These changes will be released shortly...
  Thanks @florentmorin!
 @borut-t You may be able to use the value of the "Content-Length" header fields of the response to get the data length before decompression.
  Hi @orkenstein,

You'll need to convert the `Bool` value to a `String` in the case of `.URL` parameter encoding. This works correctly for JSON, but not for `.URL` encoding. Unfortunately you need to convert the value yourself. There are a bunch more details in #1056 explaining why.

Cheers. üçª
 It adds a bunch of complexity to add that check and wouldn't be backwards compatible. There are already thousands of people using this logic as is. Therefore, if you need a bool to be a string as a query parameter, you'll need to handle the check at the client layer before passing it into Alamofire.

All the best.
  Most likely the memory persists due to the in-memory `NSURLCache` behavior or various other types of caching that UIKit could be doing. If you do end up finding a specific Alamofire leak, please comment with more info and I'd be happy to re-open and investigate.

Cheers. üçª
 I have the same problem
  Thanks @oursevendev. 

@skerkewitz, you can definitely use both in the same project. If you're in the process of moving to Swift, it would certainly be ideal to replace AFN with Alamofire in one big change, but you can certainly do this in smaller steps leveraging both. You'll just need to use the AFN session for certain APIs, and the Alamofire session for others.

Best of luck!
  This is a great question @matthiaslau. Personally I haven't tried to use cert pinning yet with a background session. If anyone else has any info here, please share!

Are you running into this problem when the app is running in the background, or when it's running in the foreground? There are some obvious problems right now with the Alamofire design working with background sessions. Such as trying to reconnect your session and all the response closures being dropped.

Could you give me a more detailed explanation of your use case?
 Hey @matthiaslau, have you made any progress here? 

Have you been able to successfully use cert pinning with your server without using background sessions? That is the first thing you should probably try to get working. To do this, you'll want to switch to a `defaultURLSession` and try to get everything working. I'm fairly confident that you're probably running into an ATS issue or maybe you have your server trust set up incorrectly. Starting here will guarantee you have ATS and cert pinning configured correctly. üëçüèº

Once you get everything working on a default URL session, then I'd suggest moving to a `backgroundURLSession` and troubleshoot. I'm fairly confident that this will just work for you after you have everything working for a default session. I think your issue is with ATS or your server trust and not actually with background session.

I'm going to close this issue out for now. If you end up finding that there is actually an issue in Alamofire for this case, please provide some more info and I'll happily re-open and help you investigate further.

Best of luck! üçª
 Hi @mattcantstop,

Sounds like this could use some additional investigation on our end. From what I'm hearing though, it sounds like background sessions are not respecting auth challenges in the same way as a default session. That's potentially problematic since Alamofire doesn't control any of that logic. It just reacts to it.

Would you be willing to put together a test case that can produce this behavior? It would much easier for us to help you debug if you could. Then we can try to dig in around the passing case and failing case and see if we can figure out what's going on.

Thanks!
 @matthiaslau are you still planning on putting together a sample app for this issue? If not, I'm going to go ahead and close this out.
 Hi @matthiaslau and @bclausdorff,

Sorry for not digging into this sooner. I finally found some time to really dig into this issue. I've scoured all the Apple docs and I can't find any definitive answer on the subject as to whether the background session configuration automatically evaluates a server trust challenge for you. Because of this, I decided to build a sample app to test it out.

What I found in the sample app is that with background sessions, server trust challenges are automatically evaluated. You'll never get called when performing the TLS handshake. iOS is just going to evaluate the cert and establish the connection if the cert chain is valid and fail if it's not. I tested both cases with `https://httpbin.org/get` and `https://expired.badssl.com/`. The challenge delegate API just isn't called in either case running on a device or in the simulator. I am assuming this is for performance reasons. If you end up needing to do something like cert pinning or allowing a connection if the cert is invalid (self-signed certs), then you just can't use a background session.

What was interesting is that the delegate is called on a basic-auth challenge. Now from what I can gather from the [Handling Authentication](https://developer.apple.com/library/prerelease/content/documentation/Cocoa/Conceptual/URLLoadingSystem/Articles/UsingNSURLSession.html#//apple_ref/doc/uid/TP40013509-SW16) docs is that `basic-auth` challenges are non-session-level challenges. I can only assume that these types of challenges are not automatically evaluated on background sessions, where session-level challenges are.

Long story short, there's nothing we can do here. Server trust challenges are automatically handled by iOS with background session configurations. As such, I'm going to go ahead and close this issue out since there's nothing we can actually do about it in Alamofire.

Thanks everyone for being patient here until we had time to get to the bottom of the behavior.

Cheers. üçª
  Hi @krezzoid,

Thanks for putting this PR together. Unfortunately we don't think this is a good set of changes to include in Alamofire itself. This deviates greatly from the delegate queue serial processing pattern leveraged heavily by the method chaining pattern. If you need this type of functionality, then I'd suggest you create your own extensions on the `Request` object to do this.

Cheers. üçª
 Ah ic. In this case I think you'll want to create a custom response serializer that takes in the queue you want to run the serialization on and does it that way. For example, just execute something like `responseData` on the `TaskDelegate` queue, then process the data into your Realm model object on your provided queue. That should allow you to do what it is you're trying to accomplish.
  Hi @Windsooon,

You probably need to use the parameter encoding `.URLEncodedInURL` instead of `.URL`. Your POST is putting the payload in the HTTPBody and not the query parameters. Additionally, you can use the following in the future to help you debug this type of problem.

``` swift
let request = Alamofire.request(.POST, URLString, parameters:parameters, encoding: .URL)
debugPrint(request)
```

This will print out the cURL command making it MUCH easier to see what's actually going on.

In the future, I'd suggest opening a question on Stack Overflow instead. We use the GitHub project for bug reports and feature requests.

Best of luck!

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @BculeMB,

This type of question is best suited for Stack Overflow. We use the GitHub project for bug reports and feature requests.

Best of luck!

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Thanks for putting this together @lucatorella! You are absolutely right, these should have always been exposed. For some reason, I've always used the `response` method and passed my custom queue along with the response serializer I needed. I'm not really sure why I didn't think to add them to the top-level APIs. Thankfully you did!

Cheers. üçª
  Can you explain this a bit more? I'm not sure what problem you're referring to, but I'm seeing some intermittent encoding errors that could occur from a deadlock.
 Yea, I see what you're saying. I don't see any reason to schedule the stream in the runloop either. Not sure it will actually cause problems, but there's no reason for it. There's a good chance the runloop doesn't even notice that it was added. 

I removed the runloop scheduling and all the unit tests still passed.
 @wizzardchao could you post a link to the docs you're referring to?
 Thanks for the due diligence here @wizzardchao. You are absolutely right that it is currently implemented incorrectly. Thanks for pointing us towards the Apple docs. Those were really helpful. Since it looks like @KingOfBrian has already done all the work for us to fix this in #1121, I'm going to close this issue out. Please redirect all further comments to #1121.

Thanks! üçª
  Yep, definitely a typo. Great catch @topchul! And thanks for putting together the PR to fix it. üçª
  Thanks @vsouza. We currently aren't closely supporting SPM since it's still in beta. If anyone out there with more experience with SPM would be willing to help get Alamofire ready, it would be greatly appreciated!

Cheers. üçª
  The line is enforced for safety. It's to make sure you aren't trying to provide a `SessionDelegate` that isn't actually the delegate of the `NSURLSession` you're passing in. Otherwise, Alamofire won't really do much of anything for you.

Thanks for the answer @wizzardchao. You're spot on. In this particular use case @binkdotli, it's probably not worth trying to force your `SecurityLib` session and delegate into Alamofire. However, you could certainly still use parts of Alamofire to help build `NSURLRequest` objects such as `ParameterEncoding` and `MultipartFormData`.

Best of luck! üçª
  Marking as a duplicate of #1086.
 I'm going to close this issue out since it's a duplicate of #1086 @IvanZhouGitHub. Please redirect all comments to that issue instead.

Thanks! üçª
  Hi @wgywgy,

You'll want to use the [request.cancel()](https://github.com/Alamofire/Alamofire/blob/master/Source/Request.swift#L177-L190) API to generate the `resumeData` which you will then extract as shown in this [example](https://github.com/Alamofire/Alamofire#accessing-resume-data-for-failed-downloads) in the README. Then you'll need to use the `resumeData` and the [resume](https://github.com/Alamofire/Alamofire/blob/master/Source/Alamofire.swift#L366-L368) API to resume the request the next time you hit `startDownload`.

In the future, these types of questions are best suited for Stack Overflow @wgywgy. We use our GitHub project for feature requests and bug reports.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
 The `resumeData` is not guaranteed to actually resume @jdleung. You want to try it, and if the OS cannot resume the download, it will restart it instead.
 @tiagoaap If the user kills your app there is no way to take any action, much less save resume data. At best you could manually write the download data to disk periodically during the download, but that's a lot of work for a user who doesn't care if your app completes the download.   Hmmmm...nothing obvious jumps out. I'd recommend trying to print out the `cURL` command to see if that leads you in the right direction.

``` swift
let request = Alamofire.request(.POST.rainForest.URL, ...)
debugPrint(request) // print out cURL command
```

In the future, questions like this are best suited for Stack Overflow. We use our GitHub project for bug reports and feature requests.

Best of luck!

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  https://github.com/Alamofire/Alamofire#uploading-multipartformdata
  It's failing to convert the `NSData` into a UTF-8 String on [these lines](https://github.com/Alamofire/Alamofire/blob/master/Source/ResponseSerialization.swift#L222-L228). You should instead try the `responseData` serializer and print it out to try and figure out why you cannot decode it. You could also try to write it to a file to debug it further. Long story short is that you're failing to decode the data as UTF-8.

In the future, questions like these should be asked on Stack Overflow. We use GitHub for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hmmmm...doesn't seem possible @shlowdy. The type on `userAgent` is `String`, not `String?`. Also, I haven't seen the optional arguments in the `User-Agent` header before.
 Ah...thanks for clarifying @shlowdy. I definitely see what you mean. The logic works fine as is, since it's using either the `AnyObject` coming from the dictionary or defaulting to a `String` which is then stored as a `String`. Then, when substituting into the new mutable string, each `AnyObject`'s `description is used to build the final String. All this logic works correctly, but can be a bit misleading.

In order to simplify, I just pushed 30525873 to make things a bit easier to digest. Hopefully that helps clarify things.

Cheers. üçª
  This PR extends the `SessionDelegate` override closures to include variants that contain the `completionHandler` parameter. In certain cases, such as reported in #1095, Alamofire was not providing enough flexibility to allow a user to override the implementation and perform some async operation before calling the `completionHandler`. These changes allow users to fully override the entire set of functionality inside any of the `SessionDelegate` APIs.

> For more details about a specific use case, please refer to #1095.

An alternative approach to this PR would be to remove the `final` modifier from the `SessionDelegate` declaration. This would allow users to subclass the `SessionDelegate` which would remove the need for these variant closures. I feel though that this is not a good idea since the `SessionDelegate` does not publicly expose the subdelegates and opening this up could lead to misuse when subclassing.

cc @jshier, @kcharwood, @kylef, @AnthonyMDev 
 @AnthonyMDev and @JoachimK, thanks for the healthy debate here. I think it always helps improve functionality when looking at approaches from many different angles. You have both certainly helped do that.

With that said, I tend to agree with @AnthonyMDev on most all the discussion here @JoachimK. You've made many interesting statements here, and I'll do my best to reply to the ones that I think could use some additional clarification.

---

> How about giving the session- and task-delegate each a delegate of same kind that users of Alamofire could implement. If a method is implemented, call it, if not use Alamofire's default implementation.

This is exactly what the override closures allow you to do. The difference is that this approach let's you override only one of the methods, not all. The approach you are suggesting is relying on @objc protocols which we're obviously going to try to avoid in Alamofire. Especially given all the changes currently taking place in Swift 3.0.

> Why not allow an NSURLSessionDelegate instead of a SessionDelegate to be passed to the Manager initializer. What is special about Alamofire's SessionDelegate that would take much work to reproduce in an own delegate and everyone needs?

Look at the implementation of the `SessionDelegate`. It does MUCH more than simply act as an `NSURLSessionDelegate`. It stores a bunch of state as well as a special `TaskDelegate` for each request. There's much more going on in there.

> Also, if I see it correctly, I could implement my own delegate and make it instantiate an instance of SessionDelegate itself to forward methods to that if I don't want to provide a custom implementation. This way, the implementation of the SessionDelegate wouldn't even be lost, but could be reused.

You can absolutely do this, but again I'd question why. Most of the time, you just want to use the override closures. There are other things that happen in those methods (such as cleanup) that you'll have to do yourself if you completely override the method.

> Another thing about the challenge/authentication specifically: If we are going to provide our "own" API (be that in blocks or as delegate) instead of using Apple's declared delegate protocols, we could try to seize the opportunity and improve upon it.

Generally I agree with this philosophy. However, I don't think it is wise in this particular case. The reason is that the delegate APIs are so complicated and come with so much documentation, that I hate to deviate too far from them. We don't want to have to re-create all the documentation that already exists for all the `NSURLSessionDelegate` protocols and all the more specific ones. Instead, Alamofire strives to provide a layer of convenience so the general user never even has to know about the delegate calls. Yet for power users, they have the ability to customize all the `NSURLSessionDelegate` calls if absolutely necessary.

---

Overall, thank you for all your feedback here @JoachimK. You've certainly helped us improve Alamofire significantly by exposing all the completion handlers directly in the override closures.

Cheers. üçª
  This has been raised in many different issues @maximveksler (#755, #1073, #1076). As stated in all those other issues, this behavior is by design. You need to make sure your URL is properly escaped before passing it into Alamofire. We don't want to automatically modify the URL you pass in because that would lead to confusion amongst the community.

Cheers. üçª
  Hello 
    I'd like to add the ability to retry requests transparently on token authentication failures, and wanted to check to see if it was functionality that might be accepted before going off and writing it. This is not a request to add oauth support, but functionality that could be used to easily add oauth support. The public API I see (names are probably not great) would look like:

``` swift
extension Request {

    public typealias RetryCallback = NSURLRequest? -> Void
    public typealias RetryCheck = (NSURLRequest?, NSHTTPURLResponse?, RetryCallback) -> Void

    func check(check: RetryCheck) -> Self {
    }
}
```

This would be consumed by the client like:

``` swift
request.check() {HTTPRequest, HTTPResponse, callback in
     if let HTTPResponse = HTTPResponse where HTTPResponse.statusCode == 401 {
         self.refreshAuthenticationToken() { token in
            let newRequest = HTTPRequest.mutableCopy()
            newRequest?.allHTTPHeaderFields["Authorization"] = "Bearer \(token)"
            callback(newRequest)
         }
     }
     callback(nil)
}
// Normal response handler
request.responseObject(completion)
```

_Background:_
Transparent token refresh is almost always desired when interacting with OAuth. This forces every request to re-implement painful token refresh that has to recapture all of the inputs and perform the logic above. It would be awesome to easily add this refresh behavior to the existing chain.

_Implementation Approach_
I believe this would be relatively easy to implement. First the operation queue would be suspended. If nil is passed to the callback, the operation queue would be resumed, and the remaining response chain would run. If a request was passed to the callback, all of the state of the request object would be cleared out and the new request would over-write the old one. The request would then be ran again with a new token, and hopefully succeed.

I was hoping to be able to create a request copy and copy over all of the response chain, but the response chain is built by grabbing the request via operation block closures, so I don't think that approach can work.

Any thoughts?

Thanks!

Brian
 So, I was looking through the implementation approach above, and it looks pretty bad. A request really doesn't want to retry, it's one request.

However, it may be easy to make the responder chain copyable. Right now it appears that the NSOperationQueue that represents the responder chain grabs the request state via closures. If that relation ship was stored as arrays of `ResponderChain` objects that conformed to a protocol like `func respondWithRequest(request: Request)`, a retry could move the responder chain to a new request and function as though it was one request from the API consumer perspective.

It appears that the use of the NSOperationQueue as a responder chain happens in 4 places, so this should be a relatively small change. Good chance that there's another shortfall I'm un-aware of though!
 Hi @KingOfBrian,

Thanks for putting together your thoughts on this. It's certainly an issue that a vast majority of iOS developers face these days. After looking through your suggestions, I think your looking at a greatly simplified example of what's generally happening. When a token has expired, generally that means the user hasn't used your app in a while. When they open it up, you probably have 10 different requests you need to make to sync back up. Unfortunately ALL those requests are going to hit a 401, not just one of them, and they are all going to hit it at slightly different times.

If you don't consider all the requests that are racing towards a 401, you're going to be in a world of hurt. Most OAuth servers aren't going to allow you to have 10 different access tokens all at the same time. Generally, you can create a few, but creating new ones tends to invalidate old ones. Therefore, creating new ones for each request can end up invalidating other ones that are already in flight. You can get into some really bad scenarios here.

Rather than thinking about the problem as refreshing a token for a single request, you need to think about refreshing a token for a group of requests. Because you don't know which scenario you are going to hit and you definitely need to handle both. Therefore, I'd recommend reading my much more in-depth answer that @glennrfisher pointed out (thanks @glennrfisher).

With that said, I would LOVE to be able to move my OAuth2 wrapper library out into the OSS community. Unfortunately, it requires you to move away from method chaining and into higher level, more powerful, but less flexible APIs. I haven't created an OAuth2 library yet under the Alamofire org b/c it's going to be very tricky to get right and will take a significant amount of time to build. However, that doesn't mean I'm not going to. It's certainly on my roadmap to build, but I haven't had enough time to start putting it together yet. For now, I'd recommend reading through the Stack Overflow answer and trying to roll your own using the approach and sample code documented in that thread.

Best of luck! üçª
 Thanks for the response @cnoon. I totally agree with this not being a complete retry / oath implementation, but it's easy to add to this once the response chain can be copied. I'd like to be able to gather more input from the Alamofire team as to what the desired retry implementation would look like and what the requirements are. I have seen you mention that it's in the feature backlog.

I work with a lot of projects doing consulting that all do their own abstraction on top for authentication which is frustrating, since A) Different project, different API. B) The Alamofire API is so much more expressive. I think getting some retry support into Alamofire will help a lot more than you might picture!

Here's my OAuth implementation, which has some internal abstractions, but addresses your concerns. Let me re-write it without my internal abstractions to give a better picture of what it would look like.

```
    func reauthenticateRequest(request: Alamofire.Request) -> Alamofire.Request {
        guard let HTTPRequest = request.request else { fatalError("Invalid Request") }
        // swiftlint:disable force_cast
        let authorizedHTTPRequest = HTTPRequest.mutableCopy() as! NSMutableURLRequest
        // swiftlint:enable force_cast

        if var headers = authorizedHTTPRequest.allHTTPHeaderFields, let bearerToken = self.bearerToken {
            // Add the bearer token and retry
            headers[Constants.Authorizaton] = Constants.Bearer(bearerToken)
            authorizedHTTPRequest.allHTTPHeaderFields = headers
            let authorizedRequest = Alamofire.request(authorizedHTTPRequest)
            authorizedRequest.copyResponseChainFromRequest(request)
            return authorizedRequest
        }
        else {
            // There is not enough information to authenticate, return the original request, which will 401.
            return request
        }
    }
    // APIEndpoint encapsulates headers, parameters, encoding, fetch type to help cluster like API's. It's purpose is similar to URLRequestConverable, without having to define a hostname (which always has to be static storage in the URLRequestConverablePattern)
    func request(endpoint: APIEndpoint, authenticated: Bool = true) -> Alamofire.Request {
        let headers: Dictionary<String, String>?
        let request: Alamofire.Request
        let needsAuthentication: Bool
        var requestIsReady: Bool = true

        if let bearerToken = bearerToken where authenticated == true {
            headers = [Constants.Authorizaton : Constants.Bearer(bearerToken)]
            needsAuthentication = false
        }
        else {
            headers = nil
            needsAuthentication = authenticated
        }
        request = manager.request(configuration.baseURLString, endpoint: endpoint, headers: headers)

        if needsAuthentication {
            if let authorizationRequest = authenticationRequest {
                // A re-authorization is in progress, retry when it's done
                authorizationRequest.delegate.queue.addOperationWithBlock() {
                    self.reauthenticateRequest(request).resume()
                }
                requestIsReady = false
            }
            else if canReauthenticate {
                // There is enough information to re-authenticate
                authenticateClient() {
                    self.reauthenticateRequest(request).resume()
                }
                requestIsReady = false
            }
        }
        else if authenticated {
            // If an authenticated request has a 401, reauthenticate and retry.
            request.checkForRetry() { request, completion in
                if request.response?.statusCode == 401 && self.canReauthenticate {
                    self.authenticateClient() {
                        let newRequest = self.reauthenticateRequest(request)
                        completion(.Retry(request: newRequest))
                        newRequest.resume()
                    }
                }
                else {
                    completion(.Continue)
                }
            }
        }
        if requestIsReady {
            request.resume()
        }
        return request
    }
```
 @p2 Take a look at our new [`RequestRetrier` feature](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%204.0%20Migration%20Guide.md#request-retrier) in Alamofire 4. 
  My guess is that your request you're making with Alamofire is not the same as the POSTMAN call. If they were the same, you should get a response in the completion block with the 401 status code. You should try to use the `debugPrint` functionality on the `Request` type to help you troubleshoot.

In the future, I'd suggest going to Stack Overflow with this type of question. We use the GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @JoachimK,

Thanks for the very detailed writeup! I completely understand your frustration here and agree with you overall. Because of this, I've just created PR #1099. If you could check it out and provide feedback, that would be really helpful. That PR solves not only the challenge API problem, but many others as well. I'd love to get your feedback.

I'm going to close this issue out. Please direct all further comments to #1099.

Thanks! üçª
  Yes, you will need to delete the tmp file yourself if you're concerned about leaving it in the tmp directory. Alamofire does not clean up that file after the upload completes. I'm going to put a task into our backlog to consider whether it should or not.

Cheers. üçª
  These changes have already been applied to the `swift_2.2` branch @glennrfisher. We'll merge these changes into `master` once the official Xcode 7.3 has been released.

Cheers. üçª
  Looks like you've already [roped in the Eskimo](https://forums.developer.apple.com/thread/39454) for help here. I doubt this is directly related to an issue with Alamofire, so I'd encourage you to continue debugging with Quinn and report any issues directly related to Alamofire back to this ticket.

I'm going to close this out for now since there's no action item for Alamofire. If you post any additional info here that leads us to believe there is an issue in Alamofire itself, I'll be happy to re-open and investigate further.

Best of luck! üçª
 Cool...thanks for getting back to us @fancy42!
  We publish VERY detailed release notes for each release.
- https://github.com/Alamofire/Alamofire/blob/master/CHANGELOG.md#321
- https://github.com/Alamofire/Alamofire/releases

If you continue to have issues, I'd suggest you open a question on Stack Overflow. We use GitHub for bug reports and feature requests.

Best of luck. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  If you're running the latest version of Alamofire, passing in an empty dictionary `[:]` will set the `Content-Type` to `application/json`. A parameter value of `nil` will earlier out of parameter encoding altogether.

Cheers. üçª
  Ha! Good catch @theovoss...thanks for the change!
  Interesting. This will take some investigation on our end. I don't have access to an iOS 8.x device right now, so I'll only be able to test with the simulator which isn't as helpful.
 Okay @kchromik, I've switched over to using IPv4 on iOS 8.x in ef756b00. Would you be able to test against the latest changes on `master` to see if they resolve your problems?
 Also, can we test that on an iOS8 device built on the iOS9 SDK? I don't think you want the compile-time check, but a runtime check (Which is why I thought it would be better to stick  with ipv4 for all).
 The `#available` check does provide a runtime check as well @KingOfBrian. The availability checks provide both compile time checks for API usage as well as runtime logic branching behavior.
 Ah sweet, I did not know that! Takes time to un-learn my obj-c ways.
 Okay, I finally managed to track down an iOS 8.2 device. Looks like the IPv4 changes for iOS 8 were the correct solution. Reachability monitoring is now working as expected on both iOS 8 and 9. üëçüèº
  Thanks for the offer @korzonek, but I think we'll pass on adding a badge to the top of our README that gives our project a `B` rating.
  Hi @Sahilberi, these types of questions are best suited for Stack Overflow. We use our GitHub project for bug reports and feature requests.

Best of luck. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  1) You need to use Alamofire to make your requests.
2) You need to make sure your requests are taking at least 1 second to complete, otherwise the indicator won't actually display due to the activation timer.
3) Set the activation timer and completion timer delays to zero to see them display on any request.

Hope that helps. In the future, please open issues against the actual AlamofireNetworkActivityIndicator project.

Cheers. üçª
  Thanks for the suggestion here @nicktrienensfuzz, but we'll keep the logic as is. It was originally written to ensure all three variables were available before processing the request.
  Hi @KhaledAld,

You are failing to parse the response JSON that's coming back. I would venture a guess that most likely no response data is coming back at all. Either way, you need to spend some more time debugging this issue on your own. If you're still stuck, please open a question on Stack Overflow instead of here on our GitHub project. We only use the GitHub project for bug reports and feature requests.

Best of luck. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  We won't be merging these changes into `master` until Xcode 7.3 is officially released. If you need to have these changes right now, then please continue to use the `swift_2.2` branch for now.

Cheers. üçª
  Also closed in #1085.
  You cannot change this easily @nahouto. The NSURLSession is going to choose the chunk size for you automatically. Here's a decent [thread](http://stackoverflow.com/questions/20131900/ios-how-to-increase-chunk-size-for-nsurlsession-upload-task) explaining why. 

With that said, it is probably possible to create a different buffer size if you want to go to the effort of creating a custom `NSInputStream`. Here's a [thread](http://stackoverflow.com/questions/22864565/upload-with-buffer-ios-7) detailing how you might go about it. However this is quite complicated and can lead to many unexpected issues.

> I'd highly recommend not going this route.

Cheers. üçª
  As @abunur mentioned, you need to make sure your URLs do not contain whitespace. The `URLRequestConvertible` protocol clearly states that any methods in Alamofire using the protocol as a parameter MUST conform to [RFCs 1738 and 1808](https://github.com/Alamofire/Alamofire/blob/master/Source/Alamofire.swift#L31-L42). In simple terms, this means you need to make sure your URL is valid before passing it into Alamofire.

If you use the `ParameterEncoding` enum to encode your URL, Alamofire will make sure to encode all your spaces properly for you. In the future, these types of questions are best suited for Stack Overflow. We use GitHub for bug reports and feature requests.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  I'm not really sure what to tell you here @groovz. At this point, I can't see any actual Alamofire calls being made. Therefore, it's difficult for me to say exactly what's going on. It appears as though you've managed to deadlock the session delegate queue for a URL session (`com.apple.NSURLSession-work`), but that's just a theory at this point. Without a solid code sample or a sample project, there's very little to go on.

I'm going to close this out for now since I can't see any further action I can take. If you provide more info, I'd be happy to re-open and investigate further.

Cheers. üçª
 Hmmmm...thanks for all the info, but I still can't pinpoint any actual issue here with Alamofire. We haven't had a single report of deadlocking with parallel uploads and downloads. With the way the logic is constructed, I'm very doubtful the issue itself lies in Alamofire.

In all my networking experience, I've generally found it to be a bad idea to use a concurrent URL session delegate queue, mainly because it can lead to deadlocks. The problem is that the queue doesn't call the delegate for a single request on the same thread, it will jump threads. So two delegate callbacks you would expect to receive serially will actually happen in parallel. This can lead to really odd runtime logic and can easily lead to deadlock scenarios.

> Generally, avoid concurrent session delegate queues if possible unless you really have an extremely good reason to do so. It's much easier to keep a serial session delegate queue and then dispatch immediately when you receive the delegate call. Then you have full control.

As for what's actually causing your deadlock, I cannot be certain. As I mentioned before, I really doubt it's an issue with Alamofire because we haven't had a single report of this until now. Additionally, with what you've mentioned about changing out the session delegate queue and also making pubnub requests at the same time, I'm fairly certain this is a deadlock scenario you've created on your own end. Unfortunately, there's not much I can do to help you debug any further. The only other thing I can think of to help you is to turn off all the pubnub logic and use a serial session delegate queue and try to resolve your deadlock. You most likely won't be able to trace the root cause of it until you start eliminating some of the possible options.

Best of luck! üçª
 Cool...glad you figured it all out! üëçüèº
  You'll need to get rid of those spaces at the beginning and end of your URL string, as those are not valid URL characters. I also suggesting using our latest version, 3.2.0, to begin learning the Alamofire APIs. Your API usages appears to be out of date.
  Could you put together a quick code sample demonstrating your use case? That would make it much easier for us to come to a decision.

Thanks!
 We will not be adding a third party library as a dependency @fchaillou. That has already been discussed in great detail throughout other issues.

@KingOfBrian, I'm going to close this issue out for now. If you post feedback here, then I can gladly re-open later.

Cheers. üçª
 Sorry for the late follow up, but this is the sort of behavior that I'd like:

``` swift
request.responseJSON() { response in
    let modelResult = response.result.map { value in
        guard
            let json = value as? Dictionary<String, AnyObject>,
            let token = json["token"] as? String,
            let refreshToken = json["refresh_token"] as? String
            else
        {
            return .Failure(ServiceError.errorWithCode(.InvalidResponseContent))
        }
        return OAuthResponse(token, refreshToken)
    }
```

It's just slightly nicer than checking for error in this case, but as there are multiple transformations reads much better. I agree with you on project dependencies btw, but I think the map behavior in the atypical result object could be copied over here pretty easily.
 @KingOfBrian First, some of what you're trying to accomplish there would be better off as a custom response serializer and using the already provided API for creating your own `.response` methods. That said, I've implemented something similar as an extension on `Result` in my own app, and without further abusing `map`.

``` swift
extension Alamofire.Result {
    typealias SuccessClosure = (value: Value) -> Void
    typealias FailureClosure = (error: Error) -> Void

    // TODO: Change back to onSuccess once compiler stops being dumb.
    func ifSuccess(@noescape success: Closure) -> Result {
        if isSuccess { success() }

        return self
    }

    func onSuccess(@noescape success: SuccessClosure) -> Result {
        if case let .Success(value) = self {
            success(value: value)
        }

        return self
    }

    func ifFailure(@noescape failure: Closure) -> Result {
        if !isSuccess { failure() }

        return self
    }

    func onFailure(@noescape failure: FailureClosure) -> Result {
        if case let .Failure(error) = self {
            failure(error: error)
        }

        return self
    }
}
```

This allows the unwrapping to be chained, and has the `if` variants without capturing the underlying value. (They're named that only because the compiler couldn't tell the difference if they were overloads of the `on` functions.) 

We'll look at adding more functionality to `Result` in the future.
 I wouldnt call the map functionality abuse. It's standard result behavior across many languages, and it has come to be expected. It allows you to change the type in each chain step which is very powerful. But I agree, a custom response handler is what the code turned into.

It will be great to add more functionality to map though. If you want me to take a stab adding the standard functional methods, I'd love to!
 I'm certainly not opposed to adding this functionality @KingOfBrian. I think it could be a good addition for the functional crowd out there. If you want to take a stab at putting this together into a PR, that would be great! 

> Please make sure to add unit tests covering the common use cases.

Cheers. üçª
  In order to upload photo data, you need to extract the data out of the Photos or ALAssetsLibrary framework first, then append a body part with the image data. The fileURLs do not work the same way as files in your sandbox.

Cheers. üçª
  Hi @dalu93!

You can already do this with custom response serializers or manually parsing the response data yourself. Since responses can vary so widely for various error status codes, we cannot generalize the handling in Alamofire much more than we already have. If you have specific cases you need to handle, you'll need to use more advanced techniques to handle the errors gracefully. Please check out the [Custom Response Serializers](https://github.com/Alamofire/Alamofire#creating-a-custom-response-serializer) section of the README for more info.

Cheers. üçª
  I'm assuming you need to base64 encode your image data before uploading it. Just attaching the hash probably isn't what you're looking for. Either way, this type of question is much better suited for Stack Overflow. We use the GitHub project for bug reports and feature requests. If you already have a Stack Overflow question open, please attach a link to the question in this thread, and hopefully someone will be able to help you further.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Again, these questions belong only on Stack Overflow. We don't work through support questions on GitHub.

Best of luck. üçª
  Hi @jasminpethani,

I would suggest updating to the latest versions of CocoaPods and Xcode. That will most likely solve your issue. In the future, these types of questions are best suited for Stack Overflow. We use GitHub for bug reports and feature requests.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @acecilia, Alamofire does not support iOS 7 and hasn't for some time. If you need to support iOS 7, then you'll need to maintain your own Alamofire fork.

Cheers. üçª
  You need to add `upload.validate()` before `upload.responseJSON` in the `.Success` case. In the future, these types of questions are better suited for Stack Overflow. We use GitHub for bug reports and feature requests.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @DenHeadless,

Generally I'm against moving to a universal framework. We've had all sorts of issues with this in the past. Here are some other obvious downsides that I can see.
- Example project doesn't seem to work (obviously this is a huge problem if true)
- Another issue could be in other frameworks that use Alamofire as a dependency (such as AlamofireImage)
  - We've run into all sorts of weird dependency issues with Xcode and multiple OS's
- Can no longer not include certain files in certain targets and everything would need to be managed by `#if os()` flags.

@kylef, I'd love to get your take on this if possible.
 Thanks for putting this PR together @DenHeadless, but we've decided to not accept these changes. We're going to continue using multiple targets due to all the OS specific code in Alamofire.

Thanks again. üçª
 Just complexity. We already have all the kinks worked out by having multiple frameworks nested through several layers of dependencies. I'm not sure how using this approach would affect other libraries like AlamofireImage and all the other libraries out there that use Alamofire as a dependency and support multiple OS's.
  Hi @codesdk,

If you don't call this logic twice, it won't print out twice. I realize you don't think you are, but you must be. We have 100s of tests around this logic and have never had anyone report this behavior before. Please debug further and if you do end up feeling strongly that there truly is an issue in Alamofire, please submit a sample project to demonstrate the behavior and I'll happily re-open and investigate.

Cheers. üçª
 If you could submit a PR with a test reproducing the problem @liltimtim, I'll be more than happy to investigate. However, with the code formatting above and the PDFs, I can't possibly recreate the behavior you're seeing.
 Awesome, thanks @liltimtim! And yes, by PR I meant "Pull Request".
 Excellent! Thanks for letting us know @liltimtim. üëçüèº
  Hi @citrusbits,

First of all, none of the code you posted is calling any Alamofire APIs, so that doesn't help us. If you check out these [tests](https://github.com/Alamofire/Alamofire/blob/master/Tests/ResponseSerializationTests.swift#L318-L356), you'll see this error is sent when using a JSON response serializer with `nil` or empty data.

In the future, please open a question on Stack Overflow. We use the GitHub project for bug reports and feature requests.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  https://github.com/Alamofire/Alamofire#security
 Oh man @grosch...you need to chill out. Your reply here is certainly not appreciated.

I pointed @alessiofx to the docs to make sure he knew they were available. There is not nearly enough detail in the question to even know where to begin to help troubleshoot. In those cases, we generally point people to the docs, and they will ask additional questions if they still don't have the info they need.
 Thanks @grosch...the Stack Overflow question was MUCH better. I put together an answer on there. If you end up getting that working and feel it's something that really belongs in Alamofire, I'd love it if you'd open up a feature request with as much info as possible. I already have some ideas on how we could support it, but I really just need a way to test the implementation.

Cheers. üçª
  Thanks!
  You should print out the `response.data` in the failure case using:

``` swift
if let data = response.data {
    let json = String(data: data, encoding: NSUTF8StringEncoding)
    print("Failure Response: \(json)")
}
```

In the future, please open these types of questions on Stack Overflow. We use GitHub for bug reports and feature requests.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @yniesp, everything is building properly. Here's the output from the Alamofire 3.2.0 release:

``` bash
cnoon:~/Desktop/Tester$ carthage update
*** Fetching Alamofire
*** Checking out Alamofire at "3.2.0"
*** xcodebuild output can be found in /var/folders/s7/qpm0b2pn3d56rjlpl7g3_4fh0000gn/T/carthage-xcodebuild.NXtvLt.log
*** Building scheme "Alamofire OSX" in Alamofire.xcworkspace
*** Building scheme "Alamofire tvOS" in Alamofire.xcworkspace
*** Building scheme "Alamofire iOS" in Alamofire.xcworkspace
*** Building scheme "Alamofire watchOS" in Alamofire.xcworkspace
cnoon:~/Desktop/Tester$
```

And here's the output from HEAD on `master`:

``` bash
cnoon:~/Desktop/Tester$ carthage update
*** Fetching Alamofire
*** Checking out Alamofire at "59ef4f5da3fdba44649026603c6512fd6c5dabd0"
*** xcodebuild output can be found in /var/folders/s7/qpm0b2pn3d56rjlpl7g3_4fh0000gn/T/carthage-xcodebuild.4pVzap.log
*** Building scheme "Alamofire OSX" in Alamofire.xcworkspace
*** Building scheme "Alamofire tvOS" in Alamofire.xcworkspace
*** Building scheme "Alamofire watchOS" in Alamofire.xcworkspace
*** Building scheme "Alamofire iOS" in Alamofire.xcworkspace
cnoon:~/Desktop/Tester$
```

These were both built with `xcodebuild 7.2.1` and `carthage 0.12.0`. As for the Travis builds, something is going on with Travis. It's extremely unstable right now, so I wouldn't rely on Travis to tell you anything useful.

Cheers. üçª
  This question has been asked and answered many times. We only support one common form of collection encoding. For other types, you need to use the `.Custom` encoding. The `ParameterEncoding` methods have been publicly exposed to make it easier to do so.

For more info, please see https://github.com/Alamofire/Alamofire/issues/589 and https://github.com/Alamofire/Alamofire/issues/965.

Cheers. üçª
  This isn't true. What happens is the `Bool` bridges to an `NSNumber` when converted to an `AnyObject`. When you print out an `NSNumber` created from a `Bool`, it prints out `0` or `1`. However, once you run it through `NSJSONSerialization`, it encodes it as either `false` or `true`.

Cheers. üçª
 Oh my apologies, I missed the `.URL` encoding parameter type. I'm going to re-open this and investigate further.
 Okay @pheuberger, I managed to dig into this a bit more. The behavior you are seeing is intended. The reason has to do with the fact that all the parameters bridge over to Objective-C. The parameter encoding logic for URL encoding relies on the `CustomStringConvertible` protocol to covert the `AnyObject` to a string representation. In the case of an `NSNumber`, this will always default to `0` or `1` in the case of a `Bool`.

``` swift
let boolValue = true
print(boolValue) // outputs `true`

let bridgedBool: AnyObject = true
print(bridgedBool) // outputs `1`
```

In order for us to change this to `true` or `false`, we'd have to implement some fairly complicated and fragile logic into the ParameterEncoding enum that I'm not comfortable doing. Additionally, this is the behavior that all other users currently expect, so it wouldn't be a backwards compatible change in any way. For now, I'd recommend you continue using your current solution to turn the `Bool` values into Strings before encoding.

Once Swift 3 is released, we'll re-investigate as to whether parameters should come in as `[String: AnyObject]` dictionaries or `[String: Any]` dictionaries allowing everything to stay 100% swift.

Cheers. üçª
 @AppsTitude The unfortunate fact of the matter is that there is no single standard for encoding parameters in a URL query. Some of the standards that do exist (largely server implementations) vary between `true`/`false` and `1`/`0`. Also, when implementing the new workaround for Swift 3, we matched our old behavior that used `1`/`0` so as not to break backward compatibility.   If you'd like to validate the response codes, add `.validate()` to your `Request` chain. Check our docs for info on how to customize this function. 
  These changes started with me experimenting with the ideas in #1029, then became something pretty awesome!

This PR adds the ability for Alamofire to track the timings of a `Request` throughout it's entire lifecycle with virtually zero overhead. The `Timeline` object stores all the timing info about the `Request` and is delivered as part of the `Response` object. The timings are collected at various points throughout the lifecycle of the request.

Alamofire can now report the latency, request duration and total duration of any `Request`. I also added `CustomStringConvertible` and `CustomDebugStringConvertible` conformance to the `Timeline` to make it really easy to print out the info.
 cc @jshier, @kcharwood, @kylef for review
 I'll add a section to the README about this once everyone is on board that this is a good set of changes to put in.
 Thanks @alimoeeny! It was definitely fun to put together.
 :+1:

@alimoeeny I do logging in my custom `.responseObject` extension, taking the closure that comes in, adding my logging call, and passing the result the actual serializer. I imagine you could do the same, especially if you have a custom response closure already.
  This PR adds the `NetworkReachabilityManager` class to the project along with full coverage of the APIs. All public APIs have docstrings and I also added a section to the README with tips and tricks. The class is fully available on `iOS`, `OSX` and `tvOS` but not `watchOS`. The podspec has been updated to reflect the `watchOS` omission.

One important callout is that the default socket address uses IPv6. Other than that, the logic is fairly similar to `AFNetworking`. I added a bit more functionality around the `Listener` closure by allowing you to specify the `dispatch_queue_t` the closure is called on.
 cc @jshier, @kcharwood, @kylef for review
  Hi Ronak,

These are all fantastic questions. At the moment, Alamofire does not have very strong support for background downloads. You observations are all perfectly valid. Let me try to answer your questions one-by-one.
1. Yes, this is a realistic case. You need to be able to handle this case properly, otherwise you can end up in a strange app state when you relaunch.
2. If you want to use Alamofire for background downloads, you need to override the `SessionDelegate` task closures. When your app gets relaunched, you need to recreate your `SessionDelegate` and wire up the closures, then recreate the background URL session with the same identifier. This is more or less what you would do if you weren't using Alamofire. What you MUST remember is that you cannot rely on `response` closures that were attached to a `Request`. Since your app was terminated and relaunched, the `Request` objects no longer exist.
   
   > To use Alamofire with background downloads, you currently need to not use the `response` closures and override the `SessionDelegate` closures.
3. You don't need to do this. You only need to recreate your background URL session when your app delegate is notified to `application:handleEventsForBackgroundURLSession:completionHandler:`. An easier approach may be to recreate the background URL session when your app is launched. But some people may feel that you should instead create the URL session lazily. Your call either way.

So, in summary, you can absolutely use background URL sessions with Alamofire. There is not as much convenience yet as there could be, but it can certainly be done. You need to make sure you don't use the `response` closures, and you need to override the task override closures in the `SessionDelegate`.

> _Full Disclosure:_ If you are just downloading files in the background, I'd recommend you just create your own `NSURLSession` and `NSURLSessionDelegate` and wire it up yourself. The URL requests are easy to build since you really only need to pass a URL. There's just too much overhead on Alamofire for this use case. The Alamofire APIs are also designed around closures chained to the `Request` which doesn't work with background sessions.

Additionallly, this is already being worked on in #981. I'd encourage you to check it out and provide some feedback. I haven't had time to review that PR yet myself.

Thanks for the awesome question. Hopefully that helps clear some things up. Cheers. üçª
 I don't understand your reasoning here @ronak2121. First off, I don't understand what you mean by multiplexing in #1. As for #2, I don't understand what that accomplishes. Additionally, recreating requests is only easy if you have them completely abstracted and all callbacks are done using a delegate pattern, not closures.
 While I appreciate your feedback here, I respectfully disagree. There are MANY other complex things going on here. As mentioned before, we've put this into our backlog slated for Alamofire 4.0 to make sure we handle things properly. We'll take all this feedback into consideration when we start working through our actual solution.

Cheers. üçª
  Alamofire does not support web sockets. However, it does support `NSURLSessionStreamTask` which could be used to implement web sockets. There are currently no plans to add support for this.

Cheers. üçª
  Thanks for putting this together @vivid-cieslak! I cherry picked it into `master` in 59ef4f5d.

Thanks again! üçª
  These are all very valid points @popwarfour. This particular behavior has a lot of history, but your description and reasoning here is spot on. We're discussing this right now and will get back to you shortly. Thank you for the detailed write up!
 Okay @popwarfour, thanks for your patience. We had a good discussion on Slack about this topic and have decided to revert the changes in 75c269ae. Instead, we are now properly handling the case of an empty query string in URL encoding. This has been fixed in 8b618c76 if you want to check it out. These changes will be available in the 3.2.0 which we are working on right now.

Thanks again for your excellent description here. We've been fighting this issue ever since that change was made. You managed to get to the root issue which made it much easier to work out the proper solution.

Cheers. üçª
  You are most likely being hit by ATS. Please see this [section](https://github.com/Alamofire/Alamofire#app-transport-security) in our README. Also, these types of questions are best suited for Stack Overflow. We use GitHub for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  This future will be added to Alamofire in our next release. It is not currently available.
  Why not use a ServerTrustPolicyManager instead here? Much easier to work with. Additionally, these types of questions are best suited for Stack Overflow. We use GitHub for feature requests and bug reports.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Thanks @oflannabhra!
  Hi @katunch,

I just verified that everything is working properly with the latest release of Carthage and Xcode 7.2. Here's the output using the same `Cartfile` you have.

``` bash
cnoon:~/Desktop/Tester$ carthage update
*** Fetching Alamofire
*** Checking out Alamofire at "3.1.5"
*** xcodebuild output can be found in /var/folders/s7/qpm0b2pn3d56rjlpl7g3_4fh0000gn/T/carthage-xcodebuild.kj6RLc.log
*** Building scheme "Alamofire OSX" in Alamofire.xcworkspace
*** Building scheme "Alamofire iOS" in Alamofire.xcworkspace
*** Building scheme "Alamofire tvOS" in Alamofire.xcworkspace
*** Building scheme "Alamofire watchOS" in Alamofire.xcworkspace
```

What you need to do is update your installation of Carthage and try again. All you need to do to do that is the following:

``` bash
cnoon:~$ brew update ; brew doctor
cnoon:~$ brew upgrade carthage
```

Best of luck! üçª
 You also want to make sure you're running the latest version of Xcode and that `xcodebuild -version` reports that latest version as well.
 I believe this ends up happening when you don't have an iOS simulator installed with a connected watch simulator. Please see this [thread](https://github.com/Carthage/Carthage/issues/790) for more info. If you are still experiencing issues, I'd suggest filing an issue with the Carthage project.
 Excellent @mmizutani üëçüèº
  Hi @terenzeyuen,

Short answer is no. You'll need to make the requests one-by-one and manage to completion of all downloads at the client level. With that said, I'd recommend you check out [AlamofireImage](https://github.com/Alamofire/AlamofireImage). It does have the ability to batch download a list of images.

Cheers. üçª
  This is the expected behavior @foffer. You need to make sure your `URLString` conforms to RFCs 1738 and 1808. Otherwise you will not be able to construct a valid `NSURL` as you have seen. This is documented clearly in the [URLStringConvertible](https://github.com/Alamofire/Alamofire/blob/master/Source/Alamofire.swift#L31-L42) docstrings.

``` swift
public protocol URLStringConvertible {
    /**
        A URL that conforms to RFC 2396.
        Methods accepting a `URLStringConvertible` type parameter parse it according to RFCs 1738 and 1808.
        See https://tools.ietf.org/html/rfc2396
        See https://tools.ietf.org/html/rfc1738
        See https://tools.ietf.org/html/rfc1808
    */
    var URLString: String { get }
}
```

I'm not completely sure what you're use case is, but if you can, you should leverage the `ParameterEncoding` enumeration encoding which can handle all this for you to ensure your URL is properly encoded.

Cheers. üçª
  Hi @gaganpsinghkrishnais, these types of questions are better suited for Stack Overflow. We use GitHub for feature requests and bug reports.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Alamofire is a wrapper around the Cocoa URL Loading System, as mentioned in the [advanced usage](https://github.com/Alamofire/Alamofire#advanced-usage).

I think what you are looking for is already available there:

> ## Advanced Usage
> 
> > Alamofire is built on `NSURLSession` and the Foundation URL Loading System. To make the most of this framework, it is recommended that you be familiar with the concepts and capabilities of the underlying networking stack.
> 
> **Recommended Reading**
> - [URL Loading System Programming Guide](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html)
> - [NSURLSession Class Reference](https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSURLSession_class/Introduction/Introduction.html#//apple_ref/occ/cl/NSURLSession)
> - [NSURLCache Class Reference](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html#//apple_ref/occ/cl/NSURLCache)
> - [NSURLAuthenticationChallenge Class Reference](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLAuthenticationChallenge_Class/Reference/Reference.html)
 Hi @skington, what you are asking us to document is not even possible. You cannot make your own requests. The `Manager` instance is responsible for creating `Request` objects and vending them back for inspection. The reason for this design is the fact that Alamofire wraps the URL Loading System as @kylef mentioned earlier.

I would recommend reading the docs that @kylef posted, then read through the Alamofire README a second time. All the information to make all different requests is in there. You cannot dive straight into Alamofire without understanding the URL Loading System and how it works. Alamofire is a convenience layer on top of the Apple APIs making networking easier and more convenient, but it is not a replacement. The APIs work very closely together which is why it's important to learn both.

I'm going to close this issue out for now. If you have some more specific requests that you would like to see us add, I'd be happen to re-open if they seem like a useful addition for the community.
  @donpironet You'll need to keep a reference to your manager around. You requests are being cancelled because the manager you're using is being deallocated. I like to use a `static let sharedManager` in my `Manager` subclass to maintain a single instance.
 Because it's not static. A `private let` is just an instance variable, one that's deallocated with the instance. Create a `static let sharedManager = RegisterManager()` and use it for your request calls (i.e. `RegisterManager.sharedManager.request()`).
  Everything actually works as you would expect once it goes through `NSJSONSerialization`.

``` swift
import Foundation

var params = [String: AnyObject]()
params["test"] = "testString"
params["b1"] = true

print(params)

let data = try! NSJSONSerialization.dataWithJSONObject(params, options: .PrettyPrinted)
let json = String(data: data, encoding: NSUTF8StringEncoding)
print(json)
```

What you're seeing when you print the dictionary is the result that the bridged `NSNumber` returns from `description`. All is good. üëçüèº
  You need to pass the headers in the `request` method directly, not set them on the configuration. You can also set them in the configuration if you create a custom `Manager`. But your best bet is to use the `headers` parameter in the `request` method.

Best of luck! üçª
  Hi @dinya007, thank you for your willingness to contribute! I think at this time that we'd rather not add this particular change since we'd rather direct everyone to leverage the `ParameterEncoding` types, but please keep the ideas coming!

Cheers. üçª
  Excellent @eriktelepovsky! 

I'm going to close this issue out @pradeep-chauhan. There isn't much to go on here and our test suite is working fine. If you can provide some more details on this particular issue, I'll be happy to re-open.

Cheers. üçª
  Thanks!
  Hi @adamjweaver, the reason that it is no longer being called is that we no longer call the `.Custom` closure in the event that there are no parameters being passed in. This was changed in the `3.1.4` release. However, due to several issues being opened on this topic, we're debating as to whether reverse the logic. Please hold tight for now while we figure this out. For now, you'll need to stay on the 3.1.3 release unless you can find another workaround.

We don't intend the `.Custom` encoding to be used unless you actually have parameters to encode. However, we've had multiple reports of users using this for other things than what it was intended.
 Okay @adamjweaver, thanks for your patience. We've decided to revert the changes in 75c269ae and instead handle the case of an empty query string properly for URL encoding. I've fixed up the issue in 8b618c76 if you want to check it out. These changes will be available in the 3.2.0 which we are working on right now.

Cheers. üçª
  Hi @viri, my apologies for not getting back to you sooner. I'm glad you found a workaround. As for your authentication issue, I'm not quite sure what the problem was. You didn't post enough code for me to be sure you weren't making the request wrong. My best guess is that your credentials created by calling the authenticate were failing when the challenge occurred which was triggering the error. However, without some more code to investigate, I can only speculate.

I'm going to close this out for now since you were able to resolve your issue. Cheers. üçª
 Alright @viri, could you please post a full code sample (not just the `responseData` closure) and also the error you are seeing? We need more info to go on here.
 Thanks for all the info here @virl. Now I understand exactly what your concerns are and why you are seeing the behavior you are. This is NOT a bug. This is the exact behavior you should see. What happens when there is an authentication challenge is the following:
- Request is made
- Server sends back authentication challenge for basic auth
- Alamofire provides credentials provided by `authenticate`
- Credentials are sent back to server
- Server rejects credentials and sends back authentication challenge again
- Alamofire cancels the request since authentication has failed
- The request is completed with a cancellation error and no response

There is never a response generated in this scenario, which is why you won't see one when an authentication challenge fails. Hopefully that helps clarify things.

Cheers. üçª
  Thanks for putting this together @Baza207! I cherry picked the commit into the new `swift_2.2` branch in 3cf3614c. We'll maintain this separate branch until Xcode 7.3 is officially released.

Thanks again! üçª
  Hi @alimoeeny, thanks for the awesome idea! I started playing around with different ways to make something like this to work and it turned into PR #1054! If you could check that out, I'd certainly appreciate it.

I'm going to close this issue out for now. Please redirect all comments to #1054 from here on out. Thanks! üçª
  Please update to 3.1.5 and try to reproduce again, as I was unable to reproduce using 3.1.5 on the 9.2 6s simulator. I get the result: `T%C3%BCrkiye`.
 Hi @ergunkocak, I'm going to close this out since we cannot reproduce. If you can create a good repro case I'll be happy to re-open.

Cheers. üçª
  Alamofire will escape your parameter strings if you pass your parameters to one of the `.URL` `ParameterEncoding` types. Or you could call the parameter escaping used by Alamofire manually by calling `ParameterEncoding.URL.escape()`

You can also pre-escape your URL strings using the non-deprecated `.stringByAddingPercentEncodingWithAllowedCharacters()` and one of the [URL character sets](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSCharacterSet_Class/index.html#//apple_ref/doc/uid/20000157-SW12). Depending on what part of the URL your escaping, you'll use a different character set.
  Thanks for letting us know. We'll get this fixed ASAP.
 @jshier has already created one approach in #1027. I'm going to close this issue out for now. Please direct all future comments to #1027. üëçüèº
  Your `Content-Type` header is being overwritten by the one generated by the `.JSON` encoding type. To set the header while still using the result of `.JSON` encoding, use the `.Custom` encoding, like this:

``` swift
request(.POST, URLString, parameters: parameters, encoding: .Custom({ (inRequest, parameters) -> (NSMutableURLRequest, NSError?) in
            let JSONEncodedRequest = ParameterEncoding.JSON.encode(inRequest, parameters: parameters).0
            JSONEncodedRequest.setValue("application/vnd.api+json", forHTTPHeaderField: "Content-Type")

            return (JSONEncodedRequest, nil)
        }), headers: nil)
```

This should accomplish what you want. And if you have more than one or two requests in your app, I would recommend following the `URLRequestConvertible` router pattern [mentioned in our documentation](https://github.com/Alamofire/Alamofire#crud--authorization) so that you don't need to keep replicating this logic. 
 Thanks @jshier!
  Yes, you'll need to remove or move the old file first. Alamofire plays it safe and doesn't do it automatically.
  I have answered this question [on StackOverflow](http://stackoverflow.com/questions/34934369/alamofire-serial-requests).
  If you're seeing a crash, a code sample which reproduces it would be a good starting point for us to start investigating this issue. As well, the actual crash report would help in determining what lead to the crash.
 Your example doesn't compile, as parameters is `[String : AnyObject]`. I tried this and it didn't crash:

``` swift
request(.GET, "https://httpbin.org/get", parameters: ["data" : NSData()], encoding: .URLEncodedInURL, headers: nil).responseString { response in
            print(response)
}
```
 Hi @fulldecent, unfortunately in this case there's nothing we can do to help you. You are passing in parameters that cannot be represented in JSON. You cannot store raw data like that in JSON. It needs to be in the form of a valid JSON object type. It's really a bummer that `NSJSONSerialization` does not handle this case better, especially considering it throws in the event of encountering an error. I just verified that your parameters will crash.

I'd suggest you do two things. 1) Make sure you only create valid JSON objects as parameters. 2) File a radar with your sample code. This should not crash but should throw an error.

Cheers. üçª
  Such a large feature requires careful planning and consideration, so it's certainly not a short term feature. However, we are tracking it internally and will take it into consideration for future versions.
 In the meantime, here's a [post](http://stackoverflow.com/questions/28733256/alamofire-how-to-handle-errors-globally/28748683#28748683) where I documented how you "could" implement OAuth2 yourself.
  If you're having such an issue, and can't cut down on the amount of data to be serialized, you can always create your `NSURLRequest`s asynchronously before issuing the Alamofire `Request`. A quick and dirty version might be: 

``` swift
dispatch_async(dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0)) {
    let request = Router.GET(parameters: bigParameters).URLRequest
    Alamofire.request(request)
}
```

However, we'll keep this request in mind in the future.
 Hi @Joost-Elements, if you're encoding a giant payload, you need to either handle it asynchronously yourself and then hand it over to Alamofire, or call Alamofire asynchronously like @jshier documented. Serializing this asynchronously would require ALL the public APIs for `Request` creation to use completion closures which would seriously complicate things. It's certainly best for this rare case to push the responsibility down to the clients.

Cheers. üçª
  Without more detail about what you've tried and the specifications of you backend service, it's hard to say where the issue is here. To get a broader audience for you question, use StackOverflow and tag Alamofire while providing as much context and detail you can about your backend service.

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Could you be more specific? Alamofire provides both a `.progress` property on `Request` as well as the `.progress()` closures which can provide the progress details usually provided by `NSProgress`. We're also tracking additional progress report features in our backlog. However, a more precise explanation of your requirements would help us refine what users are looking for in this area.
 Hi @fulldecent, thank you for your suggestion. This is not a change we will be making though for a couple reasons. 

First off, that protocol is only for objects reporting a single progress object. A manager is going to be reporting progress on all network activity. If each request creates a child progress object, you won't be able to track the progress on a per request basis anymore. Everything just gets MUCH more complicated.

Additionally, the progress APIs from `NSURLSession` don't work this way either. Progress is measured per request and reported back in that same manner. Collating the progress is not something Alamofire knows how to do since it doesn't know the relationship between requests.

Cheers. üçª
  Your code sample is too incorrect to tell what type of parameters you're actually trying to POST. Asking this question on StackOverflow with a full code sample and tagging Alamofire may provide you better answers.

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  @iDuke I'm closing this issue for now, as you have an answer. If you need more help, feel free to open a question on StackOverflow and tag Alamofire. 

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  The mysteries of Xcode's UI are likely a better question for StackOverflow, but I believe the README is a bit misleading in this instance, as it may not have been updated for the watchOS and tvOS targets. So I think it's referring not so much to the top or bottom group, but merely the spatial relationship between the iOS and OS X frameworks in a single one of those lists. I'll make a note to get that updated.
  Thank you for the pull request @hwittland. Unfortunately, we don't think this is a good change to make to the core Alamofire logic. It already defaults to the main queue when a custom one is not provided. Additionally, the queue can easily be overridden already by calling the `response` method with a queue and response serializer.

Thanks again. üçª
  I believe you're technically correct, which is the best kind of correct, but such a change in vocabulary would have a rather wide ranging impact on this project, given that the term isn't just used in documentation but the names of classes and functions, both currently and historically (and shared with the AFNetworking library). Having both terms, some in documentation and others in code would likely be more confusing than clarifying. So this is unlikely to change, but we'll keep it in mind for the future.
 This is not the first time this question has been asked. More details in https://github.com/Alamofire/Alamofire/issues/674.
  @MarcSteven You'll need to provide the full code for your `MSGistRouter` type, as well as the compiler error given, for anyone to have success in diagnosing your issue. 
 Glad you got it working.
  Build configurations and external dependencies can be tricky to get right in Xcode. You'll likely have better luck asking such a question on StackOverflow, tagging Alamofire, and providing more detail, like how you're integrating Alamofire and whether you have other dependencies. 

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @samirGuerdah...thanks for the pull request! Unfortunately, these changes are too heavy handed and should not be merged. This attribute is only to be used in cases where you actually want to throw up a warning if the return value is not used. For example, we don't want to throw a warning on the `Alamofire.request()` method if you don't use the returned `Request`.

Thanks again. üçª
  You seem to be having trouble properly communicating with whatever backend you're using. Asking such a question on StackOverflow, tagging Alamofire and providing some code showing how your request is being issue with likely lead to better results. If you do find a bug with Alamofire, please open a new issue and provide a code sample that shows the issue.

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  You'll need to provide more detail for anyone to be able to answer your question. You'll also have better luck asking such a question on StackOverflow and tagging Alamofire.

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  The line `queue ?? dispatch_get_main_queue()` uses Swift's nil coalescing operator, [as described in Swift's documentation](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html), to use the main queue if none is provided. We also have many tests around this feature and in fact the library wouldn't even function if the completion handler was never called. So it's likely this is an issue with your code, in which case you'll likely have better luck finding a solution using StackOverflow and tagging Alamofire, as recommended by our Contributing document. If you do think you've found a bug in the library, feel free to open another issue with code that shows the bug.

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  It looks like you're having trouble figuring out how to communicate with your backend (or really, a local version of such). You'll likely have much better luck asking such a question on StackOverflow, as recommended in our Contributing document. If your issue is a bug in Alamofire, feel free to open another issue with as much detail as you can provide so we can try to debug the issue.

# 

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  In order to diagnose or trouble shoot this issue, we'll need your crash log and your calling code. 
 You cannot provide an invalid `NSURL` when using the `download` API. Alamofire will try to move the temp file to the file URL you have provided. You are intentionally providing a bad URL which is crashing NSFileManager most likely.
  Add some delay to your loop, or perhaps use `dispatch_after` or an operation queue so you're not sending requests really quickly?
 I'm with @kylef on this one @Jonovono. When receiving a 429, you should retry using an exponential back off implemented with `dispatch_after`.

Also, these types of questions are generally better suited for Stack Overflow. Cheers. üçª
  @Chatatata I think that "NS'ish" class you mention belongs in Foundation, and should be implemented there and not inside Alamofire. In particularly over at https://github.com/apple/swift-corelibs-foundation/blob/master/Foundation/NSURLSession.swift and https://github.com/apple/swift-corelibs-foundation/blob/master/Foundation/NSURLProtocol.swift.

Apple mention on the [Swift corelibs Foundation README](https://github.com/apple/swift-corelibs-foundation#part-of-swift-30) that they aim for implementation parity with Darwin's Foundation for Swift 3.0: 

> Our primary goal is to achieve implementation parity with Foundation on Apple platforms. This will help to enable the overall Swift 3 goal of portability.

Alamofire also uses libdispatch which is not yet available on Linux [from swift.org](https://swift.org/core-libraries/#libdispatch):

> libdispatch is currently available on all Darwin platforms. This project aims to make a modern version of libdispatch available on all other Swift platforms. To do this, we will implement as much of the portable subset of the API as possible, using the existing open source C implementation.
 Well said @kylef. I'm going to close this issue out since support needs to be built into Swift Foundation, not Alamofire directly. 

Cheers. üçª
  Hi @ski081,

I can't spot anything obviously wrong in your sample code. I'd recommend checking out the [tests](https://github.com/Alamofire/Alamofire/blob/master/Tests/ManagerTests.swift#L202-L280) we have verifying this behavior. If that doesn't help you spot your issue, then I'd suggest opening a question on Stack Overflow with more info.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  @renatop7 What does  `.description` print for your `Request`? That should tell you what method is being used.  Using `.debugDescription` will give you a curl command you can run to see any behavioral differences.
 If you take a look at the difference between what's printed when using your router and when using the direct call, you should be able to see any differences that are causing your backend to behave different. As you can see, Alamofire is generating the correct method type. 

I'm closing this issue for now. If you need more support, create an issue on [StackOverflow](http://stackoverflow.com) and tag `Alamofire` and the community there will help you out. However, if you find an Alamofire issue, feel free to open another issue here.
  Hi @Hokila,

Questions like these are best suited for Stack Overflow. We use the GitHub project for bug reports and feature requests.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  @itchingpixels Thanks for this! However, we'll need to do a much more comprehensive investigation to support this feature. We are tracking automatic retry as a feature in our backlog, so it's possible we'll support this in the future.
  I put together a fairly detailed [code sample](http://stackoverflow.com/a/28748683/1342462) on Stack Overflow documenting this. Hopefully that helps get you going in the right direction. If you need further assistance, then I'd suggest opening a new question on Stack Overflow.

Cheers. üçª
  There certainly is.

``` swift
Alamofire.upload(
    .POST,
    "https://httpbin.org/post",
    multipartFormData: { multipartFormData in
        multipartFormData.appendBodyPart(fileURL: unicornImageURL, name: "unicorn")
        multipartFormData.appendBodyPart(fileURL: rainbowImageURL, name: "rainbow")
    },
    encodingCompletion: { encodingResult in
        switch encodingResult {
        case .Success(let upload, _, _):
            upload.progress { bytesWritten, totalBytesWritten, totalBytesExpectedToWrite in
                print(totalBytesWritten)
            }
            upload.responseJSON { response in
                debugPrint(response)
            }
        case .Failure(let encodingError):
            print(encodingError)
        }
    }
)
```

üëçüèº
 Your best bet would be to try to [suspend](https://github.com/Alamofire/Alamofire/blob/master/Source/Request.swift#L154-L156) the `Request` which in turn calls [suspend](https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSURLSessionTask_class/#//apple_ref/occ/instm/NSURLSessionTask/suspend) on the `NSURLSessionTask`. The docs for the `suspend` method on the task state as follows:

> A task, while suspended, produces no network traffic and is not subject to timeouts. A download task can continue transferring data at a later time. All other tasks must start over when resumed.

While this will technically pause the upload, I don't believe it will be able to resume the upload where it left off. It will inherently restart the upload from the beginning when it is resumed. I've never actually tried this myself, so I'd be interested to see how it works.

With that said, you can certainly resume uploads if your server supports it. There's just not any simple built-in way in Apple's or Alamofire's APIs to do so. Check out this [thread](https://developers.google.com/youtube/2.0/developers_guide_protocol_resumable_uploads) for more info.
  You need to extract the parameters from each case in the `Router`, then pass them into the `encode` method. Right now, you are passing `nil` into your `encode` method which is why it won't work properly.

In the future, you should ask these types of questions on Stack Overflow. We use our GitHub project for feature requests and bug reports.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
 That code shouldn't even compile. You need to change this:

``` swift
let request = NSURLRequest(URL: URL!.URLByAppendingPathComponent(result.path))
```

to this:

``` swift
let request = NSMutableURLRequest(URL: URL!.URLByAppendingPathComponent(result.path))
```
 Yep...that would do it! Glad you figured it out. üëçüèº
  Hey thanks!

As for your issue, have you considered not using the Alamofire shared instance of the `Manager`? That is really only intended for simple use cases and for demonstration purposes. In general, I would expect production ready apps to configure a custom `Manager` with all the bells and whistles (customized URL session configuration, custom URL cache, etc.). Would it be possible in Moya to create a custom `Manager` instance that takes a configuration flag as to whether `startRequestsImmediately` should be set to `true` or `false`?

Setting up a custom instance of the `Manager` to match the shared instance is as simple as:

``` swift
let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
configuration.HTTPAdditionalHeaders = Alamofire.Manager.defaultHTTPHeaders

let manager = Alamofire.Manager(configuration: configuration)
manager.startRequestsImmediately = false
```

That seems like the best option to me at the moment. Adding the `startRequestsImmediately` to the top-level APIs certainly would work, but seems heavy handed. We're trying to keep those top-level APIs as simple as possible by avoiding any additional parameters.
 Sounds good @ashfurrow. I think it's also a great choice to use DI in this case and have Moya be able to take in a pre-configured `Manager`. That gives Moya users the flexibility to configure everything they should need. üëçüèº
  It was closed by the original creator of the issue. If you having issues, please open a question on Stack Overflow. If you have found a potential bug in Alamofire, please open a new issue on GitHub.

I'm going to lock this issue down.
  Hi @tokorom,

This behavior is intended. The `.Custom` parameter encoding case should only be used for creating a custom parameter encoding for the URL request, nothing else. It doesn't logically make sense to be customizing all different parts of the URL request inside of a parameter encoding method. It should only customize the parameters.

> Please see #954 for more info about the change.

Instead, you should create your own URL request manually and customize as needed. You can still use the `ParameterEncoding` encode method, then customize the returned mutable URL request as needed. Once you are finished, you can pass it to the `Manager.request` method to execute the request.

Hopefully that all makes sense.

Cheers. üçª
  Thanks for putting this together @tokorom...much appreciated! I merged a slightly modified variation of your changes in 08cf2695 while still giving you attribution. Thanks again for putting this together! üçª
  Thanks for putting this together @dapenggao! I merged a slightly modified version of your changes in fa5a10d2 while still giving you attribution. You need a `prefix(6)` to maintain the same logic. I also pulled the `quality` into a separate local variable to make it a bit easier to understand.

Thanks again! üçª
  Thanks for putting this together @mwoollard! This is going to take me a while to dig through everything you have put together and wrap my head around everything. Please be patient with us while we evaluate this PR. Thanks!
 I haven't forgotten about this @mwoollard. Hope to get to it soon!
 Okay @mwoollard, I finally managed to make it through your PR. Unfortunately, I don't think these changes or this approach should be adopted into Alamofire. These changes are quite involved and don't solve the core issue which is that all the closure logic is still being dropped.

When we add better support to Alamofire for background sessions, we have to address the fact that all the public APIs currently only serve `default` and `ephemeral` configurations. Closures simply don't work with background sessions. Just FYI, we've slated better background session support for Alamofire 4 in our Trello backlog.

Thanks again for all your work here. All the best. üçª
  That is the expected behavior. It explicitly calls that out in the documentation.
  Hmmmm...not sure off the top of my head. I really doubt it's actually an issue with the Alamofire framework. I would be more inclined to guess it has to do with the way you added the Alamofire framework to your framework target and/or your test target. I would guess you don't have the linked frameworks set up quite right.

If you can verify that everything is configured as expected, then I would suggest filing an issue with the Carthage project. They would certainly be better equipped to help you troubleshoot. If you do in fact find an actual issue with our project settings for the framework, please provide more info and I'll be happy to re-open this issue and continue to investigate.

Cheers. üçª
  Hi @dickwu,

My guess at this point is that you're getting bit by ATS. Here's a few tips:
- Check out our documentation in the [README](https://github.com/Alamofire/Alamofire#app-transport-security). This will most likely fix up your issue.
- Dig through all the info in #876. There's a TON of great info in that issue about ATS and how to wield it.
- Finally, you should stop using self-signed certs. Check out Let's Encrypt like @ntnmrndn mentioned. üëçüèº

If you still cannot figure it out, I'd suggest opening a question on Stack Overflow.

Best of luck! üçª
  At the moment, there are no plans to build this type of feature. With that said, I just added a card to our Trello backlog to discuss this further with the ASF.

Cheers. üçª
  Hi @MarcSteven, I'm sorry you were receiving the error. Since there are thousands of people using Alamofire and CocoaPods together without issues, I'm going to assume you were running into an issue with your local setup and possibly your project.

We have fairly detailed instructions in our [README](https://github.com/Alamofire/Alamofire#cocoapods) that should help you iron out your issue. Another useful tip is to make sure your CocoaPods installation is up-to-date and that your Xcode Command Line Tools is set properly. Beyond that, I would encourage you to open a question on Stack Overflow to get further assistance. We use our GitHub project for bug reports and feature requests.

Cheers. üçª
  Version 1.3.1 and below support iOS 7, you may use the 1.x versions as mentioned in the 1.x READMEs: https://github.com/Alamofire/Alamofire/tree/1.3.1

Version 2.0 and onwards is iOS 8+.
  I'm going to close this issue out. Please provide more details in the future @cloudjanak so we know what it is you are actually asking or suggesting. Cheers.
 You cannot reuse the session after you have invalidated it. You will have to create a new Manager after invalidation to continue making requests.
 I've already answered your question on Stack Overflow. You need to invalidate the session, then you need to create a new `Manager` instance and make requests through that.
  Hi @sebastienvermeille,

We have many tests and thousands of users that are not experiencing this problem. Most likely this is an issue with the way you are forming your response or with your server. In general, these types of questions are best suited for Stack Overflow. We use the GitHub project for bug reports and feature requests.

Best of luck!

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
 Agreed @ntnmrndn. 

Alamofire does not actually modify the data coming back from the server in any way @sebastienvermeille. If it is changing, it is not Alamofire that is doing it. The sample code you posted simply makes the request using an `NSURLSession`, and uses `NSJSONSerialization` to parse the response data. There's nothing Alamofire would be doing to modify the data out from under you. 

As @ntnmrndn suggested, if you need further assistance, we need a sample project to go on. Additionally, these types of questions are best suited for Stack Overflow. I can almost guarantee you the issue here is not Alamofire. If you open a question on Stack Overflow and post the link here, we could continue to help you there.
  Hi @rjong,

Questions like these are best suited for Stack Overflow. We use GitHub for bug reports and feature requests.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  I respectfully disagree. If you are using the `.Custom` parameter encoding without parameters, you are misusing the API. There are many other ways to assemble an `NSURLRequest` to create your requests. The top level APIs already allow you to specify the HTTP Method, URL, parameters, parameter encoding and headers.

If these options are not sufficient, then you need to drop down a level and assemble your `NSURLRequest` manually before creating an Alamofire `Request`.

Cheers. üçª
  Thank you for putting this together @DavdRoman. We always appreciate updates from the community. 

With that said, I'm afraid we won't be adopting these changes into Alamofire. The main reason is complexity. There is no official RFC spec for any of the collection formatting. Our official Alamofire position is that we support one of the most commonly used formats when it comes to URL encoded collection formatting. If you need to customize the format in a different way, then you need to use a `.Custom` parameter encoding.

The main reason for this is to make it easy for the community to adopt, yet flexible enough to handle any use case. This is our philosophy when designing any of the Alamofire APIs. These changes make things more complicated without a high enough ROI to consider it a worthwhile change. Additionally, these changes are not in any way backwards compatible and would require a major version bump.

Thanks again. üçª
  I'm going to go ahead and close this issue out. Please see my comments in #966. Cheers. üçª
 Just to be clear, at no point did I claim that the PR was declined because "it's not commonly used". I declined it for other reasons which were very cleared documented. Additionally, I think you are assuming a bit too much here. At no point have we claimed we'll never support this feature. It's actually in our Trello backlog and has been for a while. I think I could have done a better job explaining that in my previous comment to avoid confusion...my bad there.

We completely understand there's a need for such a feature and want to support feature requests the best we possibly can. With that said, we have a very large community that we always need to consider when adding complexity into our APIs. This is definitely one of those features that we need to be careful how we introduce. 

Please be patient because there are many features here we are actively supporting. If you feel that you would like to see this feature added sooner than we will be able to, then by all means submit a complete, well thought out pull request. We'll be more than happy to consider it. But please understand that it is certainly in the community's best interest for us to decline PRs once in a while that aren't up to our standards or designed in a way that we deem suitable.
  Hi @yarneo,

We have many MANY tests around all possible Alamofire use cases. Without seeing some code, there is no way to pinpoint what exactly is going wrong. I have yet to see a stack trace reported by anyone else similar to this. I'd encourage you to open a question on Stack Overflow with code samples demonstrating how you are making requests. If you do end up finding an issue in Alamofire itself, please open a new issue or provide more detail on this issue and I'll be happy to re-open.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
 It appears that you are using SwiftyJSON to parse the response. You're unwrapping of the JSON data is completely unsafe and is most likely the cause of your issues. You should use optional binding or optional chaining to safely extract the JSON data, rather than assuming it is always there.

On a side note, the Alamofire names are mangled because of Swift, not because of Alamofire itself.

And finally, please use Stack Overflow in the future. By doing so, it let's others in the community help out with these types of support questions and let's us focus more on building new features and maintaining Alamofire itself.

Cheers.
  Hi @phatmann...thanks for putting this together. Unfortunately, that section of the README is only for promoting libraries officially supported by the [AlamofireSF](https://github.com/Alamofire/Foundation). We want to avoid promoting libraries in which we don't have any control over.

Thanks anyways! üçª
  Thanks for the PR @nvh. Unfortunately, I don't think this change is the correct way to go with the `responseJSON` serializer. The statement you made about the `response` method being hidden doesn't seem to be true. The following compiles without any issues on the `master` branch:

``` swift
Alamofire.request(.GET, "https://httpbin.org/get")
    .response(
        queue: dispatch_get_main_queue(),
        responseSerializer: Request.JSONResponseSerializer(),
        completionHandler: { response in
            print(response)
        }
)
```

If you need to use a custom queue, this is the recommended way to do it. This is also a great example of why the `ResponseSerializerType` protocol exists making it easy to swap serialization logic.

Thanks again! üçª
  Hi @lemarian,

These types of questions are better suited for Stack Overflow with an `alamofire` tag. We generally use GitHub for bug reports and feature requests.

Cheers. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Thanks for putting this together @jacobjennings...much appreciated! I made a few small formatting changes to your PR and pushed it up in 234568d4 still giving you attribution.

Thanks again! üçª
  I like it!
  Hi @AnthonyMDev, 

Thanks for putting this together...much appreciated! Overall I really like the goal of this change that you broke down nicely in your description. However, I think there's a MUCH easier approach. What about the following?

``` swift
public func encode(
    URLRequest: URLRequestConvertible,
    parameters: [String: AnyObject]?)
    -> (NSMutableURLRequest, NSError?)
{
    var mutableURLRequest = URLRequest.URLRequest

    guard let parameters = parameters where !parameters.isEmpty else { return (mutableURLRequest, nil) }

    var encodingError: NSError? = nil

    // etc. etc.
}          
```

That's probably what this method should have been doing all along. If your down with this approach, do you think you could rework this PR to handle the change this way while keeping the test as part of the PR?
 Thanks for putting this together @AnthonyMDev...much appreciated! I also pushed b0c6a9bf to fix up a failing custom parameter encoding test case. Normally I wouldn't modify a test like this so a change that did break the test suite could move though. However, when looking at the failing test, it wasn't really a good test. Therefore, I updated it.

Thanks again!
  Hi @jedlewison, thanks for putting this together! Unfortunately, we won't be merging these changes in. The project was definitely configured this way by design. We want to support Carthage as well as always have the project compile the test code with any code changes. It helps ensure we never introduce compiler issues in the test suite when fixing bugs or developing new features. I understand that this introduces a slight overhead when using Carthage to compile Alamofire, but IMO I'd always error on the side of stability here rather than Carthage performance.

Thanks again. üçª
 Okay, thanks for all this info @jedlewison. I'm going to re-open this and investigate further. I wasn't aware that flag prohibiting the compiler optimizations. It makes sense now that I'm thinking about it that way.

Thanks for pressing on us here. üëçüèº
 Okay @jedlewison, after digging in further, I think your change is overall the best course of action. The reason I've been so hesitant on this change is that it requires us to disable the Travis-CI builds for the release configuration. Apple doesn't allow you to have an optimized build with the `ENABLE_TESTABILITY` flag disabled and still use `@testable` in your test target.

While that's certainly a bummer, it's not a blocker. I ended up finding another workaround for this in 39ca953d. What I did was create a `ReleaseTest` configuration that is configured exactly like the `Release` configuration, except has the `ENABLE_TESTABILITY` flag enabled. Since Carthage defaults to the `Release` configuration, this should be a sufficient way to attack the problem. This allows us to run our test suite against the `ReleaseTest` configuration on Travis-CI, while still allowing all our Carthage users to optimize their Alamofire frameworks.

Thanks again for your due diligence here. Alamofire is certainly much better off for it!

Cheers. üçª
 That's awesome! Glad to hear it. üëçüèº
  Thanks for putting this together @ntnmrndn! I merged a slightly modified version of your changes in 9ef1602f. Thanks again! üçª
  Check the [README for version 1.3.1](https://github.com/Alamofire/Alamofire/tree/1.3.1#installation)

> Embedded frameworks require a minimum deployment target of iOS 8 or OS X Mavericks

It's not possible to use CocoaPods or Carthage to integrate Alamofire on iOS 7 since they use frameworks to integrate and thus require iOS 8 onwards.

Check the instructions at https://github.com/Alamofire/Alamofire/tree/1.3.1#source-file
  You can definitely do this in Alamofire. Check out the [source code](https://github.com/Alamofire/Alamofire/blob/master/Source/Manager.swift#L329-L330) for the override closures in the `SessionDelegate`. üëçüèº
  Thank you for your PR @sun-fox-cj!

Unfortunately, we think this is probably not the best change for the community. The `escape` method is intended only for escaping query parameter key value pairs. It is not for escaping other parts of a URL. If you find the need to customize the escaped characters, then you will need to use your own custom implementation. We have MANY tests around this functionality to ensure we're following the spec as closely as possible for everyone.

Thanks again. üçª
  You are looking for `response.data`. That will be all the original data returned by the server.

In the future, these types of questions should be opened as a question on Stack Overflow with an Alamofire tag. We use GitHub for bug reports and feature requests. 

Cheers. üçª
  This is not something that I think is a good addition to Alamofire. This is merging the validation and response serialization operations into a single one. Validation is intended to validate the response header data to ensure the response and status code match what you expect. The second step is to serialize the response data in whatever means necessary. There is a clear separation of concerns here in the current design.

More specifically, why are you trying to force JSON serialization up a level? Why can you not accomplish what you need with the current response serialization design?

I'm going to close this issue out...but I'm happy to continue the conversation. As with any issue, if something comes up that warrants re-opening, I'm always happy to do so.

Cheers. üçª
 Oh man that's a bummer. Makes more sense now why you were trying to do what you were doing. I think both your approach and the custom response serializer approach are valid approaches to solving the problem for your use case. But I don't think it's something that should live outside your very specific use case.
 @s0meone I'm dealing with the same issue you are: my backend returns 200 for (nearly) everything, meaning I have to parse JSON to find the actual response code and boolean fields to determine whether the request succeeded. I was able to do this using a custom response serializer. Given that I was writing one anyway to deal with generic object deserialization, adding the deserialization of the base response from JSON was no more difficult. You can see an example of this [here](https://gist.github.com/jshier/f08f08e05d994b5bdc7d).
 Awesome...thanks @jshier!
  Hi @abinop,

These types of questions are better suited for Stack Overflow. If you could open a question there with an `alamofire` tag and post a link back to this issue, that would be preferred. We use GitHub for bug reports and feature requests.

Cheers. üçª
 Apologies @abinop...I just [replied](http://stackoverflow.com/a/34193782/1342462) to your question. Cheers. üçª
  Okay, let me clear up some things here. @Neku, the `data` is available in the `response` object. Therefore, it is always available, if it was returned from the server, as `response.data`.

@tomekh7, you can absolutely use `responseJSON` with SwiftyJSON. You can initialize a `JSON` object from `NSData` or from an `AnyObject` that has already been parsed by `NSJSONSerialization`.

If the future, these types of questions should be opened as a question on Stack Overflow. We use GitHub for bug reports and feature request.

Cheers. üçª
  Not really sure why you opened this...either way, I'm going to close it out.
  Hi @AlexNikov,

Please see my comments on #876 on how to proceed. Once you get through those, if you could comment back on this issue with your findings, we can go from there. Apologies for commenting on the other issue, I didn't realize you had opened this one.
 Hi @AlexNikov, 

Sorry for the delay in getting back to you on this. I'm almost positive you're getting bit by ATS. The certificate you are trying to workaround is not valid due to a host mismatch. The certificate host is `meduzaradio.com` and does not contain the `instore` subdomain. What I believe you need to do here is update your exception domain to `meduzaradio.com` and then you should at least see your `ServerTrustPolicyManager` getting called. Then the following should kick in:

``` swift
let serverTrustPolicies: [String: ServerTrustPolicy] = ["instore.meduzaradio.com": .DisableEvaluation]
```

I'm going to go ahead and close this issue out since I think I've identified the root issue. If you post any info back on here to the contrary, I'd be more than happy to re-open and continue to investigate.

Cheers. üçª
 We'll certainly keep this in mind @Leshich. For now, I'd recommend you subclass the `ServerTrustPolicyManager` to customize the behavior exactly as shown above.

Cheers. üçª
  Customization on this level can be accomplished by creating your own custom response handler, as outlined in our documentation [here](https://github.com/alamofire/alamofire#response-serialization-1). Specifically, if you want to, say, log all errors and only handle valid responses:

``` swift
extension Request {
    func responseSimpleJSON(options options: NSJSONReadingOptions = .AllowFragments, completionHandler: AnyObject -> Void) -> Self {
        let fullCompletionHandler = { (response: Response<AnyObject, NSError>) in
            switch response.result {
            case let .Success(object):
                completionHandler(object)
            case let .Failure(error):
                debugPrint("\(self) failed: \((error as NSError).localizedDescription)")
            }
        }

        return response(responseSerializer: Request.JSONResponseSerializer(options: options), completionHandler: fullCompletionHandler)
    }
}
```

Which can be used like this:

``` swift
Alamofire.request(.GET, "https://httpbin.org/get")
    .responseSimpleJSON { object in
        print(object)
    }
```

I'm going to close this issue for now but feel free to reopen if you find this solution or the flexibility of the current response serializer architecture to limiting for what you want to accomplish.
  Hi @jacobjennings, thanks for all the info here...nice work. üëçüèº

I think you have a valid point and the `certificatesInBundle` and `publicKeysInBundle` should pick up `cer`, `crt` and `der` file extensions. As for failing silently, I disagree because you can check the number of returned certificates returned by the method. Now it may be a bit difficult to figure out which one was missing, but at least you would know one was.

Would you be willing to put together a PR that updates the behavior here along with a test or two verifying the functionality?
 Ping here @jacobjennings...would you be willing to help put this together?
 I'm going to close this issue out...please redirect all comments to #956.
  I'm going to assume you are using CocoaPods. The issue has been fixed by the CocoaPods team, but the fix has not yet been released. Please see https://github.com/Alamofire/Alamofire/issues/871 for more info.
  Answered on Stack Overflow. üëçüèº
  Alamofire is limited to the HTTP/2 support offered by the underlying iOS system frameworks, specifically `NSURLSession`. Unfortunately, at this time `NSURLSession` offers no exposed support for either `PUSH_PROMISE` or the HTTP/2 stream functionality. Only iOS 9, watchOS 2, tvOS (9), and OS X 10.11 offer any support for HTTP/2, and this functionality is implemented as an invisible layer for existing `NSURLSession` and CFNetworking clients.

As for whether Alamofire will reuse existing connections: as with HTTP/2 support, Alamofire is at the mercy of `NSURLSession`. Fortunately, in this case connections can be reused, at least in the case of HTTP/2 connections, since that is part of the protocol specification. On compatible OSes and connections, HTTP/2 will be used automatically, so you should see connection reuse. However, you should always test to ensure your server is compatible with the HTTP/2 implementation provided by the system frameworks, as no manual control is provided by the frameworks.

As to polling vs. push, if at all possible polling is to be avoided. Unless you need the lower latency of native HTTP/2 push, Alamofire can be combined with Apple's push notification service (APNS) to provide asynchronous support for long running tasks. In fact, APNS was recently converted to HTTP/2 itself, so it's entirely possible they're using some of its abilities in the new implementation. 

For more information about the system networking frameworks and their capabilities, Apple's WWDC sessions are especially helpful. See: [Networking with NSURLSession](https://developer.apple.com/videos/play/wwdc2015-711/) and [What's New in Notifications](https://developer.apple.com/videos/play/wwdc2015-720/).

I'm going to close this issue, as there's not a lot we can do here before Apple exposes the required APIs. If you have more questions regarding hybrid APNS/Alamofire architectures, feel free to ask on StackOverflow and tag Alamofire.
 @johndpope I'm not sure how that's relevant here. Alamofire wraps the underlying `URLSession` APIs, so users of either level of APIs will never see raw HTTP/2 requests, per design. 

@danielrhodes Looks like `URLSession` gained support for HTTP/2 push in Apple's latest OS releases. Support is automatic, so there's nothing to be done by Alamofire or even users of `URLSession` directly to gain support. It essentially acts like a cache preheat, where the pushed response is stored in the associated `URLCache` instance and then used as the response when a request is made for the pushed data.
  The problem @marathoner1234 is that your `master` repo is messed up, or is not able to pull properly since you probably have some unstaged changes in your repo. All you need to do is remove the `master` repo and set it up again.

``` bash
rm -rf ~/.cocoapods/repos/master
pod setup
```

That should get you back in business. üëçüèº
 Anytime man...glad to help! üôåüèº
  The Swift compiler has a tough time with the misuse of generic classes. You can fix the issue by adding the generic parameter conformance:

``` swift
class Foo {
    func bar(response: Alamofire.Response<AnyObject, NSError>) {
        // winning üëçüèº
    }
}
```
  The app doesn't crash, you're merely hitting the breakpoint you have set. It's rather common for those of Apple's frameworks that use C++ underneath to use exceptions in ways that Objective-C and Swift don't and so you may hit those exceptions with that breakpoint. That's why I usually run with the exception breakpoint set only for the language I care about. For Swift you can set the Swift error breakpoint in Xcode 7.1 and higher. 

I'm going to close this issue. Feel free to open another issue if you find a crash that can be traced to Alamofire's code. 

Also, thanks for the sample project. It made seeing this issue very easy. :+1: 
 Since Swift doesn't use exceptions (though the C++ that underlies much of its implementation might), you'd have to use the Swift error breakpoint like I said. That will break on any thrown error, including those wrapped from Objective-C `NSError`s. Whether that's actually useful to you is up to you to determine.
  @CapeFurSeal Can you post the string you tried to encode (redacted for any special information), the string you got after encoding, and the string you expected? It would make it much easier for us to diagnose your issue.
 We are simply RFC 3986 - [Section 2.1](https://tools.ietf.org/html/rfc3986#section-2.1) and [Section 3.4](https://tools.ietf.org/html/rfc3986#section-3.4). The `+` character should be encoded as `%2B` as demonstrated in our ParameterEncoding [tests](https://github.com/Alamofire/Alamofire/blob/master/Tests/ParameterEncodingTests.swift#L281-L290).
 I'm going to close this issue out @CapeFurSeal. If you end up finding an actual bug in the logic, please provide some additional information and we'll be happy to re-open. Cheers. üçª
 You bet! Glad you got it all figured out. üëçüèº
  I don't see anything obvious. Seems strange that you're getting a `-1005` here. You should try to first debug this by using `debugPrint(request)` after your `request.responseJSON()` call to generate the `curl` command. Then you can try to hit the service using `curl` to see if you see the same issue there. That at least would be a start.
 @codywinton I'm going to go ahead and close this issue out. If you continue running into issues, please open a question on Stack Overflow. We try to use GitHub for bug reports and feature requests. If you end up finding the issue is something inside Alamofire, please provide some additional info and I'll be happy to re-open the ticket.

Best of luck! üçª
 Looks like you're calling different APIs and you're using different HTTP methods. If the bottom cURL works, then you should just use the in your Alamofire code.
 Not sure off the top of my head since you are using `.JSON` parameter encoding. As I mentioned before, these types of questions are best suited for Stack Overflow. If you open a question there and post the link, we may be able to continue to help out there.

Cheers. üçª
  Agreed @toby78. This is an incredibly complicated feature to build, but I've just placed a card in our Trello backlog. Once the tech spike around this work starts up, I'll be sure to comment back on this issue.
  Hi @cesar-oyarzun-m,

I don't see anything obviously wrong. You should use the `debugPrint` functionality on `Request` to attempt to pin down what the issue is through `curl`. Most likely the `Request` isn't being sent correctly. Also, disabling evaluation won't help with the 401. That's only for disabling TLS evaluation.

On a different note, questions like these are best suited for StackOverflow. We use GitHub for bug reports and feature requests. If you could open a question there and post the link to that question back in this issue, that would be appreciated.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  You cannot modify the `Request`after it has been resumed. With that said, don't cry...there's still a way. üòâ

Once the `Request` has been resumed, you need to let it fail, then rebuild it with the new access token and resend it. You also need to make sure to keep the closure around so you can execute it after the second request completes. You also need to make sure you don't call the closure twice.

I've actually built an OAuth2 library for my company ontop of Alamofire that does exactly this. While that library cannot be open sourced, I've detailed the overall solution in this [thread](http://stackoverflow.com/questions/28733256/alamofire-how-to-handle-errors-globally) on StackOverflow. Hopefully that helps get you going.

Best of luck! üçª
 First off, there's no quick solution to handling the OAuth2 race conditions. It is a very tricky problem to solve that I've tackled more than once.

With that said, you could add your own extension to an `NSURLSessionTask` if you need to store some additional info on it. There's nothing stopping you from doing this since Alamofire exposes all that logic publicly. As for those two properties being read-only, that not an Alamofire decision, that was Apple's.

If you end up finding a solution that works really well for you and think it might be a good addition to Alamofire, please submit a PR and we'll gladly check it out!
  Most likely the result of `host + requestURL` is not a valid URL, causing the unwrapping to crash. Please ensure you're passing a valid URL.
 I'm going to close this for now, let us know if fixing the backslashes and quotes doesn't fix the issue.
 Hi @YilunLiu, you need to use parameter encoding to properly escape the query string parameters instead of building the query string yourself. This is exactly why the entire `ParameterEncoding` enumeration exists. This is NOT a problem with Alamofire, you are misusing an `NSURL`.
  Alamofire does not support multi-platform frameworks to allow it to work seamlessly with CocoaPods AND Carthage with the same Xcode project. If you are attempting to make a new podspec that attempts to create a multi-platform framework and are having issues, please open an issue with the CocoaPods project. You'll receive much better assistance there.
  Unfortunately we're going to need more information before being able to offer an assistance. First of all, what versions of Alamofire and Xcode are you using? How are you making the call to Alamofire? Can you post some of your code? It should be farther down in your stack trace.
 Is any part of `http + domain + path` dynamic or provided by the user? You mentioned Saudi Arabia; is it possible for the user to input, say, Arabic characters that are used in the URL? 2.0.2 does force unwrap the `NSURL` it expects from your request string, which is really the only thing I can see causing a crash in that section of code. I suppose it could fail if invalid characters are entered. Is it possible for you to validate the string you make the request with beforehand?

That being said, it's always a good idea to keep up to date with the latest Alamofire version, as there will be no bug fix 2.0.x releases. If this does turn out to be an issue with Alamofire, it would only be fixed in the latest version, so an update would be necessary on your part anyway.
 Sounds good. I'm closing this for now but feel free to open a new issue if you continue to see crashes on 3.x after you validate your URL input.
  Hi @kohdesmond,

As you have already pointed out, this question is much better suited for Stack Overflow. We use GitHub for bug reports and feature requests. If you open a question and post the link here, someone from our team may be able to help you debug your issue.

> Also, you will certainly be able to attract more help by formatting your code nicely. Much easier to dig through.

Best of luck! üçª
 Glad you figured it out @kohdesmond. Could you elaborate on why ATS was putting you in an endless redirect scenario? Your explanation could possibly help someone else out there that finds this thread. üëçüèº
  Handling whether to display the activity indicator is much more complicated than this solution supports. This implementation will result in all sorts of flickering of the activity indicator which is not what you want. We already have a card for this feature in our Trello backlog as a result of #670. This is certainly high on our priority list, but we want to make sure we do this properly before rolling it out.
  Hi @lorenzoferrante,

Questions like this are best suited for Stack Overflow. We use GitHub for bug reports and feature requests. Best of luck. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  I would recommend you both use the `debugPrint` functionality on the `Request` to help you figure out your issue through `cURL`.

``` swift
let request = Alamofire.request(.GET, "URLString")
    .responseString { response in
        debugPrint(response)
    }

debugPrint(request)
```

Then debug the issue through `cURL` to see if you can track down the problem easier. Most likely the issue is not Alamofire, but how you are making the request.
 I'm going to close this issue out for now. If either of you provide any other information that leads us to believe there is an actual issue with Alamofire, we'll happily re-open the issue.
  Hi @aryaxt,

This doesn't look like Alamofire activity to me. The call stack starts off with an `NSURLConnection` call and then many very low level calls in CFNetwork. I really doubt any of these calls are actually coming from Alamofire. I'd recommend you dig through the rest of your dependencies and try to figure out which ones could be making these calls. Something like Charles Proxy could also help you track down the network traffic.

Best of luck. üçª
  Any chance you could provide a sample project that demonstrates this?
 Additionally, how did you install Alamofire and which version did you install?
 Please try to wipe your DerivedData and Xcode cache and try it again. We cannot reproduce this issue. If you end up not being able to fix the issue, please provide more info and possibly a sample project and I'll happily re-open the issue.
  We've merged an alternate plist in #913 which should fix the issue for those installing Alamofire using submodules or Carthage. For those using CocoaPods, it will require a new release of CocoaPods. It appears they have already fixed the root issue in [CocoaPods #4539](https://github.com/CocoaPods/CocoaPods/pull/4539/files).
  From what I can see here, it looks like the Swift standard library is leaking the structure it uses to check the OS version when we use `if #available` in `encode`. Can you post the project you used to reduce this issue? It would allow us to replicate it more easily and confirm my suspicions. 
 Okay @jshier, I put together a small sample app that demonstrates the leak. Unfortunately I'm having major issues with `Leaks` where I cannot see anything other than the symbol addresses on iOS 8.3. I'm definitely able to repo the leak, but I cannot tell what the leak actually is the same way that @mruvim has demonstrated. I'm wondering if you could pick this up from here? I've pushed up a small sample project making it easy to debug.
- https://github.com/cnoon/AlamofireLeakage

I'm almost certain there's a leak in the availability checks which means we just need to file a radar. But without being able to dig into this any further, I'd hesitate to file the radar myself.
 @cnoon I've attempted to replicate the leak using multiple version of Xcode and I'm suffering from the same missing symbol issue you are. Leaks may be broken on El Capitan, because the Time instrument works fine.

In any event I think it's fine to report the issue to Apple, as any memory leak in Swift is a compiler or system library issue, and there are more than just this leak visible when you run the demo app. However, they probably won't fix the issue as it doesn't affect iOS 9.1. I'm sure a radar with with a link to this issue and the demo project would be appreciated though.

@mruvim It seems unlikely we'll be able to fix this issue directly or through a workaround, as the platform check is necessary to work around another framework bug, as noted in the code comment. We could drop the platform check and use the workaround code on all platforms but that would lead to an unacceptable performance regression on all platforms.
 Thanks everyone for the help here. I just opened [rdar://23689364](https://openradar.appspot.com/radar?id=4980581951602688) which hopefully will bring this to Apple's attention. I'm going to go ahead and close this out @mruvim. Thanks again for reporting. üçª
  Hi @mikewalkerjr,

Questions like this are best suited for Stack Overflow with an `alamofire` tag. We use GitHub for bug reports and feature requests. If you do end up submitting a question on Stack Overflow, please post the link back to this thread and I'm sure someone will be able to help you out.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Thanks for this @simonbs!
  Thanks @tmnb
  Man I don't think there's anything we can do on that one. The only option I see is to file a rdar which you already have done. Cheers. üçª
  You should convert your `useCredit` parameter to an `Int` before placing it into your `params` dictionary.

Questions like this are better suited for Stack Overflow. In the future, if you could ask your questions there, that would be great! We use GitHub for bug reports and feature requests.

Cheers üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Nope, see [RFC 3986 - Section 3.4](https://tools.ietf.org/html/rfc3986#section-3.4). It is recommended that both the `?` and `/` are not percent escaped in query string parameters. Below is our actual percent escaping logic for `.URL` encoding with additional documentation.

``` swift
/**
    Returns a percent-escaped string following RFC 3986 for a query string key or value.

    RFC 3986 states that the following characters are "reserved" characters.

    - General Delimiters: ":", "#", "[", "]", "@", "?", "/"
    - Sub-Delimiters: "!", "$", "&", "'", "(", ")", "*", "+", ",", ";", "="

    In RFC 3986 - Section 3.4, it states that the "?" and "/" characters should not be escaped to allow
    query strings to include a URL. Therefore, all "reserved" characters with the exception of "?" and "/"
    should be percent-escaped in the query string.

    - parameter string: The string to be percent-escaped.

    - returns: The percent-escaped string.
*/
public func escape(string: String) -> String {
    let generalDelimitersToEncode = ":#[]@" // does not include "?" or "/" due to RFC 3986 - Section 3.4
    let subDelimitersToEncode = "!$&'()*+,;="

    let allowedCharacterSet = NSCharacterSet.URLQueryAllowedCharacterSet().mutableCopy() as! NSMutableCharacterSet
    allowedCharacterSet.removeCharactersInString(generalDelimitersToEncode + subDelimitersToEncode)

    var escaped = ""

    //==========================================================================================================
    //
    //  Batching is required for escaping due to an internal bug in iOS 8.1 and 8.2. Encoding more than a few
    //  hundred Chinense characters causes various malloc error crashes. To avoid this issue until iOS 8 is no
    //  longer supported, batching MUST be used for encoding. This introduces roughly a 20% overhead. For more
    //  info, please refer to:
    //
    //      - https://github.com/Alamofire/Alamofire/issues/206
    //
    //==========================================================================================================

    if #available(iOS 8.3, OSX 10.10, *) {
        escaped = string.stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacterSet) ?? string
    } else {
        let batchSize = 50
        var index = string.startIndex

        while index != string.endIndex {
            let startIndex = index
            let endIndex = index.advancedBy(batchSize, limit: string.endIndex)
            let range = Range(start: startIndex, end: endIndex)

            let substring = string.substringWithRange(range)

            escaped += substring.stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacterSet) ?? substring

            index = endIndex
        }
    }

    return escaped
}
```
  It's a bit tricky if you use the `suggestedDownloadDestination` method. 

If you use the `suggestedDownloadDestination` method to retrieve the `destination` closure, you'll need to pass the `response` to the `destination` closure in your `response` closure to figure out where the file was moved.

``` swift
let destination = Alamofire.Request.suggestedDownloadDestination(
    directory: .CachesDirectory,
    domain: .UserDomainMask
)

Alamofire.download(.GET, "http://www.adobe.com/devnet/acrobat/pdfs/pdf_open_parameters.pdf", destination: destination)
    .progress { bytesRead, totalBytesRead, totalBytesExpectedToRead in
        print(totalBytesRead)
    }
    .response { request, response, _, error in
        print(response)
        print("fileURL: \(destination(NSURL(string: "")!, response))")
}
```

This should always give you the right value, as long as your `directory` and `domain` are valid on iOS. If not, you'll get the temporary location which is actually accurate as well. If you truly want full control over where the file is moved to, don't use the `suggestedDownloadDestination` method and use your own custom `destination` closure that returns the fileURL you want.
 The downloaded file path isn't going to be in the header. You need to load the data using the `NSData` initializer to load the contents of `fileURL`. Then you'll be in business.
 The file isn't moved into the temp location @chlebta, that's where the data is written while the download is in progress. Once completed, it will attempt to move the new file to the location provided in the `destination` closure. You need to make sure your folder structure is in place before attempting to move the temp file to it's final location.
  Most likely parameter encoding is failing when trying to encode the JSON in the HTTP body of the URL request.

I would suggest taking this question to Stack Overflow. We use the GitHub project for reporting bugs and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  I just created a new Swift project and added Alamofire 3.1.1 using CocoaPods 0.39.0 and Xcode 7.1. Everything works properly. I'm going to close out. In the future, I'd encourage you to take these types of questions to Stack Overflow.
  Thanks for putting this together @cotsog! This has been a really tricky problem for us to track down. I can see how this solution would in fact fix the problem. The one caveat that I would like to point out is that this solution is NOT thread-safe. Anywhere where this solution is used, we need to make sure the async callback is executing on the main thread. Otherwise, we can run into a race condition where the callback is trying to call the expectation while the time is expiring.
 Okay so I ended up unwinding the merge and squashing the commits into e4320bd5. Thanks again for putting this together!
  Thanks for this @JRHeaton! I merged a slightly modified version of your changes in cbac897b and also put together 2159ce3c for `watchOS` and `tvOS`. Both are available in `master`.
  Hi @EslamAbo,

We use Stack Overflow for general usage questions and GitHub for bugs and feature requests. If you could open an issue on Stack Overflow with an `alamofire` tag, that would be preferred.

Good luck!

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  First, I'd suggest updating directly to the latest version, 3.1.0. 

Second,if you take a look at the [download documentation](https://github.com/Alamofire/Alamofire/blob/master/README.md#downloading) you'll see that the destination closure has a different signature than what you're attempting. Specifically it take two parameters and requires you to return an `NSURL`. Once you meet those requirements you should build just fine.
  Alamofire doesn't have any built in SOAP or XML support, so you'd have to write your own. Fortunately it's straightforward to [create a custom response serializer](https://github.com/Alamofire/Alamofire/blob/master/README.md#response-serialization-1), but the XML parsing is up to you.

As for the parameters, take a look at the [documentation](https://github.com/Alamofire/Alamofire/blob/master/README.md#parameters) and see which of the built in encoding match your use case. 
  If you don't want to serialise the request parameters as a JSON body, why are you setting the encoding parameters to `ParameterEncoding.JSON`? Surely you just want to leave this at it's default value of `.URL` to URL encode these parameters?
 JSON encoded data needs to be set in the HTTP body. You cannot pass JSON data in the query string.

> You technically can as `.URL` encoded value data, but that's besides the point here.

In the future, please open a question on Stack Overflow and tag `alamofire`. We use GitHub for bug reports and feature requests.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Thanks for the PR @paulthorsteinson. Rather than merging this in, I removed the playground completely in 7582758d due to instability reasons. Thanks again.
  You aren't validating the response status code, so it is possible that a 404 will return you a `.Success` case. All that the `responseData` serializer does is validate that there wasn't an error (which there won't be since you aren't validating the response status code) or that the data exists.

``` swift
public static func dataResponseSerializer() -> ResponseSerializer<NSData, NSError> {
    return ResponseSerializer { _, _, data, error in
        guard error == nil else { return .Failure(error!) }

        guard let validData = data where validData.length > 0 else {
            let failureReason = "Data could not be serialized. Input data was nil or zero length."
            let error = Error.errorWithCode(.DataSerializationFailed, failureReason: failureReason)
            return .Failure(error)
        }

        return .Success(validData)
    }
}
```

In your case, you are receiving a 404 which isn't throwing an error, and the server is returning data. Therefore, your `responseData` serializer succeeds. If you expect a 404 to always throw an error, you should additionally use the `.validate(statusCode: [200])` method before the `responseData` serializer. More info in the [Validation Section](https://github.com/Alamofire/Alamofire#validation) of the README.

In the future, questions like this are better suited for Stack Overflow with an `alamofire` tag. We use GitHub for bugs and feature requests. üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  This is quite clearly a CocoaPods issue. I suggest you try running the command suggested to update the master repo and consult with the CocoaPods project if you aren't able to get that working. 
 You may want to just delete the `master` repo @zuil7 in ~/.cocoapods/master and then run `pod setup` and possibly `pod repo update master`.
  You won't be able to refresh the headers before `.responseArray` is executed. You'll instead need to start the refresh request, then re-execute your original request after the refresh has succeeded.

In the future, this type of general usage question is better suited for Stack Overflow with an `alamofire` tag. We use GitHub for bugs and feature requests.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Thanks for this @3lvis! I've just pushed up a new branch that removes the code necessary to work around the core issue that was filed in that radar in 563dc0d0ab6610e46c9c5f1ae2b40cb08f10d7fe. Once the Travis-CI tests are all verified to pass, I'll merge this PR into master as well as 563dc0d0ab6610e46c9c5f1ae2b40cb08f10d7fe.
 Alright, everything looks good. Thanks again man!
  We've been tracking this closely in our Trello project. Alamofire could greatly benefit from better 204 support. Therefore, we've been discussing the options in how to actually handle this. This PR puts forward the most sensible, non-invasive support for this behavior IMO.

The only other thing I question about this approach is whether we should require validation on the 204 as an acceptable status code before allowing this check in the response serializers. That would better help identify intent. I also hate to require that though as I feel it is a bit heavy handed.

I'm very interested to get everyone else's thoughts on this change. Anyone out there that has had to work through a 204 use case, please get your feedback in now!
 cc @jshier, @kcharwood, @kylef 
 That's exactly right @damienrambout. These changes have a big set of tradeoffs. I'm not a huge fan of having to return the `NSData()` and `NSNull()` objects either, but that's the only option without making MAJOR changes to the other underlying types.
  TONs of info in [Carthage #859](https://github.com/Carthage/Carthage/issues/859) to help you solve your validation issues. This is not actually an issue with Alamofire itself. Carthage and Xcode 7.1 have some major challenges that are very well detailed in that issue.
 Ah bummer. Well I'd suggest starting with an issue on the Carthage project. If it does end up being some type of issue with the Alamofire project settings, please provide more info with a link to the Carthage ticket and I'll be happy to re-open this issue or investigate the new one if you go that route.
  Thanks!
  You would need to create your own `response` serializer if you would like this behavior. You could certainly use the `responseJSON` serializer for now, but you'd need to handle the `.Failure` case and parse the server data using `NSJSONSerialization`.

All the default response serializers are written in a manner that when any error occurs, the serializers will not run their serialization logic. This is certainly the most common case which is why they are written in that manner. When deviating from this logic, it's quite easy to create your own custom response serializer tailored to your use case.
  It's never too much of a nitpick @Nirma! Always always always submit a PR or open an issue with a question if you notice anything that could be improved. Thank you for doing so! 

I'm fairly certain these have not already been changed because this didn't used to work in Swift 1.2. Somewhere along the Swift 2.0 or 2.1 releases the Foundation extensions on String from NSString were implemented properly. Either way, this is a great change. Thanks for putting it together!

Cheers üçª
  Hi @sourcebit,

This means your `URLString` is invalid. Using the `URLStringConvertible` protocol requires your `URLString` to conform to the RFC 1738 and 1808 specs.

``` swift
/**
    Types adopting the `URLStringConvertible` protocol can be used to construct URL strings, which are then used to 
    construct URL requests.
*/
public protocol URLStringConvertible {
    /**
        A URL that conforms to RFC 2396.

        Methods accepting a `URLStringConvertible` type parameter parse it according to RFCs 1738 and 1808.

        See https://tools.ietf.org/html/rfc2396
        See https://tools.ietf.org/html/rfc1738
        See https://tools.ietf.org/html/rfc1808
    */
    var URLString: String { get }
}
```

Your query string doesn't look like it was formed correctly which means you most likely didn't use the `ParameterEncoding.URL` encoding type which will handle this all for you correctly.
  Hi @omkar0001,

Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

Best of luck!
 Hi @omkar0001,

I promise you that's the best way to ensure no one ever helps you. Our team works very hard to provide the highest quality libraries we possibly can. Additionally, everyone on our team does this purely on their own time. In order to help us focus on the library and less on support, we direct support questions to Stack Overflow since there are more people there to help answer support types of questions. This allows us to focus on Alamofire, and less on your individual problem of parsing JSON. Comparing our small team's approach to corporate giant of Microsoft is simply an idiotic comparison and is certainly not appreciated.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Could you try running the `iOS Example` project in the Alamofire workspace under the same conditions to see if you run into the same problem? I just ran the example with the exact setup that you mentioned and everything works exactly as expected. I'm curious if you see the same crash in that example app.

Additionally, as @AndrewBarba mentioned, any source code or sample project you could post would be VERY helpful.
 Hey that's awesome! üéâ Glad you got things figured out @slynglen.
  Closed as a duplicate of #878, please search existing issues before opening new ones in the future.
  Need more info here @istvanelekes. 
- How did you install it? 
- What version or commit hash are you building against? 
- Are you using Xcode 7.1 or one of the betas?
 Thanks @ikesyo!
  Hi @vigyanhoon,

Please check out Stack Overflow before opening an issue with Alamofire. There are MANY questions that have already been answered on this topic.
- https://stackoverflow.com/questions/33169739/how-to-set-different-expiration-timeout-for-each-nsurlrequest
- https://stackoverflow.com/questions/27135735/setting-client-side-timeout-per-request-with-alamofire-swift/27259082#27259082
- https://stackoverflow.com/questions/31095070/alamofire-does-not-respect-timeout-interval

Best of luck!
  You should just need to include the port number:

``` swift
let serverTrustPolicies: [String: ServerTrustPolicy] = [
    "localhost:3000": .DisableEvaluation
]
```

If that doesn't work, please add more detail and I'll gladly re-open the issue. üëçüèº
 Could you provide your full curl command? Additionally, would it be possible for us to be able to hit the server to try and debug the issue? I'm wondering if there's some additional challenge we're running into with self-signed certificates.
 Thank you for providing all that info and setting up the test server @iMoritz. So much easier to debug the problem on our end. I was able to get to the bottom of your issue. The following test case successfully makes a request to your test server using Alamofire.

``` swift
func testSelfSignedCertificate() {
    // Given
    let manager: Alamofire.Manager = {
        let serverTrustPolicies: [String: ServerTrustPolicy] = [
            "api.moritzsternemann.de": .DisableEvaluation
        ]

        let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
        configuration.HTTPAdditionalHeaders = Alamofire.Manager.defaultHTTPHeaders

        return Alamofire.Manager(
            configuration: configuration,
            serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies)
        )
    }()

    let expectation = expectationWithDescription("request should succeed")

    var request: NSURLRequest?
    var response: NSHTTPURLResponse?
    var data: NSData?
    var error: NSError?

    // When
    manager.request(.GET, "https://api.moritzsternemann.de:3000")
        .response { responseRequest, responseResponse, responseData, responseError in
            request = responseRequest
            response = responseResponse
            data = responseData
            error = responseError

            expectation.fulfill()
        }

    waitForExpectationsWithTimeout(defaultTimeout, handler: nil)

    // Then
    XCTAssertNotNil(request, "request should not be nil")
    XCTAssertNotNil(response, "response should not be nil")
    XCTAssertNotNil(data, "data should not be nil")
    XCTAssertNil(error, "error should not be nil")
    XCTAssertEqual(response?.statusCode, 200, "response status code should be 200")
}
```

I was incorrect when I said that the server trust policy should include the port number. It appears with this URL, the challenge host does not include the port number. If you add this test into the Alamofire test suite or into your own test suite, you'll see that it passes successfully.

```
Test Suite 'Selected tests' started at 2015-10-25 12:57:12.588
Test Suite 'BaseTestCase' started at 2015-10-25 12:57:12.589
Test Case '-[Alamofire_iOS_Tests.BaseTestCase testSelfSignedCertificate]' started.
Test Case '-[Alamofire_iOS_Tests.BaseTestCase testSelfSignedCertificate]' passed (0.460 seconds).
Test Suite 'BaseTestCase' passed at 2015-10-25 12:57:13.050.
     Executed 1 test, with 0 failures (0 unexpected) in 0.460 (0.461) seconds
Test Suite 'Selected tests' passed at 2015-10-25 12:57:13.050.
     Executed 1 test, with 0 failures (0 unexpected) in 0.460 (0.462) seconds
```

The key to figuring out what is going on is to add a breakpoint to the `ServerTrustPolicyManager.serverTrustPolicyForHost(:)` method. That will allow you to see what the `host` is associated with the challenge. There are several other ways to debug this, but that is certainly the easiest.

Hopefully this issue will help others in a similar position. Thanks again for all the info to help us debug! üçª
 Roger...I'll investigate further @iMoritz! Re-opening.
 Thanks for all the awesome feedback here. I definitely want to make sure all this is working properly. üëçüèº
 Thanks for all the info here @iMoritz and @4np. It may take me a couple of days before I can dig into this problem deeply just as a heads up.
 Okay, so this was a tricky one to figure out. Long story short, you are both being bit by ATS and need to configure it just right to allow the challenge APIs to be called. Here's an example of the ATS settings you need:

![ats settings](https://cloud.githubusercontent.com/assets/169110/10866234/33411c3e-7fe3-11e5-846a-c4e1fa1a0456.png)

Now I'll dig in here a bit more to try and share what I was able to find out. First off, I can't believe the awful lack of documentation around ATS from Apple. Their original ATS technote has been completely pulled offline. If anyone can find a valid link to the actual Apple docs, PLEASE PROVIDE A LINK!

With that said, I was able to piece this together from a few different links. First off, you should read [this](http://cutecoder.org/programming/server-ready-ios-9-el-capitan/) entire article. Most of the info you need is in there. This walks through the basics of `NSExceptionRequiresForwardSecrecy` and `NSExceptionAllowsInsecureHTTPLoads` but doesn't explain them very well at all. I was able to find a bit more info about the cipher relaxation of `NSExceptionRequiresForwardSecrecy` [here](https://forums.developer.apple.com/thread/13472).

From what I can tell, your server must not be using a valid cipher suite, because the request automatically errors out without the `NSExceptionRequiresForwardSecrecy` flag set to `NO`. Additionally, it appears that the `NSExceptionAllowsInsecureHTTPLoads` is a flag to override the entire challenge callback system. If you don't set it to `YES`, your challenge will NEVER be called.

Once you get these settings set correctly, then the challenges are called and you can debug whether your server trust policy objects are set up correctly.

I'll be updating the README shortly with this information to make it easier for people to work with self-signed certificates in the future.

Thanks everyone for helping figure this out! üçª
 Just want to point out, on El Capitan machines you can use `nscurl` command to attempt to diagnose ATS issues.
`nscurl --ats-diagnostics https://api.moritzsternemann.de:3000`
However, in this instance it wouldn't have helped at all since all of the scenarios it tests for succeed, so it really gives you nothing to go on. 
 Added ATS section to the README in 55cfc16b.
 Hi @AlexNikov,

Set a breakpoint in the `serverTrustPolicyForHost` method in the `ServerTrustPolicyManager` class to see if it's getting called. If it is, then you have ATS most likely configured correctly. If it's not getting called, then your ATS configuration is still not correct.

If it is getting called, then check to make sure your `host` matches yours exactly. If you still can't get to the bottom of the issue after verifying all this, please open a separate issue with enough info for us to continue to debug the problem. Also please read through all the very detailed info in this post. There's a ton of good info here to help you solve the problem.

Cheers.
 Couldn't agree more @4np! üéâ
 That should not actually be true @Link-. You should certainly be able to disable evaluation without having to mark the self-signed cert as a trusted cert. Can anyone else out there confirm this? We have many tests verifying this behavior, but none that deal with ATS at an app level.
 I would NEVER recommend doing the above in production @tvich1! For everyone thinking this is a good solution, I can't stress enough that you should never actually do this. Instead, use something like [Let's Encrypt](https://letsencrypt.org) to generate a valid cert.
 Ah. So your `Manager` instance was being deallocated in the middle of the inflight request @emilynswanson?
 Hi @tejasverixo, make sure you're `defaultManager` instance is not being released. Other than that, please file a question on Stack Overflow. We use our GitHub project for bug reports and feature requests.  There's a `tvOS` branch up at the moment. We'll be cutting a 3.1.0 release with full `tvOS` support most likely this evening.
  Hi @dashugege,

This type of question is best suited for [Stack Overflow](https://stackoverflow.com) with an `Alamofire` tag per our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md). The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

Best of luck!
  It does not directly. You will need to create your own SOAP interface around Alamofire.
  Thanks for your detailed write up @drichardson. Hopefully this helps someone else fighting a similar issue.

I'm a bit confused though as to whether you're asking a question, or just reporting behavior. The use case you detailed behaves exactly the way I would expect it to. For a default session configuration, the request should fail eventually since you aren't using a background session configuration. If you expect the request to complete successfully even when being backgrounded, then you need to switch over to using a background configuration.

Your proposed solution to the problem doesn't actually solve the connection closed error from occurring, it simply buries it from being reported by deallocating the original URL session and replacing it with a new one. Therefore, I'm not really sure what else to say. IMO, this is behaving exactly as expected.
 Yeah in this case you'll need to reload your table view cell or reload the `UIImageView`. There's not really anyway around it at the Alamofire or AlamofireImage level. Best of luck!
  How did you add Alamofire to your project? Did you use CocoaPods, Carthage or manual installation by downloading the source and adding the Alamofire Xcode project as a dependency to your project?
 Yeah I don't really know if there's a workaround for this particular issue. The availability methods are a bit annoying in this respect. The problem is that they need to be included in the project to get everything to compile with a deployment target of iOS 8.0. When you install using CocoaPods with a deployment target of 9.0, the availability methods will trip the warning.

I'll think on this some more and possibly file a radar. If anyone has any suggestions in the community on a way to get around this while maintaining an iOS 8 deployment target, I'm all ears!
 cc @kylef to see if there's any magic he knows of to workaround this problem.
 I don't know of the top of my head.

@sendoa I'd suggest filing a bug on CocoaPod's if there ware warnings that are not being inhabited by `inhibit_all_warnings!`. There might be something we can do, but this may be an Apple bug and may need to be raised further upstream as a radar if the bug lies with Apple.
 Thanks for the feedback @kylef. I assumed this was actually an Apple bug and we'd need to file a radar. This will make the 3rd or 4th radar I've filed around availability so I'm not surprised. Once I get it filed, I'll post the link to Open Radar and close this issue out.
 Thank you for filing [CocoaPods #4423](https://github.com/CocoaPods/CocoaPods/issues/4423) @sendoa. I've added additional comments about a [sample project](https://github.com/cnoon/AvailabilityWarningRadar) I created to demonstrate the problem. Hopefully we can get this issue resolved for all Pod libraries. 

Given that this is not actually an issue with Alamofire that we can solve, I'm going to close this issue out. I will update this issue periodically as we learn more about 4423.
 On second thought, I think I'll leave this one open until we get a confirmation from the CocoaPods team as to how they want to proceed.
 Yes, and for tracking purposes there is a PR at https://github.com/CocoaPods/CocoaPods/pull/4320 which would solve this.
 Awesome! Thanks @segiddins.
 Yep, that change is not part of CocoaPods 0.39.0. It will be available in the next pre-release.
 @pavankataria The next pre-release of CocoaPods, as this is a CocoaPods bug not Alamofire. CocoaPods 1.0.0.beta.1 contains the fix and can be installed via:

``` shell
$ gem install cocoapods -v 1.0.0.beta.1
```
  Thanks @ay8s.
  Hi @tomvlk, would you be able to submit us a sample project that exposes the issue? I can't think of any reason why you would see this behavior. Is the request timing out?
  @rephiscorth That specific test case is to ensure that the JSON (or any data) serialiser raises an error when the data is nil since we we're expecting JSON body (or data).

If you're not expecting a body you shouldn't be using the JSON serialiser.

You should instead use the `response` method instead of `responseJSON` when you're not looking for JSON.

``` swift
Alamofire.request(.GET, "http://httpbin.org/get", parameters: ["foo": "bar"])
         .response { request, response, data, error in
             print(request)
             print(response)
             print(data)
             print(error)
          }
```
 Thanks @kylef.
 Thanks for your detailed feedback here @dilizarov and @damienrambout!

I understand where you are coming from, but what you are saying @dilizarov is not entirely true. The `responseJSON` serializer has ALWAYS thrown an error when the data returned from the server is empty. How the error is thrown has changed a bit, but even the original version would throw the `No Value` error from `NSJSONSerialization` when trying to deserialize the empty server data. Now we have some additional checks prior to running `NSJSONSerialization`, but the end result is still the same.

With that said, I don't think there's a way to cleanly handle this behavior without creating a custom response serializer. Trying to handle this use case in the common `responseJSON` serializer will just make the complexity too difficult understand for the general user. You need a serializer that first checks for the 204 response code. If it is a 204, return a Success result (probably with a `Void` type). If it is not a 204, run JSON parsing over the server data and extract out the custom error message. This is VERY different behavior than the current `responseJSON` implementation which is why I would encourage you to roll your own solution here.

Another way to do this without creating a custom response serializer would be to use the status code validation logic in conjunction with the `response` serializer. If the error comes back as a validation error, then run the JSON serialization over the server data if it exists and extract the exact error message.

To reiterate, the `responseJSON` serializer is not a solution for anything JSON. It's simply for the VERY common case that you know an API will return JSON in the event that the request is successful.
 @dilizarov and @damienrambout, after much internal debate, we've decided it would be best to add better support for the 204 use case. Please check out #889 if you get a chance. This is our first stab at proper 204 support directly in the response serializers.
  This is a known CocoaPods issue when trying to archive watch apps. See CocoaPods issues [4178](https://github.com/CocoaPods/CocoaPods/issues/4178) and [4369](https://github.com/CocoaPods/CocoaPods/issues/4369). If you continue to have issues, please raise an issue with CocoaPods.
  You need to delete the file first before you re-download it. The [moveItemAtURL(:toURL:)](https://github.com/Alamofire/Alamofire/blob/master/Source/Download.swift#L200) is failing.
  Hi @bkawakami,

Github is for reporting issues and new feature requests. Questions like these belong on [Stack Overflow](https://stackoverflow.com) with an `Alamofire` tag.

Cheers.
  The reason it is not exposed is that we didn't think there should ever be a need to specify your own value. The current implementation follows the RFC specs which are a bit vague. Could you shed some more light on what the server is doing so we can better understand the use case? Opening this up is something I'd rather avoid unless there is a valid reason to do so.
 Hi @FrankJaeger, I'm going to close this PR for now. If you end up posting a valid case for making this change, I may re-open and merge. Cheers.
  Could you post your code you are calling that is tripping this crash? There's not enough info here yet to diagnose the issue.
 Could you post a sample project that can demonstrate this? It's very difficult to diagnose this type of crash through screenshots. A sample project or test that can demonstrate the behavior would be VERY useful.
 Hi @CodeEagle, I'm going to close this issue out for now. If you post a sample project or an actual code sample that we can run to help debug, I'll be happy to re-open.
  This is all documented in the README [examples](https://github.com/Alamofire/Alamofire#uploading-multipartformdata). You need to grab the `upload` object out of the encoding result to chain.
  Thanks @cristeahub!

@mirzadelic In addition to the documentation linked by @cristeahub, see the [3.0 migration guide](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%203.0%20Migration%20Guide.md).
  Hi @kalyansriram,

Github is for reporting issues and new feature requests. Questions like these belong on [Stack Overflow](https://stackoverflow.com) with an `Alamofire` tag.

Cheers.
  There could be a few reasons from your example, why I think you may be seeing this:
- Your example may be inaccurate since you are blocking the main thread which could cause any other tasks to block and stay in memory.
- You are performing a new request every 0.1 seconds, which may be quicker than it takes to handle the responses. If this is the case, new requests will be happening and as time goes on, the amount of requests happening at any time will be more and more.

We can alter your example to no longer block the main thread, and instead dispatch from the main thread after a delay which is a little higher allowing the request to finish. For example:

``` swift
class AppDelegate: NSObject, NSApplicationDelegate {
  func applicationDidFinishLaunching(aNotification: NSNotification) {
    performRequest();
  }

  func performRequest() {
    let delayTime = dispatch_time(DISPATCH_TIME_NOW, Int64(1 * Double(NSEC_PER_SEC)))
    dispatch_after(delayTime, dispatch_get_main_queue()) { [weak self] in
      print("Performing Request")
      Alamofire.request(.GET, "https://httpbin.org/")
      self?.performRequest()
    }
  }
}
```

With this updated example, you can see the memory usage is constant and not increasing:

![screen shot 2015-10-13 at 16 58 39](https://cloud.githubusercontent.com/assets/44164/10471609/a80b03ec-71cc-11e5-9761-be7b9b1daf1b.png)
  Works fine for me in Alamofire 3.0.0 in a unit test.

``` swift
class ResponseJSONTestCase: BaseTestCase {
    func testThatResponseJSONReturnsSuccessResultWithValidJSON() {
        // Given
        let URLString = "https://httpbin.org/get"
        let expectation = expectationWithDescription("request should succeed")

        var response: Response<AnyObject, NSError>?

        // When
        Alamofire.request(.GET, URLString, parameters: ["foo": "bar"])
            .responseJSON { closureResponse in
                response = closureResponse
                expectation.fulfill()

                if let err = closureResponse.result.error as? NSURLError where err == .NotConnectedToInternet {
                    print("Cannot connect to the internet")
                }
            }

        waitForExpectationsWithTimeout(defaultTimeout, handler: nil)

        // Then
        if let response = response {
            XCTAssertNotNil(response.request, "request should not be nil")
            XCTAssertNotNil(response.response, "response should not be nil")
            XCTAssertNotNil(response.data, "data should not be nil")
            XCTAssertTrue(response.result.isSuccess, "result should be success")
        } else {
            XCTFail("response should not be nil")
        }
    }
}
```

I'm going to close this out for now. If you end up finding an actual issue in Alamofire, please post some additional info and I'll be happy to re-open. Otherwise, I'd suggest in the future you open questions like these on Stack Overflow.

Best of luck!
  First, please update to the release version of Alamofire 3 so we can rule out an issue with the older version. 

Second, your definition of the response serializer, `public static func objectSerializer() -> ResponseSerializer` needs to include the types of the value and error to be returned. It's likely that by adding those your code will build successfully. 
 Here's a much more condensed version of your logic that compiles fine on Alamofire 3.0.0:

``` swift
protocol MTLModel {}
typealias MTLError = NSError

extension Request {
    static func objectSerializer <T: MTLModel> () -> ResponseSerializer <T, MTLError>  {

        return ResponseSerializer <T, MTLError> { request, response, data, error in
            let failureError = NSError(domain: "", code: 0, userInfo: nil)
            return Result<T, MTLError>.Failure(failureError)
        }
    }

    func responseObject<T: MTLModel> (queue: dispatch_queue_t? = nil, willStart: (() -> Void)? = nil, didStop: (() -> Void)? = nil, completionHandler: Response<T, NSError> -> Void) -> Self {
//        willStart?()
//        UIApplication.sharedApplication().networkActivityIndicatorVisible = true

        return response(responseSerializer: Request.objectSerializer(), completionHandler: { (response: Response<T, NSError>) in

            dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), { () -> Void in

                print(response)

                dispatch_async(queue ?? dispatch_get_main_queue()) {
                    didStop?()
                    UIApplication.sharedApplication().networkActivityIndicatorVisible = false
                    completionHandler(response)
                }  
            })
        })
    }
}
```

If this doesn't end up working, please comment exactly why and I'll be happy to re-open.
 @cnoon  it would be epic if you can add some blog post or improved documentation about customer serializers. Its quite hard to implement for those of us learning, and the various articles on the internet seem to have wildly different ways of implementing it.  
Can we have one siimple way as an example that doesn't rely on 3rd party libaries and just shows the basics?  By default Alamofire registers any response that makes it through the response serializer (in your example, the `dataResponseSerializer` used by `.responseData`) as a success. If you wish to validate the response code of your request, just add a `.validate()` to your request chain. This will ensure that your response code is between 200 and 299, inclusive. You can also customize validation using the [methods described in the documentation](https://github.com/Alamofire/Alamofire#validation).
  In these cases, you need to use the `response` serializer instead of the `responseXXX` serializers. All others throw errors if the data is not valid. This is something that we're continuing to investigate to see if there is a better way to handle it. It's already being tracked in our backlog.
 @Ysix please check out #889 if you get a chance. This is our first stab at proper 204 support directly in the response serializers.
  Hi @a6475593,

Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

Best of luck!
  Hi @gkss,

Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

Best of luck!
  You need to make sure you keep a strong reference to your new `manager` instance, otherwise the requests are cancelled as soon as the `manager` is deallocated.
 I'm going to close this out @cwack-letsdev. I'll be happy to re-open if you do find an issue in Alamofire.
  `response.response.statusCode`.
  By default Alamofire registers any response that makes it through the response serializer (in your example, the `JSONResponseSerializer` used by `.responseJSON`) as a success. If you wish to validate the response code of your request, just add a `.validate()` to your request chain. This will ensure that your response code is between 200 and 299, inclusive. You can also customize validation using the [methods described in the documentation](https://github.com/Alamofire/Alamofire#validation).

In your case:

``` swift
Alamofire.request(.GET, Constants.Path.rootUrl + "/api/users", parameters: ["username" : usernameString, "limit":3] , headers: ["tb-token" : userToken!])
            .validate()
            .responseJSON { response in }
```
  Hi @lukeg01,

Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

Additionally, I believe this question has been asked multiple times on Stack Overflow. I'd search there first. It usually ends up being an issue with DerivedData or with the way you have it installed.

Best of luck! üçª
  Hi @jdoes,

Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

Best of luck!
 Okay @jdoes. If no one answers or comments on your question, that generally means your question needs to have more detail and be very clear. It also needs to show the steps you've taken to already debug it. Otherwise the community may think you haven't spent the adequate time to debug it. Try to take another pass adding any details you can think of, and I'll take a look.
  Thanks @mkral!
  Thanks @Ashton-W!
  @felipeflorencio This is because Alamofire depends on iOS 8.0 (this is required to integrate Swift frameworks). You will either need to find other ways to integrate Alamofire (without CocoaPods), or drop support for iOS 7.

There is a better error message for this in the upcoming version of CocoaPods (0.39).

``` shell
$ pod install --no-repo-update --no-integrate
Analyzing dependencies
[!] Unable to satisfy the following requirements:

- `Alamofire (= 1.3.1)` required by `Podfile`

Specs satisfying the `Alamofire (= 1.3.1)` dependency were found, but they required a higher minimum deployment target.
```
  I don't think it would @AnthonyMDev.

The `Request` object already has some really good debugging functionality built in. If someone needs additional logging, I'd say that lends itself to a `Manager` subclass. Logging is a complicated beast and I'd rather avoid coupling a logging library directly to Alamofire. Additionally, everyone has their own opinions on how a logging system should work...problem is that most people always disagree. Therefore, I'd rather leave network request logging out of Alamofire altogether.
 @AAverin You can `debugPrint` the `Request` you made to get a `curl` command output, which will let you see the URL, parameters, and headers that were part of the request. Any response logging will have to be written custom by you.
  That's a great question! The answer is quite complicated so let me split it up.

## Short Version

We don't want users to have to cast response serializer errors from `ErrorType` to `NSError` every time just to allow custom error types for `Validation`.

## Long Version

All Alamofire errors encountered when making a request are stored in a request's `TaskDelegate` instance. That error then propagates to all the responser serializers. Since the majority of errors that can be encountered when making network requests are actually generated by `NSURLSession` rather than Alamofire, it makes sense to have Alamofire also generate NSError objects to maintain consistency. This makes the response serializers much less complicated.

In Alamofire 2.0, we made the unfortunate decision to switch the `TaskDelegate` error to an `ErrorType` rather than an NSError. This forced all users to have to cast the error in the response serializers to an `NSError` even if they didn't implement custom `Validation` closures. Not a great tradeoff considering we have thousands (maybe hundreds of thousands) of people using the response serializers and only hundreds creating custom Validation closures.

There are also many more details in #791 if you'd also like to check that out.
  Just FYI...we're aware that there is a fairly large issue with 204 response handling which is why #889 exists. Please check it out if you get a chance before we merge to make sure we're covering your use case properly! üçª
  Thanks @AnthonyMDev.
  Hi @thomasbaldwin, please put yourself in our shoes. Your comment is incredibly unhelpful. 
- Which code samples are incorrect?
- Which version of the README are you looking at? 
- Which version of Xcode are you using? 

Most likely the code samples work just fine if you are using the version of Xcode the README specifies.
 @thomasbaldwin If you want the documentation for 2.0.2, view the 2.0.2 tag on GitHub. Current master is for 3.0.0. 
 Good call @seigel! Fixed in afc8cdb3.
  The carthage build works properly on 3.0.0-beta.3.

``` bash
cnoon:~/Desktop/CarthageTester$ carthage update --platform iOS
*** Fetching Alamofire
*** Checking out Alamofire at "3.0.0-beta.3"
*** xcodebuild output can be found in /var/folders/s7/qpm0b2pn3d56rjlpl7g3_4fh0000gn/T/carthage-xcodebuild.eI0AZs.log
*** Building scheme "Alamofire iOS" in Alamofire.xcworkspace
cnoon:~/Desktop/CarthageTester$
```

Support questions like this are better suited for Stack Overflow. If you do end up finding an actual issue in the Alamofire project, please comment back on this issue and I'll be happy to re-open if necessary.

Best of luck!
 Thanks for adding more detail @silver619. You original question simply did not have enough info to go on.

After digging in to understand what's going on, I tracked down [Carthage #535](https://github.com/Carthage/Carthage/issues/535) which contains quite a few details about the required change. It appears that bitcode support is compiled differently between normal builds and archived builds. To allow Carthage to work properly, I have added the `BITCODE_GENERATION_MODE` user defined setting with a value of `bitcode` to all three framework targets in f6e19674.

This should fix up the issue. If you could possibly test this @silver619, I'd really appreciate it. Thanks again!
 You would use:

``` bash
github "Alamofire/Alamofire" "master"
```
 Yeah that makes sense. Updated all frameworks in 4a213ebe and 373293c0.
  I'm not really sure. This is way outside our general usage. I'm not sure if you can compile a Swift 2.0 framework or app against the 10.10 SDK in Xcode 7. I'd encourage you to take this question to Stack Overflow since this is much more of a Swift and Xcode question than an Alamofire question.
  @dms90 There is no official version 3.0 for CocoaPods yet, you'll have to use `pod 'Alamofire', '~> 3.0.0-beta.3'`.
 Thanks @jshier! üçª
 Updated in 8a3c5256 @ScheerMT to avoid confusion until the official 3.0 release.
 It is very stable. I would anticipate there will be almost no changes other than documentation at this point between the latest commit in `master` and the tagged 3.0 release. We're looking to release Alamofire 3.0 this weekend.
  We will not be directly supporting sockets. We do however already support `NSURLSessionStreamTask` usage.
  You need to use the `response` serializer with a download since no data is actually returned. The data is instead written to a file. If the `error` is `nil`, the download completed successfully.
  This is not something that is directly supported. You can use the `.Custom` parameter encoding to accomplish this. See this [thread](http://stackoverflow.com/a/32031315) for more info.
  While, it used to take 3 arguments, it takes one argument as of https://github.com/Alamofire/Alamofire/pull/792 in Alamofire 3.0.
  Thanks @jshier.
  Thanks for your PR @Screon! I merged a slightly modified version of your PR in 401e76a9. Thanks again!
  Thanks @neugartf!
  The error makes me think you are running one of the Alamofire 3.0 betas. What commit hash or tagged version are you building against?
 If you are just now pulling down the library and building against it, I would suggest starting right off with the Alamofire 3.0 betas. I would also encourage using CocoaPods. The instructions can be found right in the [README](https://github.com/Alamofire/Alamofire#cocoapods). Once you switch over, please check out the [3.0 Migration Guide](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%203.0%20Migration%20Guide.md) for more information to get rolling. Between the README and the Migration Guide, you should be up and running making requests in no time.

If you do still run into legitimate issues, please comment back on this issue and I'll be happy to re-open.

Best of luck! üçª
  Any service call that should NOT return data needs to use the `response` serializer at the moment. All the others expect data to exist, otherwise it will return a `.Failure` result. I'll think some more on the idea of having a generic response serializer that supports the concept of `No Data`. Maybe a `responseNoData` serializer?
 @tkrajacic please check out #889 if you get a chance. This is our first stab at proper 204 support directly in the response serializers.
  @chrene Which platform? Has anyone else ran into this issue that could help @chrene troubleshoot? I would certainly open a question on Stack Overflow as well to get more visibility to this problem @chrene. This is the first time I've heard of this issue, so I'm very doubtful this is an issue with Alamofire itself.
 Okay thanks for getting back to me @chrene.
  First problem you need to switch to return `NSMutableURLRequest` instead of `NSURLRequest`. The second is that it needs to be `responseJSON { request, response, result in`. See the [README](https://github.com/Alamofire/Alamofire/tree/2.0.2#response-handling) for version 2.0.2 for more details.
  What is not released? Could you be MUCH more specific?
  Hi @idrisyildiz7,

Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

Best of luck!
  What version of Alamofire are you using?
 You need to set the domain to `www.anexamplehost.cn` instead of `anexamplehost.cn`. If you want to implement wildcarding, you'll need to create a subclass of `ServerTrustPolicyManager` and override the [serverTrustPolicyForHost](https://github.com/Alamofire/Alamofire/blob/master/Source/ServerTrustPolicy.swift#L56) method.

Best of luck! üçª
 In the case that you're an IP address instead of a domain, the string should most likely be just the IP address. You'll need to debug the [serverTrustPolicyForHost](https://github.com/Alamofire/Alamofire/blob/master/Source/ServerTrustPolicy.swift#L56) method to make sure.
  It depends on what version of Alamofire you are using, but you can always get the original server data in the event of an error if you are using either the Alamofire 2.x or 3.x releases.

#### Alamofire 2.x

``` swift
Alamofire.request(.GET, "http://httpbin.org/get")
         .responseJSON { request, response, result in
             print(result)
             debugPrint(result)

             print(result.data) // original server data if .Failure case
         }
```

#### Alamofire 3.x

``` swift
Alamofire.request(.GET, "http://httpbin.org/get", parameters: ["foo": "bar"])
         .responseJSON { response in
             print(response.request)  // original URL request
             print(response.response) // URL response
             print(response.data)     // server data
             print(response.result)   // result of response serialization

             if let JSON = response.result.value {
                 print("JSON: \(JSON)")
             }
         }
```
 You can print out the error in `result`. That will give you additional info.
  Your static serializer uses an optional value while the response serializer does not. That is your issue. In the future, please post sample code and not screenshots. It's much easier for us to debug and for others to code scan.

Good luck!
  You have MANY options to handle this case...several of which you've already mentioned in your post.

The best option IMO for this case would be to create a custom response serializer to handle the various parsing options. Continue to validate the response status codes, then in your custom response serializer, switch on the error code and use different parsing schemes depending on what type of error you received. Then you can validate your response codes and fork the parsing all within a single response serializer that gets re-used over and over. The [README](https://github.com/Alamofire/Alamofire#generic-response-object-serialization) goes into quite a bit of detail in how to create your own custom response serializer.

Best of luck!
  This issue is much better suited for Stack Overflow. If you end up finding an actual issue in the Alamofire project, please comment back on this issue and I'll be happy to re-open it.

Best of luck!
  There is no built in support for this. You need to look into the documentation of the Security framework and possibly override the `taskDidReceiveChallenge` closure on the `SessionDelegate`. See the `ServerTrustPolicy` for more information.
  You need to update to the official Xcode 7.0 release.
  You should be using the `tvOS` branch. We won't be supporting tvOS in the `master` branch once Xcode 7.1 is out of beta.
  You can validate status codes in MANY ways. Here are a few examples:

``` swift
Alamofire.request(.GET, "http://httpbin.org/get", parameters: ["foo": "bar"])
    .validate(statusCode: 200..<300)
    .validate(statusCode: Set([200, 206]))
    .validate(statusCode: [200, 206])
    .validate(statusCode: [200])
    .response { response in
        print(response)
    }
```

Whatever you pass in just needs to conform to `SequenceType`.
  Thanks for your PR @dfmuir! I merged a slightly modified version of your changes into `master` in 13925497.

Cheers üçª
  Thanks for all the info here @ldiqual. I was actually looking into this myself and came to the same conclusion about the queue issue. There's no published documentation that I've been able to track down about the queue behaviors on UI Tests. If you ever find any, please comment on this issue to update us.

For now, I'd say that the workaround is to use a different queue for the response serializers. I also do not want to add hooks into Alamofire for attempting to detect whether it is a UI test or not. Nor do I think it would be possible to do that.

Cheers.
  Thanks for all the info. I'd say everything is working exactly as expected based on the info provided. If you need a successful 401, don't `validate`, and use the `response` or `responseData` serializer.
  Thanks @AnthonyMDev for helping out here! üçª
  Hi @thiphariel,

Alamofire will never change the HTTP method on the request. It is maintained throughout `ParameterEncoding` as well as when the `NSURLRequest` is sent to the URL session.

For more assistance, I'd suggest you ask your open a question with sample code on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  I don't think this is something that we'll directly support in Alamofire because 1) it's fairly OS specific and 2) we wouldn't know which upload method you would need to use to send the data to the server. There is some useful information [here](http://stackoverflow.com/questions/12138484/how-to-upload-image-that-was-taken-from-uiimagepickercontroller) and [here](http://stackoverflow.com/a/12121605/1342462) that should help you implement this functionality.
  You need to make sure your "custom" manager is initialized properly with the background session identifier before setting the `backgroundCompletionHandler`. If you are calling this on the `Alamofire.Manager.sharedInstance` then it will have no effect. Without knowing what `manager` is, I'd say that's most likely your issue.

For more info, I'd suggest checking out some of the examples in the [URL Loading System](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/URLLoadingSystem/Articles/UsingNSURLSession.html#//apple_ref/doc/uid/TP40013509-SW26) docs.
 Let's move it to Stack Overflow @paulyoung. If you post a link to the question in this issue, I'll try to help you out there.
  Thanks for helping out here @jshier. üëçüèº

@ballerabdude I would suggest you drop down to the Alamofire 2.0.2 branch where we have all the sample code updated in the README and a migration guide put together. The Alamofire 3.0.0-beta.1 is a pre-release. I don't anticipate we'll cut the official 3.0 release here for at least another week, maybe two.
  There is not nor do I think that makes sense to put into Alamofire directly. Instead, I would suggest putting that logic a layer above Alamofire. You always need to construct the parameters, URL, encoding types, etc. before you actually call Alamofire to automatically create the request and execute it. Before you call into Alamofire, you should run your validation.

If you need to first perform parameter encoding and get the `NSURLRequest` all set up, then you'll want to stop using the global convenience `request`, `download` and `upload` methods that take the `Method`, `URLString`, `parameters`, `headers`, etc. and drop down to start calling `ParameterEncoding.encode` directly. Then you can manually assembly your `NSURLRequest` and validate it prior to executing on an Alamofire session.

Does that all make sense?
 Thanks @AnthonyMDev...best of luck!
  Your sample code does not match your description. You are using the `response` method which deals with the 4 tuple values, not a `Result` type. Yet in your description, you are claiming that you are getting a `.Failure` case. Please update your description and sample code to match. Otherwise it is impossible to help you diagnose your issue.
 Could you post your sample project on GitHub or somewhere else so I can try to debug it?
 Thank you for creating that sample project @nonec. After digging into this some more, it appears that it's not an Alamofire bug, but an Apple bug. The following logic reproduces the same issue whether you are using Alamofire or `NSURLSession`:

``` swift
@IBAction func buttonTapped() {
    let testURLString = "http://jsonplaceholder.typicode.com/users/3"

    // NSURLSession Approach
    let URLRequest = NSURLRequest(URL: NSURL(string: testURLString)!)

    let request = session.dataTaskWithRequest(URLRequest) { data, response, error in
        if let data = data, let text = NSString(data: data, encoding: NSUTF8StringEncoding) {
            print(text)
        } else {
            print("failed")
        }
    }

    request.resume()

    // Alamofire Approach
    Alamofire.request(.GET, testURLString)
        .responseJSON { response in
            print(response.result.value)
        }
}
```

I would suggest you file a [radar](http://bugreport.apple.com) to bring it to Apple's attention.
  You guys really need to read through the commits if you're running off master instead of the official "Latest Release". Otherwise you run the risk of the documentation being a bit out-of-date. Considering that `master` currently contains the Alamofire 3.0.0-beta.1 pre-release changes, the docs are significantly out-of-date. This will be resolved over the next couple of days.

If you are running on 2.0.2, @peteclark3's example will work. If you are running on `master` or `Alamofire 3.0.0-beta.1`, you need to use the new response type:

``` swift
Alamofire.request(.GET, "https://httpbin.org/get")
    .responseJSON { response in
        debugPrint(response)

        if let JSON = response.result.value {
            print(JSON)
        }
    }
```
 The documentation is forthcoming gents. Please be patient. The Alamofire 3.0.0-beta.1 is a "pre-release", not an official release.
  Could you provide more info to go on?
- Full sample code showing how you're making the call
- Whether this is an iOS or OS X app
- What version of Alamofire you are using
- How you installed Alamofire into your project

This is the exact error that you get from ATS when you try to call a service over `http`.
 Thanks @Aghassi. This will take me a bit to figure out what's going on here. I haven't put together OS X app yet with Alamofire. 

Does anyone else in the community that works on OS X regularly have any idea what @Aghassi could be running into?
 You might also want to consider hitting the URLs with cURL commands, Paw, POSTMAN, etc. to verify things are working as expected.
  Thanks for filing this issue @eburi. I'll need to put some tests together to figure out exactly why the headers are being dropped. Are you overriding any of the session delegate closures?
 Okay @eburi, you're going to have to take this one up with Apple.

I've added a fairly robust test in cdeb5c19 that demonstrates the behavior. It appears that most headers are passed through from the original to the redirect request with the exception of the `Authorization` header. I can't find any documentation on this behavior, but the test verifies what is actually going on. If you need to pass the `Authorization` header through, you'll have to do it manually by overriding the closure.

``` swift
func testThatRedirectedRequestContainsAllHeadersFromOriginalRequest() {
    // Given
    let redirectURLString = "https://httpbin.org/get"
    let URLString = "https://httpbin.org/redirect-to?url=\(redirectURLString)"
    let headers = [
        "Authorization": "1234",
        "Custom-Header": "foobar",
    ]

    // NOTE: It appears that most headers are maintained during a redirect with the exception of the `Authorization`
    // header. It appears that Apple's strips the `Authorization` header from the redirected URL request. If you
    // need to maintain the `Authorization` header, you need to manually append it to the redirected request.

    Alamofire.Manager.sharedInstance.delegate.taskWillPerformHTTPRedirection = { session, task, response, request in
        var redirectedRequest = request

        if let
            originalRequest = task.originalRequest,
            headers = originalRequest.allHTTPHeaderFields,
            authorizationHeaderValue = headers["Authorization"]
        {
            let mutableRequest = request.mutableCopy() as! NSMutableURLRequest
            mutableRequest.setValue(authorizationHeaderValue, forHTTPHeaderField: "Authorization")
            redirectedRequest = mutableRequest
        }

        return redirectedRequest
    }

    let expectation = expectationWithDescription("Request should redirect to \(redirectURLString)")

    var response: Response<AnyObject, NSError>?

    // When
    Alamofire.request(.GET, URLString, headers: headers)
        .responseJSON { closureResponse in
            response = closureResponse
            expectation.fulfill()
        }

    waitForExpectationsWithTimeout(defaultTimeout, handler: nil)

    // Then
    XCTAssertNotNil(response?.request, "request should not be nil")
    XCTAssertNotNil(response?.response, "response should not be nil")
    XCTAssertNotNil(response?.data, "data should not be nil")
    XCTAssertTrue(response?.result.isSuccess ?? false, "response result should be a success")

    if let
        JSON = response?.result.value as? [String: AnyObject],
        headers = JSON["headers"] as? [String: String]
    {
        XCTAssertEqual(headers["Custom-Header"], "foobar", "Custom-Header should be equal to foobar")
        XCTAssertEqual(headers["Authorization"], "1234", "Authorization header should be equal to 1234")
    }
}
```

All you need to do is override the `taskWillPerformHTTPRedirection` closure on the delegate as shown in the test. If you feel strongly about this behavior being incorrect, then I'd suggest you file a [radar](http://bugreport.apple.com) with Apple.

Cheers. üçª
 It's most likely not implemented that way for security purposes, but more for usability. Forwarding on the `Authorization` headers can fail the redirected request on certain servers. Some servers can throw 400s if they are sent `Authorization` headers when they are not expecting it. Therefore, it's good to follow Apple's lead here. 

If you do need to append the headers to the redirected request, you'll need to do so manually as shown in the test logic above.
  You first need to create your own session configuration with your 3 second timeout, then create a custom `Manager` instance. More info can be found in the [README](https://github.com/Alamofire/Alamofire#modifying-session-configuration).
  What's the full code sample? Please paste the code in rather than taking a screenshot.
 I don't understand what you mean by `serialize the result anymore`.
 Although not displayed in this issue, it appears you temporarily posted the following code into here:

``` swift
        Alamofire.request(.GET, Constants.Path.rootUrl + "/api/users/" + userToShow, headers: headers)
            .responseData { _, _, result in
                print("Success: \(result.isSuccess)")
                print("Response: \(result)")


                if let arrayOfDicts : NSDictionary? = try NSJSONSerialization.JSONObjectWithData(JSON!, options:NSJSONReadingOptions.MutableContainers) as? NSDictionary  {


                        let secImageUrl : getPImages = getPImages()
                        secImageUrl.getProfileImageFromUser(self.userToShow, completionHandler: {

                            (url:NSURL!) in


                            self.profilePic.sd_setImageWithURL(url)

                        })


                        let nameString:String! = arrayOfDicts!.objectForKey("name") as! String
                        let surnameString:String! = arrayOfDicts!.objectForKey("surname") as! String
                        let roleString =  arrayOfDicts!.objectForKey("role") as! String
                        let bioText = arrayOfDicts!.objectForKey("description") as! String

                        let date:String = arrayOfDicts?.objectForKey("birth") as! String

                        let dateFormatter = NSDateFormatter()
                        dateFormatter.dateFormat = "dd/MM/yyyy"
                        let dateNS = dateFormatter.dateFromString(date)
                        let ageInt = self.calculateAge(dateNS!)

                        self.name.text = nameString + " " + surnameString
                        self.role.text = roleString
                        self.age.text = "\(ageInt)"
                        self.bio.text = bioText


                }
        }
    }
```

You have multiple problems in here. You need to wrap your try in a `do` / `catch` block. Additionally, you should use the `responseJSON` serializer for your case. Please refer to the [README](https://github.com/Alamofire/Alamofire#response-json-handler) and the [Migration Guide](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%202.0%20Migration%20Guide.md) since there are code samples for all this logic.

Best of luck.
  This PR opens up the `Manager` initialization to allow users to use dependency injection for both the underlying `NSURLSession` and `SessionDelegate`. 
#### Using Dependency Injection for the URL Session

This change was really made due to #794. While libraries like Mockingjay and OHHTTPStubs are one way to perform automation, Alamofire should also allow a bit more control over the URL session creation to allow approaches like DVR to be possible. This PR adds a failable initializer allowing this to be possible.
#### Using Dependency Injection for the Session Delegate

The current design of the `Manager` initialization is tailored to starting up your app, setting up a `Manager` instance and start making requests. It does not however support background session callbacks very well. 

The problem is that you need to configure the override closures on the `SessionDelegate` before actually creating the NSURLSession. Otherwise, you could start receiving delegate callbacks before you've had a chance to hook up the override closures. This PR adds the ability to use dependency injection to pass in a pre-configured `SessionDelegate` that already has the override closures set.
 cc @kylef and @kcharwood 
 :+1: 
 I don't understand why the second initializer doesn't do exactly what you need @dgdosen.

``` swift
    public init?(
        session: NSURLSession,
        delegate: SessionDelegate,
        serverTrustPolicyManager: ServerTrustPolicyManager? = nil)
    {
```

Just create a session delegate, then create your custom session, and pass both in. You have references to both the delegate and the session. Win win.
  You could also use something like [Mockingjay](https://github.com/kylef/Mockingjay) as that instead registers a custom NSURLProtocol to the `NSURLSession` that Alamofire would use.
 Hi @troya2, thanks for opening this issue. While Mockingjay and OHHTTPStubs certainly have their place and are good solutions in most cases, I don't think that relying on an `NSURLProtocol` should be the only way to perform this type of customization.

Therefore, I have made some changes in #795 to make this possible. I've actually been meaning to rework the initialization of the `Manager` for a bit anyways. You opening this ticket gave me enough of a push to dig in and get it updated. The changes in #795 now use DI to inject a custom `NSURLSession` or a `SessionDelegate`, depending on your use case. If everyone could take a look at that PR and give feedback, I'd greatly appreciate it.

I'm going to close this issue out. Please direct all future comments to #795.

Thanks again! üçª
  Run `pod repo update`. Then `pod search Alamofire` will display `Alamofire 2.0.1` as the latest release which fully supports Swift 2.0. You can always check what our latest release is in our [Releases](https://github.com/Alamofire/Alamofire/releases) section in GitHub as well.
  This PR creates a generic `Response` type to help simplify response serialization. Instead of returning a tuple with four different values, response serializers now return a single generic `Response` object. This makes it MUCH easier to use response serializers, and will help users avoid making mistakes such as incorrectly naming the tuple parameters.

I've seen MANY cases of people swapping the `request`, `response`, `data` and `result` parameters in the tuple. They constantly get misused with tends to lead to a large amount of confusion. Additionally, it can cause strange compiler errors that are quite difficult to debug. This PR attempts to address these issues by replacing the tuple with a generic `Result` type with a generic `Response` struct.
### Old Usage

``` swift
Alamofire.request(.GET, "http://httpbin.org/get", parameters: ["foo": "bar"])
    .response { request, response, data, result in
        print(request)
        print(response)
        print(data)
        debugPrint(result)
    }
```
### New Usage

``` swift
Alamofire.request(.GET, "http://httpbin.org/get", parameters: ["foo": "bar"])
    .response { response in
        debugPrint(response)

        // or

        print(response.request)
        print(response.response)
        print(response.data)
        debugPrint(response.result)
    }
```

This should really help alleviate misuse and should simplify response serialization usage with the concrete struct.
 cc @kcharwood and @kylef 
 Absolutely @cristeahub. I'd rework all the README code samples and put together another migration guide.
 :+1: 
 It was definitely intended @cristeahub. The `response` method simply forwards all the data collected from the `SessionDelegate` without any additional processing. The others are all customized to process the data in a specific way.
  This PR is a non-backwards compatible set of changes solving several shortcomings of the current `Result` and `ResponseSerializer` design. Here is a quick list of callouts:
- `Result` type now takes two generic parameters (Value and Error) where the Error conforms to `ErrorType`.
  
  > No longer stores the `data` in the `.Failure` case.
- All response serializers now return the original server data as an `NSData` optional.
  
  > This solves all the issues reported in #779.
- The `TaskDelegate` now stores the error as an `NSError` instead of an `ErrorType`.
  
  > This was changed in #732 and this should not have been. With these changes, consumers no longer need to cast the `error` to an `NSError`. 
- The `ValidationResult` failure case now requires an `NSError` and not an `ErrorType`.
  
  > This means that a custom `Validation` closure MUST return an `NSError`. The change made to address #732 should NOT have been made. All errors generated by Alamofire (including custom Validation) need to generate `NSError` types. Otherwise we force all consumers to have to cast all error objects returned from Alamofire even though they are not using their own custom validation error types.

For more details, please refer to #732, #757 and #779.
 cc @kcharwood and @kylef 
 I would also love feedback here from @jshier, @AnthonyMDev and @jschmid if you have time to check it out.
 Hi @jshier, you aren't missing anything. What you are proposing has never actually been possible. In Alamofire 2.0 your response serializer just isn't called if there was error that occurred prior to response serialization. 

Let me dig through this issue a bit more and see if there's something we can do to make this a bit easier. Off the top of my head I'm thinking that the delegate error (if one exists) should be passed through to the response serializer.
 Okay @jshier, after digging in a bit more, I realized that the issue was MUCH worse than I originally thought. Thank you for pointing that out! I owe you a beer for that one. üçª

I've addressed the issue using the approach I mentioned previously in 025f33bc. All response serializers now receive the delegate error as a parameter in the `serializeResponse` closure.

IMO, this has three major benefits. 1) It fixes the major bug that I introduced üòâ 2) Ensures all response serializers are always actually executed 3) Allows each response serializer to inspect the error and figure out how to proceed. Certain types of errors will actually cause the server to return different payloads. This abstraction would actually allow you to use different parsing schemes based on the error type.
 Awesome! Yes #792 is PR'd on top of this one. The combination of the two is what I'm thinking response serialization for Alamofire 3.0 looks like.
 Thanks @ziogaschr! I'm looking to get it merged into master today or tomorrow. Need to get the ASF to make a review pass here. Once #791, #792 and #795 are merged, I'll be cutting Alamofire 3.0.0-beta.1 to get testing going.
 @kcharwood awesome...thanks for digging through this! üëäüèº 

As for the migration guide, I'll be putting that together here in the next couple of days. I'll be sure to cover all your suggestions in detail.

@AnthonyMDev I'm in the process of merging all these PRs right now and cutting the Alamofire 3.0.0-beta.1 release. I won't have a migration guide put together for a couple of days, but I'm sure you can figure out the API differences from the PRs and the test code.

Everyone else, thanks for helping get this through! üçª
 Okay @jschmid, while I appreciate your feedback, you are using validation and response serialization incorrectly. You should not be creating a custom validation extension to validate the status code, that EXACT functionality already exists in Alamofire and all the error handling is taken care of by the response serializers. If you need to handle a validation failure in the response serializer completion, just switch on the error code like you do for all other types of errors.

Additionally, why would you want to start throwing your own custom errors when you aren't creating your own custom response serializers? That doesn't make sense to me. IMO you're just making your life more difficult...on purpose! Instead, keep all the errors coming out of Alamofire as NSErrors and you can just switch on the error code. Why would you want to have to switch on NSError codes AND your custom error type? That's actually MORE complicated.

By locking down the error type stored in Alamofire to ALWAYS have to be an NSError, it allows all response serializers to be strongly typed which means you don't have to cast the error to an NSError every time you need to access it. This is the 99% case for the Alamofire community. Power users are like @jshier are certainly going to create custom response serializers tailored to their own needs, but the common usage pattern should be as simple as possible. This fits with our overall design philosophy which is to cater Alamofire to the masses by making it as simple and easy to use as possible, while flexible enough to serve the power users.

Locking down the NSError internal type allows us to support some powerful features and more consistent APIs:
- Strongly typed NSError returned by the no-op response tuple method
- Strongly typed errors returned by all generic response serializers
  
  > No more casting to NSError
- Custom response serializers can specify their own strongly typed error encapsulating the NSError being produced by Alamofire if necessary (see @jshier's sample code)
- Consistent generic usage patterns between ResponseSerializer, Response and Result types

Hopefully that helps clear up any possible confusion as well as shed some light on the big picture.
  Remove the `Alamofire.xcodeproj` project from your Xcode project. This will automatically remove all associations to Alamofire from your Xcode project. Then remove the [submodule](http://stackoverflow.com/questions/1260748/how-do-i-remove-a-git-submodule).
  `Authorization` headers should not be set in the `HTTPAdditionalHeaders` dictionary on the `NSURLSessionConfiguration`. Instead, an `Authorization` header should be appended to each individual request. This is the recommendation of both the ASF as well as Apple.
 @eburi which version of Alamofire are you using? Alamofire 2.0.1 contains a fix that should solve this issue for you.
 @phiberjenz and @simonnarang: please refer to the info in #798 for more info on these findings. It walks you through the various options available to you when this happens.

Cheers. üçª
  When making a data request, you receive progress callbacks on the download data, not on the upload data. You should be using `Alamofire.upload` instead. Check out the documentation on [NSURLSessionUploadTask](https://developer.apple.com/library/prerelease/ios/documentation/Foundation/Reference/NSURLSessionUploadTask_class/index.html) for more info.
  The recommended way to send an `Authorization` header is to NOT use the `NSURLSessionConfiguration` `HTTPAdditionalHeaders`, but instead to pass it along with each individual request. This is both the recommendation of the ASF (Alamofire Software Foundation) and Apple. The main reason for this is that the header value tends to change over time.
  I cannot reproduce this issue. I followed the [Adding Frameworks](https://github.com/Carthage/Carthage#adding-frameworks-to-an-application) instructions in the Carthage README and had no issues. Here is some additional info about my setup:

### Cartfile

``` bash
github "Alamofire/AlamofireImage" ~> 1.0
```

### Carthage Version

``` bash
$ carthage version
0.8.0
```

### Xcode Build Version

```
$ xcodebuild -version
Xcode 7.0
Build version 7A218
```

### Building Frameworks

```
$ carthage build --platform iOS
```

Since everything is working as expected, I'm going to close this issue out. If you continue to have issues after all the info I've just posted, I would encourage you to consider opening an issue with the Carthage project or on Stack Overflow to help you continue further. If you do end up finding an issue in the Alamofire project itself, then I'll be happy to re-open this issue.

Best of luck!
  Fair enough. Updated the documentation in 71a26d64 to be more clear. Thanks!
  There is no `swift-2.0` branch anymore, please follow the installation instructions for CocoaPods in the [README](https://github.com/Alamofire/Alamofire/#cocoapods):

``` ruby
pod 'Alamofire', '~> 2.0'
```
  Thanks for the PR @nickygerritsen! I'm not exactly sure how that managed to get messed up in 8873379, but I'm glad it's fixed!

Thanks again! üçª
  Could you both give me a bit better description of what you are trying to do and why the current design of the `.Success` case doesn't give you the flexibility that you need?
 Thanks for your feedback @jshier and @rafaelc0sta...much appreciated! I've just pushed up #791 which should solve all these issues. If you could check it out and provide feedback, I'd greatly appreciate it. I'm going to close this issue out. Please redirect all future comments to #791.
  Swift 2.0 has been supported since the day it was announced.
  The `Content-Type` header is set for you automatically. You don't need to generate your own.
 You can if you encoded the data yourself by creating your own `MultipartFormData` object, encoding the data, then manually creating a `Request`. The convenience method does this all for you.
  Hi @tobiasolofssonevry,

Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

Best of luck.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Thank you for your feedback @grantjbutler. 

This is a great question. Long story short is that your [HTML 4.01 spec](http://www.w3.org/TR/html401/interact/forms.html#didx-applicationx-www-form-urlencoded) (created in 1999) is outdated. All the Alamofire logic and tests are driven from the much newer [RFC 3896](https://www.ietf.org/rfc/rfc3986.txt) spec published in Jan 2005. We have MANY [tests](https://github.com/Alamofire/Alamofire/blob/master/Tests/ParameterEncodingTests.swift#L38-L235) around this behavior as well as some fairly verbose [documentation](https://github.com/Alamofire/Alamofire/blob/master/Source/ParameterEncoding.swift#L192-L216).

Cheers. üçª
  I can't spot anything obvious. Could you post the `debugPrint` output of the `Request` you are creating with `Alamofire.request` call? That would certainly help. Also, you should try to use that cURL to see if you can hit your server as expected.

Another thing I would suggest is to open a question on Stack Overflow. You'll get many more people to help you debug your issue.
 I'm going to close this issue out. Please open an issue on Stack Overflow @mikewalkerjr. If you post the link in this issue, I'm sure either @jshier or myself will be able to continue to help you out there.

Best of luck.
 @PurviJani Posting on old issues is not a good way to get support. These types of questions are best suited for [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Thanks @Baza207! üçª
 I ended up resetting the merge and just cherry picking your change in 2d8466cd. In the future, if you could rebase before you push up your PR, that would be greatly appreciated. 

Thanks again!
  Hi @Jayvd,

Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

Thanks!

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
 The solution is already there @cloudjanak. You can use the other `appendBodyPart` methods to accomplish the same thing.
  It supports Swift 2.0. Please take the time to read the [documentation](https://github.com/Alamofire/Alamofire#requirements) in the future. Thanks!
  Hi @cczufish,

Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

Best of luck.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Thanks for your PR @bscarano...much appreciated! 

I merged a slightly modified version of your PR in 8873379b. I wanted to make sure all the settings were correct, so I created the framework and test targets myself going through each step carefully. I still gave you attribution for the change. I also want to keep this separated from the `master` branch until it's officially released.

Thanks again! üçª
  The `debugPrint` output is printing out the `description` of the successfully parsed JSON `AnyObject`. It's not printing out the JSON itself. This works as expected.
  Thanks for your PR @Baza207...much appreciated! I ended up merging a modified version of #767. Thanks again!
  We will not be adding a dependency to the core Alamofire framework. Adding a dependency has many risks and greatly increases complexity for those adopting it. The fact that the two Result types collide is something you can easily resolve on your end by adding the framework namespace. 

The Alamofire `Result` type does not contain all the same complexity due to the fact that it does not need it. If you feel there are certain cases that our current implementation does not handle properly or as well as it could, then please open a pull request with a good explanation of why the additional logic is necessary, and we'll take a look.
 Looks like there are radars filed @marcelofabri and there's also an acceptable workaround to the problem. While I understand it's not as convenient as you would like, I don't think it's appropriate for us to rename our classes due to other third party library collisions.
 @Rupert-RR it is a very unwise decision to couple to any dependency that you do not control for large open-source projects. Anyone that has been responsible for such a library knows exactly what I mean by this. As soon as you add the dependency, you are forever bound by that dependency if there are new Swift beta releases, bugs, changes that don't conform to semver, etc. This is not something we're interested in exposing ourselves or the community to.

Additionally, the `Result` type provided in Alamofire is tailored specifically to Alamofire use cases. It is not intended to be used as a solve all `Result` type outside of Alamofire APIs. It also includes an additional `data` associated value in the `.Failure` condition which the antitypical/Result library doesn't support.

Hopefully that clears up any confusion.
 Let's agree to disagree @Rupert-RR. I'm not interested in discussing this further.
  Your `Downloader` instance is probably getting deallocated which is deallocating the `mngr` instance.
  You cannot do this with asynchronous calls. 

The easiest way to explain it would be to have you create a playground where you `dispatch_async` to one of the global concurrent queues. Then try to throw inside the closure of the `dispatch_async`. This is the underlying issue with attempting to throw with async operations. Instead, you need to pass the error off to your `completionHandler`.
 Yes, you are missing the core problem. Try to throw inside a `dispatch_async` call in a playground and you'll start to see what the problem is.
 I cannot speak for Apple @kevinbelter but it is certainly a design flaw with the error handling system which is why we use the alternative concept of a `Result` type in Alamofire.
  @wizgod Could you please confirm which version of iOS you are having this problem?
 Also, could you let us know how you installed Alamofire into your project.
  Hi @RyanCodes...thanks for your PR. Unfortunately this doesn't properly add support for `tvOS`. We'll be putting together a branch to add proper `tvOS` support early next week. Thanks again!
  Not actually a duplicate, this is for Carthage not CocoaPods. #759 fixes this.

@imns Please use the following in your Cartfile:

``` odgl
github "Alamofire/Alamofire" ~> 2.0
```
  @AnthonyMDev thanks for your feedback. You are absolutely right and it should be implemented as a double generic `Result`.

For a bit of background, the `Result` type originally took an `NSError`. When working with @jshier in #732, I changed the `Result` to take an `ErrorType` 64a00447. Instead, I should have made the `Result` a double generic and forced the error to conform to `ErrorType`. 

I'm currently working with the ASF to figure out how to proceed here. I'll update the issue once we decide what we're going to do. Thanks again for bringing this to our attention.
 We will not be adding a dependency for a Result type @Rupert-RR. Please see #764 for more info.
 Okay @AnthonyMDev, we've finally landed on how to attack this issue and I've just pushed up #791 which addresses the core design flaw. If you could check it out and provide feedback, I'd certainly appreciate it. I'm going to close this issue out. Please redirect all future comments to #791.
  Thank you for your feedback @roymckenzie!

There is not currently a way to set the `ParameterEncoding` type for all requests, nor do we think it's in the community's best interest to add one. The most common case is certainly to use `.URL` encoding for `GET` requests. Adding an override into the `Manager` would not only complicate the implementation, but could (most likely would) lead to confusion.

Thanks again.
  I think this crash comes from `NSURL(string: URLString.URLString)!` since you're passing in an invalid URL (URLs may not contain spaces).

URLs should be urlencoded and thus any spaces should be replaced with `%20`. The second example you have shown is properly encoding and escaping characters and thus doesn't crash.
 @tosbaha If Alamofire URL encoded your input, it still wouldn't become a URL because the `:` and `/` would be escaped.

```
http%3A%2F%2Fwww.example.com%2Fabc%2Fdef.asp%3Fk%3Dabc%20def
```
 @tosbaha the docs state:

``` swift
public protocol URLStringConvertible {
    /**
        A URL that conforms to RFC 2396.

        Methods accepting a `URLStringConvertible` type parameter parse it according to RFCs 1738 and 1808.

        See https://tools.ietf.org/html/rfc2396
        See https://tools.ietf.org/html/rfc1738
        See https://tools.ietf.org/html/rfc1808
    */
    var URLString: String { get }
}
```

If you do not end up using the Alamofire `ParameterEncoding`, then you risk the possibility of certain characters not being escaped properly. This is exactly why we would recommend you always use the `ParameterEncoding` enumeration to do this. The `URLStringConvertible` protocol is merely convenience. It should not be used in cases where you are not confident that the URLString is valid. 

We do not want to combine the concept of character escaping with the `URLStringConvertible` protocol because as @kylef mentioned, there can be some very strange behavior that causes way more harm then good.

Best of luck.
  An `NSMutableURLRequest` is a reference type. You don't need to use an `inout` declaration on it. It will modify both instances. If that doesn't completely solve your problem, please open an issue on Stack Overflow.

Best of luck!
  Yes, iOS 7 is not supported in Alamofire 2.0. We're supporting current and previous versions of iOS (9.0 and 8.0)
  You need to use the Xcode 7 GM. Then everything will build properly. If you continue to experience issues (unlikely), then please open a question on Stack Overflow.
  Thanks @dwightwatson.
  Thanks @keith. I just updated the README installation instructions in 343e24073990172de3c55871762f68d49838a3ce @codebeaulieu. Cheers.
  Thank you for your PR @bojan. We are not going to support iOS 7 in Alamofire 2.0. Please see #554, #525, #523, etc. for more info.
  Interesting. The only thing that strikes me as surprising is the `encodingMemoryCompletion` being modified to such a large value. Could you put some timings around how long the encoding takes and how long the upload takes just to have more info to go on? Could you then drop the `encodingMemoryThreshold` to zero and run the same timings?

Other than that I cannot see any actual issues with your logic. Alamofire does not doing anything to throttle your upload.
 I'm not sure what to tell you unfortunately. This is not an issue with Alamofire, but is instead of issue with your network or device. I would suggest taking your question to Stack Overflow. Maybe they will be able to help out more.

If you do end up finding an actual issue with `MultipartFormData` uploading, then please add some additional info and I'll be happy to re-open the issue.

Best of luck.
  Thanks @paulyoung.
  Make sure to copy the example from the [swift-2.0](https://github.com/Alamofire/Alamofire/tree/swift-2.0#crud--authorization) branch and not `master`. The `URLRequestConvertible` protocol has changed between Alamofire 1.0 and 2.0. For more info about migrating to Alamofire 2.0, check out our [migration guide](https://github.com/Alamofire/Alamofire/blob/swift-2.0/Documentation/Alamofire%202.0%20Migration%20Guide.md).
  This has been a long withstanding problem that has been reported and questions many times on GitHub or Stack Overflow (#283, #374, #623, #646). Issue #374 has a wealth of information about the different options and a healthy debate between @mattt and @mxl. For this particular issue, I tend to side with @mxl.

Having personally had to deal with services constantly that require appending parameters to the query string for .POST and .PUT methods, I felt it was time to add support into Alamofire to make this situation more palatable for everyone. The main challenge is avoid complicating the `ParameterEncoding` enumeration to keep it simple even though we need to add another case or condition. I think this change strikes a nice balance.

I tried to update the documentation to make it as clear as possible to understand the differences between the two cases.

Other alternatives I consider were `.URLEncodedInQueryString` (too verbose), `.URLQuery` (too vague), and also adding a flag to the `.URL` case such as `.URL(encodedInURL: Bool)`. The problem with this approach is that you cannot specify a default parameter in an associated value.
 cc @kcharwood and @kylef 
  Thank you for your PR @dduan...much appreciated! 

Unfortunately, I've decided not to merge this change into Alamofire. I definitely see where you were trying to go with this, but I think the fact that you need to hand it the `session` and the `credential` are simply proof that it is trying to do too much. I also think that by `nil`ing out the parameters, users could get confused why their `cURL` commands aren't working properly when they're not getting an accurate representation of the actual request.

Thanks again.
  Hi @paulyoung, my apologies for not getting back to you sooner. I've been working on wrapping the AlamofireImage release over the past week. 

Your issue certainly seems to be a bug in the implementation of Alamofire. My best guess at the moment is that we always need to write to a file if the session configuration is a background configuration. I'll dig into this theory today and get back to you.

Thanks for all the hard work here debugging this. Much appreciated! üçª
 It's all good dude. No worries. I just managed to get a test case put together that reliably produces this crash 100% of the time. Should have a fix up soon! üëçüèº
 Fixed in 441a9dca. Thanks again for the awesome details! üçª
 There are. I haven't decided whether we're going to cut one this weekend or wait until the GM drops. If we end up cutting one this weekend, you'll see it go out over Twitter. üëçüèº
 You know what, you're right! I'll cut 1.3.2 here shortly.
 So unfortunately, this cannot be back ported. It looks like the nullability on the `identifier` property is set incorrectly in the iOS 8 SDK. It thankfully is fixed in the iOS 9 SDK. Since there's no other way that I know of to run this check, it looks like you'll have to work around this limitation on your own.

What your can do @paulyoung is set the `encodingMemoryThreshold` to zero which will cause the upload to always write the file to disk before the upload. That will certainly work for you for now until you update to Alamofire 2.0.

Sorry dude üòï
  @jshier is correct. If your `Content-Length` is unknown, this is the behavior you should see. I'm going to close this out. If you find that `Content-Length` is actually known and believe there is truly an issue, please provide more info and I'll re-open if necessary.

Cheers.
  Hi @genu1,

I just added tests around this behavior in 33dcfd4b demonstrating how to do this. I'm not exactly sure why you are crashing, but Alamofire can handle this case without issue. I'm going to close this issue out for now. If you provide more info that leads us to believe there is an issue in Alamofire, we'll be happy to re-open.

Cheers. üçª
  NSNull is still really burdensome to deal with, even in Swift.
 I actually have a pull request for this that is very similar
 #737 addresses this
 Hi @harlanhaskins, after much thought, this is not something we will be adding directly to Alamofire. 

The reason is that this has fairly serious performance implications for large JSON payloads. It is MUCH more performant to handle the `NSNull` values at your actual JSON parsing level. While it's not as convenient, there are certainly JSON libraries out there that can easily handle `NSNull` values.

Now with that said, you can still add this to your app or wrap it into your own custom response JSON serializers. If this is how you want to handle these, then by all means, go right ahead. We just aren't looking to add this functionality directly into Alamofire core.

Thanks for the suggestion!
  We'll do this once the GM is cut and not before. We're all over this.
  Hi @tryadelion,

Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

Best of luck!

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
 Okay, next time you open an issue, please be a bit more specific. You just answered you own question which is why I pointed you to SO in the first place. Alamofire already supports your use case and is documented accordingly. It does not have your "exact" use case, but certainly walks through creating an `NSURLRequest` and passing that into the `request` method.

If you actually have a feature request (I think you might), then please open the issue as such with a well thought out case. More times then not, those cases actually get implemented in some form. Just please keep in mind that we want to build convenience layers for the common cases, yet remain flexible enough to cover all cases.
  Yep, you need to be on beta 6 for the latest `swift-2.0` branch commits or the Alamofire 2.0.0-beta.3 release.
  We have now transformed the `Result` type and all uses of it to use the `ErrorType` for exactly that reason. We continue to generate `NSError` objects inside Alamofire to guarantee that that is the only error type that will ever come out of Alamofire. Using the `ErrorType` though in the `Result` type gives all developers the freedom to wrap all Alamofire error in their own `ErrorType` enumeration.
 Those are all perfectly valid points @jschmid. Thanks for putting together all your feedback to make your case. To make a very long story short, I agree and I've updated all the logic around all result types in Alamofire to use `ErrorType` instead in 64a00447.

Originally @jshier and I worked through the changes on the `Result` type and we just missed the other cases. The validation case you are referring to is more-or-less the same issue @jshier and I were originally discussing. I think the changes in 64a00447 should completely remove this limitation.

Thanks again!
 Hey @jschmid and @jshier!

I've been reworking the error handling and response serialization logic and just pushed up #791. If you guys could check it out and provide feedback, that would be great! What we ended up doing here in 64a0044 was not the best decision.
  Is there any way you could provide a failing test for this change? That would help us debug to make a more informed decision.
 Thanks for your PR @cheolhee! 

After much investigation, I've decided to merge this change in 21040abd. I've also added a test around the POST behavior in ba6d3dd5.

With that said, I only made this change due to the fact you're seeing issues without the change. I cannot see any downsides to making the change. This [thread](http://stackoverflow.com/questions/16819502/application-x-www-form-urlencoded-and-charset-utf-8) makes me believe though that the `charset` should not really be required. Additionally, no actual unicode characters will ever make it into the HTTP body since all parameter key/value pairs are percent escaped prior to be encoded into UTF-8.

I'm assuming your server is requiring the `charset` when it actually shouldn't. Either way, as I mentioned, I cannot see any downsides to adding it.

For future reference, there's a good amount of information about the encoding algorithm [here](http://www.w3.org/TR/html5/forms.html#application/x-www-form-urlencoded-encoding-algorithm).
  Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @blixt,

Thank you for taking the time to put together this really well thought out issue. You have some very good feedback and use cases that others could learn from about the way Alamofire is intended to be used and is designed.

### Issue

I think the biggest issue you are fighting at the moment is that you are trying to funnel three very different types of requests through the same root method. Additionally, you're trying to build all three requests using the same `URLRequestConvertible` implementation. Now I completely get why you are trying to boil your API calls down, but you've passed the point of no return with reusability IMO.

### Splitting Up URLRequestConvertible

Why not create three different types of objects with their own implementations rather than trying to jam them all into one? You have three different types of requests to make, so have three different wrappers for these types of requests? This would certainly solve the issues you are fighting against at the moment. I think the code samples in the [API Parameter Abstraction](https://github.com/Alamofire/Alamofire/tree/swift-2.0#api-parameter-abstraction) and the [CRUD](https://github.com/Alamofire/Alamofire/tree/swift-2.0#crud--authorization) examples demonstrate how to sensibly encapsulate similar chunks of logic. What I would not encourage though is to use a single enumeration to work for EVERY single API. It gets too daunting to handle all the cases, especially when your request types are so drastically different.

### Don't Funnel into a Single Alamofire Call

Another suggestion I have is to not try to wrap your entire API into a single call into Alamofire. Instead, I tend to wrap APIs as follows:

``` swift
class SomeService {
    static func callFirstService(parameters: [String: AnyObject], completion: ModelObject? -> Void) {
         // Implement some Alamofire.request() call fully tailored to this service call
         // Attempt to parse the logic into the model object and serve it back to the callback
    }

    static func callSecondService(parameters: [String: AnyObject], completion: ModelObject? -> Void) {
         // Implement some Alamofire.request() call fully tailored to this service call
         // Attempt to parse the logic into the model object and serve it back to the callback
    }

    // So on and so forth
}
```

> This approach let's you tailor each `Request` to the service you are calling. Alamofire is MUCH easier to use with this approach rather than funneling these calls into a single call to execute the request.

### Embrace Chaining

The approach you've taken really goes against the idea of method chaining. Alamofire makes it really easy to customize the setup of a request, validation and response handling. It is not structured at all to handle all these cases in a single API. This is one of the most powerful parts of the Alamofire design, and you are really working against it rather than embracing it.

### Summary

I really appreciate all your feedback. It's very helpful to see where people are running into design issues when leveraging Alamofire to call their APIs. I would really encourage you to read through this feedback carefully and consider these design suggestions. Alamofire can easily achieve what you need, but gets complicated with the way your trying to funnel your calls through it.
 Hi @blixt,

Now we're narrowing it down. I couldn't agree more with your comments about the Facebook API. That's exactly the message I was trying to relay in my "Don't funnel into a single call" section. We're on the same page there. Alamofire makes that quite simple with the exception of `MultipartFormData`. I think my biggest take away here is your frustration with the two-step handling of `MultipartFormData`. 

It was designed that way because it has to be if you are uploading a large amount of data. The data needs to be encoded to disk before you can create the request. Since the request isn't actually created until the encoding completes, the method call cannot return the request to allow for chaining. The only way it could return a request to allow for chaining would be to encode the data in memory or on disk on the caller thread and directly create the upload request and return it. This has very problematic implications with blocking the caller thread for a significant amount of time. This is why uploading `MultipartFormData` was designed as a two-step process.

Now, you could certainly make this a one step process by pre-encoding the `MultipartFormData` manually, then handling off the already encoded data to the regular upload methods (data, file, stream). This would allow you to chain both approaches in the same manner. If you have other suggestions on how to handle the two-step problem in a more elegant manner, I'm all ears. IMO there isn't a better way to do this unless all NSURLSessionTask creation was deferred until `Request.resume()` was technically called. This however would require a complete re-write of the Alamofire core logic and would have MANY other downsides.

As for your last comment of controlling what data is put into the query string and what is put into the body, I tend to disagree. If you need fine grained control, create your own `NSURLRequest` objects with the `ParameterEncoding` enum and then pass that `NSURLRequest` into the `URLRequestConvertible` methods. The convenience APIs designed to do it all in one step (request, download, upload) are a bit too convenient for you. With that said, there is currently a PR open to add another URL encoding case that will at least allow you to specify that the encoded parameters should go into the URL and not the body regardless of the Method.

Great discussion...thanks for all the feedback. So far I don't have any actionable items here. If you can come up with some suggestions on the `MultipartFormData` design, I'm happy to revisit the design of the upload methods.
 Hi @blixt,

Your serializer suggestions are good, but lack the context around the limitations of this type of implementation on iOS. Subclassing `NSInputStream` is VERY fragile and simply not recommended. We've learned the hard way from our trials with AFNetworking. This is why we went with the approach we did in Alamofire. It is much more robust and reliable. You still aren't addressing the fundamental issue of encoding the data before creating the `Request`. You cannot do it after you create the `Request`. You're ideas are all really good, but they aren't possible to implement. Believe me, I considered them heavily before building the current implementation.

As for your challenges with using `ParameterEncoding` in both the query string and the HTTP body, you can still handle this case by using a combination of `ParameterEncoding` and `URLRequestConvertible`. Alamofire has always been designed to make the common cases as simple as possible, while being flexible enough to still allow you (the power user) to perform any operations that you need by having access to the underlying URL Loading System.

I appreciate all your feedback in this thread. I think it is very useful and well thought out. As a takeaway, I would challenge you with a couple things. 1) Try to work with Alamofire rather than working against it. It's not designed to be perfectly convenient for every use case. It's designed to be convenient for the common cases, yet give you the flexibility to control what you need. Layer the convenience levels around it in your own APIs to abstract the Alamofire complexities. 2) Open a pull request with your ideas and suggestions on how we can make improvements. We are in no means locked into any way of doing things. We take the submitted PRs very seriously and love it when new ideas and designs come in from the community.

Cheers.
  Hi @carlshimer,

I'm not sure where you see that the `completion` closure needs to be called on the main thread. I've dug through all the Apple [docs](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplicationDelegate_Protocol/#//apple_ref/occ/intfm/UIApplicationDelegate/application:handleEventsForBackgroundURLSession:completionHandler:) I can find and cannot find anything that references that. Additionally, I have several apps built ontop of Alamofire that do have functional tests around this behavior that do not call the `completion` closure on the main queue and I haven't seen any issues.

I'm going to closure this issue out for now. If you can provide some additional information that merits further investigation, I'll be happy to re-open.

Thanks! üçª
 Exactly what I was looking for and couldn't track down. I'll get this fixed asap. üëçüèº
 Addressed in 4264b9d5. Thanks for pushing back here!
  Not sure I understand your question.

> How can i force to append as an string?

All data placed into the HTTP body of the upload request needs to be encoded into `NSData` before being transmitted. It's a bit more complicated than that under-the-hood, but at a higher level, that is the easiest way to explain it. Therefore, you cannot append a string. You can only append a String encoded as `NSData`. 

Does that make sense?
  Thanks for your PR @jschmid! I pushed a slightly modified version of your changes in d4301808 giving you attribution.

Thanks again! üçª
  Thanks @cristeahub.
  Sweet! Thanks for the PR @dfmuir. üçª
  Thanks for the heads up @kodayashi. We will certainly get this fixed.
 Thanks for reporting @kodayashi! Your issue should be resolved with 8023191f.
  Hi @conradwt, thanks for your question and feedback!

At the moment, I think this is something that we should not support. The reason being that there are just too many assumptions that need to be made to write these types of "convenience" methods. 
- How do we know which `NSStringEncoding` to use? 
- How do we know which type of `NSDate` formatter you want to use?

Because of this ambiguity, I think it's best to leave these types of methods out of Alamofire. IMO, they should instead be created as extensions on the `MultipartFormData` class that internally creates the encoded data that you need, then calls the appropriate Alamofire method.

Does that make sense?
  Is there any possible way you could provide us sample code that we can actual run to help us debug the issue? We already authentication challenge tests that are passing as expected.
 Hi @avf, I need your help to debug this. I don't have a way to test NTLM authentication. If you could provide more information that would be really helpful. Would you be able to provide actual sample code that I could run? If you're worried about obfuscation, would you be willing to work with me through email or Slack?

We have tests around this for basic and digest auth that work just fine with that code change. Please get back to me asap. I'd like to get this tied off before the Alamofire 2.0 release.
 Thanks for getting back to me @avf. Unfortunately, since we don't have any way to test this, I'm going to have to close this out for now. If someone runs across this issue again, we can re-open or debug at that time.

Cheers. üçª
 Would you be willing to help me debug this issue @mubashirjavaid? It may take a bit of time to figure out the issue. I may need you to try some different branches to try out some different approaches. Also, would you be able to provide me with enough sample code that I could debug the problem myself. I'd be happy to work with you in a non-public facing way such as through Slack or email.
 Got some awesome info for debugging this from @mubashirjavaid! Once I have a chance to dig through the issue I'll report back what I find. Hopefully I'll have a fix.
 Okay...got to the bottom of the issue. Thank you so much @mubashirjavaid for helping me debug the problem. I wouldn't have been able to figure out what the root cause was without your help! üçª

The issue was in fact the commit b69959b. That was a very bad change on my part. I have reverted that change in a9480269 and made another bug fix in 6ac4ce17. I was able to verify that a9480269 does in fact fix the NTLM issue. It also fixes some other unwanted behaviors.

I'll be pushing out 2.0.1 here shortly that will include this fix. Thanks everyone for helping get to the bottom of this issue. Alamofire is much better off for it!
  Thanks @cristeahub.
 I'm not sure if there's an alternative. The main reason we've dropped support is that we cannot test it due to the fact that iOS 7 doesn't support frameworks. We'd need to duplicate our entire test suite which is just not reasonable. Therefore, to keep our quality as high as possible with full test coverage, we made the tough decision to drop iOS 7 support.

If you are willing, it would be quite easy to fork Alamofire and make the necessary fixes for iOS 7.
  Hi @kaelite, thanks for the suggestion! I completely agree and implemented the change along with tests in 4e633d6d.

Cheers. üçª
  Thanks for your PR @sai-prasanna! Much appreciated. This task was actually sitting in our Trello backlog. I pushed a modified version of your PR in 282eec67 while still giving you attribution. 

Thanks again for your changes! üçª
 @sai-prasanna, the only suggestion I have would be to look at the diff between what you submitted and what I actually committed. That will help you find the differences in phrasing, code structure, etc. Otherwise, just keep the PRs coming...best way to learn is to practice! üëçüèº
  You can get the decoded JSON payload from the result you've printed in your example.

``` swift
Alamofire.request(.GET, "https://api.someplace.com/", parameters: nil, encoding: .JSON, headers: headers)
    .responseJSON(completionHandler: { _, _, result in
             switch result {
             case .Success(let payload):
                 print(payload)
             case .Failure(_, let error):
                 print(error)
             }
    })
```
  Great catch! Just one comment and then we can get it merged.
  So after much thought I think we should leave this as is. The main reason is that in some cases, we aren't going to want to call the progress closures on the main thread.

For example, if you have some library that you are working on that handles asset downloads, you probably want Alamofire to call your library off the main thread so you can then handle some processing and then eventually bubble it up to the main thread. If we automatically dispatch the progress closures to the main thread, you'll have to then dispatch again to get off the main thread causing unnecessary dispatching.

The downside of not changing the behavior is that you must dispatch to the main thread if your progress closure needs to update some user interface values. While this is unfortunate, at least you still have full control over the behavior.

Thanks for opening the issue so we could investigate!
 Absolutely @grundid...I've added a task to our Trello project to get the docs updated before the 2.0 release. I'll update this issue once I've done so. Thanks again.
  Thanks @ikesyo.
  The 2.0.0-beta.1 release compiles on beta 5. The 2.0.0-beta.3 release compiles on beta 6.
  Hi @hengchengfei,

Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

Best of luck!

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Dependencies in CocoaPods are have a locked commit/version, to update to the latest you may run `pod update Alamofire`.
  Hi @danwalkowski,

Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

Best of luck.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
 Both of you need to be on the Alamofire 2.0.0-beta.2 release with Xcode 7 beta 6.
  This looks great @mishagray! Thank you for putting this together...much appreciated! üçª
  Thank you for your PR @mackuba. Unfortunately I ended up merging the changes in #707 that fixed the iOS Example as well. Thanks again.
  Hi @telenc,

Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

Best of luck!

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  While it is certainly possible to return multiple auth challenges, it is not recommended which is pointed out in [RFC 2617 - Section 4.6](http://tools.ietf.org/html/rfc2617#section-4.6). The following threads have more info.
- [Delimiters for WWW-Authenticate for multiple schemes](http://stackoverflow.com/questions/10239970/what-is-the-delimiter-for-www-authenticate-for-multiple-schemes)
- [WWW-Authenticate header - multiple realms](http://stackoverflow.com/questions/3576197/http-authentication-www-authenticate-header-multiple-realms)

Since this is not common case, your only option is to override the `taskDidReceiveChallenge` which you already have. I don't think it's a good idea to add further support to Alamofire for this case since it is not only not recommended, but is also quite rare. Thankfully, you can already override the behavior by overriding the session delegate's task closure. This is exactly why they were opened up in the first place.

It is unfortunate that you need to replicate some of the logic, but that's certainly a better alternative for the community when you consider the 100s of use cases that are not common behavior. We're trying to keep Alamofire simple to use for the common cases, yet flexible enough that power users can customize everything that they need.

Best of luck.
  The reason that `NSError` was originally used was not allow any Alamofire users to have to switch on the error types coming out of Alamofire. Since most of the errors are `NSError` objects generated by the URL Loading System, we decided to keep all errors generated by Alamofire logic to be `NSError` objects as well to make it easier for the consumer.

With that said, we did not spend enough time considering the power user that is creating their own response serializers. I think it is a great idea to wrap up Alamofire errors and then your own custom errors into your own custom enum to make it easier for yourself at the app level. For anyone that is willing to go to those lengths, the Result type was restricting you from doing that in a Swift-like manner. Because of this, I've updated the Result type to now take an ErrorType in the Failure case in e489c5fe.

Thanks for the awesome feedback! üçª
  Hi @AndriyGo,

This may be helpful: https://forums.developer.apple.com/thread/3653.

Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

Best of luck!

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Thanks for pointing this out. Would you be willing to put together a pull request for this and verify that the code compiles?
 Thanks for all the info @thebluepotato. I've updated the README with slight changes to your example code in eabd1734.
  Please see #588 and #383. Cheers.
  Hi @mudithsilva,

Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

Best of luck!

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  I agree with your assessment...but unfortunately this is not something we can control. You're setting the headers on the NSURLSessionConfiguration which is not an Alamofire object, but part of Apple's URL Loading System. Additionally, this behavior works in certain cases, and not in others. This is why we make the blanket recommendation.

Another reason we recommend not setting a `Content-Type` header in this way is that it should be set on a per request basis. The parameter encoding enum also sets this value directly on the `NSURLRequest` in most cases.

We've also run into odd behaviors with whether this works as expected on certain versions of iOS. If you do end up need to set the header in this way, make sure to set the values on the configuration before you create the Alamofire `Manager` instance.
  Is the intention to be able to subclass the `ServerTrustPolicyManager` and override this method to be able to support things like wildcarded domain names? If that's the case, do we also need to open up the `policies` dictionary so you can access it?

``` swift
public private(set) let policies: [String: ServerTrustPolicy]
```
 Thanks for this @jriehn. I pushed your changes into the `swift-2.0` branch in 6c38ad01 and into the `master` branch in 8d659cc0. I also opened up the `policies` dictionary and added docstrings in subsequent commits.

Thanks again! üçª
  We will not be renaming anything in Alamofire due to some collision with another third party library. We cannot let other outside libraries, in which we have no control or influence, govern our naming conventions. That would be a poor policy for our users.

In this case, I would consider continuing to work the problem and think of outside the box solutions. What about the possibility of typealiasing the `Result` from `antitypical` in your project and using that instead? I'm sure there are other options as well.

Best of luck!
  We just added tests in 10f94788 to verify that this is working correctly for all types of session configurations on iOS 9. Everything is working as expected with only Alamofire. Please check out the logic in that commit and see where you may be doing something different.

Are you using any libraries that mess with `NSURLProtocol`s?
 Cool...glad you got it figured out! üçª
 Yes @ADevelopStudio, that approach would certainly mitigate this issue. I just wanted to verify with @pvegh that there was some implementation issue and that he wasn't experiencing an issue that we don't have tests for.
  Fixed in bf86ff50.
  I just added some tests in 10f94788 to verify that this is working as expected. The tests are passing without any issues on iOS 9. I currently have an Xcode 7 issue where none of my iOS 8 simulators are working so I can't verify the tests there.

Could you provide some additional details around your issue?
- Which version of Xcode are you using?
- Which branch, tag or commit are you build Alamofire on?
- How did you build Alamofire?

Also, you should be adding the headers to the configuration before you create the `Manager`.
 Thanks for pointing the issue out @tkrajacic. I fixed the issue in bf86ff50. The fix was terrible to get right. The `#available` checks are not working as expected and I had to switch over to using an OS predefine. If anyone else can find a better solution here I'm all ears.
 @Jeanblanc88 I'm glad you figured out your `manager` instance was not being retained. 

As for your issue now, using an ephemeral background session does not disable caching. It only switches it over to using in-memory caching. To disable caching, you should set the [URLCache](https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSURLSessionConfiguration_class/#//apple_ref/occ/instp/NSURLSessionConfiguration/URLCache) property on the `configuration` to `nil`.

I'm going to close this issue out since it has been resolved. If you have any further issues with the caching behavior, I'd encourage you to open a question on Stack Overflow.
  I just used your `Podfile` along with CocoaPods 0.38.2 and Xcode 7 beta 5 with no issues. I'm not sure where your problem stems from, but everything is working fine for me with all the info you have provided. I would also suggest you change your Podfile to the following:

``` ruby
platform :ios, '9.0'
use_frameworks!
pod 'Alamofire', '2.0.0-beta.1'
```
  Bitcode is enabled in both Debug and Release configurations for the watchOS target in the `swift-2.0` branch. I just built Alamofire on all three OS's using Carthage without any issues.

### Cartfile

``` bash
github "Alamofire/Alamofire" "swift-2.0"
```

### Carthage Version

``` bash
cnoon:~/Desktop/CarthageChecker$ carthage version
0.8.0
```

### `xcodebuild` version

``` bash
cnoon:~/Desktop/CarthageChecker$ xcodebuild -version
Xcode 7.0
Build version 7A176x
```

### `carthage update` output

``` bash
cnoon:~/Desktop/CarthageChecker$ carthage update
*** Fetching Alamofire
*** Checking out Alamofire at "9a1e321cf0a345b32142394446fa1a7e08cf6942"
*** xcodebuild output can be found in /var/folders/s7/qpm0b2pn3d56rjlpl7g3_4fh0000gn/T/carthage-xcodebuild.zLOTLA.log
*** Building scheme "Alamofire OSX" in Alamofire.xcworkspace
*** Building scheme "Alamofire watchOS" in Alamofire.xcworkspace
*** Building scheme "Alamofire iOS" in Alamofire.xcworkspace
```

If you continue to experience issues, I would suggest opening an issue with the Carthage project.
 Hi @Sljux, I just filed [Carthage 790](https://github.com/Carthage/Carthage/issues/790) which hopefully will help resolve the issue. I was able to reproduce the behavior you're seeing.
 It appears that you MUST have an iPhone + watch simulator set up in Xcode before you can use Carthage to compile the Alamofire watchOS framework. Not entirely sure why, but at least know we know how to solve the problem.

Please refer to [Carthage #790](https://github.com/Carthage/Carthage/issues/790) issue for more details.
  Thank you for your PR @yanke-guo. Could you provide me a good description of why you feel this change should be made? At the moment I don't feel this is a good change to make for the project.
 Okay @yanke-guo, I'm going to close this out.
  Thanks @ikesyo.
  We will officially release 2.0.0 when Xcode 7 goes GM. At that time we'll merge the `swift-2.0` branch into `master`. Cheers.
  Any mismatch has been fixed in the `swift-2.0` branch and the Alamofire `2.0.0-beta.1` release.
  `swift-2.0` branch is targeted for the latest beta (Xcode 7 beta 5). You would need to pin to the commit bbdd0f8833113d3a7ec08dda59107b41f205edbe or such for beta 4 support.
  Great point. I updated the documentation in aff4311e. Thanks for letting us know! üçª
  I would guess your `manager` instance is going out of memory. You need to keep a reference to it so it doesn't get deallocated.
 Cool...glad we figured it out!

I hesitate to put that in the documentation. Hopefully this Issue will help others catch the mistake. 
 Fair enough. I pushed 9a1e321c to address this. Thanks!
  You need to be on the latest commit on the `swift-2.0` branch on Xcode 7 beta 5. You could also use the `Alamofire 2.0.0-beta.1` release from CocoaPods. It WILL NOT work any other way.
 You need to be on the latest version of CocoaPods and also confirm your command line tools are set to Xcode 7b5.
  Of course! Here's how you would do it:

``` swift
Alamofire.upload(
    .POST,
    URLString: "http://httpbin.org/post",
    multipartFormData: { multipartFormData in
        multipartFormData.appendBodyPart(fileURL: unicornImageURL, name: "unicorn")
        multipartFormData.appendBodyPart(fileURL: rainbowImageURL, name: "rainbow")
    },
    encodingCompletion: { encodingResult in
        switch encodingResult {
        case .Success(let upload, _, _):
            upload.progress { bytesRead, totalBytesRead, totalBytesExpectedToRead in
                print(totalBytesRead)
            }
            upload.responseJSON { request, response, result in
                debugPrint(result)
            }
        case .Failure(let encodingError):
            print(encodingError)
        }
    }
)
```
  Could you please post your `Podfile`?
 Glad everyone figured it out! üëçüèº
  Answered on Stack Overflow.
  The `fileURL` is in your `destination` closure. You are providing the URL, so make sure to keep a reference to it so you can access it in your `response` closure.
  @schickling Can you share a bit more code, perhaps an example to reproduce this?
 @schickling You've used `responseJSON` thus it returns a failure if there is no JSON. You could use `response` if you are not looking for a JSON body.

https://github.com/Alamofire/Alamofire/tree/swift-2.0#response-handling
 Great question @schickling. 

You can no longer use the `responseJSON` response serializer if there is no data returned. That will fail `NSJSONSerialization` which will in turn return a `.Failure` result. As @kylef mentioned, the way to handle this case now is to use the default `response` method that does not leverage a response serializer or return a `Result` type. This was all by design. 

You should not be using a response serializer if you are not expecting response data from the server.
  This is a great question @krummler. 

We've been discussing this in our Slack channel and we've decided to leave it as is. It could be both a serializer or deserializer depending on which way you look at it. Given the history of this naming convention spans over 4 years from AFN and AF, we've decided to leave the name as is to avoid any confusion.

Thank you for posing the question. Cheers.
  This is exactly what should happen if the request was cancelled. You are not going to receive an `NSHTTPURLResponse` in the event of a cancellation because the request didn't succeed. You are also never going to receive a valid `string` object if the request didn't succeed because you didn't receive any data from the server.

Additionally, we have test cases verifying this behavior works as expected.
  Couldn't agree more. Thanks for pointing that out. Change has been made in 6f3c72ce.

Thanks!
  I'm not sure what this issue is trying to point out or ask. Please provide more description in your issues or they are just going to be immediately closed. All the documentation has already been updated for the `Result` type response serializer usage.
  Okay everyone, this Issue is your chance to help us shape the future of Alamofire! üî•üî•üî•

We've been knocking out all the obvious features and we've finally made it to the end of the have-to-have list. Now we'd like to reach out to the community to take feature requests. You have just as important of a role as we do to help us shape our next feature set.

Please understand that this is simply a place to gather feedback. This is by no means a promise that the ASF will end up implementing any of the suggestions here. I can assure you though that we will take each suggestion seriously and consider adding it to our Trello backlog. Please take some time to clearly articulate your feature request so we don't have to pry the information out of you. Clarity will certainly make it much easier for your feature request to make it into our backlog. üòâ

I'm super excited to see what everyone comes up with...happy requesting!!!
 Yep, thanks for the feedback so far everyone. The activity indicator is certainly a reasonable request.
 @tkrajacic the UIImage/NSImage functionality is already on the list and is currently one of our highest priorities. üëçüèº
 @nskboy that certainly would be useful. However, that would be an incredibly difficult feature to build without clobbering the public APIs. We'll have to put some serious thought into whether something like that would be doable at the core Alamofire level.
 Thank you for the example @nskboy. We are on the same page about a possible approach. My previous point was that implementing retrying logic with our current set of global convenience APIs is not going to be possible. We want to avoid adding any more additional parameters to the global methods.
 @adamkuipers there are not currently any plans, but it would certainly be worth an investigation. I'm curious if anyone has come up with a solution using curried functions, or have wired in something like BrightFutures or PromiseKit. 

If there is an elegant solution using curried functions, that could possibly be something worth adding into Alamofire core, but the others would certainly be implemented as component libraries to Alamofire.
 Thank you everyone for all your feedback. Here's a list of feature requests along with notes from our perspective.
- Add support for network activity indicator
  
  > This will need to be done carefully. There are MANY complex issues with getting this correct that we've had to fight on AFNetworking. We don't want to go down the same route as we did there, so this will be a bit tricky to get right. No firm commitment here, but we're certainly going to try to come up with a solution.
- Add support for UIImage/NSImage response serialization
  
  > This is already taking place! üëçüèº
- Add support for auto-retrying with progressive back-off
  
  > This will need some serious investigation as to how this could be implemented. No promises that we can make this happen, but we're going to look into it.
- Add support for future/promise based API
  
  > We really want to investigate using curried functions in Alamofire core. Anything tied directly to any of the promise/future based APIs should be built by the community. We will certainly investigate this though.

Again, thank you everyone for all your feedback!
 Just FYI...we just released [AlamofireImage](https://github.com/Alamofire/AlamofireImage)!
 No updates yet...still in our backlog.
 Yep, already on the list @lucatorella.
 There are no short term plans to implement this feature directly in Alamofire core @bvankuik.
  Hi @codecowboy,

Unfortunately CocoaPods doesn't support integrating into Command Line Tools (for a number of reasons). See https://github.com/CocoaPods/CocoaPods/issues/3707.
  Are you writing your own response serializer? Could you post some more logic? I'm trying to understand what you're trying to do to figure out whether we should open that method up or not.
 Thanks for the explanation gents. That was oversight on my part. I've opened up both `errorWithCode:failureReason:` methods in 85b90fe1. This should resolve your issues. üëçüèº
  :+1: from me.
 Thank you for your PR @mackuba. 

These changes are only to support iOS 7 and introduce compiler warnings into our main project. The Alamofire 2.0.0 release is going to drop support for iOS 7 altogether since we can't test it and give it the proper support it needs. Since we don't want to introduce warnings into the project, we're not going to be able to make this change.

Thanks again for the PR.
 It's not a necessary check if your deployment target is 8.0.
 We're dropping support for iOS 7 with the Alamofire 2.0 release. Therefore, we don't want to introduce fixes for iOS 7 that generate compiler warnings for iOS 8 and iOS 9 users.
  Pull down the latest commits in the `swift-2.0` branch. This issue has already been resolved.
 This is not an issue in the Alamofire 2.0.0-beta.1 release @Prince2k3. Nor is it an issue in the latest `swift-2.0` branch. Please please please update to the latest commit.
  Thank you for your PR @johndpope. I merged a modified form of your PR in 2bffaf1b giving you attribution. Thanks again!
 It works fine for me. I've migrated the example over to use all HTTPS calls which should play nice with ATS. Could you possibly provide more info and open a new PR if necessary? Could you check against the Alamofire 2.0.0-beta.1 release?
  Anywhere where the `Result` is available, the `NSHTTPURLResponse` is also provided. Therefore, if you are not passing the `response` around where you may need it, that is an implementation problem on the client side, not an issue with Alamofire. This is exactly why it was designed the way it was. 

There are MANY other things in the `response` that may be useful besides the `statusCode`. Therefore we don't want to make a special exception to the `statusCode`. Here's a quick example of how you should attempt to handle this issue.

``` swift
Alamofire.request(.GET, "https://httpbin.org/get")
    .responseJSON { request, response, result in
        switch result {
        case .Success(let JSON):
            print(JSON)
        case .Failure(let data, let error):
            print(response?.statusCode)
            print(error)

            callFailureMethod(response: response, result: result)
        }
    }
```

or

``` swift
Alamofire.request(.GET, "https://httpbin.org/get")
    .responseJSON { request, response, result in
        debugPrint(result)
        print(response?.statusCode)

        callFailureMethod(response: response, result: result)
    }
```

Best of luck!
 If you didn't successfully make a request to the server, you most likely won't have received an `HTTPURLResponse` back from your server. The easiest way to check is to always print it out:

``` swift
debugPrint(response.response)
```
 The `-1009` is **NOT** the response HTTP status code, it is the `Error.code`. These are two very different things. If you don't have an HTTP status code, you'll most likely have an Error code which will generally tell you why you didn't receive an HTTP status code.
  You need to update to Xcode 7 beta 5.
  Thank you for your PR @maxgoedjen. 

In this case I think this is not a good addition for Alamofire. You are duplicating the `value: T?` computed property functionality and also introducing a `throws` that isn't necessary which just adds unnecessary complexity. A `Result` type should never have to `throw`. If you really want to keep this type of functionality, you can always use it as your own extension on the `Result` type.

Thanks again.
  Everything works as expected with Xcode 7 beta 5 which is all documented in the README. 

If you are experiencing other issues, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

Best of luck.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Thank you for your input @calvintwr. We chose to use underscores to emphasize meaning and show intent just as @cristeahub mentioned. Since this is a VERY common pattern demonstrated all over the Swift language, we feel it is also a good pattern to use in the documentation in particular areas. If you are unfamiliar with the pattern, then I suggest you read up on Swift closures and usage patterns to get a better feel for what we're trying to demonstrate. Again, thanks for the feedback.

Cheers.
 Hi @calvintwr, thanks for the feedback. I definitely see your point, but respectfully disagree. We're not catering the documentation to users that are not familiar with Swift. I'd also discourage users from attempting to use Alamofire before getting familiar with all the ins and outs of the Swift language.
  Hi @Elmundo,

Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

Best of luck!

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Thank you for reporting @appsmonkey. I just pushed 61d6ddf9 that addresses this issue. Here's the output from just running against the following Cartfile.

### Cartfile

```
github "Alamofire/Alamofire" "fix/enabling_testability"
```

### Carthage Output

``` bash
cnoon:~/Desktop/CarthageChecker$ xcodebuild -version
Xcode 7.0
Build version 7A176x
cnoon:~/Desktop/CarthageChecker$ carthage version
0.7.5
cnoon:~/Desktop/CarthageChecker$ carthage update
*** Fetching Alamofire
*** Checking out Alamofire at "61d6ddf9c91da83a062cbe29dc6b7f6a0a5d8789"
*** xcodebuild output can be found in /var/folders/s7/qpm0b2pn3d56rjlpl7g3_4fh0000gn/T/carthage-xcodebuild.7T1Gz9.log
*** Building scheme "Alamofire iOS" in Alamofire.xcworkspace
*** Building scheme "Alamofire OSX" in Alamofire.xcworkspace
*** Building scheme "Alamofire watchOS" in Alamofire.xcworkspace
cnoon:~/Desktop/CarthageChecker$ 
```

Thanks again for reporting! I'm going to close this issue out. If you still have any issues, please comment on this issue and I'll gladly re-open it.

Cheers üçª
  Thank you for putting this together @mcudich...great work!

I merged a slightly modified version of your changes into a squashed commit in 62947d6d that still gives you attribution.

Thanks again! üçª
  Hi @henriquesobral,

You should try to override the following task override closure on the session to attempt to track down what's going on.

``` swift
/// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:`.
public var taskWillPerformHTTPRedirection: ((NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest) -> NSURLRequest?)?
```

You can set this closure by:

``` swift
let manager = Alamofire.Manager()
manager.delegate. taskWillPerformHTTPRedirection = { session, task, response, request in
    print(request)
    return request
}
```

That should at least help you debug.
 Hi @henriquesobral, if you could get back to me by the end of the weekend I would appreciate it. Otherwise I'm going to close this issue out. 

None of this behavior should be caused by Alamofire itself. Alamofire let's the redirection happen exactly as Apple intended while exposing the `taskWillPerformRedirection` closure to override the behavior as I mentioned before.
 I'm going to close this issue out. @henriquesobral if you end up finding the root issue is actually a problem with Alamofire, please comment on this issue and I'll re-open it. 

Cheers.
  Hi @ErickB14,

Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

Best of luck!

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  It works as designed. Please see this [thread](https://github.com/AFNetworking/AFNetworking/issues/179) for more detailed information.
  This is already in #616 along with including a target to actually build/test this. /cc @cnoon Are we plan to merge #616?
 Yep, I was planning on getting to #616 tonight @kylef. @neonichu thank you for your PR, but we're going to pull in all watchOS support through #616. Thanks again!
  This is most likely a bug in `AlamofireObjectMapper`, not in Alamofire itself. 

The Alamofire 1.3.0 release had a non-backwards compatible change that went into it which was documented in the [release notes](https://github.com/Alamofire/Alamofire/releases/tag/1.3.0). You are most likely running into a problem with the `AlamofireObjectMapper` that hasn't yet updated to match the response serialization changes in PR #593.

It was decided that it would be better to get the serialization change in before going to Alamofire 2.0. You are most likely one of the unfortunate ones that had their logic break due to this change.

What I would do if I were you would be to debug the simple case first. Try to pull out `AlamofireObjectMapper` and just make the requests with Alamofire 1.3.0 and print out the results. Make sure things are working properly. Then you'll know you've narrowed down the issue to `AlamofireObjectMapper`. Then you can dig into the response serializers in `AlamofireObjectMapper` and find the issue and submit a PR.

I'm going to close this issue out for now since we've never seen this type of behavior and I'm almost positive it's not an issue with Alamofire itself. If you do end up seeing the issue without `AlamofireObjectMapper`, please provide some more details (code samples) and I'll gladly re-open this issue and help you dig into it.

Best of luck! üçª
 Ah...that makes sense. I'm glad you solved it, and thanks for posting the solution here. Hopefully it helps someone else out that encounters a similar issue.

With that said, I would really like to discourage using any libraries in production facing apps that mess with Alamofire's underlying NSURLSession by using an `NSURLProtocol`. This is fine for things like stubbing, but the protocol usage does not respect all the properties of the session configuration which can cause some bad issues and strange behaviors. What you are reporting here is WAY worse than what I've seen so far. Therefore, I would keep your distance from something like `BigBrother` to ensure your networking logic doesn't go haywire.

Unfortunately I don't have an alternative at the moment to solve your activity indicator need. I can say though that we will be adding more support around UIKit most likely after the Alamofire 2.0 release. Until then, I'm afraid you're on your own in this area unless you want to roll the dice with something like BigBrother.
  Thank you @ikesyo. @cristeahub the documentation in the README for the `Result<String>` change is forthcoming.
  @abinop You should check if the result is a success, and then use the successful value or handle the failure.

``` swift
Alamofire.request(.GET, URLString, parameters: ["foo": "bar"])
    .responseJSON { request, response, result in
        switch result {
        case .Success(let JSON):
            print("Success with JSON: \(JSON)")

        case .Failure(let data, let error):
            print("Request failed with error: \(error)")

            if let data = data {
                print("Response data: \(NSString(data: data, encoding: NSUTF8StringEncoding)!)")
            }
        }
    }
```
  Hi @hadiz, PR #595 added support to directly access the `resumeData` on a download request. There are a couple of ways in which you can access the `resumeData`. The first is through the `data` object returned in the `response` serializer. It will automatically be populated with `resumeData` if `resumeData` is actually available. The second way is to directly access the `resumeData` property on the download request.

Both of these approaches are clearly demonstrated in the tests written in #595. The documentation for these updates is forthcoming.

Best of luck!
  Thanks @jankase...much appreciated!
  Thank you for your PR @jankase. I really hesitate to make this change because I feel it could be misleading to users to make a `Result<T>` conform to `BooleanType`. Here's a quick snippet that I put together to demonstrate why.

``` swift
func testResultConditionals() {
    let result1 = Result.Success("Testing")
    let result2 = Result<String>.Failure(
        NSData(),
        NSError(domain: Error.Domain, code: -1, userInfo: nil)
    )

    // Switching on cases
    switch result1 {
    case .Success:
        print("Result 1 is a success")
    case .Failure:
        print("Result 1 is a failure")
    }

    // Pattern matching in conditionals
    if case .Success = result1 {
        print("Success comparison works")
    }

    if case .Failure = result2 {
        print("Failure comparison works")
    }

    // Convenience methods
    if result1.isSuccess {
        print("Success check works...clear and concise")
    }

    if result2.isFailure {
        print("Failure check works...clear and concise")
    }

    // Leveraging `BooleanType`
    if result1 {
        print("Result conforms to BooleanType so it can be used like this...could be confusing")
    }
}
```

Could you make a more substantial case as to why you think it should be added? At the moment I'm leaning towards not making this change.

cc @kcharwood and @kylef...do you guys have an opinion here?
 I think I agree with @cnoon on this.

Apple discourage conforming to BooleanType when you're representing more than a simple boolean value, take a look at the [BooleanType protocol documentation](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Reference/Swift_BooleanType_Protocol/).

> Only two types provided by Swift, Bool and ObjCBool, conform to BooleanType. Expanding this set to include types that represent more than simple boolean values is discouraged.

This is interesting approach @jankase.
 Ah yeah I didn't check the docs. That totally makes sense @kylef. Thank you for the PR @jankase, but I'm going to decline this PR. Thanks again!
  It's right in the [docs](https://github.com/Alamofire/Alamofire#http-headers). We added custom header support into all the global APIs in the Alamofire 1.3.0 release. Now it's super easy to tack on any custom header that you need.

Best of luck!

### EDIT

Whoops, I didn't read your post close enough...apologies. In order to build the header from the request body, you have a few options. The easiest would be to use the `ParameterEncoding` enum to generate an `NSMutableURLRequest`, then compute and attach your `Authorization` header. Once you've added the header to your `NSMutableURLRequest`, you can pass that directly into any of the global `request`, `download` or `upload` methods.
  Thank you for your PR @jankase. Unfortunately, we will not be merging this change. Please see #525 and #554 for more information. 

Cheers.
  Hi @bruceflowers,

It's not an actual issue with Alamofire but is instead some problem with some other kind of setup. Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

Best of luck!

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  You just need to update to Xcode 7 beta 4 and all your issues will be resolved.
  We're not going to merge the `swift-2.0` branch into `master` until we're ready to release Alamofire 2.0 which will roughly coincide with the Xcode 7 GM release date.
  Could you try updating to the latest version of CocoaPods (0.38.2) and report back?
 Okay thanks for the info. This is still on my radar @johndpope, I just haven't had time to check it out yet. Should be able to get to this in the next couple of days. Stay tuned...
  Hi @dromerobarria,

You most likely need to use a background session configuration when setting up your `Manager` instance. Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

Best of luck!

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @4np, this is the Swift compiler giving you a VERY misleading error. The issue is actually in your `download` declaration. You are missing the `destination` parameter. We brought all the global `Alamofire` methods inline with the `Manager` methods which will cause these issues in certain places.

We also documented this issue in the [release notes](https://github.com/Alamofire/Alamofire/releases/tag/1.3.0) in the upgrade section at the bottom. Additionally, the logic is correct in the [sample code](https://github.com/Alamofire/Alamofire#downloading-a-file-wprogress) in the README.

In the future, when you have issues like this, please take your question to Stack Overflow as @cristeahub mentioned.

Cheers üçª
  This PR refactors the response serializers to leverage `Result` types and also creates customized validation errors to resolve Issue #447.
## Result Types

As I'm sure most people are aware, the double optional tuple scenario is Swift is a real problem resulting in us always having to check three cases even though there are really only two. `Result` types guarantee that you only ever have to account for the two situations.
### Previous Style

The major area of Alamofire that previously suffered from this issue were the response serializers. Here is an example of the previous pattern:

``` swift
Alamofire.request(.GET, URLString, parameters: ["foo": "bar"])
    .responseJSON { request, response, json, error in
        if let error = error {
            print("error occurred: \(error)")
        } else if let json = json {
            print("json response: \(json)")
        } else {
            print("something went really wrong b/c I didn't get json or an error")
        }
    }
```
### New Style

After several revisions, the new way of extracting response JSON will leverage a `Result` type eliminating the third case:

``` swift
Alamofire.request(.GET, URLString, parameters: ["foo": "bar"])
    .responseJSON { request, response, result in
        switch result {
        case .Success(let JSON):
            print("Success with JSON: \(JSON)")
        case .Failure(let data, let error):
            print("Request failed with error: \(error)")

            if let data = data {
                print("Response data: \(NSString(data: data, encoding: NSUTF8StringEncoding)!)")
            }
        }
    }
```

> The result success value is guaranteed to be returned as an actual value, not an optional. Additionally, in the case of a failure, the error is guaranteed and the original data returned from the server is returned as an `NSData` optional. All default response serializers have been refactored to ensure these cases are always upheld. The required reworking the error system in Alamofire.

There are also convenience computed properties on the `Result` type to make it really easy to check for things like a success or extract the success value out:

``` swift
Alamofire.request(.GET, URLString, parameters: ["foo": "bar"])
    .responseJSON { request, response, result in
        if let JSON = result.value {
            print("JSON Response: \(JSON)")
        } else {
            print("Error: \(result.error)")
        }
    }
```
#### Bonus Points

The coolest part about this set of changes is that the old `response` method was kept in tact. There are certainly cases where you may not want to use a response serializer, but you just want to hook into the `response` to know that the task delegate queue processing is complete. Therefore, the original `response` method still exists, but no longer includes a `responseSerializer` parameter. It simply calls the `completionHandler` immediately.

``` swift
public func response(
    queue: dispatch_queue_t? = nil,
    completionHandler: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Void)
    -> Self
{
    delegate.queue.addOperationWithBlock {
        dispatch_async(queue ?? dispatch_get_main_queue()) {
            completionHandler(self.request, self.response, self.delegate.data, self.delegate.error)
        }
    }

    return self
}
```

This allows you to simply tap into the completion of the task without running any extra processing as though you implemented the session delegate completion method directly.
## Validation Errors

Previously, if response validation failed, you simply received an `NSError` with a `com.alamofire.error` domain with a `-1` error code. This made it quite difficult to figure out whether content type or status code validation actually failed.

With the new structure, content type and status code validation have separate errors making it really easy to tell what actually went wrong.

``` swift
public struct Error {
    public static let Domain = "com.alamofire.error"

    public enum Code: Int {
        case InputStreamReadFailed           = -6000
        case OutputStreamWriteFailed         = -6001
        case ContentTypeValidationFailed     = -6002
        case StatusCodeValidationFailed      = -6003
        case DataSerializationFailed         = -6004
        case StringSerializationFailed       = -6005
        case JSONSerializationFailed         = -6006
        case PropertyListSerializationFailed = -6007
    }
}
```
## Summary

These changes should simplify the process of handling success and failure cases for responses. I would love feedback from the community here to see if there are any edge cases that I haven't thought of. Please keep in mind that we have MANY different edge cases to consider here before being to quick to recommend other solutions. As I mentioned earlier, this went through several revisions before being pushed up.
- There are data, download and upload tasks that the response serializers ALL need to support.
  - Downloads behave MUCH differently and don't return any data.
- You need to be able to access the original server data in the case that an error occurred.
- You want to avoid optionals at all costs in the case of a success or failure to avoid having to optional bind inside a switch.

Thanks in advance for taking a look!
 cc @kylef and @kcharwood 
 Okay, I'm going to merge this in. Thanks for the feedback @saniul and @kostiakoval!
 @cnoon This pull request doesn't update the examples/documentation in the README. Would you be able to do that in another PR? (re #641).
 Thanks for the heads up @kylef. I usually always do that as part of the original PR and this time I just forgot. It's definitely the next thing I'm going to work on. Should have it done today or tomorrow.
 Hey @kylef and @kcharwood, README updates for Result types are up in PR #648! üëçüèº
 The JSON error is going to be in the `.Failure` case of a result.
  Just tested everything with the exact setup.

### Carthage Version

``` bash
cnoon:~/Desktop/QuickTest$ carthage version
0.7.5
```

### xcodebuild version

``` bash
cnoon:~/Desktop/QuickTest$ xcodebuild -version
Xcode 6.4
Build version 6E35b
```

### Cartfile

```
github "Alamofire/Alamofire" == 1.3.0
```

### Carthage Update

``` bash
cnoon:~/Desktop/QuickTest$ carthage update
*** Fetching Alamofire
*** Checking out Alamofire at "1.3.0"
*** xcodebuild output can be found in /var/folders/s7/qpm0b2pn3d56rjlpl7g3_4fh0000gn/T/carthage-xcodebuild.RPRBhu.log
*** Building scheme "Alamofire iOS" in Alamofire.xcworkspace
*** Building scheme "Alamofire OSX" in Alamofire.xcworkspace
```

Everything builds exactly as expected. For further assistance, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Just ran the following...something you have configured is just incorrect:

### Carthage Version

``` bash
cnoon:~/Desktop/QuickTest$ carthage version
0.7.5
```

### xcodebuild version

``` bash
cnoon:~/Desktop/QuickTest$ xcodebuild -version
Xcode 7.0
Build version 7A165t
```

### Cartfile

``` bash
github "Alamofire/Alamofire" "swift-2.0"
```

### Carthage Update

``` bash
cnoon:~/Desktop/QuickTest$ carthage update
*** Fetching Alamofire
*** Checking out Alamofire at "5f2c29751b35069ec1452046e24dfba506cbc603"
*** xcodebuild output can be found in /var/folders/s7/qpm0b2pn3d56rjlpl7g3_4fh0000gn/T/carthage-xcodebuild.BUFS51.log
*** Building scheme "Alamofire iOS" in Alamofire.xcworkspace
*** Building scheme "Alamofire OSX" in Alamofire.xcworkspace
```

Everything builds exactly as expected. For further assistance, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

Good luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
 Cool, glad to hear it! Thanks for posting your issue and the solution. üëçüèº
  Yep, you'll need to update to Xcode 7 beta 4 to use the latest commits in the `swift-2.0` branch.
 Try to run `pod update` again. I pushed a fix for this problem yesterday in fb8c54c86944516d0b838a33205d3a8e9809e539 that you may not have picked up.
  Hi @BasThomas,

Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
 @jonauz you need to use the `.URLEncodedInURL` to encode the parameters in the `URL` for a `POST`.
  Now that is an awesome catch! Thanks for letting us know @unusuallyreticent. I just pushed 5f2c2975 to fix this issue. Thanks again for letting us know!
  Thanks for this @pcantrell. I just pushed a modified version of this change in fb8c54c8 with attribution to @robrasmussen. Thank you so much for helping out with this!
  This seems like an unnecessary addition to me because backwards compatibility is still maintained. For example, there is not any issue that I'm aware of with the following code block:

``` swift
import Foundation

func URLRequest() -> NSMutableURLRequest {
    return NSMutableURLRequest(URL: NSURL(string: "")!)
}

let request1: NSURLRequest = URLRequest()
let request2: NSMutableURLRequest = URLRequest()
let request3 = URLRequest()
```

Am I missing something obvious?
  Thank you for reporting @jeeftor. We're aware of the issue and are tracking it in #610 (thanks @ikesyo). Please redirect all further comments to that ticket. I'm going to close this out as a duplicate.
  Hi @cvlntn, clean all, wipe derived data, etc. You're running into common Xcode issues.
  Nice...thanks for this @tomco. I have a few other things that I'm working on completing in Alamofire at the moment but I'll get to this as soon as possible!
 Thank you for all your hard work here @tomco! I squashed your PR, tweaked it slightly and pushed it into the `swift-2.0` branch in b4cb7cc3 giving you attribution. Great work!

Cheers üçª
  Great question...totally possible already. You need to use the `URLRequestConvertible` in combination with an `NSMutableURLRequest` to override the `cachePolicy` for that particular request. Check out the documentation and you'll see what I mean.

Here's an example of a test that creates an `NSMutableURLRequest` and customizes it before starting a `Request` with it.
- https://github.com/Alamofire/Alamofire/blob/swift-2.0/Tests/ValidationTests.swift#L238-L260

Cheers üçª
  Closing this issue out. Please update to Xcode 7 beta 4. Cheers üçª
  Hi guys, could you please provide more info? Screenshots, configuration build, platform, etc.
 Cool, thank you for posting that @dickwu. Your issue is the same reported in #610. I'm going to close this issue for now. If you could redirect all comments to that issue, I'd appreciate it.

Cheers üçª
  Thanks for the PR @corinnekrych...merged!
  Thanks @ikesyo!
  This is exactly why I hate disabling Travis CI. We would have caught this if there was an Xcode 7 build. Either way, I have a completely packed day so I won't be able to look into this until this evening.

Could anyone else take a stab at figuring out what's causing the root issue?
 So @robrasmussen definitely wins the rockstar badge for the day! Thank you for tracking this down!

I pushed a modified version of #621 in fb8c54c giving attribution to @robrasmussen for the change. I have also filed [rdar://22024442](http://openradar.appspot.com/radar?id=6082025006039040) which I would encourage everyone to duplicate to help get this resolved.

You can now compile Alamofire in both Debug and Release on iOS and OS X without any issues. Hopefully this resolves the issue for everyone. If not, please comment on this issue and I'll re-open as necessary.

Again, thanks to everyone for helping out! üçª
  Hi @robskillington, as far as I can tell, these changes have already been made and are available in the `swift-2.0` branch. I thought I had already cleaned this all up. Looks like it all was changed in 78f155d8. Could you please confirm?

I'm not exactly sure why it's showing the diff b/c those changes have already been made in the branch your submitting the PR against. Seems strange to me.
 Okay, your changes are completely valid and definitely need to occur. However, it appears to me that everything has already been changed. Check out the code [here](https://github.com/Alamofire/Alamofire/blob/swift-2.0/Source/ServerTrustPolicy.swift#L161-L219) that is the current form of the evaluate method in the `swift-2.0` branch. You'll see that the changes are already in there.
 I feel like you're probably running into some out-of-date upstreaming issue.
  You would need to do it directly inside your `responseObject` implementation. If `data` is `null`, then your `responseObject` will be returned as a `nil`. If you do have `data`, then you attempt to parse it and return your fully initialized object if parsing was successful.
  Hi @SwiftFire,

The behavior works correctly. We have tests confirming this. The issue you are running into has been asked and answered many times before. Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

Best of luck.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @Kam21,

Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

Cheers.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Sweet...thanks @fewspider!
  Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Against which device and/or simulator?
 @BilalReffas please don't randomly post questions in already filed issues. You can either reach out to us on Twitter @AlamofireSF or open a new issue.
 Hey @zgosalvez I just figured out your issue. You cannot use the `feature/server_trust_policy` branch in Xcode 7 beta 3 because those changes do not yet support Swift 2.0, nor does that branch contain any of the Swift 2.0 changes that have been made in the `swift-2.0` branch.
 Well given that information you'll just have to figure it out on your own for now until we officially move it over for you. We should have that done in a week or so. Best of luck!
  You're running into [ATS](https://developer.apple.com/library/prerelease/ios/technotes/App-Transport-Security-Technote/). You can't use the HTTP protocol directly out of the box in iOS 9. Check out this [link](http://www.neglectedpotential.com/2015/06/working-with-apples-application-transport-security/) to resolve your issue.

Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  I will once the 1.3.0 release is completed. We're VERY close to wrapping it. I would assume the 1.3.0 release will go out in the next few days. You can always check out the [milestones](https://github.com/Alamofire/Alamofire/milestones) page for more info.
  The webpage reflects the current version in `master`. If you want the README for the 1.2.3 release, then you need to check out the README for that release.
  This PR hopefully addresses Issue #510.
## Quick Problem Summary

The issue is described in detail [here](https://github.com/Alamofire/Alamofire/issues/510#issuecomment-112581617). The validation is failing if no `Content-Type` comes back in the response.
## Reproduction Attempts

I tried every http://httpbin.org trick in the book to recreate the issue they are seeing in #510, but was unsuccessful. I cannot trick the `NSHTTPURLResponse` into be so confused that it cannot guess what the `MIMEType` is. It always comes back valid. I would really like to have a test around this change, but just can't seem to get httpbin to do my bidding. If someone could provide a test, that would be amazing!
## Solution

The solution here seems pretty simple. A wildcard accept type `*/*` should always pass validation whether a `MIMEType` exists on the response or not. The current implementation will only pass if the MIMEType on the response is valid. Therefore, my change just adds a small condition that allows `Content-Type` validation to succeed if one of the acceptable content types was `*/*`. Additionally, I can't see any downsides of this change.

Since I can't get a test around this change, I'd love it if @allaire and/or @MartinRogalla could confirm that this change does in fact fix the issue they reported in #510.
 cc @kylef and @kcharwood 
 Thank you @allaire...much appreciated!
 Thank you for confirming @allaire! That makes me feel much better about this change. I'm going to go ahead and merge it.

As for your question about stubbing it, that's a pretty difficult thing to do that will require a custom `NSURLProtocol` which has all sorts of weird behaviors with `NSURLSession`s. Additionally, the validation gets registered as a closure into the task delegate queue which runs after the request completes, thus just making it difficult to simulate.

Once we have spent some time working through stubbing requests with Alamofire, it will make this a much easier thing to simulate. Until then, I'm just going to throw a ticket into our Trello project and we'll get to it later.

Thanks again for all the diligence...apologies for it taking a month for us to get it fixed.
 Hi @Jirka1111, if you are having a problem, please open a new issue and link back to this one if it is in fact related. I'm very confident in this change as well as being having it verified by @allaire who helped debug this issue for weeks.
 @Jirka1111, please take your question to Stack Overflow. I'm almost certain you just have an issue with the way you're formatting your request. This [thread](http://stackoverflow.com/questions/25986129/cocoa-error-3840-invalid-value-around-character-0-afnetworking) may help shed some light.
 @Jirka1111 please be a bit more mindful of our time. We point you towards Stack Overflow when we know there's not an issue with the library but instead an issue with your code. It's purely to allow the community to help us with support questions. If we just sat and answered support questions, we'd never have time to work on moving the library forwards.

With that said, you are not receiving a 204 but instead of 404. You are most likely not hitting the server properly. You need to use cURL debugging or some other form to figure out where your issue lies. Please  do not continue to seek advice through this closed issue.

Best of luck.
  Thank you very much for all your hard work here @forgot!

I'm very sorry but I need to decline this PR. I don't want anyone else picking up all these changes without them having been made by our TC. I want to go through each of the new features that have been added for the 1.3.0 release one-by-one to make sure they get ported properly.

With that said, I ensure you that this work is forthcoming. We're very close to wrapping the 1.3.0 release and this will be the very next thing we pick up.

Thank you for your patience...and apologies for declining. I don't like to flat out decline PRs...but I think it's the best course of action for Alamofire and the community for time being.

Cheers üçª
 In the future, before you take on such a large chunk of work, please reach out to us through our [@AlamofireSF](https://twitter.com/AlamofireSF) twitter handle or open an issue asking for guidance from the TC as to whether to proceed. That would have given us the opportunity to let you know our thoughts before you went to all the work.
  This PR addresses three issues:
1. When uploading `MultipartFormData` where appending body parts would fail, the encoding would succeed and the upload would take place without the failed body parts.
2. Added a method for appending body parts with data, name and mime type.
   
   > See #591 and #555 for more details.
3. Added a completely open `appendBodyPart(stream:length:headers:)` method that allows you to append any kind of data with any type of headers you wish.
## Problem

The upload methods for `MultipartFormData` are very convenient and make it very easy to construct the data and upload it. The problem though is that the file URL methods will return an error if something goes wrong when creating the `BodyPart`. This is a very easy case to forget to handle. Even worse, the encoding does not realize there was an error and will continue onwards.

For example, say you had the following logic:

``` swift
Alamofire.upload(
    .POST,
    URLString: "http://httpbin.org/post",
    multipartFormData: { multipartFormData in
        multipartFormData.appendBodyPart(fileURL: unicornImageURL, name: "unicorn")
        multipartFormData.appendBodyPart(fileURL: rainbowImageURL, name: "rainbow")
    },
    encodingCompletion: { encodingResult in
        switch encodingResult {
        case .Success(let upload, _, _):
            upload.responseJSON { request, response, JSON, error in
                println(JSON)
            }
        case .Failure(let encodingError):
            println(encodingError)
        }
    }
)
```

If `rainbowImageURL` is not a valid URL, appending the body part will actually return an error, but the encoding succeeds and only the unicorn image is uploaded to the server. This is very problematic and needs a better solution.
### Solution

Since it is clunky to have to handle the error each time you append a body part, I chose to handle the error internally and bubble it up when encoding takes place. What this means is that in the above example, you don't need to check if appending each body part succeeds or not, you just need to handle whether encoding succeeds which the `upload` methods already do for you automatically.

Another advantage is that encoding will fail immediately if there was an issue appending any of the body parts. This approach seems like the best way to solve the problem. Even when moving to Swift 2.0, we won't want to have to `try` each time we try to append a body part. It's much easier from the user's perspective to bubble up the error at the time of encoding.

We could also use both approaches and still return an error optional for the file URL methods, but that seemed redundant and not optimal.
 cc @kylef and @kcharwood 
 @Samback there is not. We'll port all the 1.3.0 changes over to the `swift-2.0` branch once we cut the 1.3.0 release.
 You'll have to roll your own @Samback for the next week or so if you absolutely have to have it now, or you'll need to use AFNetworking. There are some posts on Stack Overflow explaining how to put together a quick and dirty approach to generating the boundaries manually. Otherwise, I'd recommend you just hang on a bit longer.
  This PR adds much better support for resume data with regards to download requests to address #141.
## Problem

Previously, there were only two ways to get resume data out of a request.
1. Cancel the request using the `Request.cancel()` method and retrieve the resume data from the `AnyObject?` in the `response` method.
2. Extract the resume data from the `error` returned in any of the `response` methods from the `userInfo` dictionary using the `NSURLSessionDownloadTaskResumeData` key.

The downsides to this is that you could only get direct access to the resume data by canceling the request. It would never be directly returned in the `response` method if it was interrupted by say a loss of network connection. Additionally, you could only ever access the resume data in the `response` parameters through either the `data` parameter in the event of a cancelled request, or through the `error` by digging the data out from the `userInfo` dictionary. This made it impossible to fetch the resume data without the use of the `response` serializers.
## Solution

To improve the resume data support, I made a couple of key changes that should make it MUCH easier to work with resume data.
1. For any failed download request, the resume data is automatically extracted out of the `error` object if it is available.
2. Added a `resumeData` computed property on the `Request` to allow you to access that data outside the `response` serialization methods. For example, you can now access the `resumeData` in any of the chained `Request` methods if you so choose.
   
   > This change coupled with the changes in #590 should give you complete customization control of the behavior of download requests and how the serial queue executes after completion.

I also added several tests around this behavior to demonstrate the usage and verify the behavior.
 cc @kylef and @kcharwood 
  You are most likely running into an issue with [App Transport Security](https://developer.apple.com/library/prerelease/mac/technotes/App-Transport-Security-Technote/index.html) (ATS) introduced in iOS 9. Here's an [article](http://www.neglectedpotential.com/2015/06/working-with-apples-application-transport-security/) that details how to workaround your issue.

> Please note that we do not encourage disabling ATS in any fashion. That should always be a last resort.
  This PR addresses issue #296 by refactoring the response serialization logic to leverage the power of generics. With the addition of the `ResponseSerializer` protocol and the `GenericResponseSerializer` generic struct, it is now much easier to work directly with value types as well as get the actual type returned directly rather than having to cast the `AnyObject`.
## Improvements
- The four default response serialization methods now all return the most applicable type directly instead of an `AnyObject`. You no longer have to cast the result from an `AnyObject?` to `NSData`...Alamofire now handles this internally using generics.
  > JSON and PropertyLists still return an `AnyObject` since that is the most applicable type in those cases.
- Custom response methods can now support generic types directly without having to cast the result of the underlying `response` method implementation.
## API Changes

The coolest part about these changes is that they have almost the exact same public API. As you can see from all the test logic, the high level functions that everyone is consuming remain unchanged. The only difference is if you are using the underlying `response` method. In this case, the `serializer` parameter has been renamed to `responseSerializer` for clarity purposes.

Since the underlying `response` implementation previously returned an `AnyObject?`, those implementations will still "just work". What it will result in is that you will no longer need to cast the serialized object being returned.
 cc @kylef and @kcharwood 
  I've been using it in multiple projects and everything works properly. Here are a few troubleshooting tips:
- Make sure you have the latest version of Xcode 7 beta 3
- Update CocoaPods to the latest pre-release version
- Clean the project
- Wipe DerivedData
- etc. etc.

---

Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @chrisco314, first off, my apologies for not replying to your Stack Overflow question. I've been focusing mainly on the 1.3.0 release and haven't been able to spend as much time on Stack Overflow as I would like. 

With that said, I'm fairly certain you should be able to do this already without any changes to Alamofire. Would it be possible for you to test a theory for me? Could you try to upload some JSON data to your server using the following approach?

``` swift
multipartFormData.appendBodyPart(
    fileData: data, 
    name: "name", 
    fileName: "filename.json", 
    mimeType: "application/json"
)
```

I'm fairly certain this method should do "exactly" what it is you are looking for. I'm also curious if your variation is the exact same call minus the `filename` argument in the `Content-Disposition` header. We've had a similar issue opened in #569 but we never heard back from @top2tech. 

If you could verify whether that method works for your case that would be great. Additionally, it would also be useful to know if you are finding that the `filename` argument is optional. I'm having a difficult time determining from the RFC specs whether the filename is optional or not.
 Okay @chrisco314, let's take a step back for a sec.

I need you to help me diagnose the problem you are having before I'm going to consider redesigning the APIs. Could you please answer my original questions? Can you directly pass in your `mimeType` to the following method and still have it work? If not, could you please walk me through why?

```
multipartFormData.appendBodyPart(
    fileData: data, 
    name: "name", 
    fileName: "filename.json", 
    mimeType: "application/json"
)
```
 Okay, so if I boil down your extremely verbose set of multiple answers, you are able to do what you need with either of the following methods:
- `appendBodyPart(fileData:name:fileName:mimeType:)`
  
  > If you provide a dummy `fileName` value
- `appendBodyPart(data:name:)`
  
  > If you override it and add a `mimeType` argument that would append a `Content-Type` header

As an initial takeaway, I'd say the `appendBodyPart(data:name:)` method most likely needs an optional `mimeType` parameter which will add the `Content-Type` header to the body part if it is passed in. That would certainly solve your main issue.

---

As for your proposed API changes, I really appreciate your feedback! 

When designing the current implementation, the one thing that didn't feel exactly right was the fact that you can easily bury the errors that occur when appending a new body part if you aren't careful. Only some of the methods can actually fail, but if they fail without you handling them, your body part won't make it up to the server.

As for providing the closure in the `upload` method, that is simply to be able to create the data inline with the rest of the request. I'll consider adding another alternative API where you pass the `MultipartFormData` object in directly rather building it on the fly with a provided closure.

Overall, you have piqued my interest here so I will probably be making some changes to address some if not all of these issues. Once I push up a PR I'd appreciate some more feedback if you have time.

Cheers üçª
 Okay @chrisco314, I just pushed up PR #596 which addresses all the issues presented in this ticket. Please check it out and redirect all further comments to #596.

### Proposals Implemented

I took about half of your suggestions in this ticket and implemented a variation of them. 
- Added an `appendBodyPart(data:name:mimeType:)` method which solves your root issue. 
- Added a base method that everything calls through that is completely wide open allowing for headers like `Content-Transfer-Encoding`. 
- Now internally tracking a body part error that is bubbled up immediately during encoding. This eliminates the possibility of uploading something to the server that is missing a body part.

### Proposals Not Implemented

Some of the suggestions that I did not incorporate were:
- Reordering the parameter names
  
  > The parameter names begin with either `data`, `fileURL` or `stream` to make it easier to work with autocomplete to narrow down your choices. Starting with `name` makes it difficult to pick out the one you are looking for. While I completely understand your logic, I disagree that this would be the best course of action.
- Variadic Initializer and/or Chaining Optionals

> Both of these approaches make the APIs clunky and more difficult to use IMO.
- Multiple Enumerations and Chained Headers
  
  > This approach presents way too many ways for users to make mistakes. It also does not provide any flexibility since you cannot customize the behavior by extending enumeration cases.

### Summary

Alamofire is intended to provide very clean, robust APIs to make networking easy, yet be flexible enough to allow users to customize any part of the networking stack, thus supporting a range of experience from novice to expert. Therefore, some of your suggestions aligned very well with our overalls goals which is exactly why they were implemented.

Thanks again for all your efforts here...Alamofire is certainly better for it!

Cheers üçª
 Hi @pavm035, multipart/mixed uploads are not supported at this time.
  There are a couple of changes here. 
## Removal of respondsToSelector

The first was to remove the `respondsToSelector` override in the `Manager` class. The only reason I could come up with as to why they were there in the first place was that the original `SessionDelegate` override closures were internal. Having this override would allow clients to "peak" into whether or not those internal closures were set. Since the override closures are now public themselves, this logic no longer seems necessary.

> If anyone can think of a good reason as to why these shouldn't be removed...please comment on this PR!
## Opening the TaskDelegate Queue

I originally set out to open up the `TaskDelegate` APIs completely. After a deep investigation of the way the task delegate override closures are implemented and abstracted, I think it's best to leave them as they are. They are extremely well designed and provide an amazing amount of abstraction that can be overridden by the `SessionDelegate` closures. If a user really needs to customize the default behaviors, the `SessionDelegate` override closures should be used instead. Opening the `TaskDelegate` override closures would not only be redundant, but I'm afraid it would open up an abundance of confusion to the general user.

With that said, there is still an opportunity to allow users to implement custom behaviors on the `TaskDelegate` queue. At the moment, you cannot customize any `Request` operation logic until one of the `response` serializers are called. This is problematic if you need to run any other operations prior to this. For example, if you wanted to run some pre and post operations around validation, you couldn't do so.

Because of this, I opened up the `TaskDelegate` and `queue` to allow for customization. I also added some unit tests around this behavior to ensure it works as expected. This should give users ultimate flexibility without exposing hardly any of the internal API. Win win win. I'm excited to see what users will end up doing with this new found freedom! üòÅ
 cc @kylef and @kcharwood 
  There is no error in the implementation. There is no spec around URL collection encoding and therefore Alamofire implements a [best practice approach](https://github.com/Alamofire/Alamofire/blob/master/Source/ParameterEncoding.swift#L48-L51). If your server expects a different syntax, please use the .Custom `ParameterEncoding`.
 @muzammil-hussain you should take Rob's advice in that thread and switch over to JSON. If that cannot be done in your case, you should implement a `.Custom` parameter encoding. Collections with URL encoding are not supported in an RFC spec and thus is not an encouraged practice. Finally, AFNetworking is simply another slightly modified version of the URL parameter encoding and is not a more accurate version of URL encoding even it is works with your server.
  Thanks for the suggestion @msanders! Would you be willing to take a stab at implementing this? Or anyone else that's a big Carthage fan?
 So after chatting with @kylef, we agreed that this is not something that we are going to support. Apple specifically recommends in the following article not to distribute 3rd party frameworks since they are tied to the specific version of Xcode and Swift.
- [Access Control - Apple Swift Blog](https://developer.apple.com/swift/blog/?id=5)

> Developers building frameworks to be used across their projects need to mark their API as public. While distribution and use of 3rd-party binary frameworks is not recommended (as mentioned in a previous blog post), Swift supports construction and distribution of frameworks in source form.

We want to support Carthage as much as possible while still ensuring the integrity of our releases. By not deploying prebuilt frameworks, we guarantee that an Alamofire release will continue to work even when the next version of Xcode and/or Swift drops.

> This is of course assuming the Swift enhancements still compile.
 I do not. I'll defer to @kylef here. He's really our running expert on frameworks and distribution.
  Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  This PR contains several changes:
1. Modified internal `URLRequest(method:URLString:)` method to accept an optional `headers` dictionary and also made the return value an `NSMutableURLRequest` to make it easier to work with.
2. Extended the `request`, `upload` and `download` methods on `Manager` to accept an optional `headers` parameter.
3. Extended the global `request`, `upload` and `download` methods to accept an optional `headers` parameter.
4. Modified the global `upload` and `download` method external parameters to match the `request` method structure.
5. Added initialization tests for `request`, `upload` and `download` methods to ensure we can now create requests with and without custom headers.

This has been a feature that has been requested by a large portion of our community. Please see the following issues for more info: #27, #32, #99, #111, #113, #119 and #490.
 Awesome! Thanks @kylef! üëäüèº
  The `upload` method in this case cannot directly return the upload `Request` object. It is available in the `encodingResult` object. You need to attach your `progress` closure to the `upload` object that you are extracting from the `.Success` case of the `encodingResult`.
  Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  You are absolutely right @mcudich. We are trying to finish up the 1.3.0 release before we starting porting all the changes over. There are some major features (MultipartFormData included) that will require a significant amount of work. We will start moving the changes over to the `swift-2.0` branch as quickly as we can.
  It definitely does. Please read through the [URL Loading System](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html) for more info.
 There is no support for this type of behavior nor do we have any plans to support it. Could you explain your use case a bit more so we could have a better understanding?
 Okay so let me clear this up a bit. For those of you that want to download in this manner, you'll need to roll the implementation on your own using [Range headers](http://httpwg.github.io/specs/rfc7233.html#range.requests). This will only work if the server you're trying to hit actually supports the `Range` header. If yes, you should be able to run several partial downloads in parallel. The number of downloads you can run in parallel will be capped by the total simultaneous downloads supported by the URL session configuration.

With that said, I seriously question whether this would be any more performant than using a single TCP socket to the server with resume data. The only case I can think of that it would would be the server capping the bandwidth on a single TCP socket. Not sure if that's common practice or not. If anyone has more info there I'd love to hear it!

Also, as mentioned before, I don't think this is something we'd like to support in Alamofire or AlamofireImage.
  This PR adds the ability to evaluate the validity of the TLS handshake in many different ways. It is not 100% complete, but is getting very close. I wanted to push it up to gather feedback from everyone before I finalize all the public docstrings and add documentation to the README (which will be extensive).
# Features

There are a whole bunch of new features added in this PR. I'll try to break down each of them one-by-one.
## Evaluation Policies
### Evaluation Policies per Host

Since different servers and web services have leaf certificates, intermediate and even root certificates, it is important to have the flexibility to specify evaluation policies on a per host basis. Otherwise, wouldn't be able to do things like use default evaluation for `host1`, certificate pinning for `host2` and public key pinning for `host3`.

The new `ServerTrustPolicy` enumeration and `ServerTrustPolicyManager` class help make this happen. You specify a policy for each host and Alamofire will handle the rest.
### Default Evaluation

The session delegate and task delegate did receive challenge callbacks both still use the `.PerformDefaultHandling` auth challenge disposition by default. This guarantees that anyone using Alamofire without a custom `ServerTrustPolicy` will get the Apple's default evaluation behavior. Therefore, you aren't getting any kind of custom behavior unless you actually specify you want it.

Here's a list of the custom types of things you can do with the new `ServerTrustPolicy` enumeration:
- The `.PerformDefaultEvaluation` case allows you to control whether you want to use host validation for the challenge. This could be helpful if you have a certificate with a DNS Name that doesn't match the host. It is certainly recommended though to ALWAYS validate the host.
  
  > We recommend that you always validate the host.
- You can now disable evaluation for a given host using the `.DisableEvaluation` case. This can be very helpful for self-signed certificates in development environments.
  
  > We would strongly advise against ever using this in a production environment.
- The `.CustomEvaluation` case allows you to provide an evaluation closure for your host to determine whether the challenge should be authenticated or not. This is syntactically much easier and safer to do than using the session and/or task delegate override closures. This also allows you to get all the default behavior for any other auth challenge type such as basic auth.
## Certificate Pinning

Certificate pinning is a useful way to guarantee that a certificate chain is not only valid, but also includes a certificate that you have provided. This is very helpful in mitigating a MITM attack. Here are some additional notes:
- You can provide multiple certificates for a given host. Each certificate is used as an anchor certificate in the evaluation of the server certificate chain.
- You can control the host validation as well when pinning certs.
## Public Key Pinning

Public key pinning has some additional advantages over certificate pinning. Public keys can be reused between different certificates after they expire. This makes it much easier to deal with revocation dates. The `ServerTrustPolicy` supports public key pinning and has some pretty powerful customizable options.
- Pin one or multiple public keys to a given host. This allows you to specify backup keys that can be used just in case your current keyset gets compromised.
- You can control whether host validation is ON or OFF.
- You can also specify whether to allow invalid certificates or not. This can be very useful in certain situations such as you have an expired leaf certificate or an intermediate certificate is missing.
  > These issues should be resolved on Production environments. We recommend using public key pinning in combination with host validation and full certificate chain evaluation.
#### Where's my SPKI (Subject Public Key Info) Pinning?

We are working very hard to make this happen, but it will not be part of this original feature set. Apple does not expose the SPKI through the Security framework which means we can't extract that chunk of data directly from the certificate data. In order to implement this, we're considering rolling our own DER decoder to do this on-the-fly. AFNetworking has already made some good progress on this front. Regardless, we won't add this feature unless we're 100% confident in our implementation. Please stay tuned. The TC is all over this.

---
## Tests Tests and More Tests

So I wrote more tests than I can possibly imagine. To give you a rough idea of how many tests I wrote, all the logic to support the `ServerTrustPolicy` is about 250 lines and the tests are ~1600 lines long. I'm sure there are still many more tests that I could write as well. Check out the `ServerTrustPolicyTests` and `TLSEvaluationTests` for more info. 

> Seriously...check it out. We need to make sure we have every possible case accounted for.
## Sidenotes
- The `NSURLSession` extension ended up being a MUCH cleaner approach than I originally had. It's fairly tricky to make the server trust policies available to the session and task delegate callbacks without any of them knowing about the `Manager`. It's great design, but presented some issues when trying to gracefully share around the server trust policies with everyone that needed them. The extension ended up being a nice way to pass it around since all the callbacks pass the `NSURLSession` in as an argument. Win win.
## TODO Before Merging
- [X] Gather feedback from the community
- [X] Finalize the public docstrings
- [X] Add section to the README covering `ServerTrustPolicy` usage

---
# Questions For You

So with this large of a change, I'm looking for the community to help give me some feedback. Security is VERY difficult to get right, and a ton of effort has gone into this original PR. However, that doesn't mean that it is all the way there. Please help me dig through this PR with a fine tooth comb so we can get all the issues ironed out before it gets merged. Here are a few questions I have for everyone.
- Are the `ServerTrustPolicy` cases clear? I have written over 10 variations of them and these were the ones that I felt were most clear.
- How about `ServerTrustPolicy`? I wanted to make sure it was specific to dealing with server trust auth challenges. I also wanted to remove SSL or TLS from the name to avoid confusion. I don't want to have to close out issues asking for us to add SSL pinning just b/c we named our APIs TLS something or other.
- What tests am I missing? I feel like I did a pretty solid job of covering all the possible cases for `ServerTrustPolicy`.
  - How about for TLS evaluation?
- Should certificate pinning have the option of `allowInvalidCertificates`? At the moment this is something that I didn't support, but I'm looking for feedback.

Thank you everyone as always for helping out!
 cc @kylef, @kcharwood
 I agree @vkedwardli. Thinking through it more it did seem to be a validate case. Support added in a1ea7318.
 I just pushed up another set of commits that completed the following:
- Refactored `allowInvalidateCertificates` to `validateCertificateChain` to be much more inline with the `validateHost` naming convention.
- Added ability to set whether to `validateCertificateChain` for certificate pinning.
- Added a bunch of tests around the new behavior.
- Added public docstrings for all public APIs.
- Added a Security section to the README.

At this point I feel really good about this set of changes. This should be good to go pending a full review from the TC.
 Thank you for the feedback @zgosalvez. 

I definitely thought about the use case of using a custom `ServerTrustPolicy` with the `Alamofire.Manager.sharedInstance`. The reason I chose not to support it is that you are always fighting a potential race condition. By opening up the ability to modify the `serverTrustPolicyManager` instance on the `session`, people could change this out while `Request`s are running which causing various threading issues.

I also think that if someone is going to go to the effort of setting up a custom `ServerTrustPolicy`, they are probably not using the `Alamofire.Manager.sharedInstance` object. They are most likely configuring a custom `Manager` instance anyways to change the default behavior such as using a custom `NSURLSessionConfiguration`.

I'll continue to think on this some more, but I'm definitely in the camp of not supporting this for now.
 Hi @crewshin,

Directly from the README updates in this PR:

---

### Security

Using a secure HTTPS connection when communicating with servers and web services is an important step in securing sensitive data. By default, Alamofire will evaluate the certificate chain provided by the server using Apple's built in validation provided by the Security framework. While this guarantees the certificate chain is valid, it does not prevent man-in-the-middle (MITM) attacks or other potential vulnerabilities. In order to mitigate MITM attacks, applications dealing with sensitive customer data or financial information should use certificate or public key pinning provided by the `ServerTrustPolicy`.

#### ServerTrustPolicy

The `ServerTrustPolicy` enumeration evaluates the server trust generally provided by an `NSURLAuthenticationChallenge` when connecting to a server over a secure HTTPS connection.

``` swift
let serverTrustPolicy = ServerTrustPolicy.PinCertificates(
    certificates: ServerTrustPolicy.certificatesInBundle(),
    validateCertificateChain: true,
    validateHost: true
)
```

There are many different cases of server trust evaluation giving you complete control over the validation process:
- `PerformDefaultEvaluation`: Uses the default server trust evaluation while allowing you to control whether to validate the host provided by the challenge. 
- `PinCertificates`: Uses the pinned certificates to validate the server trust. The server trust is considered valid if one of the pinned certificates match one of the server certificates.
- `PinPublicKeys`: Uses the pinned public keys to validate the server trust. The server trust is considered valid if one of the pinned public keys match one of the server certificate public keys.
- `DisableEvaluation`: Disables all evaluation which in turn will always consider any server trust as valid.
- `CustomEvaluation`: Uses the associated closure to evaluate the validity of the server trust thus giving you complete control over the validation process. Use with caution.

#### Server Trust Policy Manager

The `ServerTrustPolicyManager` is responsible for storing an internal mapping of server trust policies to a particular host. This allows Alamofire to evaluate each host against a different server trust policy. 

``` swift
let serverTrustPolicies: [String: ServerTrustPolicy] = [
    "test.example.com": .PinCertificates(
        certificates: ServerTrustPolicy.certificatesInBundle(),
        validateCertificateChain: true,
        validateHost: true
    ),
    "insecure.expired-apis.com": .DisableEvaluation
]

let manager = Manager(
    configuration: NSURLSessionConfiguration.defaultSessionConfiguration(),
    serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies)
)
```

These server trust policies will result in the following behavior:
- `test.example.com` will always use certificate pinning with certificate chain and host validation enabled thus requiring the following criteria to be met to allow the TLS handshake to succeed:
  - Certificate chain MUST be valid.
  - Certificate chain MUST include one of the pinned certificates.
  - Challenge host MUST match the host in the certificate chain's leaf certificate.
- `insecure.expired-apis.com` will never evaluate the certificate chain and will always allow the TLS handshake to succeed.
- All other hosts will use the default evaluation provided by Apple.
 Thanks for the feedback @vkedwardli. While you are certainly correct, I would strongly advise against making such a change. Anyone that needs to customize the behavior of Alamofire should be creating their own instance of a `Manager`. The `sharedInstance` is just the common case scenario. This gives you the freedom to modify the session configuration headers as well as create a ephemeral or more commonly, a background session. It also avoids the race condition of setting the `ServerTrustPolicy` after you have already started requests.
 Thanks for the feedback @briv! I couldn't agree with your comments about the documentation. I just pushed 0d8803e6 to hopefully address your concerns. Thanks again!
  Hi @kedardesai, the major of the work has already been completed, but has been de-prioritized to help us focus on the Alamofire 1.3.0 release. We will pick back up again shortly after that release is out. üëçüèª
 The majority of the functionality is already built into [AlamofireImage](https://github.com/Alamofire/AlamofireImage). Other non-image related features are currently in our Trello backlog.
  Thank you for your PR @kentya6! I merged a slightly modified version of your changes in e0dd9e84. 

Cheers. üçª
  Thank you for your feedback @joeljfischer. The `swift-2.0` branch is by no means complete. It has simply been ported to allow you to use Alamofire with Swift 2.0. We're going to rework all the error logic before the Alamofire 2.0 release goes out the door. We'll certainly consider your feedback when discussing the API changes.

Cheers üçª
  Thank you for reporting the issue. We have not been able to reproduce this issue in Travis CI or locally from our end. Could you possibly provide some more detail to the following questions?
- Is this reproducible 100% of the time?
- Are you running the iOS 8.3 simulator?
- Could you provide the full console output from running the test suite that produces a failure?
 Okay, we'll keep an eye on it but I'm going to close this issue out for now. I'll reopen it if anyone else reports this same behavior or we can track it in Travis CI. Thanks again.
  Thank you for your PR @avismarahl...much appreciated! üçª
  Of course! 

You need to post the data in the `HTTPBody` of an `NSMutableURLRequest` as XML and use the `response` serializer to parse the XML response `NSData` with an XMLParser of your choice. 

Here is an [example](http://stackoverflow.com/questions/21308227/how-can-you-use-afnetworking-2-0-to-make-a-request-of-a-soap-web-service) of how to do it with AFNetworking. The concepts are similar enough that it should translate to Alamofire.
  Perfect, thanks @kylef!

Quick question. Don't we want this change to go against the `swift-2.0` branch to target Xcode 7 instead of against `master`?
 Thanks @kylef. I added this change in 5b4a59b4.
  What version of CocoaPods did you install with?

``` ruby
pod --version
```

It's also listed in your Podfile.lock file. That will help us diagnose.

cc @kylef 
 Thanks @kylef! 

I'm going to close this issue out. @mikewalkerjr, if you still have an issue after trying @kylef's solution, please add some additional info to this issue and we can re-open it if necessary.
  Official support is now available in the `master` branch. See #539 for more details.
  Hi @Rfaessen, I'm almost positive this is not an issue in Alamofire. I just commented on the question in Stack Overflow. Let's track this issue there and we'll re-open this issue if there does end up being a problem. üëçüèª
  If you need to override the default behavior for URL encoding, then you need to use the `.Custom` case of the `ParameterEncoding` enumeration. There is no RFC spec that defines how collections should be encoded. Therefore, Alamofire provides a reasonable default, and also allows you to provide any other custom behavior you could need.

Best of luck.
  Hi @top2tech, @kylef and I spoke offline and both agree that this body part structure is something that we haven't seen before in any API / service. Could you provide us with some example APIs or usages to help us better understand your proposed changes? 

Otherwise I'm afraid we'll have to reject this change.
 @top2tech could you get back to us on this? I'm going to close this PR out tomorrow if I don't hear back from you. Cheers.
 Hi @top2tech, I'm going to close this PR out since I haven't heard back from you. If you really want to re-open this, please provide answers to the questions that have been posed in this thread. Cheers.
  Thank you for your PR @ikesyo...it is much appreciated! I combined your three commits down into one and pushed into `master` as a5c214ab.

Thanks again! üçª
  Is there any chance someone in the community that is doing a bunch of work with watchOS could help us figure out @jaybuangan's issue?
 cc @kylef, @tobiasoleary, @skywinder, @jhersh
 This issue has been resolved in b4cb7cc30ca5da25b7833e31d515ddef9acb97bc.
  This is just a guess but I think you may be missing the `use_frameworks!` in your `Podfile`. 

You should move your issue to Stack Overflow and tag `Alamofire` and `CocoaPods`. You will receive much better assistance from the community. Additionally, we don't use the GitHub project for support.

Best of luck.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @Ufosek, thank you for reporting your issue.

Without a full code sample, it is difficult to diagnose your issue. Additionally, the code sample you provided is canceling the `self.request` and then creating a new request on `self.request_`. I'm going to assume that that is a typo.

There should always be a slight delay between canceling a request and receiving the callback. The reason is that the request is running on a different queue. The cancellation needs to make it over to the other queue, then call back to the main queue to execute the serialization closure. This is certainly the expected behavior.

As for not receiving the callback, I would assume you have some sort of race condition occurring. Without a full code sample, it would be difficult to diagnose. Regardless, if you could post this question on Stack Overflow, it would receive much more attention. It also let's us focus more on core features and actual Alamofire issues rather than troubleshooting.

Best of luck.

---

Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Thanks for helping out @sikhapol! üçª
  Seems like this is most likely an issue with CocoaPods at the moment. Please check out this [issue](https://github.com/CocoaPods/CocoaPods/issues/3661) for more information.
  Thanks for chiming in @polysyn, it is much appreciated. 

@njuri, please feel free to comment on this issue if that doesn't solve your problem. If there proves to be an issue with Alamofire, I'll be happy to re-open, but for now I'm going to close this out.

Cheers.
  Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Thank you for your PR @oanhof.

The `taskDidComplete` closure is exposed to allow you to completely override the default behavior if you so choose. It was not intended to allow you to hook into the `SessionDelegate` callbacks for notifications and still execute the default behavior.

As an alternative, you can use the `response` serializers to know once a task was completed. Additionally, we plan to open up more of the `Request` class in the 1.3.0 release to allow you to extend a `Request` to have additional hooks along with the already provided ones such as `validate`, `authenticate`, `response`, `responseJSON`, etc.

Hopefully this helps clarify things a bit. Cheers.
  Thanks for this PR @ikesyo! I have just a single comment that will require a few changes throughout the PR. If you could get those changes made, I'll gladly merge it.

Thank you for taking the time to clean up the logic.
 Great work @ikesyo...thanks for the changes! üçª
  It doesn't look like anything in that stack trace is crashing due to Alamofire logic. My best guess is that your `fileUrls` array is empty or the `URL` itself is invalid.

I'm going to close this out for now. If you provide some additional info that leads more towards it being an actual Alamofire issue, I'll gladly re-open it. Cheers.
 Ah cool, thanks for confirming.
  I would guess that when you are attempting to append the `fileURL` that it is actually failing. What happens if you do the following?

``` swift
    multipartFormData:
    {
        multipartFormData in
        multipartFormData.appendBodyPart(data:data!, name:"postdata")
        let error = multipartFormData.appendBodyPart(fileURL: fileUrls[0], name: "unicorn")
        println(error)
    },
```
 Ah that makes sense. See this [thread](http://stackoverflow.com/a/13523463) for more information. I'm going to close this issue out since this is the expected behavior.
  Thank you for the suggestion @sugarwyc. 

We will not be incorporating this change though since we are no longer supporting iOS 7 with Swift 2.0. Please see #525 for more information.

Cheers.
  Thanks for the feedback @top2tech...it is much appreciated!

I've addressed the core problem in f1557414 and am going to close this issue out. Please direct all future traffic to #539 so we can track it in a single place.

Thanks again! üçª
  Thanks @ikesyo.
  @kylef do you have any idea if this is an issue with CocoaPods or with the Xcode 7 migrator? Is there anything in the CocoaPods 0.38.0.beta.2 release that would help out with this?

@johndpope, what version of CocoaPods are you using?
 I was able to create a sample project and add Alamofire using your `Podfile` with Xcode 7 beta1 and CocoaPods 0.38.0.beta.2. Xcode 7 is not throwing any of the migrator warnings that you are seeing @johndpope. 

Could you possibly confirm? 

I will try with beta 2 once I have it installed on this computer.
 Again @johndpope, what version of CocoaPods did you do this with? Please run `pod --version` and post the results to help us out.
 I just created a new project in Xcode 7 beta 2 (7A121l) with CocoaPods 0.38.beta.2. I am not seeing the `Convert to Latest Swift Syntax` issue. @johndpope if you could provide some additional information or a sample project, then we can continue to debug this further. However, I'm going to close this issue out since I can't repro the issue with a clean project.
  Thanks for helping out here @NicholasTD07 and @ianp. 

I am able to compile the `1.2.3` release using `carthage update` without issue right now. I would encourage you to either open an issue with the Carthage project or open an issue on Stack Overflow. Both of those locations will be able to better help you solve your issue.

Cheers. üçª
  The `-1001` is a timeout error which is a bit different than the AFN issue you linked. Either way, the issue you are seeing is not directly related to Alamofire with what you have provided. I would encourage you to seek additional support on Stack Overflow.

---

Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Check out the `swift-2.0` branch.
  @pdsavard, you need to pass `Authorization` headers as part of the `Request`. Not through the `NSURLSessionConfiguration`. See the [README](https://github.com/Alamofire/Alamofire#http-headers) for more info.
 IMO the statement is accurate @paulyoung. If you think there's room for improvement, then by all means, please submit and PR and we'll certainly take a look! üëçüèº
  Thanks everyone for chiming in.
  Thanks @katunch.
  Looks good dude!
  While that was not the original intent of the feature list, I can't think of any reason not to include it. Thanks for the PR @rojotek!
  What happens if you override the `taskDidReceiveChallenge` closure instead? Do you receive the callback then?
 Thanks @jshier. I'm going to close this issue out @dcunited001. If you provide more info that leads us to believe there is actually an issue, I'll gladly re-open the ticket.
 Thank you for documenting @dcunited001...much appreciated. Hopefully it helps someone else out that runs into the same issue. üëçüèº
  This pull request adds support for uploading `MultipartFormData` to Alamofire. I would love feedback from the community to make sure everything here is in tip-top shape before rolling it in. Any feedback would be much appreciated.
## MultipartFormData

The general idea is that you append body parts to the larger MultipartFormData object, then encode it when you want the cumulative result. Encoding can be performed in two different ways:
1. Encoding In-Memory
2. Encoding Data by Streaming to Disk
### Encoding In-Memory

Encoding in-memory should only be used with small datasets. If the `contentLength` of the `MultipartFormData` is too large, you run the risk of your app being terminated due to memory usage.
### Encoding Data by Streaming to Disk

Sometimes you need to upload a very large dataset to a server such as a bundle of large images or videos. In these cases, your dataset is too large to perform the encoding in-memory. For these cases, the `MultipartFormData` class supports encoding the data using a combination of input and output streams keeping the memory footprint very small.
## Uploading from Manager

The `upload` methods for uploading `MultipartFormData` support the idea of a memory threshold. To make it as easy as possible, the memory threshold is used to determine whether the `MultipartFormData` can be encoded in-memory or whether it needs to be written to disk first. The default value for the memory threshold is currently set to 10MB.

In order to make the encoding process asynchronous, the upload methods could not return a `Request` object directly. To handle this case, the `MultipartFormDataEncodingResult` enumeration was added and exposed in an `encodingCompletion` closure. The resulting `Request` object is contained as an associated value in the `.Success` case which can then be used to chain additional methods against. While this is a bit different than the other public APIs, it still is quite simple to use.

``` swift
Alamofire.upload(
    .POST,
    URLString: "http://httpbin.org/post",
    multipartFormData: { multipartFormData in
        multipartFormData.appendBodyPart(fileURL: unicornImageURL, name: "unicorn")
        multipartFormData.appendBodyPart(fileURL: rainbowImageURL, name: "rainbow")
    },
    encodingCompletion: { encodingResult in
        switch encodingResult {
        case .Success(let upload, _, _):
            upload.responseJSON { request, response, JSON, error in
                println(JSON)
            }
        case .Failure(let encodingError):
            println(encodingError)
        }
    }
)
```
## Summary

This was a fairly complicated feature to put together, so I'd really love to gather everyone's feedback. If you have a solid grasp of RFC 2388 and 2045, then please take the time to review these changes before we merge it in.
 cc @kylef and @kcharwood 
 We will definitely merge this into the swift-2.0 branch once this gets merged into master @kamoljan. 
 Thanks @orschaef and @kaelite. That's totally my bad. I simply forgot to set the `Content-Type` on the `URLRequest`. I'll have it all fixed up shortly and will also adds tests around it @kylef.
 @orschaef and @kaelite...the `Content-Type` issue should be resolved with f1557414. If you could give it a go I would really appreciate it.
 Thank you for confirming @orschaef. I'm going to go ahead and merge this. Thank you everyone for all your help getting this feature tightened up! üéâ üéâ üéâ
 Hi @damienrambout, thanks for your feedback. 

Just for anyone else reading through this, I'd like to clarify a bit. The `upload` function doesn't return a `Request` directly because it needs to encode the `MultipartFormData` before creating the `Request`. Since the encoding operation can be very small or extremely large, you really don't want to block the caller thread while executing this. Therefore, the encoding is asynchronous and the `encodingCompletion` closure returns the `Request`. This is all intentional and by design.

A second approach in AFNetworking is to subclass `NSInputStream` and provide a dynamic upload stream rather than encoding it prior to the upload. While this is more convenient, it is extremely error prone. Additionally, subclassing `NSInputStream` is a very difficult and quite finicky. It's backed by an opaque type that needs to have certain methods overridden when toll-free bridging. It's just not a very robust or maintainable solution.

Our goal with Alamofire is to provide the absolute highest quality networking layer on top of the URL Loading System that we possibly can. Therefore, sometimes we will choose to implement certain features differently than AFNetworking to continue to improve the overall quality of its successor, Alamofire.
 @ivangodfather you can either append them as query parameters to an `NSURLRequest` or you can add them as multipart form data values using the following method:

``` swift
func appendBodyPart(#data: NSData, name: String)
```
 You got it!
 Hi @robindoble, please check out the test [logic](https://github.com/Alamofire/Alamofire/blob/master/Tests/UploadTests.swift#L134-L552). My guess is that you just have a syntax issue. If you do end up finding a mistake in an example code snippet in the README or something like that, please submit a PR or file a new issue. Thanks!
 Hi @robindoble, the `Content-Type` header is set automatically for you. If you need to set additional headers, you can either set them in the `NSURLSessionConfiguration` when you create the `Manager` instance, or you can set them on the `NSURLRequest` before you pass it into the `upload:multipartFormData` method as a `URLRequestConvertible`.
 That's not how to go about this @ivangodfather.
 @SteveNewhouse you want to use the `ParameterEncoding.queryComponents` API to help you out here. Here's some sample code to get you on track:

``` swift
let imageData: NSData? = NSData()
let URLRequest = NSURLRequest(URL: NSURL(string: "https://httpbin.org/post")!)

Alamofire.upload(URLRequest,
    multipartFormData : { multipartFormData in
        if imageData != nil {
            multipartFormData.appendBodyPart(data: imageData!, name: "avatarImage", fileName: "blah", mimeType: "image/jpeg")
        }

        let user: [String: String] = [:]

        for (key, value) in ParameterEncoding.URL.queryComponents("user", user) {
            multipartFormData.appendBodyPart(data: value.dataUsingEncoding(NSUTF8StringEncoding)!, name: key)
        }
    },
    encodingCompletion: { result in
        // todo
    }
)
```
  Thanks @ikesyo. You are most likely running into ATS @excelsior. Here's an article with some good information about what's going on and how to get around it if you absolutely have to. 

Please note that we do not encourage you to use non-secure connections on iOS 9. We will be posting an in-depth security document with the release of the Xcode 7 GM along with Swift 2.0.
  Hi @jessecurry, thank you for your feedback.

There is a way to reset the credential, but it is pretty hidden. You could get the credential storage and remove the credential like so:

``` swift
let manager = Alamofire.Manager.sharedInstance
if let storage = manager.session.configuration.URLCredentialStorage {
    storage.removeCredential(credential: credential, forProtectionSpace: protectionSpace)
}
```

However, since this would be brutal to have to do each time and still utilize the convenience of the `authenticate` method, I think your proposal for exposing the `persistence` parameter is valid. 

I have incorporated your suggestion into cb9e11b9 and set the default value to `.ForSession`. Thus, the change is backwards compatible and still has the same default behavior as before.

Cheers üçª
  Thanks for helping out @jshier.

To start @alienxp03, let me give a bit of background. Alamofire was not designed to be a Swift port of AFNetworking. It was designed to be a new Swift approach to networking in general. Things like method chaining, powerful enumerations and generics were not possible when AFNetworking was built. Therefore, we can create MANY new design patterns making Alamofire much easier to use. Please do not expect Alamofire to work exactly as AFNetworking. The two are VERY different libraries.

With that said, you have an interesting PoV here @alienxp03. Why do you feel that a 401 should automatically trigger an error? Apple doesn't trigger an error for a 401, why should Alamofire? As @jshier mentioned, this is why the `validation` methods exist. It allows you, the user, to customize the behavior of all possible status codes. In certain cases, a 401 may mean there was a basic auth issue, or possibly a server call that was making an unauthorized request to another service. There are endless amounts of situations where a 401 could mean different things. In certain cases, it isn't even actually an error to the client. This is why we don't automatically generate errors at the Alamofire level. We require the user to tell us what the error conditions are. Does that make sense?

Now, to your last point that the validation error that is returned is not super helpful. I agree that it could be better, but it is still enough for you to know that you didn't pass validation. You can then check the status code to see why it failed validation if you like. In the Alamofire 2.0 release, we are going to be reworking all the error handling logic to accommodate the Swift 2.0 changes as well as make cases like this a bit easier to diagnose.

Hopefully that helps clear up any confusion. Cheers üçª
  Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Thank you for your PR @marcelofabri. 

We are going to revisit all error handling logic for the Alamofire 2.0.0 release. We'll keep these changes in mind when we are considering alternatives for Validation handling, but for now I'm going to close out this PR since this would not be backwards compatible.

Cheers üçª
  Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Hi @joshuatbrown, thank you for your PR! The more people we have pointing out the flaws in our documentation, the better we can make it for everyone. 

I modified your commit slightly in fd2eeb7f and improved the overall example in 02625150. Everything is much better documented now and updated to Swift 1.2. 

Cheers üçª
  Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Looks like I missed the playground in the conversion. Thanks @terhechte!
  Thank you for your PR @berikv. As I mentioned in #528, this is something we're going to take a much larger approach to solving properly. Thanks again.
  Thanks for your feedback @berikv. This issue is a duplicate of #447 and I'm going to close it out as such. This is something we're planning on addressing in the 2.0.0 release.

For now, you can simply key off the domain and `-1` code if you like since validation is the only step that throws such an error.
  Thanks everyone for helping out here. I have modified the README in the `swift-2.0` branch in 6453f83b to hopefully eliminate this issue in the future.
  Alamofire caching works as expected and leverages all the default behavior of `NSURLSession`, `NSURLSessionConfiguration` and `NSURLCache`. We recently added a large amount of tests around this behavior to prove that it does work as intended. Please check out the [CacheTests](https://github.com/Alamofire/Alamofire/blob/master/Tests/CacheTests.swift) for more information.

In the future, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire` instead of creating a support issue on Github. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Thanks for your PR @mishagray. We will not be supporting iOS 7 in the `swift-2.0` branch. It too difficult to maintain multiple test targets to ensure the quality of that OS. Please see #523 for more details.

Cheers.
  Thanks @3a4oT. We've already cut a `swift-2.0` branch which will not be officially released until Xcode 7 hits GM.
  Thanks for the PR @coverback. It is much appreciated!

The `swift-2.0` does not include this check on purpose. We are going to be dropping iOS 7 support here very soon. The reason is that we cannot properly test against iOS 7 in Travis-CI without rewriting our entire test suite. The separate test suite would need to import all the Swift files (since you cannot import frameworks in iOS 7) into the target and all the tests would need to be re-written and duplicated. Since this would be a huge effort and very difficult to maintain, we've decided that it is in the best interest of the project to keep moving forward and not bring iOS 7 support along with us.

You will see more formal updates about these changes take place in the README on the `swift-2.0` branch as well as `master` here in a future release.

Thanks again.
  Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Thanks @mathiasnagler!
  Thanks for the PR @joshuatbrown...this looks good to me!
  Hi @sai-prasanna, thankfully there is not a bug here. Unfortunately you are just misusing the API. Here's the signature of the global method you are calling:

``` swift
public func request(
    method: Method, 
    URLString: URLStringConvertible, 
    parameters: [String: AnyObject]? = nil, 
    encoding: ParameterEncoding = .URL) 
    -> Request
{
    // implementation...
}
```

You'll notice that the `mutableRequest` you are passing in conforms to a `URLStringConvertible`. In the implementation, the `URLString` for the convertible is extracted to create a new `NSMutableURLRequest` that will have the "default" cache policy. This is absolutely the intended behavior in this case.

Instead, you need the other `request` method which is as follows.

``` swift
public func request(URLRequest: URLRequestConvertible) -> Request
```

This method will use your `mutableRequest` directly keeping your cache policy in place.
  This is a great start @NicholasTD07! Thank you for putting this together. 

I'm going to dig into this tonight. I'll most likely pull in your changes and rework some of the error handling along with a few other minor things. I'll also most likely blacklist the `swift-2.0` branch from the Travis-CI yaml file until Travis supports the Xcode 7 beta.

Thanks again!
 Thanks again for your work on this @NicholasTD07. 

I ended up starting from scratch given the small but challenging complexities that were presented in some of the changes. There were a few API changes introduced in iOS 9 along with some different external parameter naming conventions that I had to go through individually. It was also a bit interesting migrating over to the new error handling logic both in Alamofire and the test targets.

Everything has been completed and Travis-CI has been disabled in the new `swift-2.0` branch. I really wish that we could run Travis-CI over this branch with all the different simulators, but it isn't supported yet and probably won't be for at least a month. If everyone in the community could try this out I'd really appreciate it. All the tests are passing on both iOS 9 and Mac OS X 10.10. I'm having trouble with my iOS 8 simulators and don't have another install of Mac OS X 10.11 to test with.

Thanks again everyone for your help on this!
  Hey everyone, thanks for all the feedback here! Apologies for not getting a chance to comment on all this until now. Busy week at WWDC.

I'm going to start working on Swift 2.0 support tonight. I'll be pushing up a new `swift-2.0` branch that everyone will need to use until Xcode 7 reaches GM. Once the GM is released, we'll pull the `swift-2.0` branch into `master` and cut another release, just like we've been doing in the past with Swift 1.1 and 1.2.

Cheers üçª
 Hi @dslysenko, believe me, we're aware. We've been hard at work pushing the 1.3.0 release out the door. All efforts are now being focused on porting each and every one of those commits over to the `swift-2.0` branch.
- https://twitter.com/AlamofireSF/status/624734484609368064

Stay tuned.
  Thank you for your PR @alexpls. I accepted your change with slight modifications in c40d7907.
  Hi gents...thanks for the info here.

In this case, I'd say Alamofire has the correct default behavior. If no data is added to the `HTTPBody` of the `NSURLRequest`, then the `Content-Type` header should not be attached. If you do need to attach the `Content-Type` header, you can do that manually for this particular case.

Adding custom headers will also become much easier in the Alamofire 1.3.0 release. Cheers.
  Hey @joshuatbrown, I think this is a great idea! Here are a couple Stack Overflow answers I have posted on that topic that should get you going in the right direction.
- http://stackoverflow.com/a/29752650/1342462
- http://stackoverflow.com/a/28519246/1342462

Just hit us up if you run into any issues putting it together. Thanks for taking the initiative here!
  Thank you for that very detailed write up @ibru. It is very much appreciated.

Unfortunately you have stumbled upon a nasty issue in CFNetwork. There is a known threading issue with `ensureParserFinished` that has already been filed with Apple. There is a massive thread full of fantastic information from the AFN community which can be found [here](https://github.com/AFNetworking/AFNetworking/issues/2334).

I would like to take the same approach as AFN on this one. If anyone finds any possible workaround for Alamofire for this issue, we'd be happy to adopt the fix. Until then, it may be wise to avoid using `debugPrintln(request)` on consumer facing builds. If you see this crash in your debug builds, at least now you'll know the root cause of where the issue truly lies.

Thanks again.
  Thank you for this PR @psobot! My apologies for not getting back to you sooner. Our TC has been really busy this week at WWDC. I'm really excited about this change but haven't had enough time to go through it in depth. I should be able to get to it here in the next few days.

Thank you for your patience! üçª
 This is great work @psobot! Thank you very much for your PR. I have pulled it into master in a combination of the following commits: a15dc1d6, 93df9fe2 and 922c1ca3.
  Duly noted. We've had some very interesting discussions / debates on AFNetworking around the usage of the Reachability APIs and how useful they truly are. I'll huddle the TC at WWDC and we'll see if this is something we want to get onto the roadmap.

I'll go ahead and leave this issue open for the moment for others to comment as they like.

Cheers üçª
 Thanks for the feedback @jshier. I agree that the usefulness is for handling the connectivity restored notification. As for it being out-of-scope for Alamofire, I don't entirely agree. We want Alamofire to be the best way to use NSURLSession in Swift. Dealing with connectivity issues and events is certainly a part of that story.
 Thanks for posting that @ashleymills. I'm going to go ahead and close this issue out. We're still debating this internally to figure out whether this is something we'd like to directly support. Once we make a decision, I'll update this issue. Thanks for everyone's input here. üëèüèºüëèüèºüëèüèº
  Hi @allaire, any chance you could provide some additional information (code sample or Github project) or even better, a set of tests that reproduce the issue and submit a PR?
 Any chance you could also throw up the output of `debugPrintln(request)` on that request? That would make it much easier to debug. My initial guess is that you are failing the response validation due to the `Accept` header not matching.
 Sorry about that @allaire, I should have been a bit more specific. Could you post the debug output for the original `Alamofire.Request`?

``` swift
let request = Alamofire.request(Router.CancelRequest(organizationId: myRequest.organizationId, id: myRequest.id))
request.validate()
request.responseJSON { (request, response, json, error) in
    if error != nil {
        ProgressHUDManager.serverError()
        println(response)
        println(json)
        println(error)
    } else {
        self.myRequests.removeAtIndex(indexPath.row)

        tableView.beginUpdates()
        tableView.deleteRowsAtIndexPaths([indexPath], withRowAnimation: UITableViewRowAnimation.Automatic)
        tableView.endUpdates()
    }
}

debugPrintln(request)
```
 Looks to me that the response is coming back with a 500 status code. The error leads me to believe that the response is being parsed as JSON even though it is not. The `Content-Type` header is not `application/json` as it should be.

At this point, I would try to debug this further just using cURL or whatever HTTP client you're most familiar with. Once you have the service working exactly as you would expect, then I would try with Alamofire again.

I'm going to close this issue out as it looks to me that everything is working as expected. Best of luck!
 If it is not a string or JSON, then you want `response`. If it is a string, then you most likely want `responseString`. If it is JSON, then you most likely want `responseJSON`. These are general guidelines for the common cases. You can certainly mix and match the various response serializers to meet your needs. I'd recommend carefully reading through the [Response Serialization](https://github.com/Alamofire/Alamofire#response-serialization) section of the README.

If you could direct all further questions to Stack Overflow it would be much appreciated. You'll have a much larger community to help you out there.

---

Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
 Okay I'm going to re-open this gents.

Could someone possibly help me out here and write some failing tests to make it easier to debug the issue? We're in the middle of pushing through some giant features for the `1.3.0` release and it would save me a TON of time if there were already some tests that were failing demonstrating the issue.

The `httpbin.org/status/:code` endpoint should be very helpful here.
 Hey @allaire, @MartinRogalla and @Mistobaan! 

I just pushed up PR #598 that hopefully addresses this issue. I would REALLY appreciate it if you could test out this change to verify it does in fact fix your issue. Also, if you have any ideas on how I could add a test around this behavior I'd very much appreciate it.

Please redirect all further comments to PR #598 until we get this resolved.

Cheers üçª
 Closing this issue out since it has been resolved by PR #598. Cheers.
 @joshuaziering Yes, these changes have been merged for quite a while. Please open a new issue if you think there's a bug with Alamofire or open a question on StackOverflow and tag `Alamofire` if you're having trouble getting your content validation to work.
  Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  We are adding support for multipart form data in the 1.3.0 [release](https://github.com/Alamofire/Alamofire/milestones). We have not started that work yet. Cheers.
  The previous tests were sporadically failing when pointing at `google.com` with an `NSURLErrorHTTPTooManyRedirects` error. I moved over to `httpbin` to have more stable behavior for our automated test suite. Other changes include:
- Added default behavior tests for redirects
- Added redirect tests for using task override closures to perform and cancel redirects
- Added tests for default behavior and task override closures around multiple redirects
 cc @kcharwood, @kylef, @mattt 
  I managed to re-enable our Travis-CI builds for Alamofire. This is really my first trial with Travis-CI so I'd appreciate it if others could look this over for me. Here's a list of changes that I made.
- Switched to the latest `osx_image` which is `beta-code6.3`
- Added xcodebuild phase for the OS X tests which are now passing
- Added a `gem install cocoapods` to make sure we're linting with the latest version
- Added a CocoaPods Compatible tag to the top of the README
- Added a Carthage Compatible tag to the top of the README
 cc @kcharwood, @kylef, @mattt 
  I added tests around common `NSURLCache` usage with `Cache-Control` headers. This is mostly to demonstrate that caching does work properly with Alamofire as well as the expected behavior with the common types of `Cache-Control` headers. These tests were a bit difficult to get written and I'd love everyone's feedback.

With how Apple has implemented this behavior under the hood, it makes it quite difficult to test whether a particular request hit the network or retrieved the response from the cache. The actual negotiation of checking cached response expirations and going to the network is completely hidden from us. You can start to inspect this behavior with something like Charles Proxy, but we don't have that ability from the public API side of the URL Loading System...more details [here](http://andrewmarinov.com/ioss-corenetwork-lying/). Therefore, the only thing that I was able to use to determine whether a response came from the cache or from the network was to check the response's timestamp. By introducing a 1 second delay, I was able to always confirm whether a response came from the cache or the network.

The initial commit demonstrates my first pass at the tests. This approach was pretty solid, but was too slow. Each test introduced two network calls with a second wait between them. This doesn't scale very well and we'd love to keep our testing times down as much as possible.

The second commit results in the same tests, but optimized for speed and readability. I've added a pretty hefty amount of documentation around the tests to explain how they work. While the code is fairly self documenting, it's still complicated how everything gets set up.

With the second pass, I was able to condense the entire set of cache policy tests into single tests. This makes it a bit more difficult to debug the tests, but makes them run much faster and is much easier to understand what the test is actually testing.

As mentioned before, I'd love everyone's feedback.
 cc @kcharwood, @kylef, @mattt 
 Looks like I've still got some work to do here. I'll investigate this tomorrow as to why we're seeing failures on Travis as well as why NSURLCache has different behavior for the `no-store` header value between platforms.
 Okay, problem solved...Travis is happy!
 I can now that I've gotten to the bottom of it! üòõ

It appears that there was a bug in the iOS 8.2 simulator which I was using when I wrote the tests. Switching over to the iOS 8.3 simulator fixed the issues and we're now seeing the same behavior between iOS and OS X. Thankfully both are producing the "expected" behavior as well at this point since a `Cache-Control` header with a `no-store` value certainly shouldn't cache that request. FWIW, I'm also seeing the wrong behavior in the iOS 8.1 simulator as well.

From what I can tell by scouring the Internets is that people have been reporting all sorts of caching inconsistencies across iOS 8 (including against Alamofire itself). It looks like Apple may have finally gotten iOS 8.3 back in line. I think for now, it's probably best to just move forward. I don't think it makes sense to file a rdar for something they've already fixed. I also don't think it makes a ton of sense to write tests to try to test the older broken behavior. At the moment, we're running Travis against the latest iOS Simulator and OS X x86_64 architecture.

My approach here was to simply get tests around the expected NSURLCache behavior on both platforms, and make sure we stay green here moving forwards. Does that sound reasonable?
 That sounds good @kcharwood. I'm going to merge this PR and start working on a separate PR to add simulators for all our supported OS's as well as branch the necessary tests.
  This PR originates from the discussion in Issue #497 and PR #500. I dug through all the past issues related to percent escaping characters and came across the following: #121, #155, #166, #206, #369 and #370. The percent escaping logic has progressed nicely and is solid and well tested.

To this end, I noticed a couple of things that could be improved.
1. It would be good to clarify in the `escape` function which characters we're escaping and why.
2. In the URL parameter encoding tests, give a description of the test cases and which specs they follow along with the exceptions that have been made.

All this PR does is add the "[" and "]" characters as well as split the legal escaped characters into `generalDelimiters` and `subDelimiters`. I think this makes it much easier to understand when referencing [RFC 3986 - Section 2.2](http://tools.ietf.org/html/rfc3986#section-2.2).

The final change was to update the README mismatch which was kindly pointed out by @joshuatbrown in PR #500. I simply corrected the character to `%2B`.
 cc @kcharwood, @kylef, @mattt 
 Great point about the comment. I'll update it accordingly. 

As for the tests, great question. I already see where you're heading with that. I did some more investigation to figure out exactly why they were passing before without the change, and they're still passing with the change.

After digging in, I found the root issue. The problem is that `CFURLCreateStringByAddingPercentEscapes` claims to adhere to RFC 3986, but considers `[`, `]` and `#` to be illegal characters. It's really difficult to understand why they consider them illegal characters because the spec itself doesn't refer to characters as legal and illegal. Instead it refers to them as reserved and unreserved characters. Additionally, we're not encoding the "entire" URL, but just the query parameters.

I'm going to investigate some more and probably add some additional tests.
 Okay so in 3c95af26, I added a bunch of tests and a public docstring on the `escape` method to make things as clear as possible. Now there shouldn't be any question why or how we percent escape our query string characters. 

Here's a fun little chunk of code to run in a playground that demonstrates the "legal" vs. "illegal" ASCII characters from the Core Foundation PoV.

``` swift
import Foundation

func escape(string: String) -> String {
    return CFURLCreateStringByAddingPercentEscapes(nil, string, nil, nil, CFStringBuiltInEncodings.UTF8.rawValue) as String
}

let asciiCharacters = [
    " ", "!", "\"", "#", "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", ":",
    ";", "<", "=", ">", "?", "@", "[", "\\", "]", "^", "_", "`", "{", "|", "}", "~",
    "0123456789", "abcdefghijklmnopqrstuvwxyz", "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
]

asciiCharacters.map { println("\"\($0)\" = \"\(escape($0))\"") }

let nonLegalCharacters = " \"#%<>[]\\^`{}|"
```

Which outputs...

```
" " = "%20"
"!" = "!"
""" = "%22"
"#" = "%23"
"$" = "$"
"%" = "%25"
"&" = "&"
"'" = "'"
"(" = "("
")" = ")"
"*" = "*"
"+" = "+"
"," = ","
"-" = "-"
"." = "."
"/" = "/"
":" = ":"
";" = ";"
"<" = "%3C"
"=" = "="
">" = "%3E"
"?" = "?"
"@" = "@"
"[" = "%5B"
"\" = "%5C"
"]" = "%5D"
"^" = "%5E"
"_" = "_"
"`" = "%60"
"{" = "%7B"
"|" = "%7C"
"}" = "%7D"
"~" = "~"
"0123456789" = "0123456789"
"abcdefghijklmnopqrstuvwxyz" = "abcdefghijklmnopqrstuvwxyz"
"ABCDEFGHIJKLMNOPQRSTUVWXYZ" = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
```
 So for some reason I decided to look at the Core Foundation header this morning instead of Dash and low and behold, the answer was revealed. The header states that the `CFURLCreateStringByAddingPercentEscapes` method follows [RFC 2396](https://www.ietf.org/rfc/rfc2396.txt), not [RFC 3986](https://www.ietf.org/rfc/rfc3986.txt) like the Dash documentation states...(sad trumpet plays).

Not only is the mismatch rdar worthy, but it can cause a TON of confusion. This would be especially problematic for people working with IPv6 addresses. Support for them was added to RFC 2396 in the [RFC 2732](https://tools.ietf.org/html/rfc2732) amendment. Both of these were replaced with the latest version of these specs which is RFC 3986.

I think at this point, I'll file a rdar explaining the documentation mismatch and update the docstring accordingly along with adding the openradar link into it.
  @skywinder we are going to extend the `request`, `download` and `upload` convenience methods to support custom headers in the 1.3.0 release. We are also going to update the `ParameterEncoding` `encode` method to return an `NSMutableURLRequest`. These two changes should make it MUCH easier to add your own authorization header to a request.

For the time being, I'd like to avoid having special hooks into the `Manager` for appending certain "special" header. Before you know it we'll be supporting a handful of them when this could (and should) be easily handled by the client.

Thoughts?
 Thank you for your feedback @tomj. I agree that `Authorization` headers are a very popular authentication mechanism. We're trying to avoid adding too many APIs around auth and want to encourage users to "think" about and "understand" what it is they are really doing. Note the 20 [issues](https://github.com/search?q=setAuthorizationHeaderFieldWithUsername+language%3AObjective-C+language%3AObjective-C&ref=searchresults&type=Issues&utf8=‚úì) listed around `setAuthorizationFieldWithUsername:password:`. We want to avoid confusion and make it easy to understand the difference between how a `Request` is constructed and how auth challenges are handled.

The changes I mentioned earlier are a big step in that direction. Adding an `Authorization` header should take place when the `NSURLRequest` is being constructed. Now if you start thinking about how this would work in Alamofire, it gets a bit interesting. In AFNetworking, you have the concept of a `RequestSerializer`. In Alamofire, this does not exist. You need to add the header at the time of creation, which makes things much easier to understand. This may however make things slightly less convenient, but potentially saves people from their own mistakes.

Which leads me to my next point. @skywinder I don't think it would be wise to add a `setAuthorizationFieldWithUsername:password:` on a `Request` because you cannot modify the `Request` once it has been created. It's task has already been sent to the `NSURLSession` to be executed. This is not the case if you set the `startRequestsImmediately` flag to `false` on your `Manager` instance, but the majority of users will most likely use the default value.

This means that you can only attach the Authorization header at the time of construction, which is consistent for all headers and is simple to understand. Now there may be a way to expose a class method on a `Manager` instance to make it easy to generate an `Authorization` header, such as a class method like the following (don't hold me to the method signature):

``` swift
public class func authorizationHeaderWithUser(_ user: String, password: String) -> String
```

This would allow users to easily create a base64 encoded String to pass into the `request` function as an `Authorization` header. It's a similar idea to the `defaultHTTPHeaders` static property. I don't think it would be a good idea to add support directly in the convenience `request`, `download` and `upload` functions for a `Authorization` header. We're trying to keep those as light-weight as possible. Now I'm not advocating for this approach, I'm just throwing it out there as food for thought.
 @allaire, your approach is correct. You want to use the `URLRequestConvertible` to attach the header for now. In the 1.3.0 release, you will have a second option that will allow you to pass a `headers` dictionary into the `request`, `download` and `upload` global methods.
 @skywinder I'm going to close this issue out. We can revisit this after the 1.3.0 release if necessary. I would like to avoid specific header implementations directly in Alamofire with the exception of the `headers` parameter in those top level functions that we're adding in 1.3.0.
  Thank you for your PR @joshuatbrown! I've pulled a version of your change into #504. Cheers üçª
  It is outdated, but still stands. We are going to be adding Multipart Form Data support in the Alamofire [1.3.0](https://github.com/Alamofire/Alamofire/milestones) release. Until then, you'll want to follow the info in that thread to get started.
 Hey everyone, I just put up PR #539 which adds support for `MultipartFormData` uploads. I would love your feedback before merging it in. Cheers.
  That's a failed authentication challenge. Set the `sessionDidReceiveChallenge` property accordingly. See Apple's documentation on [Authentication Challenges and TLS Chain Validation](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/Articles/AuthenticationChallenges.html) for more details.
 Here's an [example](http://stackoverflow.com/a/30416865/1342462) of how you can dig into the `sessionDidReceiveChallenge` property.

> You should **NOT** use the implementation in that thread directly since it is disabling security checks. However, it should prove useful for debugging purposes.
 Hi @edasque, I'll give you a quick description of what's happening. Please redirect further issues with this to Stack Overflow. We just don't have enough time to troubleshoot everyone's TLS handshake issues.

With that said, @mattt mentioned that you are seeing a failed authentication challenge because that's exactly what's happening. The server is initiating a TLS handshake, and iOS by default is evaluating the challenge as a failure. This can be for several different reasons, some of which can include an expired certificate, an unsigned certificate or a certificate with a different domain than the `NSURL` that was requested. These are security checks automatically provided by the iOS Security framework to make your life easier.

Since some people need explicit control over these behaviors, we have opened up the ability to override the default Alamofire behavior. That's why I posted the response that I did to show you the basics in how to go about customizing that behavior. What you need to figure out is why the auth challenge is passing through cURL and failing in the iOS evaluation.

Best of luck!
  Thank you for your excellent discussion here @joshuatbrown and @tobiasoleary! It is much appreciated and allows others using Alamofire to learn from you. üëçüèª

I've dug through this discussion along with PR #500 and have combined everything into PR #504. If you could take a look I'd appreciate it. I'm going to close this issue out for now. Please direct all info related to this topic to #504 from this point.

Thanks again! üçª
  The object type of the `parameters` parameter is `[String: AnyObject]?`. Your `params` dictionary is of type `[String: String?]` which cannot be cast to the expected type. That is the problem. 

Also, you probably shouldn't be passing in a parameter if it doesn't exist. Otherwise you could always nil coalesce the `firstname` value into some default like so.

``` swift
let params = {
    "firstname": first.firstname ?? ""
}
```

For future issues, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire` instead of creating a support issue in Github. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Our prescribed approach is to use the built-in mocking capabilities of `NSURLProtocol`. This is not yet documented, but that's on our list of things to do.
 There are other libraries out there @vgatto such as [OHHTTPStubs](https://github.com/AliSoftware/OHHTTPStubs) that could assist for the time being.
 Hi @vgatto, I'm going to close this issue out. We do not have plans to modify the `Manager` or `Request` classes to allow for easier mocking. Instead, we will create documentation around using `NSURLProtocol` for mocking responses. It is already on our internal roadmap but has not been slated for an actual release yet. Cheers üçª
 This is still in our backlog @sohayb. No updates of a timeframe at the moment. There is a [small test](https://github.com/Alamofire/Alamofire/blob/master/Tests/URLProtocolTests.swift#L27-L81) that does demonstrate how to do this. That at least shows you the basics. Should be enough to get you going. üëçüèº
  From our Contribution Guidelines:

> # Asking Questions
> 
> We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on Stack Overflow instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  If you don't use `request_`, no, nothing really bad will happen. It acts like any other value assigned to an unused variable.
  Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  This PR contains several major changes to the test suite including:
1. Refactors all tests to follow the `Given` | `When` | `Then` structure
2. All tests now succeed on iOS and OS X
3. Adds safeguards to all tests to prevent the test suite from crashing when tests fail

My apologies for the horrendous diff. I would suggest checking out the branch and reviewing it that way. None of the tests have been removed. They have only been refactored to follow the new structure and to be safe from potential crashes.
 cc @kcharwood, @mattt and @kylef for review.
 We need Travis CI to support Xcode 6.3 because we've moved over to Swift 1.2 which only ships in that version of Xcode.
 I dig it. Nice work, @cnoon.
  Thanks for the PR, @mustafaibrahim989, but this implementation is incompatible with our project design goals. Specifically, it creates a strong dependency on UIKit, making Alamofire incompatible with OS X. It also has tight coupling to a shared singleton instance and isn't thread-safe. We are looking into ways to incorporate this kind of functionality in the future.
  I'm not sure if this is a suggestion on how to improve the documentation or not, but without more information, I can't be certain. Since there's no actionable item here, I'm going to close this issue out.
  That's why there's an overload that takes a `URLRequestConvertible`. Just set `HTTPBody` to an `NSMutableURLRequest` and pass it into that.
  From the Contribution Guidelines:

## Asking Questions

> We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
 Please follow the instructions in the [README](https://github.com/Alamofire/Alamofire/blob/master/README.md#installation). The iOS example app runs on a device without any issues and many people in the community are using Alamofire on devices. The issue is specific to your project and you should ask your question on Stack Overflow as @mattt mentioned.
  Try encoding the parameters as `.JSON`.

``` swift
let parameters = [
    "arg1": [
        [
            "id": "001",
            "name": "person1"],
        [
            "id": "002",
            "name": "person2"
        ]
    ]
]

let request = Alamofire.request(.POST, "http://httpbin.org/post", parameters: parameters, encoding: .JSON)
request.responseJSON { request, response, json, error in
    println(request)
    println(response)
    println(json)
    println(error)
}

debugPrintln(request)
```
 @fanny303 No, this is intended behavior. From [the docs](http://cocoadocs.org/docsets/Alamofire/1.2.2/Enums/ParameterEncoding.html#/s:FO9Alamofire17ParameterEncoding3URLFMS0_S0_):

> A query string to be set as or appended to any existing URL query for GET, HEAD, and DELETE requests, or set as the body for requests with any other HTTP method. The Content-Type HTTP header field of an encoded request with HTTP body is set to application/x-www-form-urlencoded. Since there is no published specification for how to encode collection types, the convention of appending [] to the key for array values (foo[]=1&foo[]=2), and appending the key surrounded by square brackets for nested dictionary values (foo[bar]=baz).
  Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Thank you for your PR @skywinder. 

We're going to be reworking the entire test system in the `1.2.3` release coming very soon. We will be hardening the tests as well as adding safeguards around each test to ensure crashes cannot occur even if the tests fail.

I'm going to decline this PR because we're going to address this issue in a much bigger way. Thanks again. Cheers :beers: 
  Thank you for your pull request @SebastienMichoy! 

I have updated the iOS 7 instructions in 17bfcd1d. While I did not end up merging your PR directly, I thank you for bringing the documentation issue to our attention. Cheers :beers: 
  Apologies for not commenting on this earlier @skywinder. We really appreciate you submitting the PR! I merged a slightly modified version of your changes in 464e31b5 and credited you with the change.
  Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Your code sample appears to be incorrect. `var manager` is not `self.manager`.
 > Only remedy is to initialize manager for each session or use custom encoding and delegate to set the headers

That sounds about right. There's not much to be done about API differences between iOS 7 and 8, so it's best to not rely on any particular behavior there.
 > But initializing manager for each request, defeats the purpose of having manager.

Don't do that, then. Managers manage a session, which can make many requests.
 > Also I think in README it should be noted that on iOS 7, once a manager is initialized, configuration is read-only.

The README already notes that Alamofire is built on top of the Foundation URL Loading System, and that an understanding of those APIs is invaluable.
 You can always attached your `Referer` header to the `NSURLRequest` that is actually making the request on iOS 7. That will certainly work as a workaround.
 Hi @tosbaha, something like that could work. Here's a post on [Stack Overflow](http://stackoverflow.com/a/29814524/1342462) with more info.
 I wouldn't go as far as this:

> Because creating URLRequest by hand defeats the purpose of having URLRequestConvertible

But I definitely see your point of view. This type of approach is currently on our internal roadmap to investigate adding this feature in a future release. If it makes it in, you'll see it appear on one of the roadmaps on the tracked milestones.
  From the header documentation for `URLStringConvertible`:

>  A URL that conforms to RFC 2396.
>  Methods accepting a `URLStringConvertible` type parameter parse it according to RFCs 1738 and 1808.
>  See http://tools.ietf.org/html/rfc2396
>  See http://tools.ietf.org/html/rfc1738
>  See http://tools.ietf.org/html/rfc1808

The API consumer is expected to percent-escape accordingly. Otherwise, valid pre-escaped URLs  would not work as expected.
  Thanks for bringing this behavior to our attention, but I don't really see how this is related to #185. Why would an `NSURLProtocol` need to be aware of a session's additional HTTP headers?
 Hi @jonah-williams, while I see where you are coming from, I don't think this very specific case is something the Alamofire should attempt to handle for all users. The client logic could append the additional headers to each `NSURLRequest` directly, rather than attaching them to the `NSURLSessionConfiguration`.

Additionally, we are going to add header support to the `request`, `download` and `upload` convenience methods in the upcoming 1.3.0 release. This should also make handling this edge case much easier until Apple corrects the underlying issue.

Thoughts?
 Thank you very much for your detailed assessment @jonah-williams. After digging into this, I completely agree with your overall frame of mind. The `NSURLProtocol` does not respect all aspects of the session configuration which can lead to all sorts of problems as you have already pointed out.

I created a `URLProtocolTestCase` to replicate this behavior in b92f4e05. This at least let's us track this behavior on all our tested platforms. I'm sure we'll end up adding more tests in the future here. If you can think of any other useful test cases here or would be willing to write some others, I would be much obliged.

With all that said, I think it is probably wise to no longer recommend using an `NSURLProtocol` with Alamofire for anything other than for mocking out test responses. I think it could be very useful here and this is something that we're interested in documenting in a future release. 
  Thank you for bringing this issue to our attention. We'll get it fixed up right away!
 Fixed in 768b71e8. Thanks again for reporting this @twmsh! üçª
 Not sure what you're referring to @btelintelo. There is no issue that is back. That check is needed and there is no iOS check needed since we're dropping support for iOS 7 in Alamofire 2.0.
  I broke the project up into multiple Swift files separated into `Core` and `Features` groups. I was very careful to split each major change into a separate commit so we didn't lose any of the critical ACL changes that were required.

I also took a stab at reworking some of the MARK statements to attempt to make it as easy as possible to quickly find the section you are looking for. I think it turned out pretty well, but I really would love some additional feedback if something doesn't seem quite right.

I also found some other minor things that I'd like to switch up, but I filed separate cards in Trello for each of them. That way this PR focuses only on the task at hand üëçüèª

> All the tests are passing on iOS. We have a separate Trello card for fixing up the OS X tests.
 This looks great, @cnoon. Thanks so much for taking the time to refactor things into something a bit more understandable for anyone less familiar with the library.
  Hi @subicura, thank you for your pull request. I am seeing the same deadlock/timeout behavior as originally reported by @jhersh on Xcode 6.3.1. Therefore, I won't be merging this PR in. We plan to bring this issue to the Apple engineers at WWDC in June.

In the meantime, I have added response status code checks in 7d644e07. Thanks again.
  I'm going to merge this in @subicura, but passing in `nil` at the moment is causing deadlocks. Please see #350 and #424 for more info. There is also additional documentation in the tests.
  Could not reproduce running Xcode 6.3.1 and CocoaPods 0.37.0.

![alamofirepods](https://cloud.githubusercontent.com/assets/169110/7456333/83e2ce82-f238-11e4-9d35-1175dbcefcba.png)

---

Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
 Getting a "Page Not Found". If you can get the link fixed, I'd be glad to help.
  Please check out #395. I've already posted a bunch of info there and on the linked Stack Overflow question.

---

Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

> ## Asking Questions
> 
> We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Can you post a code sample that reproduces this behavior?
 `"http://www.domain.de/service.php?id=123&email=abcd@t√ºr.de"` is not a valid URL, as it needs to percent-encode the non-ASCII characters. This could be documented better.

Why not pass `["id": "123", "email": "abcd@t√ºr.de"]` as `parameters`? Alamofire will automatically escape that for you.
 eb4a945 documents the requirement for a `URLString` to conform to [RFC 2396](http://tools.ietf.org/html/rfc2396).
  We don't use Github as a support forum. Please open a question on [StackOverflow](http://stackoverflow.com) and tag `Alamofire`.
  A search through Alamofire's code does not show any mention of `OutputStreamType`.

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

> ## Asking Questions
> 
> We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  Cannot reproduce:

```
~ ‚ÆÄ pod search alamofire


-> Alamofire (1.2.0)
   Elegant HTTP Networking in Swift
   pod 'Alamofire', '~> 1.2.0'
   - Homepage: https://github.com/Alamofire/Alamofire
   - Source:   https://github.com/Alamofire/Alamofire.git
   - Versions: 1.2.0, 1.1.5, 1.1.4, 1.1.3 [master repo]


-> RACAlamofire (0.0.6)
   ReactiveCocoa extensions for Alamofire
   pod 'RACAlamofire', '~> 0.0.6'
   - Homepage: https://github.com/ararog/Alamofire-RACExtensions
   - Source:   https://github.com/ararog/Alamofire-RACExtensions.git
   - Versions: 0.0.6 [master repo]


-> TKAlamofire (1.1.4)
   Elegant HTTP Networking in Swift
   pod 'TKAlamofire', '~> 1.1.4'
   - Homepage: https://github.com/nicolastinkl/TKAlamofire
   - Source:   https://github.com/nicolastinkl/TKAlamofire.git
   - Versions: 1.1.4, 1.0.2 [master repo]
```

Try updating your version of the CocoaPods gem. Or perhaps you are confused by TKAlamofire? 
 This is not an issue with Alamofire. You should try asking the CocoaPods maintainers.
  Hi @aemreunal, apologies for not getting back to you sooner. At the moment, there is no direct support in Alamofire for trusting self-signed certificates or for SSL pinning. Support for this feature is already being discussed and is slated for the 1.3.0 release. We are taking security very seriously and it is at the top of our priority list. Please see #366 for more information.

---

With that said, you do have the option to implement your own pinning for the time being if you so choose. You would need to create your own `sessionDidReceiveChallenge:` closure to override the default `SessionDelegate` behavior.

``` swift
/// NSURLSessionDelegate override closure for `URLSession:didReceiveChallenge:completionHandler:` method.
public var sessionDidReceiveChallenge: ((NSURLSession, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential!))?
```

You could certainly dig through the [AFNetworking](https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking/AFURLSessionManager.m#L815-L844) logic to see how this can be implemented as well as this [link](https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning#iOS). Both should help get you started in the right direction.

I'm going to close this issue out for now. Please feel free to reopen if necessary. If you do need help implementing your own SSL pinning, then please direct your questions towards [Stack Overflow](http://stackoverflow.com) as per our guidelines.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
 There is not yet. We're still trying to lay out the roadmap. Once we have more info we'll be sure to start filling out the `Due Date` on issues and milestones. Cheers üçª
 No it should not be. Good catch!
  Looks good to me. Thanks, @cnoon!
  No, that's irrelevant. Just because Xcode 6.3 / OS X 10.10 is required to _build_ an app using Alamofire doesn't mean that those are the requirements to _run_ that app.
  When is Alamofire used with Carthage `--use-submodules` flag, folder `Carthage/Build` is automatically tracked as uncommitted change. But this is unnecessary in this case, so I think that is better to ignore it.
 For completeness, below are discussions about this topic:
- [Carthage/issues/420#issuecomment-95772555](https://github.com/Carthage/Carthage/issues/420#issuecomment-95772555)
- [jspahrsummers/xcconfigs/pull/37](https://github.com/jspahrsummers/xcconfigs/pull/37)
 Thanks @tomassliz!
 You're welcome, I'm glad to help.
  The `response` method always returns `NSData`. Use the `responseJSON` method instead.

This is not a support forum. In the future, please ask usage questions on Stack Overflow using the "Alamofire" tag.
  When I use Alamofire as [embedded framework](https://github.com/Alamofire/Alamofire#embedded-framework) and try to build with custom named scheme and configuration (e.g. `Test-Debug`) I get this error:

> No such module 'Alamofire'

So do the schemes and configuration names and its included embedded framework scheme names need to be the same?

Maybe this issue depends on settings `Per-configuration Build Products Path`, but I don't know if is ok to edit them.
 I asked this question on StackOverflow, but there was no answer after 14 days. I know that this is not directly Alamofire issue, but when @mattt describes how to use Alamofire as embedded framework, he might know the solution. I don't know anyone who could advise me.
 I deleted the question on StackOverflow, it deserved reformulation and example project. So I created this [new topic](http://stackoverflow.com/questions/29851269/dynamic-frameworks-and-project-configurations) on StackOverflow.
Sorry for creating this issue.
  :+1: 

Thanks, @siemensikkema.
  I just realized I haven't actually commented on this issue. Sorry for that gents.

@tobiasoleary, to your original question, yes, it would be nice to have a more verbose error system. We should have some better error handling logic around validation and anywhere else we can possibly throw an error. Since this will be a fairly large breaking change, we've slated this for the 2.0.0 release. We would also like to incorporate the new error handling logic from Swift 2.0 to make this process as simple as possible to use.
 Hey everyone!

I just pushed up PR #627 which adds much better support for validation error handling. If you could check it out and leave some feedback I'd really appreciate it! Please redirect all further comments to that issue since I'm going to close this one out.

Cheers.
  This is not an issue with Alamofire, but with your particular setup of Xcode. If you are still experiencing this problem, please try asking for help on Stack Overflow.
  Alamofire [has a passing test](https://github.com/Alamofire/Alamofire/blob/master/Tests/ResponseTests.swift#L53-L63) with essentially the same input. I suspect that the error returned is not actually related to the actual underlying problem.

For any further questions, please try asking for help on Stack Overflow with the "Alamofire" tag.
  @harshcs We've responded now twice to the same support request, asking that you please not do this again. Please respect @cnoon's and my authority on this project. Any code signing issues you're having cannot be related to Alamofire itself, as Alamofire is just a Swift file. It's all to do with how you're incorporating it into your project.
  Cannot reproduce. Try cleaning your project or re-installing from CocoaPods.

If you continue to experience problems and think that this might be an issue with CocoaPods, please open an issue with them. Otherwise, please ask a question on Stack Overflow with the "Alamofire" tag.
 @atulsha That is not a valid solution to this problem. Using an older, unsupported version of Alamofire is not a good idea. Alamofire 3.3 requires Xcode 7.3. @deck2osuab Try a cleaning your build environment after updating Alamofire and Xcode to the latest versions.
  I cannot reproduce.

Can you post the entire error / crash log?
 Maybe you're missing an `import Alamofire` statement?

If you have any further issues, please try asking on Stack Overflow with the "Alamofire" tag.
  Thanks, @cnoon.
  Your server is not sending an appropriate character set, so you need to specify UTF-8 explicitly. This can be done by passing `NSUTF8StringEncoding` as the `encoding` parameter of `responseString`.
  Thanks, @cnoon.
  Fixed by 6d1238d9ac9032980c27843fc27015d8db121cdd.
  Thanks, @cnoon.
  Don't wrap anything in a top-level struct. There is no need to change anything in the original source code. You'll just have to refer to things in the global module scope (e.g. `Request` instead of `Alamofire.Request`)
  Cannot reproduce. Everything works just fine for me with version 1.2.0.

![screen shot 2015-04-09 at 11 05 50](https://cloud.githubusercontent.com/assets/7659/7073452/70d1e5ec-dea8-11e4-8181-78dd5537475b.png)
  Thanks for this, @jhersh. I really appreciate it!
  Thanks for your PR, @swizzlr. I ended up merging in a few other things for 1.2.0, which is now available.
  I just tried to `pod trunk push`, but the pod won't validate since I've already upgraded to Xcode 6.3. @cnoon Do you still have 6.2 kicking around?
 @cnoon What's your CocoaPods collaborator email address? I'll add you on.
 Alright, added. Feel free to push 1.1.5 whenever you have a chance.
 Excellent! Thanks for saving the day, @cnoon!
 @Onetaway See https://github.com/CocoaPods/CocoaPods/issues/3389#issuecomment-92353876
  Version 1.2.0 is now available.
  Thanks so much, @natecook1000. Nice catch!
  Fixed by #420. Thanks for spotting that, @natecook1000.
  Thank you for your PR, @kiancheong. This should now be fixed in master, for the 1.2.0 release.
  Hi @skywinder, thank you for your pull request. Your generator seems very powerful, but we're still discussing how we'd like to format our CHANGELOG. We'll keep you posted üëçüèª
 We have completed our initial CHANGELOG in 34224b01. Thank you again for your pull request, but we've decided to roll our own manual solution for now to provide the highest quality info we can. Thanks again üçª
  Thanks for this, @getaaron.
  :+1: 
  Thanks again, @getaaron.
  Thanks, @getaaron, but the library is named "Alamofire", no internal capitalization. Any ideas on how this could be clearer? Seems a lot of folks make that mistake... (heck, if I had a nickel for every SWIFT or XCode question on Stack Overflow)
  The HTTP specification does not support a message body for `DELETE` requests. As such, the default behavior is to append parameters into the URL query. 

If your API insists on this convention, you can construct the request yourself.
 Ah, so they finally clarified that for RFC 7231. TIL.
  Thanks, @cnoon.
  Thanks for your careful consideration on this. I think you're entirely correct‚Äîthe best option is just to remove those "convenience" methods, which actually don't provide much utility on their own now (perhaps they were necessary in earlier versions of Swift; it's all such a blur now...)
  Hi @alivingston, my apologies for not getting back to you sooner. 

Thank you for your excellent assessment of the issue. After some investigation, I found that the progress closure would only be run on a `DataTask` if the `expectedContentLength` was able to be extracted from the `response`. Additionally, the `NSProgress` object (stored inside the `TaskDelegate`) was never being set for a `DataTask`.

This didn't feel like the correct behavior. If you tell Alamofire that you want to track the progress of the request, then track it you shall. The changes made in a285dd54 should be what you are looking for. They include:
- The progress closure on a data task will now always be executed when receiving data
- The `NSProgress` object will also be updated as well and now behaves exactly as the download and upload tracking

> The one caveat here is that it is possible for the `totalBytesExpectedToReceive` can be equal to `NSURLSessionTransferSizeUnknown`. This is the same behavior as the Download and Upload tasks, but I figured I should call it out.

If you could give these changes a spin I'd greatly appreciate it. Thanks again! üëçüèª
  Thanks, @pitiphong-p.
  Thanks for your PR, @inamiy, but I agree with @cnoon.

I was initially of the same opinion, and originally set their access level to `private`. However, as much as I'd prefer a non-leaky abstraction, where as much of the underlying `NSURLSession` APIs are irrelevant (as CFNetwork is to Foundation), there are just too many potential use cases (known and unknown) where _not_ exposing this would cause undue frustration.
  Makes sense to me. I'll tag a new patch release shortly.
  Thanks for looking into this, @cnoon. I'm just about to cut Alamofire 1.1.5. When that's released, can you please verify that things are working as expected?
  @Glagnar What you described is the URL Loading System working as intended. Credentials are only passed on an authentication challenge.
  Thanks, @cnoon.
  This is a CocoaPods or Carthage issue, and has nothing really to do with Alamofire. If you're annoyed by CI output, short of a real fix, you can always use `sed` or the like to filter out undesired warnings. 
  Thanks, @cnoon.
  Thanks, @mthole.
 SSL verification and customization has been part of Alamofire since the 2.0 release. If you have any concerns with that functionality, please use the Alamofire security email, security@alamofire.org, to contact us with your specific concerns.
  Fixed by 829fb1a.
  This is not a support forum. Please take usage questions to Stack Overflow.
  This is desired behavior. A valid URL does not contain whitespace, so attempting to construct an invalid one should fail immediately. Attempting to automatically remove whitespace may have unanticipated consequences.
 `NSURL` already has a failable initializer, which triggers an runtime error when force unwrapped. There are many different ways an invalid URL could fail to be initialized; I don't see a particular reason to call out any specific one‚Äîespecially if that behavior is not well-documented.
  Hi @nolanw,

Thank you for your Pull Request...it is much appreciated. I didn't end up merging your PR directly because the `APPLICATION_EXTENSION_API_ONLY` setting is already set properly.  

> The `APPLICATION_EXTENSION_API_ONLY` is set to `YES` in both framework targets. It is set to `NO` in the test and example targets.

I have updated all the deployment targets in ccc40a1a.

> Somehow these were reset when we merged the Swift 1.2 branch into master. Either way, ccc40a1a put us back on track.
  That's the `Content-Type` of the server response (note the 500 status code).

Please take usage questions like this over to Stack Overflow.
  This is not an issue with Alamofire. If anything, it's a CocoaPods issue. Perhaps open an issue with them?
  I cannot reproduce. Tests build and pass as expected on iOS and OS X with deployment targets of iOS 7 and OS X 10.9 with HEAD of master.
  I'm not entirely sure why this would be significantly more desirable than compiling from source for your target platform. Alamofire is a single, <1k SLOC source file. Building shouldn't take more than a second. 

Given the additional operational overhead of managing releases on GitHub in addition to normal tags, it's unlikely that this will be adopted.
  Thanks, @tosbaha. Fixed by 0cd66c2.
  Thanks, @skywinder.
  Beautiful. Awesome work, @kylef and the rest of the @CocoaPods team!
  Approved offline by TC.
  The addition of manager convenience methods for upload were made on master, and had not yet been downstreamed to this branch. 950eda9688c0e5538dcc4c97c2cdd45946a33f66 rebases against master to add the missing methods.
  [According to the RFC 2616 specification, the order of HTTP headers does not matter](http://stackoverflow.com/a/750338/157142). If your server is not accepting a request for this reason, there's very little that can be done, as ordering is not a capability guaranteed by software written to this specification.
  Thanks, @skywinder. However, an equivalent change was merged with #380.
  Fixed by #400 & #401
  Multiple parameter encodings isn't really a common convention for web applications, so it's not something I'd be interested to build any more specific support for. That said, `ParameterEncoding`, with it's `Custom` case and associated closure value can be used to compose a request without reimplementing either JSON body or URL query string encoding. The solution you described should work just fine.
 @mxl Why not? It's encoded in the URL for HTTP methods that do not support am message body, or in the body as `application/x-www-form-**urlencoded**` (emphasis added) for HTTP methods that designate a message body. That's just HTTP.
 @mxl Way too complicated for my tastes. The way it works now is flexible enough to handle any use case (including the one described by this issue), without exposing unnecessary API surface area.
 @mxl It's not a common case. And there is not going to be a one-size-fits-all solution; it's always going to be as hacky as the web service you're developing against. 

> By the way who puts url-encoded parameters in request body?

Every modern web framework supports this. It's convention.
 @mxl URL form encoding of parameters is a required feature for web services that do not support JSON encoding. Not everything an app might connect to is shiny and new.
 @mxl That's the thing‚ÄîAlamofire does support modern web services out of the box. That's what it was designed to do, and what it does. I'm not particularly interested in discussing this feature any further at this time.
 @Dschee An interesting point. However, this may be achievable right now by writing a custom `ParameterEncoding` that can take the additional `include`, `sort`, or `filter` parameters in a static function. e.g. `JSONAPI.include(_:sort:filter:)` that can then be passed in Alamofire's `request` functions or used to encode `URLRequest`s directly. However, concrete proposals or even PRs would help us further consider this request.

Personally, I don't like `JSON API` from an API design perspective, but I can see the usefulness of the functionality you described.   Core Data and NSCoding are orthogonal, and integration with either is left as an exercise to the user.
  I cherry-picked the specific change for escaped characters with 9075691ca5e2e53c7fcb6b286a19abee874e97d3. Thanks again, @slizeray!
  `stringByAddingPercentEncodingWithAllowedCharacters:` suffers from excessive memory consumption. See #206.
 @slizeray This is incorrect. According to [RFC 3986 ¬ß 2.2](http://tools.ietf.org/html/rfc3986#section-2.2), `/` is a general delimiter, and needs to be escaped.
 > Beware that some older, erroneous implementations may not handle such data correctly when it is used as the base URI for relative references...
> 
> ...it is sometimes better for usability to avoid percent-encoding [slash and question mark]

@slizeray That doesn't exactly inspire confidence. If it comes down to a question of usability concerns versus incorrect server-side handling, I'll err on the side of safety.
 @slizeray I wasn't aware of this specific difference in behavior previously, but knowing this now, I'm more comfortable keeping consistent default encoding behavior between Alamofire and AFNetworking. I understand how this might be inconvenient, which is why Alamofire offers two different ways to easily override this. First, you could use the `Custom` parameter encoding, supplying your own function to do the parameter escaping. Alternatively, you could bypass all of the URL encoding completely by passing a value of type conforming to `URLRequestConvertible` (`NSURLRequest` or a custom type) directly into `request`, `upload` and `download`.
  We removed the playground in the latest versions of Alamofire. Caused more problems than it was worth.
  This is not a support forum. Please ask usage questions on [Stack Overflow](http://stackoverflow.com/tagged/alamofire).
  Alright everyone, we've added this to the 1.3.0 milestone. Please stay posted üëçüèª
 @thegorgon The 1.3.0 release is currently slated for June 22nd which is only being used as a rough goal. The release will not ship until it's absolutely ready to go. There are some VERY important features rolling into the 1.3.0 release that we want to make sure we get exactly right.

Additionally, it is a pretty aggressive timeline and first requires us to get the 1.2.3 release out the door which we're currently right in the middle of. You can check out the [milestones](https://github.com/Alamofire/Alamofire/milestones) for more info.
 Okay all you plus ones...

PR #581 is up for all your pinning pleasure. If everyone could please help out with reviewing and testing, I would REALLY appreciate it. I'm going to close this issue out. Please redirect all further comments to #581.
  Thanks, @jspahrsummers.
  Thanks for your interest in contributing, @AnthonyMDev. This repository will remain focused on the fundamental networking use cases, but there is certainly room in the greater ecosystem to support specific web services. Please let me know when you complete this work.
  As @ssherar, this is resolved by #357. Thanks, @indragiek.
  Thanks for your PR, @kylef. I really appreciate you following up on #358 to find the underlying problem here.

We should definitely respect the server's character encoding, when provided. We should definitely follow the spec to use ISO-8859-1 by default. However, we should also provide a way to override this behavior for when the server is doing something wrong, and it's not possible to fix.

I implemented this with 6cffddcf150539daea674fa9367b63a1d46b0519, which should resolve the original issues. Let me know if I missed anything here.

Thanks again, @kylef.
  Fixed by 6cffddc. See #359.
 @staticdreams If you're expecting a JSON response (3840 is the error returned by `NSJSONSerialization`), you have to use UTF-8, as that's the only encoding supported by JSON. I'm not sure why you're suddenly seeing the error, but I would confirm that the string content of the response can be successfully decoded into a UTF-8 string.
 @staticdreams If you can take the data and, using `NSString(bytes:length:encoding:)`, try to create a string and make sure it looks correct. You can also try `canBeConvertedToEncoding()` on an existing string.
  Thanks so much, @rastersize. This is merged with 2f39b86.
  Hi @briv, thank you for all your work you've put in here! We have SSL/TLS Key/Certificate pinning slated for our 1.3.0 release. We're starting to discuss this now and will keep you posted. Thanks again for all your hard work here! üëçüèª
 At this point, I think it would be best to hold off. The technical committee (TC) has already decided that we need to build have one of us build out this feature. It is one of the most critical pieces of the library to get right and be able to provide top notch support for at all times moving forwards.

With that said, we greatly value your efforts here and this will certainly give us a head start when we get started!
 Hi @briv, I just pushed up a PR that implements TLS public key and certificate pinning. Thank you for all the hard work you put into this PR. It really helped get me going in the right direction. If you could please take a look at #581 I'd really appreciate it. I want to get everyone involved to make this feature rock solid.

I'm going to close out this PR. Please direct all further comments to #581.
  For usage questions, please try [Stack Overflow](http://stackoverflow.com/questions/tagged/alamofire). If you believe that this is a bug, please open a new issue with an example project that reproduces the behavior in question.
  Fixed by #400 & #401
  Thanks so much, @jhersh.
  Thanks, @tkrajacic.
  This is not a support forum. For installation and usage questions, please try Stack Overflow.
  Universal frameworks were an interesting idea, but due to incompatibility with other build tools, they were reverted with 36499d8f3d5e5ecf9c612a301c819c10baa402c2.
 @indragiek Yessir. 36499d8f3d5e5ecf9c612a301c819c10baa402c2 is on xcode-6.3 as well now.
  I cannot reproduce. There are [several passing tests](https://github.com/Alamofire/Alamofire/blob/master/Tests/ParameterEncodingTests.swift#L27-L218) that demonstrate parameter encoding working as expected. If you can, however, create a failing test case, please submit a PR.
  @rjjohnpatrickcruz This is not a support forum. Questions like this should be asked on Stack Overflow.
  Because this is a usage question rather than a bug in Alamofire itself, the best forum for this would be Stack Overflow. If anyone else is interested in this question, feel free to follow up on [this Stack Overflow question](http://stackoverflow.com/questions/28490129/alamofire-nested-json-serializer).
  For anyone targeting Swift 1.2, you can now use the [xcode-6.3 branch](https://github.com/Alamofire/Alamofire/tree/xcode-6.3). This will be merged in once Xcode 6.3 reaches GM.
  Thanks for the PR, @boek.

I ended up going through and porting the code to 1.2 making a few more idiomatic changes with d337018.

For anyone targeting Swift 1.2, you can now use the [xcode-6.3 branch](https://github.com/Alamofire/Alamofire/tree/xcode-6.3). This will be merged in once Xcode 6.3 reaches GM.
  Universal frameworks were reverted with 36499d8f3d5e5ecf9c612a301c819c10baa402c2.
  Unfortunately, there is very little that can be done without a reproducible test case, calling context, or stack trace. If you can provide any of these, please open a new issue describing your problem.
  Framework support is orthogonal to the base SDK API requirements, so I'm not sure what this really accomplishes. That iOS 7 targets cannot use dynamic frameworks should not have any impact on the declared SDK dependencies.
  Thanks, @obohrer. I'd been meaning to do an audit of the top-level and manager APIs. I appreciate you taking the time to make this patch.
  Thanks for your PR, @Reflejo, but there are no current plans to include UIKit extensions in the base project. AFNetworking's UIKit extensions work fine with Swift.
  Hi @florianwalter, our apologies for not getting back to you sooner. With that said, I've created a sample project called [AlamofireToday](https://github.com/cnoon/Alamofire-Example-Apps/tree/master/AlamofireToday) with your exact logic and it works as intended. I would encourage you to check it out. 

Hopefully you can spot the difference between what I've created and what you are doing. I'm going to close this issue out since I cannot reproduce it. If you are able to modify my project and produce your reported behavior, then please submit a PR against my example app and reopen this issue.

Cheers üçª
 Thanks @kcharwood, good catch. Will remove.
  Fixed by #394. Passing test added with 66587f700c5f6d453b0883f12a85de28e25d6272.
  I cannot reproduce following the instructions provided in the README. If your application target supports dynamic frameworks (iOS >= 8), I would strongly suggest using CocoaPods or Carthage.
  @JRG-Developer is correct‚Äîthis is intended behavior. Use custom parameter encoding if you need anything other than the provided options.
  Thanks, @tkrajacic.
  Thanks, @tkrajacic.
  I like this pattern a lot, and wasn't even fully aware that it was possible. Thanks so much for this, @kylef.
 Based on what @norio-nomura reports and the feedback from the Carthage folks, it looks like a universal framework is not the right solution for now. Thanks for your help though, @kylef. Reverted with 36499d8f3d5e5ecf9c612a301c819c10baa402c2.
  This sounds like something you should ask the @CocoaPods folks. Sorry, but I can't help you with this.
  Thanks so much for this, @yasuoza. I really appreciate it.
  I appreciate your contribution, but this PR is unnecessary.
  Thanks, @kylef.

@Reza-Rg This is not a support forum. In the future, please take usage questions to Stack Overflow.
  :+1:

Thanks, @astrabot.
  Thanks so much for your hard work on this, @cnoon. I merged everything into master, and am excited to have this all for the 1.2.0 release. :bread:
  Thanks, @cnoon.
  :+1: 

Thanks, @rborkow.
  Sorry, but this is not a support forum. If you have a specific question about troubleshooting, please try asking on Stack Overflow.
  @51cc You're using an out-of-date version of Xcode. Please follow the instructions in the README, ensuring that you have the necessary requirements.
  This should be fixed with the 1.1.4 pod.
  See #215.
  Fixed by #400.
  Thanks, @kylef.
  Thanks for your work on this, @mk. I cherry-picked 855e9c1 and setup my own OS X target, which is now on master.
  This is not a support forum. For usage questions, please try Stack Overflow.
  No. See #298.
  Thanks for raising this point, but I disagree that this would be preferred in a majority of cases. My primary objection is that the HTTP header is `Accept-Language`, so it's looking for languages, not locales. I think it would be, in many cases, indeed preferable to have an API send back responses according to the preferred language, even if not supported by the app bundle.

Of course, this is entirely contingent on the app and API themselves. The provided `Accept-Language` is just a default value, and can be overridden in one line of code.
  Thanks, @kylef.
  This is not an issue with Alamofire. For any questions about using CocoaPods, you should ask the good folks working on that project.
  We're looking to add better support for this in the 1.3.0 release. Please stay posted üëçüèª
 Hey everyone, thank you so much for your patience! I just pushed up PR #593 for Response Serializer Generics. If you could check it out and help with feedback I'd really appreciate it.

If you could please redirect all comments to #593 from here on out, that would be helpful. I'm going to go ahead and close this issue out.
  Closing out this PR since it won't ever be merged into Alamofire core. Please see #290 for more details.
  Awesome. Excellent work, @mk. I really appreciate you taking the time to do this.
  Caching indeed works, as part of the NSURLSession API. See [this Stack Overflow question](http://stackoverflow.com/questions/27785693/alamofire-nsurlcache-is-not-working).
 We're in the process of adding tests around this usage for the `1.2.3` release. Stay tuned...
  Sure. Thanks, @mrahmiao.
  Hey everyone, 

Now that news about the [Alamofire Software Foundation](https://github.com/Alamofire/Foundation) is out, we can get back to business here. I have the majority of this library completed, and am working with the rest of the TC to get everything in tip-top shape before releasing the initial version. I'm going to close out the PR for now since it will never be merged into Alamofire core. Still no solid release date, but feel free to comment on this issue with questions until the initial release is out.
 Hey @AnthonyMDev, this is definitely still in the queue. We've decided to first focus on the Alamofire 1.3.0 release and will then cycle back to AlamofireImage.
  > HTTP POST works fine through Java and PHP so I know there isn't anything wrong with the server.

That's not a safe assumption. I wouldn't trust every client library to correctly handle SSL.

Given that this behavior is reproduced with another library, this is not an issue specific to Alamofire. Rather, this is either a bug in the underlying Foundation URL Loading System, or‚Äîmore likely‚Äîincorrect  code on the client or server.

For specific usage questions, please try Stack Overflow. This is not a support forum.
  Maybe try `import Alamofire`?

I cannot reproduce this. Alamofire now supports distribution using CocoaPods and Carthage, so you might want to try using one of those instead.
 @MaxHasADHD I cannot reproduce this issue, and many others have successfully used Alamofire in shipping applications. Your decision not to use tools that automate installation is totally on you.
  Equivalent changes have since been applied. Thanks for the PR, @rynecheow.
  Alamofire is specifically not designed to be compatible with Objective-C. It is up to the API consumer to provide the appropriate bridging accommodations to integrate it within an application.

For apps using Objective-C, try AFNetworking instead.
  A functional approach to networking was considered at the very start of the design process, but was found to be fundamentally incompatible with the architecture of `NSURLSession`. Alamofire represents the best effort to maximize productivity and convenience when using existing Foundation URL Loading System APIs in Swift applications; unfortunately, that doesn't allow for the kinds of functional paradigms that I might have liked to explore had it made sense to roll a TCP stack from scratch.
  Fixed by #258. Appreciated all the same, @marcelofabri.
  POST requests don't send parameters in the URL. There are several passing tests that validate correct behavior for request sending.

This is not a support forum. Please take any specific usage questions to Stack Overflow in the future.
  What makes you think that Alamofire doesn't already do this? It's all just a wrapper on top of `NSURLSession`. Pass in the right configuration, and everything should work as expected, no?
 I'm sorry, but I don't really understand if this is an issue or not; whether this is a bug in Alamofire or a misunderstanding of how to use the `NSURLSession` APIs.

If this is an issue with Alamofire, please submit a PR with a failing test that demonstrates the issue. With that, I would be more than happy to work towards a solution.
  Please do not report questions from Stack Overflow. This is not a support forum.
  See #218.
  Thanks, @kylef!
  Looks good. Thanks so much for this, @astrabot.
  This is not a support forum. As stated in the README, general questions should be taken to Stack Overflow.
  Duplicate of #218.
  I'm sorry, but I don't understand what this accomplishes...

`NSURLSession` download tasks download to a temporary directory, and it's up to the API consumer to move the file to a permanent location upon completion. Files in temporary directories are not guaranteed to stick around beyond that first opportunity, so it doesn't make sense _not_ to enforce this (even if it is just moving to the same location, if that behavior is desired for whatever reason).
 The purpose of this method is to, in fact, download a file over a network connection. If you don't need or want the downloaded file, you should either remove the file afterwards or not make the request in the first place. I see no compelling reason to compromise the existing semantics to accommodate such a use case.
  Thanks, @technomage. Fixes #268.
  This is a question about using Git, not having to do with Alamofire specifically. If you continue to experience this problem, try asking on Stack Overflow or another appropriate forum.
  Duplicate of #266.
  This is not a support forum. As per the README, please take general questions like this to Stack Overflow, or another appropriate forum.
  Thanks for bringing this to my attention, @cnoon. It appears that the correct course of actions was to simply remove `deinit`, which is done with e356b9f, which is a squashed merge of your original PR. @corinnekrych's suggestion of trying `finishTasksAndInvalidate`  yielded the same results.

For lack of a more involved change, I've documented the requirement for session task invalidation before reinitialization with d41b8da.
  Sorry, but I'm not really sure what you're asking... Have you read through the [App Extension Programming Guide](https://developer.apple.com/library/ios/documentation/General/Conceptual/ExtensibilityPG/index.html)?
 Fixed by #273.
  As stated in the README, iOS 7 does not support embedded frameworks.
  `kCFURLErrorCannotParseResponse   = -1017`. For whatever reason, your server is not responding with a valid HTTP response.

However, this is not a support forum. For help on specific usage, please try Stack Overflow.
  >  How can I use them like strings (true or false).

There is no standardized representation of boolean values in URL-encoding, either on the client or server. Convert them to strings ahead of time.
  Thanks, @nathanborror.
  @mattt wrote up a good answer [here](https://github.com/Alamofire/Alamofire/issues/157). If the manager is not retained, the running task is cancelled while the underlying `NSURLSession` is being shut down. That is most likely your issue. If that does not fix it, please open a new question on Stack Overflow.
  Thanks, for the PR, @cnoon! I'd been considering this for a while myself.
  Since HTTP status codes are a closed set of constant values, an `enum` would be a more appropriate choice. That said, providing this in the framework seems unnecessary.
  Thanks, @slash7.

I cannot provide technical assistance for specific installations of Alamofire. If you have further questions, please try Stack Overflow or another appropriate forum.
  Thanks, @philipheinser!
  Ah geez. Thanks for pointing this out, @cnoon. I'll have to write a previously-failing test to make sure this doesn't happen again.
 Much appreciated all the same. I'll push out a new release in the morning.
  Thanks, @tkrajacic. You are correct‚Äîthe underlying Foundation URL Loading System handles this automatically.
  Thanks, @mowens. A new version has been tagged with this change.
  >  It would be nice to have methods that explicitly expects JSON Array or JSON Object and fails when it doesn't get such response.

That's already the default behavior. `NSJSONSerialization` will return an error if the root object is not a collection if `NSJSONReadingAllowFragments` is not set as the reading options.

Beyond that, it's up to you to determine how to interpret the `AnyObject` returned from `NSJSONSerialization`.
  As stated before:

> As for --compressed, this also feels unexpected. The point of the curl command output is to debug the request going out, rather than emulate the response. Any additional processing or logic should be left up to the end user, who can append additional flags or pipe / output as appropriate.

There are other reasons why this might not be a good idea. From the `man` page:

> `--compressed`
> 
> (HTTP) Request a compressed response using one of the algorithms curl supports, and save the uncompressed document. **If this option is used and the server sends an unsupported encoding, curl will report an error.**

If anyone wants or needs this behavior, it would be trivial to concatenate the necessary `--compressed` flag at the end of the command.
  As stated in the README:

> Since there is no published specification for how to encode collection types, the convention of appending [] to the key for array values (`foo[]=1&foo[]=2`), and appending the key surrounded by square brackets for nested dictionary values (`foo[bar]=baz`).

For now, any other convention of nested parameter serialization should make use of `ParameterEncoding.Custom`.
  Thanks for your contribution, @puls.

Generally, project maintainers prefer to have PRs (as well as individual commits) focused on one particular feature. Just something to keep in mind in the future.

Regarding empty JSON response serialization, I don't think this is a necessary change, as `NSJSONSerialization` already returns `nil` if its `data` parameter is zero length:

``` swift
NSJSONSerialization.JSONObjectWithData(NSData(), options: nil, error: nil)
// nil
```

And even if it weren't, it feels out of place to add a conditional before handing off to the designated serialization API. That is, someone might ostensibly depend on `NSJSONSerialization`, in this case, to return a particular value or to populate its `error`.

As for `--compressed`, this also feels unexpected. The point of the `curl` command output is to debug the request going out, rather than emulate the response. Any additional processing or logic should be left up to the end user, who can append additional flags or pipe / output as appropriate.
 > Given a RESTful web service endpoint that can return JSON or return nothing with an appropriate status code, a successful request can return an error or not return an error and the developer would be left trying to glean information from an NSError object, something you've previously advised against.

I was only advising against errors as a means of communicating validation failure. This is, however, necessary for `NSJSONSerialization` or `NSPropertyListSerialization`, which normally produce error objects.

> Finally, given that there's no documentation in the API that responseJSON uses NSJSONSerialization...

[This is incorrect](https://github.com/Alamofire/Alamofire/blob/master/Source/Alamofire.swift#L1356):

> >  Creates a response serializer that returns a JSON object constructed from the response data using `NSJSONSerialization` with the specified reading options.
  Can you provide any context for this change? Preferably in the form of a failing unit test? It's unclear what this is PR is attempting to fix...
 Perfect. Thanks so much, @sunnycows!
  "file was built for arm64 which is not the architecture being linked (armv7)"

You're building for the wrong architecture.
 Whatever the issue is, you can probably replicate it on a normal local build to the device or simulator by changing "Build Active Architecture Only" to NO for DEBUG mode.
 I cannot provide technical assistance for specific installations of Alamofire. If you have further questions, please try Stack Overflow or another appropriate forum.
  Thanks, @nsarno.
  Sorry, but you're entirely mistaken about how HTTP or Alamofire works. This is documented and expected behavior.

Collaboration is a virtue to be celebrated, but sending pull requests based on opinions and guessing do more harm than good, as they are a burden on project maintainers.
  Duplicate of #243. Please do not re-open closed issues like this.
  See #243.
  Could not reproduce in either Xcode 6.1.1 or latest Xcode 6.2 beta with latest version of Alamofire.
  I can't reproduce this. Alamofire uses [HTTPBin](http://httpbin.org) as a backing web service for both the example app and test suite, and both GET and POST requests echo back their respective form parameters as expected.

If problems still persist, please open a pull request with a failing test against HTTPBin that demonstrates the issue.
  Thanks, @flovilmart. Committed with a bit of refactoring in ae2ea5a. A new release is forthcoming.
  GitHub Issues is for reporting bugs or discussing features in the framework. Please take any specific usage questions or Xcode debugging questions to Stack Overflow or another appropriate forum.
  Cannot reproduce. Make sure you are using the latest version of Alamofire and Xcode.
  You have it backwards: adding Alamofire as a single file is what would be hacky. I'm not at all happy about the hoops necessary to distribute this as a shared framework, but that's ultimately the correct way to do so. Fortunately, CocoaPods and Carthage are working to make this process seamless, and should be GA soon.
  As per the README, please ask general questions on Stack Overflow or another appropriate forum, so that GitHub Issues can focus on bugs and feature requests of the framework.
  The blocks associated with each chained response handler are, in fact, being executed in order. However, because the `jwtJson` object takes longer to create than `string`, the `responseString` block finishes first.

There are no guarantees about the ordering of chained responses, save for the fact that `validate` acts like a barrier, with subsequent response handlers producing errors if invalid.

The reason no ordering is guaranteed by the framework is to avoid unnecessarily blocking for response handlers to complete. If you really need two separate response object types, you can use `dispatch_group` to manually execute behavior on processed objects in the desired order, or simply create a new response handler that produces both JSON and a string representation as necessary.
 You assumptions are correct @mrubin. If you don't specify custom `queue`s to run the `response` closures on, it will fallback to the main queue which will result in serial behavior for that request.
 So reading back through this thread is pretty interesting. The original response from @mattt clearly indicates that it was running the response serialization closures in parallel. However, when looking back at the codebase in b5d6f581 around the time of that response, I don't think that was possible. The `TaskDelegate` queue has always been a serial queue.

That same behavior was still maintained in aa6ea80b when we switched it from using a `dispatch_queue_t` to an `NSOperationQueue`. Nothing really changed except being able to cancel the operations in a forced shutdown scenario which allows the `Manager` instance to deallocate gracefully.

Now to really answer this question, we need to understand what's going on. Here's the order of operations that govern this behavior:
1. Create request
2. Add responseJWT implementation onto the Request's internal serial queue
3. Add responseString implementation onto the Request's internal serial queue
4. Request finishes, start up the serial queue
5. Executes the responseJWT implementation on the serial queue
6. Calls the responseJWT completion closure on whatever queue was provided (main by default)
7. Executes the responseString implementation on the serial queue
8. Calls the responseString completion closure on the provided queue (main by default)

There's no simple way to break the chaining here. You could couple your response serializers to depend on each other allowing the following ones to `early out` if certain conditions were met, but that seems a bit strange. I think that you'd instead want to build a single response serializer that could handle the multiple scenarios as a single, cohesive operation.

The custom response serializer could also take in multiple closures to chain together inside the response serializer. Either way, if you need to chain these operations together with the concept of breaking the chain, then the default behavior here is not going to work in your favor.
  In that case, you can validate only the content type and switch on successful status codes as necessary. Or, again, you can create a custom response handler that populates objects as desired.
 So just as a heads up...this is now supported in the `swift-2.0` branch through the in the default `response` serializers and also in the generic response serializers using the `Result` type. If there is ever an error that occurs anywhere in the request process, you will now receive the error and the original server data if it is available.

I'd encourage you to check it out. All the [documentation](https://github.com/Alamofire/Alamofire/tree/swift-2.0#response-handling) has been updated accordingly.
 Hi @ziogaschr, thanks for your feedback. In the future, please comment directly on the issues you are referring to. That way we keep the conversations going in the correct location. 

With that said, your suggestion is actually how it works in Alamofire 2.0. The `.Failure` case contains the `NSData?` from the server where the `.Success` case only includes the parsed object. While this is certainly the common use case, other outside the box features such as custom logging or DVR playback may need access to the original data, even in the `.Success` case. Therefore, in Alamofire 3.0, the original server data is ALWAYS returned in all the custom response serializers, not just in `.Failure` cases. If you don't need to use it, then don't. 

Additionally, in #792, the `Response` object encapsulates the fact that the `NSData?` is even available. Therefore, you don't need to access it if you don't actually need it.

Cheers.
 Are you running two parsing schemes? I don't quite understand your use case. Could you post some pseudo code or actual code of what you're attempting to do? I have a few different ideas, but I want to make sure I actually answer your question.
 Thank you for providing sample code. That makes it SOOO much easier for me to tell what you're trying to do. In this case, I would recommend working a bit more with Alamofire rather than against it. Let me explain.

Instead of trying to return a parsed JSON object in a failure case, take it one step further and convert the JSON object into a custom error that your app handles. In your example, rather than returning the `ResponseHandler` type, return a custom `RateLimit` error. You can use associated values on the `RateLimit` case if you need to keep any of that data. Although, I don't really think at the app level you need to know anything other than what the URL request was as well as the error that occurred.

You're already doing this in the second error case where you're catching invalid data prior to parsing the JSON and capturing it in a custom error.

Lastly, your final SwiftyJSON parsing case "could" use generics to attempt parse the JSON into a concrete model object. Then your `Result` type could return something like a `User` object rather than a vague `ReponseHandler` type.

Does that all make sense?
 No worries man, glad to help! üçª
  CocoaPods support is coming soon (See #218). Until that time, only the documented installation steps are supported. I unfortunately cannot provide any assistance in using Alamofire in an unsupported way.
  > From what I understand I have to use a shared manager for manipulating header configuration like this...

No, that's only for headers that are consistent across all requests. If it's for a single request, you'd pass an instance of `NSURLRequest`.
  At the time of writing, Swift did not yet have failable initializers, which is definitely something that would be desirable when interacting with unknown and potentially untrusted data from an external web service. b5d6f58 makes this change to add such a consideration.
  See #220
  Thanks for this, @ishkawa. Apologies for the delay in getting this integrated.
  From their README:

> CocoaPods projects must also have what‚Äôs known as a podspec file, which includes metadata about the project and specifies how it should be built. **Because Carthage uses xcodebuild to build dependencies, instead of integrating them into a single workspace, it doesn‚Äôt have a similar specification file.**

As far as I can tell, there are no additional steps necessary for Alamofire to be compatible with Carthage. If there is a specific change that needs to be made to the project workspace in order to support it, I'd be happy to review that pull request.
  Indeed, this changed in the latest version of Swift. Fixed by fb5592e01b1af5d657fd17a39a39ad6895b2173e.
  This functionality is not currently provided. There are no current plans to add this as a feature.
  Why not invoke a currying function or other kind of partially-applied callback in the response handlers of contingent requests? Alternatively, you could invoke a function in the response handlers for each request to check the number of active session data tasks.

An implementation on the manager itself is probably not a great solution, since it relies on mutable shared state (additional requests may be made or cancelled at any time). 
  Thanks for your suggestion, @cosminstirbu. This seems like something that would be better served by a separate `NSURLProtocol` subclass, which could intercept all networking traffic, regardless of framework. This isn't the route AFNetworking took, but it's probably what I'd recommend going forward.
  Alamofire builds against the iOS 7 SDK, but distribution through dynamic frameworks requires iOS 8.
  This is most likely related to server behavior rather than anything to do with Alamofire. Please take this over to Stack Overflow, or another appropriate forum.

If, however, you can provide an example project that reliably reproduces this behavior, I would be more than happy to investigate.
  See #218.
  Thanks for the PR, @puls.

Validation is one of the core value propositions of AFNetworking, at least as I see it. Unfortunately, it also appears to be a central point of confusion (or at least this feature in combination with a lack of understanding about HTTP). There are so many questions on Stack Overflow that ask "why doesn't his work?" when the error is, at least I thought, pretty explicit ("Unacceptable content type `text/html` when `application/json` was expected"). Even worse, I've seen apps even use these `NSError` objects verbatim to alert the user. Even for a savvy user, knowing that the app got a 404 is not actionable or useful. 

All of this leads me to believe that there's diminishing value in attempting to communicate anything through an `NSError` object. 

Validation is an opt-in feature in Alamofire, so the onus is on developers to respond to failure accordingly. In production, a validation error should be handled as a failure; any further logic like "if status == 500 but the JSON is formatted like this error message..." should be already handled by the response serialization.

As such, my recommendation to the end user is to treat a validation error as an opaque signal to signal a failure.
 > I'm not sure how providing less information at the API level forces better UI or fewer questions on Stack Overflow. If the onus is on developers to respond to failure accordingly, shouldn't they be able to respond better if they know why validation failed?

Information is only valuable if people know how to use it. An overwhelming amount of anecdotal evidence tells me that an error like the one used by AFNetworking is not something that people know how to interpret.

> (The scenario I envision: all client networking errors are reported back to a service out of band as a diagnostic; a spike in unacceptable content types is much more actionable than a spike in generic validation errors.)

Why not then create a new function `validateWithDiagnostics` that runs `validate` and logs the `request` and `response`?
  @mrackwitz Thanks for all of your great work in bringing Swift support to CocoaPods. I couldn't be more excited to be able to take advantage of this.

After reading through CocoaPods/CocoaPods#2835, I got the sense that official support might be a little ways off. If that's the case, I'd prefer to keep this unmerged until everything is good-to-go, so as to avoid any confusion. Would not merging this now be blocking you in some way? 
 @kylef Sounds good. Thanks, @mrackwitz for the PR. I'm really happy to do what I can to help drive CocoaPods adoption for Swift. This is going to be a huge improvement to how folks get started with Alamofire; I can't thank y'all enough for all of your hard work to make this possible.
  This is a non-issue. An empty string works and is semantically appropriate.
  Please do not cross-post questions from Stack Overflow.
  AFNetworking already processes response data on a background queue (using the main queue would be inappropriate). Occasions which would necessitate a custom queue are going to be relatively rare, and usually entail some other nontrivial accommodations. In those situations, I'm comfortable relying on the existing mechanism for specifying a custom response serialization handler.
  Please do not cross post [questions from Stack Overflow](http://stackoverflow.com/questions/26834293/swift-could-not-build-objective-c-module-alamofire).
  Thanks for the PR, @brandonroth. Doing a quick search through the README showed a few other cases where an `NSURL` initializer needed to be updated (d7f07d1). One other stylistic difference is that I prefer to have the `!` on the initializer itself, rather than add it on each use.
  This PR does not cleanly merge into master. Please resubmit with only the necessary changes.
  This is a question regarding NSURLSession, not Alamofire. Please take this over to Stack Overflow or another more appropriate forum.
  :+1: 

Thanks, @segiddins.
  Thanks so much for the thoughtful writeup of this issue. It's really surprising that `stringByAddingPercentEncodingWithAllowedCharacters` would have such a glaring memory consumption issue. If you haven't already, I would strongly encourage you to file a radar about this.

Since this behavior is not produced in AFNetworking, it makes sense to just adopt the approach used there. dc1fd5c does exactly this, by porting over the same CFURLCreateStringByAddingPercentEscapes call used by AFNetworking.

Please let me know if this does not resolve your issue.
 @TheWalkingDead1024, if you are having an issue in AFNetworking, then please open a new issue in that project.
 cc @kcharwood 

Thank you for reporting this issue @TheWalkingDead1024. My apologies for first pointing you towards the AFNetworking project. This issue actually spans both projects.

The approach previously taken to use the `CFURLCreateStringByAddingPercentEscapes` Core Foundation call was perfectly fine until the call was deprecated in the iOS 9 SDK. Therefore, we needed to move off that call back to `stringByAddingPercentEncodingWithAllowedCharacters` to get away from the deprecation. Unfortunately, when that change was made, we forgot about this previously closed issue.

After much debugging, I was able to track this issue down to only occurring in Alamofire on iOS 8.1 and 8.2 using the iPhone 4S and iPhone 5 simulators. It is 100% reproducible, but is crashing in different ways depending on the size of the Chinese string that is passed in. It's always some form of a `malloc` error. The following sample code will reproduce the issue in the iOS Example app.

**AppDelegate.swift**

``` swift
import Alamofire
import UIKit

@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate, UISplitViewControllerDelegate {

    var window: UIWindow?

    // MARK: - UIApplicationDelegate

    func application(
        application: UIApplication,
        didFinishLaunchingWithOptions launchOptions: [NSObject : AnyObject]?)
        -> Bool
    {
        dispatch_after(
            dispatch_time(DISPATCH_TIME_NOW, Int64(2.0 * Float(NSEC_PER_SEC))),
            dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0))
        {
            self.runLargeChineseCharacterEncodingTest()
        }

        return true
    }

    func runLargeChineseCharacterEncodingTest() {
        let repeatedCount = 20_000
        let URL = NSURL(string: "https://example.com/movies")!
        let parameters = ["chinese": String(count: repeatedCount, repeatedString: "‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ")]

        let start = NSDate()
        print("starting parameter encoding")
        ParameterEncoding.URL.encode(NSURLRequest(URL: URL), parameters: parameters)
        print("finished parameter encoding: \(NSDate().timeIntervalSinceDate(start)) seconds")
    }
}

extension String {
    private init(count: Int, repeatedString: String) {
        var value = ""
        for _ in 0..<count { value += repeatedString }
        self = value
    }
}
```

I've also added a unit test in 4f6b2956 to verify that the encoding works as expected. The test will fail 100% of the time without the solution in place. Unfortunately it causes the test suite to crash rather than fail without the solution implemented, but that's the way it is due to the nature of the issue.

**Unit Test**

``` swift
func testURLParameterEncodeStringWithThousandsOfChineseCharacters() {
    // Given
    let repeatedCount = 2_000
    let URL = NSURL(string: "https://example.com/movies")!
    let parameters = ["chinese": String(count: repeatedCount, repeatedString: "‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ")]

    // When
    let (URLRequest, _) = encoding.encode(NSURLRequest(URL: URL), parameters: parameters)

    // Then
    var expected = "chinese="
    for _ in 0..<repeatedCount {
        expected += "%E4%B8%80%E4%BA%8C%E4%B8%89%E5%9B%9B%E4%BA%94%E5%85%AD%E4%B8%83%E5%85%AB%E4%B9%9D%E5%8D%81"
    }
    XCTAssertEqual(URLRequest.URL?.query ?? "", expected, "query is incorrect")
}
```

## Solution

As reported originally by @PrideChung, the only workaround is to limit the encoding calls to a character limit by splitting the operation into a batch call. This is the approach I used in 4f6b2956 which does in fact fix the problem. I've also added documentation to the `escape` implementation to remove the batching once iOS 8 is no longer supported by Alamofire. 

For now, I've set the batchLimit to 50 which tends to add about a 20% overhead. This overhead is negligible in most cases until the parameter to encode gets extremely large. In the event of extremely large parameter data, the encoding should be done asynchronously.
 It was only found to crash for iOS 8.1 and 8.2, hence our workaround only affects those OSes. There shouldn't be any further issue here. If you are seeing a new crash, please open a new issue.  This is not an appropriate forum for asking this. As stated in the README, this should be asked on Stack Overflow or the like.
  GitHub Issues is not the correct forum for discussing specific implementations. For that, try Stack Overflow instead.
  CocoaPods doesn't support Swift yet, as stated in the README. When it is, Alamofire will certainly add support for it.
  Check that you have the latest version of Alamofire downloaded, meet all of the requirements, and install exactly according to the instructions. For any further questions, try Stack Overflow.
  Thanks, @powerje.
 Just FYI, we just released [AlamofireImage](https://github.com/Alamofire/AlamofireImage)!
  > I'm not sure why this occurs, but it's probably not Alamofire.

It's not Alamofire. None of the methods you listed are at all related to Alamofire.

I'm sorry that you're experiencing this issue, but I hope you reach a resolution soon.
  This is a consequence of the implicit conversion when storing `lon` in `parameters`:

``` swift
println("parameter values: \(parameters.values.array))") 
// parameter values: [42.358056, -71.06361099999999, bar])
```

There is nothing that Alamofire can do to work around this limitation. To ensure a particular level of precision of floating point numbers, use the `NSString` formatting functions.
  Thanks again, @cnoon.
  This is an issue with the Swift compiler, not anything specifically to do with Alamofire. Please try asking on the Apple Developer Forum or Stack Overflow.
  I cannot reproduce. All tests pass and the example project works as expected on master using Xcode 6.1.

If your project isn't recognizing `dispatch_suspend`, you have more serious issues...
  I'm making the following request:

```
        Alamofire.request(.GET, "\(self.url)/cities")
            .authenticate(user: self.user, password: self.password)
            .response {(request, response, _, error) in
                println(response)
        }
```

but i get 

Optional(<NSHTTPURLResponse: 0x7fb6d46089a0> { URL: https://.../v1/cities } { status code: 404, headers {
    "Access-Control-Allow-Origin" = "*";
    Connection = "keep-alive";
    "Content-Encoding" = gzip;
    "Content-Length" = 369;
    "Content-Type" = "text/html; charset=UTF-8";
    Date = "Wed, 22 Oct 2014 18:05:35 GMT";
    Server = "nginx/1.1.19";
    Vary = "Accept-Encoding";
} })

a 404 because the basic auth token header isn't being included... what am I doing wrong?
 @adamwaite Yes I'm sure. I can cURL using the same url and everything works as expected.

curl -i -u <user>: -H "User-Agent: Stayful/com.stayful.stayful-iphone (1; OS Version 8.1 (Build 12B411))" -H "Accept-Encodin: gzip;q=1.0,compress;q=0.5" -H "Accept-Language: en;q=1.0" "https://.../v1/cities"
 @adamwaite but I don't think .authenticate is working because I don't see auth headers being passed to the endpoint at all
 @macu i'm not sure what you mean but i'm simply expecting the basic auth headers to be sent along with my request because I've set the .authorize(user:pass:) on the request obj
 @troypayne That's not how authentication challenges work. Read the URL Loading System Programming Guide for more information.
  Thank you for your pull request @ivanmoskalev. Apologies for not getting back to you sooner. You can actually get the resume data from the code sample I posted in #141. Also, we're going to add better support for resume data in the 1.3.0 release. Please follow the progress of #141 for future updates.
  Yes. This is explicitly documented.
  :+1: 

Thanks, @johnbeynon.
  Ugh. Sorry that didn't work out as expected. What I meant to say was "wrap everything in a `struct Alamofire { ... }` to simulate a namespace. See 8e2e525.
 @joshuatbrown Yeah, nothing like that in Swift. Even if such a macro did exist, that wouldn't work, since Only the top-level type declarations would be wrapped. All of the extensions would need to be left as they are.
  You are correct‚ÄîAlamofire does not directly implement this functionality. My current thinking is that this should be handled entirely by a separate `NSURLProtocol`-based mechanism, which could be shared between AFNetworking and Alamofire.
  The existing Xcode 6.1 branch was merged in with 959fb5ea53fd128e877c9bb4fec964794730d877. If there are any outstanding changes from this PR that you would like to incorporate, please add them in a new PR.
  It's all in the example. OAuth tokens are set in a request header.
  The existing Xcode 6.1 branch was merged in with 959fb5e. If there are any outstanding changes from this PR that you would like to incorporate, please add them in a new PR.
  Fixed by #167.
  Exposing the initializer for `Alamofire.Request` is a no-go. Objects initialized in this fashion are not connected to an owning manager, which is necessary for actually getting requests to work. It'd be irresponsible to expose an incomplete interface for the sake of dependency injection.

A much better solution would be to stub and mock the requests themselves, using `NSURLProtocol` (or any of the off-the-shelf solutions for HTTP mocking / stubbing). 
  For general questions like this, please use [Stack Overflow](http://stackoverflow.com/questions/tagged/alamofire) instead. GitHub Issues are for reporting bugs and discussing features.
  Thanks, @johngibb!
  Xcode 6.1 is not officially released yet. Alamofire will merge this branch and require Xcode 6.1 once it is.
  CocoaPods does not yet support Swift dependencies. This is specifically noted in the README.
  Thanks for the PR, @parto. I ended up taking it a step further in 923c009 by changing the queue to concurrent and using a barrier async on the setter.
  :+1: 

Thanks, @mac-cain13.
  Hi,

Is there support or will there be support for timeouts? I'd like my request to die out if it doesn't return within 4 seconds.
 Timeout interval is a configurable parameter of `NSMutableURLRequest`.
 @mattt How would I do this in code using Alamofire?
  Like the compiler warning says, `UserNetworkModel` needs to be `final`:

``` swift
final class UserNetworkModel: ResponseObjectSerializable, ResponseCollectionSerializable { ... }
```
  Great work, @parto. Thanks for the PR.
  Fixed by #174
  Cannot reproduce. Please follow the installation instructions exactly. For any additional assistance, please try Stack Overflow.
  :+1: 
  Thanks, @nvh!
  @VadimDez I'm having the same problem, let me know if you figure it out!
 ![screen shot 2014-10-10 at 2 27 08 pm](https://cloud.githubusercontent.com/assets/3412692/4597175/2fa261cc-50ab-11e4-8c11-41510cdca9f7.png)
 @nvh Me? I'm on Yosemite 10.10 (14A386a), Xcode: 6.1 Base SDK iOS 8.1 (Deployment target iOS 8.0)
  Looks like something was mis-merged from master. This is fixed by 6b6facc0ac407bc37e6c71f5d93d11f21894b8ba.
  Error code -1005 for `NSURLErrorDomain` means "The connection failed because the network connection was lost." (Additional information [here](http://nshipster.com/nserror/)).

There are a number of reasons why this could happen, whether it's your internet connection or `httpbin.org`'s cutting out, or sabotage by some proxy or firewall. If you're still having trouble getting this to work, I'd recommend consulting Apple's Developer Docs or asking a question on Stack Overflow.
  Fixed by 942cf29. Looks like spaces weren't being encoded.
  Cannot reproduce. Make sure that you are using the latest version of Alamofire.
 I don't know what to tell you. [`validate` exists and works just fine on the HEAD of the xcode-6.1 branch](https://github.com/Alamofire/Alamofire/blob/xcode-6.1/Source/Alamofire.swift#L832-L842). If your local copy doesn't have it, your local copy is out of date.
  .DS_Store is something that should be put in a global .gitignore. A project's .gitignore should be specific to that particular development environment.
  Thanks, @parto.
  See #153.
  The difference here is that the initialized `manager` is not owned, and is deallocated shortly after it goes out of scope. As a result, any pending tasks are cancelled.
  +1 except i'm getting this error:

![screen shot 2014-10-09 at 10 37 33 am](https://cloud.githubusercontent.com/assets/3412692/4578067/f57bf34e-4fc1-11e4-9b9c-0bc54fc51149.png)
  See #153.
  Thanks for the kind words, @rlimberger.

Alamofire is built on the Foundation URL Loading System, and can therefore be integrated with custom `NSURLProtocol`s.

Unfortunately, I can't provide any support for this. I'd recommend contacting a technical account manager at Shibboleth for support, or asking around on Stack Overflow.
  Thanks, @kaphacius. Fixes #146.
  The README has been updated with installation instructions that specifically deal with targets that do not support embedded frameworks. Apologies if any of this was unclear. Hopefully this should resolve things.
  What are the exact parameters that cause this behavior?
 Fixed by 942cf298364e4244a65478d8a5f7b025ee78e056. See #162.
  `upload` does not accept a `parameters` parameter, since the body of a request is a factor of the data, file, or stream being uploaded. Any necessary configuration can be achieved by using the version of the method accepting a `URLRequestConvertible` argument.
 Hi @albincr, it depends on your service. Most likely you'll want to upload the data as [MultipartFormData](https://github.com/Alamofire/Alamofire#uploading-multipartformdata). You may also need to pass the parameters in the [query string](https://github.com/Alamofire/Alamofire#manual-parameter-encoding-of-an-nsurlrequest) and supply the image data for the [upload](https://github.com/Alamofire/Alamofire#uploading-a-file).
 You probably have some conflict. You could try `Alamofire.Method.POST`. Otherwise please take your questions to Stack Overflow.

Instead of creating a support issue in Github, please open a question on [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. The Alamofire community is very helpful and supportive. Stack Overflow is the best place to get your question answered quickly and correctly.

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
  You can't send GET requests as JSON, because GET requests don't have a message body.
  Thanks for reporting this, @techxplorer. Indeed, this was the incorrect behavior.

d28f0c0 adds a fix, as well as a previously-failing test.
 @codeblooded Thanks for your offer to contribute. The reported behavior was a bug, rather than an example of some desired behavior that should be afforded by an additional feature. 

Out of curiosity for other permitted query string characters, e495cae adds a test to explicitly check to make sure question marks are encoded properly, which they are.
 Fixed by #153.
  Thanks for the PR, @stuntdouble. I always appreciate it when changes accompany new tests.

I wonder if this is the correct behavior, though. With this change, an empty array would be indistinguishable from a single element array containing a blank string.

Unfortunately, as noted in the documentation, there is no specification governing what the behavior should be. Is this change based on behavior you observed in a conventional web application framework?
 Given the potential for ambiguity with this change, I'm deciding to close the PR. 

I'd be happy to take another look if anyone could show this behavior in the wild (again, lacking any firm specification).
  It's `Alamofire`, not `AlamoFire`.
  Thanks, @nduplessis!
  Alamofire can be compiled against a minimum deployment target of iOS 7. How it is distributed within a project is an entirely separate concern.
  We're looking to add better support for this in the 1.3.0 release. We'll keep you posted üëçüèª
 Hey everyone, I just posted a PR #595 that adds much better resume data support for downloads. If you could all check it out I'd appreciate it. Please direct all further comments on resume data to that issue.

Cheers üçª
  Indeed it should. Thanks for the PR, @rynecheow.
  Thanks, @orta!
  D'oh. Following rules of precedence, I should have merged this instead of the #139. Descending sort order strikes again.

Apologies, and thanks for the PR, @rosskimes.
  The wording was changed as a consequence of c99e9ff6c1161f7b7ee4452d4110da8daeb13a2e. Thanks for your contribution, @tomlokhorst.
  Cannot reproduce. It's likely an issue installing or integrating the framework. 

da237ff adds two tests specifically for `progress`, which both pass.
  > I am suppose to get an error only if the statusCode is not 200..<300 right?

No. If there was an error in the request itself, that will be the error returned in the response handler. Or, if there is an error serializing the response object (as is the case here, since content-length = 0, `NSJSONSerialization` fails with an error).
  As noted in the README, just use the AFNetworking UIKit extensions. There's really no benefit in rewriting all of that in Alamofire.
  Thanks for the PR, but the `switch` is in place to accommodate the soon-to-be-implemented download and upload requests.
  Alamofire itself will be free of external dependencies, but as @tangplin mentions, this functionality can be added very easily.
  Based on your explanation, a few possible reasons come to mind. It could be that your code in response handlers are blocking the main thread, or that the process of creating and sending a request is blocking in some way. `NSURLSession` automatically manages its own connection pool, so it's unlikely that the network IO itself is the root cause of what you're describing.

Would you be able to create a small example project that reproduces this?
  An `import` statement was added in bb112f07e430c487e75ad3e9f059e9e27705597a. Thanks for your contribution, @twe4ked.
  Apologies for the delay in responding. I agree with your sentiment, and have cherry-picked bae253fb0a50143b3c2012ad6894693656e0362f (the other patch was made moot by changes in the meantime).
  I can't reproduce, but this is almost certainly a duplicate of #55. The solution explained there didn't work?
  Thanks, @adamhartford, but this doesn't go quite far enough, and breaks a few tests. 52b0086 makes the necessary changes.
  I'm not sure what the issue would. [This test](https://github.com/Alamofire/Alamofire/blob/master/Tests/ManagerTests.swift#L27-L45) demonstrates this API in use.
  :+1: 

Thanks, @iUtvikler.
  >  I send a search request "apple" and seconds later...

A few seconds later? You're probably not getting any tasks back because that task already finished.

Regardless, I would recommend against this approach. Keep a reference to your `Alamofire.Request` object and cancel directly instead.
 @ingouackaz 

[Alamofire.Request -cancel()](https://github.com/Alamofire/Alamofire/blob/master/Source/Alamofire.swift#L655-L663).

That you're getting an "Unrecognized selector" exception is troubling. You're using Alamofire in Swift, right?
  I appreciate your PR for this, @jonandersen, but I'm not sure if this belongs in the README for this project. 

There's a slippery slope argument one could make about whether we should also include instructions for installing Git, or creating a new project in Swift, or installing Xcode... but really, it's just that this is probably an inessential detail for a majority of folks.

As a compromise, 2b10607 adds a link to the Git submodule documentation, so anyone (blissfully) unfamiliar with submodules have a point of reference.

Thanks, @jonandersen.
  Installation instructions (until CocoaPods supports Swift) are provided in the README. The only required file is Alamofire.swift. If there's any mention of `XCTest`, you're loading or linking against the testing target  somehow.
  Indeed, the HTTP body was not being encoded. Fixed by 1e634b3. Thanks, @skasriel.
  Thanks, @ricardopereira.
  No, these are specifically intended to be private.
  [From the README](https://github.com/Alamofire/Alamofire#http-basic-authentication):

``` swift
let user = "user"
let password = "password"

Alamofire.request(.GET, "https://httpbin.org/basic-auth/\(user)/\(password)")
    .authenticate(user: user, password: password)
    .response {(request, response, _, error) in
        println(response)
    }
```

This does not add an `Authorization` header until after the initial request fails. See the [Apple Documentation on Authentication Challenges](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/URLLoadingSystem/Articles/AuthenticationChallenges.html) for more information.

If something's not working, then it's likely to do with the server you're attempting to connect to.
  in AFNetworking for objective-c, there was this convenient flag I could set. 

[self setAllowsInvalidSSLCertificate:YES];

What's its equivalent in Alamofire for swift?
 Alamofire doesn't yet provide TLS verification, so there's no equivalent for `setAllowsInvalidSSLCertificate`.
 It is not yet available. TLS verification is slated for the 1.3.0 release. More info can be found [here](https://github.com/Alamofire/Alamofire/milestones).
 Check out the Security section of the README @Lweek.
  Thanks, @duemunk.
  Thanks, @rosskimes.
  Noted in c99e9ff6c1161f7b7ee4452d4110da8daeb13a2e.
  Use the `HTTPAdditionalHeaders` property of `NSURLSessionConfiguration`. This value may or may not be derived from the default `HTTPAdditionalHeaders` value for the session configuration of the default manager.
 `Alamofire.Manager.sharedInstance.session.configuration.HTTPAdditionalHeaders`
 Yeah, that's the point. If you want custom headers, pass it into the configuration of a new manager. The aforementioned line of code gets you the default, in case that's something you wish to base it off of.
  Until this is implemented, AFNetworking's multipart form request functionality can be used in conjunction with Alamofire itself.
 @mileswd we are going to implement this. We haven't finalized the `1.3.0` roadmap yet, but most likely this feature will make it onto that list. Stay tuned...
 Hey everyone, I just put up PR #539 which adds support for `MultipartFormData` uploads. I would love your feedback before merging it in. Cheers.
 Hi @chrisco314, I've seen some weird throttling on uploads on some ISPs before, but generally, it should just upload consistently. Alamofire doesn't do anything to trigger that behavior in any way.
 You need to add the parameters to the multipart form data @Johnykutty. üëçüèº
  Duplicate of #105, which will be merged into a 1.1 branch.
  Thanks for submitting this PR, @duemunk. As far as I can tell, the same necessary changes to the project were applied in cb7dde5b3aa7134cca57fc60fcaa0d03c5676ba3. Since the merge wasn't going to be clean anyway, I decided to work out my general frustrations in a sweeping epic of an installation guide, with 96e6a2fb72d7122cecd744ac811e6824731f42a4.

Seriously, CocoaPods for Swift couldn't come soon enough.
  Fixed by cb7dde5.
  Props to whoever in Cupertino wrote that great error message. 582eec1 should fix this.
  Thanks, @arnaudjbernard!
  Fixed by cb7dde5.
  See #70.
 Hi @mathiasi,

If you are finding this to be more than just the in-memory usage of the shared `NSURLCache`, then please open a new issue with a good description, info about how you installed Alamofire, Xcode versions and all relevant sample code. An actual sample project would be awesome.

Cheers.
  Presumably, if you were sending the header `Content-Type: application/json`, you would also then be sending JSON in your body. If so, specifying `ParameterEncoding.JSON` should perfectly suit your needs.

Otherwise, the latest in master also provides an interface that takes a `URLRequestConvertible` type parameter, of which `NSURLRequest` is a conforming class.  
  Thanks for the PR, @Mikoj. I ended up adding a slightly modified version of [GitHub's Swift `.gitignore` file](https://github.com/github/gitignore/blob/master/Swift.gitignore) in ae1e1148ba41f1b20b922f3a49edd1e7bb01a93c
  Thanks for the PR, @banDedo, but I think I'm going to take things in a different direction. The top-level convenience methods are good for making getting started and making one-off requests, but for applications which regularly access an API, more significant infrastructure is warranted.

5b94f2a2f1a368a63db2e692b9004a236560c0f3 adds the `URLRequestConvertible` protocol, which a consumer `enum`, `struct`, or `class` responsible for constructing requests can adopt. It'll have to be heavily documented before it goes live in 1.0, but I think it offers the cleanest and most extensible approach.
  Xcode bug notwithstanding, I was luckily able to fix this with 32fb7b4. Seems the XCTest runner doesn't take kindly to inner class test cases.
  Thanks for the patch, @johngibb. An equivalent change ended up being made with 59503b763ac4b71c7bce36bce44512b3cfa255f2.
  Thanks, @johngibb.
  It doesn't really make sense for a dictionary to have an optional value type, since setting a `nil` for a key removes that key from a dictionary:

``` swift
var parameters: [String: AnyObject?] = [:]
parameters["foo"] = nil
parameters.keys.array.count // 0
```

If this weren't the case, we'd expect a non-empty set of keys.

As @yanke-guo points out, `NSNull` is the appropriate value to pass here.
 Everything needs to bridge back to Objective-C to use `NSJSONSerialization` @rlaferla. Hopefully Swift 3 will give us some better options.
 @PurviJani Posting on old, unrelated issues is not a good way to get support. These types of questions are best suited for [Stack Overflow](https://stackoverflow.com) and tag `Alamofire`. We use our GitHub project for bug reports and feature requests.

Best of luck! üçª

---

From our [Contribution Guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md)

## Asking Questions

We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on [Stack Overflow](https://stackoverflow.com) instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
 @esetnik That issue should be fixed by [SE-140](https://github.com/apple/swift-evolution/blob/master/proposals/0140-bridge-optional-to-nsnull.md) as part of Swift 3.0.1 which I believe will be part of Xcode 8.1, which will be released alongside iOS 10.1. When that will be I'm not sure. 

In the mean time, doing what you suggest would be very complicated, requiring us to build our own non-generic optional protocol (for casting), along with functionality to extract values or `NSNull` and dynamically rebuild `parameters` values, which are arbitrarily sized. So it would be terrible for performance, requiring `O(n)` time and `O(n)` memory (as we'd have to copy the value passed in). It would also be slowed down by the fact that we'd have to do `is` checks on every value in parameters, both to check for optionality as well as to see if it's a collection type. So, given that it will be fixed rather soon, I'd say we won't be adding that functionality.

@cnoon, anything to add?
 I'm not sure where you get that necessity? The proposal bridges values (of any type) as their value or `NSNull`. The `Any` cast is done when passed as a `[String : Any]` value to the Alamofire APIs. 
  This was caused by a change in Swift source mapping from Foundation, which caused the `HTTPMethod` property of `NSURLRequest` to be optional.
 Fixed by 59503b7.
  Fixed by 997a2a4.
  Thanks for the PR, @lesmuc.

9ad2866 actually makes all of this unnecessary by using the built-in `HTTPAdditionalHeaders` property of `NSURLSessionConfiguration`.
  Fixed by cb7dde5, or otherwise mitigated by following instructions described above.

Anxiously awaiting Swift support in CocoaPods.
 You MUST have a deployment target of iOS 8.0 or above to use embedded frameworks with CocoaPods.

From the [README](https://github.com/Alamofire/Alamofire#installation):

## Installation

> **Embedded frameworks require a minimum deployment target of iOS 8 or OS X Mavericks.**
> 
> To use Alamofire with a project targeting iOS 7, you must include the `Alamofire.swift` source file directly in your project. See the ['Source File'](#source-file) section for instructions.
  I could not reproduce this. Perhaps this was fixed by #106, or maybe the latest Xcode 6.1 beta?
  Alamofire is already updated for Beta 7, as of 288509fc45b41d5545958d2b363679f7f8c6715c. Given the addition of implicit unwrapped optionals, his patch appears to be compatible with Beta 6, or some other previous version.
  See #32.
  Glad to hear the latest version fixes your issue.
  Thanks, @JJSaccolo!
  Fixed by #78.
  I actually prefer the way singletons are currently implemented in Swift. Unless Apple provides any official guidance on this in documentation, I am comfortable keeping things the way they are.
  > I presume various closure-typed properties in SessionDelegate, TaskDelegate, DataTaskDelegate and DownloadTaskDelegate are intended to be used by clients to extend/override particular delegates behavior.

Actually, that's incorrect. These are implemented internally for the sake of completeness. Any functionality intended for the end user would be exposed on `Manager` or `Request`.
  Thanks for pointing this out, @odnoletkov. 00b4dee43d95050e0f1749ef596a3a7d9289cfdd adds the missing step of removing the subdelegate after its received its last delegate method.
  Actually, I decided to remove `baseURL` outright from Alamofire. The recommended pattern for URL construction (will be documented extensively in the near future) is to construct `enum`s conforming to `URLStringConvertible`.
 https://github.com/Alamofire/Alamofire#crud--authorization
  I can't speak to specific build configuration issues. Xcode 6 and Swift are still in beta, and are subject to bugs and breaking changes.

The only officially support means of distribution for Alamofire are building as a framework or using CocoaPods, once that is supported. Of course, you're welcome to maintain your own fork, but I would strongly recommend against that.
  @rkeniger This is an interesting idea, but I believe out of scope for the library. Although JSON is ubiquitous, the practice of XSS (most commonly starting JSON with `)]}',`) is a niche practice, mostly relegated to the world of client-side JavaScript. Adding this as a parameter to `responseJSON` would mostly just confuse users.

That said, I could see a library providing an extension on `Alamofire.Request` that provides a `responseXSSProtectedJSON` method, or the like.
  Thanks, @rkeniger.
  Duplicate of #55.
  I cannot reproduce. Alamofire works fine with Beta 6.
 @jjochen Beta 6 is a minimum requirement for Alamofire.
  That's a fundamentally unsafe operation, since `NSJSONSerialization +JSONObjectWithData:...` returns `AnyObject?`.

See #57 for additional discussion.
  Thanks, @MacKeeper!
  Adding a .gitignore file that hides xcuserdata, which shows up as (untra...
 Thanks, @troypayne. A `.gitignore` file following GitHub's Swift template was added with ae1e1148ba41f1b20b922f3a49edd1e7bb01a93c.

(FWIW, `xcuserdata`, like `.DS_Store` and other common noise, is something a lot of people like to put in their user-level `.gitignore`)
  I have this 70% done on a private branch. I appreciate your willingness to help, but I would not recommend working on this yourself.
  > Parsing client specific JSON is beyond the scope of this library, and is a responsibility placed on the specific client.

Well said, @justinmakaila.

Though I would say the easiest way to integrate would be to implement a `responseSwiftyJSON` method in an extension on Alamofire.Request.
  Thanks, @zrcoder.
  Has anyone been able to run Alamofire.swift on a device running iOS 7?

For me, it's crashing with:

dyld: Library not loaded: @rpath/Alamofire.framework/Alamofire
  Referenced from: /var/mobile/Applications/A59259D8-0AF7-43AD-AC21-2A0530B26B09/Stayful.app/Stayful
  Reason: image not found
 @martijnkorteweg 
I get the following error after adding AlamoFire.framework to the Embedded Binaries

dyld: Symbol not found: _NSURLAuthenticationMethodHTTPBasic
  Referenced from: /private/var/mobile/Applications/560EC324-52BC-4046-9C3B-D830BE0E870D/Stayful.app/Frameworks/Alamofire.framework/Alamofire
  Expected in: /System/Library/Frameworks/CFNetwork.framework/CFNetwork
 in /private/var/mobile/Applications/560EC324-52BC-4046-9C3B-D830BE0E870D/Stayful.app/Frameworks/Alamofire.framework/Alamofire
(lldb) 
 @mattt any ideas?
 @angelcasado thanks! That did the trick
  This was caused by a change from Beta 5 to Beta 6. Delete your DerivedData directory and try again.
  The example project is built with Alamofire as a framework. You can use that as a reference if you need more clarification on installation.
 Thanks, @angelcasado.
  The latest in master has an example project and test harness. That should be a good place to start.
  Thanks for your PR, @Coltspb. I made a similar change to the same effect with 34f8f2f.
  Thanks for your PR, @Dschee. In the process of greater project restructuring, similar or equivalent changes were made in 9f7c365.
  As of 9f7c36531d6a23ab8b5bb3f456fb7a7c79370d65, Alamofire is updated for Xcode 6 Beta 6.
  Thanks for your PR, @maxpow4h. Unfortunately, these changes aren't applying cleanly after 9f7c36531d6a23ab8b5bb3f456fb7a7c79370d65, which did significant restructuring on the project. If you wouldn't mind, please open a new PR against the latest master.

Responding to specific changes:

> - Removed default arg of User's home directory

I actually like these as a default. I've found that most users are completely flummoxed by `NSFileManager` semantics, and would prefer something that "just works". Any reason why this wouldn't be an appropriate default?

> - Moved test 100.json file to Library/Caches directory

This test is to simulate downloading a file to the documents directory. For lack of a CDN to host a meatier file, I'm using HTTPBin's file stream.

> You probably want to pick a better NSError domain.

As of the latest commit in master, Alamofire does not construct `NSError` objects.
  Duplicate of #36.
  Thanks for sharing your thoughts, @tLewisII, but I'm not really sure what this would accomplish... Instead of any additional safety, I think a extra hoop like this would only serve to frustrate anyone who just wants to make a network request in an idiomatic fashion.

If anything, the correct approach would be to provide an extension on `NSURL` to have it conform to `StringLiteralConvertable`. I'm looking into that for the next release.
  Unit tests work just fine as-is. Are you running into any specific issue with access control?
 As of 9f7c36531d6a23ab8b5bb3f456fb7a7c79370d65, Alamofire is structured for use as a framework, rather than a drop-in file. The access control is such that the unit tests target in the provided test harness is able to successfully run all of the tests.
  Thanks for the PR, @NialG. One of the new patterns I'm incorporating before 1.0 is the `URLRequestConvertible` protocol, which structs / classes / enums can adopt in order to create an `NSURLRequest` (there is also `URLStringConvertible`, which is used to generate just the path).

The idea being that, for a larger application, a router object would be responsible for constructing paths or requests according to a particular context. For example:

``` swift
enum ExampleAPIRoute: URLRequestConvertible {
    case User(Int)

    var URLRequest: NSURLRequest {
        let baseURL = NSURL(string: "http://api.example.com")

        switch self {
        case .User(let id):
            let path = "/users/\(id)"
            return NSURLRequest(URL: NSURL(string: path, relativeToURL: baseURL))
        }
    }
}

request(URLRequest: ExampleAPIRoute.User(1)).response { (_,_,_, _) in
   // ...
}
```
  This is touched on a bit in #7. Basically, the current top-level interfaces for requests are a convenience for initializing with `NSURLRequest` objects. These will eventually expand to support other fields in a future release.
  It would be a difficult API design decision to defend if the input parameters of a serializer closure did not match those of the response closure. I could easily imagine removing information here to be problematic for certain use cases.

As for the existing serializers, I don't see an issue with their current implementation, other than perhaps not forwarding any existing errors up the stack using the underlying error information of an `NSError`.
  Thanks for your PR, @venj, but this is a duplicate of #34. As for #35, this is an unrelated change.
  It's a compiler error. Explicitly cast your parameters as `[String: AnyObject]` (or maybe `[NSObject: NSObject]`), and you should be good to go.
  df5e97e fixes this by nil-coalescing each value to `"Unknown"`.
  Hmm... following your findings, I don't understand how this would produce the desired behavior. In the case of an if / else statement, if certain cases overlap, it should go from most specific / exclusive to least. Unless I have it wrong, shouldn't it be testing download, then data, then upload?
 Thanks, @jandrewmoore.
  @tonglil You can encode the string as `NSData` and set as the `HTTPBody` or an `NSURLRequest`, which you then pass into `Alamofire.Manager.request`.
  These are doing different things. Alamofire is creating a credential that will be used during an authentication challenge, whereas AFNetworking is setting the `Authorization` header in the initial request.
  Thanks, @hpique!
  Fixed by #34. Thanks again, @jandrewmoore.
  Yes, `URLSession:didReceiveChallenge:` is the method implemented in Alamofire as well. Additional control over this behavior, namely TLS chain validation, is forthcoming.
  For anything beyond what the shorthand provides, you'll have to drop down a level of abstraction to create and manage `NSURLRequest` objects yourself. This may change in a future version, but for now, here's the process:

``` swift
let URL: NSURL(string: "http://api.imgur.com/3/gallery.json")
var mutableURLRequest = NSMutableURLRequest(URL: URL)
mutableURLRequest.setValue("...", forHTTPHeaderField: "Authorization")

let manager = Alamofire.Manager.sharedInstance // or create a new one
let request = manager.request(mutableURLRequest)
request.responseString { (request, response, string, error) in
         // ...
}
```
 Alternatively, you could also set the `Authorization` on the `defaultHeaders` of a manager. This would automatically apply the header to all requests created through method shorthand. 

Real documentation for this usage is forthcoming.
  Thanks, @sasikiran, but #24 came in a little before this one. Do you see any changes missing from that?
  I think there are plenty of opportunities to integrate other dependencies with Alamofire, but they'd be best suited as separate libraries themselves.

For example, someone could create Alamofire+SwiftyJSON, which added the method `responseSwiftyJSON`. Similarly, I'm planning to create an extension for XML support using [Ono](https://github.com/mattt/ono), which would add the `responseOnoXMLDocument` method (or similarly named).
  :+1:

Thanks, @kylef!
  Any clue why I have so many errors? Here's the first:

Alamofire.swift:46:16: Type '[String : AnyObject]?' does not conform to protocol 'BooleanType'
 I've created pull request https://github.com/Alamofire/Alamofire/pull/24 that fixes the issues.
  Cheers, @romanroibu. Thanks for the PR.
  Thanks for your feedback, @onevcat. In the process of updating the code to the latest beta, and other refactoring, similar or equivalent changes have been applied.
  You're probably missing an `import Foundation`.
 As of 9f7c36531d6a23ab8b5bb3f456fb7a7c79370d65, an example project and test harness are included in the repository.
  Indeed, that's a bit of code made unnecessary by the `URLRequest` convenience method a few lines down. Thanks, @onevcat.
  Fixed by #34.
  There is a bug in iOS 7 wherein sessions tasks created on a concurrent queue may not have unique identifiers (which is necessary for keying delegates on task identifiers). This ensures that all tasks are created serially, and have unique identifiers.
 The `queue` is a serial queue @pavm035.

``` swift
let queue = dispatch_queue_create(nil, DISPATCH_QUEUE_SERIAL)
```
  Thanks for your PR, @vmartinelli.  I had been developing this in a private branch, waiting until the example project was finished, so I apologize for any inconvenience in maintaining a separate fork by not providing this initially.

627b7420f9a8a690cfab57fc48c19a6941b3daeb adds an example project and test harness.
  Swift function naming conventions are still being determined, so there's no authority to cite for any specific rationale.

My personal thinking is that `response` is complementary to `request`; the ambiguity arises from the fact that request is both a noun and a verb. `respondJSON` doesn't sound right, though. Instead of an instance method, think of it instead as each method omitting an implicit `on`, i.e. `onResponse`.

> By the way, a similar question: what do you see as the advantage of Chainable Request / Response methods?  Could someone show me an example that clearly shows the advantage?

I'm not sure what you're asking, here... Objective-C would use chaining a lot more if there wasn't a syntactic cost; returning `Self` is a convenient way to string along expressions.

One additional benefit of the approach used by Alamofire is that it allows for multiple `response` calls, for any situation that might want to handle responses differently:

``` swift
Alamofire.request(.GET, "http://example.com")
               .responseJSON { (_,_, JSON, _) in
                     // ...
              }.responseJSON { (_,_, JSON, _) in
                    // ....
             }
```
  Thanks for suggesting this, @dataxpress. This is definitely something I'd considering‚Äîgoing back and forth a few times, in fact. Ultimately, though, I find myself preferring the explicit consistency of the current APIs. 

The extra method opens the rest of the convenience APIs up to potential bloat in order to match it. One confusing outcome if that were to come to pass is that `download` would also default to `GET`, whereas `upload` would be `POST` (which is not, itself, a strong default in a world where web apps tend to flex their method vocabulary).
  :rose: :fire: 
  Fixed by c709d35.
  See #8.
  Thanks, but this is not the error. There was a missing code fence block, fixed by d466d8e7fd66202d1a7be477c54d3cc0386f3339.
  Most of the development and documentation of Alamofire so far has focused on the simplest, most common use cases. Right now, what you're describing is accomplished by constructing a request with an `NSURLRequest`. The API may change to accommodate the described method in the future.
 @Dschee That's just not how I use GitHub Issues. I give you all assurances that I know what I'm doing.
 @Dschee Feel free to conduct yourself in your work as you see fit. I'm not particularly interested in having a discussion about process.

> On 2014/08/13, at 14:26, Dschee notifications@github.com wrote:
> 
> I don't wanna be disrespectful ‚Äì I mean you're the one with the big experience here ‚Äì but your explanation hardly satisfies my curious mind. I'm still wondering why you close ideas for future versions. I'd be happy to keep them opened or at least mark them within closed issues so that I can find them later as ideas for new versions.
> 
> But who am I to tell you something about maintaining great frameworks ... :)
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
  Thanks, @pwightman. This ended up being fixed with d466d8e7fd66202d1a7be477c54d3cc0386f3339, which changed the formatting from what was used to originally fit the code into the slides for the presentation announcing Alamofire on Wednesday.
/n  Hello ,
i called PHP web service using post method.For that i have used following code.

        let net = NetworkReachabilityManager()
         net?.startListening()
        
          net?.listener =
            { status in
                
                if  net?.isReachable ?? false
                {
         
                    Alamofire.request(Constants.baseURL, method: .post, parameters: [
                        "request": "verification_api",
                        "Device_id" : "Simulator",
                        "Country_id" : "88",
                        "Phone":"91953333666",
                        "Mobile_type":"ios",
                        ]
                       ,encoding: JSONEncoding.default, headers: nil).responseJSON {
                        response in
                        switch response.result {
                        case .success:
                            print(response)
                            
                            break
                        case .failure(let error):
                            
                            print(error)
                        }
                    }
                    

                }
                else
                {
                    print("no connection")
                }
         }

In above code "Constants.baseURL" contain " https://216.105.93.249:8089/api" basic URL of the web service.

i am using POST method with Https then it give me wrong response but with out Https it give me proper response.

So any one can help me for calling web service using Https and POST.

Thank You
 Hello @shraddha-patel-1891 

this is not the place to ask general questions it's only for bugs reporting 

run the app with following code and note what's the output it give back , might be you are by mistake  sending incorrect key value pair or not sending any required keys check in your parameters dictionary 

Alamofire.request(Constants.baseURL, method: .post, parameters: [
                    "request": "verification_api",
                    "Device_id" : "Simulator",
                    "Country_id" : "88",
                    "Phone":"91953333666",
                    "Mobile_type":"ios",
                    ]
                   ,encoding: JSONEncoding.default, headers: nil).responseJSON {
                    response in
                    switch response.result {
                    case .success:
                        print(response)
                        
                        break
                    case .failure(let error):
                        
                        print(error)
                    }
                }  After installing IOS 10.2, network connectivity is lost when running on cellular data.  "No Network Connection" error unless wifi is turned on.
  Hi,

I get this crash in Crashlytics:

> Crashed: NSOperationQueue 0x1455b7a0 :: NSOperation 0x14664230 (QOS: LEGACY)
> 0  libswiftFoundation.dylib       0x12db1f0 static Data._unconditionallyBridgeFromObjectiveC(NSData?) -> Data (__hidden#3564_:1698)
> 1  Alamofire                      0x6b9370 @objc SessionDelegate.urlSession(URLSession, dataTask : URLSessionDataTask, didReceive : Data) -> () + 192
> 2  Alamofire                      0x6b9370 @objc SessionDelegate.urlSession(URLSession, dataTask : URLSessionDataTask, didReceive : Data) -> () + 192
> 3  Alamofire                      0x6b8d84 @objc SessionDelegate.urlSession(URLSession, dataTask : URLSessionDataTask, didReceive : Data) -> () + 112
> 4  CFNetwork                      0x25dee061 __67-[NSURLSession delegate_dataTask:didReceiveData:completionHandler:]_block_invoke221 + 36
> 5  Foundation                     0x26015679 __NSBLOCKOPERATION_IS_CALLING_OUT_TO_A_BLOCK__ + 8
> 6  Foundation                     0x25f765f3 -[NSBlockOperation main] + 146
> 7  Foundation                     0x25f68bc9 -[__NSOperationInternal _start:] + 768
> 8  Foundation                     0x26017931 __NSOQSchedule_f + 192
> 9  libdispatch.dylib              0x2537e423 _dispatch_queue_drain$VARIANT$mp + 1758
> 10 libdispatch.dylib              0x2537da61 _dispatch_queue_invoke$VARIANT$mp + 284
> 11 libdispatch.dylib              0x2538015d _dispatch_root_queue_drain + 396
> 12 libdispatch.dylib              0x2537ffcd _dispatch_worker_thread3 + 96
> 13 libsystem_pthread.dylib        0x25535b29 _pthread_wqthread + 1024
> 14 libsystem_pthread.dylib        0x25535718 start_wqthread + 8

How can I find whats wrong? And how can I fix it?


## Alamofire Environment

**Alamofire version:** 4.5.0
**Xcode version:** 8.3.3
**Swift version:** 3
**Platform(s) running Alamofire:** iOS
**macOS version running Xcode:** Sierra
  Hi, 

there is no example of a Get call having url, method, **parameters and headers together**. The following code could not get parameter "id" passed to the backend. Could anyone here help take a look?
```
let parameters: Parameters = ["id": "1"];
        let headers: HTTPHeaders = [
            "SomeAPIKey": "SomeAPIValue"
        ];
        Alamofire.request("http://backend.com:8080/user", method: .get, parameters: parameters, encoding: JSONEncoding.default, headers: headers).responseJSON { (response:DataResponse) in
            debugPrint(response);
        };
```
  ## What did you do?
Attempt to make a network request to a REST API.

## What did you expect to happen?

I would get the JSON data back properly.

## What happened instead?

In the JSON, the keys in the dictionary do not have quotes around them, even though using Postman and a web browser, everything is fine. Just to make sure, I've tried with other APIs and I get the exact same results.

What Alamofire returns(notice the syntax highlighting):
````json
SUCCESS: {
    "birth_year" = 19BBY;
    created = "2014-12-09T13:50:51.644000Z";
    edited = "2014-12-20T21:17:56.891000Z";
    "eye_color" = blue;
    films =     (
        "http://swapi.co/api/films/2/",
        "http://swapi.co/api/films/6/",
        "http://swapi.co/api/films/3/",
        "http://swapi.co/api/films/1/",
        "http://swapi.co/api/films/7/"
    );
    gender = male;
    "hair_color" = blond;
    height = 172;
    homeworld = "http://swapi.co/api/planets/1/";
    mass = 77;
    name = "Luke Skywalker";
    "skin_color" = fair;
    species =     (
        "http://swapi.co/api/species/1/"
    );
    starships =     (
        "http://swapi.co/api/starships/12/",
        "http://swapi.co/api/starships/22/"
    );
    url = "http://swapi.co/api/people/1/";
    vehicles =     (
        "http://swapi.co/api/vehicles/14/",
        "http://swapi.co/api/vehicles/30/"
    );
}
````

What Postman returns, and what Alamofire **should** be returning:
````json
{
    "name": "Luke Skywalker",
    "height": "172",
    "mass": "77",
    "hair_color": "blond",
    "skin_color": "fair",
    "eye_color": "blue",
    "birth_year": "19BBY",
    "gender": "male",
    "homeworld": "http://swapi.co/api/planets/1/",
    "films": [
        "http://swapi.co/api/films/2/",
        "http://swapi.co/api/films/6/",
        "http://swapi.co/api/films/3/",
        "http://swapi.co/api/films/1/",
        "http://swapi.co/api/films/7/"
    ],
    "species": [
        "http://swapi.co/api/species/1/"
    ],
    "vehicles": [
        "http://swapi.co/api/vehicles/14/",
        "http://swapi.co/api/vehicles/30/"
    ],
    "starships": [
        "http://swapi.co/api/starships/12/",
        "http://swapi.co/api/starships/22/"
    ],
    "created": "2014-12-09T13:50:51.644000Z",
    "edited": "2014-12-20T21:17:56.891000Z",
    "url": "http://swapi.co/api/people/1/"
}
````

## Alamofire Environment

**Alamofire version: 4.5.9**
**Xcode version: 9 Beta 1**
**Swift version: 4.0**
**Platform(s) running Alamofire: iOS**
**macOS version running Xcode: 10.12**

## Demo Project

https://github.com/dannymout/AFIssue
 @jshier OK, I thought this was why I couldn't parse JSON properly, turns out it was something else. Thank you for helping.  I am using Open Cart API. The api has a very weird mechanism..

The API return header status code 200 even on unauthorized access, instead of 401.And returns the 401 error code in the body as attached in the image. 

<img width="1158" alt="screen shot 2017-07-16 at 7 22 10 pm" src="https://user-images.githubusercontent.com/7752578/28248080-76a39dba-6a5d-11e7-8509-3f27ee643161.png">


This way, my response success block is triggered instead of retrying the request. I have been using the Alamofire Adapter and Retrier for a long and this seems to be working find when the header status code is 401. But the API returns me 401 status code in the body which doesn't trigger the  delegate method while validating the request.
```
    func should(_ manager: SessionManager,
                retry request: Request,
                with error: Error,
                completion: @escaping RequestRetryCompletion) 
```

How should i handle this situation... Is there a way i can call the retrier delegate method manually?
 I managed to solve it as below. But is there any better way to solve this?
```
extension DataRequest {
    
    public func validateBodyStatusCode() -> Self {
        
        return validate { request,response,data in
            
            PrinterHelper.jsonPrinter(self.delegate.data!)
            do {
                if  let json = try JSONSerialization.jsonObject(with: data!, options: []) as? [String : Any]{
                    
                    if let statusCode =  json["statusCode"] as? Int, statusCode == 401{
                        
                        let reason:AFError.ResponseValidationFailureReason = .unacceptableStatusCode(code: 401)
                        return .failure(AFError.responseValidationFailed(reason: reason))
                        
                    }else{
                        
                        return .success
                    }
                }else{
                    
                    return .success
                }
                
            } catch let error {
                
                print("Json serialization error \(error)")
                let reason:AFError.ResponseValidationFailureReason = .unacceptableStatusCode(code: response.statusCode)
                return .failure(AFError.responseValidationFailed(reason: reason))
                
            }
        }
    }
}
```

And using the custom Validation as 

```
 let apiRequest = manager!.request(networkAddress, method: EndPoint.method, parameters: parameter, encoding: enCodingFormat, headers:authFlagHeader).validateBodyStatusCode().responseJSON { (response) in
            
            let parsedResult =  ResponseParser<EndPoint.ResponseType>.parseResponse(withResponse: response)
            callback(parsedResult.0,parsedResult.1)
            
        }
```  I am using Alamofire 4.+ and swift 3.0. I am making a post request like [this](https://stackoverflow.com/questions/45050013/alamofire-always-returns-response-as-empty-dictionary).
But it always prints [ ] @mansuu Can you show us your code?  ### Issue Link :link:
#1526 
  `Alamofire.request(url, method: .get, parameters: parameters)
`

Parameters is a dictionary, I know i can send it to the background.
But now, i wang to send JSON(Not an object for dictionary) to the background, what should i do?

Thx!
## Alamofire Environment

**Alamofire version:** 4.5.0
**Xcode version:** 8.3.3
**Swift version:** 3
**macOS version running Xcode:** 10.12.5 You can just convert it into a dictionary
```swift
func convertToDictionary(text: String) -> [String: Any]? {
    if let data = text.data(using: .utf8) {
        do {
            return try JSONSerialization.jsonObject(with: data, options: []) as? [String: Any]
        } catch {
            print(error.localizedDescription)
        }
    }
    return nil
}
```  
I am sending bearer token in header which is working for post method. The code below is I am using for POST method

```
let parameters: Parameters = [
            "key1":"Value1",
            "key2":"value2"
        ]
        let headers = [
            "Authorization": "Bearer "+loginkey!
        ]
        
        Alamofire.request(url, method: .post, parameters: parameters, encoding: URLEncoding.httpBody,headers: headers).responseJSON
            {
                response in
            debugPrint(response)
        }

```
 for GET method I am using below code

```
let headers = [
            "Authorization": "Bearer "+loginkey!
        ]
        
        Alamofire.request(url, method: .get, headers: headers).responseJSON
            {
                response in
            debugPrint(response)
        }
```

but I always get response as unauthorized. i have checked the server log,it doesn't receive http header I am sending.

what is wrong with Alamofire here?

## Alamofire Environment

Alamofire version:4.5.0
Xcode version:8.3.3
Swift version:3

macOS version : macOS Sierra 10.12.5
  ### Goals :soccer:
Recent REST services exposes GET APIs with parameters passed as subcomponents of the Request URL. 

This means that instead of encoding parameters as

`requestUri?key=value&key2=value2`

their requests are something like

`requestUri/value/value2`

### Implementation Details :construction:
I am using Alamofire to interact with an ASP.NET WebApi 2 service that accepts parameters as described above. I think that Alamofire should be able to treat these kind of requests as normal parameters, even if they actually modify the request URL.

To do this, I have added a new struct that implements the ParameterEncoding interface and encodes parameters as subcomponents of the request URL.

### Testing Details :mag:
I have two tests which verify that parameters are inserted in the requested order. Hi @jshier ,

Actually, I don't know if this is a real standard yet, but it is widely used in REST services built with Microsoft ASP.NET WebAPI 2.

You can find further information on this page: [Routing in ASP.NET Web API](https://docs.microsoft.com/en-us/aspnet/web-api/overview/web-api-routing-and-actions/routing-in-aspnet-web-api). Also, this page is relevant, if you want to read more about this: [Attribute Routing in ASP.NET Web API 2](https://docs.microsoft.com/en-us/aspnet/web-api/overview/web-api-routing-and-actions/attribute-routing-in-web-api-2)

Just to take a look at other worlds too, I know a few PHP frameworks that work in the same way. For example, there's [FatFree Framework](https://fatfreeframework.com/3.6/routing-engine).  I am getting this too. Can this be re-opened? If you closed it because you fixed the problem, could you post your solution please?  > ‚Ñπ Please fill out this template when filing an issue.
> All lines beginning with an ‚Ñπ symbol instruct you with what info we expect. You can delete those lines once you've filled in the info.
>
> Per our [*CONTRIBUTING guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md), we use GitHub for
> bugs and feature requests, not general support. Other issues should be opened on Stack Overflow with the tag `alamofire`.
>
> Please remove this line and everything above it before submitting.

* [x] I've read, understood, and done my best to follow the [*CONTRIBUTING guidelines](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md).

## What did you do?

As the title mentions I've set up a backgroundURL with Alamofire. It works like a charm in simulator but on my device doesn't. I'm sure I'm missing something here since I'm not that experienced with URL. Here's the code I have so far:

class NetworkManager {

static let shared = NetworkManager()

private lazy var backgroundManager: Alamofire.SessionManager = {
    let bundleIdentifier = MyStruct.identifier
    return Alamofire.SessionManager(configuration: URLSessionConfiguration.background(withIdentifier: bundleIdentifier))
}()

var backgroundCompletionHandler: (() -> Void)? {
    get{
        return backgroundManager.backgroundCompletionHandler
    }
    set{
        backgroundManager.backgroundCompletionHandler = newValue
    }
}
//delegate function in my AppDelegate
   func application(_ application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: @escaping () -> Void) {
    NetworkManager.shared.backgroundCompletionHandler = completionHandler
}
//function in my ViewController
 func populateArrays(){  
 Alamofire.request("http://www.aps.anl.gov/Accelerator_Systems_Division/Accelerator_Operations_Physics/sddsStatus/mainStatus.sdds.gz").responseData { response in
        switch response.result{
        case .success:
            print("Validation Successful")
        case .failure(let error):
            print(error.localizedDescription)
        }
        if let data = response.result.value{

## What did you expect to happen?

In simulator the app still accesses the URL and parses/stores the data.  I expected it to do the same when I installed the app on my phone.

## What happened instead?

The app did not access the URL when the app goes into the background or the phone is locked.  Instead it stops dead.  Breakpoints placed on the function do not fire until the app goes back into the foreground.

## Alamofire Environment

**Alamofire version:** 4.5
**Xcode version:** 8.3.3
**Swift version:** 3.1
**Platform(s) running Alamofire:** iPhone
**macOS version running Xcode:** Sierra

## Demo Project

‚Ñπ
[ArgonneApp copy.zip](https://github.com/Alamofire/Alamofire/files/1116171/ArgonneApp.copy.zip)

  ## What did you do?

Uploading the image using multipart upload. Here I have set default configuration for URLSession. 

## What did you expect to happen?

After starting request immediately disconnecting my network connection so error needs to be generated. 

## What happened instead?

Not receiving any Connection Lost OR Time Out OR any other error. Failure block is not getting called for any case. 

## Alamofire Environment

**Alamofire version: 4.4** 
**Xcode version: 8.3.2** 
**Swift version: 3.0**

## Demo Project

    let configuration = URLSessionConfiguration.default
    configuration.timeoutIntervalForRequest = 15.0
    configuration.timeoutIntervalForResource = 15.0
    self.alamofireManager = Alamofire.SessionManager(configuration: configuration)

    self.alamofireManager.upload(multipartFormData: { (multipartFormData) in
        multipartFormData.append(UIImageJPEGRepresentation(newImage, 1)!, withName: "file", fileName: "image.jpeg", mimeType: "image/jpeg")
        if let parameters = params{
            for (key, value) in parameters {
                multipartFormData.append(value.data(using: String.Encoding.utf8.rawValue)!, withName: key)
            }
        }
    }, to:apiURL, method: .post, headers: authHeader)
    { (result) in
        switch result {
        case .success(let upload, _, _):
            upload.uploadProgress(closure: { (progress) in
                DDLogInfo("Image Upload Progress : \(progress)")
            })
            upload.responseJSON { response in
                //print response.result
            }
            break
        case .failure(let error):
            if error._code == NSURLErrorTimedOut || error._code == NSURLErrorNetworkConnectionLost {
                print("Time Out/Connection Lost Error")
            }
            DDLogInfo("Error :\(error.localizedDescription)")
            break
        }
    }



  There's no functionality difference, the change is cosmetic.    Issue Link üîó
No registered issue. 

Goals ‚öΩÔ∏è
Alamofire crashes if log is enabled and request use client authentication through .pfx certificate. Log cant fetch user and password fields and crash by force unwrapping.

Implementation Details üöß
Removed unsafe wrapping for user and password field.

Testing Details üîç  I knew I can do this for normal upload:

    let fileURL = Bundle.main.url(forResource: "data", withExtension: "zip")
    
    Alamofire.upload(fileURL!, to: "http://localhost:3000/upload")
        .uploadProgress { progress in // main queue by default
            print("Upload Progress: \(progress.fractionCompleted)")
        }
        .responseJSON { response in
            debugPrint(response)
    }

But how am I supposed to show progress for uploading multipartFormData?

    Alamofire.upload(multipartFormData: { (multipartFormData) in
      let path = "\(Bundle.main.resourcePath!)/images"
      let all = try? FileManager.default.contentsOfDirectory(at: URL(string: path)!, includingPropertiesForKeys: nil, options: [])
      
      let filtered = all!.filter { $0.pathExtension == "jpg" }
      for item in filtered {
          let url = URL(fileURLWithPath: item.path, isDirectory: false)
          multipartFormData.append(url, withName: "photos", fileName: url.lastPathComponent, mimeType: "image/jpeg")
      }
    }, to: "http://localhost:3000/upload") {
      (encodingResult) in
      switch encodingResult {
      case .success(let upload, _, _):
          upload.responseJSON { response in
              debugPrint(response)
          }
      case .failure(let encodingError):
          print(encodingError)
      }
    }       ```
Alamofire.upload(multipartFormData: { (multipartFormData) in
    ...
}, to: "http://localhost:3000/upload") {
  (encodingResult) in
  switch encodingResult {
  case .success(let upload, _, _):
      upload.uploadProgress(closure: { (progress) in
           print("Upload Progress: \(progress.fractionCompleted)")
      })
      upload.responseJSON { response in
          debugPrint(response)
      }
  case .failure(let encodingError):
      print(encodingError)
  }
} 
``` Thank you so much. It works.
Anyway to show progress of normal http request?  Just being curious ... 

Do you have already figured out a way to approach this Encodable protocol? If yes, please do share any thoughts / ideas you have regarding this feature request so far. Here's what I think would work.

ParameterEnconding.swift

```swift
#if swift(>=4.0)
public func encode(_ urlRequest: URLRequestConvertible, with parameters: Encodable) throws -> URLRequest {
        var urlRequest = try urlRequest.asURLRequest()

        if urlRequest.value(forHTTPHeaderField: "Content-Type") == nil {
            urlRequest.setValue("application/x-www-form-urlencoded; charset=utf-8", forHTTPHeaderField: "Content-Type")
        }

        let encoder = JSONEncoder()
        do {
            let encoded = try encoder.encode(parameters)
            urlRequest.httpBody = encoded
        } catch {
            throw AFError.parameterEncodingFailed(reason: .jsonEncodingFailed(error: error))
        }
        return urlRequest
    }
#endif
```
I still don't know if encodable could be converted into querys. Hope this helps.   When update to Alamofire4 and Swift3 Ôºårequest sometimes be cancled.
```
open override func requestJSON() -> SignalProducer<NetApiProtocol, NetError> {
        NetApiData.addApi(self)
        return SignalProducer { [unowned self] sink,disposable in
            let urlRequest = NetApiData.getURLRequest(self)
            let request = Alamofire.request(urlRequest)
            self.request = request
            self.indicator?.bindTask(request.task!)
            let timeBegin = Date()
            request.responseJSON { [weak self] response in
                guard let wself = self else { return }
                NetApiData.removeApi(wself)
                DDLogWarn("ËØ∑Ê±ÇËÄóÊó∂: \(NSDate().timeIntervalSince(timeBegin).secondsToHHmmssString())")
                let transferedResponse = wself.transferResponseJSON(response.toNetApiResponse())
                switch transferedResponse.result {
                case .success:
                    DDLogInfo("ËØ∑Ê±ÇÊàêÂäü: \(wself.url)")
                    if let value = transferedResponse.result.value {
                        DDLogVerbose("JSON: \(value)")
                        wself.response = response.toNetApiResponse()
                        wself.fillJSON(value)
                        sink.send(value: wself)
                        sink.sendCompleted()
                        return
                    }
                case .failure(let error):
                    if let statusCode = StatusCode(rawValue:error.code) {
                        switch(statusCode) {
                        case .canceled:
                            DDLogWarn("ËØ∑Ê±ÇÂèñÊ∂à: \(wself.url)")
                            sink.sendInterrupted()
                            return
                        default:
                            break
                        }
                    }
                    DDLogError("ËØ∑Ê±ÇÂ§±Ë¥•: \(wself.url)")
                    DDLogError("\(error)")
                    let err = error is NetError ? error as! NetError : NetError(error: error)
                    err.response = transferedResponse.response
                    sink.send(error: err)
                }
            }
            disposable.add { [weak self] in
                guard let wself = self else { return }
                NetApiData.removeApi(wself)
            }
        }
    }

```

when i delete this line `self.indicator?.bindTask(request.task!)` ,it will be ok.
bindTask coder is:

```
open func bindTask(_ task: URLSessionTask, view: UIView?, text: String?){
        task.indicatorView = view
        task.indicatorText = text ?? ""
        let notificationCenter = NotificationCenter.default
        notificationCenter.removeObserver(self, name: Notification.Name.Task.DidResume, object: nil)
        notificationCenter.removeObserver(self, name: Notification.Name.Task.DidSuspend, object: nil)
        notificationCenter.removeObserver(self, name: Notification.Name.Task.DidCancel, object: nil)
        notificationCenter.removeObserver(self, name: Notification.Name.Task.DidComplete, object: nil)
        if task.state == .running {
            notificationCenter.addObserver(self, selector: #selector(TaskIndicator.task_resume), name: Notification.Name.Task.DidResume, object: nil)
            notificationCenter.addObserver(self, selector: #selector(TaskIndicator.task_suspend), name: Notification.Name.Task.DidSuspend, object: nil)
            notificationCenter.addObserver(self, selector: #selector(TaskIndicator.task_cancel), name: Notification.Name.Task.DidCancel, object: nil)
            notificationCenter.addObserver(self, selector: #selector(TaskIndicator.task_end), name: Notification.Name.Task.DidComplete, object: nil)
            var notify = Notification(name: Notification.Name(rawValue: ""), object: nil)
            notify.userInfo = [Notification.Key.Task: task]
            self.task_resume(notify: notify)
        } else {
            var notify = Notification(name: Notification.Name(rawValue: ""), object: nil)
            notify.userInfo = [Notification.Key.Task: task]
            self.task_end(notify: notify)
        }
    }

```

I call request in `viewWillAppear`,if I did not delete `self.indicator?.bindTask(request.task!)` ,  the first is ok , second is bad.I want the reason?

1.
 `Async.main(after: 0.5) { [weak self] in
            self?.loadData()
        }`
2.
`
loadData()
`

  I know there's a lot of object mapping extensions for Alamofire around (like [Alamofire-ObjectMapper](https://github.com/tristanhimmelman/AlamofireObjectMapper)) but since we now have the `Codable` type built into Swift 4's standard library I think it would make sense to consider adding them as first class citizens alongside the `[String: Any]` parameters and parameterEncoding strategy.

Specifically this would mean:

- [ ] Add native support for specifying an `Encodable` type and an encoder (like `JSONEncoder`) which will then be placed into the `httpBody` as `Data` (this is what the encoders `.encode` method returns).
- [ ] Add native support for mapping the response (or parts of the response) to initialize an object of a given `Decodable` type using the received data, if possible.

Note that this issue arised because we don't have support for `Encodable` objects as part of the request when only specifying `parameters` and `parameterEncoding` in [this issue](https://github.com/Moya/Moya/issues/1135) for the Moya project, which includes Alamofire as its dependency. Although I've laid out to them, how we can solve this without changing Alamofire, there's kind of an agreement that it would be great to hear if and how Alamofire plans to support the `Encodable` and/or `Decodable` protocol types. I would love to see this in an addition to the existing, very flexible Alamofire-ObjectMapper. @jshier Thanks for splitting this up. Looking forward to both of them being implemented!  While checking for memory leaks in an iOS application, i found that when I use the `NetworkReachabilityManager` to check for online/offline status and i go offline there is a memory leak found by instruments/leaks tool.

I narrowed the leak down to the call of `SCNetworkReachabilitySetDispatchQueue` in `NetworkReachabilityManager.startListening()` function

To reproduce the issue:
1. create a new iOS one page app with swift
2. add `NetworkRecahbilityManager` member to `ViewController` class
3. initialize `NetworkRecahbilityManager` and call `startListening` in  `viewDidLoad()` function
4. run the app &  attach the instruments\leaks tool
5. go offline & back online 
6. abserve memory leaks reported in the instruments\leaks tool
 i've pushed the sample project to this repo : https://github.com/ranlor/alamofire-testapp
you can clone it and run the xcworkspace file.
you can  profile it via xcode and while it's running go offline/online and you should see a leak in the instruments/leaks panel.
FYI i'm using xcode 8.3.3 and osx 10.12.5  This is a general question about network connectivity issues and Alamofire behavior.

I have a mobile application, which is heavily dependent on Swift/Alamofire library. Overall experience within the Application is smooth when the application is connected to Wi-Fi network. 

At the same time, in recent days I have observed that the application produces

a. empty screen
b. error messages for simple services
c. non-deterministic behavior
d. abrupt termination

Per discussion with my mobile developer, I am being briefed as these issues are related to server side code or API response. On server-side, the logs indicate no such issues at all. At times, server even don't observe API being called. 

As a server-side developer, I have following questions pertaining to Alamofire library behavior.

1. If network connection drop happens, does Alamofire library re-try to establish network connection again automatically or developer needs to code?
2. Does library provide the individual status code such as timeout, connection drop, etc..?
3. Is there any best practice document/guidelines that library owner can share?
4. As a mobile developer, how one can trap exceptions and put an application into a better state?  Hi, I'm getting an error with the Info.plist when uploading my iOS app to App Store. The error comes via email right after the upload to App Store finishes.
The deployment target of the app is iOS 10.0 and I'm using the latest version of the SDK -> 3.0.0.

This are the errors:

> Unexpected CFBundleExecutable Key - The bundle at '/Payload/APP_NAME.app/Target Support Files/Alamofire/Info.plist' does not contain a bundle executable. If this bundle intentionally does not contain an executable, consider removing the CFBundleExecutable key from its Info.plist and using a CFBundlePackageType of BNDL. If this bundle is part of a third-party framework, consider contacting the developer of the framework for an update to address this issue.
> 
> Unexpected CFBundleExecutable Key - The bundle at '/Payload/APP_NAME.app/Target Support Files/AlamofireImage/Info.plist' does not contain a bundle executable. If this bundle intentionally does not contain an executable, consider removing the CFBundleExecutable key from its Info.plist and using a CFBundlePackageType of BNDL. If this bundle is part of a third-party framework, consider contacting the developer of the framework for an update to address this issue.

If I do what is described in the error and erase the CFBundleExecutable Key, the app doesn't run in Xcode, and that's the only solution I have found in forums. I have also tried only changing the CFBundlePackageType to BNDL and setting Enable Bitcode to NO in my Project Settings, but it doesn't work.

I use CocoaPods to manage the library.

Any thoughts on what it can be? Thanks, actually I found the solution:

The "Target Support Files" folder generated by CocoaPods was added to the "Copy Bundle Resources" in the "Build Phases" of the app, therefore all the Info.plist files of the libraries. Removing it solved the issue and I can submit the app at last!  Created a new project, and using pod install Alamofire; then just run get apple mach-o linker error. Please check the screen capture below, thanks
![screen shot 2017-06-21 at 6 47 31 pm](https://user-images.githubusercontent.com/26848805/27380621-6efc4a08-56b2-11e7-9e65-0ab0a5cb43bc.png)
 Xcode version: __Version 8.3.3 (8E3004b)__
Alamofire: __pod 'Alamofire', '~> 4.4'__
Swift: __3__
CocoaPods: __1.2.1__
Mac mini (Late 2014)
macOS Sierra version __10.12.5__

Thanks for your reply and it works fine on simulator but get the above error when build for real device. the iOS for iPad I installed it on my macBook PRO and i try to build iOS program for iPhone over swift. 

Thanks


> 2017. 6. 23. 11:01, vincentSuwenliang <notifications@github.com> ÏûëÏÑ±:
> 
> the iOS for iPad
> 
> ‚Äî
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub <https://github.com/Alamofire/Alamofire/issues/2171#issuecomment-310550043>, or mute the thread <https://github.com/notifications/unsubscribe-auth/AKrSePHLEmQMUBurTmYEVctnQ-zpP05Jks5sGxxegaJpZM4OAyTj>.
> 

  I've some trouble about SSL Pinning in Alamofire. I've examine all the document that I can found but I couldn't manage to handle it. I might get it wrong.

Currently, I am working on an example https://github.com/antekarin/ios-ssl-pinning

I converted it to swift 3 and updated the pods to the latest version of Alamofire.

To make it clear; the project is use "github.com.cer" certificate, and because I define domain (like below) I expect to get success when I go to "https://github.com" and to get failure when I enter (in example) "https://twitter.com". But in every condition my request return some value and does not block other requests.

```
self.serverTrustPolicies = [
  "github.com": self.serverTrustPolicy!
]
```
I would greatly appreciate it if you kindly give me some feedback on this.

```
let githubCert = "github.com"
    let corruptedCert = "corrupted"

    var urlSession: Foundation.URLSession!
    var serverTrustPolicy: ServerTrustPolicy!
    var serverTrustPolicies: [String: ServerTrustPolicy]!
    var afManager: SessionManager!

    var isSimulatingCertificateCorruption = false

    override func viewDidLoad() {
        super.viewDidLoad()

        self.configureAlamoFireSSLPinning()
        self.configureURLSession()

        self.activityIndicator.hidesWhenStopped = true
    }

    // MARK: SSL Config

    func configureAlamoFireSSLPinning() {
        let pathToCert = Bundle.main.path(forResource: githubCert, ofType: "cer")
        let localCertificate:NSData = NSData(contentsOfFile: pathToCert!)!

        self.serverTrustPolicy = ServerTrustPolicy.pinCertificates(
            certificates: [SecCertificateCreateWithData(nil, localCertificate)!],
            validateCertificateChain: true,
            validateHost: true
        )

        self.serverTrustPolicies = [
            "github.com": self.serverTrustPolicy!
        ]

        self.afManager = SessionManager(
            configuration: URLSessionConfiguration.default,
            serverTrustPolicyManager: ServerTrustPolicyManager(policies: self.serverTrustPolicies)
        )
    }


    // MARK: Button actions

    @IBAction func alamoFireRequestHandler(_ sender: UIButton) {
        self.activityIndicator.startAnimating()
        if let urlText = self.urlTextField.text {

            self.afManager.request(urlText).responseString { response in

                guard let data = response.data, response.error == nil else {
                    self.responseTextView.text = response.error.debugDescription
                    self.responseTextView.textColor = UIColor.red
                    return
                }

                self.responseTextView.text = String(data: data, encoding: String.Encoding.utf8)!
                self.responseTextView.textColor = UIColor.black
            }


        }
    }
``` @cnoon I am having the same problem, and I read the documentation.

Could you please brainstorm at least, tell what is the first thing that comes on your mind.

Why would it return **status code 200** for **all the domains**, why the other domains do not get blocked?  I am new to swift and new to this api but I am needing to create a POST multipart/form-data all to transfer multiple kinds of files and was wondering for using the multipart/form-data feature of this api is there a way to create your own boundary for the multipart/form-data feature ? No. Boundary is created by MultipartFormData.
```swift
public init() {
    self.boundary = BoundaryGenerator.randomBoundary() // and boundary is let, it cannot change.
    self.bodyParts = []
    self.streamBufferSize = 1024
}
``` Understood, my mistake :)

On Jun 21, 2017 7:48 AM, "Christian Noon" <notifications@github.com> wrote:

> Hi @TannerS <https://github.com/tanners>,
>
>    - https://github.com/Alamofire/Alamofire#uploading-multipart-form-data
>
> In the future, I'd suggest you open a question on Stack Overflow
> <https://stackoverflow.com> and tag alamofire. We use our GitHub project
> for bug reports and feature requests.
>
> Best of luck! üçª
> ------------------------------
>
> From our Contribution Guidelines
> <https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md>
> Asking Questions
>
> We don't use GitHub as a support forum. For any usage questions that are
> not specific to the project itself, please ask on Stack Overflow
> <https://stackoverflow.com> instead. By doing so, you'll be more likely
> to quickly solve your problem, and you'll allow anyone else with the same
> question to find the answer. This also allows maintainers to focus on
> improving the project for others.
>
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/Alamofire/Alamofire/issues/2167#issuecomment-310102353>,
> or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AIdKD88A4SlYh1Xe5Y8idVlhhHK15BRvks5sGS02gaJpZM4N-nd5>
> .
>
  20170524  It's a really minor fix, but this branch supports Swift 4 so shouldn't we update this file to Swift 4?  I filed this bug with Apple today. Probably an Xcode issue, but I thought I'd log it here as well for completeness.

>If you build a tvOS application that links against Alamofire using Xcode 9 9M136h (either swift 3.2 or 4.0) and attempt to run on tvOS 10.2, the app crashes and the following is shown in the console:

> dyld: Symbol not found: _OBJC_CLASS_$_NSURLSessionStreamTask
  Referenced from: /private/var/containers/Bundle/Application/A6598C3C-74B0-4464-BE26-A82F9FF914AC/TvTest.app/Frameworks/Alamofire.framework/Alamofire
  Expected in: /System/Library/Frameworks/Foundation.framework/Foundation
 in /private/var/containers/Bundle/Application/A6598C3C-74B0-4464-BE26-A82F9FF914AC/TvTest.app/Frameworks/Alamofire.framework/Alamofire

>The same project built with Xcode 8.3.3 works as expected.

Basically, create a new tvOS project. Add AF via Cocoapods and import into a file (don't need to call into AF). Attempt to run on a tvOS 10.2 device. I deleted my DerivedData folder each time switching from XC 9 to 8 and back to 9. That did not help. I have the same issue. I have cleared the dervied data folder and it doesnt seems to help either.

dyld: Symbol not found: _OBJC_CLASS_$_NSURLSessionStreamTask
  Referenced from: /private/var/containers/Bundle/Application/83E6570D-9EB6-4B6C-8871-755942F43B8C/fodmapRevamp.app/Frameworks/Alamofire.framework/Alamofire
  Expected in: /System/Library/Frameworks/Foundation.framework/Foundation
 in /private/var/containers/Bundle/Application/83E6570D-9EB6-4B6C-8871-755942F43B8C/fodmapRevamp.app/Frameworks/Alamofire.framework/Alamofire Yes, I tried it over the holiday and it was still a problem.

radar://32828698

I attached a small test project showing the issue when I submitted that. Apple just replied that my ticket was a closed as a duplicate of 32298344 @jshier  yes it I still an issue. I am wondering why this is happening.

I am not running on tvOS. It was on iOS 10.3  Is it possible to change the subDelimitersToEncode variable which is in the URLEncoding struct, within your local class?

Within the URLEncoding struct the string equals:
```swift
let subDelimitersToEncode = "!$&'()*,+;="
```

However I need to modify this string to equal (removing the comma):
```swift
let subDelimitersToEncode = "!$&'()*+;="
```  Help me on this issue: https://stackoverflow.com/questions/44588883/return-json-from-php-to-swift-alamofire?noredirect=1#comment76165486_44588883  download failure when without specific destination file path used sample code

```swift
Alamofire.download("https://httpbin.org/image/png").responseData { response in
    if let data = response.result.value {
        let image = UIImage(data: data)
    }
}
```

The desired behavior should response data even if not specific destination   In **ParameterEncoding** I want to change the **queryComponents** method for multiple parameters '
I want to this line from 
                components += queryComponents(fromKey: "\(key)[]", value: value)
  to 

                components += queryComponents(fromKey: "\(key)", value: value)

without modifying the code in Alamofire.

Could you please suggest us best way.
 Could you please help me how can I do this.how can I extend the existing the URLEncoding or  inject my URLEncoding into alamofire.  Hi,

I have several functions that execute an http request using Alamofire on my IOS device. It works perfectly: It connects the user using the login url of a website and then I can make any request to this website. 
However, when I use these functions on my WatchOS device, it doesn't work. I only can login the user. Data requests fail and return nil. I do exactly the same thing on both device.
Any idea? Thanks..  There was a change recently in [PR #2047] "Added missing charset JSONEncoding encode API".

Actually, the MIME type `application/json` does not define a charset parameter. Please refer to [RFC 7158 11. IANA Considerations](https://tools.ietf.org/html/rfc7159#section-11).

Note that each specific MIME type defines _its own set_ of valid parameters. There's no generalisation for all MIME types, say that the `charset` parameter has a ubiquitous meaning across all MIME types. The proposed action for a conforming server is to ignore undefined parameters for a certain MIME type.

Furthermore, in case of JSON parsing, there's no need to specify the Unicode scheme (through the charset parameter). The specific UTF scheme from any given byte stream representing a wellformed JSON can be unambiguously identified, and proper JSON parsers will figure out that first before doing parsing.

Strictly, a parser not supporting the full range of Unicode does not conform to the specification, see [RFC 7158  9. Parsers](https://tools.ietf.org/html/rfc7159#section-9). If parsers are limited to parse only a subset of the UTF schemes, say only UTF-8, then these would fail anyway when the JSON is encoded with a different scheme and succeed otherwise anyway as well. So, specifying a charset parameter doesn't make anything better. According the RFC, the  _recommended_ (default) encoding is UTF-8 and most if not all will support this.

So IMHO and in practice, adding a charset parameter would not make any web server understand JSON better. I would suggest, in order to avoid confusion by not conforming to the standard, to drop the recent addition again. Also, ensure that Alamofire only encodes in UTF-8 - if that is possible, that is, when it can control the encoding.

  Hi,

i'm Just wondering if there is any way to handle below error,

`responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.inputDataNilOrZeroLength)`

I know exactly what its means, and i'm returning false value from my API in case of empty data but its not useful at all, so how can i handle it since its not related to networking errors   Ok, please check below code,

```
manager.session.configuration.timeoutIntervalForRequest = 10
let parameters: Parameters = ["pageno": pageno]
manager.request("http://API URL", method: .post, parameters: parameters, encoding: URLEncoding.default, headers: nil).responseJSON { (response:DataResponse<Any>) in
    
    switch(response.result) {
    case .success(_):
        if let data = response.result.value{
            if (data["status"] as! Bool){
            self.dataarray = data as! [AnyObject]
            
            self.tableView.reloadData()
        }
        }
        break
        
    case .failure(let error):
        print(response.result.error!)
        if error._code == NSURLErrorTimedOut {
            print("REQUEST TIME OUT")
        }
        break
        
    }
}
```
The API Response (**status**) is Boolean value and indicates if the response has data or not (empty) and as shown i'm handling the response only if its **TRUE** , but as i mentioned before its not useful because the error closure always throw 
`responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.inputDataNilOrZeroLength)` error if the response is empty .
So i need to catch and handle this error in the error closure (ex : show alert message NO MORE DATA) just like how i handled the time out error in my code  Okay, Thanks Man   I donnot understand why the response.resumeData is nil when downLoadRequest.cancel().

the downLoad code like this:
``` swift
if let cancelData = UserDefaults.standard.object(forKey: fileName) as? Data {
        downLoadRequest = Alamofire.download(resumingWith: cancelData, to: destionation)
} else {
        downLoadRequest = Alamofire.download(fullURL, headers: ["token" : kToken], to: destionation)
}
downLoadRequest.downloadProgress(closure: { (progress) in
            self.showProgress(Float(progress.fractionCompleted), title: "DownLoading...")
        })
downLoadRequest.responseData { (response) in
            self.stopLoading()
            switch response.result{
            case .success(_):
                UserDefaults.standard.removeObject(forKey: fileName)
                DispatchQueue.main.async {
                    completeHandle()
                }
            case .failure(_):
                print("\(response.resumeData!)")
                UserDefaults.standard.set(response.resumeData, forKey: fileName)
            }
        }

``` you can try to write data to file use FileManager when you downloading....... @xuanwenchao if I do not cancel, the task download success, and i can open the file, but when i do download.cancel(),  the  response.resumeData = nil, and how can i write data to file when resumeData is nil?  My Pod File has
`pod 'Alamofire', '~> 4.4'`

My code is
```
import Alamofire
 var postData        : Data! 
....
fullURLString = Commons.getFullURL(self.apiUrl) + "/" + self.getOrPostType
        fullURL = URL.init(string: fullURLString)
.....
 Alamofire.request(fullURL, method: .post, parameters: postData).responseJSON { response in
                        self.responseData = response.result.value
            }
```

Documentation at [here](https://github.com/Alamofire/Alamofire)

> // All three of these calls are equivalent
> Alamofire.request("https://httpbin.org/post", method: .post, parameters: parameters)
> Alamofire.request("https://httpbin.org/post", method: .post, parameters: parameters, encoding: URLEncoding.default)
> Alamofire.request("https://httpbin.org/post", method: .post, parameters: parameters, encoding: URLEncoding.httpBody)

What am I missing here ? Parameters's type is wrong. It should be Parameters?(aka. [String: Any]?), not Data.
```swift
Alamofire.request("", method: .post, parameters: Data()!) // just demo. Extra argument 'method' in call.
Alamofire.request("", method: .post, parameters: ["a": "test", "b": 3]) // public typealias Parameters = [String: Any]. Okay.
``` Why is XCode reporting `.method` as the extra parameter. I wonder why XCode is to misleading.      open func resume() {
        guard let task = task else { delegate.queue.isSuspended = false ; return }

        if startTime == nil { startTime = CFAbsoluteTimeGetCurrent() }

        task.resume()

        NotificationCenter.default.post(
            name: Notification.Name.Task.DidResume,
            object: self,
            userInfo: [Notification.Key.Task: task] // error occurred
        )
    }    An extra step has been added for users using Alamofire with Xcode 9 No problem, I appreciate you taking out the time to consider the PR.
Cheers!  Hi all,

I'm currently facing an issue with redirect with POST request. Say if i have a request like POST "https://dev.abc.co", in taskWillPerformHTTPRedirection i get https://dev-1.abc.co (correct domain from load balancer), but the redirect request is now in GET instead of POST, and all the POST data is gone. Is there anything I'm missing?

static let manager: SessionManager = {
    
    let configuration = URLSessionConfiguration.default
    configuration.httpAdditionalHeaders = SessionManager.defaultHTTPHeaders
    configuration.requestCachePolicy = .useProtocolCachePolicy
    
    let certs = ServerTrustPolicy.certificates(in: Bundle.main)
    
    let security = ServerTrustPolicy.pinCertificates(certificates: ServerTrustPolicy.certificates(in: Bundle.main),
                                                     validateCertificateChain: true,
                                                     validateHost: true)
  
    let trustPolicies =
      ServerTrustPolicyManager(policies: [
        "*.abc.co":
          .pinCertificates(certificates: ServerTrustPolicy.certificates(in: Bundle.main),
                           validateCertificateChain: true,
                           validateHost: true)
        ])
    
    let manager = SessionManager(configuration: configuration,
                          serverTrustPolicyManager: trustPolicies)
    
    manager.delegate.taskWillPerformHTTPRedirection = { (session, task, response, request) -> URLRequest? in
      print("REDIRECT Request: \(request)")

      return request
    }
    
    return manager
}()
  ### Overview

This PR introduces the use of `fastlane` for testing and archiving Alamofire.
`fastlane` is best used in combination with `bundler`

### Install Bundler

```zsh
$ [sudo] gem install bundler
```

### Install Fastlane

Start by installing it, after you've installed `bundler`, all you need to do is:

```zsh
$ bundle install
```

### Using Fastlane

```zsh
$ bundle exec fastlane ios test
$ bundle exec fastlane macos test
$ bundle exec fastlane tvos test
```

### Archiving Alamofire and creating a GitHub release

The script will prompt you for answers if you do not provide them.

```zsh
$ bundle exec fastlane archive
[11:28:38]: -------------------------------------------------
[11:28:38]: --- Step: Verifying required fastlane version ---
[11:28:38]: -------------------------------------------------
[11:28:38]: Your fastlane version 2.37.0 matches the minimum requirement of 2.37.0  ‚úÖ
[11:28:38]: Platform 'tvos' is not officially supported. Currently supported platforms are [:ios, :mac, :android].
[11:28:38]: Platform 'watchos' is not officially supported. Currently supported platforms are [:ios, :mac, :android].
[11:28:38]: Driving the lane 'archive' üöÄ
[11:28:38]: --------------------
[11:28:38]: --- Step: prompt ---
[11:28:38]: --------------------
[11:28:38]: A release name is required to create a GitHub release. Please provide a name:
5.5.5
[11:28:56]: --------------------
[11:28:56]: --- Step: prompt ---
[11:28:56]: --------------------
[11:28:56]: A release tag is required to create a GitHub release. Please provide a tag:
5.5.5
[11:29:00]: --------------------
[11:29:00]: --- Step: prompt ---
[11:29:00]: --------------------
[11:29:00]: What is the path of the GitHub repository?
bsarrazin/Alamofire
[11:29:10]: ----------------------
[11:29:10]: --- Step: carthage ---
[11:29:10]: ----------------------
[11:29:10]: $ carthage build --no-skip-current
[11:29:11]: ‚ñ∏ *** xcodebuild output can be found in /var/folders/3n/0zjn1g0s2gbfflyvp1vjjfhr0000gn/T/carthage-xcodebuild.3lIltL.log
[11:29:15]: ‚ñ∏ *** Building scheme "Alamofire macOS" in Alamofire.xcworkspace
[11:29:25]: ‚ñ∏ *** Building scheme "Alamofire watchOS" in Alamofire.xcworkspace
[11:29:47]: ‚ñ∏ *** Building scheme "Alamofire tvOS" in Alamofire.xcworkspace
[11:30:11]: ‚ñ∏ *** Building scheme "Alamofire iOS" in Alamofire.xcworkspace
[11:30:37]: ----------------------
[11:30:37]: --- Step: carthage ---
[11:30:37]: ----------------------
[11:30:37]: $ carthage archive Alamofire --output build/Alamofire.framework.zip
[11:30:38]: ‚ñ∏ *** Found Carthage/Build/Mac/Alamofire.framework
[11:30:38]: ‚ñ∏ *** Found Carthage/Build/Mac/Alamofire.framework.dSYM
[11:30:38]: ‚ñ∏ *** Found Carthage/Build/iOS/Alamofire.framework
[11:30:38]: ‚ñ∏ *** Found Carthage/Build/iOS/Alamofire.framework.dSYM
[11:30:38]: ‚ñ∏ *** Found Carthage/Build/watchOS/Alamofire.framework
[11:30:38]: ‚ñ∏ *** Found Carthage/Build/watchOS/Alamofire.framework.dSYM
[11:30:38]: ‚ñ∏ *** Found Carthage/Build/tvOS/Alamofire.framework
[11:30:38]: ‚ñ∏ *** Found Carthage/Build/tvOS/Alamofire.framework.dSYM
[11:30:38]: ‚ñ∏ *** Found Carthage/Build/Mac/D1ADB48A-32B8-3189-BF12-B51F0A537C58.bcsymbolmap
[11:30:38]: ‚ñ∏ *** Found Carthage/Build/iOS/D43455C0-526B-3015-B00B-DB19F2070079.bcsymbolmap
[11:30:38]: ‚ñ∏ *** Found Carthage/Build/iOS/86A6EE77-D28E-364B-AD78-E7397AA881EA.bcsymbolmap
[11:30:38]: ‚ñ∏ *** Found Carthage/Build/iOS/EFDFDB25-2A98-3EB6-ABEB-B908B4CE154A.bcsymbolmap
[11:30:38]: ‚ñ∏ *** Found Carthage/Build/iOS/0778389A-9014-322D-B9FD-09B19AE4C757.bcsymbolmap
[11:30:38]: ‚ñ∏ *** Found Carthage/Build/watchOS/ADB2E81C-0755-362A-9E32-12414B3E38A6.bcsymbolmap
[11:30:38]: ‚ñ∏ *** Found Carthage/Build/watchOS/5E925473-C762-3E62-A713-4522B9E0CB2A.bcsymbolmap
[11:30:38]: ‚ñ∏ *** Found Carthage/Build/tvOS/444F697A-5784-3978-9119-2C516D80173C.bcsymbolmap
[11:30:38]: ‚ñ∏ *** Found Carthage/Build/tvOS/C711CD96-E7B0-3CF0-961E-38FF9C08E094.bcsymbolmap
[11:30:40]: ‚ñ∏ *** Created build/Alamofire.framework.zip
[11:30:40]: ------------------------
[11:30:40]: --- Step: git_branch ---
[11:30:40]: ------------------------
[11:30:40]: --------------------------------
[11:30:40]: --- Step: set_github_release ---
[11:30:40]: --------------------------------
[11:30:40]: Creating release of bsarrazin/Alamofire on tag "5.5.5" with name "5.5.5".
[11:30:40]: Will also upload assets ["build/Alamofire.framework.zip"].
[11:30:41]: Successfully created release at tag "5.5.5" on GitHub
[11:30:41]: See release at "https://github.com/bsarrazin/Alamofire/releases/tag/5.5.5"
[11:30:41]: Uploading Alamofire.framework.zip
[11:30:48]: Successfully uploaded Alamofire.framework.zip.
[11:30:48]: Successfully uploaded assets ["build/Alamofire.framework.zip"] to release "https://github.com/bsarrazin/Alamofire/releases/tag/5.5.5"

+------+-------------------------------------+-------------+
|                     fastlane summary                     |
+------+-------------------------------------+-------------+
| Step | Action                              | Time (in s) |
+------+-------------------------------------+-------------+
| 1    | Verifying required fastlane version | 0           |
| 2    | prompt                              | 17          |
| 3    | prompt                              | 4           |
| 4    | prompt                              | 10          |
| 5    | carthage                            | 86          |
| 6    | carthage                            | 2           |
| 7    | git_branch                          | 0           |
| 8    | set_github_release                  | 8           |
+------+-------------------------------------+-------------+

[11:30:48]: fastlane.tools finished successfully üéâ
```

The above script will produce:
![screen shot 2017-06-11 at 11 32 26 am](https://user-images.githubusercontent.com/1077441/27012209-b7bd9132-4e99-11e7-8587-b859576cf1a1.png)

### Requirements

The script requires an environment variable named `GITHUB_API_TOKEN`. Alternatively, you can provide the token at the command line as such (along with the other values):

```zsh
$ bundle exec fastlane archive github_api_token:xxx github_release_title:5.5.5 github_release_tag:5.5.5 archive_repository_path:"bsarrazin/Alamofire"
[11:37:15]: -------------------------------------------------
[11:37:15]: --- Step: Verifying required fastlane version ---
[11:37:15]: -------------------------------------------------
[11:37:15]: Your fastlane version 2.37.0 matches the minimum requirement of 2.37.0  ‚úÖ
[11:37:15]: Platform 'tvos' is not officially supported. Currently supported platforms are [:ios, :mac, :android].
[11:37:15]: Platform 'watchos' is not officially supported. Currently supported platforms are [:ios, :mac, :android].
[11:37:15]: Driving the lane 'archive' üöÄ
[11:37:15]: ----------------------
[11:37:15]: --- Step: carthage ---
[11:37:15]: ----------------------
[11:37:15]: $ carthage build --no-skip-current
[11:37:15]: ‚ñ∏ *** xcodebuild output can be found in /var/folders/3n/0zjn1g0s2gbfflyvp1vjjfhr0000gn/T/carthage-xcodebuild.c2QilB.log
[11:37:19]: ‚ñ∏ *** Building scheme "Alamofire macOS" in Alamofire.xcworkspace
[11:37:30]: ‚ñ∏ *** Building scheme "Alamofire iOS" in Alamofire.xcworkspace
[11:37:56]: ‚ñ∏ *** Building scheme "Alamofire watchOS" in Alamofire.xcworkspace
[11:38:18]: ‚ñ∏ *** Building scheme "Alamofire tvOS" in Alamofire.xcworkspace
[11:38:42]: ----------------------
[11:38:42]: --- Step: carthage ---
[11:38:42]: ----------------------
[11:38:42]: $ carthage archive Alamofire --output build/Alamofire.framework.zip
[11:38:42]: ‚ñ∏ *** Found Carthage/Build/Mac/Alamofire.framework
[11:38:42]: ‚ñ∏ *** Found Carthage/Build/Mac/Alamofire.framework.dSYM
[11:38:42]: ‚ñ∏ *** Found Carthage/Build/iOS/Alamofire.framework
[11:38:42]: ‚ñ∏ *** Found Carthage/Build/iOS/Alamofire.framework.dSYM
[11:38:42]: ‚ñ∏ *** Found Carthage/Build/watchOS/Alamofire.framework
[11:38:42]: ‚ñ∏ *** Found Carthage/Build/watchOS/Alamofire.framework.dSYM
[11:38:42]: ‚ñ∏ *** Found Carthage/Build/tvOS/Alamofire.framework
[11:38:42]: ‚ñ∏ *** Found Carthage/Build/tvOS/Alamofire.framework.dSYM
[11:38:42]: ‚ñ∏ *** Found Carthage/Build/iOS/D43455C0-526B-3015-B00B-DB19F2070079.bcsymbolmap
[11:38:42]: ‚ñ∏ *** Found Carthage/Build/Mac/D1ADB48A-32B8-3189-BF12-B51F0A537C58.bcsymbolmap
[11:38:42]: ‚ñ∏ *** Found Carthage/Build/iOS/86A6EE77-D28E-364B-AD78-E7397AA881EA.bcsymbolmap
[11:38:42]: ‚ñ∏ *** Found Carthage/Build/iOS/EFDFDB25-2A98-3EB6-ABEB-B908B4CE154A.bcsymbolmap
[11:38:42]: ‚ñ∏ *** Found Carthage/Build/iOS/0778389A-9014-322D-B9FD-09B19AE4C757.bcsymbolmap
[11:38:42]: ‚ñ∏ *** Found Carthage/Build/watchOS/ADB2E81C-0755-362A-9E32-12414B3E38A6.bcsymbolmap
[11:38:42]: ‚ñ∏ *** Found Carthage/Build/watchOS/5E925473-C762-3E62-A713-4522B9E0CB2A.bcsymbolmap
[11:38:42]: ‚ñ∏ *** Found Carthage/Build/tvOS/444F697A-5784-3978-9119-2C516D80173C.bcsymbolmap
[11:38:42]: ‚ñ∏ *** Found Carthage/Build/tvOS/C711CD96-E7B0-3CF0-961E-38FF9C08E094.bcsymbolmap
[11:38:45]: ‚ñ∏ *** Created build/Alamofire.framework.zip
[11:38:45]: ------------------------
[11:38:45]: --- Step: git_branch ---
[11:38:45]: ------------------------
[11:38:45]: --------------------------------
[11:38:45]: --- Step: set_github_release ---
[11:38:45]: --------------------------------
[11:38:45]: Creating release of bsarrazin/Alamofire on tag "5.5.5" with name "5.5.5".
[11:38:45]: Will also upload assets ["build/Alamofire.framework.zip"].
[11:38:45]: Successfully created release at tag "5.5.5" on GitHub
[11:38:45]: See release at "https://github.com/bsarrazin/Alamofire/releases/tag/5.5.5"
[11:38:45]: Uploading Alamofire.framework.zip
[11:38:53]: Successfully uploaded Alamofire.framework.zip.
[11:38:53]: Successfully uploaded assets ["build/Alamofire.framework.zip"] to release "https://github.com/bsarrazin/Alamofire/releases/tag/5.5.5"

+------+-------------------------------------+-------------+
|                     fastlane summary                     |
+------+-------------------------------------+-------------+
| Step | Action                              | Time (in s) |
+------+-------------------------------------+-------------+
| 1    | Verifying required fastlane version | 0           |
| 2    | carthage                            | 87          |
| 3    | carthage                            | 2           |
| 4    | git_branch                          | 0           |
| 5    | set_github_release                  | 8           |
+------+-------------------------------------+-------------+

[11:38:53]: fastlane.tools finished successfully üéâ
```  If so, I'll be happy to create a PR with this in it... Created the PR here:
https://github.com/Alamofire/Alamofire/pull/2148  I have this error on Xcode 9, after updating my project to swift 4 with the new iOS 11 beta version:

"Pods/Alamofire/Source/ParameterEncoding.swift:245:31: Closure tuple parameter '(String, String)' does not support destructuring with implicit parameters"

Any help ?

![schermata 2017-06-09 alle 12 45 37](https://user-images.githubusercontent.com/5076292/26972353-bd9a6a82-4d11-11e7-93b8-dc5c9d41a345.png) Maybe I solved it üëç 

https://github.com/Alamofire/Alamofire/issues/2141

 step1: select pods 
step2: select targets  Alamofire
step3: select builds setting
and search  swift language version

we can set swift language version 3.2
I can`t speak English
  I need to upload images with parameter to web service, but the encoding type has to JSON . How can send the image with JSON Parameters?
          
             func UpdateMulipartApi(){
             let parameter: Parameters = ["action":"edit_profile", "user_id":"11"]

            Alamofire.upload(multipartFormData: {
                (multipartFormData) in
                
              multipartFormData.append(UIImageJPEGRepresentation(self.imgprofile.image!, 0.3)!, withName: "filename", fileName: "swift_file.jpeg", mimeType: "image/jpg")
                  multipartFormData.append(UIImageJPEGRepresentation(self.Imgbackground.image!, 0.3)!, withName: "cover_image", fileName: "swift_file.jpeg", mimeType: "image/jpg")
                
                for (key, value ) in parameter {
                    multipartFormData.append(((value) as AnyObject).data(using: String.Encoding.utf8.rawValue)!, withName: key)
                    
                }
            
            }, to: "http://server.com/apis/object.php") //url changed
         
            {  (result) in
                switch result {
                case .success(let upload, , ):
                    
                    upload.uploadProgress(closure: { (progress) in
                        UILabel().text = "\((progress.fractionCompleted * 100)) %"
                    })
                    
                    
                    upload.responseJSON { response in
                        
                        guard ((response.result.value) != nil) else{
                            print(response.result.error!.localizedDescription)
                            return
                        }
                        var json = JSON(response.result.value!)
                        print(json)
                        guard (json["result"]["msg"] .intValue) == 201  else {

                            return
                        }

                        self.showalertview(messagestring: "Profile Updated Successfully")
                        
                        
                    }
                case .failure(let encodingError):
                    print (encodingError.localizedDescription)
                    animationView?.pause()
                    animationView?.removeFromSuperview()
                }
                
            }
            
        }  How to upload image synchronously with parameter  Hi,
I have a problem when an application built using Xcode 9. Runtime error right after when application is going to start:
```
dyld: Symbol not found: _OBJC_CLASS_$_NSURLSessionStreamTask
  Referenced from: /Users/.../Library/Developer/Xcode/DerivedData/###-bcrzoulrsfdubrbahknmpsvtakka/Build/Products/Debug/###.app/Contents/MacOS/../Frameworks/Alamofire.framework/Versions/A/Alamofire
  Expected in: /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation
 in /Users/.../Library/Developer/Xcode/DerivedData/###-bcrzoulrsfdubrbahknmpsvtakka/Build/Products/Debug/###.app/Contents/MacOS/../Frameworks/Alamofire.framework/Versions/A/Alamofire
```

Cocoapods configuration:
```
platform :osx, '10.11'

use_frameworks!

target 'TranslateEverywhere' do
	
    pod 'MASShortcut'
    pod 'PySwiftyRegex',    '~> 1.0'
    pod 'Alamofire',        '~> 4.0'
    pod 'SwiftyJSON'
    pod 'RxSwift',          '~> 3.0'
    pod 'RxCocoa',          '~> 3.0'
    pod 'RxAlamofire',      '~> 3.0'
    pod 'SwiftyXML', 		'~> 1.4.0'
    pod 'SwiftString3',     '~> 1.0'

end

post_install do |installer|
  installer.pods_project.targets.each do |target|
    target.build_configurations.each do |config|
      config.build_settings['MACOSX_DEPLOYMENT_TARGET'] = '10.11'
    end
  end
end
```

```
pod --version
1.2.1
```
 @jshier  Tried to clean up the project, removed delivered data. Also tried to build with a new builder. Nothing helps. Also found somewhere that adding to other linker flags `-Objc` and `-framework Foundation` could help but without success.  After clearing Delivered Data, removing pods configuration:
```
post_install do |installer|
  installer.pods_project.targets.each do |target|
    target.build_configurations.each do |config|
      config.build_settings['MACOSX_DEPLOYMENT_TARGET'] = '10.11'
    end
  end
end
```
and `pod install` problem seems to be solved.  After conversion to Swift 4, getting this error.

<img width="1920" alt="screen shot 2017-06-07 at 12 54 50" src="https://user-images.githubusercontent.com/13763935/26872844-a56c5b9c-4b80-11e7-852f-a621d1dda7c2.png">
 ```swift
components.map { "\($0.0)=\($0.1)" }
```
use this.
Swift 3 the parameter is flatten, like this
```swift
components.map { $0, $1 in
  "\($0)=\($1)"
}
```
but Swift 4 not.
```swift
components.map { $0 in
  "\($0.0)=\($0.1)" // $0 is (String, String)
}
```
[SE-0110](https://github.com/apple/swift-evolution/blob/master/proposals/0110-distingish-single-tuple-arg.md) Are you planning to support Swift 4 in the future? Try this :

return components.map { (componentTuple: (String, String)) in "\(componentTuple.0)=\(componentTuple.1)"}.joined(separator: "&")

 Thanks for the information :-)   Is there a compatible branch for swift3.2: in that case, it would work with Swift 4? there is no branch for 3.2 where is the swift branch named 3.2 Give them a break guys! Or do it and PR the changes :-)  I'm seeing a fairly common `EXC_BREAKPOINT` crash in Crashlytics caused by a delegate handler in Alamofire. See below for the stack trace. The app in question is iOS 10 only, and the crash seems to happen on all devices and 10.x versions.

```
Crashed: NSOperationQueue 0x170034f60 :: NSOperation 0x1708519a0 (QOS: DEFAULT)
0  libswiftFoundation.dylib       0x100dc2e4c static Data._unconditionallyBridgeFromObjectiveC(NSData?) -> Data (__hidden#3516_:1698)
1  Alamofire                      0x10061388c @objc SessionDelegate.urlSession(URLSession, dataTask : URLSessionDataTask, didReceive : Data) -> () + 184
2  CFNetwork                      0x185672b1c __67-[NSURLSession delegate_dataTask:didReceiveData:completionHandler:]_block_invoke.242 + 36
3  Foundation                     0x185993fb0 __NSBLOCKOPERATION_IS_CALLING_OUT_TO_A_BLOCK__ + 16
4  Foundation                     0x1858d8aa8 -[NSBlockOperation main] + 96
5  Foundation                     0x1858c90a4 -[__NSOperationInternal _start:] + 620
6  Foundation                     0x18599635c __NSOQSchedule_f + 228
7  libdispatch.dylib              0x183d2e1bc _dispatch_client_callout + 16
8  libdispatch.dylib              0x183d3c3dc _dispatch_queue_serial_drain + 928
9  libdispatch.dylib              0x183d319a4 _dispatch_queue_invoke + 652
10 libdispatch.dylib              0x183d3e34c _dispatch_root_queue_drain + 572
11 libdispatch.dylib              0x183d3e0ac _dispatch_worker_thread3 + 124
12 libsystem_pthread.dylib        0x183f372a0 _pthread_wqthread + 1288
13 libsystem_pthread.dylib        0x183f36d8c start_wqthread + 4
```

Due to the crash being `EXC_BREAKPOINT` I'm assuming it's a failing assertion somewhere and may actually be happening in the Swift/Obj-C compatibility layer before the actual delegate code is even called. But I'm not sure how to debug this and was hoping someone on here has an idea why this would happen.

I use Alamofire for standard HTTPS requests to a JSON backend. I have one standard session manager and one background session manager. I'm setting the `backgroundCompletionHandler` in the app delegate as well. Since this crashes independently from any of my code I'm having a very hard time tracking whether this is happening for random requests, or specific ones. That said, it shouldn't be possible for any request to return "nil" data since even a request that returns nothing has a valid data payload of 0 bytes.

I've got a separate background `URLSession` that I'm managing myself (with a unique session identifier) and four Alamofire sessions (two of which are regular sessions, and the other two are background sessions with unique identifiers). Are there known conflicts with using multiple sessions with Alamofire? Alright, I've filed radar `32631704`. Oh and I forgot to mention that the project is built with Swift 3. +1 on this Experienced the same today. +1 found any solution i also got the same problem I've taken all precautions I can imagine in my code now and this crash is still occurring.

Our project also has other background `URLSession`s with `URLSessionDelegate` assigned and does not crash in those, so is it possible this crash is related to how Alamofire does magic with `respondsToSelector` etc? @jshier I understand the crash itself is due to a bug in the bridging code, but it's also a bug that only happens in the specific code path caused by Alamofire. Since other `URLSession` configurations doing roughly the same thing are working in Swift 3, it's likely that Alamofire can work its way around the crash. Is this something you would consider investigating? @jshier Okay thank you for looking into this.

For context, in the past 7 days this crash happened to ~8% of our active users (52% of them were using iOS 10.3.2, some older 10.x versions, some iOS 11), according to Crashlytics. Interestingly, it happened on average only ~1.2 times per unique user that experienced the crash.

Most of the reports have a user account id associated which (due to our app flow) probably means it's not associated with first-time install/launch. Several of the crash reports have the main thread initializing the app which suggests this may happen specifically for tasks that made progress in the background.

Hope this data is helpful.  The app is not on iOS 9 so I can't provide any statistics there. I included most of this in my bug report but I've added the above to the report as additional context. @jshier Configuration-wise we don't change anything, but the number of concurrent connections may go up and down as different API calls and uploads are performed. In rare cases where the user has been disconnected there might be pending retryable requests which could spike the connection count (presumably the underlying `URLSession` will limit it though).

I would expect the connection count to stay around 2 for most of the requests, but while spiking, assuming the `URLSession` doesn't take advantage of pipelining or HTTP/2 (I haven't investigated if it is switching to HTTP/2 for our API endpoints), the count could probably reach 10-20 or so. I've not been able to correlate the crash with a burst of requests, though.

The calls made through Alamofire should all have request payloads and response sizes <100 kB (JSON API), while our own `URLSession` code will be uploading potentially hundreds of megabytes. @jshier Unfortunately, I haven't been able to find any correlations based on configuration. It's happening on all iOS 10-enabled devices, including iPads and iPod Touch.

Available disk space does not appear to be a factor either. Free RAM is generally around 3-15% so could be an indicator, but it could also be the norm that most RAM is in use on iOS devices. I've seen several crashes with 25+% free RAM so it's definitely not a clear cause. Is this an issue since 4.5.0? Because I've been thinking of upgrading, but maybe I should wait for a bit. This report is for Alamofire 4.4.0. I'll update to 4.5.0 for our next release to see if it makes any difference. So i'm also on 4.4.0 so it doesn't make any difference. Thanks @blixt! @blixt @jshier 

My app crashed in the below delegate method, I changed my `data` to Optional parameter. Compiler shows me a warning "parameter has different optionality than expected by protocol", but this workaround worked for my case and I do not experience crashes anymore. 
Note: And, yes, this method is still being called by delegate.

```
extension MySessionDelegate: URLSessionDataDelegate {
    func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data?) {      
      if (data == nil) {
      } else {
      }
    }
}

```  I have integrated Alamofire into my project using carthage. We are working on CI-CD setup for our application. I created a bot and configured Xcode server, i am getting below issue as error while i integrate the bot with Xcode Server,
	**Opening import file for module 'Alamofire': Permission denied**
It works fine when i run it directly in simulator. Getting this error only when i try to integrate my project with Xcode server. Can anyone please help me on this?  xcode 8.3.2
swift 3
Alamofire 4.4.0
SwiftyJSON 3.1.4

AlamofireSwiftyJSON.swift

<img width="1124" alt="screen shot 2017-06-03 at 8 21 53 pm" src="https://cloud.githubusercontent.com/assets/6891269/26757900/57a379b0-489a-11e7-93b7-eb517407d514.png">

  I did not find any stream exmaples in the project, can anyone give some instruction about stream usage?   Even if there is no standard most of the web framework will avoid the usage of square brackets while passing an array as parameter.
That is why I've added a new parameter to avoid the usage of brackets during URL parameter encoding.  I found out that many people use timeout like this:

```swift
let manager = Alamofire.SessionManager.default
manager.session.configuration.timeoutIntervalForRequest = 120
manager.request("yourUrl", method: .post, parameters: ["parameterKey": "value"])
```

Or rebuild configuration and set it to object‚Äôs session. 

I think it is not a good way to do it because if people work in teams these weird checks on exact "under-water" codes will make code very unreadable. Also not suit for Alamofire‚Äôs structure. 

I added this code because I thought it would be nice if Alamofire had this function as a basic feature.   Hey there,

I just migrated to Alamofire 4 and my post requests dont work sometimes. 

The issue is, I originally I added both query and .net form parameters together and it worked fine.

Hovever its not working when I add them together now.

1. How do I solve this?
2. Is it possible to use Alamofire 3 with Swift 3.  [
<img width="1009" alt="screen shot 2017-05-29 at 12 38 02 pm" src="https://cloud.githubusercontent.com/assets/26128545/26556943/b896d84e-446b-11e7-9846-433aad6b845a.png">
](url) Same problem here. Any ideas how to solve this?  Added new let constant to enhance the code readability and integrity.
 It worked fine on my local iPhone 7 test but it seems to fail on CI. Can you re-test it please?  Swift & Objective-C beginners can not know the validity of execution results.
We are glad that there is no black box at least beginning of READ.ME.  I'm trying to connect to a Web server on a local network using Alamofire. If I open the url with a browser, it gives a ssl warning. If I just ignore and add the exception to the browser, it definitely works.  
I wasn't able to get Alamofire to ignore. What am I doing wrong?  
Thanks in advance!  
Here is the testing code:  

    let parameters:Parameters = ["macro":"696B38D0-AF57-4991-83DD-DFD03F1A693B", "value":""]
    let manager = SessionManager(serverTrustPolicyManager: ServerTrustPolicyManager(policies:["10.0.1.19:4491":.disableEvaluation]))
    manager.request("https://10.0.1.19:4491/action.html", parameters:parameters).authenticate(user:user, password:password).response {
     response in
      debugPrint(response)
    }

Here is the error:  

Alamofire.DefaultDataResponse(request: Optional(https://10.0.1.19:4491/action.html?macro=696B38D0-AF57-4991-83DD-DFD03F1A693B&value=), response: nil, data: Optional(0 bytes), error: Optional(Error Domain=NSURLErrorDomain Code=-999 "cancelled" UserInfo={NSErrorFailingURLKey=https://10.0.1.19:4491/action.html?macro=696B38D0-AF57-4991-83DD-DFD03F1A693B&value=, NSLocalizedDescription=cancelled, NSErrorFailingURLStringKey=https://10.0.1.19:4491/action.html?macro=696B38D0-AF57-4991-83DD-DFD03F1A693B&value=}), timeline: Timeline: { "Request Start Time": 517281923.642, "Initial Response Time": 517281923.818, "Request Completed Time": 517281923.818, "Serialization Completed Time": 517281923.865, "Latency": 0.177 secs, "Request Duration": 0.177 secs, "Serialization Duration": 0.047 secs, "Total Duration": 0.224 secs }, _metrics: nil)
 I declared the sessionManager in the beginning of the class, and now I get this error:
Alamofire.DefaultDataResponse(request: Optional(https://10.0.1.19:4491/authenticatedaction.html?macro=696B38D0-AF57-4991-83DD-DFD03F1A693B&value=), response: nil, data: Optional(0 bytes), error: Optional(Error Domain=NSURLErrorDomain Code=-1202 "The certificate for this server is invalid. You might be connecting to a server that is pretending to be √¢‚Ç¨≈ì10.0.1.19√¢‚Ç¨¬ù which could put your confidential information at risk." UserInfo={NSURLErrorFailingURLPeerTrustErrorKey=<SecTrustRef: 0x170134a00>, NSLocalizedRecoverySuggestion=Would you like to connect to the server anyway?, _kCFStreamErrorDomainKey=3, _kCFStreamErrorCodeKey=-9813, NSErrorPeerCertificateChainKey=(
    "<cert(0x108066e00) s: Keyboard Maestro i: Keyboard Maestro CA>"
), NSUnderlyingError=0x170259d70 {Error Domain=kCFErrorDomainCFNetwork Code=-1202 "(null)" UserInfo={_kCFStreamPropertySSLClientCertificateState=0, kCFStreamPropertySSLPeerTrust=<SecTrustRef: 0x170134a00>, _kCFNetworkCFStreamSSLErrorOriginalValue=-9813, _kCFStreamErrorDomainKey=3, _kCFStreamErrorCodeKey=-9813, kCFStreamPropertySSLPeerCertificates=(
    "<cert(0x108066e00) s: Keyboard Maestro i: Keyboard Maestro CA>"
)}}, NSLocalizedDescription=The certificate for this server is invalid. You might be connecting to a server that is pretending to be √¢‚Ç¨≈ì10.0.1.19√¢‚Ç¨¬ù which could put your confidential information at risk., NSErrorFailingURLKey=https://10.0.1.19:4491/authenticatedaction.html?macro=696B38D0-AF57-4991-83DD-DFD03F1A693B&value=, NSErrorFailingURLStringKey=https://10.0.1.19:4491/authenticatedaction.html?macro=696B38D0-AF57-4991-83DD-DFD03F1A693B&value=, NSErrorClientCertificateStateKey=0}), timeline: Timeline: { "Request Start Time": 517316327.668, "Initial Response Time": 517316327.911, "Request Completed Time": 517316327.911, "Serialization Completed Time": 517316327.912, "Latency": 0.243 secs, "Request Duration": 0.243 secs, "Serialization Duration": 0.001 secs, "Total Duration": 0.244 secs }, _metrics: Optional((Task Interval) <_NSConcreteDateInterval: 0x17002b6e0> (Start Date) 2017-05-24 10:58:47 +0000 + (Duration) 0.251558 seconds = (End Date) 2017-05-24 10:58:47 +0000
(Redirect Count) 0
(Transaction Metrics) (Request) <NSURLRequest: 0x170013cd0> { URL: https://10.0.1.19:4491/authenticatedaction.html?macro=696B38D0-AF57-4991-83DD-DFD03F1A693B&value= }
(Response) (null)
(Fetch Start) 2017-05-24 10:58:47 +0000
(Domain Lookup Start) (null)
(Domain Lookup End) (null)
(Connect Start) (null)
(Secure Connection Start) (null)
(Secure Connection End) (null)
(Connect End) (null)
(Request Start) 2017-05-24 10:58:47 +0000
(Request End) 2017-05-24 10:58:47 +0000
(Response Start) 2017-05-24 10:58:47 +0000
(Response End) (null)
(Protocol Name) (null)
(Proxy Connection) NO
(Reused Connection) YES
(Fetch Type) Unknown

))
  i download some file need Segment download 

for example
 url  :  http://www.example.com/zzh/zhao1.mp3       seize  50000

curl -r 0-10240 -o "zhao.part1" http://www.example.com/zzh/zhao1.mp3 &\
curl -r 10241-20480 -o "zhao.part1" http://www.example.com/zzh/zhao1.mp3 &\
curl -r 20481-40960 -o "zhao.part1" http://www.example.com/zzh/zhao1.mp3 &\
curl -r 40961-50000 -o "zhao.part1" http://www.example.com/zzh/zhao1.mp3 

if i ues Alamofire , How should I write?  Alamofire.request(url!, method: .get, parameters: nil, encoding: URLEncoding.queryString, headers: nil)
        .responseJSON { (response) in
            guard response.result.isSuccess else {
                return
            }
            DispatchQueue.main.async {
                UIApplication.shared.isNetworkActivityIndicatorVisible = false
                self.updateSearchResults(response.data)
            }
    }



I tried to change!!!
let url = str.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed)

but!

The app will be shut down.
If url include Korean  import error!
No such module 'Alamofire'  After downloading, i just want to add in local database the object and show in uitableview  `self.readingCollectionview.reloadData()`. Although I added like sample code, it doesn't work. Thanks.

```
let utilityQueue = DispatchQueue.global(qos: .utility)
Alamofire.download(downloadUrl, method: .get, parameters: nil, encoding: JSONEncoding.default, headers: headers, to: destination)
 .downloadProgress(queue: utilityQueue) { progress in
  DLog("Download Progress: \(progress.fractionCompleted)")
 }
 .response { response in
  DispatchQueue.global(qos: .background).async {
    DBTransition().SubscribeBook(bookList, sampleBook: true)                        
    if self.catalogueBooks.count == self.eGazelCount {
      self.localBooks = DBTransition().readBooksLocal()
      DispatchQueue.global().async {
         self.readingCollectionview.reloadData()
      }
   }
 }
 }
}
```  Hi

I added an extension for my Watch to my iOS app. I would like to use Alamofire in my Watch app as I do in my iOS app. I added a new target in my project, and started by adding "import Alamofire", if I build my app, it says "No such mode Alamofire". Any idea why ? 
My iOS app, in the same project, works perfectly with Alamofire. 

Thanks !
Mickael.  I use this when I need to allow invalid certificates and it works perfectly:

```
static var manager : SessionManager = {

// Create the server trust policies
let serverTrustPolicies: [String: ServerTrustPolicy] = [
    "my server url": .disableEvaluation
]

// Create custom manager
let configuration = URLSessionConfiguration.default
configuration.httpAdditionalHeaders = Alamofire.SessionManager.defaultHTTPHeaders

let manager = Alamofire.SessionManager(
    configuration: URLSessionConfiguration.default,
    serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies)
)

return manager
}()
```

But Is it possible to change serverTrustPolicy of Alamofire.SessionManager to be able to use top-level convenience methods like Alamofire.request  The closure provided as a parameter to DataRequest.stream should be able to throws. If something wrong happen we need to say so for Alamo to close the connection‚Ä¶ I think‚Ä¶  Hello, I have an issue about Cache Control with Alamofire.

When I receive a 304 from the server and I have previously cached data from 200, the 304 request is not cached. So when I request again my server, I receive again a 304 instead of cached data. You have an idea about this issue inside Alamofire ?

Everything is ok when I test on chrome or other platforms. I inspected headers for 200 and 304 and it's good to use Cache Control.

Thanks and sorry for my english.  This is my configuration :
```swift
let configuration = URLSessionConfiguration.default
configuration.timeoutIntervalForRequest = 30
configuration.httpAdditionalHeaders = SessionManager.defaultHTTPHeaders
configuration.requestCachePolicy = .useProtocolCachePolicy
configuration.urlCache = URLCache()
self.requestManager = Alamofire.SessionManager(configuration: configuration)
```  I am using AF and using it's delegate to catch the authentication chanllenge returned by my server. 

    func connectGetRequest(_ url : URL){

        let sessionManager = Alamofire.SessionManager.default
        sessionManager.request(url).responseString { response in
            print("Response String: \(response.result.value)")
        }
        let delegate: Alamofire.SessionDelegate = sessionManager.delegate
        
        
        delegate.taskDidReceiveChallengeWithCompletion = { session, task, challenge,  completionHander in
            print("session is \(session), task is \(task) challenge is \(challenge.protectionSpace.authenticationMethod) and handler is \(completionHander)")
            if(challenge.protectionSpace.authenticationMethod == "NSURLAuthenticationMethodServerTrust"){

                completionHander(.performDefaultHandling,nil)
            }else{
                
                print("chanllege type is \(challenge.protectionSpace.authenticationMethod)")
                
          // Following line give me the error: "passing non-escaping parameter 'completionHander' to function expecting an @escaping closure"

    self.handleAuthenticationforSession(challenge,completionHandler:  completionHander)
            }
        }
        
        delegate.dataTaskDidReceiveData = {session , task, data in
            
            print("received data \(data)")
        }
        
    }

    
    func handleAuthenticationforSession(_ challenge: URLAuthenticationChallenge,completionHandler:   @escaping (Foundation.URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
        
             
            Authhandler.handleChallenge(forURLSessionChallenge: challenge, completionHandler: completionHandler)
            

    }
    

issue I have:

 
 1. If I use the code above as it is, I get

  error: "passing non-escaping  parameter 'completionHander' to function expecting an @escaping closure"

 2. If I make the parameter of the function handleAuthenticationSession non escaping, I get :

         func handleAuthenticationforSession(_ challenge: URLAuthenticationChallenge,
          completionHandler:   (Foundation.URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
        
             }

error: "Closure use of non-escaping parameter 'completion' may allow it to escape"

Also, handleChallenge method from AuthHandler class (which is a part of obj-c framework) looks like following. 

    -(BOOL)handleChallenge:(NSURLAuthenticationChallenge *)challenge
                           completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition,
                                                       NSURLCredential *credential))completionHandler;

So basically I am stuck in a deadlock while I use Alamofire's closure syntax to delegate the auth challenge. Update:

Someone on SO pointed out that I am hitting the same issue as [this](https://github.com/Alamofire/Alamofire/pull/1951) bug.

Can  someone please confirm?
Thanks  I changed **timeoutIntervalForRequest** with 

    let manager = Alamofire.SessionManager.default
    manager.session.configuration.timeoutIntervalForRequest = 3    
    manager.request(url).response {}

but seems not worked, Any suggestion? Any solutions?  I have noticed this problem as closed before but I am getting the same problem.

![screen shot 2017-05-12 at 10 56 07 am](https://cloud.githubusercontent.com/assets/13575978/25983318/a45260f0-3701-11e7-81b7-af8b62f03e00.png)

P.S - I have imported Alamofire in the class mentioned in the screenshot

Here is my pod details

    platform :ios, '10.0'

    use_frameworks!
    target 'PhotoTagger' do
         pod 'Alamofire'
    end

Also the only thing being auto completed is AlamofireVersionNumber and i cannot access anything when I am trying to use the auto complete feature. Now if i write Alamofire by hand then I can access some methods, but then again something is going wrong and code is not compiling, which i think boils down to the issue that the class isnt being fetched by auto complete.

I have tried -

In Project settings > Build settings

1. Always search user path To YES
2. Header search path to only include "$(inherited)" as non-recursive

All other pods are working fine, except Alamofire.
Also after writing class name by hand or copy pasting, some of the methods that are being auto completed does not have the same signature of the actual method of the Alamofire class

Please please please !! help me sort this out, so that someone out there when facing this can help themselves too. There isnt any solution to this as of now.  ![screen shot 2017-05-12 at 00 26 39](https://cloud.githubusercontent.com/assets/13282369/25972777/0c1588aa-36aa-11e7-8aa0-e98f254547ab.png)
![screen shot 2017-05-12 at 00 30 10](https://cloud.githubusercontent.com/assets/13282369/25973004/f1762daa-36aa-11e7-8099-43388f55de30.png)


I'm trying to upload my data on server and my application crashes, this line of code performed normally when i use defaultSessionManager, just fix it or tell me how to upload data when my app is in background state 8.3.2, swift 3, alamofire 4.4.0, all information about exception that I have is on screenshots. iOS version 10.2.1  This PR is part of a campaign to fix a lot of typos on github! You can see the progress on https://github.com/Lutzifer/fix_typos/  [Response]: nil
[Data]: 0 bytes
[Result]: FAILURE: invalidURL("http://api.test.com/v1/posts?tags=Áç®Á´ãÊ®ÇÈöä")
[Timeline]: Timeline: { "Request Start Time": 516165521.179, "Initial Response Time": 516165521.179, "Request Completed Time": 516165521.179, "Serialization Completed Time": 516165521.179, "Latency": -0.000 secs, "Request Duration": -0.000 secs, "Serialization Duration": 0.000 secs, "Total Duration": 0.000 secs }
  - request : nil
  - response : nil
  ‚ñø data : Optional<Data>
    ‚ñø some : 0 bytes
      - count : 0
      ‚ñø pointer : 0x7a62a960
        - pointerValue : 2053286240
      - bytes : 0 elements
  ‚ñø result : FAILURE: invalidURL("http://api.test.com/v1/posts?tags=Áç®Á´ãÊ®ÇÈöä")
    ‚ñø failure : AFError
      - invalidURL : "http://api.test.com/v1/posts?tags=Áç®Á´ãÊ®ÇÈöä"
  ‚ñø timeline : Timeline: { "Request Start Time": 516165521.179, "Initial Response Time": 516165521.179, "Request Completed Time": 516165521.179, "Serialization Completed Time": 516165521.179, "Latency": -0.000 secs, "Request Duration": -0.000 secs, "Serialization Duration": 0.000 secs, "Total Duration": 0.000 secs }
    - requestStartTime : 516165521.17944801
    - initialResponseTime : 516165521.17939502
    - requestCompletedTime : 516165521.17939502
    - serializationCompletedTime : 516165521.17944801
    - latency : -5.2988529205322266e-05
    - requestDuration : -5.2988529205322266e-05
    - serializationDuration : 5.2988529205322266e-05
    - totalDuration : 0.0
  - _metrics : nil  
<img width="878" alt="wx20170511-120248 2x" src="https://cloud.githubusercontent.com/assets/26423316/25931911/d1dd59b4-3641-11e7-8da5-df2077f87210.png">
 ÂΩìÁÑ∂‰ºöÂá∫ÈîôÔºå‰∏≠ÊñáÈúÄË¶ÅËΩ¨‰πâ  I am not sure if my issue belongs to "feature request" or not. I asked it at [stackoverflow]( http://stackoverflow.com/questions/43795943/how-to-reduce-boilerplate-in-responsejson-just-like-i-use-urlrequestconvertible) and did not get any answer so far. 

Let me repeat my question here,

I use URLRequestConvertible to groups my web calls, and to reduce the boilerplate code. But in each responseJSON I still have boilerplate to process my JSON response. They all look like these,

1. Check response.result.isSuccess
2. Check response.result.value as? the type data I expect (mostly a dictionary)
3. Check for the success indicator in dictionary
4. If succeed then retrieve the data I need.
5. Because I group the related calls in one URLRequestConvertible, their responses have the similar format that I actually have the 5th step to further retrieve the "real" data I am looking for.

So is there any way to reduce these boilerplate codes in responseJSON?  Hello, My web API needs client certificate while requesting from my IOS app (Ex. cert prompt on safari browser).  The certificate was pushed by MDM app(A) on my device and it is available under (Settings/General/Device Management/Digital Workspace/certificate) and the same certificate i want to use to make WebAPI request in My App (B) on the same device. 

Does it possible? If Yes, How can i achieve using Alamofire? Hi, I am having similar issue, when I access the API endpoint from iOS safari, it prompts the user for selecting client certificate. But when i call the API endpoint with Alamofire, it simply times out.  Hi!
I am using the latest Alamofire (v4.4.0) in my iOS app and I recently noticed that calling the `responseJson` on a `DataRequest` returns success when the HTTP response code is 4xx (ex. 422) even when I call the `validate()` method on it beforehand. I also tried manually specifing `validate(statusCode: [200])` and `validate(statusCode: 200..<300)` but still returns success in the closure. Hi!
Since I reported this issue, I dug deeper and found out what really caused the problem. Alamofire **_does_** validate responses correctly when calling validate() on a request in itself. But I only called it inside a response handling closure. I did it because in that response handling closure I checked the http status code and if it was `401` I tried a token refresh. If that token refresh was successful, or the status code was not `401`, **_only than_** I called validate on the request, before calling the final response handling closure. And this validate always resulted in response.result being success in the final response handling closure despite the status code being an error, for example `422`.

I don't know if this is an expected behavior, but if it is, I feel it should be documented, and if it isn't, I hope you can fix it. In the meantime, calling validate() on the request **_before_** the first response handler solved the problem in my app.

I created a sample project which demonstrates this behavior with an example API, I will upload it and link to it soon. Here is the example repository where I demonstrate the issue:
https://github.com/balazsgerlei/AlamofireValidationProblem  There are three previous examples, so the wording should be 'not use any' instead of 'not use either'.  I added alamofire to my workspace manually. I can import Alamofire in my code but I keep getting "Use of undeclared type" when I try to use a type declared in Alamofire like DataRequest.   Is there way to use TrustKit with Alamofire for pinning.
Can anyone help me in implementing it.    Updated ResponseTests.swift with some enhanced comments for clarity.
This is in reference to the issue opened: https://github.com/Alamofire/Alamofire/issues/2090
  I was writing a few tests in `ResponseTests.swift` to validate where an issue may have been coming from while using AlamoFire and noticed that `ResponseTests.swift` has test cases grouped by the response data that is returned by no comment to indicate that.  Wanted to add some clarity around this.  The library returns `-999` error in a case when ssl pinning failed. So there is no possible way to distinguish those errors to display relevant message to the user. 

I've searched through issues here and found some evidence that it is going to be fixed at version 5.0, but I could not find 5.0 dev branch:
https://github.com/Alamofire/Alamofire/issues/2011#issuecomment-287661286

Also there is a closed discussion for the similar problem at AFNetworking:
https://github.com/Alamofire/Alamofire/issues/1159#issuecomment-206707040

Could you reveal if there is work in progress for that issue? Will it be fixed at all?
  `AFError` converted in the `NSError` contains a `localizedDescription`, but the `userInfo` is empty.

```swift
let error = AFError.parameterEncodingFailed(reason: .missingURL)
let nsError = error as NSError

print(nsError.localizedDescription) // URL request to encode was missing a URL
print(nsError.userInfo) // [:]
```

If `AFError` to adapt to the `CustomNSError`, the `userInfo` will contain the `localizedDescription `.

```swift
let error = AFError.parameterEncodingFailed(reason: .missingURL)
let nsError = error as NSError

print(nsError.localizedDescription) // URL request to encode was missing a URL
print(nsError.userInfo) // [AnyHashable("NSLocalizedDescription"): URL request to encode was missing a URL]
```  I get this error when I try to `@testable import` the Alamofire module. I am on the latest version of carthage (0.16.2). I have Enable Testability set to YES in the main module.   **I failed to cache Aalamofire response.**
Here  I create session manager to call a request:

  ```
let configuration = URLSessionConfiguration.default
  configuration.requestCachePolicy = .returnCacheDataElseLoad
   let sessionManager = Alamofire.SessionManager(configuration: configuration)
```


**Error :** 
 libMobileGestalt MobileGestaltSupport.m:153: pid 1717 (XXXXXX) does not have sandbox access for frZQaeyWLUvLjeuEK43hmg and IS NOT appropriately entitled

libMobileGestalt MobileGestalt.c:550: no access to InverseDeviceID (see <rdar://problem/11744455>)

Does anybody have an idea how to cache the response for the Alamofire request?  Good morning,

When a request is made per post and returns a token, when I logout, the token is invalid, but instead if I use postman or any client rest I can logout since the token is valid. My question is, can this problem come through the sessions, that is, every time I make a request is created another session different?

Thank you.  I have some issues when I want to resume a download operation. I am using Alamofire 4.4 and I made my tests on iOS 9 and 10. Here is my use cases:

1- A download operation is in progress, I cancel the request (`resumeData` is generated and saved) and then I put the application on background. After relaunching the application, I resume the download (using the `resumeData`) some times the download is being resumed and sometimes is being restarted. Is it a normal behaviour ? And are there any solution if not ?

2- A download operation is in progress, and i kill the application. Downloaded data seems to be lost and I can't resume the download. Is there any solution to get the `resumeData` and resume the download after restarting the application ?

Thank you.  i wants to send my acces token in alamofire how i do this  ok thanks  This has been mentioned before but it seems this couldn't be replicated at the time,
(https://github.com/Alamofire/Alamofire/issues/1901)

But I'm having an issue with crashing with older devices on completing large downloads, specifically when the .moveItem call is made, resulting in:
"Message from debugger: Terminated due to memory issue"

I've made a very simple project that crashes every time on the following devices with a 850mb download:
iPad 3rd Gen - iOS 9.3.5
iPhone 5s - iOS 9.3.5

The download completes fine on newer devices, including iPhone 6s, iPad Pro 9.7", iPad Pro 12"

Smaller files work ok, for example, iPhone 5s doesn't crash on a 450mb file but receives 2 messages of "Received memory warning." before completing.

Attached is a zip to the project. All it does is load Alamofire, and starts downloading a file from a url, and prints the progress to the console.
[Downloader.zip](https://github.com/Alamofire/Alamofire/files/942688/Downloader.zip)

Note: This doesn't seem to crash on any simulators, only on actual devices.

If this is a iOS memory issue, is there any recommendations to get around this? Such as not downloading to a temp directory first and just downloading straight to the documents directory, so moveItem never has to occur? 
It seems iOS 9 and older devices are still pretty common place, so simply discontinuing on older devices isn't an option at the moment.

Thanks
 Just to add to this,
It seems that the file does actually complete the move after the app crashes. Thanks for your help Jon! I'll implement `response` and see if I get the same result.  I fixed the 2 ranges that were missing one value (400..<499 and 500..<599) and I changed the other one to match the rest in order to simplify the document  String interpolation produces a debug description for an optional value; did you mean to make this explicit?

Samplecode change String(describing: )  My webservice details 

Request Headers: ["Content-Type": "application/x-www-form-urlencoded; charset=utf-8", "X-API-KEY": "123456"]
Moya_Logger: [18/04/2017 12:17:56] HTTP Request Method: POST
Moya_Logger: [18/04/2017 12:17:56] Request Body: deviceId=111&deviceType=2&email=poonam%40gmail.com&password=0192023a7bbd73250516f069df18b500&versionName=1.0


and in responce getting as below  screenshot, getting 400 as status even evrything is fine on server side (since on postman webservice working fine)

<img width="814" alt="screen shot 2017-04-18 at 12 18 14 pm" src="https://cloud.githubusercontent.com/assets/2657399/25117837/65ab70f4-2431-11e7-9dd7-129f81737358.png">

Please give reply asap
  When Alamofire could support Swift 3.1?  How can you do:

`PATCH /users/123
[
    { "op": "replace", "path": "/email", "value": "new.email@example.org" }
]`

since alamofire only admits `Parameters` that is a `[String : Any]`

thanks!  I am doing a POST request but it is giving the below error at runtime:
Error Domain=com.alamofirejsontoobjects.error Code=1 "Data could not be serialized. Could not get a dictionary from the XML." UserInfo={NSLocalizedFailureReason=Data could not be serialized. Could not get a dictionary from the XML.}


I tried the request on POSTMAN but it is working fine and giving expected XML response.

Regards
Dev   I was having problems getting an "upload" to work until I wiresharked it to find that when I was using an url as such
`http://localhost/api`
it was not working but
`http://localhost/api/`
was (the extra **'/'** did it)

The server was sending a 302 Redirect, and Alamofire was not sending any mulitpartform data after that.

Im not sure if I should be handling the redirect myself somewhere but I thought it needed reporting  #  error info
```
dyld: Symbol not found: 
__TWPVs11AnyHashables20_AnyHashableProtocols
  Referenced from: /private/var/containers/Bundle/Application/82DE4F33-8E6D-4FFE-A868-8AB1CE08758F/SmartHub.app/Frameworks/Alamofire.framework/Alamofire
  Expected in: /private/var/containers/Bundle/Application/82DE4F33-8E6D-4FFE-A868-8AB1CE08758F/SmartHub.app/Frameworks/libswiftCore.dylib
 in /private/var/containers/Bundle/Application/82DE4F33-8E6D-4FFE-A868-8AB1CE08758F/SmartHub.app/Frameworks/Alamofire.framework/Alamofire
```

# stack info:
```
dyld`__abort_with_payload:
    0x100249cb4 <+0>:  mov    x16, #0x209
    0x100249cb8 <+4>:  svc    #0x80
->  0x100249cbc <+8>:  b.lo   0x100249cd4               ; <+32>
    0x100249cc0 <+12>: stp    x29, x30, [sp, #-0x10]!
    0x100249cc4 <+16>: mov    x29, sp
    0x100249cc8 <+20>: bl     0x100249500               ; cerror_nocancel
    0x100249ccc <+24>: mov    sp, x29
    0x100249cd0 <+28>: ldp    x29, x30, [sp], #0x10
    0x100249cd4 <+32>: ret 
```

# Alamofire:4.2.0

Xcode: 8.3.1
Support the lowest mobile phone system version 9.0
use cocoapods install 

# PodfileÔºö
```
#source 'https://github.com/CocoaPods/Specs.git'
platform :ios, '9.0'
target 'XXXX' do
use_frameworks!
pod 'SDWebImage'
pod 'SVProgressHUD'
pod 'Alamofire','~>4.2.0'
pod 'MJRefresh'
pod 'CocoaAsyncSocket'
pod 'SwiftyTimer','~>2.0.0'
pod 'SnapKit','~>3.0.0'
end
```
  **Purpose**
The ```contentType``` of a ```MultipartFormData``` is ```multipart/form-data```
We could need to set it to another value (ex. ```multipart/related```), so i propose to set it writable

**Usage**
```
Alamofire.upload(multipartFormData: { mulitFormData -> Void in
        mulitFormData.contentType = "multipart/related; type=text/xml; boundary=\(mulitFormData.boundary)"
}, to: "https://example.com",
        method: .post,
        encodingCompletion: { encodingResult -> Void in
})
```
  this prints header information to STDERR instead of STDOUT making it possible to process response body using pipes (e.g. decode gzip or apply JSON pretty print) Fixed the tests for this update. Looks like the remaining fails are travis configuration issues  when calling Alamofire.download(url), return "FAILURE: responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.inputFileReadFailed(file:....."

code:
  Alamofire.download("https://httpbin.org/image/png").responseData { response in
            print(response)
            if let data = response.result.value {
                if let image = UIImage(data: data) {
                    print(image)
                }
            }
        } Xcode 8.3  Sir, how to make mehod get Alamofire with Oauth1 for get data API ?

  when im try to upload local video to server via AssetURl im facing this issue 
![screen shot 2017-04-07 at 2 08 11 pm](https://cloud.githubusercontent.com/assets/8521060/24804588/858c050e-1bcc-11e7-8359-bbc8bb6dfe96.png)
  Alamofire generates `Accept-Language` headers using the `preferredLanguages` property of `Locale`, which is a combination of the language and the region.

This works well for standard combinations: `en-US`, `fr-FR`, `fr-CA`...

However, if the user chooses a language that does not match the region, we get a combination that cannot be used as `Accept-Language`.

For example, take a device configured with the following combination:

- Language: French
- Region: United-States

The first `preferredLanguages` is then `fr-US`, which does not represent a real language (there is not a specific version of the French language used in the US).

Thus, the generated `Accept-Language` contains a value that will not be recognised in many cases. [Here is a list of valid codes](http://www.metamodpro.com/browser-language-codes). 

On a French/United-States device, Alamofire generates the following `Accept-Language`: `fr-US;q=1.0, en-US;q=0.9`
It is not properly recognised by [this PHP function](http://php.net/manual/en/locale.acceptfromhttp.php), that tries to find out the best available locale. It will return `en` instead of `fr`.

By contrast, Safari iOS makes sure to send a valid `Accept-Language`:

On a French/United-States device, the sent `Accept-Language` is `fr-fr`. (Here is a [quick way](https://www.whatismybrowser.com/detect/what-http-headers-is-my-browser-sending) to know the HTTP Headers sent by a browser).

Ideally, Alamofire should generate the same `Accept-Language` as Safari.


- Xcode version: 8.2.1
- iOS version: iOS 10 I cannot find an official list either. I guess Safari has its own list of acceptable combinations. üòï  Hello. I am using Alamofire code for uploading youtube video. Everything works fine. But suppose if while uploading, I switch off my net, my uploading stops but does not give me any error in response. I am posting my code below:
```swift
alamoFireManager.upload(multipartFormData: { (MultipartFormData) in
    let snippetValueDictionary = requestType.params
    let statusValueDictionary = ["privacyStatus":"private"]
    
    let videoMetaDictionary = ["snippet":snippetValueDictionary,"status":statusValueDictionary]
    
    do{
        let json = try JSONSerialization.data(withJSONObject: videoMetaDictionary, options: JSONSerialization.WritingOptions.prettyPrinted)
        
        MultipartFormData.append(json, withName: "snippet", mimeType: "application/json")
    }
    catch{
        
    }
    
    MultipartFormData.append(localVideoURL, withName: "video", fileName: "video.mp4", mimeType: "application/octet-stream")
    
    
}, to: urlYoutube, method: .post, headers: requestType.headers, encodingCompletion: { (result) in
    switch result {
    case .success(let upload, _, _):
        upload.uploadProgress(closure: { progress in
            
            print("Upload Progress: \(progress.fractionCompleted)")

        }).validate().responseJSON(completionHandler: { dataResponse in
            
            if dataResponse.result.error != nil {
                print("Error Description: \(dataResponse.result.error?.localizedDescription)")
                
            }
            else {
                let json = JSON(dataResponse.result.value!)
                print(json)
            }
        })
    case .failure(let encodingError):
        print(encodingError)
        
    }
})
```
When I switch off my net, the uploading stops. When I switch it back on, the uploading restarts again and upload progress is called. When the internet is not available while data is being uploaded, I need some error in response so that user is informed about network! Can you please suggest what I may be doing wrong here? Yes I was using a background session and I found this line in Apple Docs which states:
**"Upload and download tasks in background sessions are automatically retried by the URL loading system after network errors. It is unnecessary to use reachability APIs to determine when to retry a failed task"**
[](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/URLLoadingSystem/Articles/UsingNSURLSession.html)
So the behavior that we are getting from Alamofire when there in no network while running upload task with background session is correct! [https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/URLLoadingSystem/Articles/UsingNSURLSession.html](url)  When will it support swift 3.1?  Hi all,

We are exchanging JSONs between our iOS app and the Exchange web service using an NTLM protocol and one of my client has a very interesting scenario. Here's the problem : 

One of the HTTP POST operations takes just too long to complete and the timeout, which is set on the client to be 45sec, simply exceeds. As a result, the .failure handler triggers and we present "System is not available at the moment" message. This is ok, but is only partly true, because the system IS de-facto available, it's only not available for that specific POST operation, during that timeframe - hence the message. Our message really confuses them! 

The question is how can we differentiate this specific situation from the other calls which will complete successfully during the given period? I.e. how can we detect when the authentication to the NTLM web service succeeds but the afterwards operation fails because of the timeout? What handlers/validation combo can we use and in what way? I guess simply rising the timeout (or completely turning it off) wouldn't be appropriate because we DO need to detect if the system is REALLY unavailable (i.e. all operations).

Please help! If you have any ideas, or even Swift examples, that would be much appreciated.

Thanks,
Bratislav  It fixes the issue #2052. There is a bug with the reachability computation when the user has a sim but s/he didn't select the carrier yet. In this scenario we have both `.connectionRequired` and `.isWWAN`. I think CI for watchOS has some issues @jshier  @jshier can you rerun the tests please? They pass locally so it seems an odd failure. @jshier is this PR under review? Or Don't you want it merged?  `self[task]` [is guarded a few lines above to not be `nil`](https://github.com/Alamofire/Alamofire/blob/b03b43cc381ec02eb9855085427186ef89055eef/Source/SessionDelegate.swift#L454) (and captured in `request` variable), so [checking again whether it is `nil` a few lines later](https://github.com/Alamofire/Alamofire/blob/b03b43cc381ec02eb9855085427186ef89055eef/Source/SessionDelegate.swift#L465) is confusing because it suggests that it could be `nil`, which cannot be the case however.

This is based on the assumption that [validations run a few lines above](https://github.com/Alamofire/Alamofire/blob/b03b43cc381ec02eb9855085427186ef89055eef/Source/SessionDelegate.swift#L460) do not set the delegate of the `request` to `nil`. Rebased on latest master.  In URLProtocolTests.swift, `URLProtocolTestCase.testThatURLProtocolReceivesRequestHeadersAndSessionConfigurationHeaders` fails with:

- [`XCTAssertEqual failed: ("nil") is not equal to ("Optional("foobar")")`](https://github.com/Alamofire/Alamofire/blob/master/Tests/URLProtocolTests.swift#L166)
- [`XCTAssertEqual failed: ("nil") is not equal to ("Optional("foo")")`](https://github.com/Alamofire/Alamofire/blob/master/Tests/URLProtocolTests.swift#L170)

Configuration:
- Xcode 8.3 ((8E162)
- iPhone SE sim with iOS 10.3
 Just discovered the PR #2025 that seems to tackle this very problem.  when i start one or more download tasks, my app stuck.And my app come back to normal until download tasks finished.How can i solve it?Xcode8.3 and swift3.1 Thanks for your reply!I solved the problem. I check local files in function task.downloadProgress closure,that cause my app stuck.  I have an xcode 7 , iOS 9 based app (that has been working on iOS10) which uses Alamofire 3.0. I've just recently submitted the app to the app store and it got rejected because of Apple's IPv6 test using iOS 10.3. Basically they were unable to load the app. My question is if Alamofire 3.0 supports IPv6 wireless networks? I'm just curious why this issue just popped up. I would rather not upgrade this app to work with xcode 8 and update all the libraries at this point because the app is essentially done and upgrading to use all the latest libraries, etc, would be a nightmare. Has anyone heard of this problem lately with iOS 10.3? Thanks for the feedback!

      From: Jon Shier <notifications@github.com>
 To: Alamofire/Alamofire <Alamofire@noreply.github.com> 
Cc: u84six <sea11side@yahoo.com>; Author <author@noreply.github.com>
 Sent: Saturday, April 1, 2017 5:43 PM
 Subject: Re: [Alamofire/Alamofire] Alamofire 3.0, IPv6, and iOS 10.3 (#2053)
   
Alamofire fully supports IPv6, just like the underlying frameworks. When this comes up it's usually something along the lines of 1) a reachability check performed before requests failing, which is an antipattern and should be removed, 2) misconfiguration of the reachability API (make sure to use just your domain name, no scheme), or 3) the API endpoints you're talking to not supporting IPv6 themselves. Also, AFAIK, there are no changes in this regard for iOS 10.3.In the future, you should open questions like this on Stack Overflow and tag alamofire.Cheers. üçª From our Contribution Guidelines
Asking Questions
We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on Stack Overflow instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.‚Äî
You are receiving this because you authored the thread.
Reply to this email directly, view it on GitHub, or mute the thread.  

     I'm using the latest version of `NetworkReachabilityManager` in a my project and I have a problem when `SCNetworkReachabilityFlags` contain both `.isWWAN` and `.connectionRequired`. I noticed that other libraries check if the flags contain `.connectionRequired` and if it's true they throw a not reachable network. Therefore, I'm wondering why NetworkReachabilityManager doesn't do it. Is it a bug or a wanted behaviour?

You debug this scenario when you have a device with a sim but the user didn't select the carrier yet. @jshier I could have a possible fix for that. Should I create a PR or are you working on it? https://github.com/Alamofire/Alamofire/pull/2060 Ready for review üëç  I tested the change to reachability computation on a device running 10.3.1 today and all seemed to work well.  Is there a timeframe to when this will be added or is this still under review?

Here is a link to the Gist I created to test this branch: https://gist.github.com/agnosticdev/b2c7af87fc90adb1fe87e0e203634d51  Hello,

How do I send a custom type array, not knowing the amount of objects contained in the array?

* I need to send by parameter

Exemple:

class func sendExecutors(solicitation: Solicitation, executors: [Executor]) {
        UIView.showLoading()
        
        let userDefaults = UserDefaults.standard
        if let credentials = userDefaults.value(forKey: UserDefaultsKeys.credentials.rawValue) as? [String: String] {
            
            let parameters: Parameters = ["email": credentials["email"]!, "senha": credentials["password"]!, "solicitacao": solicitation.solicitationID!, "executores": executors]

            
            Alamofire.request("", method: .post, parameters: parameters).validate().responseJSON { response in
                print(response.request)
                if let data = response.result.value {
                    let json = JSON(data)
                    if json["sucesso"].int! == SolicitationActionCode.accept.rawValue {
                        UIView.removeLoading()
                        print("aceitado")
                        
                        //callback(true)
                    } else {
                        UIView.removeLoading()
                        print("n√£o aceitado")
                        
                        //callback(false)
                    }
                } else {
                    UIView.removeLoading()
                    print("Error-> \(response.result.error)")
                    //callback(false)
                }
            }
            
        }
    }
  Alamofire seems to doesn't work with the last version of Xcode.
I get this error message : Module compiled with Swift 3.0.1 cannot be imported in Swift 3.1
Help ;-) This likely duplicates Issue https://github.com/Alamofire/Alamofire/issues/1753 Removing the DerivedData folder didn't solved my issue... Any idea ? Thanks!
Edit: I downloaded the source code, compiled the iOS version. Removed the .framework of my project and replaced with the new one. Cleaned the project. Works again! Try to do "git clean -d -x -f" and build again. It works for me  let smsUrl = NetworkInfoManager.sharedInstance.app_base_url + "api/v1/sms/\(verificode!)/reg"
        print(NetworkInfoManager.sharedInstance.headers)
        
        let headers: HTTPHeaders = ["Authorizationaaa": "123456"]
        Alamofire.request(smsUrl, method: .post, parameters: smsParams, headers: headers).responseJSON { (response) in
            
            print((response.response?.allHeaderFields)!)
            debugPrint(response)
        }



[AnyHashable("Content-Type"): application/json;charset=utf-8, AnyHashable("Server"): Jetty(6.1.5), AnyHashable("Transfer-Encoding"): Identity]
[Request]: POST http://192.168.31.66:8104/api/v1/sms/18868100541/reg
[Response]: <NSHTTPURLResponse: 0x608000436a80> { URL: http://192.168.31.66:8104/api/v1/sms/18868100541/reg } { status code: 200, headers {
    "Content-Type" = "application/json;charset=utf-8";
    Server = "Jetty(6.1.5)";
    "Transfer-Encoding" = Identity;
} }
[Data]: 44 bytes
[Result]: SUCCESS: {
    m = "\U975e\U6cd5APP\Uff0c\U6ca1\U6709\U6743\U9650";
    r = "-200001";
}
[Timeline]: Timeline: { "Request Start Time": 512561463.155, "Initial Response Time": 512561463.331, "Request Completed Time": 512561463.331, "Serialization Completed Time": 512561463.332, "Latency": 0.175 secs, "Request Duration": 0.176 secs, "Serialization Duration": 0.000 secs, "Total Duration": 0.176 secs }
 ËØ∑Ê±ÇÊó∂ËÆæÁΩÆÂ§¥‰ø°ÊÅØÔºåËÆæÁΩÆ‰∏çËøõÂéª  I use multipartFormData.append(URL, withName: "file") to upload a video to server but i've got that error msg : multipartEncodingFailed(Alamofire.AFError.MultipartEncodingFailureReason.bodyPartFileNotReachableWithError(file:///var/mobile/Media/DCIM/100APPLE/IMG_0939.mp4, Error Domain=NSCocoaErrorDomain Code=257 "The file ‚ÄúIMG_0939.mp4‚Äù couldn‚Äôt be opened because you don‚Äôt have permission to view it." UserInfo={NSURL=file:///var/mobile/Media/DCIM/100APPLE/IMG_0939.mp4, NSFilePath=/var/mobile/Media/DCIM/100APPLE/IMG_0939.mp4, NSUnderlyingError=0x174450d10 {Error Domain=NSPOSIXErrorDomain Code=1 "Operation not permitted"}}))
I have open that  Privacy - Photo Library Usage Description  but i got this error and I don't have any idea ,Please help me,Thanks  a lot!

  The charset is needed to make sure, that the server uses the correct charset for decoding. +1, URLEncoding.default already uses `application/x-www-form-urlencoded; charset=utf-8`  Let's say we got a server with audio files and we need to download one of the folders with 5 audio files in it. How can we do this in a single .download() request? Thanks!  The markdown in the Manual Installation section had an error that messed up the formatting of command and regular text. This commit fixes it.

I know this is a simple PR; but I am excited because this is my first one!  Hi, I got problem with my http request
If I use like this every thing look ok .
here code:
let parameters: Parameters = ["log_old":"xxx", "log_new":"xxx"]
Alamofire.request(url, method: .post, parameters: parameters, encoding: JSONEncoding.default)

but, when I need to send some thing in header
here code:
let headers: HTTPHeaders = [
            "Content-Type": "application/x-www-form-urlencoded",
            "log_token": xxx]
let parameters: Parameters = ["log_old":"xxx", "log_new":"xxx"]
Alamofire.request(url, method: .post, parameters: parameters, encoding: JSONEncoding.default, headers: headers)

My server can get headers value, But missing all of parameters like not send parameters out.

I re-check many time. I really send not nil parameters. I check by remove headers: headers in Alamofire.request my server can read parameters, and if I add headers my server can get only headers and missing parameters.

pls help. Thank you. @coredore  you can run test case on that and verify does actually alamofire is setting everything or not , following is a sample test case which i copied from [Alamofire Test cases](https://github.com/Alamofire/Alamofire/blob/master/Tests/RequestTests.swift)  , you can take this as reference and create your own test case and let me know  does your test case is passing or not 

```swift
func testRequestClassMethodWithMethodURLParametersAndHeaders() {
        // Given
        let urlString = "https://httpbin.org/get"
        let headers = ["Authorization": "123456"]

        // When
        let request = Alamofire.request(urlString, parameters: ["foo": "bar"], headers: headers)

        // Then
        XCTAssertNotNil(request.request)
        XCTAssertEqual(request.request?.httpMethod, "GET")
        XCTAssertNotEqual(request.request?.url?.absoluteString, urlString)
        XCTAssertEqual(request.request?.url?.query, "foo=bar")
        XCTAssertEqual(request.request?.value(forHTTPHeaderField: "Authorization"), "123456")
        XCTAssertNil(request.response)
    } you should use `URLEncoding.queryString`, not `JSONEncoding.default`  HiÔºå
i have some  issues with  Instruments leaks .i just get some data with requests using alamofire,and i found some leaks.Please help ,thanks
xcode Version 8.2.1
swift3.0

![qq20170327-180719](https://cloud.githubusercontent.com/assets/2148888/24351451/41d921e6-1318-11e7-94f4-df7b38b4e914.png)

 ![screen shot 2017-03-30 at 17 44 54](https://cloud.githubusercontent.com/assets/13499785/24510052/bd9d94ce-1570-11e7-9faf-ba07acbd68b7.png)
 HiÔºå
Even I'm also facing same leak in instruments. I have created some sample project to check the leak. just added a sample request from alamofire documentations only 

Alamofire.request("https://httpbin.org/get").responseJSON { response in
    print(response.request)  // original URL request
    print(response.response) // HTTP URL response
    print(response.data)     // server data
    print(response.result)   // result of response serialization

    if let JSON = response.result.value {
        print("JSON: \(JSON)")
    }
}
<img width="1025" alt="memory_leak" src="https://cloud.githubusercontent.com/assets/12713560/24579865/931f1fb8-171b-11e7-9819-3a23ecf918b1.png">


xcode Version 8.2.1
swift3.0 @jshier   i just added a sample request like @Afsarunnisa ,and it do appear memory leak in xocde8.2.1/swift3.0

But i retest using xcode8.3/swift3.1,it look much better.they didn't appear again.
Ok,If they do appear,i will contact you again.
  I'm building a wrapper around my API where pagination happens on a request by just changing the `page=<page_number>` on the URL parameters. Ideally the wrapper should paginate somewhat like this 

```
let sessionManager = SessionManager()
sessionManager.adapter = someAdapter

let searchRequest = sessionManager.request(SomeRouter.search(query))
searchRequest.responseCollection(){ // do something here }

// When the user wants the next page results he can just do
searchRequest = searchRequest.next()
searchRequest.responseCollection(){ // do something here }
```

I've tried subclassing DataRequest but the initialiser has internal enum references. Modification of the URLRequest object is also not possible as it is a get only property. This is what I could come up with (somewhat a hackish solution)
```
enum PaginationError: Error {
    case notSupported
}

internal extension URL {
    internal func paramValue(forParam param: String) -> String? {
        guard let urlComponents = URLComponents(url: self, resolvingAgainstBaseURL: false) else { return nil }
        
        return urlComponents.queryItems?.first(where: { $0.name == param })?.value
    }
}

public extension Alamofire.DataRequest {
    public func nextPage(sessionManager: SessionManager) throws -> Alamofire.DataRequest {
        guard let request = self.request,
            let url = request.url,
                let currentPageString = url.paramValue(forParam: "page"),
                    let currentPage = Int(currentPageString) else {
            throw PaginationError.notSupported
        }
        
        let nextPage = currentPage + 1
        let nextPageURL = URL(string: url.absoluteString.replacingOccurrences(of: "page=\(currentPage)", with: "page=\(nextPage)"))!
        
        var newRequest = request
        newRequest.url = nextPageURL
        
        return sessionManager.request(nextPageURL, method: HTTPMethod(rawValue: request.httpMethod!)!)
        
    }
}
```
And calling the next function requires the sessionManager to be passed in which looks a bit ugly.

Is there some other way which is more elegant? I would have been a piece of cake if the Request object had a reference to the URLRequestConvertible and someway to update the URLRequest object in Request.
  Below is my code let me know can't we done background upload with Data.is it mandatory to have filepath.      


  let configuration = URLSessionConfiguration.background(withIdentifier:bundleIdentifier)
        configuration.timeoutIntervalForRequest = 200 // seconds
        configuration.timeoutIntervalForResource = 200
        let alamoFireManager = Alamofire.SessionManager(configuration: configuration)

   sessionManager?.upload(data!, with: (uploadRouter))
                .uploadProgress { progress in // main queue by default
                    print("Upload Progress: \(progress.fractionCompleted)")
                }.validate()
                .responseJSON { [weak self] response in
}
 @jshier  thanks for the reply . I did not understand your answer fully. can we use Data for background uploads with NSURLSession.  I'm trying to upload a file to S3 using a pre-signed request. I got it to work in curl with:
```bash
curl -v -T video.mp4 "http://<myBucket>.s3.amazonaws.com/video.mp4?AWSAccessKeyId=<myAccessKey>&Expires=1492187347&Signature=vpcUnvGALlVXju31Qk2nXNmBTgc%3D"
```

and I'm trying to do the same with AF.

```swift
let videoPath = Bundle.main.path(forResource: "media", ofType: "mov")!
let videoUrl = URL(fileURLWithPath: videoPath)
Alamofire.SessionManager.default.session.configuration.httpAdditionalHeaders = [:]
let presignedUrl = "http://mettavr.s3.amazonaws.com/dev/test-upload/grey.mp4?AWSAccessKeyId=AKIAJSRDI3YY6MHZDGGA&Expires=1492188361&Signature=qr4C0TWGN2Vx7kMWygiTTHA8%2F5A%3D"
// I also tried with decoded URL parameters
request = Alamofire.upload(videoUrl, to: presignedUrl, method: .put, headers: [:])
request.responseString(completionHandler: { response in
  print(response)
})
request.resume()
```

This fails (it gets a response that is an error message) with

    The request signature we calculated does not match the signature you provided. Check your key and signing method.

I don't really understand what's happening. I've read a few posts that mention that there might be some headers that are set by AF that are unexpected by S3 but I'm not sure. I'm hitting the same issue. Cant find anything on stack overflow relating to this. Has a thread been started? Yup. after a few hours at it I managed to figure out what it was. Namely, I needed to pass in a blank content-type for S3 to stop complaining.
If you are still after a fix, @gsabran, try manually passing ["Content-Type": " "] in the headers  Nodejs + Express as the backend, the backend URL as follow,

`router.get('/api/check/coupon/:coupon', function (req, res)...`

And I tried to send request like this 

```
Alamofire.request(httpServerPath + "/api/check/coupon/GOLDYEAR2017").responseJSON { ... }
```
however it throws 
jsonSerializationFailed(Error Domain=NSCocoaErrorDomain Code=3840 "Invalid value around character 0." UserInfo={NSDebugDescription=Invalid value around character 0.}))

My backend is never invoked.  urlRequest property of URLRequestConvertible is optional, so you have to unwrap it or make non-optional.    if Use parameters with JSONEncoding it returns response with string included as \t\t\n\t\n\t\t\n\t\n\t\t\n\t\n\t\t\n\t\t\t ?

how to handle this ? could you please provide your code or sample repo   Code :

      Alamofire.request(apiurl, method: .post, parameters: parameters, encoding: encoding, headers: headers).responseJSON { response in
            debugPrint(response)
            switch response.result {
            case .success(let data):
                var result:[String:Any] = data as! [String : Any]
                var temp:AnyObject = result["results"] 
            case .failure:
                ...
            }
        }


if the result is this :{"code":"10000","message":"OK","category":"info","results":{"carryOutCount":0,"cancelCount":0,"dayCount":0,"data":{"rows":[],"pageTools":{"pageSize":10,"startRow":0,"recordCount":0,"recordPage":0,"pageNo":1,"url":"","recordCountNo":0,"queryTotalCount":true},"total":0,"empty":true},"processingCount":0},"returnUrl":""}

the temp value will get a wrong value.

the correct value should be  {"carryOutCount":0,"canc.......}
but the true is  {"rows":[],"pageTools":......}

looke like "data" is a hot keyword  ?
  I trying to receive statusCode from my request for catching network errors, but statusCode is always nil. For example, if I ' ll disable internet connection, the response.debugDescription tells, that Error Domain=NSURLErrorDomain Code=-1009, but response.response?.statusCode still = nil. Here is my code:

           Alamofire.request(url, method: method, parameters: nil, headers: headers).responseJSON(queue: queue) { response in
                        
            switch (response.result)
            {
            case .success(let JSON):
                if success != nil { success!(JSON) }
                break
                
            case .failure(let requestError):
                printError(errorCode: response.response?.statusCode, errorDescription: requestError)
                if failure != nil { failure!(requestError) }
                break
            }
        }  **update**
i tried to with cocoapods but i get this when install
<img width="1280" alt="screen shot 2017-03-22 at 11 13 58 am" src="https://cloud.githubusercontent.com/assets/25347608/24181938/d24c044a-0ef0-11e7-9cd0-6df9b83b8c5e.png">


Hello sir

i just follow Manually step to add Almofire to my project 
so what next ? i dont get librabry in my project like OAuth 

nb : 

i dont follow this step because i dont understand

> Embedded Framework
> 
> Open up Terminal, cd into your top-level project directory, and run the following command "if" your project is not initialized as a git repository:
> 
> $ git init
> 
> 
> - Add Alamofire as a git [submodule](http://git-scm.com/docs/git-submodule) by running the following command:
> 
>   ```bash
> $ git submodule add https://github.com/Alamofire/Alamofire.git

can you explain more how to this step?

<img width="1280" alt="screen shot 2017-03-22 at 10 55 40 am" src="https://cloud.githubusercontent.com/assets/25347608/24181562/41792a4e-0eee-11e7-9b97-2d87cf9af22e.png">
  // MARK: - Convenience

func URLRequest(
    method: Method,
    _ URLString: URLStringConvertible,
    headers: [String: String]? = nil)
    -> NSMutableURLRequest
{
    let mutableURLRequest: _NSMutableURLRequest_

    if let request = URLString as? NSMutableURLRequest {
        mutableURLRequest = request
    } else if let request = URLString as? NSURLRequest {
        mutableURLRequest = request.URLRequest
    } else {
        **mutableURLRequest = NSMutableURLRequest(URL: NSURL(string: URLString.URLString)!)**
    }
__


 "https://test.com/sources/common_7eceaf80.zip\n\n\t\t\t\t"   this urlString will found nil while unwrapping an Optional value   How can I upload MultipartFormData with POST and with extra parameter? For example "year"=28  or something like that 
 let param = ["client":"my","years":28,"sex":"man"] as [String : Any]
"year" = 28 isnot String
Thanks!  ```swift
let request = Alamofire.request("https://www.google.com")
        
        
        DispatchQueue.global().asyncAfter(deadline: .now() + 20) {
            
            request.responseData { (response) in
                
                print("a")
                
                }.responseData { (response) in
                    
                    print("b")
            }
        }


```

There is a time difference between response callback and  http request finished 
 if not add delay code ,Whether there will be a network request completed before setting the callbackÔºü  This issue has been messing up my unit tests for months, and I only just realized what the cause of it is. Take the following snippet:
```
import Alamofire

let dispatchGroup = DispatchGroup()
let url = URL(string: "https://httpbin.org/get")!
let timeout = 5

dispatchGroup.enter()
request(url).response { response in
    print(response.timeline)
    dispatchGroup.leave()
}

let status = dispatchGroup.wait(timeout: .now() + .seconds(timeout))
print(status)
```
In the previous snippet, the completion handler should be called while the dispatch group is waiting, and the code should finish with a final output of `success` (as a simple network request shouldn't take 5 seconds).
Instead, what happens is that the handler isn't called until *after* the call to `wait` returns (as `timedOut`). This is because responses are handled [on the main thread by default](https://github.com/Alamofire/Alamofire/blob/ab07523ee93527e79e99037f1a2d596b30689016/Source/ResponseSerialization.swift#L115). `dispatchGroup.wait` is called before the response is handled and blocks the main thread, so the handler cannot complete until the timeout is over.

Also, the above code prints out the following timeline:
```
Timeline: { "Latency": 1.727 secs, "Request Duration": 1.728 secs, "Serialization Duration": 3.301 secs, "Total Duration": 5.028 secs }
```
Since the serialization duration is calculated as ending [when the timeline is instantiated](https://github.com/Alamofire/Alamofire/blob/ab07523ee93527e79e99037f1a2d596b30689016/Source/ResponseSerialization.swift#L98), delaying the completion handler skews the amount of time attributed to serialization.

So, two suggestions:

1. Schedule responses to be handled on the utility dispatch queue by default, which is [Apple's recommendation for network requests](https://developer.apple.com/library/content/documentation/Performance/Conceptual/EnergyGuide-iOS/PrioritizeWorkWithQoS.html).
2. Either change computation of the serialization duration so that it isn't defined as ending when the timeline is created, or create the timeline before the completion handler is called.

<hr>
Xcode version 8.2.1, targeting macOS 10.12. Thanks for the tip, that's what I'm doing now. The same problem occurs with XCTest expectations; that's what was causing problems for me originally. I only used groups to make the code snippet easier to run.

What about the bit about the response serialization timing? Is that intended behavior as well?  I used AFNetworking previously and I want change AFNetworking to Alamofire.

In AFNetworking, I can set the request serializer encoding like following:

```
self.requestSerializer = AFHTTPRequestSerializer()        
let cfEnc = CFStringEncodings.GB_18030_2000
self.requestSerializer.stringEncoding = CFStringConvertEncodingToNSStringEncoding(CFStringEncoding(cfEnc.rawValue))
```

How can I do that using Alamofire?  I am in the process of developing one iPhone application. Into that , I upload image / video to the server via multipart. Whenever i am on 3G/LTE/wifi network , it works smoothly . But when i am on EDGE network, it gives error message from server. Furthermore we managed to get server logs, From that we get to know that parameters for the request are not reaching to server when i try via EDGE network so that server gives error.

Here is Alamofire session manager code

```
let manager = Alamofire.SessionManager.default

        manager.session.configuration.timeoutIntervalForRequest = 60
        manager.session.configuration.allowsCellularAccess = true




       manager.upload(multipartFormData: {..})
```  Our project have used Alamofire, but i find some leaks when i use Instruments to test our project.  The same as: https://github.com/Alamofire/Alamofire/issues/1718
But it is crashing only in Objective-C project. 
Alamofire 4.4.0, installed via CocoaPods. 
The crash is throwing in 
<img width="622" alt="screen shot 2017-03-15 at 12 29 10 pm" src="https://cloud.githubusercontent.com/assets/18656835/23949620/986f90b2-0990-11e7-8c16-d9e2d064a862.png">

  Basically I created a php db

<img width="996" alt="2017-03-11 9 49 45" src="https://cloud.githubusercontent.com/assets/26345844/23823776/c26acf10-06a4-11e7-88a2-cc578739d039.png">

i followed a Xcode tutorial on youtube to code and change to 3 params instead of 5 however it shows

responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.inputDataNilOrZeroLength)

this is my code:

`
    let URL_USER_REGISTER = "http://192.168.1.30:8888/untitled/v1/register.php";
    
    @IBOutlet weak var textFieldEmail: UITextField!
    
    @IBOutlet weak var textFieldPassword: UITextField!
    
    @IBOutlet weak var textFieldConfirmPassword: UITextField!
    
    @IBOutlet weak var labelMessage: UILabel!
    
    @IBAction func button_SignUp(_ sender: Any)
    {
   
        
        let parameters: Parameters=[
            "sEmail":textFieldEmail.text!,
            "sPassword":textFieldPassword.text!,
            "sconfirmpassword":textFieldConfirmPassword.text!
            
        ]
        
        
        //Sending http post request
        Alamofire.request(URL_USER_REGISTER, method: .post, parameters: parameters).responseJSON
            {
                response in
                //printing response
                print(response)
                
                //getting the json value from the server
                if let result = response.result.value {
                    
                    //converting it as NSDictionary
                    let jsonData = result as! NSDictionary
                    
                    //displaying the message in label
                    self.labelMessage.text = jsonData.value(forKey: "message") as! String?
                }
        }
        
    }
    
    
    override func viewDidLoad()
    {
        super.viewDidLoad()

        // Do any additional setup after loading the view.
    }

    override func didReceiveMemoryWarning()
    {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
        
    }
`

the tutorial is this https://www.youtube.com/watch?v=08bvBgK3gcc
the php file i changed the params too.
i tried to sent a data through postman but there is no reply. I think thats where the problem is but i don't know how to fix it.

really need help for my project. Thank you beforehand.

  I have an RxSwift IOS app (Alamofire 4.2.0, Moya 8.0.1) which must connect to multiple home automation controllers - each having their own self-signed certificate (and no there's no way to enforce that my IOS app users install a trusted SSL cert).  According to the ATS documentation my configuration is correct so it's not an ATS issue.  I filed an issue with Moya and attempted several suggestions (e.g. ServerTrustManager) without any luck.

Here's the error message I get from Moya:

> underlying(Error Domain=NSURLErrorDomain Code=-1200 "An SSL error has occurred and a secure connection to the server cannot be made." UserInfo={_kCFStreamErrorCodeKey=-9806, NSLocalizedRecoverySuggestion=Would you like to connect to the server anyway?, NSUnderlyingError=0x61800005b3c0 {Error Domain=kCFErrorDomainCFNetwork Code=-1200 "(null)" UserInfo={_kCFStreamPropertySSLClientCertificateState=0, _kCFNetworkCFStreamSSLErrorOriginalValue=-9806, _kCFStreamErrorDomainKey=3, _kCFStreamErrorCodeKey=-9806}}, NSLocalizedDescription=An SSL error has occurred and a secure connection to the server cannot be made. @camcoding  ‰Ω†Â•ΩÔºåËØ∑ÈóÆËøô‰∏™ÈóÆÈ¢òËß£ÂÜ≥‰∫ÜÂêóÔºü  I am currently implementing Certificate pinning using the `ServerTrustPolicyManager`. 
Testing with invalid certificates I noticed that the error is always -999 "cancelled". As far as I know this error can also appear due to other reasons which are not an invalid or expired certificate.

I did not find a way to be sure that a request was cancelled because of an invalid certificate. I think it might be useful to either return a more specific error than -999 or throw a notification when this happens.  We published an App with both old and new SSL certificate, in the hope the transition would work smoothly. Things didn't went too well, the new certificate was never loaded (and no error message displayed).

While the root cause might be the invalid certificate, I believe we could have found it a month earlier by having a bit of logging in Alamofire ServerTrustPolicy method `ServerTrustPolicy.certificates(in bundle: Bundle)`. See below:

```
    public static func certificates(in bundle: Bundle = Bundle.main) -> [SecCertificate] {
        var certificates: [SecCertificate] = []

        let paths = Set([".cer", ".CER", ".crt", ".CRT", ".der", ".DER"].map { fileExtension in
            bundle.paths(forResourcesOfType: fileExtension, inDirectory: nil)
        }.joined())

        for path in paths {
            if
                let certificateData = try? Data(contentsOf: URL(fileURLWithPath: path)) as CFData,
                let certificate = SecCertificateCreateWithData(nil, certificateData)
            {
                certificates.append(certificate)
            }
        }

        return certificates
    }
```

So the bundle contains certificates, Alamofire wants to load them, fails and does not report an error. This function ought to be explicitly called, so shouldn't a log (or even a fatalError!) be expected? Instead, the error is sucked up and only appears much later (during actual network connections) as obscure "-999" error code. 

WDYT?  Currently, there is no way to create/append a MultipartFormBody with unknown size. The networking does not require this size. In fact, its only use in Alamofire seems to be deciding whether to encode into memory or a file.

Please make the size optional. If the (total) size of a MultipartFormData is unknown, you can always default to using files (which is safe).
A streaming interface (cf #1980) would not need to make even this decision. > If the (total) size of a MultipartFormData is unknown, you can always default to using files (which is safe).

You can even start assembling in memory, and switch to a file if the chunk grows too large. Please take a look at the PKMultipartInputStream project:

https://github.com/pyke369/PKMultipartInputStream  The different response types share certain characteristics, but do not conform to a shared protocol. This makes implementing helper methods for, say, error logging, unnecessarily hard.

I propose a protocol like this:

```swift
protocol AlamofireResponse {
    var request: URLRequest? { get }
    var response: HTTPURLResponse? { get }
    var error: Error? { get }
}

extension DefaultDataResponse: AlamofireResponse {}
extension DefaultDownloadResponse: AlamofireResponse {}
extension DataResponse: AlamofireResponse {}
extension DownloadResponse: AlamofireResponse {}
...
```

One that exposes `.data` for responses that have such a property would be useful as well.

Side note: `XResponse` and `DefaultXResponse` are not related? Why? I'm asking this here but it affects multiple issues: how can we track Alamofire's progress if you close all tickets, even if you accept them (for consideration)?  Alamofire can currently download data into memory (as `Data`) or into files. This can be undesirable overhead, for instance if we want to unzip, decrypt, or perform any other operation "on the fly".

Streams seem to be the way to go. There are two fundamentally different approaches:

 1. Take an `OutputStream` and write the received data into it.
 2. Provide an `InputStream` the caller can read the received data from.

I suspect that the second variant is nicer, but ymmv.

Alamofire should implement at least one approach to streaming response data (without saving it into a file in between). It seems that we can use `DataRequest.stream` to implement 1.
This feature is not documented in README.md!  As I [discovered during testing](http://stackoverflow.com/q/42644111/539599), `SessionManager.upload(multipartFormData:...)` uses the main queue for calling the completion handler. This is different from all other request functions, and confusing.

Also, it causes a deadlock if the main thread is running (and blocking the main queue).
I found this during testing, but it may also affect applications. Using `self.queue.sync` (cf. my [self answer](http://stackoverflow.com/a/42646559/539599)) *seems* to fix the issue, but I have no idea if that's a robust change -- hence this ticket. I'll have a look, thanks.

However, I still consider the inconsistent behaviour of Alamofire an issue. `update` [already uses](https://github.com/Alamofire/Alamofire/blob/25d8fdd8a36f510a2bc4fe98289f367ec385d337/Source/SessionManager.swift#L692) `self.queue.sync` a few lines above. How is that not prone to deadlocks as you describe? I see. The issue is that the completion handler may make another request, which may use `self.queue.sync` and promptly deadlock. Got it, thanks! what if the main queue needs to wait for the result in order to proceed? For example, I have a command line app, all it does is some kind of rest API calls, every time you run the command, you have to be sure about the outcome of the calls in order to properly quit the program. Also, IMHO, for a general purpose library like Alamofire, due to "best practice", users shouldn't use it in certain way is not an enough excuse for not providing the flexibility. Swift is a general purpose language, waiting for a async operation in main thread is not always a mistake. In some cases, that's the purpose. I agree. I guess we'd have to look into how XCTest expectations work, because when using them, all Alamofire opertions work as expected while the main thread waits. (I guess the trick is to take the main thread out of the main DispatchQueue and attach it at the end?)  Swift compiler Error **Cannot convert value of type 'URLSessionConfiguration' to expected argument type 'URLSession'** in **self.session = URLSession(configuration, didReceiveChallenge: delegate, completionHandler: nil)** line of code  I'm trying to use my Proxy for an API request that needs a specified IP.
To debug my issue, I'm requesting the IP from a webservice.

This is my current code:
```

    import UIKit
    import Alamofire
    
    class ViewController: UIViewController {
    
        var requestManager = Alamofire.SessionManager.default
        
        override func viewDidLoad() {
            super.viewDidLoad()
        }
        
        override func viewDidAppear(_ animated: Bool) {
            super.viewDidAppear(true)
            
            var proxyConfiguration = [NSObject: AnyObject]()
            proxyConfiguration[kCFNetworkProxiesHTTPProxy] = "http://xxx@eu-west-static-01.quotaguard.com" as AnyObject?
            proxyConfiguration[kCFNetworkProxiesHTTPPort] = "9293" as AnyObject?
            proxyConfiguration[kCFNetworkProxiesHTTPEnable] = 1 as AnyObject?
            
            let cfg = Alamofire.SessionManager.default.session.configuration
            cfg.connectionProxyDictionary = proxyConfiguration
    
            let ip = URL(string: "https://api.ipify.org?format=json")
            
            requestManager = Alamofire.SessionManager(configuration: cfg)
            requestManager.request(ip!).response { response in
                print("Request: \(response.request)")
                print("Response: \(response.response)")
                print("Error: \(response.error)")
                
                if let data = response.data, let utf8Text = String(data: data, encoding: .utf8) {
                    print("Data: \(utf8Text)")
                }
            }
        }
    }
```

The problem: the responsed IP is the same with or without the `proxyConfiguration`. Any help is very appreciated.

PS: physical device used. As you can read [here](https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md#asking-questions), this should be on Stack Overflow.  Im retrieving json from an html page does alamofire have a function that remove the html or what can you sugest.  Hi.

I'm experiencing an issue with Alamofire 4.4 when getting paginated results... What i'm doing is getting a list of objects with this call (which works fine for the first page)

```
        Alamo.request(items/list,
                          method:get,
                         parameters:param,
                          encoding: JSONEncoding.default,
                          headers: headers).responseJSON(queue: queue,
                                                         completionHandler: { response in ... }
```

The result of the call above would be paginated with a next url (with a cursor) to call and the first page results... So i'm calling it straight away as the url

```
        Alamo.request(items/list?cursor=cgD0xMADdd,
                          method:get,
                         parameters:param,
                          encoding: JSONEncoding.default,
                          headers: headers).responseJSON(queue: queue,
                                                         completionHandler: { response in 
                                                                      print(response.metrics?.taskInterval)
                          }
```

This second call sometimes acts very fast but sometimes can take up to a minute. Note that no other call to other APIs in the project is acting this way...  I also tried to remove the query params and adding them as `parameters` in the Alamo.request but did not work. 

Here the full metrics. Note that all delay is between (Request Start)  and (Request End). Can you help me?

```
(Start Date) 2017-03-03 00:23:15 +0000
(Duration) 59.880781 seconds
(End Date) 2017-03-03 00:24:15 +0000
(Fetch Start) 2017-03-03 00:23:15 +0000
(Domain Lookup Start) 2017-03-03 00:24:15 +0000
(Domain Lookup End) 2017-03-03 00:24:15 +0000
(Connect Start) 2017-03-03 00:24:15 +0000
(Secure Connection Start) 2017-03-03 00:24:15 +0000
(Secure Connection End) 2017-03-03 00:24:15 +0000
(Connect End) 2017-03-03 00:24:15 +0000
(Request Start) 2017-03-03 00:23:15 +0000
(Request End) 2017-03-03 00:24:15 +0000
(Response Start) 2017-03-03 00:24:15 +0000
(Response End) 2017-03-03 00:24:15 +0000
```


 Hi @jshier , 

Sure. Thanks for your response and sorry for the noise... I actually found the problem and maybe this can be improved on Alamofire as well... 

So the problem was related to the fact I was creating a request with an empty dictionary within  `parameters`... 

```
        self.sessionManager.request(url,
                          method:method,
                          **parameters: [:]**,
                          encoding: JSONEncoding.default,
                          headers: headers).responseJSON { response in ... }
```

This was adding an extra `Content-Length=2` header in the request which kept the load balancer waiting for these bytes (which where never coming). By removing `parameters: [:]` everything works smoothly... 

I just though you might want to investigate that. It's not actually a bug since I was misusing the library, so my bad, but it might be of your interest. Next time i'll use stackoverflow.

Thanks again.


  Hi! I was checking if I had any memory leaks with Instruments and I found that Alamofire is leaking an NSLock. I don't know if it has already been reported, but on the latest release (**4.4.0**) is still present. I have found it using the **4.3.0** and I have updated the pod to check if it was already fixed. The app it's on it's early stages, this happens with just a single GET request.

**The version of Xcode you're using:** 8.2.1
**The version of iOS or macOS you're targeting:** iOS 10.2 (14C89)
**The full output of any stack trace or compiler error:**

![screen shot 2017-03-02 at 13 00 02](https://cloud.githubusercontent.com/assets/8229382/23506639/844a50be-ff49-11e6-917c-fe4867718a3c.png)
![screen shot 2017-03-02 at 13 00 58](https://cloud.githubusercontent.com/assets/8229382/23506644/877b4324-ff49-11e6-83ee-9fab3aeb14dc.png)


  [SE-140 has landed](https://github.com/apple/swift-evolution/commit/1202af531896d3e1708708ff09e4f6dd91d43f47), however [Parameters still don't support proper Swift optionals](https://github.com/Alamofire/Alamofire/blob/65ac1c5f2d0b6ebf947be98c96586b0f8eef8a1b/Source/ParameterEncoding.swift#L45).

This needs to change in order to better leverage the type system and provide improved developer ergonomics. Parameters should be `[String: Any?]`, not `[String: Any]`
  Part of License is `See LICENCE for details' in README.

But It's not uncomfortable and unkind

I added LICENSE link.  `URL.appendPathComponent` is mutating; the example is set up to use the generating version `URL.appendingPathComponent`.  I am using Alamofire to download files into my iOS app and it works fine for smaller files (~1GB or less) but when I try to download anything larger it fails. It completes the entire download, gets to 100% and then throws the error:

> FAILURE: responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.inputFileReadFailed(file:///...))

Why is it failing on the large files?

Here is my code - I am using a sessionManager to allow for background downloads since the files are so large (there may be a better way to do this but I do not think it is related to this issue.):

    let destination: (URL, HTTPURLResponse) -> (URL, DownloadRequest.DownloadOptions) = { (temporaryURL, response) in 
    if let directoryURL = FileManager().containerURL(forSecurityApplicationGroupIdentifier: applicationGroup), let suggestedFilename = response.suggestedFilename {
        let filePath = directoryURL.appendingPathComponent("\(suggestedFilename)")
        return (filePath, [.removePreviousFile, .createIntermediateDirectories])
    }
    return (temporaryURL, [.removePreviousFile, .createIntermediateDirectories])
    }

    if self.reachability.isReachableViaWiFi {

    var request: DownloadRequest

    if let resumeData = resumeData {

        request = BackendAPIManager.sharedInstance.alamoFireManager.download(resumingWith: resumeData)
            .downloadProgress { progress in
                cell?.progressView.isHidden = false
                cell?.progressView.setProgress(Float(progress.fractionCompleted), animated: true)
        }
    } else {
        request = BackendAPIManager.sharedInstance.alamoFireManager.download(fileLocation, to: destination)
            .downloadProgress { progress in
                cell?.progressView.isHidden = false
                cell?.progressView.setProgress(Float(progress.fractionCompleted), animated: true)
        }
    }

    request.responseData { response in
        switch response.result {
            case .success( _):
                cell?.pctLabel.text = nil
                cell?.progressView.isHidden = true
                break;
            case .failure:
                print(response)
                resumeData = response.resumeData
        }
    }
    }


    class BackendAPIManager: NSObject {
    static let sharedInstance = BackendAPIManager()
    var alamoFireManager : Alamofire.SessionManager!

    var backgroundCompletionHandler: (() -> Void)? {
        get {
            return alamoFireManager?.backgroundCompletionHandler
        }
        set {
            alamoFireManager?.backgroundCompletionHandler = newValue
        }
    }

    fileprivate override init()
    {
        let configuration = URLSessionConfiguration.background(withIdentifier: "com.nw.fileDownload.background")
        configuration.timeoutIntervalForRequest = 14400 // 4 hours
        configuration.timeoutIntervalForResource = 14400
        self.alamoFireManager = Alamofire.SessionManager(configuration: configuration)
    }
    }    The string extension defined in `Tests/String+AlamofireTests.swift` is redundant since the 
Swift Standard Library provides `String(repeating: count:)` which accomplishes the same thing. 
  My project requires a different way of encode collection types:
let parameters: Parameters = ["foo": ["bar", 1, 2]]
my expectation is "foo=bar,1,2", not "foo[]=bar&foo[]=1&foo[]=2".

but URLEncoding is struct, so that i cannot override func queryComponents(fromKey key: String, value: Any) -> [(String, String)]

how can i change the encoding format?  I know this is more of an iOS 10.3 related difference in behavior but there is a change in 10.3 in the way Alamofire and other HTTPS based apps function when dealing with **self-signed certificates**. In 10.2, importing the CA Trust + Certificate on a device and trusting via a config profile allows for HTTPS requests to occur within an app without the need for any ATS exceptions. In 10.3 this same action does not work and results in the error: (kCFStreamErrorDomainSSL, -9813)

If switching a REST API call from a self-signed certificate to a host using a commercial cert, such as one generated by Let's Encrypt, the same code returns back expected data. This might pop up more once 10.3 is final. I have some sample code on github that works when running on 10.2 but does not work on 10.3 when installing the CA & Certificate. I also have a bug report open with Apple. At the moment the code is just trying to make sure it can get some response back from the server behind the cert, independent of performing any REST actions. Should I update once hearing more back from Apple? It looks like the trust is now "turned on" in iOS 10.3 builds in: Settings -> General -> About -> Certificate Trust Settings Once that was enabled for the certificate the code looks to be working!  Hi, I am adding Alamofire to my Xcode 8 project and everything works fine but when I start typing "Alamo.." there are no Alamofire related results in the autocompletion. Even if write Alamofire. (with the period at the end) there are still no autocompletion suggestions. I tried installing the framework via CocoaPods and manually and it didn't work both ways. I also tried adding the ($inherited) non recurisve to the Header Search Paths of my project but still without success. **I have imported Alamofire to my class!** 

Any help would be appreciated! Thanks in advance!  Added URL structure to Download File Destination example (lines 632 & 633) as required by Xcode  It was very confusing the me that `Request.authenticate` did not work for my application but I have to add the header by hand.

I propose the following interface:

```swift
enum BasicAuthMethod {
	case urlCredential, header
}

open func authenticate(
        user: String,
        password: String,
	method: BasicAuthMethod = .urlCredential
        persistence: URLCredential.Persistence = .forSession)
        -> Self
    {
	switch method {
		case .urlCredential:
		        let credential = URLCredential(user: user, password: password, persistence: persistence)
		        return authenticate(usingCredential: credential)
		case .header:
			// Build header using Request.authorizationHeader
			// Add it to the current request
	}
}
```

One might argue that the current implementation could be replaced with case `.header` since the version with credentials is already readily available as

```swift
.authenticate(URLCredential(user: _, password:, _))
```

but the above is backwards-compatible.  I have posted this on StackOverflow but we can't figure it out. In a nutshell:
- I have a singleton class that implements all network calls using Alamofire and AlamofireImage with caching
- AlamofireImage with caching is working like a charm with call backs to UIImageViews upon data received
- Alamofire POST/GET responseJSON calls have a 20 seconds (estimated) lag before they fire. If I debug, the lag does not occurr. If I press pause during the lag time, the app seems to be sitting on the main thread waiting for?

Here is an example, this log in function calls a proprietary API using HTTP GET. The API responds within 50ms when called using curl and when called by this call if you hit the login button twice. So the issue seems to be the first "cold" call to a specific URL.

```
func login(email:String, password:String, controller:UIViewController)   {
    ... url and parameters are set up here...
let task = Alamofire.request(url, method: .post, parameters: parameters, encoding: JSONEncoding.default, headers: nil).responseString
            { response in
                switch(response.result) {
                case .success(_):
                    if let json = response.result.value {
                        if let r = JSONDeserializer<Response<Session>>.deserializeFrom(json: json) {
                            if r.status == 200 {
                                switch r.content{
                                case let s as Session:
                                    self.session = s
                                    self.updateSession()
                                    NSLog("*** session %@ obtained", s.session_id)
                                default:
                                    NSLog("could not read the session payload!")
                                }
                            }
                            else {
                                // TODO do something about the error code
                                NSLog("session not obtained, error %d %@",r.status, r.error)
                            }
                        }
                    }
                case .failure(_):
                    NSLog("session not obtained, error %@",response.result.error as! String)
                }
                controller.reloadInputViews()
            }
        task.resume()
}
```


Here is my pod file
```
platform :ios, '10.0'

target "TeamMateiOS" do
  use_frameworks!
  pod "Koloda"
  pod 'FXKeychain'
  pod 'JSQMessagesViewController'
  pod 'ImagePicker'
  pod 'SwiftyJSON', :git => 'https://github.com/SwiftyJSON/SwiftyJSON.git'
  pod 'Alamofire'
  pod 'AlamofireImage'
  pod 'Alamofire-Synchronous'
  pod 'HandyJSON' 
  pod 'SwiftKeychainWrapper'
  pod 'Fabric'
  pod 'Crashlytics'
end
``` Thank you, indeed the problem is what I am passing as callback. I am using a reference to the UIViewController that initiated the call so that I can call reloadInputViews() and keep things agnostic. If I don't pass it, everything flies but the controller will never know the data is ready. I am going to switch to a completionhandler....  HI,
In my application I have several requests that can be started simultaneously. Some must be executed as quickly as possible. They should not be hampered by less important requests.
The ideal would be to be able to specify the QOS that one wants when one creates a request. It would also be necessary to be able to limit the bandwidth used by certain requests.
If I could find an example to do this with Alamofire it will help me üôÇ
  In the `README.md` the usage example for `POST Request with Parameters` doesn't include the parameter `method: .post`.

If the method is not included in the `request` it will default to `.get`  Hi,
this is the link to my question in stackOverflow. http://stackoverflow.com/questions/42340218/migrating-from-urlsession-to-alamofire-4-3-in-swift-3-encoding-issue

I am posting it here as I haven't got any reply there.

  I'm having this issue where Alamofire is using an incorrect authorization header when sending a request to my server.

The first time I use the username and password and everything works fine. Then if I change the username and password quickly and retry the request as a different user it completely fails. When I print the HTTP headers in the iOS console it is correct every time. But when my server prints the headers it's different then the headers I printed on the iOS console.

If I wait a couple of minutes before changing users it seems to work fine. But if I do it within a minute the authorization header that is printed on the iOS device is different then the one the server receives. So it's using the old authorization information not the new one.

Below is the code I'm using.

	func reloadData() {
		print("Reloading data!!")	
		let keychain = KeychainSwift()
		
		let email: String = keychain.get("email")!
		let password: String = keychain.get("password")!
		
		URLCache.shared.removeAllCachedResponses()
		
		let sessionManager = Alamofire.SessionManager.default
		sessionManager.session.configuration.requestCachePolicy = .reloadIgnoringLocalCacheData
		
		
		let loginString = String(format: "%@:%@", email, password)
		let loginData = loginString.data(using: String.Encoding.utf8)!
		let base64LoginString = loginData.base64EncodedString()
		
		print(base64LoginString)

		let headers: HTTPHeaders = ["Authorization": "Basic \(base64LoginString)"]

		

		sessionManager.request("http://IPHERE:3000/api/items", headers: headers).validate().responseJSON { response in
			switch response.result {
				
			case .success(let value):
				
				let json = JSON(value)
				print("JSON: \(json)")
				
				for item in json.array! {
					
					let title: String? = item["title"].stringValue
					self.titles.append(title!)
					self.colors.append(UIColor.blue)
				}

				self.tableView.reloadData()
				
			case .failure(let error):
				print ("My Error")
				print (error)
				let alertController = UIAlertController(title: "Error", message: "Error, please try again or contact support", preferredStyle: UIAlertControllerStyle.alert)
				let okAction = UIAlertAction(title: "OK", style: UIAlertActionStyle.default) { (result : UIAlertAction) -> Void in
				}
				alertController.addAction(okAction)
				self.present(alertController, animated: true, completion: nil)
			}
		}
	}

So if I call this function the first time it works fine. `base64LoginString` is correct and matches what the server receives. If I logout and enter a different users information, `base64LoginString` is different then the original which is correct and is expected. But that request when it gets sent to the server still has the old `base64LoginString` value instead of the new one. So the server returns the information for the first user even tho we are now logged in as the second user.

So somewhere between printing `base64LoginString` and the server receiving the request something fails. It's almost like it caches the headers or something, which doesn't make sense at all.

Also for reference I'm using Node, Express, and Passport.js to handle web requests and auth on the backend. Let me know if I can provide any more information to help out.  I was wondering if HTTP pipelining is supported in this framework or not? thx Posted a question to the stack instead  Looking at Alamofire for doing multi-part requests with potentially large data, I'm confused: why does it only support assembling everything in RAM or in a file?

Taking from `writeEncodedData(to:URL)`, I think something like this should do:

~~~swift
    /// Writes the appended body parts into the given output stream.
    ///
    /// This process is facilitated by reading and writing with input and output streams, respectively. Thus,
    /// this approach is very memory efficient and should be used for large body part data.
    ///
    /// - parameter stream: The stream to write the multipart form data into.
    ///
    /// - throws: An `AFError` if encoding encounters an error.
    public func writeEncodedData(to outputStream: OutputStream) throws {
        if let bodyPartError = bodyPartError {
            throw bodyPartError
        }

        self.bodyParts.first?.hasInitialBoundary = true
        self.bodyParts.last?.hasFinalBoundary = true

        for bodyPart in self.bodyParts {
            try write(bodyPart, to: outputStream)
        }
}
~~~

(Not compiled nor tested, so I post it in this form instead of a pull request for now.)

I would then bridge the `OutputStream` to a buffered `InputStream` and upload that one using one of the regular variants of `Alamofire.upload`.

Is there any fundamental issue with this that I'm overlooking? @cnoon Thanks for your elaborate response!

I thought that you'd rewire that `OutputStream` to an `InputStream` used for upload. But you are right, that's backwards; a better signature would be `func readEncodedData() throws -> InputStream` (name tbd). This could then be passed to `upload(InputStream)` or used by `upload(multipartFormData:)`.

I agree that it shouldn't be too hard to add this (isn't that what you always say before actually digging in? :'D). I'm tight on time right now, but I may look into it. Given that we may want this in our application, chances are I can develop it on company time even -- will have to check with the bosses, obviously. Quick draft. This is unnecessarily complicated by the fact that `InputStream` is not a protocol. \*sigh\*

```swift
public func readEncodedData() throws -> InputStream {
        if let bodyPartError = bodyPartError {
            throw bodyPartError
        }

        self.bodyParts.first?.hasInitialBoundary = true
        self.bodyParts.last?.hasFinalBoundary = true

        return MpfdStream(parts: self.bodyParts.map({ $0.bodyStream }))
    }

private class MpfdStream: InputStream {
    private var current: Int
    private var parts: [InputStream]

    init(parts: [InputStream]) {
        super.init(???) // Whatever do we do here?
        precondition(parts.count > 0)
        self.parts = parts
        self.current = 0
    }

    override func read(_ buffer: UnsafeMutablePointer<UInt8>, maxLength len: Int) -> Int {
        guard current >= 0 && current < self.parts.count else {
            return -1 // What is correct here?
        }

        var currentPart = self.parts[current]
        assert(currentPart.hasBytesAvailable) // otherwise we'd have moved the index on!

        let response = super.read(buffer, maxLength: len)

        if !currentPart.hasBytesAvailable {
            self.current += 1
        }

        return response
    }

    override var hasBytesAvailable: Bool {
        return current >= 0
                && current < self.parts.count
                && self.parts[self.current].hasBytesAvailable
    }

    // What else do we have to override?
}
```

Side note: what happens with the boundaries if I call `writeEncodedData` multiple times, but add parts in between? Looks like a potential bug to me. But then, all the streams will be consumed, anyway...  I am trying to call my HTTP post request with a JSON data object. I was told that I need to use upload method.

As I try to use the upload method.
Xcode auto complete shows
Alamofire.upload(<#T##data: Data##Data#>, to: <#T##URLConvertible#>)

When I try to

let fullURL = God.getFullURL(apiURL: self.apiUrl)
self.postData = try! JSONSerialization.data(withJSONObject: postData, options: JSONSerialization.WritingOptions.prettyPrinted)

Alamofire.upload(postData, fullURL).responseJSON { response in
self.responseData = response.result.value
}
I get an error

Cannot invoke 'upload' with an argument list of type '(Data, String)'
Check out
http://stackoverflow.com/questions/42113651/swift-3-0-alamofire-4-0-extra-argument-method-in-call/42122684#42122684

DONT CLOSE THE ISSUE WITHOUT RESOLVING AND RECOMMENDING CORRECTIONS. Your documentation is faulty. 

https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%204.0%20Migration%20Guide.md

Look at your migration guide for .POST, you recommned using upload. I for one don't see the docs saying that you can pass `String` as URL; you need to call `asURL`, if available. The compiler message is quite clear.

Less anger and entitlement would help a long way, too. Sorry to sound upset, my earlier question was closed with a very cryptic response. 

https://github.com/Alamofire/Alamofire/issues/1958 @jshier FWIW, "reading the code of the library itself" is exactly what documentation should save us from. While I take your point -- other developers can sometimes be expected to look at the code before posting an issue, just to be more constructive about it -- it's not a good response to a (hypothetical) concern about the documentation.

That said, I find the documentation of Alamofire quite good.  For exampleÔºöhttp://192.168.1.12:8013/api/materialSort?sort=[102, 98, 94, 96, 95, 97]    
 The inside of the array Spaces lead to attempt failed 



errorÔºöJSON could not be serialized because of error:
The data couldn‚Äôt be read because it isn‚Äôt in the correct format.  Getting a memory leak in Version 4.3.0 in DataTaskDelegate.
![screen shot 2017-02-22 at 3 20 34 pm](https://cloud.githubusercontent.com/assets/20050977/23237643/22df2c5a-f913-11e6-8939-1707e82d0f96.png)
![screen shot 2017-02-22 at 3 28 16 pm](https://cloud.githubusercontent.com/assets/20050977/23237767/afd56dae-f913-11e6-9481-c230a15f7ab8.png)
 Mac OS 10.12
Xcode Version 8.2.1
Cannot upload project right now... (( I ran it using Instruments Version 7.3.1.
Bug is not valid. Closing.   Hi,
This issue probably is not related to the Alamofire.
I posted it at SO (http://stackoverflow.com/questions/41862345/cfnetwork-crashes-app-if-urlrequest-timeout-then-user-authenticates-via-kerberos) but I could not get any answer.
So I was wondering if anyone has the same experience and can help me to resolve it.

**Problem**
I develop an enterprise iOS application that uses kerberos for authentication. I have a `timeoutInterval = 30` for each request. 
Authentication and url requests work just fine if user enters the password before the request timeout. 
If user enters the password 30 seconds after iOS prompts user to, CFNetwork crashes App next time that application calls a web service, as seen below. 

```
Date/Time:       2017-01-24T03:16:42Z
Launch Time:     2017-01-24T03:16:03Z
OS Version:      iPhone OS 10.0.2 (14A456)
Report Version:  104

Exception Type:  SIGSEGV
Exception Codes: SEGV_ACCERR at 0x68
Crashed Thread:  4

Thread 0:
0   libsystem_kernel.dylib               0x0000000189d8816c mach_msg_trap + 8
1   CoreFoundation                       0x000000018ad85cec __CFRunLoopServiceMachPort + 188
2   CoreFoundation                       0x000000018ad83908 __CFRunLoopRun + 1128
3   CoreFoundation                       0x000000018acb2048 CFRunLoopRunSpecific + 440
4   GraphicsServices                     0x000000018c735198 GSEventRunModal + 176
5   UIKit                                0x0000000190c85628 -[UIApplication _run] + 680
6   UIKit                                0x0000000190c80360 UIApplicationMain + 204
7   SampleiOSApp                   0x00000001000301bc main (AppDelegate.swift:15)
8   libdyld.dylib                        0x0000000189c945b8 start + 0

Thread 1:
0   libsystem_kernel.dylib               0x0000000189da6a88 __workq_kernreturn + 8
1   libsystem_pthread.dylib              0x0000000189e68db4 start_wqthread + 0

Thread 2:
0   libsystem_kernel.dylib               0x0000000189da6a88 __workq_kernreturn + 8
1   libsystem_pthread.dylib              0x0000000189e68db4 start_wqthread + 0

Thread 3:
0   libsystem_kernel.dylib               0x0000000189d8816c mach_msg_trap + 8
1   CoreFoundation                       0x000000018ad85cec __CFRunLoopServiceMachPort + 188
2   CoreFoundation                       0x000000018ad83908 __CFRunLoopRun + 1128
3   CoreFoundation                       0x000000018acb2048 CFRunLoopRunSpecific + 440
4   Foundation                           0x000000018b7c0b1c -[NSRunLoop(NSRunLoop) runMode:beforeDate:] + 300
5   Foundation                           0x000000018b7e160c -[NSRunLoop(NSRunLoop) runUntilDate:] + 92
6   UIKit                                0x00000001915fac7c -[UIEventFetcher threadMain] + 132
7   Foundation                           0x000000018b8be50c __NSThread__start__ + 1020
8   libsystem_pthread.dylib              0x0000000189e6b860 _pthread_body + 236
9   libsystem_pthread.dylib              0x0000000189e6b770 _pthread_start + 280
10  libsystem_pthread.dylib              0x0000000189e68dbc thread_start + 0

Thread 4 Crashed:
0   CFNetwork                            0x000000018b51ae60 std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<AuthenticationState::AuthInfoType, std::__1::unique_ptr<AuthenticationInfo, std::__1::default_delete<AuthenticationInfo> > >, void*>*> std::__1::__hash_table<std::__1::__hash_value_type<AuthenticationState::AuthInfoType, std::__1::unique_ptr<AuthenticationInfo, std::__1::default_delete<AuthenticationInfo> > >, std::__1::__unordered_map_hasher<AuthenticationState::AuthInfoType, std::__1::__hash_value_type<AuthenticationState::AuthInfoType, std::__1::unique_ptr<AuthenticationInfo, std::__1::default_delete<AuthenticationInfo> > >, AuthenticationState::AuthInfoTypeHasher, true>, std::__1::__unordered_map_equal<AuthenticationState::AuthInfoType, std::__1::__hash_value_type<AuthenticationState::AuthInfoType, std::__1::unique_ptr<AuthenticationInfo, std::__1::default_delete<AuthenticationInfo> > >, std::__1::equal_to<AuthenticationState::AuthInfoType>, true>, std::__1::allocator<std::__1::__hash_value_type<AuthenticationState::AuthInfoType, std::__1::unique_ptr<AuthenticationInfo, std::__1::default_delete<AuthenticationInfo> > > > >::find<AuthenticationState::AuthInfoType>(AuthenticationState::AuthInfoType const&) const + 0
1   CFNetwork                            0x000000018b516b90 AuthenticationState::updateState(HTTPResponseMessage*, _CFURLAuthChallenge*, _CFURLCredential const*, __SecTrust*) + 148
2   CFNetwork                            0x000000018b4f8724 HTTPProtocol::_protocolInterface_useCredential(_CFURLCredential const*, _CFURLAuthChallenge*) + 880
3   CFNetwork                            0x000000018b4f7008 ___ZN12HTTPProtocol19askAccountsForCredsEh_block_invoke_2 + 240
4   libdispatch.dylib                    0x0000000189c611c0 _dispatch_client_callout + 12
5   libdispatch.dylib                    0x0000000189c6cb24 _dispatch_block_invoke_direct + 372
6   CFNetwork                            0x000000018b5f2e98 RunloopBlockContext::_invoke_block(void const*, void*) + 32
7   CoreFoundation                       0x000000018acb19a8 CFArrayApplyFunction + 64
8   CFNetwork                            0x000000018b5f2d7c RunloopBlockContext::perform() + 132
9   CFNetwork                            0x000000018b5f40a4 MultiplexerSource::perform() + 308
10  CFNetwork                            0x000000018b5f3e10 MultiplexerSource::_perform(void*) + 60
11  CoreFoundation                       0x000000018ad86278 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 20
12  CoreFoundation                       0x000000018ad85bc0 __CFRunLoopDoSources0 + 520
13  CoreFoundation                       0x000000018ad837c0 __CFRunLoopRun + 800
14  CoreFoundation                       0x000000018acb2048 CFRunLoopRunSpecific + 440
15  CFNetwork                            0x000000018b49fcec +[NSURLConnection(Loader) _resourceLoadLoop:] + 332
16  Foundation                           0x000000018b8be50c __NSThread__start__ + 1020
17  libsystem_pthread.dylib              0x0000000189e6b860 _pthread_body + 236
18  libsystem_pthread.dylib              0x0000000189e6b770 _pthread_start + 280
19  libsystem_pthread.dylib              0x0000000189e68dbc thread_start + 0
```

My code for the request is as follows:

```
let manager = Alamofire.SessionManager.default
manager.retrier = RetryingManager()
let request: Alamofire.Request = manager.request(httpRequest as! URLRequestConvertible)
    .validate(statusCode: 200..<300)
    .validate(contentType: ["application/json"])
    .responseObject(queue: queue, completionHandler: {
        (response: DataResponse<T>) in

        if let JSON = response.result.value {
            DispatchQueue.main.async() {
                debugPrint("JSON: \(JSON)")
                // callback with the data
                completion(JSON, nil)
            }
        } else if let resultError = response.result.error {
            if resultError._code == NSURLErrorTimedOut {
                Alamofire.SessionManager.default.session.invalidateAndCancel()
            }
            var statusCode: Int?
            if let responseResult = response.response {
                statusCode = responseResult.statusCode
            }
            let errorMessage = WebServerErrorHelper.createErrorMessage(resultError: resultError, statusCode: statusCode ?? 0, serverData: response.data)

            DispatchQueue.main.async() {
                completion(nil, errorMessage)
            }
        }
    })
```

Here queue is a concurrent DispatchQueue and timeInterval is set as 30 for httpRequest. I do not have a clue how to solve the problem. Thanks in advance.
 Thanks @jshier and @cnoon for your responses.
Unfortunately, I am not able to find a solution. I send my comments below.

1. The only thing that I set is the `retrier`. I have a class that conforms to RequestRetrier and provides the retrying logic:

```
public class RetryingManager: RequestRetrier {

    private let (maxRetryCount, retryInterval) = Configuration.retryingParameters // (10, 1)
    public func should(_ manager: SessionManager, retry request: Request, with error: Error, completion: @escaping RequestRetryCompletion) {
        guard request.retryCount < maxRetryCount else {
            completion(false, 0)
            return
        }
        if let response = request.task?.response as? HTTPURLResponse, response.statusCode > 299, response.statusCode != 404 {
            completion(true, retryInterval) // retry after 1 second
        } else {
            completion(false, 0.0) // don't retry
        }
    }
}
```
I have a special case for 404 because the backend sends me 404 for cases that content is not present. Besides that there is nothing fancy here.
I already tried to have a singleton and set the `retrier` once but it did n't fix the crash.

Should I add cases to handle the Kerberos authentication timeout, here? 

I removed the retrying mechanism altogether but I still have the same crash.

2. You are right about `invalidateAndCancel()` it does not add any value so I removed it but it did not help.
3. Here I have a method to create the user-friendly error by checking `resultError._code` and `Data`.
4. responseObject is coming from AlamofireObjectMapper.

@cnoon Kerberos authentication is done at the iOS level. When application calls endpoints that are defined in the SSO profile, iOS asks for the user to enter the password for the profile. 
I cannot ask for username and password in the application because of security policies.

Problem boils down to: **It's something odd to do with the challenge being answered after the request has already timed out!**

Do I need to deal with `Alamofire.SessionManager.default.delegate.sessionDidReceiveChallenge` and 
`Alamofire.SessionManager.default.delegate.taskDidReceiveChallenge` somehow?  Why is a response that has a status code of 429 (throttling limit reached) getting categorized as a success?

Heres my environment:

- Xcode Version: `8.2.1 (8C1002)`
- MacOS Version: `10.12.3`
- iOS Version: `10.2`

```
let manager = Alamofire.SessionManager.default
manager.session.configuration.timeoutIntervalForRequest = NetworkHandler.timeout        
manager.request(urlRequest).responseJSON { response in
    switch response.result {
        case .success:
            //429 code response getting called in here
            
        case .failure(_):
            //429 code response should be called here
    }
}
```

Any ideas as to why this is happening?  I has run into this issue recently when the server include body message with status code 404. The message was supposed to give a nice feedback to the user who access via the browser.

With the below API, AlamoFire did save the content which later confuse the App to think that the file was successfully downloaded.

**Alamofire.download(urlRequest: URLRequestConvertible, to: DownloadRequest.DownloadFileDestination?)**

Of currently, we can check response.response?.statusCode and then delete the file if it existed. But I think that AlamoFire should not save or create file if the status code different than 200. Ok, may be some app need to save html 404 message when the link was not found or broken. I thought download mean to save only actual content to the destination file. Well, it just need to check and remove the file in the response callback. Thanks for the reply  Using Alamofire v4.3.0 for tvOS, I'm failing to export an ipa from an archive, with this error:

2017-02-17 16:27:31 +0000 [MT] Presenting: Error Domain=IDEFoundationErrorDomain Code=1 "Failed to verify bitcode in Alamofire.framework/Alamofire:
error: Cannot extract bundle from /var/folders/tf/trlj_nmd34n35gv0bbr13skj9vb2f5/T/XcodeDistPipeline.8wM/Root/Payload/...
  Hi, 
I am working with a Ibm Notes REST service, and doing a PATCH request as specified in the IBM documentation (https://www-10.lotus.com/ldd/ddwiki.nsf/xpAPIViewer.xsp?lookupName=IBM+Domino+Access+Services+9.0.1#action=openDocument&res_title=Document_PATCH_dds10&content=apicontent) documentation fails when using Alamofire to do the request.

I can get it to work using Swift  URLRequest object, but naturally I ¬¥d rather, if possible, use the Alamofire library to the REST calls.

It looks like the problem is in the format used to pass the parameters. At the end point IBM is expecting an string, instead of an object. Could the same thing that I am doing using the plain URLRequest object, be achieved using the Alamofire library?  

Request with Alamofire:
`let headers: HTTPHeaders = [
            "Content-Type": "application/json",
            "X-HTTP-Method-Override": "PATCH"
        ]
        
        let parameters: Parameters = [
            "Subject": "hallo"
        ]
        
        let url = "http://mydomain/mydb/mydb_tesT.NSF/api/data/documents/unid/DD026770D91AA23DC1257EF90035E1C4"
        
        Alamofire.request(url, method:.post, parameters:parameters, headers:headers).responseJSON { response in
            switch response.result {
            case .success:
                debugPrint(response)
                
            case .failure(let error):
                print(error)
            }
            
        } `

Request succesful using Swift 3 URLRequest:

`var request = URLRequest(url: URL(string: "http://mydomain/mydb/mydb_tesT.NSF/api/data/documents/unid/DD026770D91AA23DC1257EF90035E1C4")!)
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("PATCH", forHTTPHeaderField: "X-HTTP-Method-Override")
        
        
         request.httpMethod = "POST"
         let postString = "{\"Subject\":\"pete\"}"
         request.httpBody = postString.data(using: .utf8)
         let task = URLSession.shared.dataTask(with: request) { data, response, error in
         guard let data = data, error == nil else {                                                 // check for fundamental networking error
         print("error=\(error)")
         return
         }
         
         if let httpStatus = response as? HTTPURLResponse, httpStatus.statusCode != 200 {           // check for http errors
         print("statusCode should be 200, but is \(httpStatus.statusCode)")
         print("response = \(response)")
         }
         
         let responseString = String(data: data, encoding: .utf8)
         print("responseString = \(responseString)")
         }
         task.resume()
` +1  As title.  how can I add struct in parameters when uploading MultipartFormData:

let parameters = [
      "parameter1": "test1",
      "parameter2": "test2"]

    Alamofire.upload(multipartFormData: { multipartFormData in
            for (key, value) in parameters {
                multipartFormData.append(value.data(using: String.Encoding.utf8)!, withName: key)
            }
            multipartFormData.append(structObject, withName: "user")

          if let imageData = UIImageJPEGRepresentation(image, 1) {
          multipartFormData.appendBodyPart(data: imageData, name: "file", fileName: "file.png",      mimeType: "image/png")
        }
        }, to: url, encodingCompletion: { encodingResult in
            switch encodingResult {
            case .success(let upload, _, _):
                upload.responseJSON { response in
                    if let value = response.result.value as AnyObject?{
                        let json = JSON(value)
                    } else {
                        
                    }                    
                }
            case .failure(let encodingError):
                print(encodingError)
                
            }
        }
        )
 any help please , I want to send params like this : 
let parameters = [
    "foo": [1,2,3],
    "bar": [
        "baz": "qux"
    ]
]
but using alamofire.upload , because I have Images too that I  want to send  with params  After installing a new pod (not related to network) I get a ""Use of unresolved identifier 'JSONEncoding'" when building. I'm using Alamofire 4.3 and pod version is 1.1.1

`Alamofire.request(kTokenValidationURL, method: .post, parameters: parameters, encoding: JSONEncoding.default)`

I have cleaned the project, work directory, deleted Derived Data folder, restart xcode and computer and the problem persists.  Hi, can we have Alamofire as a binary download for carthage please  Really I just want to know if there is one cookie or no cookie. I'm 14 and i should really study right know, fast answer appreciated!

Thanks!  I'm using Alamofire 4.3.0 with swift 3.

Here's my code:

`self.apiserver.alamoFireManager!.download(f, method: .get, parameters: nil, encoding: JSONEncoding.default, to: destination)`

if i change to use:

`self.apiserver.alamoFireManager!.download(f, to: destination)`

Other error occurres: `Cannot invoke 'download' with an argument list of type '(String, to: (URL, HTTPURLResponse) -> (URL))'`

How do i solve it?
  @grantkemp can you please explain what fixed the issue. I am having same issue for below mentioned code

`   let destination: DownloadRequest.DownloadFileDestination = { _, _ in
            
            let documentsURL = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)[0]//FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
            let filepath = documentsURL.appending("/InvoicePDF.pdf")
            
            let fileURL = URL.init(fileURLWithPath: filepath, isDirectory: false)
            
            return (fileURL, [.removePreviousFile, .createIntermediateDirectories])
        }
     
        
        let request : DownloadRequest
        

        
        let utilityQueue = DispatchQueue.global(qos: .utility)

        request = Alamofire.download(url, to: destination)

        request.downloadProgress(queue: utilityQueue) { (progress) in
            SVProgressHUD.showProgress(Float(progress.fractionCompleted))
        }
        .responseData { (response) in
            switch response.result {
            case .success(let data):
                SVProgressHUD.popActivity()
                let documentURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
                let fileURL = documentURL.appendingPathComponent("InvoicePDF.pdf")
                
                do {
                    try data.write(to: fileURL)
                }
                catch {
                    print("Some thing went wrong")
                }
                self.presentDocumentControllerForPath(fileURL)
                
            case .failure(let error):
                Alerts.showOKAlertWithMessage(error.localizedDescription, andTitle: "Error")
                SVProgressHUD.popActivity()
            }
        }`   ```objc
//target: Alamofire.swift line 97
// MARK: - Convenience

func URLRequest(
    method: Method,
    _ URLString: URLStringConvertible,
    headers: [String: String]? = nil)
    -> NSMutableURLRequest
{
    let mutableURLRequest: NSMutableURLRequest

    if URLString.dynamicType == NSMutableURLRequest.self {
        mutableURLRequest = URLString as! NSMutableURLRequest
    } else if URLString.dynamicType == NSURLRequest.self {
        mutableURLRequest = (URLString as! NSURLRequest).URLRequest
    } else {
        mutableURLRequest = NSMutableURLRequest(URL: NSURL(string: URLString.URLString)!)
    }

    mutableURLRequest.HTTPMethod = method.rawValue

    if let headers = headers {
        for (headerField, headerValue) in headers {
            mutableURLRequest.setValue(headerValue, forHTTPHeaderField: headerField)
        }
    }

    return mutableURLRequest
}

```
in your code URLString fix some `"` `spage` not good example:

>https://bibleverse-d0859.firebaseio.com/v/1/books.json?orderBy="version_code"&equalTo="ASV"
>(lldb) po URLString
>"https://bibleverse-d0859.firebaseio.com/v/1/books.json?>orderBy=\"version_code\"&equalTo=\"ASV\""

>(lldb) po URLString.URLString
>"https://bibleverse-d0859.firebaseio.com/v/1/books.json?>orderBy=\"version_code\"&equalTo=\"ASV\""

and your code ` NSURL(string: URLString.URLString)! `view error  please not `!`

my english not good , hope you can understand  I am trying to call my HTTP post request with a JSON data object. I was told that I need to use upload method.

As I try to use the upload method.
Xcode auto complete shows
`Alamofire.upload(<#T##data: Data##Data#>, to: <#T##URLConvertible#>)`

When I try to
```swift
let fullURL = God.getFullURL(apiURL: self.apiUrl)
self.postData = try! JSONSerialization.data(withJSONObject: postData, options: JSONSerialization.WritingOptions.prettyPrinted)

Alamofire.upload(postData, fullURL).responseJSON { response in
self.responseData = response.result.value
}
```
I get an error

`Cannot invoke 'upload' with an argument list of type '(Data, String)'`
Check out
http://stackoverflow.com/questions/42113651/swift-3-0-alamofire-4-0-extra-argument-method-in-call/42122684#42122684 Guys, something wrong with your documentation. Must be fixed.

This works.
`            Alamofire.upload(postData!, to: fullURL, headers:nil).responseJSON { response in
                self.responseData = response.result.value`
 @jshier 

What do we use for post a object ?

What do you mean by "initial function call"

What do you mean by "generally incorrect".. ?? Your documentation from Alamofire 3 to 4 states that we should use `upload` for POST. Get your story straight.

Upload Request - Simple with URL string

```
// Alamofire 3
Alamofire.upload(.POST, urlString, data: data).response { request, response, data, error in
    print(request)
    print(response)
    print(data)
    print(error)
}

// Alamofire 4
Alamofire.upload(data, to: urlString).response { response in // method defaults to `.post`
    debugPrint(response)
}
```  Hello,

I'm using Alamofire 3.4.1 and I when an error occurred I need to get response content and header.

Is that possible in this version ?

Thank you for your work.  I'm trying to implement Alamofire in a Cocoa Touch Framework and use this framework in a different xCode project for reuse
I'm getting the following error: "linker command failed with exit code 1 (use -v to see invocation)"

reproduce steps:
1. creata a Cocoa Touch Framework project in xCode
2. pod init in the terminal
3. add pod 'Alamofire', '~> 4.3' to the Podfile
4. pod install in the terminal
5. open the xcworkspace and compile - build is success

6. create a Single View Application in xCode
7. compile - build is success
8. add the xcodeproj of the first project (I can't add the xcworkspace)
9. add the .framework file to the second project Embedded Binaries

10. compile - build is failed with the error

screen shot of error is here
![linker error](https://cloud.githubusercontent.com/assets/13539857/22695768/e11c8c18-ed19-11e6-8482-358a72e12810.png)

complete code is attached here
[Demo.zip](https://github.com/Alamofire/Alamofire/files/757978/Demo.zip)

I'm probably doing something wrong
please assist
 The trick is in generated xcworkspace, you should open and work from it, if you work with Cocoapods  I need to send in this format json:
`{
	"DocCont":[{
		"DocumentContent":"base64 string",
		"LeftEyeX":"String",
		"LeftEyeY":"String",
		"RightEyeX":"String",
		"RightEyeY":"String"
	}],
	"OrderId":"String",
	"Token":"String"
}`

I'm posting this is so:
`        let imgBase64 = imageData?.base64EncodedString(options: .lineLength64Characters)

let param: Parameters = ["DocCont": [
            ["DocumentContent": "\(imgBase64)",
                "LeftEyeX": "LeftEyeX",
                "LeftEyeY": "LeftEyeY",
                "RightEyeX": "RightEyeX",
                "RightEyeY": "RightEyeY"
            ]
            ],
                                 "OrderId": "myOrder",
                                 "Token": "myToken"
        ]
        
        let url = "\(MyVariables.url)/TaxiCreditRestService/OrderService.svc/SendScan"
        
        Alamofire.request(url, method: .post, parameters: param, encoding: JSONEncoding.default, headers: nil).responseJSON { response in
            switch response.result {
            case .success(let value):
                let json = JSON(value)
                print("Client error: \(json["Error"])")
                print("Client IsOK: \(json["IsOK"])")
            case .failure(let error):
                print("error send scans: \(error)")
            }
        }
`

But I get the error "Code = 3840" Invalid value around character 3. "
How do I solve this problem?   > @cnoon: closures captured as properties are `@escaping` by default

None of any properties were marked with `@escaping` (such as `sessionDidReceiveChallengeWithCompletion`), but parameters in them.

And for parameters there is implemented in Swift 3 proposal "[Make non-escaping closures the default](https://github.com/apple/swift-evolution/blob/master/proposals/0103-make-noescape-default.md)" :3

**Proof ‚Ññ1.**

Generated Objective-C code for `dataTaskDidReceiveResponseWithCompletion` property:
```obj-c
@property (nonatomic, copy) void (^ _Nullable dataTaskDidReceiveResponseWithCompletion)(NSURLSession * _Nonnull, NSURLSessionDataTask * _Nonnull, NSURLResponse * _Nonnull, SWIFT_NOESCAPE void (^ _Nonnull)(enum NSURLSessionResponseDisposition));
```

You can see `SWIFT_NOESCAPE` in closure parameter declaration.
This doesn't conforms to `URLSessionDataDelegate` protocol method `optional public func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive response: URLResponse, completionHandler: @escaping (URLSession.ResponseDisposition) -> Swift.Void)`


**Proof ‚Ññ2**

Create project that uses Alamofire and place this code instead of AppDelegate boilerplate.

```swift
import UIKit
import Alamofire

@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate, URLSessionDataDelegate {
    var window: UIWindow?

    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {
        self.testAlamofireEscaping()

        return true
    }

    func testAlamofireEscaping() {
        let sessionDelegate = SessionDelegate()
        sessionDelegate.dataTaskDidReceiveResponseWithCompletion = self.urlSession
        let _ = SessionManager(configuration: URLSessionConfiguration.default, delegate: sessionDelegate, serverTrustPolicyManager: nil)
    }

    // MARK: - URLSessionDataDelegate

    func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive response: URLResponse, completionHandler: @escaping (URLSession.ResponseDisposition) -> Swift.Void) {
        completionHandler(.allow)
    }
}
```

As we knows Swift allows to use instance methods as closures.
I have custom implementation of `URLSessionDataDelegate`.
But compiler throws error: `Cannot assign value of type '(URLSession, URLSessionDataTask, URLResponse, @escaping (URLSession.ResponseDisposition) -> Void) -> ()' to type '((URLSession, URLSessionDataTask, URLResponse, (URLSession.ResponseDisposition) -> Void) -> Void)?'`
With fixed version of `open var dataTaskDidReceiveResponseWithCompletion: ((URLSession, URLSessionDataTask, URLResponse, @escaping (URLSession.ResponseDisposition) -> Void) -> Void)?` it doesn't throw any error.

**Proof ‚Ññ3**

```swift
@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate, URLSessionDataDelegate {
    var window: UIWindow?

    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {
        self.testAlamofireEscaping()

        return true
    }

    var completionHandler: ((URLSession.ResponseDisposition) -> Void)!

    func testAlamofireEscaping() {
        let sessionDelegate = SessionDelegate()
        sessionDelegate.dataTaskDidReceiveResponseWithCompletion = { (session: URLSession, dataTask: URLSessionDataTask, response: URLResponse, completionHandler: ((URLSession.ResponseDisposition) -> Void)) in
            self.completionHandler = completionHandler
        }
        let _ = SessionManager(configuration: URLSessionConfiguration.default, delegate: sessionDelegate, serverTrustPolicyManager: nil)
    }

    // MARK: - URLSessionDataDelegate

    func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive response: URLResponse, completionHandler: @escaping (URLSession.ResponseDisposition) -> Swift.Void) {
        completionHandler(.allow)
    }
}
```

As we see there is `@escaping` attribute for `completionHandler` parameter in `URLSessionDataDelegate` `urlSession(_:dataTask:didReceive:completionHandler:)` signature.
So I can copy this handler in any variable I want.
`dataTaskDidReceiveResponseWithCompletion` closure signature doesn't have such attribute. So I can't copy this handler anywhere.
Compiler throws recoverable error `Assigning non-escaping parameter 'completionHandler' to an @escaping closure`
After fixing-up it throws new error `Cannot assign value of type '(URLSession, URLSessionDataTask, URLResponse, @escaping ((URLSession.ResponseDisposition) -> Void)) -> ()' to type '((URLSession, URLSessionDataTask, URLResponse, (URLSession.ResponseDisposition) -> Void) -> Void)?'`

With fixed version of `open var dataTaskDidReceiveResponseWithCompletion: ((URLSession, URLSessionDataTask, URLResponse, @escaping (URLSession.ResponseDisposition) -> Void) -> Void)?` it doesn't throw any error.

**Conclusion**

I think that there MUST be `@escaping` in closure parameters.
  Hi, 

I made a RequestRetrier that manage only the status code 401. But my problem is that I receive a body response from the server and I need to access to the data from the error response(This is a JSON that give the kind of error and some informations). Right now, I don't see any way to get the data  the RequestRetrier.

Is it possible to get the data from the requestRetrier?

Thank you I have a similar issue related to the request retrier. Some errors that needs retrying will have a 200 response code. Therefor we need to parse these in a custom response serializer.

However, errors returned from the response serialization will not be handled by the retrier and will result directly in a failure response. It would be great if we can get these errors in the retrier.

 Same problem Found out that with this i can get data, but it seems, that it do the request again
```
func should(_ manager: SessionManager, retry request: Request, with error: Error, completion: @escaping RequestRetryCompletion) {
guard let request = request as? DataRequest else { fatalError() }
        request.responseData { response in
          fulfill(response.data)
        }
}
```
 Suddenly it stops working (not entering the closure =( ) Use `request.delegate.data`  I having a strange issue, not sure if it is my fault or a real issue. Using the NetworkReachabilityManager, after each update a notReachable-flag gets fired about 0.01 - 0.04s later.

- Xcode version 8.2.1
- iOS target version 10.0 (in Podfile and Xcode)
- Tested on hardware 10.2.1 (iPhone SE) and emulators
- Alamofire version 4.3 (installed via pod today)

Am I doing something wrong?

View controller class:
```swift
import UIKit
import Alamofire

class MainViewController: UIViewController {
    
    var api_url: String = ""
    var reachability: NetworkReachabilityManager? = nil
    @IBOutlet weak var statusLabel: UILabel!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        registerSettingsBundle()
        api_url = getApiUrlFromSettingsBundle()
        pingHostForReachability(stringUrl: api_url)
        
    }

    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        
        // stop listening for reachability when view will disappear
        if let reachability = reachability {
            reachability.stopListening()
            NSLog("stopped listening for reachability")
        }
    }
    
    func registerSettingsBundle() {
        let appDefaults = [String:AnyObject]()
        UserDefaults.standard.register(defaults: appDefaults)
        UserDefaults.standard.synchronize()
    }
    
    func getApiUrlFromSettingsBundle() -> String {
        let defaults = UserDefaults.standard
        if let url = defaults.string(forKey: api_url_key) {
            return url
        }
        return String()
    }
    
    func pingHostForReachability(stringUrl: String) {
        NSLog("new reachability manager, listening @ \(stringUrl)")
        if reachability != nil {
            reachability?.stopListening()
        }
        reachability = NetworkReachabilityManager(host: stringUrl)
        reachability?.listener = { status in
            NSLog("Network Status Changed: \(status)")
            switch status {
            case NetworkReachabilityManager.NetworkReachabilityStatus.reachable(let connectionType):
                let type = connectionType.hashValue == 0 ? "WLAN" : "WWAN"
                self.statusLabel.text = "Status: Connected (via \(type))"
                break
            
            /*case NetworkReachabilityManager.NetworkReachabilityStatus.notReachable:
                self.statusLabel.text = "Status: No Connection"
                break
            case NetworkReachabilityManager.NetworkReachabilityStatus.unknown:
                self.statusLabel.text = "Status: Unknown"
                break*/
                
            default:
                self.statusLabel.text = "Status: No connection"
                break
            }
        }
        reachability?.startListening()
    }

}
```

Logs, switched between 3g and wlan:
```
2017-02-03 15:03:06.211886 app[752:117893] new reachability manager, listening @ http://google.de
2017-02-03 15:03:06.237435 app[752:117893] Network Status Changed: reachable(Alamofire.NetworkReachabilityManager.ConnectionType.ethernetOrWiFi)
2017-02-03 15:03:06.238725 app[752:117893] Network Status Changed: notReachable
2017-02-03 15:03:19.688307 app[752:117893] Network Status Changed: reachable(Alamofire.NetworkReachabilityManager.ConnectionType.wwan)
2017-02-03 15:03:21.736435 app[752:117893] Network Status Changed: notReachable
2017-02-03 15:03:24.618858 app[752:117893] Network Status Changed: reachable(Alamofire.NetworkReachabilityManager.ConnectionType.wwan)
2017-02-03 15:03:24.622224 app[752:117893] Network Status Changed: notReachable
2017-02-03 15:03:32.554985 app[752:117893] Network Status Changed: reachable(Alamofire.NetworkReachabilityManager.ConnectionType.ethernetOrWiFi)
2017-02-03 15:03:32.602293 app[752:117893] Network Status Changed: notReachable
``` I have the same kind of problem when first subscribing for reachability changes. If the app is launched with internet connection, listener closure gets `.reachable` status and then immediately `.notReachable`. Same problem here. It actually happens with any reachability frameworks so I think problem is in SCNetworkReachability I was having the same issue. Then I removed the scheme (https://) of my url and it was working fine again.

Found the answer here: https://github.com/Alamofire/Alamofire/issues/1782  ![screen shot 2017-02-03 at 11 44 02 am](https://cloud.githubusercontent.com/assets/5466582/22578758/19d9de0a-ea06-11e6-9e94-ff004b4e6071.png)
Hi,

I am profiling sessionManager.default and I'm  curious why every time I call sessionManger.default it creates a memory leak.

**update**

I also profiled the sample project and has the same issue

```
@IBAction func didTapButton(_ sender: Any) {
      let _ = SessionManager.default
}
```  When i make a request as below memory leak occurs
 `Alamofire.request("serviceAdress").responseJSON { response in 
print(response.result 
)}`

![screen shot 2017-02-02 at 19 41 49](https://cloud.githubusercontent.com/assets/1283764/22559250/38cdca0c-e979-11e6-9565-e31d209b5532.png)
 i am new to alamofire. i am really sory @jshier but i didn't understand which variable i will declare top of the class?   Alamofire request first time working (return 200 success) but next times (same api endpoint) not working return 500 (Invalid character around 0), If remove and install app its works again first time but next not working again. For the same api endpoint return success on postman but alamofire return 500.
Why ? You didn't post any examples, snippets of code, troubleshooting steps, or anything. This is definitely not a problem with the library or everyone would be experiencing such a simple issue, so I would suggest posting to [Stack Overflow](http://stackoverflow.com/questions/tagged/alamofire) with more details.  Use case:
Working with REST service whose Authorization process is based on asymmetric singing&encryption. Different endpoint may require or not require request signatures (HMAC or similar), meaning that each request should be signed using 1 or more private keys, or should not be signed at all.
As I understand in Alamofire 4.0 there are two ways it can be implemented:
1. Create several RequestAdapter instances (depending on how much private keys and private key combinations you have) which leads to creating several SessionManager instances with underlying NSURLSession.
2. Use the fact that creation of URLRequest is synchronous (is it?) and set appropriate RequestAdapter instance before creating request and clean this value after.

None of these approaches seems elegant to me, maybe we should allow to pass requestAdapter as parameter to all request methods in SessionManager? > Signing certain requests vs. others is a pretty straightforward use case that can be handled using an adapter or a router

Can you please explain how to implement such behavior using RequestAdapter? (and Router too) Up? @jshier I need to sign different requests differently. Requests should be signed using different keys or sometimes should not be signed at all - that's the use case @jshier I can't understand how you suppose to do this **easily** using request router pattern, also documentation states that Router pattern can be used for Authorization, but doesn't include any examples for this case.
I ended with this workaround to allow passing different RequestAdapters for different requests (I really don't like this approach, but that's the best I can do at this moment)

```
struct AlamofireRequestRouter: URLRequestConvertible {
    private let url: URLConvertible
    private let method: HTTPMethod
    private let parameters: Parameters?
    private let encoding: ParameterEncoding
    private let headers: HTTPHeaders?
    private let adapter: RequestAdapter?
    
    init(
        _ url: URLConvertible,
        method: HTTPMethod = .get,
        parameters: Parameters? = nil,
        encoding: ParameterEncoding = URLEncoding.default,
        headers: HTTPHeaders? = nil,
        adapter: RequestAdapter? = nil)
    {
        self.url = url
        self.method = method
        self.parameters = parameters
        self.encoding = encoding
        self.headers = headers
        self.adapter = adapter
    }
    
    func asURLRequest() throws -> URLRequest {
        let originalRequest = try URLRequest(url: self.url, method: self.method, headers: self.headers)
        let encodedURLRequest = try encoding.encode(originalRequest, with: parameters)
        let adaptedURLRequest = try self.adapter?.adapt(encodedURLRequest) ?? encodedURLRequest
        return adaptedURLRequest
    }
}
``` @jshier The point is that signing url request logic should be separated from logic that creates requests. Code, that performs requests signatures, should not depend on the way you create your requests and vice versa, that's why I think RequestAdapter is the best way to accomplish my goal as it only takes fully prepared URLRequest and doesn't care about who/when/where created it  I don't want to sound rude, but I think #1938 needs some urgent attention.  Anyone wiring up taskDidComplete for background upload or download will suffer a lot of leaks. The taskDelegate queue never gets resumed before the task is removed from requests. The queue leaks everything in it.  i'm trying to upgrade my project to swift 3 and AF4, and keep seeing that almost everything is based on URLRequest, encoding for example. but from what i see, URLRequest is supported inly on iOS10 and above.
other example, is in previous version 3.5 i used to assemble the NSMutableURLRequest object with all the params i need, and then just passed it to Alamofire.request method.
which now seems to accept only URLRequestConvertible, which correct me if i'm wrong, but URLRequestConvertible is creating a NSURLRequest as well.
am i missing something?
 seems like URLRequest supported only from iOS10 and above
https://developer.apple.com/reference/foundation/urlrequest  Alamofire.request(.POST, parameters: Parameters, encoding: .JSON, headers: requestHeader).responseJSON { response in

Error: Extra argument 'parameters' in call.
Swift iOS error. Please help.
 Which Alamofire version are you using ?
With current version of Alamofire and Swift 3 you can use the below method :
Alamofire.request(url, method: .post, parameters: parameters, encoding: JSONEncoding.default, headers: headers).responseJSON { response in }
 Here, question is how to make Parameters?.
Why stop supporting "MutableURLRequest"? now need to fix whole project. sucks üëé   ```
let destination: DownloadRequest.DownloadFileDestination = { _, _ in
	var documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
	let fileURL = documentsURL.appendPathComponent("pig.png")
	
	return (fileURL, [.removePreviousFile, .createIntermediateDirectories]) //Error occurs here
}
Alamofire.download("https://httpbin.org/image/png", to: destination).response { response in
	print(response)
	
	if response.error == nil, let imagePath = response.destinationURL?.path {
		let image = UIImage(contentsOfFile: imagePath)
	}
}
```  Excuse the last post - accidentally hit something...

I have a strange issue with Instruments leaks. I'm running a loop to add many download requests to a background session. The SessionManager is contained in a class singleton pretty much as follows:

class BackgroundTransferCoordinator {
  static let sharedInstance = BackgroundTransferCoordinator()
  lazy var session: SessionManager = { 
       // session with background configuration 
  }()
  // .. too much to show
}

When building background requests in a loop, the following code results in a stunning number of leaks after adding just four requests:

for _ in 0..<4 {
  let request = self.session.download(url)
  request.resume()
}

To confuse matters, adding less than 4 items is more than often OK. Replace the for loop content with this:

let request = self.session.session.downloadTask(with: url)
request.resume()

...and you can add as any requests as you like, with no leaks showing up. I'm typically adding 50 or more requests on a first run and then adding a couple per day thereafter - documents.

The BackgroundTransferCoordinator class sets handlers for:
session.delegate.taskDidComplete
session.delegate.downloadDidFinishDownloadingToURL

I actually run the code inside the getAllTasks completion handler to query existing background tasks and then add missing tasks. However, other code builds requests on the main queue and that also fails after adding more than three in a loop. There is no crash occurring, and all requests complete properly - got the files to prove it.

As far as I can see, the difference appears to be the second example, by using the URLSession directly, bypasses this:

private func download( _ downloadable: DownloadRequest.Downloadable,
        to destination: DownloadRequest.DownloadFileDestination?)
        -> DownloadRequest  

... and requests do not end up being added to SessionDelegate.requests 

I'm not convinced this isn't an issue with Instruments or the way I'm using it. I will try to make a test project in the next couple of days if possible.

 
 

 I have attached a couple of zipped CSV files. I have also confirmed the issue exists adding requests in a loop though I have no clear idea yet why. The following code block shows the problem code. It is running inside the getAllTasks completionHandler but has exactly the same issue running on the main queue.


[IQSMS-Reporting-leaksWithLoopIssue.csv.zip](https://github.com/Alamofire/Alamofire/files/738088/IQSMS-Reporting-leaksWithLoopIssue.csv.zip)
[IQSMS-Reporting-leaksNoLoopIssue.csv.zip](https://github.com/Alamofire/Alamofire/files/738089/IQSMS-Reporting-leaksNoLoopIssue.csv.zip)
 OK, safari is not playing ball with my code when using // comments. The following code picks up unreadable folder files and starts a background download. The TransferID().string is a short encoded description string used to identify the task later. I'm not keeping any references to download tasks. Session.startsRequestsImmediately  is false.

            if completed < total {
                let unreachable = folder.manifest.unreachable
                for rec in unreachable {
                    let taskDescription = TransferID(type: .update, stagingId: stagingId, name: rec.filename, md5sum: rec.md5sum).string
                    if taskDescriptions.contains(taskDescription) == false {
                        
                        /*
                        let req = self.session.download(rec.url)
                        req.task?.taskDescription = taskDescription
                        req.resume()
                         */
                        let req = self.session.session.downloadTask(with: rec.url)
                        req.taskDescription = taskDescription
                        req.resume()
                        
                    }
                    
                }
            } else if total > 0 {
                self.stagingID = 0
                _ = folder.convertToReady()
            } There are 20 files in the code loop shown previously. I only have to loop for 4 to get the leaks trace. Each time the code run is repeated (deleting the folder of files), total memory used grows, so I'm beginning to  think block is being retained somewhere. <img width="1497" alt="screen shot 2017-01-30 at 04 41 31" src="https://cloud.githubusercontent.com/assets/13529631/22411656/7e561fb4-e6a6-11e6-80e8-e40a5caf7c12.png">
 The loop code without the issue produces this image. I clicked refresh 10 times in the trace period. The error message on the App is because I faked an md5 checksum error on the last file in order to loop the test.
<img width="1296" alt="screen shot 2017-01-30 at 04 55 02" src="https://cloud.githubusercontent.com/assets/13529631/22411841/8f74f1c4-e6a8-11e6-8b5a-83048777ce0c.png"> Also, I forgot to mention, there are 2 x SessionManagers running. The default is doing the foreground fetches very nicely thank you :-). That should explain why there are 2 x NSLock objects shown. I'll post a test later today. [AlamofireBackgroundSessionTest.zip](https://github.com/Alamofire/Alamofire/files/738198/AlamofireBackgroundSessionTest.zip)

One test project! Do try setting the loop to 0..<4 Something is bit odd. In the test project SessionTest, unwire taskDidComplete. Note the function is empty in the test. Just wiring it up causes the issue in Instruments Leaks.

    init() {
       // session.delegate.taskDidComplete = self.backgroundSessionTaskDidComplete
       session.delegate.downloadTaskDidFinishDownloadingToURL = self.downloadTaskDidFinishDownloadingToURL
    }

 Ok guys, bit of code for you to look at. The mod is not in the best place - should be in the if taskDidComplete block but I think you will get the idea as to what is going wrong if session.taskDidComplete is wired up:

    open func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {
        /// Executed after it is determined that the request is not going to be retried
        let completeTask: (URLSession, URLSessionTask, Error?) -> Void = { [weak self] session, task, error in
            guard let strongSelf = self else { return }

            if let taskDidComplete = strongSelf.taskDidComplete {
                taskDidComplete(session, task, error)
            } else if let delegate = strongSelf[task]?.delegate {
                delegate.urlSession(session, task: task, didCompleteWithError: error)
            }

            NotificationCenter.default.post(
                name: Notification.Name.Task.DidComplete,
                object: strongSelf,
                userInfo: [Notification.Key.Task: task]
            )
            
            // ADDED. delegate queue is not resumed if only Session.taskDidComplete is wired!
            if let delegate = strongSelf[task]?.delegate {
                delegate.queue.isSuspended = false
            }
            
            strongSelf[task] = nil
        }

        guard let request = self[task], let sessionManager = sessionManager else {
            completeTask(session, task, error)
            return
        }

        // Run all validations on the request before checking if an error occurred
        request.validations.forEach { $0() }

        // Determine whether an error has occurred
        var error: Error? = error

        if let taskDelegate = self[task]?.delegate, taskDelegate.error != nil {
            error = taskDelegate.error
        }

        /// If an error occurred and the retrier is set, asynchronously ask the retrier if the request
        /// should be retried. Otherwise, complete the task by notifying the task delegate.
        if let retrier = retrier, let error = error {
            retrier.should(sessionManager, retry: request, with: error) { [weak self] shouldRetry, timeDelay in
                guard shouldRetry else { completeTask(session, task, error) ; return }

                DispatchQueue.utility.after(timeDelay) { [weak self] in
                    guard let strongSelf = self else { return }

                    let retrySucceeded = strongSelf.sessionManager?.retry(request) ?? false

                    if retrySucceeded, let task = request.task {
                        strongSelf[task] = request
                        return
                    } else {
                        completeTask(session, task, error)
                    }
                }
            }
        } else {
            completeTask(session, task, error)
        }
    }
 Oh, I forgot to mention, if you just move the 'private let lock = NSLock()' right to the top of the SessionDelegate class, you want see this anymore in Leaks. It's a weird thing in Swift.

open class SessionDelegate: NSObject {   
    private let lock = NSLock()  // <-- first in the class

 damn your spell checker! "you **won't** see ..." The issue looks different from simulator to device. I ran the same code both on device and the simulator they look different. (Leak object) But when I look at the stack trace on both SessionDelegate.init() can be seen.
<img width="310" alt="screen shot 2017-02-01 at 10 45 02" src="https://cloud.githubusercontent.com/assets/5278438/22502027/896d2ab6-e86b-11e6-9eb2-3682aa0098d7.png">

<img width="310" alt="screen shot 2017-02-01 at 10 45 09" src="https://cloud.githubusercontent.com/assets/5278438/22502026/896cc1ac-e86b-11e6-8d67-a252c004749f.png">

@unusuallyreticent 

```Oh, I forgot to mention, if you just move the 'private let lock = NSLock()' right to the top of the SessionDelegate class, you want see this anymore in Leaks. It's a weird thing in Swift.```

I tried it but nothing changed.


 The Request adds a block operation referencing self, to the TaskDelegate.queue. I can't remember what it is off-hand, something to do with setting a time maybe. The taskDelegate is itself a strong property of the Request. The taskDelegate queue is not resumed in two situations. The first is when SessionDelegate.taskDidComplete is wired up. The second is when taskDelegate.TaskDidCompleteWithError is wired up. I am not 100% sure of the second case, however the first I can see clearly in debug. The queue is never resumed and the whole request and task delegate leak due to a strong reference cycle held inside that queue. At least, that's what I think it is. I not the guru here. I just make the tea.

The last cleanup point is inside the completeTask block inside the SessionDelegate didCompleteWithError function I listed earlier. The code modification I made ensures that queue is resumed, the queue operation completes and the reference cycle is remove:

if let delegate = strongSelf[task]?.delegate {
                delegate.queue.isSuspended = false
            }

Request.resume() has this, but task is NOT nil so it does not get executed in this case...
guard let task = task else { delegate.queue.isSuspended = false ; return }

The only other place where isSuspended is set false is in TaskDelegate didCompleteWithError. That bit of code is never run if SessionDelegate.taskDidComplete is wired up. If taskDidComplete is not wired up and TaskDelegate.taskDidCompleteWithError is wired up instead, then again, the queue is never resumed and the request (and all its references) and the task delegate leak.

The separate issue of the NSLock() appearing in instruments is I believe, due to a bit of a mess with swift initialisation. It seems to occur in static instance classes. If you want something really odd, try adding a couple of string dictionaries to the the AppDelegate. I guess it has something to do with the way Instruments works but, silly as it sounds, repositioning properties makes a difference. It can of course, work both ways. Repositioning can make something else appear to leak. Its just something I discovered by accident. [AlamofireBackgroundSessionTest.zip](https://github.com/Alamofire/Alamofire/files/744612/AlamofireBackgroundSessionTest.zip)

Here is the same test project with the SessionDelegate file modification in urlSession-didCompleteWithError, and the repositioned NSLock() just to make Instruments-leaks show pretty green lights.  @chamira, the NSLock() property has to be first - before any other property. Look what I did to SessionDelegate in the test project. I only moved this single property to the top. You have moved retrier, sessionManager and requests as well. Leave them were they were. It's a really silly issue. Laughable really. @jshier - thanks. I'll try it out. And, sorry if I seemed a bit rude occasionally. It was unintentional - late nights, three projects on the go, too much coffee :-(

I was only looking at my particular corner case - using taskDidComplete so I didn't consider that TaskDelegate should still be called anyway. Makes sense. They aren't exclusive. 

Did you try that silly trick with NSLock()? That has got to be the daftest trick. If anyone told me to do that I would consider them loony.  @jshier - that's solved it.  I'm trying to connect to a server using a self-signed certificate. 
I added the correct .der file in the app bundle, however all requests fail. 

Is it possible get it working with a self signed certificate?


```
class APIManager {

    private static let serverTrustPolicies: [String: ServerTrustPolicy] = [
        "domain.com": .pinCertificates(
            certificates: ServerTrustPolicy.certificates(),
            validateCertificateChain: true,
            validateHost: true
        )
    ]

    static let manager = SessionManager(
        serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies)
    )

}
```

  Quick question: Has Apple shown any indication that they'll be porting `Security.framework` to Linux?  Ah, got it. FWIW, the Vapor (and Kitura guys) had to reimplement HTTP clients, either through libCURL or from scratch. And they used OpenSSL for the security stuff IIRC

https://github.com/IBM-Swift/Kitura-Request
https://vapor.github.io/documentation/http/client.html I‚Äôd be in favor of abstracting `ServerTrustPolicy` on both platforms so that interested developers can implement their own security methods, and then having current code as the default on Apple platforms. What library are you using on Linux to provide the basic SSL encryption? I would think that library would also provide certificate-chain validation, since that's an integral part of using SSL.

You'll definitely need to use some existing library with good Linux system integration, like OpenSSL. You do _not_ want to get into the business of compiling your own lists of root certificates, managing cert revocation lists, or running interactive cert-verification protocols. So it sounds like URLSession on Linux already supports SSL? (Sorry, I haven't been keeping up with the standard library.) If so, it needs to support cert validation too. It sounds like either it's not validating certs (which would be a terrible security problem), or it does the validation but doesn't expose a way for clients to customize it or run their own validation. In the latter case I think it's a feature they really need to add. So is the linux branch considered workable work-in-progress? or should I be aiming for https://github.com/SwiftOnEdge/Edge up until stuff start clearing out? Third option looks like most consistent. I think, that one stable dependency like Security or OpenSSL isn't so bad.  last spam.. (sorry guys) 

just wanted to let the community know that up until Alamofire is ready I'm having success with [Zewo](https://github.com/Zewo/HTTPClient) `.Package(url: "https://github.com/Zewo/HTTPClient.git", majorVersion: 0, minor: 14)` for building an [AWS Lambda Swift](https://gist.github.com/maximveksler/1f47e4a618cdf7e58169f6a2a04f32d6) based function. Tried Kitura but it's relaying on openssl-dev package to be installed on my Docker image, unfortunately it's not. So I switched to Zewo which brings the COpenSSL as a dependency, thus not relaying on what is installed on the build serve which I think is a better approach in general. Does this link help: [https://github.com/swift-server/security/blob/master/README.md](https://github.com/swift-server/security/blob/master/README.md) ?

It was posted here: [https://lists.swift.org/pipermail/swift-server-dev/Week-of-Mon-20170123/000233.html](https://lists.swift.org/pipermail/swift-server-dev/Week-of-Mon-20170123/000233.html) The next Security Meeting of the Swift-Server-Dev group is going to be scheduled:

https://lists.swift.org/pipermail/swift-server-dev/Week-of-Mon-20170220/000265.html

@jshier aren't you interested in this, no? fyi - there is a swift wrapper around libCurl  https://github.com/dmcyk/SwiftyCurl that could provide a stop gap to allow Alamofire + swift on server until Apple help out. 
although - IBM is pretty set on ditching cCurl for swift.
https://github.com/IBM-Swift/CCurl/issues/10

I think if the implementation could simply be switched out when time comes - then investing in SwiftyCurl could bare fruit quickly.  As in - hey we have an Alamofire linux branch up and running in days, not months. 

My personal opinion is until swift 4 or 5 - server side swift isn't going to get any traction. 
People are waiting for ABI to stabilize.  A brilliant pod cast with Chris Lattner for anyone interested - http://atp.fm/episodes/205



 Hi, 
I'm from the Swift@IBM team and just dropping a comment here to say we're also interested in seeing Alamofire ported over to Linux. So if there's anything we can do to help or anything you need from us please contact either [Ian Partridge](https://github.com/ianpartridge) or [Lloyd Roseblade](https://github.com/lroseblade). 
Thanks.  Hi! I'm a french developer who is trying to use Swift on Android, and I'm very interested in having a Linux port of Alamofire. I think it would work on Android too.
Is there anything I could do to help? Thank you! Hi,
I'm a mobile developer for iOS and we a currently playing around with server-side swift. So far using Alamofire to send requests works as expected, but receiving a response does not. I've already debugged the code a bit and it seems to receive and process the response on a NSURL level, but the callback-closure never gets called. If you'd like, I can open a separate issue for that.
Thanks. Just to keep you updated, on my fork I managed to build an Alamofire version based on the linux branch, updated with the current master, and still working for macOS and iOS. I didn't provide any workaround for the Security part for now, it's just removed from the Linux build because it still seems to be in discussion on the Apple side.

Should I open a Pull Request with these changes? [https://github.com/Creatiwity/Alamofire/tree/linux](https://github.com/Creatiwity/Alamofire/tree/linux)

Note that I wanted to test it on Android and due to some problems on the Swift side, I am still working on it, but I think it should work both on Linux and Android very soon.  I am not sure this is the place and the way to ask a question, but I am out of options. Long story short - memory leaks are caused by `static Request.serializeResponceJSON` inside Alamofire. My problem is fully described in this [stackoverflow thread](http://stackoverflow.com/questions/41594282/alamofire-memory-leaks-instruments). I got a few up votes, so I suggest, it does not happen due to some obvious mistakes, made by me, so I really need some explanation. I've asked this in [SwiftyJSON repo](https://github.com/SwiftyJSON/SwiftyJSON/issues/780), they've suggested, that it is connected with Alamofire. You can find test project there.  Hi...

I need consume an API, which can return an 403 status and the reason of the fails in json format.

I do this
```swift
Alamofire.request("MY_URL", method: .post, encoding: JSONEncoding.default)
    .validate()
    .responseJSON(completionHandler: { response in
        if let value = response.result.value {
            // do something with json data
        } else if let error = response.result.error {
            // do something ewith error json 
        }
    })
```

The problem is that i need the json error when the request fails...
 Alamofire treats all requests as successful. Take a look at [Response Validation](https://github.com/Alamofire/Alamofire#response-validation) to see if you are able to get what you want or else clarify a bit more in your question with examples. @sagarpatkar for example, the login endpoint can return something like this when the credentials are valid:

```json
{
  "user_id": "@cheeky_monkey:someserver.org",
  "access_token": "abc123",
  "home_server": "someserver.org"
}
```

or this, when the credentials are invalid

```json
{
  "errcode": "M_FORBIDDEN",
  "error": "anything"
}
```

I use ObjectMapper to map the response with my Credentials and Error classes

I remove the `.validate()` call and update the request:

```swift
Alamofire.request("LOGIN_URL", method: .post, encoding: JSONEncoding.default)
    .responseJSON(completionHandler: { response in
        if let value = response.result.value {
            if response.response?.statusCode == 200 {
                let creds = Mapper<MXCredentials>().map(JSON: value as! [String: Any])!
                // do something with api credentials (ok response)
            } else {
                let e = Mapper<MXError>().map(JSON: value as! [String: Any])!
                // do something with api error (204 response)
            }
        } else if let error = response.result.error {
            // Alamofire error
        }
    })
```

That solve my issue but feels kind ugly to me xD, if i use `.validate()`, the code enter in `// Alamofire error` but i can't do `let e = Mapper<MXError>().map(JSON: value as! [String: Any])!` because `response.result.value` is nil  if request header contains "$" symbol, then debugDescription (cUrlRepresentation)  returns incorrect value: header contains not escaping value for this symbol, and on server we have header with incorrect value (it includes only part before "$" symbol).  I am able to pin using the certificates, but I also get the public key hash from an api call. Is there any way I can use that for pinning? (Ex. Convert the string to a certificate and then pin using that certificate) I will start getting the string once the existing in-app certificates near expiry.  The key is meant as a backup. In short,  the existing pinning is with certificates,  but once they near expiry,  backend will start sending me a backup key again which I will then pin.  Should I be able to use TrustKit with Alamofire. Since TrustKit allows SHA256 pinning, I can pin using TrustKit and the use the default SessionManager from Alamofire to make the request. Any thoughts? I got the web service response changed from a SHA256 to a String. I was then able to convert it to a certificate and save for later pinning use. You can close this question.  Hi... I wanna send a request with query and body parameters...

Alamofire support this feature or i need to build the query parameters manually like this:

```swift

Alamofire.request("MY_URL?access_token=\(token)&param2=\(param2)", method: .post ...)
```  Alamofire will not overwrite my file if it already exists, and I am not sure how to make it overwrite it.

```
let destination = DownloadRequest.suggestedDownloadDestination()
		print("You have selected \(id)")

		Alamofire.download("https://downloadme.com/download.pdf", to: destination)
			.authenticate(user: "username", password: "password")
			.responseString { response in
				print(response.destinationURL!.path)}
```

What if the destination exists, how do I overwrite it?  I'm subclassing the SessionManager and when I call this
`
   self.request(url:  "someurl", method: HTTPMethod.post, parameters: nil, encoding: JSONEncoding, headers: nil).responseJSON {`

xCode gives me the error extra argument 'method' in call.

I don't get it. Because the autocomplete gives me this method.
  I'm dealing with this issue here.
I have make a json request with alamofire and inside my json there are some characters like `u00b` etc. Which is greek language.
Although when i print the dictionary i cant see the correct string like "Œ±Œ≤Œ≥" but their unicode characters.

Which is the proper way with alamofire to unicode all the text that i get to utf-8 so i can print out the proper characters??

The following code is the request that i make.

    func getManPerf() {
        Alamofire.request(baseurl, method: .get, parameters: ["action": "categories", "subaction": "getproducts", "category_id": "11", "limit": "0,30"]).responseJSON { (responseData) -> Void in
            if((responseData.result.value) != nil) {
                let result = responseData.result
                print(result)
                
                if let dict = result.value as? Dictionary<String, AnyObject>{
                    if let list = dict["products_in_category"] as? [Dictionary<String, AnyObject>] {
                        
                        for obj in list {
                            let manPerfumes = Products(productDict: obj)
                            self.manPerfumeData.append(manPerfumes)
                        }
                        DispatchQueue.main.async{
                            self.manPerfumeCV.reloadData()
                            
                        }
                        
                        
                    }
                }
                
            }
        }
    }

What changes do i have to make to my code so it can bring me the correct data? Thanks!  Any eta, roadmap or plans to add linux support? Yes, it will be very good. Swift on Linux become very popular!!!  I tried to cache response.destinationURL?.path and wanted to use it later, but I found the file downloaded was deleted later. It exists in the original response closure. So how could I use the downloaded file directly not download it again?  Given there are two AlamofireManager available:

```
    public static func alamofireManager() -> Alamofire.SessionManager {
        if (Api.alamofireManagerInstance == nil) {
            Api.alamofireManagerInstance = Alamofire.SessionManager(configuration: defaultConfiguration())
        }
        
        return Api.alamofireManagerInstance!
    }
    
    public static func backgroundDownloadManager() -> Alamofire.SessionManager {
        if (Api.backgroundDownloadManagerInstance == nil) {
            let identifier = Bundle.main.bundleIdentifier!
            
            let configuration = URLSessionConfiguration.background(withIdentifier: identifier)
            configuration.sessionSendsLaunchEvents = true
            
            let manager = Alamofire.SessionManager(configuration: configuration)
            manager.startRequestsImmediately = true
            
            Api.backgroundDownloadManagerInstance = manager
        }
        
        return Api.backgroundDownloadManagerInstance!
    }
```

And I call them like this:

```
Api.backgroundDownloadManager()
                .download(v.downloadURL(), method: .get, to: { (url, response) -> (destinationURL: URL, options: DownloadRequest.DownloadOptions) in
 // construct URL
})
.downloadProgress(closure: { (p) in
 // update spinner etc
})
.response(completionHandler: { (response) in
  if let e = response.error {
    print ("error detected: \(response.error)")
  }
})
```

Then, once I disconnect my phone from the source (by unplugging the source device from WiFi), only the first foreground session manager will report the below error. The backgroundDownloadManager will NOT report any error (thus causing spinners to never disappear etc).

It can be fixed by switching to the `alamofireManager` as shown above. Then the error will be reported correctly:

```
error detected: Optional(Error Domain=NSURLErrorDomain Code=-1005 "The network connection was lost." UserInfo={NSUnderlyingError=0x17644d6e0 {Error Domain=kCFErrorDomainCFNetwork Code=-1005 "(null)" UserInfo={NSErrorPeerAddressKey=<CFData 0x17048b860 [0x1b509dbb8]>{length = 16, capacity = 16, bytes = 0x10020050c0a801fe0000000000000000}}}, NSErrorFailingURLStringKey=http://large.filesource/video.mov, NSErrorFailingURLKey=http://large.filesource/video.mov, NSLocalizedDescription=The network connection was lost.})
```


This is on iOS 10.2 (14C92), using Alamofire 4.3.0 (Podfile.lock below):

```
PODS:
  - Alamofire (4.3.0)
  - AlamofireImage (3.2.0):
    - Alamofire (~> 4.1)
  - Crashlytics (3.8.3):
    - Fabric (~> 1.6.3)
  - Fabric (1.6.11)
  - Fuzi (1.0.1)
  - OHHTTPStubs (5.2.3):
    - OHHTTPStubs/Default (= 5.2.3)
  - OHHTTPStubs/Core (5.2.3)
  - OHHTTPStubs/Default (5.2.3):
    - OHHTTPStubs/Core
    - OHHTTPStubs/JSON
    - OHHTTPStubs/NSURLSession
    - OHHTTPStubs/OHPathHelpers
  - OHHTTPStubs/JSON (5.2.3):
    - OHHTTPStubs/Core
  - OHHTTPStubs/NSURLSession (5.2.3):
    - OHHTTPStubs/Core
  - OHHTTPStubs/OHPathHelpers (5.2.3)
  - OHHTTPStubs/Swift (5.2.3):
    - OHHTTPStubs/Core
  - ReachabilitySwift (3)
  - RxAlamofire (3.0.3):
    - RxAlamofire/Core (= 3.0.3)
  - RxAlamofire/Core (3.0.3):
    - Alamofire (~> 4.0)
    - RxSwift (~> 3.0)
  - RxSwift (3.1.0)
  - SimulatorStatusMagic (1.9.2)
  - SVProgressHUD (2.1.2)
  - SwiftyDropbox (4.1.1):
    - Alamofire (~> 4.3.0)
  - SwiftyJSON (3.1.4)
  - Timberjack (0.0.2)
``` Hi @jshier and @cnoon , I've also found the issue and did what you said that is giving a short timeout period(10s). 

The problem then I had:

- If you have Wi-Fi ON with no internet, sometimes the timeout gets calls, but sometimes it doesn't.  It's inconsistent. If the 1st time the timeout works, then somehow the 2nd time definitely won't work. Is there a cache or something? Is there a way to clear it?

-  if you have Wi-Fi OFF before you making the request, then the error/response(the response closure) is guaranteed to be NEVER called. The timeoutForRequest takes NO effect.

Code: 

    private lazy var sessionManager: SessionManager = {
        
        let configuration = URLSessionConfiguration.background(withIdentifier: "abc.background")

        //Default timeout
        configuration.timeoutIntervalForRequest = 10

        var manager = Alamofire.SessionManager(configuration: configuration)
        
        return manager
    }()

      self.sessionManager.download("https://www.abc.com", to: self.destionation(destination)).response { (response) in
              debugPrint("timeout:\(Date())")
              debugPrint(response)
      }.downloadProgress(closure: { (progress) in
              debugPrint("Progress:%\(progress.fractionCompleted)")
      }).resume()


  Hi @jshier , thanks for your reply.

However, all the problems I've mentioned above were occurred when app running in Foreground. Are you saying that if I set the background identifier, even I run the App in foreground I still won't get a immediate failure when Wi-Fi OFF? 

The Wi-Fi failure is not a too big deal to me, because I could always run the connectivity test to manually fail the network process. The biggest thing is that the timeoutIntervalForRequest is not always working once I set the background identifier and even the App runs in foreground. So you create the manager like I've written in above, runs the App in foreground and have the Wi-Fi ON and connected to a network without internet, sometimes you get the timeout failure within the timeInterval you set but sometimes you don't. Once I remove the background identifier, then every functionalities work as normal . @jshier Thanks for your detailed explanation. That helped me a lot. Hello @jshier 

Not getting Time out / Connection lost error in foreground mode with default URLSession configuration, 

    static let sharedManager: SessionManager = {
        let configuration = URLSessionConfiguration.default
        configuration.timeoutIntervalForRequest = 10.0
        configuration.timeoutIntervalForResource = 10.0
        return SessionManager(configuration: configuration)
    }()

Please help.  Can someone pls tell me where the issue lies, tried two different samples, might be lacking on my code as it did not perform the request, did not passed through Alamofire .request code. Thank you so much.

Sample Code #1:

          let credentialData1 = "\(user):\(password)".data(using: String.Encoding.utf8)!
          let base64Credentials1 = credentialData1.base64EncodedString(options: [])
          let headers1 = ["Authorization": "Basic \(base64Credentials1)"]
 
          Alamofire.request("http://192.168.12.250:5000/v1/getprofile",
                          method: .get,
                          parameters: ["":""],
                          encoding: JSONEncoding.default,
                          headers:headers1)
            .validate()
            .responseJSON { response in

                print("Get request for Swift 3")
                if response.result.value != nil{
                    print("Sample response: ", response)
                }else{
                    print("There's an error")
                }
        } 

Sample Code #2:

        var headers4: HTTPHeaders = [:]
        if let authorizationHeader = Request.authorizationHeader(user: user, password: password) {
            headers4[authorizationHeader.key] = authorizationHeader.value
        }
        Alamofire.request("http://192.168.12.250:5000/v1/getprofile", headers: headers4)
            .responseJSON { response in
                   print("Sample response: ", response)
                  debugPrint(response)
        }    Alamofire (4.2.0)

Does `SessionManager` have to stay allocated after initiating a background upload? I hope not, because if so it can't be used in an extension context AFAIK. 

Interestingly, `self.session?.uploadTask(with: req, fromFile: sharedContainerFileUrl)` does work, and upload completed. 

If I never exit the extension, the file uploads to S3 successfully. Obviously not exiting the extension until an image upload completes is an anti-pattern, so I can't really do that. 

If you are certain this is not an issue with Alamofire, I'm happy to move it to stack overflow. 

``` Swift
//  var session: URLSession?
//  var uploadTask: URLSessionUploadTask?
  var manager: SessionManager?

  fileprivate func shareSignalProducer(forImageUrl url: URL, publish: Bool, site: Site, note: String) -> SignalProducer<Void, NSError> {

    let configuration = URLSessionConfiguration.background(withIdentifier: "group.io.thegrid.take.er.easy")
    configuration.sharedContainerIdentifier = "group.io.thegrid"
    self.manager = SessionManager(configuration: configuration)

    return SignalProducer<Void, NSError> { observer, _ in

      guard var sharedContainerFileUrl = self.sharedBaseDirectory else {
        observer.send(error: GridError.sharedContainerAccessError.nsError)
        return
      }
      sharedContainerFileUrl.appendPathComponent(UUID().uuidString)
      sharedContainerFileUrl.appendPathExtension(url.pathExtension)

      guard let data = try? Data(contentsOf: url, options: Data.ReadingOptions.mappedIfSafe) else {
        observer.send(error: GridError.readFromDiskError.nsError)
        return
      }

      guard let _ = try? data.write(to: sharedContainerFileUrl, options: Data.WritingOptions.atomic) else {
        observer.send(error: GridError.writeToDiskError.nsError)
        return
      }

      self.http.getSignedUploadURL(objectName: "image", contentType: url.mimeType())
        .subscribe(onNext: { signedURL in


          self.manager?.upload(sharedContainerFileUrl, to: signedURL.signedUrl, method: .put, headers: ["Content-Type": url.mimeType()])

          /* This does initiate and complete the upload in the backgoround
          self.session = URLSession(configuration: configuration)

          guard let presignedURL = URL(string: signedURL.signedUrl) else { fatalError("SignedUploadURL.signedUrl invalid value") }

          var req = URLRequest(url: presignedURL)
          req.httpMethod = "PUT"
          req.setValue(url.mimeType(), forHTTPHeaderField: "Content-Type")

          self.uploadTask = self.session?.uploadTask(with: req, fromFile: sharedContainerFileUrl)
          self.uploadTask?.resume()
          */

        }, onError: { error in
          observer.send(error: GridError.error(description: error.localizedDescription).nsError)
        }, onCompleted: {
          observer.send(value: ())
          observer.sendCompleted()
        })
        .addDisposableTo(disposeBag)
    }
  }
``` Another note:
As a test I added a progress handler,  and did not exit the extension until it was triggered with > 0 percentage complete. Same result, just terminated the upload. Seeing the same result in a share extension.

```
let sessionConfig = URLSessionConfiguration.background(withIdentifier: "com.my.app.Background")
sessionConfig.sharedContainerIdentifier = "group.com.my.app"
let manager = Alamofire.SessionManager(configuration: sessionConfig)
manager.startRequestsImmediately = true
_ = manager.request(DataRouter.create(data))
```
(where the `DataRouter` enum implements URLRequestConvertible, and `data` is a simple object that supplies request params. Works consistently in the main app.)

does not fire a request to my server unless I manually breakpoint before dismissing the share extension and wait for the request to complete. 

Commenting this out and replacing it with a simple 
```
let session = URLSession(configuration: sessionConfig)
session.dataTask(with: request).resume()
```
yields the expected result of sending the request once the share extension is dismissed. 


Any ideas?
 That is exactly the result I had. The moment the extension dismisses, the upload terminates.  @cnoon @jshier - Here is the rub... If you create a singleton and the extension does not terminate properly, or the singleton is leaked, there is a good chance you won't be able to launch that extension again until the system cleans it up. 
Extension contexts/lifecycles are ephemeral, and there is a good chance the use case is to be able to launch the share or otherwise multiple times.

The flow for a share in my application _does_ require the main application to process follow up requests, so in that sense it _could_ all be deferred and managed by the main app. 

All that said, I stuck with `uploadTask` as it does exit the extension cleanly, and perform the upload successfully. I really don't think the issue is likely resolved from a root cause standpoint, but there are workarounds for sure.

Thanks guys for the discussion. Hey guys I meant to follow up on this sooner- I ended up finding the same results. Making the session manager static ensures it lives until the (upload) tasks are complete. Thanks for your time and assessments @jshier.

@cnoon and @nickvelloff also have good points for taking care of more complex or chained uploads in a `URLSessionTaskDelegate`.  Hey Alamofire Team:

First off - I know this is completely out of line but I'm hoping someone out of the kindness of their heart will help me out here as I would do the same for anyone else. If someone is willing to help me here then I can promise you that I will not forget about this in the future - so please keep that in mind.

I am hoping someone would be willing to write a quick simple example in Swift 3.0 that uses Alamofire to record a video and then uploads this video once the user clicks "Upload" onto a web server.

If ANYONE on the team or any user would be willing to write a quick example that accomplishes this then I would be forever grateful and I would pay this favour back with interest one day in the future. That's the type of person I am.

Thank you so much all and again I apologize for such an annoying request. 

Cheers
  Hi there. I'm trying to extend Alamofire with additional Request and Response types. I'm building a SOAP library that has typed requests/responses. I found Alamofire nice to work with and would like to prevent reinventing the wheel for the http transport. However I've run into an issue which is preventing me from extending Alamofire to introduce these typed Requests. Ideally I'd like to build the following type;

```
class Request<T>: DataRequest {
    public func response(
        completionHandler: @escaping ((Response<T>) -> Void))
        -> Self
    { .... }
}
```

In my library I would extend `SessionManager` adding a new method that returns this type. However to achieve parity with the other requests methods, some internal types have to be used. I've highlighted those lines below.

```
extension SessionManager {
    func request<T>(_ urlRequest: URLRequestConvertible, some: T) -> Request<T> {
        var originalRequest: URLRequest?

        do {
            originalRequest = try urlRequest.asURLRequest()
>           let originalTask = DataRequest.Requestable(urlRequest: originalRequest!)

>           let task = try originalTask.task(session: session, adapter: adapter, queue: queue)
            let request = Request(some: some, session: session, requestTask: .data(originalTask, task))

>           delegate[task] = request

            if startRequestsImmediately { request.resume() }

            return request
        } catch {
            return request(originalRequest, failedWith: error)
        }
    }
}
```

[At the moment I'm simply wrapping the request and response types][1]. However the obvious drawback here is that the API becomes rather ugly as calls can no longer be chained;
```
wrapperRequest.response(...) < response is of type "Wrapper"Request
wrapperRequest.request.authorization(...)  < response is of type Alamofire.Request
```

Thus finally my question. A lot of classes and properties have been marked "open", which communicate that they might be overridden. However some of the building blocks have been hidden which prevent further customization. Is it possible that these internal types become open as well?

[1]: https://github.com/Bouke/Lark/blob/2a382ec22288f884143bf97bc3e0cee7be6d6fbb/Sources/Lark/Client.swift#L32-L34 Hi @jshier, thanks for your swift reply!

For example my SOAP server might expose a method `foo(input: FooType) -> BarType`. The server exposes a WSDL (with XSD) that my library will use to generate Swift code for. Something like;
```
class FooBarServiceClient: Client {
    func foo(input: FooType) -> Request<BarType> {...}
}
```

When calling this method `FooType` will be serialized into XML (SOAP Envelope). The response is also XML (SOAP Envelope) which will be deserialized into `BarType`.

I would be able to deserialize into a generic `Envelope`. The problem with having only DataRequest available, I lose type information and I cannot deserialize Envelope into BarType.

```
extension SessionManager {   
    func request<T: URLRequestRoutable>(_ parameters: T) -> DataRequest {
                                                            ^^^^^^^^^^^
        return request(parameters.route)
    }
}
```

For reference, this is the wrapping `Request<T>` type.
```
public struct Request<T> {
    var request: DataRequest
    var responseDeserializer: (Envelope) throws -> T

    @discardableResult
    public func response(
        completionHandler: @escaping ((Response<T>) -> Void))
        -> Request
    {
        request
            .response(responseSerializer: EnvelopeDeserializer()) { originalResponse in
                let response = Response(
                    request: self,
                    result: try! self.responseDeserializer(originalResponse.result.value!)
                )
                completionHandler(response)
            }
        return self
    }
}
``` Ah yes now it's starting to get clear to me. I've compiled a small sample of the above;
```swift
import Foundation
import Alamofire

// MARK:- library code
protocol SOAPActionConvertible: URLRequestConvertible {
}
protocol SOAPDecodable {
    init(decode: Data)
}
@discardableResult
func perform<T: SOAPActionConvertible, U: SOAPDecodable>(
    _ action: T,
    completionHandler: @escaping (_ response: DataResponse<U>) -> Void)
    -> DataRequest
{
    return Alamofire.request(action).responseSOAP { completionHandler($0) }
}
struct SOAPSerializer<Value: SOAPDecodable>: DataResponseSerializerProtocol {
    public typealias SerializedObject = Value
    public var serializeResponse: (URLRequest?, HTTPURLResponse?, Data?, Error?) -> Result<Value> = { (_, _, data, _) in
        return .success(SerializedObject(decode: data!))
    }
}
extension DataRequest {
    func responseSOAP<T: SOAPDecodable>(
        completionHandler: @escaping (_ response: DataResponse<T>) -> Void)
        -> Self
    {
        return response(responseSerializer: SOAPSerializer(), completionHandler: completionHandler)
    }
}

// MARK:- generated code
struct FooType {
    let a: Int
    let b: Int
}
struct FooAction: SOAPActionConvertible {
    let foo: FooType
    func asURLRequest() throws -> URLRequest {
        return URLRequest(url: URL(string: "http://httpbin.org/get")!)
    }
}
struct BarType {
    let c: Int
}
struct FooResponse: SOAPDecodable {
    let bar: BarType
    init(decode: Data) {
        bar = BarType(c: 3)
    }
}

// MARK:- usage
let request = perform(
    FooAction(foo: FooType(a: 1, b: 2)),
    completionHandler: { (response: DataResponse<FooResponse>) in
        print(response.result.value)
    })
```

Now in order to make the call site even clearer, I could also generate a ``Client`` with concrete types;

```swift
// MARK:- generated client
struct FooBarServiceClient {
    @discardableResult
    func foo(
        input: FooType,
        completionHandler: @escaping (_ response: Result<BarType>) -> Void)
        -> DataRequest
    {
        return perform(
            FooAction(foo: input),
            completionHandler: { (response: DataResponse<FooResponse>) in
                completionHandler(.success(response.result.value!.bar))
            })
    }
}

// MARK:- usage
let client = FooBarServiceClient()
client.foo(input: FooType(a: 1, b: 2), completionHandler: { bar in print(bar.value!.c) })
```

There are some nice aspects of this; mostly relying on Swift's type resolver to inject the correct types. There's also a few things left to work on. A user might want to set a "SOAP Header" (xml element additional to the method parameters) for all future method calls. In order to do this; ``SOAPActionConvertible`` would have to also know about these headers. This would however introduce a lot of complexity on all the generated types. For now I've settled on an intermediate type ``Envelope`` (soap-speak for a xml message that contains body + headers). The response is also an ``Envelope`` which can be decoded back to the method's return type.

```swift
extension DataRequest {
    @discardableResult
    func responseSOAP(
        completionHandler: @escaping (_ response: DataResponse<Envelope>) -> Void)
        -> Self
    {
        return response(responseSerializer: EnvelopeDeserializer(), completionHandler: completionHandler)
    }
}
```
In the library, this method is called like this:
```swift
open class Client {
    open func call<T>(
        serialize: (Envelope) throws -> Envelope,
        deserialize: @escaping (Envelope) throws -> T,
        completionHandler: @escaping (Result<T>) -> Void)
        -> DataRequest
    {
        let envelope = try serialize(Envelope())
        var request = URLRequest(url: endpoint)
        // set correct parameters on request
        return Alamofire.request(request).responseSOAP {
            do {
                completionHandler(.success(try deserialize($0.result.resolve())))
            } catch {
                completionHandler(.failure(error))
            }
        }
    }
}
```

And finally the generated code calls the generic ``call<T>`` method:

```swift
client FooBarServiceClient {
    @discardableResult func foo(
        _ parameter: FooType,
        completionHandler: @escaping (Result<BarType>) -> Void) 
        -> DataRequest
    {
        return callAsync(
            serialize: { envelope in
                // add xml to envelope
                return envelope
            },
            deserialize: { envelope in
                return try BarType(deserialize: node)
            },
            completionHandler: completionHandler)
    }
}
```

Quite a lot of moving parts though and I'd like to further apply generics on the code. But for now I'm quite fond of the result. Many thanks for your time!  i need to upload the image to server, i try by using postman and it work perfect. But in my ios app, it always return error
here the postman header
POST /api/file?objectId=587991afeb536e1180e662f5&amp;fileType=3 HTTP/1.1
Host: apimapflakes.azurewebsites.net
Accept: application/json
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW
Authorization: Bearer 5878f70ab88c071c2c1aa3b3
Cache-Control: no-cache
Postman-Token: aa2b6bca-5b16-3084-abc1-ffd1747646f3

------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="fileName"; filename=""
Content-Type: 


------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=""


------WebKitFormBoundary7MA4YWxkTrZu0gW--

anh here the code, im trying some solution on stackoverfow, etc but still same error
let url = "http://apimapflakes.azurewebsites.net/api/fileobjectId=587991afeb536e1180e662f5&fileType=3"
let header = [
                "Accept": "application/json",
                "Content-Type": "multipart/form-data",
                "Authorization": "\(type) "+token
            ]
            Alamofire.upload(multipartFormData: { multipartFormData in
                multipartFormData.append(imageData, withName: "file", fileName: "photo.jpeg", mimeType: "image/jpeg")
            }, to: url, headers: header, encodingCompletion: { (result) in
                switch result {
                case .success(let upload, _, _):
                    upload.response(completionHandler: { response in                       
                    })
                case .failure(let encodingError):
                   print(endcodingError)
                }
            })
teh upload request is success but reponse data is some kind of html string. its must be the image url  ```
class func GET(_ URLString: String, parameters: Any?, success: ((_ response:  Any) -> Void)?,failure: ((_ errorMessage: String?) -> Void)?)
    {
        let params = parameters as! Parameters
        Alamofire.request(URLString, method: .get, parameters: params, encoding: URLEncoding(destination: .httpBody)).validate().responseJSON { (response) in
            switch response.result {
            case .success:
                guard let obj = response.data else{
                    return
                }
                success?(response: obj)
            case .failure(let _):
                failure?(NetworkTool.paserError(response.data))
            }
        }
        
    }
```
This is part of the error log until the request times out:
`ready socket-flow (satisfied)] Write request has 4294967295 frame count, 0 byte count  `


 > Sending GET with JSON in body gets Timeout error
> https://github.com/Alamofire/Alamofire/issues/1819  I'm using Alamofire 3.5.1 in my Swift 2.3 code. It seems like Alamofire is causing my app to crash. I haven't been able to reproduce the crash myself but I believe it originates in Alamofire according to the following crash report from an iPhone 6s device running IOS 10.2. Can you please look into this issue?

```
Exception Type:  SIGABRT
Exception Codes: #0 at 0x18c413014
Crashed Thread:  13

Application Specific Information:
*** Terminating app due to uncaught exception 'NSMallocException', reason: '*** -[NSConcreteMutableData appendBytes:length:]: unable to allocate memory for length (1476400124)'

Last Exception Backtrace:
0   CoreFoundation                       0x000000018d4451b8 __exceptionPreprocess + 124
1   libobjc.A.dylib                      0x000000018be7c55c objc_exception_throw + 52
2   CoreFoundation                       0x000000018d445100 +[NSException raise:format:] + 112
3   Foundation                           0x000000018de748e0 _NSMutableDataGrowBytes + 644
4   Foundation                           0x000000018de7459c -[NSConcreteMutableData appendBytes:length:] + 368
5   Foundation                           0x000000018e084780 __49-[_NSDispatchData enumerateByteRangesUsingBlock:]_block_invoke + 40
6   libdispatch.dylib                    0x000000018c2cea98 _dispatch_data_apply + 124
7   libdispatch.dylib                    0x000000018c2ceac0 _dispatch_data_apply + 164
8   libdispatch.dylib                    0x000000018c2d35e4 dispatch_data_apply + 36
9   Foundation                           0x000000018e084748 -[_NSDispatchData enumerateByteRangesUsingBlock:] + 60
10  Foundation                           0x000000018de74404 -[NSConcreteMutableData appendData:] + 76
11  Alamofire                            0x00000001006e24a0 function signature specialization <Arg[0] = Owned To Guaranteed, Arg[1] = Owned To Guaranteed, Arg[2] = Owned To Guaranteed> of Alamofire.Request.DataTaskDelegate.URLSession (__ObjC.NSURLSession, dataTask : __ObjC.NSURLSessionDataTask, didReceiveData : __ObjC.NSData) -> () (Request.swift:422)
12  Alamofire                            0x00000001006d9ecc Alamofire.Request.DataTaskDelegate.URLSession (__ObjC.NSURLSession, dataTask : __ObjC.NSURLSessionDataTask, didReceiveData : __ObjC.NSData) -> () (Request.swift:413)
13  Alamofire                            0x00000001006c44ec function signature specialization <Arg[0] = Owned To Guaranteed, Arg[1] = Owned To Guaranteed, Arg[2] = Owned To Guaranteed> of Alamofire.Manager.SessionDelegate.URLSession (__ObjC.NSURLSession, dataTask : __ObjC.NSURLSessionDataTask, didReceiveData : __ObjC.NSData) -> () (Manager.swift:619)
14  Alamofire                            0x00000001006bbcdc @objc Alamofire.Manager.SessionDelegate.URLSession (__ObjC.NSURLSession, dataTask : __ObjC.NSURLSessionDataTask, didReceiveData : __ObjC.NSData) -> () (Manager.swift:0)
15  CFNetwork                            0x000000018dc1282c __67-[NSURLSession delegate_dataTask:didReceiveData:completionHandler:]_block_invoke.242 + 32
16  Foundation                           0x000000018df33fb0 __NSBLOCKOPERATION_IS_CALLING_OUT_TO_A_BLOCK__ + 12
17  Foundation                           0x000000018de78aa8 -[NSBlockOperation main] + 92
18  Foundation                           0x000000018de690a4 -[__NSOperationInternal _start:] + 616
19  Foundation                           0x000000018df3635c __NSOQSchedule_f + 224
20  libdispatch.dylib                    0x000000018c2ce1bc _dispatch_client_callout + 12
21  libdispatch.dylib                    0x000000018c2dc3dc _dispatch_queue_serial_drain + 924
22  libdispatch.dylib                    0x000000018c2d19a4 _dispatch_queue_invoke + 648
23  libdispatch.dylib                    0x000000018c2de34c _dispatch_root_queue_drain + 568
24  libdispatch.dylib                    0x000000018c2de0ac _dispatch_worker_thread3 + 120
25  libsystem_pthread.dylib              0x000000018c4d72a0 _pthread_wqthread + 1284
26  libsystem_pthread.dylib              0x000000018c4d6d8c start_wqthread + 0
```
 Hi @cnoon!

Thank you for the help!  Hi,

I am getting below error. Can anyone please help.

NSURLSession/NSURLConnection HTTP load failed (kCFStreamErrorDomainSSL, -9814)

Thanks  I use the RequestAdapter in conjunction with the RequestRetrier as per your example, but The RequestAdapter seems to not use the new access token that I set instead it uses the old access token. I konw this because in the adapt(_) function i put this:

```

private var accessToken: String?

    func adapt(_ urlRequest: URLRequest) -> URLRequest {
        guard let accessToken = self.accessToken else {
            print("access token is nil!")
            return urlRequest
        }
        var urlRequest = urlRequest
        print("acces token to be used: \(accessToken)\n")
        urlRequest.setValue("bearer " + accessToken, forHTTPHeaderField: "Authorization")
        return urlRequest
     }

    func should(_ manager: SessionManager, retry request: Request, with error: Error, completion: @escaping RequestRetryCompletion) {
        guard let refreshToken = keychain["refresh_token"] else {
            print("refresh token is nil!")
            return completion(false, 0.0)
        }
        print("token has expired, request new token!")
        if let response = request.task?.response as? HTTPURLResponse, response.statusCode == 401 {
            self.retrieveNewToken(refreshToken: refreshToken, request: request) { newAccessToken in
                if (newAccessToken != nil) {
                    self.accessToken = newAccessToken
                    completion(false, 0.0)
                } else {
                    completion(false, 0.0)
                }
            }
        } else {
            completion(false, 0.0)
        }
    }
```

the print that i use which is "access token to be used: asdhb37" is only called once

How do I solve this problem?  This is related to this issue #1544   I'm using swift for Ubuntu with Perfect.org  ```
Alamofire.request(url).downloadProgress { progress in
            print(Float(progress.completedUnitCount) / Float(progress.totalUnitCount))
            
            }.responseData { response in
                if let data = response.result.value {
                    self.image = UIImage(data: data)
                }
        }
```

i'm using my code like this and progress.totalUnitCount gets -1 with lots of images
any reasons?  I'm trying to upload multiple videos to the server . When I try uploading a single video, am getting a proper response from the server and uploading successfully. But when I upload multiple videos one by one am getting 500 Internal server error, adding the code below.

      func uploadVideo(index : Int){
     //dummy array contains list of URL for upload
       let dummArr = self.dummyArray.object(at: index) as! Questions

    print("upload link is",dummArr.ansVideoLnk)

    let header = ["Authorization":"{code} \(GlobalVar.interVCode)"]

      //filePathArray contains list of videoPath
       let file = self.filePathArray[index]  as! URL

    let URLL = try! URLRequest(url: dummArr.ansVideoLnk, method: .post, headers: header)
    var movieData:Data?
    do{
       // movieData =  try Data.init(contentsOf: self.filePathArray[index] as! URL, options: .alwaysMapped)

        movieData = try Data.init(contentsOf: file)


    }catch{

    }


    Alamofire.upload(
        multipartFormData: { multipartFormData in

            multipartFormData.append(movieData!, withName: "binaryContent", fileName: "file.mp4", mimeType: "video/mp4")
    },
        with: URLL,
        encodingCompletion: { encodingResult in
            switch encodingResult {
            case .success(let upload, _, _):
                upload.responseJSON { response in
                    print("response is ", response)
                    if((response.result.value) != nil) {
                        print("respnse date", response)
                        self.uploadIndex += 1
                        if self.uploadIndex < self.filePathArray.count{

                            self.uploadVideo(index: self.uploadIndex)
                        }

                    } else {

                    }
                    }

                .uploadProgress { progress in // main queue by default
                        print("Upload Progress: \(progress.fractionCompleted * 100)")

                }

            case .failure(let encodingError):
                print("failed", errno)
                print("ERROR RESPONSE: \(encodingError)")
                break
            }
    }

    )


} Perhaps if something was wrong with Alamofire, you'd receive a response with a different error code and more information rather than the 500 you are receiving now.

Do you know if the server you are uploading to supports what you are trying to do?  This question may be better for [Stack Overflow](http://stackoverflow.com/questions/tagged/alamofire) or for the maintainer of the server or application you are uploading to.  After updated the swift 3.0 of alamofire, we are start getting this issue. In previous versions of alamofire it is working fine. We have no clue on what charges are there in new moveItem method of swift 3.0. Please help us on that. ```javascript
self.request = self.backgroundManager!.download(data! as! URLConvertible, to: nil)
                .downloadProgress(queue: DispatchQueue.global(qos: .utility)) {  progress in
                    print("Progress: \(progress.fractionCompleted)")
                    DispatchQueue.main.async {
                        self.updateProgress(Int64(progress.fractionCompleted), totalBytesRead: progress.completedUnitCount, totalBytesExpectedToRead: progress.totalUnitCount)
                    }
                }
                .validate { request, response, temporaryURL, destinationURL in
                    // Custom evaluation closure now includes file URLs (allows you to parse out error messages if necessary)
                    return .success
                }
                .responseString {  response in
                    self.handleResponseOfDownload(response.response, error: response.result.error as NSError?)
            }
```

Alamofire Version - 4.2
Xcode - 8.1
iOS - 10.2 Have the same issue.   When finish download large file, move the file out of `Tmp`  directory will raise up the memory.Then the app will kill by system. I tried this with sample of Alamofire also but end result is same. @jshier 
Please help us to solve the issue ASAP. @subicura `URLSessionDownloadTask` on this have't this problem. I have to use `URLSessionDownloadTask ` to instead. @cnoon You can use download example of Alamofire  with lower end device like 1GB RAM device with following url  http://mirror.nforce.com/pub/speedtests/500mb.bin or any other url of 1GB to reproduce issue.

I will try myself also but if you have time, please look into it. @cnoon Here is my findings :- 
If we do not pass 'destination' in download statement,  like this 
```javascript 
Alamofire.download("http://mirror.nforce.com/pub/speedtests/100mb.bin", to: nil) 
```
then it is working fine.
OR 
If we comment this line in code of downloadTaskDidFinishDownloadingToURL delegate of Alamofire 
   ```Javascript  
       // try FileManager.default.moveItem(at: location, to: destinationURL)
 ```
then it also working fine. So both are the same things, comment moveItem method or pass nil as destination, things are working fine.

But if we pass destination in download statement it sparks the memory footprint and crash the app on lower end devices.

So it seems that there is some problem with 'moveItem' methods of iOS SDK. 


 
 @cnoon  Before swift 3, moeItem method is working fine as expected. @cnoon I have created one sample of URLSessionDownloadTask and there i use moeItem method and it is working fine as expected. So now it seems that there is some issue of threading or process that i m not able find-out in Alamofire. I tried to run `  try FileManager.default.moveItem(at: location, to: destinationURL)` in `DispatchQueue.main.sync` block but end result is still same. Yes @cnoon I am not able to find anything related to issue. @cnoon  Any update on this.  Hi, I'm stuck in the following situation: 1) create dictionary data 

                let subparams:[String:Any?]  = [
                    "estimate_service_id": NSNumber(value: timesheet.serviceID),
                    "work_date":timesheet.workDate as AnyObject,
                    "duration":NSNumber(value: Int(timesheet.workDuration)),
                    "description":timesheet.workDescription as AnyObject,
                    "staff_id":FPUserController.sharedInstance.getStaffId() as AnyObject,
                    "docket_id":NSNumber(value: timesheet.jobID),
                    "task_id": nil
                    ]
                let array = [subparams]
                params = [ "timesheets": array]

Resulting in following data (by debugPrint()):

`Optional(["timesheets": [["estimate_service_id": Optional(1932), "task_id": Optional(1578), "staff_id": Optional(842), "description": Optional(), "work_date": Optional(2017-01-09), "docket_id": Optional(81), "duration": Optional(1800)]]])`

And when the data is given to 

`Alamofire.JSONEncoding.default.encode(mutableURLRequest, with: params)`

Then I get the exception at 

ParameterEncoding.swift:  let data = try JSONSerialization.data(withJSONObject: parameters, options: options)

To me the data looks valid. What are possible steps to figure out what is wrong?

References: 

Apple Swift version 3.0 (swiftlang-800.0.46.2 clang-800.0.38)
pod 'Alamofire', '~> 4.2.0'
pod 'SwiftyJSON', '~> 3.0‚Äô

 I can confirm that issue does not appear starting from Apple Swift version 3.0.1 (swiftlang-800.0.58.6 clang-800.0.42.1). I think you should close this issue.   FAILURE: responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.jsonSerializationFailed(Error Domain=NSCocoaErrorDomain Code=3840 "Invalid value around character 0." UserInfo={NSDebugDescription=Invalid value around character 0.}))
  ‚ñø failure : AFError
    ‚ñø responseSerializationFailed : ResponseSerializationFailureReason Same here! üòì  I was wondering if you had any plans to do this. I realize it can be problematic when we go through swift language transitions, but that can be mitigated somewhat through version pinning. Now that things have appeared to settle a bit before Swift 4.0, I think CI servers around the world might have a collective sigh of relief. üòç Thanks for considering the feature!

I'd estimate that Alamofire takes ~30 seconds to build on our CirclCI instance. If you are interested, I can do a bit of testing and get a more accurate number. It's certainly not an eternity, but we all know the pain of that CI build never going fast enough.

I've done this a couple times before in simpler cases. If you would like any assistance, please let me know. FWIW, I was a bit off on the build time. Last CirclCI run took ~ 3 minutes for carthage to build the scheme Alamofire iOS. That's often a thought that goes through my head as I watch the CI logs. üò≠ It's taking several minutes to compile on my machine (MBP late 2015) as well, It would be great to have a prebuilt framework. I'd be happy to implement this, but this would require at least member-level privileges to the repo I believe. Let me know if I can be of assistance. Thanks @cnoon. I respect that decision.

If it changes anything for you, we just merged https://github.com/Carthage/Carthage/pull/1755 which should go a long way to addressing issues with incompatible Swift versions. In short, the new behavior is:
* If the framework has Swift in it, and
* We cannot successfully determine that it was built with a compatible Swift version (same version for now),
* We will build instead of utilizing the download.
  Which encoding should I use?   @dp4dileep Here's an example: 

``` swift             
// provide here the image that you want to upload, 
// and a value between 0 and 1 where 1 is the highest quality 
// https://developer.apple.com/reference/uikit/1624115-uiimagejpegrepresentation

    let imageData = UIImageJPEGRepresentation(image, 0.8) 

    let url = yourUrl

    Alamofire.upload(multipartFormData: { multipartFormData in
           
            multipartFormData.append(imageData!, withName: "photo", fileName: "photo.jpeg", mimeType: "image/jpeg")},

                         to: url,
                         
                         encodingCompletion: { encodingResult in
                            
                            switch encodingResult {
                                
                            case .success(let upload, _, _):
                                upload.responseJSON { response in
                                    // your implementation 
                                }
                            case .failure(let encodingError):
                                // your implementation 
                            }
     })
```  Just a note that doing a plain install will generate an error message like:

```
[!] The `testTests [Debug]` target overrides the `ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES` build setting defined in `Pods/Target Support Files/Pods-testTests/Pods-testTests.debug.xcconfig'. This can lead to problems with the CocoaPods installation
    - Use the `$(inherited)` flag, or
    - Remove the build settings from the target.

[!] The `testTests [Release]` target overrides the `ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES` build setting defined in `Pods/Target Support Files/Pods-testTests/Pods-testTests.release.xcconfig'. This can lead to problems with the CocoaPods installation
    - Use the `$(inherited)` flag, or
    - Remove the build settings from the target.

[!] The `testUITests [Debug]` target overrides the `ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES` build setting defined in `Pods/Target Support Files/Pods-testUITests/Pods-testUITests.debug.xcconfig'. This can lead to problems with the CocoaPods installation
    - Use the `$(inherited)` flag, or
    - Remove the build settings from the target.

[!] The `testUITests [Release]` target overrides the `ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES` build setting defined in `Pods/Target Support Files/Pods-testUITests/Pods-testUITests.release.xcconfig'. This can lead to problems with the CocoaPods installation
    - Use the `$(inherited)` flag, or
    - Remove the build settings from the target.
```
**Environment**
pod --version
1.1.1

ruby -v
ruby 2.3.3p222 (2016-11-21 revision 56859) [x86_64-darwin15]

**Podfile**
```
# Uncomment this line to define a global platform for your project
platform :ios, '10'

target 'test' do
  # Comment this line if you're not using Swift and don't want to use dynamic frameworks
  use_frameworks!

  # Pods for test
  pod 'Alamofire'

  target 'testTests' do
    inherit! :search_paths
    # Pods for testing
  end

  target 'testUITests' do
    inherit! :search_paths
    # Pods for testing
  end

end
```

This may be related with some issue with cocoapods that isn't yet picking the correct values for that entry (not adding on install the $(inherited) entry.
 Of notice, it is picking the correct value for the main target (albeit with a "YES" instead of a "$(inherited)", but not for the test / uitest targets.

When performing a "pod update", those settings get overwritten / redone (the xcconfig files gets recreated with the wrong values).

After a 'gem install cocoapods --pre' to install the current beta, and repeating the 'pod update' command results in the same problem.

```
pod --version
1.2.0.beta.3
```
  I've an issue on this guard
                let failureReason = "Array could not be serialized because input data was nil"
                let userInfo: Dictionary<NSObject, AnyObject> = [NSLocalizedFailureReasonErrorKey as NSObject: failureReason as AnyObject, Error.UserInfoKeys.StatusCode: response!.statusCode]
                let error = NSError(domain: Error.Domain, code: Error.Code.StatusCodeValidationFailed.rawValue, userInfo: userInfo)
                return .Failure(error)
            }
the problem is the Error type "Error.UserInfoKeys.StatusCode: response!.statusCode" and "NSError(domain: Error.Domain", how can i fix it?  Steps:

1. Create a plain one view project, select swift, compile and test (it should show a empty white simulator).
2. Pod init on the terminal on same folder as the project is
3. Edit Podfile to add "pod 'Alamofire', '~> 4.0'"
4. Pod install

Version 4.2.0 is installed and the workspace is created.

Open the workspace and you get a dialog box:

"Convert to Current Swift Syntax?"

If you hit "Later", you will get a new dialog stating that "Xcode 8 will not be able to build the target 'Alamofire'".

Selecting 'Later' again you get one error:

"Use Legacy Swift Language Version‚Äù (SWIFT_VERSION) is required to be configured correctly for targets which use Swift. Use the [Edit > Convert > To Current Swift Syntax‚Ä¶] menu to choose a Swift version or use the Build Settings editor to configure the build setting directly."

Trying to convert will produce 0 code changes, but will generate more then 800 errors.

 The fix is to just change on build settings the value of "SWIFT_VERSION" which is undefined to NO.

And everything will be fine after that. Yurp, my problem currently with CocoaPods is that version 1.1 is not compiling on my mac. Probably some leftover broken libs or gems somewhere, will sort it one day (or maybe the problem will fade away by itself soon).  Hi 
I am using the latest AF4 and for the case where the user puts in an incorrect username / password combo-  AF is returning an error which is fairly unfriendly which states: 

```Response validation failed: Response status code was unacceptable: 401.
Failure Reason: unacceptableStatusCode(401)
Response status code was unacceptable: 401
```
 - how do I get AF to return the message that says that the user's creds are "Unauthorized" 

I am using the code from the Readme. 
 That makes sense @jshier.  Thanks so much for the quick response.  

 What approach did you use to wrap?  Just running a switch after the `case: failure (let error):` to " an error message prettifier" class?
 I didn't realise that people used 401 for different errors - always learning new things with AF. 
 Thanks I have been doing a lot of reading on Alamofire after this and that looks like a great approach. 
I tried to add it as an extension to Request but I keep getting errors which don't seem to make sense
eg Dedodable is returning as unknown, despite the fact I have AF added in already
![image](https://cloud.githubusercontent.com/assets/751115/21663951/4a2ffe46-d2db-11e6-802e-397beacfc3ee.png)
 Will give it a go - massive thanks for the guidance @jshier 
Will share what I come up with - but will close this off for now. 
  Hello, In my app i use only Alamofire  for the networking.
Right now the live version of the app is using Alamofire 4.1.0 and the one waiting for review is in 4.2.0

I have noticed a significant increase on crashes in iOS 10.2.
All the crashes are related to the CFNetwork. Most of the them have reducted stack trace.

I am pasting below some sample stack traces.

Have you noticed anything similar? 
My crash free users before 10.2 were arround 99.7%, now a I am at 97.8% and I need to find the what is causing the issue

Thank you.

```
Crashed: com.apple.CFNetwork.Connection
EXC_BAD_ACCESS KERN_INVALID_ADDRESS 0x0000000000000110

Crashed: com.apple.CFNetwork.Connection
0  CFNetwork                      0x18524131c TCPIOConnection::copyProperty(__CFString const*) + 44
1  CFNetwork                      0x1851117dc SPDYConnection::_onqueue_closeStream(SPDYStream*) + 236
2  CFNetwork                      0x1851117dc SPDYConnection::_onqueue_closeStream(SPDYStream*) + 236
3  CFNetwork                      0x1851116cc ___ZN14SPDYConnection19startEnqueuedStreamEP10SPDYStream_block_invoke_2 + 28
4  libdispatch.dylib              0x1839221fc _dispatch_call_block_and_release + 24
5  libdispatch.dylib              0x1839221bc _dispatch_client_callout + 16
6  libdispatch.dylib              0x1839303dc _dispatch_queue_serial_drain + 928
7  libdispatch.dylib              0x1839259a4 _dispatch_queue_invoke + 652
8  libdispatch.dylib              0x18393234c _dispatch_root_queue_drain + 572
9  libdispatch.dylib              0x1839320ac _dispatch_worker_thread3 + 124
10 libsystem_pthread.dylib        0x183b2b2a0 _pthread_wqthread + 1288
11 libsystem_pthread.dylib        0x183b2ad8c start_wqthread + 4
```

```
Crashed: com.apple.NSURLConnectionLoader
EXC_BAD_ACCESS KERN_INVALID_ADDRESS 0x0000000012d42c68

Crashed: com.apple.NSURLConnectionLoader
0  libobjc.A.dylib                0x1904c80a0 objc_retain + 16
1  CFNetwork                      0x1921b5054 <redacted> + 240
2  CFNetwork                      0x192110ce8 <redacted> + 348
3  CFNetwork                      0x1921e5990 <redacted> + 104
4  CFNetwork                      0x1921e591c <redacted> + 36
5  CFNetwork                      0x19217b12c <redacted> + 332
6  CFNetwork                      0x19217afa0 <redacted> + 60
7  CFNetwork                      0x19217af38 <redacted> + 268
8  CFNetwork                      0x1920ecec0 <redacted> + 116
9  CFNetwork                      0x19207f110 <redacted> + 48
10 CFNetwork                      0x19207f044 <redacted> + 220
11 CFNetwork                      0x19207d3d0 <redacted> + 128
12 CFNetwork                      0x1921b48fc <redacted> + 1904
13 CFNetwork                      0x1921b40bc <redacted> + 144
14 CFNetwork                      0x1921b600c <redacted> + 28
15 libdispatch.dylib              0x1909021bc <redacted> + 16
16 libdispatch.dylib              0x19090dab0 <redacted> + 376
17 CFNetwork                      0x1922b22a8 <redacted> + 36
18 CoreFoundation                 0x191951c18 CFArrayApplyFunction + 68
19 CFNetwork                      0x1922b218c <redacted> + 136
20 CFNetwork                      0x1922b34b4 <redacted> + 312
21 CFNetwork                      0x1922b3220 <redacted> + 64
22 CoreFoundation                 0x191a26b5c <redacted> + 24
23 CoreFoundation                 0x191a264a4 <redacted> + 524
24 CoreFoundation                 0x191a240a4 <redacted> + 804
25 CoreFoundation                 0x1919522b8 CFRunLoopRunSpecific + 444
26 CFNetwork                      0x1921578f0 <redacted> + 336
27 Foundation                     0x19258ce68 <redacted> + 1024
28 libsystem_pthread.dylib        0x190b0d850 <redacted> + 240
29 libsystem_pthread.dylib        0x190b0d760 _pthread_start + 282
30 libsystem_pthread.dylib        0x190b0ad94 thread_start + 4
``` Hello, in our latest release we used the 4.2 version of Alamofire iOS 10.2 as a base SDK. 
All the CFNetwork crashes are gone!

Thanks! i'm not use Alamofire SDK(i use AFNetworking3.1),and i still got lots of this seem crashs!
<img width="914" alt="screen shot 2017-04-21 at 1 59 56 pm" src="https://cloud.githubusercontent.com/assets/5213620/25264671/fc6fdf14-269a-11e7-97ab-6b7e5356f50d.png">
 Got this crash while using Alamofire 4.4.0.
Apart from Alamofire I use Mixpanel/OneSignal/Crashlytics
I mean other libs which use network. 
Might be some issue with them but saw this posted issue in Alamofire
  

0	CFNetwork	
TCPIOConnection::copyProperty(__CFString const*) + 44
1
CFNetwork	
SPDYConnection::_onqueue_closeStream(SPDYStream*) + 236
2	CFNetwork	
SPDYConnection::_onqueue_closeStream(SPDYStream*) + 236
3	CFNetwork	
___ZN14SPDYConnection19startEnqueuedStreamEP10SPDYStream_block_invoke_2 + 28
4	libdispatch.dylib	
_dispatch_call_block_and_release + 24
5	libdispatch.dylib	
_dispatch_client_callout + 16
6	libdispatch.dylib	
_dispatch_queue_serial_drain + 928
7	libdispatch.dylib	
_dispatch_queue_invoke + 884
8	libdispatch.dylib	
_dispatch_root_queue_drain + 540
9	libdispatch.dylib	
_dispatch_worker_thread3 + 124
10	libsystem_pthread.dylib	
_pthread_wqthread + 1096   This is a follow-up on #1883 and implements my second approach explained in https://github.com/Alamofire/Alamofire/pull/1883#issuecomment-269853832.

Progress:
- [x] Add new request method which accepts both query and body parameters
- [x] Make the existing request method a convenience method for the new one
- [ ] Add new download method which accepts both query and body parameters
- [ ] Make existing download method a convenience method for the new one
- [ ] Add tests to cover the new method use cases
- [ ] Document the new method in the README  `URLRequest.setValue(_ value: String?, forHTTPHeaderField field: String)` allows taking a `nil` `value`. We should allow setting `nil` as well, as a way to remove headers that are set in `session.configuration.httpAdditionalHeaders`. I meant setting `nil` on the request level. I incorrectly thought this would remove headers set at the configuration level. After your explanation though it makes sense that it wouldn't remove them. Thanks!  This adds the feature requested in #374 to Alamofire in a backwards-compatible and (hopefully) clean way. I'd love to hear feedback on this approach. The usage would be as simple as this:

```swift
let queryUrl = QueryURL(url: urlString, parameters: ["lorem": "ipsum"])
let bodyParameters = ["foo": "bar"]
Alamofire.request(queryUrl, method: .post, parameters: bodyParameters, encoding: JSONEncoding.default).response // ...
```

Progress:

- [x] Implement support for both query and body parameters
- [x] Write test to ensure the feature survives future changes
- [ ] Add a section to the README explaining this feature This is an interesting approach, but I agree that this is similar to what is already achievable.
@jshier That was one of the solutions I was considering actually. The problem is that you can still pass parameters into the `request()` functions. So if you pass an `encoding` of this new multiple encoding type with parameters given to it, and you also pass parameters to the `request()` function, what happens then? The only way this would make sense to me would be if we removed the `parameters` parameter from the `request()` functions and instead made people pass the parameters to the `ParameterEncoding` struct. But this seems to complicate the API a bit.

Another option I have considered is adding a `queryParameters` parameter to all request creation methods. This would make `URLEncoding.Destination.queryString` redundant, so we would likely want to deprecate it. Since we would be using `queryParameters` for encoding in the url, `URLEncoding` would now only be used to setting the query string in the `httpBody` This seems simple to implement and easy to use, however it may make the `parameter`parameter confusing. Maybe we could rename it to `bodyParameters`. This would require a major version release and an API breaking change, which isn't ideal.

Example:

````swift
    open func request(
        _ url: URLConvertible,
        method: HTTPMethod = .get,
        queryParameters: Parameters? = nil,
        parameters: Parameters? = nil,
        encoding: ParameterEncoding = URLEncoding.default,
        headers: HTTPHeaders? = nil)
        -> DataRequest
```` I'm not a fan of the idea of **changing** the request methods parameters to include `queryParameters` and `bodyParameters`, it communicates to the Alamofire API user that he should split his data into query and body parameters ‚Äì which may not be needed for many APIs and just adds clutter to the method interface for those. So I think the old method should be kept.

Instead I suggest adding a new method and **keeping the old one as a convenience method**. This would result to something like this:
```swift
// new convenience method, note that I also changed 'encoding' to 'bodyEncoding'
open func request(
        _ url: URLConvertible,
        method: HTTPMethod = .get,
        queryParameters: Parameters?,
        bodyParameters: Parameters? = nil,
        bodyEncoding: ParameterEncoding = URLEncoding.default,
        headers: HTTPHeaders? = nil)
        -> DataRequest

// old method, unchanged
open func request(
        _ url: URLConvertible,
        method: HTTPMethod = .get,
        queryParameters: Parameters? = nil,
        parameters: Parameters? = nil,
        encoding: ParameterEncoding = URLEncoding.default,
        headers: HTTPHeaders? = nil)
        -> DataRequest
```

That way this would also not be a breaking change and we could add it immediately without any annoyances for the users of Alamofire. I've just posted #1185 which implements my recent suggestion. What do you think?

If you like the approach I'd be glad to implement the next steps described in the PR (e.g. adding such a method for the `download` request, too).  Following is my request:

 ```
Alamofire.request(url, method: .get, parameters: params, encoding: JSONEncoding.default)
 .responseJSON(completionHandler: { (response) in
     switch response.result {
     case .success(let retrivedResult):
         print(retrivedResult)
//         success(brandTags)
         break
     case .failure(let errorGiven):
         print(errorGiven)
         print(String(data: response.data!, encoding: String.Encoding.utf8) ?? "")
         failure(APICaller.parseErrorAndGiveMessage(givenError: errorGiven as NSError))
         break
     }
 })
```

When I encode the parameters as JSONEncoding.default as above, the request always times out with following in my logs:

```
2016-12-27 12:22:41.425948 xyz[5140:133008] [] nw_endpoint_flow_service_writes [2.1 35.164.98.40:80 ready socket-flow (satisfied)] Write request has 4294967295 frame count, 0 byte count
2016-12-27 12:23:41.485534 xyz[5140:133041] [] nw_endpoint_flow_service_writes [2.1 35.164.98.40:80 ready socket-flow (satisfied)] Write request has 4294967295 frame count, 0 byte count

Error Domain=NSURLErrorDomain Code=-1001 "The request timed out." UserInfo={NSUnderlyingError=0x60000024a9b0 {Error Domain=kCFErrorDomainCFNetwork Code=-1001 "(null)" UserInfo={_kCFStreamErrorCodeKey=-2102, _kCFStreamErrorDomainKey=4}}, NSErrorFailingURLStringKey=http://xyz-beta.abc.com/v1/brands/1a1/notifications, NSErrorFailingURLKey=http://xyz-beta.abc.com/v1/brands/1a1/notifications, _kCFStreamErrorDomainKey=4, _kCFStreamErrorCodeKey=-2102, NSLocalizedDescription=The request timed out.}
2016-12-27 12:23:41.488336 xyz[5140:133868] [] __tcp_connection_write_eof_block_invoke Write close callback received error: [89] Operation canceled
```

But when I remove the parameter encoding like below, the request completes properly without any problem.

```
Alamofire.request(url, method: .get, parameters: params)
     .responseJSON(completionHandler: { (response) in
         switch response.result {
         case .success(let retrivedResult):
             print(retrivedResult)
    //         success(brandTags)
             break
         case .failure(let errorGiven):
             print(errorGiven)
             print(String(data: response.data!, encoding: String.Encoding.utf8) ?? "")
             failure(APICaller.parseErrorAndGiveMessage(givenError: errorGiven as NSError))
             break
         }
     })
```

What is the making the difference? I have updated the code sample in question. Please have a look.  Is there a chance [ Swift Package manager ](https://github.com/apple/swift-package-manager) could be added as installation option next to Carthage and pod? check this https://github.com/Alamofire/Alamofire/issues/1544 @jshier: on that note, can we figure out whats going wrong with https://github.com/Alamofire/Alamofire/issues/1815?
I think the spm integration is broken right now, and that probably needs to be fixed before documentation to use it can be written 

EDIT: Scratch that, I just tested out `swift package update` on Moya, and it was working! I'll go ahead and close #1815 as well too. Something must have been fixed üòÑ  Looks good to me. It looked very easy and plain to use from other tutorials that I have seen. Until now I was not a fan of pod because of the workspace it creates and was using Carthage. But SPM looks promising. I hope to be able to use it for most packages in the near future :)   Are there any beginner issues I can help with?  responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.inputDataNilOrZeroLength)   i'm using swift 3 & xcode 8.2 beta with alamofire last version from cocoapods, 
api is from our team : http://xxxxxxxxxxxxxxxx/api/v1/users

when i used alamofire it's headache me for 3 days trying post data to api but showing me 422 code error , i use native http request that one built in swift 3 it's working fine .

i spend 3 days for error that is bug from your library , 


for more details feel free to contact me . 
i hope you fix it as much as possible  can you provide example repo or code , what's the issue ?

and for error code 422 means 

422 Unprocessable Entity
   The 422 (Unprocessable Entity) status code means the server
   understands the content type of the request entity (hence a
   415(Unsupported Media Type) status code is inappropriate), and the
   syntax of the request entity is correct (thus a 400 (Bad Request)
   status code is inappropriate) but was unable to process the contained
   instructions.  For example, this error condition may occur if an XML
   request body contains well-formed (i.e., syntactically correct), but
   semantically erroneous, XML instructions.  I was wondering what the purpose of `URLParameterEncoding.default` is. It isn't a singleton allowing for sharing a single instance of a `URLParameterEncoding`. Likewise, initializing a `URLParameterEncoding` with default options seems to be better served by just calling the initializer with no parameters. This pattern also applies to `JSONEncoding` and `PropertyListEncoding`. Thanks for the response, @jshier!

I don't think the performance penalty of creating a `URLParameterEncoding` is too big of a deal. It more just caught me off guard when I wrote a unit test that essentially amounted to `URLParameterEncoding.default === URLParameterEncoding.default` and it failed. I had mistakenly assumed it was a singleton. When I dug into it I was curious what the reasoning was because it seemed like `URLParameterEncoding()` would be more idiomatic to create a new instance with default values. I figured it might be a legacy purpose. Thanks for satisfying my curiosity!  Using Alamofire 4.2.0 (in Xcode 8.2.1 on macOS 10.12.2) like so:

```swift
Alamofire.request(fullPath, method: httpMethod(for: action), parameters: parameters, encoding: JSONEncoding.default, headers: headers).responseJSON { dataResponse in
    // some code
    print(dataResponse.debugDescription)
}
```

I'm getting the following output:

```console
[Request]: https://my.webservice.net/api/v1/people
[Response]: <NSHTTPURLResponse: 0x618000033420> { URL: https://my.webservice.net/api/v1/people } { status code: 404, headers {
    Connection = "keep-alive";
    "Content-Encoding" = gzip;
    "Content-Type" = "text/html; charset=utf-8";
    Date = "Thu, 22 Dec 2016 09:11:54 GMT";
    Server = nginx;
    "Transfer-Encoding" = Identity;
    "X-Request-Id" = "32f6de11-52b6-4357-878e-1a52467b1d5a";
    "X-Runtime" = "0.306651";
} }
[Data]: 119035 bytes
[Result]: FAILURE: responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.jsonSerializationFailed(Error Domain=NSCocoaErrorDomain Code=3840 "Invalid value around character 0." UserInfo={NSDebugDescription=Invalid value around character 0.}))
[Timeline]: Timeline: { "Request Start Time": 504090714.667, "Initial Response Time": 504090714.998, "Request Completed Time": 504090714.999, "Serialization Completed Time": 504090714.999, "Latency": 0.331 secs, "Request Duration": 0.332 secs, "Serialization Duration": 0.000 secs, "Total Duration": 0.332 secs }
```

As you can see there's plenty of information about the response, result, timeline ‚Äì the data is stripped, which is IMHO a good idea. But what I'm really missing here is **the info about the HTTP method** that was used  to send a request to the **requested URL**, which is the **only information about the request**. As many APIs have several endpoints for the same URL (differing in the HTTP method) the current information will not be helpful to debug issues with log files.

For example we could change the current output to something like this (analogous to the Timeline):

```console
[Request]: Request { url: "https://my.webservice.net/api/v1/people", method: "PATCH" }
[Response]: [...]
```

We could of course think about adding parameters to the debug info, too. But that's out of scope of this issue, I'm explicitly asking for the HTTP method here. Thanks for the PR! üëç   One of my application use alamofire, and i would like to update it.
This time i have this error when i try to validate the archive on Xcode : 

`Archive validation failed due to the issues listed below.`
`iTunes Store operation failed.
No suitable application records were found. Verify your bundle identifier 'org.alamofire.Alamofire'`

Can anyone help me ?
Thanks  Hello,

After upgrading to Xcode 8, Swift 3 I can build the app, but it crashes when I try to run it:
```
library not loaded: @rpath/Alamofire.framework/Alamofire
  Referenced from: /var/containers/Bundle/Application/EC3CE17C-A31E-4052-ABC8-A7526028490B/SomeApp.app/SomeApp
  Reason: image not found
```

I have tried several suggestions, but nothing handles it.  It happens both on a physical iPad and on the simulator (iPad Air 2).

Alamofire is included under Embedded Binaries as well as Linked Frameworks and Libraries in the General Tab:

![general](https://cloud.githubusercontent.com/assets/9595654/21370043/b4eb5056-c6be-11e6-8957-a5dd408768aa.jpg)

Here is the Build Phases tab:
![buildphases](https://cloud.githubusercontent.com/assets/9595654/21370178/5fcfeaae-c6bf-11e6-9c1e-510c8bbfaa73.jpg)

Is there anything else required for Alamofire?

Thanks.
 Is there anyone with a solution or suggestion to this? I have not upgraded any of our code and this gives me concern regarding the failure possibilities should an upgrade be attempted.

It would be very helpful should there be a workable solution from someone. I'm looking forward to a solution for this for my own projects. I would appreciate it. Bump.  Some help with this would be great...  I'm try to download file using https protocol the file download success but the progress is return 0.0 

if I use http it works fine :/  can you describe your problem by providing  some code , that's not  working. let headers = ["User-Agent": "LoLSum-iOS-90a0142e"]       
 Alamofire.request("https://api.lolsummoners.headlezz.net/v2/champions/en/0",headers:headers)
            .downloadProgress { progress in
                print(progress.fractionCompleted)
                print(progress)
                self.loadingProgress.setProgress(Float(progress.fractionCompleted), animated: true)
            }


<img width="662" alt="screen shot 2016-12-28 at 6 06 38 pm" src="https://cloud.githubusercontent.com/assets/6974081/21525872/a86ac7ec-cd28-11e6-8262-3d8ca422387a.png">
 http://serverfault.com/questions/629096/the-content-length-header-does-not-exist  Downloaded 4.2.0, compiled the iOS framework (Xcode 8.2.1), added the framework to my project ('Embedded Binaries', 'Linked frameworked and binaries')

import Alamofire

Alamofire.request("https://httpbin.org/get").responseJSON { response in
            // blah
})

Build fails with Module 'Alamofire' has no member named 'request''

Please fix.

Thanks
 I have the same problem with a project I just spent 3 days converting from Swift 2.3 to 3.0 and now the only issue getting it to run is Alamofire. 

I have Module 'Alamofire' has no member named 'SessionManager', undeclared type 'URLConvertible', 'DataResponse','JSONEncoding','URLEncoding'.....   All the updates, it's as if 3.0 is still there or the module isn't really getting imported at all.  small change on download part,  I try to fix link of 'Download File Destination'  > This allows you to rebuild the responses if necessary in client code to do things like wrap the error in your own custom error or modify the server data or possibly inject a missing header, etc. The main use case is to wrap the error.

Side note: https://github.com/Alamofire/Alamofire/pull/1836 also addresses error handling, maybe in a superior way: DataResponse.map and DataResponse.flatMap do recreate new responses that wrap a new result or a new error, but without exposing public initializers:

```swift
Alamofire.request("https://httpbin.org/get").responseJSON { response in
    // Here response is DataResponse<[String:Any]>,
    // and stuffResponse is DataResponse<Stuff>:
    let stuffResponse = response.flatMap { json in try Stuff(json: json) }
}
```

Besides, preserving responses' metrics is only possible with internal APIs (see https://github.com/Alamofire/Alamofire/pull/1836/files#diff-0532e61b339db1c06287f9110afe7dfcR147).

It's not that I want to push my #1836 at all cost. I just want to say that it addresses response transformations in a way that prevents the complex initializers from bubbling up into the public API. @jshier That's perfectly clear. I just saw an opportunity to explain some uses of the functional approach which can be overlooked - since #1836 had no feedback whatsoever. Now I'm *not* a functional guru/evangelist/lobbyist - I'm a regular imperative developer, and certainly don't want to force abstract functional cathedrals down into anyone's throat. #1836 is actually pretty narrow.

Now the use cases exposed by @cnoon are *not* straightforward: injecting headers, modifying server data, etc. That looks pretty advanced to me.

On the other side, map/flatMap are a concise syntax for a very common use case, which is to turn server data into application types, while preserving errors and response metadata. The map/flatMap idioms are, I think, simpler than extensions that [custom response serialization](https://github.com/Alamofire/Alamofire#custom-response-serialization) requires today. And they blend naturally in the map/flatMap landscape that Swift already brings with optionals and collections.

Maybe give a look at #1836 some day? You may eventually find it useful.    Hey there,

In my app, I need to do requests to services with urls including special characters like {,[,],}. However Alamofire crashes when I pass the url with those characters.  I tried to make a basic encoder, but even when I encode these characters, it still crash. How do I use those characters in url?

Here is my encoder:
```
func myurlencoder(url :String) -> String{
    
    var returnUrl = url
    
    let myDict = [
        
        "{" : "%7B",
        "}" : "%7D",
        "[" : "%5B",
        "]" : "%5D",
        "\"" : "%22"
    ]
    
    for (key,value) in myDict{
        returnUrl = returnUrl.stringByReplacingOccurrencesOfString(key, withString: value)
    }
    
    return returnUrl
}
```

I get "fatal error: unexpectedly found nil while unwrapping an Optional value" error on 

`public protocol URLStringConvertible`

in 

```
func URLRequest(
    method: Method,
    _ URLString: URLStringConvertible,
    headers: [String: String]? = nil)
    -> NSMutableURLRequest
{
    let mutableURLRequest = NSMutableURLRequest(URL: NSURL(string: URLString.URLString)!) //ERROR IN THIS LINE
    mutableURLRequest.HTTPMethod = method.rawValue

    if let headers = headers {
        for (headerField, headerValue) in headers {
            mutableURLRequest.setValue(headerValue, forHTTPHeaderField: headerField)
        }
    }

    return mutableURLRequest
}
```  Greetings,

I found an issue in the Cocoapods for v4.2.0 where the minimum iOS SDK version support is set to iOS 8.0 where the codes is available in iOS 9.0.0 in the SessionDelegate.swift for Watch OS

![screen shot 2016-12-19 at 9 42 20 am](https://cloud.githubusercontent.com/assets/9997430/21298727/8d92cd44-c5cf-11e6-9f16-619475d1982a.png)
  #Error 1:
Static member 'defaultHTTPHeaders' cannot be used on instance of type 'SessionManager'
var defaultHeader = Alamofire.SessionManager.default.defaultHTTPHeaders


#Error 2: extra param 'method' in call
Alamofire.request(URLConvertible, method: HTTPMethod, parameters: Parameters?, encoding: ParameterEncoding, headers: HTTPHeaders?) Update on #Error 1:
This is a statement/line, i copied from main page of Alamofire source, as a part of header customization. But when i build the same statment in my project, it's showing me an error Static member 'defaultHTTPHeaders' cannot be used on instance of type 'SessionManager'.
var defaultHeader = Alamofire.SessionManager.default.defaultHTTPHeaders
Pl. look at these statements, available on source code page.
-----------
Modifying the Session Configuration

var defaultHeaders = Alamofire.SessionManager.default.defaultHTTPHeaders
defaultHeaders["DNT"] = "1 (Do Not Track Enabled)"

let configuration = URLSessionConfiguration.default
configuration.httpAdditionalHeaders = defaultHeaders

let sessionManager = Alamofire.SessionManager(configuration: configuration)

---------------------------------------------------


Update on #Error 2:
It's not a Stackoverflow question. It's an Alamofire source bug. When you start writing "Alamofire.request("

it will show/allow you to add these many params, "String URL Convertible", method: <Alamofire.HTTPUrlMethod>, parameters: parameters, encoding:URLEncoding.default, headers: header

But when you compelete this line and build, it shows an error like extra parameter in arguments/call. ![screen shot 2016-12-19 at 9 48 25 am](https://cloud.githubusercontent.com/assets/16011224/21301103/64e2f8be-c5d0-11e6-9ca8-0dd5ec69e720.png)
 Please look at this snapshot, it may give you an exact idea about what's my query.  I'm developing a get method with parameters by Alamofire 4.0 version
The method I am using is below : 
`Alamofire.request("http://host/api/deals/?keywod=ÌïúÍ∏Ä", method: .get,  encoding: JSONEncoding.default).responseJSON `

ÌïúÍ∏Ä is a korean word. It fails to get a response compared to have an english keyword with a successful response.

Is there anything I can solve this problem?  Alamofire.request("String URL Convertible", method: <Alamofire.HTTPUrlMethod>, parameters: parameters, encoding:URLEncoding.default, headers: header).responseJSON { (response) in 

Showing an error as extra parameters <Alamofire.HTTPUrlMethod> in request.

Xcode 8.2 Hi jshier, It's not a Stackoverflow question. It's an Alamofire source bug. When you start writing "Alamofire.request("

it will show/allow you to add these many params, "String URL Convertible", method: <Alamofire.HTTPUrlMethod>, parameters: parameters, encoding:URLEncoding.default, headers: header

But when you compelete this line and build, it shows an error like extra parameter in arguments/call.  Often (especially when debugging) a server will respond with detailed error messages (often including stack traces, etc.) when serving a 400 or 500; when using `validate(200..<300)` (or similar) all that Alamofire gives in the error is, e.g. ```ResponseValidationFailureReason.unacceptableStatusCode(400)```.

It would be nice to see the server response body in this error type as well. Any update on this?  I've just started using Moya and got bitten by this. same here. I am also gettting 400 status code ..not not getting the reason why this is coming. I tried a,, the option for eating. +1 @jshier I'm not sure I understand, what sort of problems would a very large response body create in the case of e.g. a 500?

(Also, I have never encountered an API which returns very large bodies for errors.  Is that common enough that it should justify design decisions which affect all users of Alamofire?) Could you provide an example of that?  i want encode image to base64 string and send it via POST method
i got an error "invalide value around charactor 0."
any solution?  In `SessionManager.allowRetrier()` the [timeDelay supplied by the request retrier](https://github.com/Alamofire/Alamofire/blob/master/Source/SessionManager.swift#L869) is not honored. 
This code path is hit when a request fails due to an `AdaptError`.
Alamofire v4.2.0

  I'm sending serial post http request to php script for database . 
using for in loop method 
for _ in 1 ... 1000 
It works great but suddenly it stops sending requests after while when i checked with charles  I am developing a Today extension. From within the extension I want to perform some of the api calls I perform on the app container.

In the extension, I have access to token and I replicated the App Transport Security from the app container in its plist. However, the sames successful calls I make on the app container do not work on the app extension.

The error is ` NSURLErrorDomain Code=-999 "cancelled"`, and the following are the same to both app extension and app container.

```
<key>NSAppTransportSecurity</key>
    <dict>
        <key>NSExceptionDomains</key>
        <dict>
            <key>the_api_ip</key>
            <dict>
                <key>NSIncludesSubdomains</key>
                <true/>
                <key>NSTemporaryExceptionAllowsInsecureHTTPLoads</key>
                <true/>
                <key>NSTemporaryExceptionMinimumTLSVersion</key>
                <string>TLSv1.0</string>
                <key>NSTemporaryExceptionRequiresForwardSecrecy</key>
                <false/>
            </dict>
        </dict>
    </dict>
```

```
var manager: Alamofire.SessionManager = {

        // Create the server trust policies
        let serverTrustPolicies: [String: ServerTrustPolicy] = [
            "the_api_ip": .pinCertificates(
                certificates: ServerTrustPolicy.certificates(),
                validateCertificateChain: false,
                validateHost: true
            ),
        ]

        // Create custom manager
        let configuration = URLSessionConfiguration.default
        configuration.httpAdditionalHeaders = Alamofire.SessionManager.defaultHTTPHeaders
        let manager = Alamofire.SessionManager(
            configuration: URLSessionConfiguration.default,
            serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies)
        )

        return manager
    }()
```

Is there a reason such code will not work on the Today Extension. Perhaps, I have to make some extra configuration for the Today Extension.

I am using `Alamofire 4.2`

Thanks for the help! I am also facing the same issue tried with the latest Alamofire Library. Still not fixed. I have a similar issue @cnoon . I've pinpointed why my requests are not working. The request are going through to my server however the response is always 500. The  problem is with the cookies. I am using session key to identify the user. While all the cookies , especially the cookie containing the session key are accessible in the container app, the same code in the Today Extension does not return the cookie containing the session key. I've gone through the git repo and as I see it, the default session configuration uses a persistent disk-based cache and stores credentials in the user‚Äôs keychain. Could it be that Alamofire can't access the disk in Extension? 

Any help would be appreciated on how to resolve this issue. Thanks. And sorry for posting this during the holidays.  :P  @cnoon 
It's not able to pick up sever trust policies properly.
`
class NetworkManager {

    var manager: SessionManager?

    init() {

        let policies:[String:ServerTrustPolicy]=[
            "https://xyz.com": .disableEvaluation
        ] 
    manager=Alamofire.SessionManager(serverTrustPolicyManager:ServerTrustPolicyManager(policies:policies))

    }
}`

I am trying to blindly trust a server so that no ssl evaluation take place.
The same thing i am doing using NSURLSession.

`func urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
        
        
        if (challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust) {
            if (challenge.protectionSpace.host == "xyz.com") {
                let credential = URLCredential(trust: challenge.protectionSpace.serverTrust!)
                completionHandler(.useCredential, credential)
            }
        }
        
    }`

  I'm using a token-based authentication for my client app, but Alamofire doesn't sends authorization headers when following redirects so the server responds `Forbidden`

When I try sending this request manually from `postman` or even `curl` command in terminal, everything works as well, so what should I do with that problem?

I'm using Alamofire 4.0 and swift 3  May I ask what is the reasoning behind not allowing JSONEncoding with `GET`?  I was so sure that I created a test project to send you and prove myself correct, but it turns our you are correct. So the explanation must be that either my API server or AWS ELB discard message bodies on get requests. 
Thanks @cnoon .  Hello, I am receiving crash reports of some users that cannot get any request correctly done. I have tested in lots of devices without finding one to personally test it and I have no clue on what should be happening. Using Alamofire 3.5.1

I am getting some 1 star reviews because of this and would like to find a solution. Could anybody help me?

All I can see is this:

<img width="1427" alt="captura de pantalla 2016-12-14 a las 18 14 54" src="https://cloud.githubusercontent.com/assets/5667171/21192686/b1d8af42-c229-11e6-9222-e2c08ef0abbc.png">
 @cnoon here is the code I'm using to make requests. Execute function creates de requests and processRequest calls Alamofire responseJSON function:

`

    override func execute(completion: (response: Response<T>?, error: ErrorType?) -> Void) {
        let managerId = NSUUID().UUIDString
        // Create a new manager for each request to customize its request header
        let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
        configuration.HTTPAdditionalHeaders = buildHeaders()
        let manager = Alamofire.Manager(configuration: configuration)
        managerStore[managerId] = manager

        let encoding = isBody ? Alamofire.ParameterEncoding.JSON : Alamofire.ParameterEncoding.URL
        let xMethod = Alamofire.Method(rawValue: method)
        let fileKeys = parameters == nil ? [] : parameters!.filter { $1.isKindOfClass(NSData) }
                                                            .map { $0.0 }

        if fileKeys.count > 0 {
            manager.upload(
                xMethod!, URLString, headers: nil,
                multipartFormData: { mpForm in
                    for (k, v) in self.parameters! {
                        switch v {
                        case let fileURL as NSURL:
                            mpForm.appendBodyPart(fileURL: fileURL, name: k)
                            break
                        case let data as NSData:
                            mpForm.appendBodyPart(data: data, name: k, fileName: "image.jpg", mimeType: "image/jpg")
                            break
                        case let string as NSString:
                            mpForm.appendBodyPart(data: string.dataUsingEncoding(NSUTF8StringEncoding)!, name: k)
                            break
                        case let number as NSNumber:
                            mpForm.appendBodyPart(data: number.stringValue.dataUsingEncoding(NSUTF8StringEncoding)!, name: k)
                            break
                        default:
                            fatalError("Unprocessable value \(v) with key \(k)")
                            break
                        }
                    }
                },
                encodingMemoryThreshold: Manager.MultipartFormDataEncodingMemoryThreshold,
                encodingCompletion: { encodingResult in
                    switch encodingResult {
                    case .Success(let upload, _, _):
                        self.processRequest(upload, managerId, completion)
                    case .Failure(let encodingError):
                        completion(response: nil, error: encodingError)
                    }
                }
            )
        } else {
            processRequest(manager.request(xMethod!, URLString, parameters: parameters, encoding: encoding), managerId, completion)
        }
    }

    private func processRequest(request: Request, _ managerId: String, _ completion: (response: Response<T>?, error: ErrorType?) -> Void) {
        if let credential = self.credential {
            request.authenticate(usingCredential: credential)
        }

        request.validate().responseJSON(queue: dispatch_queue_create("com.sergiocg90.manager-response-queue", DISPATCH_QUEUE_CONCURRENT) ,options: .AllowFragments) { response in
            managerStore.removeValueForKey(managerId)

            /* Added to register status codes */
            if request.response?.statusCode >= 400 {
                let error = NSError(domain: (request.response?.URL?.URLString)!, code: (request.response?.statusCode)!, userInfo: nil)
                dispatch_async(dispatch_get_main_queue()) {
                    completion(response: nil, error: error)
                }
                return
            }

            if response.result.isFailure {
                dispatch_async(dispatch_get_main_queue()) {
                    completion(response: nil, error: response.result.error)
                }
                return
            }

            if () is T {
                dispatch_async(dispatch_get_main_queue()) {
                    completion(response: Response(response: response.response!, body: () as! T), error: nil)
                }
                return
            }
            if let json: AnyObject = response.result.value {
                let body = Decoders.decode(clazz: T.self, source: json)
                dispatch_async(dispatch_get_main_queue()) {
                    completion(response: Response(response: response.response!, body: body), error: nil)
                }
                return
            } else if "" is T {
                dispatch_async(dispatch_get_main_queue()) {
                    completion(response: Response(response: response.response!, body: "" as! T), error: nil)
                }
                return
            }
            dispatch_async(dispatch_get_main_queue()) {
                completion(response: nil, error: NSError(domain: "localhost", code: 500, userInfo: ["reason": "unreacheable code"]))
            }
        }
    }`

That execute function is called by this other one:

`

    public class func getServerInfo(id id: Int32, completion: ((data: MyDataClass?, error: ErrorType?) -> Void)) {
        getServerInfoWithRequestBuilder(id: id).execute { (response, error) -> Void in
            completion(data: response?.body, error: error);
        }
    }


`  I was having problems with Alamofire 4.2.0. After updating my Frameworks with Cocoapods I started getting this error, while trying to run application on device (not simulator). I spend two hours searching about, where I have problem with my App Identifier.. 
And after I opened my Device log to find error and there it was:

[MIBundle _validateWithError:]: 44: Bundle at path /private/var/........../Frameworks/Alamofire.framework did not have a CFBundleIdentifier in its Info.plist

After deleting Alamofire and clearing Derived data folder, I was able to run my app again on physical device.

So there seems to be some problems? Anyone else? I also have that problem

I can't upload app to store 

When i try to upload to AppStore 

"No suitable application records were found. Verify your bundle identifier 'org.cocoapods.Alamofire" I am still working on finding solution on this, because I have lots of classes using Alamofire Framework in my project. 
Till now the only way to run project on my phone was to delete all pods and re-install Cocoapods, clearing derived data folder and project to get rid of all Alamofire files... 
 I already fix that problem go to project Pods > Target Alamofire > Signing tap > enable Automatically manage signing  Already tried, but no luck.. Seems that my problem is somewhere else.  update README.md to fix URLConvertible example issue  I used to use this script to log response

```
response { request, response, data, error in
            guard let response = response else {
                if let path = request?.URL?.absoluteString, description = error?.localizedDescription {
                    print("XXX \(path): \"\(description)\"")
                }
                return
            }
            
            guard let path = response.URL?.absoluteString else {
                return
            }
            
            if let data = data, body = NSString(data: data, encoding: NSUTF8StringEncoding) where level == .Verbose {
                print("\(response.statusCode) \(path): \"\(body)\"")
            } else {
                print("\(response.statusCode) \(path)")
            }
        }
```

But after i have updated the new version of alamofire which is 4 it's getting an error
`Cannot call value of non-function type 'HTTPURLResponse?'`

Any help would be appreciated  What I would like to achieve: some of the requests my app has to make need to include a JWT; I would like to avoid that two requests are being made which both need the JWT and therefore first request a new JWT from the server (resulting in two tokens). If I can be sure that there's only one request at a time, I can avoid this (e.g. in combination with the new Request Adapter). thanks for your response!

But are you keeping a flag somehow to check if a JWT-request is already running? My problem is the following:

If two requests, A and B are started in short sequence and both need the JWT header, then both will fail. With the `RequestRetrier` both will start new and - as we don't have a valid JWT - request one. So two JWT are requested at the same time. That means I need some kind of semaphore or how did you avoid this?  Since I install Xcode 8.2 I can't build my app anymore. I have this message 

‚ÄúUse Legacy Swift Language Version‚Äù (SWIFT_VERSION) is required to be configured correctly for targets which use Swift. Use the [Edit > Convert > To Current Swift Syntax‚Ä¶] menu to choose a Swift version or use the Build Settings editor to configure the build setting directly.

Is there a way to fix this?

Thanks for your help
 Thanks! It worked! ;-) please give a sample!
 pod 'Alamofire', '~> 4.0'

Fixed the problem I'm having the same issue as the OP here.

Anyone have anymore ideas on this topic?  The above comments don't seem to be working for me.  Jshier is probably correct, and I'm probably doing something wrong. 

I tried adding:

config.build_settings['SWIFT_VERSION'] = '3.0'

... to my podfile, but it isn't fixing the issue. oh, I find true way fix the same problem:
1. Build settings -> search swift, choice use legacy swift language version
2. Toggled no to yes -> build. You will get more error.
3. Back toggled yes to no. build -> success! https://forums.developer.apple.com/thread/69340
Toggling the "Use Legacy Swift Language Version" setting from "no" to "yes" and "yes" to "no"  did the trick for me.  Potential fix for issue #1839.  ### Implementation sample: 
``` swift
let parameters = [
			"uid": "12DE3BEB-C088F467E5F1-D1AF-44C8-AD01",
			"memories": [
				["foo": "bar"],
				["foo": "baz"]
			]
		] as [String : Any]
		
		Alamofire.request("http://api/endpoint",
			method: .post,
			parameters: parameters,
			encoding: URLEncoding.default).responseJSON { (response) in
				if let JSON = response.result.value as? [String: Any] {
					print("JSON: \(JSON)")
					let response = NPDResponse(with: JSON)
					return completion(response)
				}
				
				completion(nil)
		}
```

### Actual formatted query :
```
memories[][foo] bar
memories[][foo] baz
uid	12DE3BEB-C088F467E5F1-D1AF-44C8-AD01
```

### Expected formatted query : 
```
memories[0][foo] bar
memories[1][foo] baz
uid	12DE3BEB-C088F467E5F1-D1AF-44C8-AD01
```  Other pods works fine, but Alamofire's  not.How to fix it?    Hello,

This pull request addresses #1072.

It contains:

- Three new Result methods: `unwrap`, `map`, and `flatMap`.
- Two new DataResponse and DownloadResponse methods: `map` and `flatMap`.
- Tests for Result
- Inline documentation

It does not contain:

- Tests for DataResponse and DownloadResponse, because I don't quite know where to put them
- Documentation in README.md, because I prefer waiting for your feedback

### Result.unwrap

`unwrap` returns a result's success value, or throws its failure error:

```swift
let result: Result<Data> = ...
try result.unwrap() // Data
```

### Result.map

`map` transforms the success value of a result, while preserving its eventual failure error. Its closure argument must not throw any error:

```swift
let result: Result<Data> = ...
result.map { $0.count } // Result<Int>
```

### Result.flatMap

`flatMap` transforms the success value of a result, while preserving its eventual failure error, and catches eventual transformation error:

```swift
let result: Result<Data> = ...
result.flatMap { try JSONSerialization.jsonObject(with: $0) } // Result<Any>
```

It is worth noting that the proposed flatMap method does not strictly follow the rules of functional programming, because its closure argument does not return another Result. Instead, its closure returns a regular value, and can throw. That's because in Swift, throwing methods are more fundamental than the `Result` type, and the sample code above looks like it is the right thing to do. Besides, users who use Result extensively can still use the unwrap method in their flatMap closures:

```swift
func f(_ data: Data) -> Result<Int> { ... }
let result: Result<Data> = ...
result.flatMap { try f($0).unwrap() } // Result<Int>
```

### DataResponse and DownloadResponse

Their `map` and `flatMap` methods apply `map` and `flatMap` to their result, while preserving all other information (requests, timelines, etc.).

They make it easier to perform ad-hoc deserializations, when extending Alamofire with a full-fledged DataResponseSerializer is not worth it.

```swift
func getStuff(_ completionHandler: @escaping (DataResponse<Stuff>) -> Void)) {
    Alamofire.request("https://httpbin.org/get").responseJSON { response in
        completionHandler(response.flatMap { JSON in
            return try Stuff(with: JSON)
        })
    }
}

getStuff { response in
    print(response.request)  // original URL request
    print(response.response) // HTTP URL response
    print(response.data)     // server data
    print(response.result)   // result of response serialization

    if let stuff = response.result.value {
        print("stuff: \(stuff)")
    }
}
```

---

What do you think?
 cc @KingOfBrian, @cnoon, @jshier My introduction of `flatMap` deserves an update. I wrote:

> `flatMap` transforms the success value of a result, while preserving its eventual failure error, and catches eventual transformation error:
> 
> ```swift
> let result: Result<Data> = ...
> result.flatMap { try JSONSerialization.jsonObject(with: $0) } // Result<Any>
> ```
> 
> It is worth noting that the proposed flatMap method does not strictly follow the rules of functional programming, because its closure argument does not return another Result. Instead, its closure returns a regular value, and can throw. That's because in Swift, throwing methods are more fundamental than the `Result` type, and the sample code above looks like it is the right thing to do. Besides, users who use Result extensively can still use the unwrap method in their flatMap closures:
> 
> ```swift
> func f(_ data: Data) -> Result<Int> { ... }
> let result: Result<Data> = ...
> result.flatMap { try f($0).unwrap() } // Result<Int>
> ```

I remain convinced that the natural `flatMap` accepts a throwing closure, but I remain open to a `flatMap` overload that accepts a `Result` argument, and better follows the functional rules:

> ```swift
> func f(_ data: Data) -> Result<Int> { ... }
> let result: Result<Data> = ...
> result.flatMap { f($0) } // Result<Int>
> ```

Yet since Swift has no standard `Result` type, an app that includes Alamofire may also include other libraries that define their own `Result` type. Is it a good idea to bless the `Result` type of Alamofire? That's an open question:

> ```swift
> // Unavoidable
> func f(_ data: Data) -> SomeLib.Result<Int> { ... }
> let result: Alamofire.Result<Data> = ...
> result.flatMap { f($0) } // Compiler error
> ```

Finally, I also introduced the `unwrap` function:

> `unwrap` returns a result's success value, or throws its failure error:
> 
> ```swit
> let result: Result<Data> = ...
> try result.unwrap() // Data
> ```

I guess the reciprocal `wrap` should be added as well, for completeness' sake:

```swift
let r = Result.wrap { try getInt() } // Result<Int>
```
 @jshier, @cnoon: The intent behind this PR is not to turn Alamofire into a functional programming flagship, but instead to enhance Alamofire with a tiny set of functional idioms that blend well into regular imperative Swift code.

The proposal is to remove some friction in custom response deserialization. Result.map/flatMap are only there to support DataResponse.map/flatMap which are the real added value of this PR. The final touch to this PR will be *documentation* and *guidelines* for simple response deserialization. This is what this PR is about:

```swift
// Look, ma! No custom extension to DataRequest!
func getStuff(_ completionHandler: @escaping (DataResponse<Stuff>) -> Void)) {
    Alamofire.request("https://httpbin.org/get").responseJSON { response in
        completionHandler(response.flatMap { json in try Stuff(json: json) })
    }
}

getStuff { response in
    print(response.request)  // original URL request
    print(response.response) // HTTP URL response
    print(response.data)     // server data
    print(response.result)   // result of response serialization

    if let stuff = response.result.value { // stuff is Stuff
        print("stuff: \(stuff)")
    }
}
```

Alamofire *does not need* those extensions. As you say above, application developers can already add a few extensions to Result and DataResponse that cover their use cases. Alamofire is extensible, and this is good.

It just happens that custom deserialization deserves a little polish, and that a tiny set of functional idioms improves it a lot, when properly explained and documented. Embedding [antitypical/Result](https://github.com/antitypical/Result) concepts and vocabulary is not my proposal. Enhancing deserialization is. 
> On Jan 10, 2017, at 2:56 PM, Gwendal Rou√© <notifications@github.com> wrote:
> 
> @groue commented on this pull request.
> 
> In Source/Result.swift <https://github.com/Alamofire/Alamofire/pull/1836>:
> 
> > @@ -100,3 +100,82 @@ extension Result: CustomDebugStringConvertible {
>          }
>      }
>  }
> +
> +// MARK: - Functional Tools
> +
> +extension Result {
> +    /// Returns the success value, or throws the failure error.
> +    ///
> +    ///     let possibleString: Result<String> = .success("success")
> +    ///     try print(possibleString.unwrap())
> +    ///     // Prints "success"
> +    ///
> +    ///     let noString: Result<String> = .failure(error)
> +    ///     try print(noString.unwrap())
> +    ///     // Throws error
> +    func unwrap() throws -> Value {
> I was waiting for this question. Yes, I did not choose dematerialize. I don't think Alamofire needs/wants to use bleeding edge functional concepts or vocabulary.
> 
> dematerialize is long. dematerialize is spectacular. dematerialize is abstract. dematerialize is pedantic. dematerialize contains a latent implicit disagreement on swift's choice of try/catch/throws instead of a "proper sum type" that needs to be "materialized". dematerialize is not yet a term of art.
> 
> On the other side, Rust's unwrap sounds just as boring as it needs to be. It fits better in the multi-paradigms Swift language. It fits better with some Swift evolution discussions around wrapper types such as Optional and other various boxes. Unfortunately, this mailing list is a chore when you look for something in it, but I'd like to put my finger on a proposal/post by @erica <https://github.com/erica> - maybe she'll read this and help ;-)
> 


You rang!? I always prefer short and sweet: `unwrap`.

-- E 
> On Jan 11, 2017, at 11:31 AM, Jon Shier <notifications@github.com> wrote:
> 
> Thinking about it more, it would probably help interop if we used wrap/unwrap and let antitypical/Result use materialize/dematerialize, so I think I've just convince myself we're good there.
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub <https://github.com/Alamofire/Alamofire/pull/1836#issuecomment-271953638>, or mute the thread <https://github.com/notifications/unsubscribe-auth/AAB_sMGJ00whQyj87OqnWRW9k1u4YFWcks5rRSAOgaJpZM4LJoqQ>.
> 
I think this is where I'm suppose to link a few things. 

Here you go, with the understanding that these are works in progress and likely to change.

https://gist.github.com/erica/3daa8ec77aef2feaefca3a3a19aedee3 <https://gist.github.com/erica/3daa8ec77aef2feaefca3a3a19aedee3>
https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c <https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c>

I have a lot of strong thoughts about `Result` types and biased unwrapping but I'm coming very late into this discussion and I'm unsure what exactly you're trying to decide.

-- E

 
> On Jan 11, 2017, at 11:43 AM, Jon Shier <notifications@github.com> wrote:
> 
> Mostly naming at this point, as we want this functionality. We're already using a Result type, so its existence is beyond question, so this is mainly about what other functionality it should have.
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub <https://github.com/Alamofire/Alamofire/pull/1836#issuecomment-271956653>, or mute the thread <https://github.com/notifications/unsubscribe-auth/AAB_sIltBU8FfBmO2pzV7_L8FpoU9OFxks5rRSK1gaJpZM4LJoqQ>.
> 
I think the unambiguous thing you are doing with a result type is unwrapping a value. You're not "materializing" it.

-- E

 @jshier, I'l keep `unwrap` and add `wrap` when you tell me so. Although `wrap` could be bike-shedded too üòâ :

```swift
// Factory method?
Result.wrap { try value() }

// Initializer?
Result(value: { try value() })
Result(wrapping: { try value() })
```

Swift fosters initializers, doesn't it? I'd vote for `Result(value: { try ... })`:

```swift
// Result<Stuff>
let result = Result(value: { try Stuff(json: json) })
result.value()      // Stuff?
try result.unwrap() // Stuff
```
 Thanks @cnoon ! For the answer, the hints, and for the warning against deserialization on the main thread, which I overlooked. Requested updates to the PR are coming :smile: @cnoon, @jshier, I've rebased this PR against the master branch, added tests for DataResponse and DownloadResponse, the Result initializer reciprocal of unwrap, and presented response mapping as an introduction to custom response serialization in the README.

I did not document the new Result methods, though! It does quite not fit in any existing section - Result is just an utility, after all. How do you think we should tell Alamofire users about these additions? @cnoon I forgot your question:

> The only thing I've found that I "think" is incorrect is this code sample from your original post. Wouldn't this return Int or throw rather than returning a Result<Int> from the unwrap?
> 
> ```swift
> func f(_ data: Data) -> Result<Int> { ... }
> let result: Result<Data> = ...
> result.flatMap { try f($0).unwrap() } // Result<Int>
> ```

Yes, `f($0).unwrap()` is `Int` (or throws).

And `result.flatMap { try f($0).unwrap() }` is `Result<Int>`. Flicks bic light. Congrats all.

-- E

> On Feb 26, 2017, at 2:16 PM, Christian Noon <notifications@github.com> wrote:
> 
> Okay @groue <https://github.com/groue>, I just squashed your PR down and made a few formatting and documentation tweaks and pushed it up into master in 7f8fe9c <https://github.com/Alamofire/Alamofire/commit/7f8fe9c7c69a958c279827f173e3b43a90f0c552> while maintaining your attribution. We can't thank you enough for all your great work here and persistence given the fact that it took us a long time to get this feature added in. I think it all paid off very well though given the final result.
> 
> These changes will ship as part of the Alamofire 4.4.0 release here shortly.
> 
> Thanks again! üçª
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub <https://github.com/Alamofire/Alamofire/pull/1836#issuecomment-282588233>, or mute the thread <https://github.com/notifications/unsubscribe-auth/AAB_sAH5hd2OVQk79zGMck3HrNJ9bj3Cks5rgeuYgaJpZM4LJoqQ>.
> 

 üëç I'm quite glad we have converged on this delicate topic! Many thanks to all, @cnoon, @jshier, @erica !!!  I am using alamofire in my project and getting this error some times

<pre>
platform :osx, '10.10'

def shared_pods
    pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git'
    pod 'PromiseKit', '~> 4.0'
    pod 'Zip', :git => 'https://github.com/marmelroy/Zip.git'
    pod 'ReachabilitySwift', '~> 3'
end
</pre>

<pre>
Fatal Exception: NSGenericException
0  CoreFoundation                 0x7fffa1d60473 __exceptionPreprocess
1  libobjc.A.dylib                0x7fffb64c2cad objc_exception_throw
2  Foundation                     0x7fffa38dc332 -[_NSConcreteDateInterval dealloc]
3  CFNetwork                      0x7fffa1189fab -[__NSCFURLSessionTaskMetrics _initWithTask:]
4  CFNetwork                      0x7fffa1189b5a -[NSURLSessionTaskMetrics _initWithTask:]
5  CFNetwork                      0x7fffa0ec0f10 -[__NSCFURLLocalSessionConnection _tick_finishing]
6  libdispatch.dylib              0x7fffb6d73f5f _dispatch_call_block_and_release
7  libdispatch.dylib              0x7fffb6d6b128 _dispatch_client_callout
8  libdispatch.dylib              0x7fffb6d81b97 _dispatch_queue_serial_drain
9  libdispatch.dylib              0x7fffb6d73d41 _dispatch_queue_invoke
10 libdispatch.dylib              0x7fffb6d6cee0 _dispatch_root_queue_drain
11 libdispatch.dylib              0x7fffb6d6ccb7 _dispatch_worker_thread3
12 libsystem_pthread.dylib        0x7fffb6fb8736 _pthread_wqthread
13 libsystem_pthread.dylib        0x7fffb6fb8211 start_wqthread
</pre> @cnoon @jshier 

My Podfile.lock
<pre>
PODS:
  - Alamofire (4.1.0)
  - PromiseKit (4.0.1):
    - PromiseKit/Foundation (= 4.0.1)
    - PromiseKit/QuartzCore (= 4.0.1)
    - PromiseKit/UIKit (= 4.0.1)
  - PromiseKit/CorePromise (4.0.1)
  - PromiseKit/Foundation (4.0.1):
    - PromiseKit/CorePromise
  - PromiseKit/QuartzCore (4.0.1):
    - PromiseKit/CorePromise
  - PromiseKit/UIKit (4.0.1):
    - PromiseKit/CorePromise
  - ReachabilitySwift (3)
  - Zip (0.6.0)

DEPENDENCIES:
  - Alamofire (from `https://github.com/Alamofire/Alamofire.git`)
  - PromiseKit (~> 4.0)
  - ReachabilitySwift (~> 3)
  - Zip (from `https://github.com/marmelroy/Zip.git`)

EXTERNAL SOURCES:
  Alamofire:
    :git: https://github.com/Alamofire/Alamofire.git
  Zip:
    :git: https://github.com/marmelroy/Zip.git

CHECKOUT OPTIONS:
  Alamofire:
    :commit: c2134d7645ee6869298dc8d3587e580a3ec83f96
    :git: https://github.com/Alamofire/Alamofire.git
  Zip:
    :commit: 6f3b6b442b9c8711068178c3c6c9da4bf75f52b4
    :git: https://github.com/marmelroy/Zip.git

SPEC CHECKSUMS:
  Alamofire: e266cf991b933498df791e645e0d8ac294492153
  PromiseKit: ae9e7f97ee758e23f7b9c5e80380a2e78d6338c5
  ReachabilitySwift: f5b9bb30a0777fac8f09ce8b067e32faeb29bb64
  Zip: 805fc2fa9d2f05bbb7762d982d7a42ccdcc51f42

PODFILE CHECKSUM: c381e7dbaaf703f8485474005926bf120720ca75

COCOAPODS: 1.0.1
</pre>

My Crashlytics Report
<pre>
# Crashlytics - plaintext stacktrace downloaded by Aruljothi at Sat, 10 Dec 2016 11:10:22 GMT
# URL: https://www.fabric.io/TestApp/mac/apps/com.aj.TestApp/issues/58487f260aeb16625bbb009c/sessions/139d5acad5b04cc0afb16b3f55e60c19_8907d6d7237844f884bb74259f4b9c0a_0_v1
# Organization: TestApp
# Platform: mac
# Application: TestApp
# Version: 1.4 (5)
# Bundle Identifier: com.aj.TestApp
# Issue #: 2
# Issue ID: 58487f260aeb16625bbb009c
# Session ID: 139d5acad5b04cc0afb16b3f55e60c19_8907d6d7237844f884bb74259f4b9c0a_0_v1
# Date: 2016-12-07T15:58:43Z
# OS Version: 10.12.1 (16B2555)
# Device: MacBook Air (13-inch, Early 2015)
# RAM Free: 8.6%
# Disk Free: 83.8%

#7. Crashed: com.twitter.crashlytics.mac.exception
0  TestApp                     0x10df0d74c CLSProcessRecordAllThreads + 4330293068
1  TestApp                     0x10df0d5e9 CLSProcessRecordAllThreads + 4330292713
2  TestApp                     0x10defda15 CLSHandler + 4330228245
3  TestApp                     0x10df0b875 __CLSExceptionRecord_block_invoke + 4330285173
4  libdispatch.dylib              0x7fffb6d6b128 _dispatch_client_callout + 8
5  libdispatch.dylib              0x7fffb6d6bd62 _dispatch_barrier_sync_f_invoke + 83
6  TestApp                     0x10df0b2b2 CLSExceptionRecord + 4330283698
7  TestApp                     0x10df0b0e1 CLSExceptionRecordNSException + 4330283233
8  TestApp                     0x10df0ae37 CLSNSApplicationReportException(objc_object*, objc_selector*, NSException*) + 4330282551
9  AppKit                         0x7fff9fd8486f uncaughtErrorProc + 158
10 CoreFoundation                 0x7fffa1dded2a __handleUncaughtException + 746
11 libobjc.A.dylib                0x7fffb64c4f15 _objc_terminate() + 94
12 TestApp                     0x10df0aba9 CLSTerminateHandler() + 4330281897
13 libc++abi.dylib                0x7fffb59b6d69 std::__terminate(void (*)()) + 8
14 libc++abi.dylib                0x7fffb59b6de3 std::terminate() + 51
15 libobjc.A.dylib                0x7fffb64c4d11 objc_terminate + 9
16 libdispatch.dylib              0x7fffb6d6b13c _dispatch_client_callout + 28
17 libdispatch.dylib              0x7fffb6d81b97 _dispatch_queue_serial_drain + 896
18 libdispatch.dylib              0x7fffb6d73d41 _dispatch_queue_invoke + 1046
19 libdispatch.dylib              0x7fffb6d6cee0 _dispatch_root_queue_drain + 476
20 libdispatch.dylib              0x7fffb6d6ccb7 _dispatch_worker_thread3 + 99
21 libsystem_pthread.dylib        0x7fffb6fb8736 _pthread_wqthread + 1299
22 libsystem_pthread.dylib        0x7fffb6fb8211 start_wqthread + 13

--

Fatal Exception: NSGenericException
0  CoreFoundation                 0x7fffa1d60473 __exceptionPreprocess
1  libobjc.A.dylib                0x7fffb64c2cad objc_exception_throw
2  Foundation                     0x7fffa38dc332 -[_NSConcreteDateInterval dealloc]
3  CFNetwork                      0x7fffa1189fab -[__NSCFURLSessionTaskMetrics _initWithTask:]
4  CFNetwork                      0x7fffa1189b5a -[NSURLSessionTaskMetrics _initWithTask:]
5  CFNetwork                      0x7fffa0ec0f10 -[__NSCFURLLocalSessionConnection _tick_finishing]
6  libdispatch.dylib              0x7fffb6d73f5f _dispatch_call_block_and_release
7  libdispatch.dylib              0x7fffb6d6b128 _dispatch_client_callout
8  libdispatch.dylib              0x7fffb6d81b97 _dispatch_queue_serial_drain
9  libdispatch.dylib              0x7fffb6d73d41 _dispatch_queue_invoke
10 libdispatch.dylib              0x7fffb6d6cee0 _dispatch_root_queue_drain
11 libdispatch.dylib              0x7fffb6d6ccb7 _dispatch_worker_thread3
12 libsystem_pthread.dylib        0x7fffb6fb8736 _pthread_wqthread
13 libsystem_pthread.dylib        0x7fffb6fb8211 start_wqthread

#0. com.apple.main-thread
0  libsystem_kernel.dylib         0x7fffb6ec841a mach_msg_trap + 10
1  libsystem_kernel.dylib         0x7fffb6ec7867 mach_msg + 55
2  CoreFoundation                 0x7fffa1cd7834 __CFRunLoopServiceMachPort + 212
3  CoreFoundation                 0x7fffa1cd6cc1 __CFRunLoopRun + 1361
4  CoreFoundation                 0x7fffa1cd6514 CFRunLoopRunSpecific + 420
5  HIToolbox                      0x7fffa1273fbc RunCurrentEventLoopInMode + 240
6  HIToolbox                      0x7fffa1273df1 ReceiveNextEventCommon + 432
7  HIToolbox                      0x7fffa1273c26 _BlockUntilNextEventMatchingListInModeWithFilter + 71
8  AppKit                         0x7fff9f95db79 _DPSNextEvent + 1093
9  AppKit                         0x7fffa00731c3 -[NSApplication(NSEvent) _nextEventMatchingEventMask:untilDate:inMode:dequeue:] + 1637
10 AppKit                         0x7fff9f95253d -[NSApplication run] + 926
11 AppKit                         0x7fff9f91d1ad NSApplicationMain + 1237
12 TestApp                     0x10ddee2b9 main (AppDelegate.swift:37)
13 libdyld.dylib                  0x7fffb6da1255 start + 1

#1. com.apple.NSURLConnectionLoader
0  libsystem_kernel.dylib         0x7fffb6ec841a mach_msg_trap + 10
1  libsystem_kernel.dylib         0x7fffb6ec7867 mach_msg + 55
2  CoreFoundation                 0x7fffa1cd7834 __CFRunLoopServiceMachPort + 212
3  CoreFoundation                 0x7fffa1cd6cc1 __CFRunLoopRun + 1361
4  CoreFoundation                 0x7fffa1cd6514 CFRunLoopRunSpecific + 420
5  CFNetwork                      0x7fffa0ea7334 +[NSURLConnection(Loader) _resourceLoadLoop:] + 313
6  Foundation                     0x7fffa36e430d __NSThread__start__ + 1243
7  libsystem_pthread.dylib        0x7fffb6fb8aab _pthread_body + 180
8  libsystem_pthread.dylib        0x7fffb6fb89f7 _pthread_body + 284
9  libsystem_pthread.dylib        0x7fffb6fb8221 thread_start + 13

#2. com.twitter.crashlytics.mac.MachExceptionServer
0  libsystem_kernel.dylib         0x7fffb6ec841a mach_msg_trap + 10
1  libsystem_kernel.dylib         0x7fffb6ec7867 mach_msg + 55
2  TestApp                     0x10def8a0f CLSMachExceptionServer + 4330207759
3  libsystem_pthread.dylib        0x7fffb6fb8aab _pthread_body + 180
4  libsystem_pthread.dylib        0x7fffb6fb89f7 _pthread_body + 284
5  libsystem_pthread.dylib        0x7fffb6fb8221 thread_start + 13

#3. com.apple.NSEventThread
0  libsystem_kernel.dylib         0x7fffb6ec841a mach_msg_trap + 10
1  libsystem_kernel.dylib         0x7fffb6ec7867 mach_msg + 55
2  CoreFoundation                 0x7fffa1cd7834 __CFRunLoopServiceMachPort + 212
3  CoreFoundation                 0x7fffa1cd6cc1 __CFRunLoopRun + 1361
4  CoreFoundation                 0x7fffa1cd6514 CFRunLoopRunSpecific + 420
5  AppKit                         0x7fff9faaa5a0 _NSEventThread + 205
6  libsystem_pthread.dylib        0x7fffb6fb8aab _pthread_body + 180
7  libsystem_pthread.dylib        0x7fffb6fb89f7 _pthread_body + 284
8  libsystem_pthread.dylib        0x7fffb6fb8221 thread_start + 13

#4. Thread
0  libsystem_kernel.dylib         0x7fffb6ed04e6 __workq_kernreturn + 10
1  libsystem_pthread.dylib        0x7fffb6fb87b5 _pthread_wqthread + 1426
2  libsystem_pthread.dylib        0x7fffb6fb8211 start_wqthread + 13

#5. Thread
0  libsystem_kernel.dylib         0x7fffb6ed04e6 __workq_kernreturn + 10
1  libsystem_pthread.dylib        0x7fffb6fb87b5 _pthread_wqthread + 1426
2  libsystem_pthread.dylib        0x7fffb6fb8211 start_wqthread + 13

#6. Thread
0  libsystem_kernel.dylib         0x7fffb6ed04e6 __workq_kernreturn + 10
1  libsystem_pthread.dylib        0x7fffb6fb87b5 _pthread_wqthread + 1426
2  libsystem_pthread.dylib        0x7fffb6fb8211 start_wqthread + 13

#7. Crashed: com.twitter.crashlytics.mac.exception
0  TestApp                     0x10df0d74c CLSProcessRecordAllThreads + 4330293068
1  TestApp                     0x10df0d5e9 CLSProcessRecordAllThreads + 4330292713
2  TestApp                     0x10defda15 CLSHandler + 4330228245
3  TestApp                     0x10df0b875 __CLSExceptionRecord_block_invoke + 4330285173
4  libdispatch.dylib              0x7fffb6d6b128 _dispatch_client_callout + 8
5  libdispatch.dylib              0x7fffb6d6bd62 _dispatch_barrier_sync_f_invoke + 83
6  TestApp                     0x10df0b2b2 CLSExceptionRecord + 4330283698
7  TestApp                     0x10df0b0e1 CLSExceptionRecordNSException + 4330283233
8  TestApp                     0x10df0ae37 CLSNSApplicationReportException(objc_object*, objc_selector*, NSException*) + 4330282551
9  AppKit                         0x7fff9fd8486f uncaughtErrorProc + 158
10 CoreFoundation                 0x7fffa1dded2a __handleUncaughtException + 746
11 libobjc.A.dylib                0x7fffb64c4f15 _objc_terminate() + 94
12 TestApp                     0x10df0aba9 CLSTerminateHandler() + 4330281897
13 libc++abi.dylib                0x7fffb59b6d69 std::__terminate(void (*)()) + 8
14 libc++abi.dylib                0x7fffb59b6de3 std::terminate() + 51
15 libobjc.A.dylib                0x7fffb64c4d11 objc_terminate + 9
16 libdispatch.dylib              0x7fffb6d6b13c _dispatch_client_callout + 28
17 libdispatch.dylib              0x7fffb6d81b97 _dispatch_queue_serial_drain + 896
18 libdispatch.dylib              0x7fffb6d73d41 _dispatch_queue_invoke + 1046
19 libdispatch.dylib              0x7fffb6d6cee0 _dispatch_root_queue_drain + 476
20 libdispatch.dylib              0x7fffb6d6ccb7 _dispatch_worker_thread3 + 99
21 libsystem_pthread.dylib        0x7fffb6fb8736 _pthread_wqthread + 1299
22 libsystem_pthread.dylib        0x7fffb6fb8211 start_wqthread + 13

#8. Thread
0  libsystem_kernel.dylib         0x7fffb6ed04e6 __workq_kernreturn + 10
1  libsystem_pthread.dylib        0x7fffb6fb87b5 _pthread_wqthread + 1426
2  libsystem_pthread.dylib        0x7fffb6fb8211 start_wqthread + 13

#9. Thread
0  libsystem_kernel.dylib         0x7fffb6ed04e6 __workq_kernreturn + 10
1  libsystem_pthread.dylib        0x7fffb6fb87b5 _pthread_wqthread + 1426
2  libsystem_pthread.dylib        0x7fffb6fb8211 start_wqthread + 13
</pre>

Yes, I changed my system time manually ahead of 1 hour and testing the api service.

Note: I am using PromiseKit to make a Multiple Alamofire request at the same time Hello, I have the same problem. 
I am not doing anything with the dates. 

```
Fatal Exception: NSGenericException
0  CoreFoundation                 0x1897861c0 __exceptionPreprocess
1  libobjc.A.dylib                0x1881c055c objc_exception_throw
2  Foundation                     0x18a394b4c -[_NSConcreteDateInterval dealloc]
3  CFNetwork                      0x189fbf3e0 -[__NSCFURLSessionTaskMetrics _initWithTask:]
4  CFNetwork                      0x189fbf028 -[NSURLSessionTaskMetrics _initWithTask:]
5  CFNetwork                      0x189e4416c -[__NSCFURLLocalSessionConnection _tick_finishing]
6  libdispatch.dylib              0x188611200 _dispatch_call_block_and_release
7  libdispatch.dylib              0x1886111c0 _dispatch_client_callout
8  libdispatch.dylib              0x18861f444 _dispatch_queue_serial_drain
9  libdispatch.dylib              0x1886149a8 _dispatch_queue_invoke
10 libdispatch.dylib              0x18862138c _dispatch_root_queue_drain
11 libdispatch.dylib              0x1886210ec _dispatch_worker_thread3
12 libsystem_pthread.dylib        0x18881a2b8 _pthread_wqthread
13 libsystem_pthread.dylib        0x188819da4 start_wqthread
``` I am seeing the same issue. Also not changing the dates. Crash occurred after my app had been running over a day, making a batch of network requests every 30 seconds.  Hi,
it seems that Alamofire 4.2 and iOS 10.2 as base sdk solves the problem. ;)
At least it worked for our app!

Thanks I found a workaround to this issue and posted it on stackoverflow under the alias Monty

http://stackoverflow.com/questions/40723657/terminating-app-due-to-uncaught-exception-nsgenericexception-reason-sta/41919205#41919205

@jakjothi
@keithkade  We are using Alamofire (version 4.2.0 ) for downloading contents from server. We have app settings which specifies the cache limit for the downloaded contents.For checking the content size we start the download and in progress closure we are pausing the request to check the size of the content.If the content size is greater than cache limit then we are cancelling the request else we are resuming the request.
This code was working fine with Alamofire (version 3.0.0 ) but after updating to new version we are facing following issue
- if the cache limit is not exceeding we are resuming the request but currently the request is not getting resumed and we are getting timed out error.
Following is the download request
let request:DownloadRequest = Alamofire.download(URLString,
                                                         method: method,
                                                         parameters: parameters,
                                                         encoding: encoding!,
                                                         headers: headers,
                                                         to: destination)

Error:
 Error = Optional(Error Domain=NSURLErrorDomain Code=-1001 "The request timed out." UserInfo={NSURLSessionDownloadTaskResumeData=<CFData 0x170054df0 [0x1a6574bb8]>{length = 6137, capacity = 16384, bytes = 0x3c3f786d6c2076657273696f6e3d2231 ... 2f706c6973743e0a}, NSErrorFailingURLKey="OurURL", kCFStreamErrorDomainKey=4, NSLocalizedDescription=The request timed out., NSErrorFailingURLStringKey="OurURL", NSUnderlyingError=0x17005fd70 {Error Domain=kCFErrorDomainCFNetwork Code=-1001 "(null)" UserInfo={_kCFStreamErrorCodeKey=-2102, kCFStreamErrorDomainKey=4}}, _kCFStreamErrorCodeKey=-2102})
    pod 'Alamofire', '~> 4.2.0'

ÁúüÊú∫ËØ∑Ê±ÇÁΩëÁªú Ë∂ÖÊó∂Ôºå‰∏ÄÁõ¥ËØ∑Ê±Ç‰∏çÂà∞Êï∞ÊçÆÊòØÊÄé‰πàÂõû‰∫ãÔºüÊ®°ÊãüÂô®ÂèØ‰ª•ËØ∑Ê±ÇÂà∞Êï∞ÊçÆÔºåËØ∑ÈóÆËøôÊòØ‰ªÄ‰πàÈóÆÈ¢ò  ËØ∑Áî®Ëã±Êñá„ÄÇ I met a problem using Alamofire4.2.0 version. Use real machine when running the project request network timeout, always can't request data is how to return a responsibility? While using simulators can request to the data, could you tell me what's the problem  Alamofire 4.2.0
We discovered that the following works fine with URLs without a query but fails with URLs with a query.

I've seen previous discussion around Authorization... but was unable to find a resolution post or anything concerning queries. Suggestions WARMLY welcomed.

    internal let alamofireManager: Alamofire.SessionManager = {
      let configuration = URLSessionConfiguration.default
      var receivedToken: String? = nil
    
      if let token = gConfig.sharedConfig.authToken {
          configuration.httpAdditionalHeaders = ["Authorization": token]
      }
    
      let returnSessionManager = Alamofire.SessionManager(
          configuration: configuration,
          serverTrustPolicyManager: ServerTrustPolicyManager(policies: gConfig.sharedConfig.sslOverridePolicy)
      )
      return returnSessionManager
    }()

        
      let siteGood = "https://foo.bar.org/one"
      let siteBad="https://foo.bar.org/one?check=true"

      var request = alamofireManager.request(site, method: .get, parameters: parameters, encoding: JSONEncoding.default)
        
      request.responseData { (response) in ‚Ä¶    I have two different calls.  One logs in with a client certificate, the other sends data to a server.  Both require the client certificate, but the data upload requires a configuration for the headers.   The log in works without issues sending the client certificate, but the upload does not send anything at all (according to our servers).  

**This is the code where the certificate is sent and logs in to the server**
`let serverTrustPolicy : [String : ServerTrustPolicy]   = [
            "healthyagingmobileapp-dev.emory.edu" : ServerTrustPolicy.disableEvaluation
        ]
 manager = Alamofire.SessionManager(serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicy))
        }
        let cert = PKCS12Import.init(mainBundleResource: "devclient", resourceType: "p12", password: "passwordString")
        
        manager?.delegate.sessionDidReceiveChallenge = { session, challenge in
            if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodClientCertificate {
                return (URLSession.AuthChallengeDisposition.useCredential, cert.urlCredential())
            }
            if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
                return (URLSession.AuthChallengeDisposition.useCredential, URLCredential(trust: challenge.protectionSpace.serverTrust!))
            }
            return (URLSession.AuthChallengeDisposition.performDefaultHandling, Optional.none)
        }
`

**This is the code where no certificate is sent and I get a 1205 error:**

`let headers = [
            // make sure to have userID token
            "Authorization":"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MSwiY29udGFjdElkIjoiMDAzbTAwMDAwMFd5WFpnQUFOIiwiZXhwIjoxNTExOTc2NjczLCJpc3MiOiJsb2NhbGhvc3Q6ODA4MCJ9.BLQFBanzFNWH0yhSKRjXORV3dE14bP9asoKATdDzV58",
            "Content-Type":"multipart/form-data; charset=utf-8; boundary=__X_PAW_BOUNDARY__",
            ]

        let configuration = URLSessionConfiguration.background(withIdentifier: "http://healthyagingmobileapp-dev.emory.edu/upload_s3")
        configuration.httpAdditionalHeaders = headers
        
        let serverTrustPolicy : [String : ServerTrustPolicy] = [
            "healthyagingmobile-dev.emory.edu" : ServerTrustPolicy.disableEvaluation
        ]

        manager = Alamofire.SessionManager(configuration: configuration, serverTrustPolicyManager : ServerTrustPolicyManager(policies: serverTrustPolicy))
        
        let cert = PKCSImport.init(mainBundleResource: "devclient", resourceType: "p12", password: "passwordString")
        
        manager?.delegate.sessionDidReceiveChallenge = { session, challenge in
            if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodClientCertificate {
                return (URLSession.AuthChallengeDisposition.useCredential, cert.urlCredential())
            }
            if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
                return (URLSession.AuthChallengeDisposition.useCredential, URLCredential(trust: challenge.protectionSpace.serverTrust!))
            }
            return (URLSession.AuthChallengeDisposition.performDefaultHandling, Optional.none)
        }
`

I have my plist set according to your documents, and obviously the sessionManager is happy with just the ServerPolicyTrustManager by itself, but headers appear to mess it up.  Any advice appreciated. just to update.  I got rid of the configuration completely in my sessionManager and moved the headers to within the upload function and everything worked fine.  

Still, it does seem odd to me that having the configuration section causes the Server Trust Policy issue to fail.  Server Trust by itself in the SessionManager parameters works just fine.

--Further UPDATE--
added configuration back in but using default or ephemeral session configurations and they both worked.  background Configuration does not.  Is there is a way to use Alamofire with keep-alive ? i.e. SSL resume. Please advice. Thanks! @jshier i apologize for some reason i have thought i am discussing in Swagger github not alamofire! I am going to delete my comments. Would it be possible for you to check if that's a good usage of Alamofire so i can modify the generator correctly. Again apologies for mixing up the threads!

https://github.com/swagger-api/swagger-codegen/blob/master/samples/client/petstore/swift/default/PetstoreClient/Classes/Swaggers/AlamofireImplementations.swift#L54 i have a quick and dirty solution in our branch https://github.com/romk1n/swagger-codegen/commit/7e3713adfcc72a9b0df5b537c3dd088369f9880f  Hi,

I am unable to find how to enable eTag support on Alamofire.
Do you have any documentation I can read?

Thanks a lot.  Hi,

I know some old issues are about Content-Type header, but all seems to be about adding it or checking content.
My problem is that Content-Type is not accepted by the server when I do a GET request and returns an HTTP 500 error.
Infact, looking at the HTTP [RFC2616 section 7.2.1](https://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html) it says that Content-Type SHOULD be added when a content (aka a body) is sent.

As this is never the case in a GET request, shouldn't Alamofire remove the Content-Type header for GET requests ?
Also, I work with Android on the same app and libs like OKHttp seems to remove it automatically in GET requests. @jshier, I don't get it... GET method is not intended to have a body. Or at least, the body MUST NOT be taken in account. (see http://stackoverflow.com/a/983458/1829444)
So I really don't see any case where some would need to set a JSON string as body of a GET request. 

**However, the point of my issue was not about putting data in the body of a GET request or not, but only about the fact that if a GET request have no body data, the Content-Type header should be deleted from the request as this is the case using other libs.**          let urlString = mainURL + "login"
        let parameters: Parameters = ["admin": "admin"]
        
        Alamofire.request(urlString, method: .post, parameters: parameters, encoding: JSONEncoding.default)
            .responseJSON { response in
                debugPrint(response)
        }

and the debugPrint log

[Request]: http://127.0.0.1:8090/login
[Response]: <NSHTTPURLResponse: 0x60000022d160> { URL: http://127.0.0.1:8090/login } { status code: 200, headers {
    Connection = "Keep-Alive";
    "Content-Length" = 21;
    "Content-Type" = "application/json";
    Date = "Mon, 05 Dec 2016 09:53:09 GMT";
    "Keep-Alive" = "timeout=60, max=99";
} }
[Data]: 21 bytes
[Result]: SUCCESS: {
    msg = wrong;
}
[Timeline]: Timeline: { "Request Start Time": 502624389.824, "Initial Response Time": 502624389.865, "Request Completed Time": 502624389.866, "Serialization Completed Time": 502624389.866, "Latency": 0.041 secs, "Request Duration": 0.042 secs, "Serialization Duration": 0.000 secs, "Total Duration": 0.043 secs }

-----------------------------------------------------------------------------------
service code

        let uanme = req.queryParameters.first?.key
        let psd = req.queryParameters.first?.value
        
        debugPrint(req.queryParameters)
        debugPrint(req.parameters)
        
        if uanme == "admin" && psd == "admin" {
            resp.statusCode = .OK
            resp.send(json: JSON.init(["msg": "ok"]))
        } else {
            resp.statusCode = .OK
            resp.send(json: JSON.init(["msg": "wrong"]))
        }

and the log

 VERBOSE: listen(listenSocket:) HTTPServer.swift line 144 - Accepted connection from: 127.0.0.1:61293 
 INFO: handle(request:response:next:) RouterCreator.swift line 74 - Authorization: nil 
        debugPrint(req.queryParameters)    -> [:]
        debugPrint(req.parameters) -> [:]




any one has ideas?  Hello.
This request is added new policy at server trust evaluation that checking revoked server certificate. Hi @cnoon 

Here are information of this changes.

**[1. About this change]**
This change gives to new option about checking revoked server certificates.
iOS APIs(NSURLSession, WKWebView, etc) don't check revocation on default setting.
So people needs to create policy that specifically checks for certificate revocation (for example, via OCSP or a CRL).
https://developer.apple.com/library/content/technotes/tn2232/_index.html#//apple_ref/doc/uid/DTS40012884-CH1-SECSTRICTER

Alamofire also enable trust policy revocation if user wanna check server certificates is revoked.
But current trust policies of Alamofire provides pinning, not provide checking revocation.
Create manually about checking revocation at "customEvaluation" if I wanna check to revocation.
So I want to more option about more easy to enabling checking revocation.

**[2. What solves this change]**
This change makes more easier to checking revocation.

**[3. How to test this change]**
I created this sample app to testing this change.
https://github.com/WataruSuzuki/RevocationAlamofire

And also I added to unit test. It checks revoked server: https://revoked.badssl.com.

Thank you!  I try send a post request with custom headers as:

Alamofire.request( url, method: .POST, parameters: [], encoding: JSONEncoding.default, headers: ["Auth":"XXXX"] )

But, the headers not sended with request.

How do to send headers in post request?

Thanks Its not a problem for me. I send custom headers via Get and it works. My server implementation is proprietary restful.   The case I am talking about is that the server is online. the base url does exists. but, the file itself doesn't. the alamofire download doesn't detect an error! it downloads the error page itself. I am expecting an image no error is there.

    Alamofire.download(URL(string: fileUrl as String)!, to: destination).response { response in
                    if response.error == nil {
                        Log.debug("Play image downloaded successfully.")
                        
                        // hide progress
                        self.progressView.isHidden = true
                        
                        // Save image url
                        Common.setValue(value: self.fileUrl, key: self.competition_id)
                        
                        self.displayImage()
                    } else {
                        // image failed to download
                        Log.debug("Image download failed with error: \(response.error)")
                    }
                }
                .downloadProgress(closure: { (Progress) in
                        //Progress.fractionCompleted
                    Log.ver("Progress: \(Progress.fractionCompleted)")
                })  ```swift
// in Router: URLRequestConvertible method asURLRequest()
var urlRequest = URLRequest(url: someURL)
urlRequest.httpMethod = HTTPMethod.get.rawValue
let params: Parameters = [
    "location": [12.12, 12.12]
]
urlRequest = try JSONEncoding.default.encode(urlRequest, with: params)
return urlRequest
```

When I try Alamofire.request(Router.someCase), it does not work. I tested all my routers, and JSON encoding with routers work fine with POST requests. I don't know if anyone else is having this problem.

This is part of the error log until the request times out:
```swift
nw_host_stats_add_src recv too small, received 24, expected 28
nw_endpoint_flow_service_writes [2.1 ::1.8081 ready socket-flow (satisfied)] Write request has 4294967295 frame count, 0 byte count
```
 I met exactly the same issue! I have the same issue

2016-12-05 16:02:45.816 TestAlamofire[9728:191451] postMediaButtonPressed
postMedia
HttpCLient upload
2016-12-05 16:02:45.844715 TestAlamofire[9728:191494] [] nw_host_stats_add_src recv too small, received 24, expected 28
2016-12-05 16:02:45.848818 TestAlamofire[9728:191494] [] ____nwlog_simulate_crash_inner_block_invoke dlopen CrashReporterSupport failed
2016-12-05 16:02:45.849026 TestAlamofire[9728:191494] [] __nwlog_err_simulate_crash simulate crash failed "nw_socket_set_common_sockopts setsockopt SO_NOAPNFALLBK failed: [42] Protocol not available"
2016-12-05 16:02:45.849764 TestAlamofire[9728:191494] [] nw_socket_set_common_sockopts setsockopt SO_NOAPNFALLBK failed: [42] Protocol not available, dumping backtrace:
        [x86_64] libnetcore-856.20.4
    0   libsystem_network.dylib             0x000000010ac99682 __nw_create_backtrace_string + 123
    1   libnetwork.dylib                    0x000000010af76932 nw_socket_add_input_handler + 3100
    2   libnetwork.dylib                    0x000000010af544f4 nw_endpoint_flow_attach_protocols + 3768
    3   libnetwork.dylib                    0x000000010af53511 nw_endpoint_flow_setup_socket + 563
    4   libnetwork.dylib                    0x000000010af52270 -[NWConcrete_nw_endpoint_flow startWithHandler:] + 2612
    5   libnetwork.dylib                    0x000000010af6d44d nw_endpoint_handler_path_change + 1261
    6   libnetwork.dylib                    0x000000010af6ce7c nw_endpoint_handler_start + 570
    7   libnetwork.dylib                    0x000000010af84ae5 nw_endpoint_resolver_start_next_child + 2240
    8   libdispatch.dylib                   0x000000010aa16980 _dispatch_call_block_and_release + 12
    9   libdispatch.dylib                   0x000000010aa400cd _dispatch_client_callout + 8
    10  libdispatch.dylib                   0x000000010aa1de6b _dispatch_queue_serial_drain + 236
    11  libdispatch.dylib                   0x000000010aa1eb9f _dispatch_queue_invoke + 1073
    12  libdispatch.dylib                   0x000000010aa213b7 _dispatch_root_queue_drain + 720
    13  libdispatch.dylib                   0x000000010aa2108b _dispatch_worker_thread3 + 123
    14  libsystem_pthread.dylib             0x000000010ade94de _pthread_wqthread + 1129
    15  libsystem_pthread.dylib             0x000000010ade7341 start_wqthread + 13
postMedia statusCode
400
postMedia No content
 Did you guys fix it? It took me so long before realizing it could be an Alamofire error. Same problem here. All of my GET requests timeout and get a 500 error, but my POST requests work fine. My server is running Ubuntu 16.04.1, Apache 2.4.18 with a Ruby on Rails 4.2.5.1 API application. When I debugPrint the request and paste it into a console, the request fails as well. When I add -X GET to the command, it succeeds.
The error in my error logs when I run my app is as follows:
`[ 2016-12-08 10:35:53.9534 31442/7f45ad6e1700 Ser/Server.h:994 ]: [Client 1-25] Disconnecting client with error: error reading request body: Unexpected end-of-stream (errno=-1004)
[ 2016-12-08 10:44:24.8058 31469/7f168bfff700 apa/Hooks.cpp:690 ]: Unexpected error in mod_passenger: An error occurred while receiving HTTP upload data: Partial results are valid but processing is incomplete (70008)
  Backtrace:
     in 'void Hooks::sendRequestBody(const Passenger::FileDescriptor&, request_rec*, bool)' (Hooks.cpp:1200)
     in 'int Hooks::handleRequest(request_rec*)' (Hooks.cpp:561)` I figured out my problem. In my Router, I had my GET requests using JSONEncoding:
`urlRequest = try JSONEncoding.default.encode(urlRequest, with: parameters)`
To fix it, I changed it to URLEncoding:
`urlRequest = try URLEncoding.default.encode(urlRequest, with: parameters)` @jshier I am running an Express server using Elastic Beanstalk with Node.js. However, in development I am testing under localhost on Mac OS X. @willc0de4food I designed my server so that it does not parse the URL for parameters, but only looks for JSON in the HTTP body. I am intentionally trying to encode JSON in the body of the GET HTTP request. @jshier Update: Definitely is not a server problem. My logs show that no GET requests with embedded JSON even hit the server. I tried another pattern for embedding JSON to no avail
```swift
urlRequest.httpBody = try JSONSerialization.data(withJSONObject: parameters, options: [])
```
Hope to get feedback soon. @willc0de4food that works!

`GET` requests don't have a body, if you are using a body in your `GET` request you are not respecting HTTP 1.1 Specs:
https://tools.ietf.org/html/rfc2616#section-4.3
https://tools.ietf.org/html/rfc2616#section-9.3

Thus, any data in a `GET` should be passed in the Headers or URL Params. So to fix this, all I changed was the encoding:
```
Alamofire.request(url, method: .get, parameters: parameters, encoding: JSONEncoding(), headers: headers)
```
to
```
Alamofire.request(url, method: .get, parameters: parameters, encoding: URLEncoding(), headers: headers)
``` I didn't change the server API, I went through many combinations of code until one worked.  There are many method signatures for request and upload and some of them seem to be broken.  My advice is to try many combinations until one works.  There is no easy solution for this probem @baoskee try doing URL encoding instead of JSON encoding.  I copied this verbatim from the main README and it doesn't work (using the following jpeg in the example).

```swift
Alamofire.download("https://static.preapp.co/medias/2016/11/10/3194-a7d7afbf22.jpg")
    .downloadProgress { progress in
        print("Download Progress: \(progress.fractionCompleted)")
    }
    .responseData { response in
        // response.result.value  is ALWAYS nil
        if let data = response.result.value {
            let image = UIImage(data: data)
        }
    }
``` Didn't provide this information earlier. 
I'm on Swift `3.0`, using Xcode `8.1`. Alamofire `4.2.0` (cocoapods) I had the same problem
did you found a solution???  Hi,

Getting an "Module compiled with Swift 2.3 cannot be imported in Swift 3.0.1" error when importing Alamofire. 

I have 4.2 installed via Carthage and working in xcode 8.1, swift 3, brand new project. 

What am I missing?
Thanks  I'm working on a project that can download AVAssets, using `AVAssetDownloadTask` -- which is part of AVFoundation. Since I'm using Alamofire, I thought it might be good to try and extend Alamofire to support this new kind of URLSessionTask (around since iOS 9). So, I forked the repo, and put my additions over here: https://github.com/skydivedan/Alamofire

I created a unit test for it, `AVAssetDownloadsTest`, and it fails before it creates the AVAssetDownloadTask. For this kind of task to be created, I need to create an `AVAssetDownloadURLSession` (subclass of `URLSession`) and a `AVAssetDownloadDelegate` (subclass of `URLSessionTaskDelegate`), which I do. 

The problem comes up in my `AVAssetDownloadRequest`. In the `task` method (for the TaskConvertible) I check to see if the `URLSession` is an `AVAssetDownloadURLSession`, if not it bails. It looks like it is not, but I can't explain why, since I have code that definitely created it as such.

I'd appreciate any advice on what I'm missing here.  Created to discuss https://github.com/Alamofire/Alamofire/issues/1544#issuecomment-256215728 For sure @cnoon!

In short, we have a https://github.com/Moya/Moya/tree/swift-package-manager branch, which is ready to go once we have Alamofire being pulled down & building.

The instructions in #1544 for spm were focused on projects that were executables, and not app projects (I think the comments at the bottom of the issue say the same thing).

I haven't tested the integration for a couple weeks now, but assuming nothing has changed, `swift package build` doesn't successfully pull down & build alamofire  I got an error: A server with the specified hostname could not be found.
Help me, please!
Thanks.
![screen shot 2016-12-03 at 00 54 02](https://cloud.githubusercontent.com/assets/4568463/20844559/01e3f86a-b8f3-11e6-93b3-1603e5dbd571.png)
  I have to handle the HTTP response this way:

```swift
switch response.response {
case .success(...):
//responses with a valid status code and a body are here
//handling the responses that I want (like telling the user that the email or password was incorrect with a localized message) or printing the status code and the body for the user if it's an unknown status code, so he can tell me what error he gets instead of just saying "doesn't work"
case .failure(...):
//errors without status code are here, like no internet connection, printing the localized message to the user
//responses with a status code of like 200 with no body are here. probably the backend's fault that it should be 204 if it has no body
default:
//status code 204 with no body is here
}
```

In the readme it says: "By default, Alamofire treats any completed request to be successful, regardless of the content of the response."

I don't know if it would be better to handle status codes other than 204 without a body in the .success case but I'm pretty sure that status code 204 should be in the .success case. According to the readme, any status code with no body should fall into .success In the readme it says: "By default, Alamofire treats any completed request to be successful, regardless of the content of the response."

That's not true.
Status code 204 with no content doesn't fall into .success nor .failure, it goes to the default case.
Other status codes (tried with 200 and 201) with no content doesn't fall into .success either, they go to the .failure case.

I want to handle at least 204 with no content in the .success case but handling other status codes with no content in .success case would be also acceptable. (As that is the behaviour described in the readme)

edit: updated OP for clarity ```swift
Alamofire.request(url, method: .post, parameters: nil, encoding: JSONEncoding.default, headers: headers).responseJSON { response in
                switch response.result {
                case .success(let JSON as NSDictionary):
                    let statusCode = (response.response?.statusCode)! as Int
                    switch statusCode {
                    case 204:
                        //this never executes if I get 204 status code with no content
                    case 201:
                        //handling 201 code with content
                    default:
                        //showing alert for every other status clode, including the message
                        let alert = UIAlertController(title: "Error \(statusCode)", message: JSON.value(forKey: "message") as? String, preferredStyle: UIAlertControllerStyle.alert)
                        alert.addAction(UIAlertAction(title: "OK", style: UIAlertActionStyle.default,handler: nil))
                        sender?.present(alert, animated: true, completion: nil)
                    }
                case .failure(let error):
                    //If I had like a status 200 with no content, that would have to be handled here, despite readme saying it's a success regardless of content
                    let alert = UIAlertController(title: "Error", message: error.localizedDescription, preferredStyle: UIAlertControllerStyle.alert)
                    alert.addAction(UIAlertAction(title: "OK", style: UIAlertActionStyle.default,handler: nil))
                    sender?.present(alert, animated: true, completion: nil)
                default:
                    let statusCode = (response.response?.statusCode)! as Int
                    switch statusCode {
                    case 204:
                        //I have to handle status code 204 here
                    default:
                        break
                    }
                    break
                }
            }
```  unable to import Almofire(Xcode 8). So proceeding further is not possible. Please suggest me.  after running "pod install"... build it once by "command + B" to build it...  The Docset generation for Alamofire on CocoaDocs.org is broken for at least v4.2.0 and v.4.1.0.
Please see for yourself: http://cocoadocs.org/docsets/Alamofire/4.2.0/
I can not use the docset in Dash, neither with "Docs for Xcode"  adds missing casting as AnyObject to read me  Hi There,

We're trying to write unit tests around our usage of NetworkReachabilityManager by subclassing it to mock out some behavior for the purposes of tests.  We seem to have identified an issue because the class is marked as open but because of the design of the initializers there doesn't seem to be a way to subclass it in a way that compiles.  Currently there are 3 inits for NetworkReachabilityManager:

1. A private designated initializer
2. A convenience initializer that takes a hostname
3. A convenience initializer that takes no parameters

This is a problem because if we create a subclass there is no way to properly init it as we cannot call the base class designated initializer which is required by the compiler.

Either the initializers need to be adjusted to allow for this or perhaps the class should not be marked as open. To clarify, it wasn't to test the ReachabilityManager, it was a way to mock out its behavior to test OUR code that utilizes the ReachabilityManager üòÑ 

The goal was to make it mockable so you could define a protocol for this which we could mock or adjust the initializers for subclassing.  Either would meet the need.  I have  created a WEB API Controller which it contains a custom class as follow: 

Pulic Class Item {
     Public string Name{get; set;}
}

and a method to submit data: 

public HttpResponseMessage submit(List<Item> items) {

}

in swift 3.0,  I am creating the params as : 
let list : [[String : Dictionary<String, String>]] = [
            ["Item": ["Name" : "Amir"]]
        ]

then I send the request to the server, what I get at server is an Array with no members. Anyone has an idea what is incorrect with my code ? 

I have also tested Item[] instead of List<Item> at my method but it did not work. 

I'd appreciate if any one can help me on this matter.
 bad supporting, none of requests are replied.... shame!  I'm develop in swift2.3, the response resume data is nil when I send request!.cancel(). The request code as below:
```
request = Alamofire
            .download(.GET, downloadFile.url, destination: { [unowned self](url, response) -> NSURL in
                
                return NSURL(fileURLWithPath: self.filePath)
                
                })
            .progress { [unowned self](bytesRead, totalBytesRead, totalBytesExpectedToRead) in
                
                self.readedBytes = totalBytesRead
                
                dispatch_async(dispatch_get_main_queue()) {
                    let buffer = ["file": Int64(self.downloadFile.id), "speed": bytesRead, "readed": totalBytesRead, "all": totalBytesExpectedToRead]
                    GlobalBroadcast_Inst.broadcastMsg(.downloading, msg: buffer)
                }
            }
            .response { [unowned self](request, response, data, error) in
                
                if let error = error {
                    if error.code == NSURLErrorCancelled {
                        debugPrint("Canceled download: request \(request), response \(response), data \(data), error \(error)")
                    } else {
                        debugPrint(error)
                    }
                    
                } else {
                    
                    debugPrint("Downloaded file successfully")
                }
        }
```

The cancel response debug print:
```
"Canceled download: 
request Optional(<NSMutableURLRequest: 0x7f85c9911370> {
 URL: http://211.95.70.126:8080/qjbim-file/upload/44/public/002/2016/11/26/7dd46451-00f6-46cd-8abd-2c7f3378691f.png 
}), 
response Optional(<NSHTTPURLResponse: 0x7f85c76a6eb0> { 
URL: http://211.95.70.126:8080/qjbim-file/upload/44/public/002/2016/11/26/7dd46451-00f6-46cd-8abd-2c7f3378691f.png
 } { 
status code: 200, headers {\n    
\"Accept-Ranges\" = bytes;\n    
\"Content-Disposition\" = \"attachment; filename=2015-09-03 040227.png\";\n    
\"Content-Length\" = 7063823;\n   
 \"Content-Range\" = \"bytes 0-7063822/7063823\";\n    
\"Content-Type\" = png;\n    
Date = \"Sun, 27 Nov 2016 06:02:53 GMT\";\n    
Server = \"Apache-Coyote/1.1\";\n} 
}), 
data nil, 
error Error Domain=NSURLErrorDomain Code=-999 \"cancelled\" UserInfo={
NSErrorFailingURLKey=http://211.95.70.126:8080/qjbim-file/upload/44/public/002/2016/11/26/7dd46451-00f6-46cd-8abd-2c7f3378691f.png, NSLocalizedDescription=cancelled, 
NSErrorFailingURLStringKey=http://211.95.70.126:8080/qjbim-file/upload/44/public/002/2016/11/26/7dd46451-00f6-46cd-8abd-2c7f3378691f.png
}"
```
 @jshier Hi thanks for your reply. I place all the Uploader code here for you refer:
```
import Foundation
import Alamofire

public struct UploadFile {
    var id: String!
    var name: String!
    var data: AnyObject!
    var size: Int!
    var directoryID: Int!
    var status: UploadStatus = UploadStatus.waitting
    var createAt: NSDate = NSDate()
}

public class Uploader: NSObject {

    private var uploadFile: UploadFile!
    
    private(set) public var uploading = false
    
    private var request: Request?
    
    // singleton
    
    public class var sharedInstance: Uploader {
        struct Statics {
            static var instance = Uploader()
        }
        return Statics.instance
    }
    
    override init() {
        super.init()
    }
    
    public func upload(file: UploadFile) {
        uploadFile = file
        upload()
    }
    
    public func cancel(file: UploadFile) {
        if file.id == uploadFile.id, let _ = request {
            self.request?.cancel()
        }
    }
}

extension Uploader {
    
    func upload() {
        
        uploading = true
        
        let parameters = [
            "projectId":"\(UserManager_Inst.projectId)",
            "groupId":"\(UserManager_Inst.groupId)",
            "tokenId":UserManager_Inst.tokenID,
            "parentDirId":"\(uploadFile.directoryID)"
        ]
        Alamofire.upload(
            .POST,
            "\(AppManager_Inst.currentServerAddress)/cloud/uploadFile",
            multipartFormData: { [unowned self] multipartFormData in
                
                if self.uploadFile.data.isKindOfClass(UIImage),
                    let image = self.uploadFile.data as? UIImage,
                    let imageData = UIImagePNGRepresentation(image) {
                    multipartFormData.appendBodyPart(data: imageData, name: "file", fileName: "\(self.uploadFile.name).png", mimeType: "image/png")
                } else {
                    GlobalBroadcast_Inst.broadcastMsg(.uploadError, msg: ["file": "\(self.uploadFile.id)", "code": "\(UploadError.fileError.rawValue)"])
                }
                
                for (key, value) in parameters {
                    multipartFormData.appendBodyPart(data: value.dataUsingEncoding(NSUTF8StringEncoding)!, name: key)
                }
                
            }, encodingCompletion: { [unowned self] encodingResult in
                switch encodingResult {
                case .Success(let upload, _, _):
                    
                    self.request = upload
                    upload.progress { bytesRead, totalBytesRead, totalBytesExpectedToRead in
                        dispatch_async(dispatch_get_main_queue()) {
                            let buffer = ["file": "\(self.uploadFile.id)", "speed": "\(bytesRead)", "readed": "\(totalBytesRead)", "all": "\(totalBytesExpectedToRead)"]
                            GlobalBroadcast_Inst.broadcastMsg(.uploading, msg: buffer)
                        }
                    }
                    upload.responseData(completionHandler: { (response) in
                        
                        self.uploading = false
                        
                        let resp = NewFileResp.parseFromData(response.data!)
                        if resp.responseInfo.responseCode == ResponseCode.Succeed.rawValue {
                            
                            GlobalBroadcast_Inst.broadcastMsg(.uploadError, msg: ["file": "\(self.uploadFile.id)", "code": "\(UploadError.success.rawValue)"])
                            
                        } else {
                            GlobalBroadcast_Inst.broadcastMsg(.uploadError, msg: ["file": "\(self.uploadFile.id)", "code": "\(UploadError.failed.rawValue)"])
                        }
                    })
                    
                case .Failure(let error):
                    self.uploading = false
                    GlobalBroadcast_Inst.broadcastMsg(.uploadError, msg: ["file": "\(self.uploadFile.id)", "code": "\(UploadError.networkError.rawValue)"])
                    print(error)
                }
            }
        )
    }
}

```

I use it as a singleton object in my project and it should alive in the full lifecycle of my app. @cnoon It's my mistake. The response.data is 0 bytes when I do upload.cancel(), sorry for trouble you guys.  I can not find how to set `DataTaskDelegate.dataTaskDidReceiveResponse` closure, or any other because class is internal and not visible outside of framework. I did not found any setters outside of this class too.

same issues with other `TaskDelegate` childs In my case this is not an option. I don't want to keep multiple managers or to apply custom logic for all requests or to set/unset delegate before each 'special' request.
In addition, if you said I need use only sessionDelegate, then what is the purpose of `DataTaskDelegate.dataTaskDidReceiveResponse` there are no setters for this property at all. 

P.S. In my case I move sources to my project, modified them as I wanted and start using internal functionality. However this still seems as an issue for me.   It just seems that cookies don't get saved any more on 10.1.1
I've tested 9.3, 10.0 beta, 10.1 and 10.1.1. Only 10.1.1 seems to have that issue. 
Can somebody confirm? The big question now is, is it an iOS or an Alamofire bug? Ok, it seems like to happen on one device only. I just tested on another device with 10.1.1 and there was no issue. Could any device specific settings cause that?  Request is actually DownloadRequest  In file named ResponseSerialization.swift, extension for `DownloadRequest` and `DataRequest ` with same function body, like: `responseJSON` and `responseString`, some difference with function `jsonResponseSerializer`.  Why not DownloadRequest Inherit DataRequest?  
Bose `DataRequest ` and `UploadRequest`  Inherit `Request`, Why `DownloadRequest ` not.

Thanks. @jshier thx.  I can authenticate with ASCII passwords like "12345", but not with passwords like "√§√º√∂√ü√®√©".

Is there something that I have to do or is tis a bug in alamofire?  I'm using Xcode 8.1 and Swift 3. I just kept minimum deployment target as 8.0. My App have all the requirements as Alamofire 4.0's requirements.

But i could not able to install Alamofire 4.0 using Cocoapods. When i try to install, i got the below error.

**Unable to satisfy the following requirements:
- `Alamofire (~> 4)` required by `Podfile`
Specs satisfying the `Alamofire (~> 4)` dependency were found, but they required a higher minimum deployment target.**

Any solutions ?  Current default variable in SessionManager access is set to open which made me think that i [could override its behaviour](http://stackoverflow.com/q/40725354/999817), while some @robertmryan at [stackoverflow](http://stackoverflow.com/a/40747649/999817) was quick to point out, that default implementation of class shouldnt be overriden. I do think that part of Alamofire helper methods revolve around the default property. Therefore i think it would be appropriate to be able to override this property in either a subclass or an extension to set TrustPolicy objects, custom delegates, or even just a custom configuration object.

After playing around a little longer with alamofire, i created this small extension which allows to either subclass SessionManager or extend it in a category and continue to use helper methods in Alamofire.swift or even use SessionManager.default, as for me as user default should be something that 'suits the needs of my my app'.

Therefore i wonder if this extension is something that could be of use to comunity and something we could integrate in Alamofire. Please let me know.
 I like it. This would be really useful. I don't like the fact the Almofire doesn't provide enough easy extension points. SOLID design says should be open for extension and closed for mutation. Nice I agree, this approach would allow extending the functionality whilst keeping the code under control. +1 @jshier I am not sure i understand what you mean. Alamofire offers different Inits in the SessionManager to override the default behaviour, if you what are saying is such an important behaviour why do these init exist, as far as I can see these inits give the oportunity to "break the entirely of Alamofire".

It seems to me that when a user requires a specific behaviour from alamofire, the user is then responsible for its outcome and for not breaking the framework.

All this pull-request is meant to do, is to redefine as per user requirements the definition of default, and perhaps (i haven't added this) the defaultHeaders property as per the app requirements.
I tend to do work in several corporate places, as per endpoints i connect to, i can see no use of default in its current state. Also i do think that having to subclass SessionManager and create another singleton property just because of this enforcement is a negative experience, as I then loose all Helper request methods in Alamofire.

At least for me and for the type of work i tend to do, i feel that it is important to be able to override the:
- behaviour of SessionConfiguration, 
- add a TrustPolicyManager, 
- or potentially to some just change the default headers.
- sometimes i might even require to change SessionDelegate to stop redirects from occuring.

All these are perfect case scenarios, which could be easily handled by allowing the redefinition of default, and have a default meaning that suits my app needs.

I hope my explanation makes sense. Also if you still prefer to reject this PR, what would be your suggested alternative approach. @jshier I have made some changes to the original implementation where i make sure that the singleton pattern is kept. while allowing to redefine it. It doesnt seem to have updated the pull request.
My question is shall i open a new one, or is this something you guys are not interested at all?? And if not why, as URLSession allows similar behaviour as the one i propose.  This PR fixes improves the README for the `RequestRetrier`. Some OAuth services returns a result that is not convertable to [String:String]. E.g. some services returns an `expire` timestamp as an integer:

```
{
	"token_type": "Bearer",
	"refresh_token": "******************************",
	"access_token": "******************************",
	"expires_in": 36000,
	"scope": "write read"
}
```

Copying the old example from the README would result in an unsuccessful result when refreshing the access token.   ÂêåÈ¢ò„ÄÇÊÄ•ÔºÅÔºÅÔºÅ @noear  ‰∫∫ÂÆ∂ÈÉΩÁúã‰∏çÊáÇ‰Ω†ÁöÑÈóÆÈ¢ò.

How to get the redirected url?
 ÁúüÊòØÂ§™ÁÆÄÂçïÁöÑÔºõÂæàÈÖ∑ÔºÅÔºÅÔºÅ
  This PR aims to resolve #1785 by first trying to return the `URLRequest` from the task. If it‚Äôs `nil` we‚Äôll attempt to return `URLRequest` associated with the `originalTask`, if there is one. As per the https://github.com/Alamofire/Alamofire/issues/1785#issuecomment-261284279.

I‚Äôve also made `Error.underlyingAdaptError` public so that request re-triers can check any underlying adapt errors. I opted to not make the error type public as it might add confusion of what type of error `RequestAdapter`s should throw.

Hopefully this is in line with Alamofire‚Äôs style and with what you where thinking @cnoon. Let me know if you want me to make any changes.

üßÄüç∑ The tests seems to have failed due to some test flakiness and Xcode/simulator flakiness. Unfortunately I can‚Äôt re-trigger them. Ran the tests locally for all platforms (except watchOS) and they all passed ¬Ø_(„ÉÑ)_/¬Ø
 @cnoon Sounds great and what I expected from the API to begin with. Good change üëç
  Added Alamofire.framework to Link Binary With Libraries
created a Run Script
/usr/local/bin/carthage copy-frameworks
Input Files:
$(SRCROOT)/Carthage/Build/iOS/Parse.framework
$(SRCROOT)/Carthage/Build/iOS/Bolts.framework
$(SRCROOT)/Carthage/Build/iOS/Alamofire.framework 

(Was using Parse before and everything was fine, but could not build as soon as I added Alamofire)

Also, frameworks search paths are:
$(inherited)
$(PROJECT_DIR)
$(SRCROOT)/Carthage/build/iOS

Using Swift 3.0
Xcode version 8.1 and Deployment Target is iOS 9.0
Carthage is on the latest version

Xcode displays this message when i try to build my previously working project:
ld: framework not found Alamofire
clang: error: linker command failed with exit code 1 (use -v to see invocation)  I'm relying on my usage of ```NetworkReachabilityManager``` and rejection note from Apple:

> Next Steps
>
> Please revise your app and test it on a device while connected to an IPv6 network (all apps must support IPv6) to ensure that it runs as expected.
>
> Resources
>
> For information about supporting IPv6 Networks, please refer to Supporting IPv6 DNS64/NAT64 Networks and About Networking.

Referenced document [Supporting IPv6 DNS64/NAT64 Networks](https://developer.apple.com/library/mac/documentation/NetworkingInternetWeb/Conceptual/NetworkingOverview/UnderstandingandPreparingfortheIPv6Transition/UnderstandingandPreparingfortheIPv6Transition.html#//apple_ref/doc/uid/TP40010220-CH213-SW1) explicitly states, that:

> The Reachability APIs (see SCNetworkReachability Reference) are intended for diagnostic purposes after identifying a connectivity issue. Many apps incorrectly use these APIs to proactively check for an Internet connection by calling the SCNetworkReachabilityCreateWithAddress method and passing it an IPv4 address of 0.0.0.0, which indicates that there is a router on the network. However, the presence of a router doesn‚Äôt guarantee that an Internet connection exists. In general, avoid preflighting network reachability. Just try to make a connection and gracefully handle failures. If you must check for network availability, avoid calling the SCNetworkReachabilityCreateWithAddress method. Call the SCNetworkReachabilityCreateWithName method and pass it a hostname instead.
>
> Some apps also pass the SCNetworkReachabilityCreateWithAddress method an IPv4 address of 169.254.0.0, a self-assigned link-local address, to check for an active Wi-Fi connection. To check for Wi-Fi or cellular connectivity, look for the network reachability flag kSCNetworkReachabilityFlagsIsWWAN instead.

I'm using 3.4.2 version of Alamofire, and https://github.com/Alamofire/Alamofire/blob/3.4.2/Source/NetworkReachabilityManager.swift#L126 has initializer 

```
    public convenience init?() {
        var address = sockaddr_in()
        address.sin_len = UInt8(sizeofValue(address))
        address.sin_family = sa_family_t(AF_INET)

        guard let reachability = withUnsafePointer(&address, {
            SCNetworkReachabilityCreateWithAddress(nil, UnsafePointer($0))
        }) else { return nil }

        self.init(reachability: reachability)
    }
```

Another versions (for Swift 3 and Swift 2.3) seem to have the same initializer as well.

**My suggestion here:**

To remove this convenience initializer to discourage usage of arbitrary reachability checks without address / or with direct IPv4 Hello! tengo una pregunta ¬øtodas las versiones de Alamofire son compatibles con IPV6?  Alamofire.download("url","headers").responseData 
not work if i don't define the "to: destination" and give me exception:

**"Response could not be serialised, input file could not be read: file url in temp location"**

and if i use the "destination" with this options

```swift
let destination: DownloadRequest.DownloadFileDestination = { _, _ in
    let documentsURL:URL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
    let fileURL:URL = documentsURL.appendingPathComponent("peer.pdf")

    return (fileURL, [.removePreviousFile, .createIntermediateDirectories])
}
```  ```swift
func uploadFile( request sourceRequest: NSMutableURLRequest){
        sourceRequest.httpMethod="POST"
        let boundary = "FileUploader-boundary-\(arc4random())-\(arc4random())"
        sourceRequest.setValue( "multipart/form-data;boundary=\(boundary)", forHTTPHeaderField: "Content-Type")
        let data = NSMutableData()
        
        for (name, value) in headers {
            sourceRequest.setValue(value, forHTTPHeaderField: name)
        }
        
        // Amazon S3 (probably others) wont take parameters after files, so we put them first
        for (key, value) in parameters {
            data.append("\r\n--\(boundary)\r\n".data(using: String.Encoding.utf8)!)
            data.append("Content-Disposition: form-data; name=\"\(key)\"\r\n\r\n\(value)".data(using: String.Encoding.utf8)!)
        }
        
        for fileUploadInfo in files {
            data.append( "\r\n--\(boundary)\r\n".data(using: String.Encoding.utf8)! )
            data.append( "Content-Disposition: form-data; name=\"\(fileUploadInfo.name)\"; filename=\"\(fileUploadInfo.fileName)\"\r\n".data(using: String.Encoding.utf8)!)
            data.append( "Content-Type: \(fileUploadInfo.mimeType)\r\n\r\n".data(using: String.Encoding.utf8)!)
            if fileUploadInfo.data != nil {
                data.append( fileUploadInfo.data! as Data )
            }
            else if fileUploadInfo.url != nil, let fileData = NSData(contentsOf: fileUploadInfo.url! as URL) {
                data.append( fileData as Data )
            }
            else { // ToDo: report error
                print("error")
            }
        }
        data.append("\r\n--\(boundary)--\r\n".data(using: String.Encoding.utf8)!)
        sourceRequest.httpBody=data as Data
        Alamofire.upload(data as Data, with: request as URLRequest).responseString{
            response in
          if response.result.error == nil {
                print(response)
            }else{
                print(response.result.error!)
            }
        }
    }
```

I am uploading using this code, but if images count >3 it does not working  I‚Äôm in the process of updating to 4.1.0 to adopt the new behavior of the request retried and adapter introduced with #1682. Unfortunately I ran into some troubles. The intention was to make sure we refresh the access token before making any requests if it has expired. So I made the our `RequestAdapter` throw a `missingAccessToken` if the token is expired. That‚Äôs when the troubles started.

For context; we have a setup which allows different parts of the app to provide authorizers to the network layer for specific hosts. As such I need to check which host a request was for in order to tell the associated authorizer to refresh its access token.

When the adapter throws the error for a request that hasn‚Äôt touched the actual network we can‚Äôt actually refresh the token. Because the `Request` object given the `RequestRetrier` returns `nil` for both the `request` and `task` properties. As such I can‚Äôt check which host the request is going to try and reach. However the `Request` object does in fact have a reference to the `URLRequest` via the original data task. That property is internal to Alamofire.

To work around this I decided to extend our `missingAccessToken` error case with the host, ala:
```swift
public enum AuthorizerError: Error {
    case missingAccessToken(host: String)
}
```

This doesn‚Äôt work either though since `AdaptError` is also internal üòÑ As such I can‚Äôt check if the `Error` object given to the retrier is of that type and then extract the underlying error. The same is true for the `underlyingAdaptError` category on `Error` so I‚Äôm unable to use that.

As such I‚Äôm stuck with not knowing anything about the request that failed. Or am I missing something obvious?

---

To remedy this I‚Äôd like to propose a few solutions:
- Change so that the `request` property ‚Äúalways<sup>1</sup>‚Äù returns the `URLRequest` associated with it. This could be accomplished
  - Change so that `Request.task` returns `originalTask` as a `URLSessionTask` if the `delegate.task` property returns `nil`.
  - Change so that `Request.urlRequest` returns `originalTask`‚Äôs `originalRequest` value if `task?.originalRequest` is `nil`.
- Change `AdaptError` and its `error` property to be public.
- Change `Error.underlyingAdaptError` to be public.

Obviously several of these changes could made at the same time to support different use cases. Which one do you prefer? Or is there some other solution you‚Äôd rather have? I‚Äôm open to submitting a PR.

---

1. I.e. when there is a `URLRequest`, obviously not for certain types of requests which doesn‚Äôt have one. @cnoon I agree that the solution under the ‚ÄúSolution‚Äù heading is the correct one. I‚Äôll try find some time this week to send a PR, also quite swamped with stuff to do üòÖ
  Hi, I'm writing an iOS app in Swift 3 using Alamofire 4. I'm opening an external app from my own app and then trying to redirect _back_ to my app. The external app is looking for the `redirect` key in the URL to send the user back to my app. 

I can't find anything in your docs or online about this, and several attempts in code haven't clarified things for me. Could you confirm if I could do something like this with Alamofire?

```
let url = URL(string: "extapp:///?key=\(data!)&redirect=\(myapp)://key")
UIApplication.shared.open(url!, options: [:])
```  I tried to use NetworkReachabilityManager as follow in the iOS example, but it doesn't work correctly:

1. When I just start the app, it shows: 

> status :reachable(Alamofire.NetworkReachabilityManager.ConnectionType.ethernetOrWiFi)
> status :notReachable

2. And I turned the airplane mode on to disconnect the internet, it didn't respond to show me the internet is off.

3. When I turned the airplane mode, it shows 

> statuslala :reachable(Alamofire.NetworkReachabilityManager.ConnectionType.ethernetOrWiFi)
> statuslala :notReachable
> statuslala :reachable(Alamofire.NetworkReachabilityManager.ConnectionType.ethernetOrWiFi)
> statuslala :notReachable

The result is not correct. Can you please figure it out what's the problem?

---------

The testing profile is:
Xcode 8.2 beta
iPhone 6, iOS 10.1.1
The newest Alamofire commit: 928cdae0c54957cb53a6873ec64a109bc6a1be60
Under 3G internet

```
class MasterViewController: UITableViewController {

    @IBOutlet weak var titleImageView: UIImageView!

    let manager = NetworkReachabilityManager(host: "https://www.apple.com/")
    
    var detailViewController: DetailViewController? = nil
    var objects = NSMutableArray()

    override func awakeFromNib() {
        super.awakeFromNib()

        navigationItem.titleView = titleImageView
        
        weak var wSelf = self
        manager?.listener = {status in
            print("statuslala :\(status)")
            let alert = UIAlertController(title: "Alert", message: "status:\(status)", preferredStyle: .alert)
            alert.addAction(UIAlertAction(title: "Click", style: .default, handler: nil))
            wSelf?.present(alert, animated: true, completion: nil)
        }
        
        manager?.startListening()
    }
``` Awesome! Problem sovled. I hope this colsed issue helpful to others...
  Please release on swift 3.0 :)))  Hi,

I think Alamofire 4.0 support Swift-3 but the minimum target is iOS-9. And Alamofire 3.x versions support iOS-8 but this doesnt support Swift-3. So how can I use Alamofire in a Swift-3 app which support iOS-8.??      open func suspend() {
        guard let task = task else { return }

        task.suspend()

        NotificationCenter.default.post(
            name: Notification.Name.Task.DidSuspend,
            object: self,
            userInfo: [Notification.Key.Task: task]  <- here
        )
    }

    /// Cancels the request.
    open override func cancel() {
        downloadDelegate.downloadTask.cancel { self.downloadDelegate.resumeData = $0 }

        NotificationCenter.default.post(
            name: Notification.Name.Task.DidCancel,
            object: self,
            userInfo: [Notification.Key.Task: task as Any]  <- here
        )
    }


alamofire is compiled. (ok)
but in my project (failed)
 
here -> userInfo: [Notification.Key.Task: task as Any]

5's error

Ambiguous use of 'Task'
 Request.swift 
Ambiguous use of 'Task'
 SessionDelegate.swift 
 I'm experiencing the identical issue. Does anyone know a good work-around with swift3?
 Experiencing same issue on 4.4.0 Experiencing this as well on 4.4.0

Same 5 errors. same issue on 4.4.0 same issue on 4.4.0 Same here same issue on 4.5.0  env: ios 10.1, swift 3.0, Alamofire 4.0

Download data from URL:
```
let destination: DownloadRequest.DownloadFileDestination = { _, _ in
                            let documentsPath = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)[0]
                            let documentsURL = URL(fileURLWithPath: documentsPath, isDirectory: true)
                            let fileURL = documentsURL.appendingPathComponent("tmp.json")
                            return (fileURL, [.removePreviousFile, .createIntermediateDirectories])
                        }
                        Alamofire.download(someUrl, to: destination)
                            .downloadProgres { progress in
                                DDLogDebug("download report progress:\(progress.fractionCompleted)")
                                self.updateProgressView.progress = Float(progress.fractionCompleted)
                        }
```

The data (about 10MB) can be downloaded successfully, I only received fractionCompleted=0.0 during downloading.

How can I fix the problem? same problem here

:/
 I got the same problem same problem. Anyone, solve this problem? I am working on getting the download progress of Alamofire too, but I also met this issue. any help pls? ugh! same problem.
 I find if the server is not a support streaming server, **fractionCompleted** will be always zero @ShiWeiCN Yes correct I'm having the same issue, but ShiWeiCN could be right.  I've the same issue 
 Same issue The same issue Hi, still having this issue. i am using Using Alamofire (4.4.0). is there any updates on this? thanks. I was having this problem and I was able to fix it adding the `Content-Length` header to my server response.  The same issue,  fix it adding the Content-Length header to  server response is greatfull. same problem.  Can you give me an example of working with cookies?
How to add a cookie to my request and read response cookie?



Thanks in advance

  The server can not get the parameters
 Please elaborate
  The podspec needs the ios and macos targets to be updated to 8.0 and 10.10
    Hi

I am writing a client via Alamofire. 


        // Asynchronously make a get request to the end point.         
Alamofire.request(.GET, escapedUrlPath, headers:customHeaderPayLoad).validate().responseJSON { response in
            
            let latency = response.timeline.latency
            print(latency)
                
            switch response.result {
            case .Success(let data):
                successCallback(data: data)
                self.recordLatency(latency)
            case .Failure(let error):
        }

My question is that since Alamofire caches responses by default, the first call has high latency (e.g 0.5 seconds) and subsequent calls on the same url are much faster (0.01 seconds). 

I need a mechanism to only record calls when response did not come from a cache. 
  Using

- Xcode 8.1 (8B62)
- iOS 9-10
- Swift 3
- Alamofire 4.0.1

After updating my XCode yesterday my app will not archive. However, It will build and run on the simulator and external devices. I am not sure if this is a cocoapods, XCode, or Alamofire issue.

This is the error I am getting:
`ld: 2 duplicate symbols for architecture arm64
clang: error: linker command failed with exit code 1 (use -v to see invocation)`

I have tried:

pod deintegrate
pod install
open project
clean (command + alt + shift + K)
Archive

Uninstalling cocoapods
Reinstalling cocoapods
pod install
Clean
Archive

This is what my pod file looks like:

```source 'https://github.com/CocoaPods/Specs.git'
platform :ios, '9.0'
use_frameworks!

target 'my project' do
    pod 'Alamofire', '~> 4.0'
end

post_install do |installer|
    installer.pods_project.targets.each do |target|
        target.build_configurations.each do |config|
           config.build_settings['SWIFT_VERSION'] = '3.0'
        end
   end
end  Hi guys

I have an issue with the injection of the URLSessionConfiguration. This code without a specific configuration object works and the response is not nil:
`let sessionManager = Alamofire.SessionManager.default
  sessionManager.request(poiMethodName, method: .get, parameters: parameters)
            .validate()
            .responseJSON(queue: networkQueue) { response in
              // Some parsing code here
 }`

However if I inject a default configuration into a Session Manager the response object is nil:
`let configuration = URLSessionConfiguration.default
  let sessionManager = Alamofire.SessionManager(configuration: configuration)
  sessionManager.request(poiMethodName, method: .get, parameters: parameters)
            .validate()
            .responseJSON(queue: networkQueue) { response in
              // Some parsing code code
 }`

Some ideas what is going wrong here?

Kind regards
Dennis  ERROR ITMS-90209: "Invalid Segment Alignment. The app binary at 'XXXX.app/Frameworks/Alamofire.framework/Alamofire' does not have proper segment alignment. Try rebuilding the app with the latest Xcode version."

-----------------but my Xocde is 8.1

ERROR ITMS-90087: "Unsupported Architectures. The executable for XXXX.app/Frameworks/Alamofire.framework contains unsupported architectures '[x86_64]'."

  Hello guys,

I've a big problem when I try to update an image to my Db.

I must to upload an image, and some string value.

```
 func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) {
        if let selectedImage = info[UIImagePickerControllerOriginalImage] as? UIImage {
            imageCropped = selectedImage
            self.sendImageWithMultipart()
            imagePicker.dismiss(animated: true, completion: { _ in })
        }
    }
```

```
func sendImageWithMultipart() {        
        Alamofire.upload(multipartFormData: {
            multipartFormData in
            multipartFormData.append("\(HGYGjihf746fg743g)".data(using: String.Encoding.utf8, allowLossyConversion: false)!, withName :"auth_token")
            multipartFormData.append("\(0)".data(using: String.Encoding.utf8, allowLossyConversion: false)!, withName :"os")
            multipartFormData.append("\(10.0.3)".data(using: String.Encoding.utf8, allowLossyConversion: false)!, withName :"os_version")
            multipartFormData.append("\(3.0.3)".data(using: String.Encoding.utf8, allowLossyConversion: false)!, withName :"app_version")
            
            if let photo = self.imageCropped, let jpegImage = UIImageJPEGRepresentation(photo, 50.0) {
                print(jpegImage)
                multipartFormData.append(jpegImage, withName: "profile_photo", mimeType: "image/*")
            }
        }, to: "\(Constants.GENERAL_ADDRESS_2)\(Constants.API_MODIFYUSER_PROFILE_PHOTO)", method:.post, headers:["Content-Type":"multipart/form-data; charset=utf-8; boundary=__X_PAW_BOUNDARY__"], encodingCompletion: {
            encodingResult in
            switch encodingResult {
            case .success(request: let upload, streamingFromDisk: _, streamFileURL: _):
                upload.validate().responseJSON {
                    response in
                    if response.result.isFailure {
                        debugPrint(response)
                    } else {
                        debugPrint(response)
                    }
                }
            case .failure(let encodingError):
                NSLog((encodingError as NSError).localizedDescription)
            }
        })
    }
```

but the result is this:

```
[Request]: "\(Constants.GENERAL_ADDRESS_2)\(Constants.API_MODIFYUSER_PROFILE_PHOTO)"
[Response]: <NSHTTPURLResponse: 0x17023c0e0> { URL: "\(Constants.GENERAL_ADDRESS_2)\(Constants.API_MODIFYUSER_PROFILE_PHOTO)" } { status code: 500, headers {
    "Cache-Control" = "no-cache, private";
    Connection = close;
    "Content-Length" = 5545;
    "Content-Type" = "text/html; charset=UTF-8";
    Date = "Thu, 10 Nov 2016 10:49:00 GMT";
    Server = "Apache/2.4.18 (Amazon) OpenSSL/1.0.1k-fips PHP/5.6.21";
    "X-Powered-By" = "PHP/5.6.21";
} }
[Data]: 5545 bytes
[Result]: FAILURE: responseValidationFailed(Alamofire.AFError.ResponseValidationFailureReason.unacceptableStatusCode(500))
[Timeline]: Timeline: { "Request Start Time": 500467740.667, "Initial Response Time": 500467740.793, "Request Completed Time": 500467743.733, "Serialization Completed Time": 500467743.733, "Latency": 0.126 secs, "Request Duration": 3.066 secs, "Serialization Duration": 0.000 secs, "Total Duration": 3.066 secs
```

the problem is how I convert the Image, or the Content type or what? 

thank you  We are updating to Swift 3 and therefore to the latest Alamofire version. Unfortunately the signature of the Result enum changed.

```
-public enum Result<Value, Error: Swift.Error> {
+public enum Result<Value> {
```
https://github.com/Alamofire/Alamofire/commit/7b419b76a48b7c6e6b676ccc5d66e64cb00c93c2#diff-7a1ba79e4a1bfd6430ca2070dcbc3ea0

We were using the generic error type to implement our custom response serializer. Our rest api delivers json objects in case of an error. We would like to map the error response using ObjectMapper.

Is there a way to implement this feature using the current Alamofire API?

```swift
public enum ErrorInfoJson<T: Mappable>: ErrorType {
    case Canceled
    case Network(ErrorInfoMessage)
    case UnexpectedStatusCode(Int, T?)
    case ParseError
}
```

```swift
public func responseObjectErrorInfoJson<T: Mappable, E: Mappable>(completionHandler: Response<T, ErrorInfoJson<E>> -> Void) -> Self {
    return response(queue: nil, responseSerializer: Request.ObjectErrorInfoJsonResponseSerializer(), completionHandler: completionHandler)
}
```

```swift
public static func ObjectErrorInfoJsonResponseSerializer<T: Mappable, E: Mappable>() -> ResponseSerializer<T, ErrorInfoJson<E>> {
    return ResponseSerializer { request, response, data, error in
        guard error == nil else {
            return parseErrorInfoJson(request, response: response, data: data, error: error!)
        }
        
        if let parsedObject: T = parseJson(request, response: response, data: data, error: error) {
            return .Success(parsedObject)
        }
        
        return .Failure(.ParseError)
    }
}
```

```swift
private static func parseErrorInfoJson<T, E: Mappable>(request: NSURLRequest?, response: NSHTTPURLResponse?, data: NSData?, error: NSError) -> Result<T, ErrorInfoJson<E>> {
    if error.code == NSURLErrorCancelled {
        return .Failure(.Canceled)
    }
    
    guard let statusCode = response?.statusCode else {
        return .Failure(.Network(ErrorInfoMessage(error: error)))
    }
    
    // error = nil, da der Response nur im Erfolgsfall deserialisiert wird
    let parsedObject: E? = parseJson(request, response: response, data: data, error: nil)
    return .Failure(.UnexpectedStatusCode(statusCode, parsedObject))
}
```  Error Domain=NSURLErrorDomain Code=-999 "cancelled" UserInfo={NSErrorFailingURLKey=https://myURL, NSLocalizedDescription=cancelled, NSErrorFailingURLStringKey=https://https://myURL}), _metrics: nil)

This error occurs while trying to upload images as multipartFormData.

this is my code:
` var headers = Dictionary<String,String>()
        var defaultHeaders = Alamofire.SessionManager.defaultHTTPHeaders
        if let token = UserDefaults.standard.object(forKey: "jwt") as? String{
            defaultHeaders["Authorization"] = "Bearer " + token
        }
        
        let configuration = URLSessionConfiguration.default
        configuration.httpAdditionalHeaders = headers
        
        let sessionManager = Alamofire.SessionManager(configuration: configuration)
        
        sessionManager.upload(multipartFormData: { (multipartFormData) in
            for imageURL in imagesURLs{
                multipartFormData.append(imageURL, withName: "file[]")
            }
        }, to: "\(devURL)/resources/image", encodingCompletion: { encodingResult in
            
            switch encodingResult {
                
            case .success(let upload, _, _):
                upload.response { response in
                    print(response)
                }
            case .failure(let encodingError):
                print(encodingError)
            }
            
        })` Thanks!
  Hi Team, 

I was setting up a project, instead of using cocoapods i tried carthage for the first time. Everything went perfect and then developers thing happened :)

i am facing this issue, please suggest how to fix this.

my Xcode version is 8.0
git version 2.8.4 (Apple Git-73)
and carthage version 0.18.1: Redundant Redundancy

*** Fetching Alamofire
*** Checking out Alamofire at "4.0.1"
*** xcodebuild output can be found in /var/folders/v1/4631b9hn10g6yppr2c6k8jjr0000gn/T/carthage-xcodebuild.MRfbSY.log
*** Building scheme "Alamofire macOS" in Alamofire.xcworkspace
2016-11-09 17:57:56.855 xcodebuild[5784:145495] [MT] PluginLoading: Required plug-in compatibility UUID 8A66E736-A720-4B3C-92F1-33D9962C69DF for plug-in at path '~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/RealmPlugin.xcplugin' not present in DVTPlugInCompatibilityUUIDs
2016-11-09 17:57:57.036 xcodebuild[5784:145495] WARNING: Failed to load plugin at path: "/Users/developerclan/Library/Application Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin", skipping. Error: Error Domain=NSCocoaErrorDomain Code=3587 "dlopen_preflight(/Users/developerclan/Library/Application Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin/Contents/MacOS/Alcatraz): no suitable image found.  Did find:
	/Users/developerclan/Library/Application Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin/Contents/MacOS/Alcatraz: mmap() error 1 at address=0x112244000, size=0x00018000 segment=__TEXT in Segment::map() mapping /Users/developerclan/Library/Application Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin/Contents/MacOS/Alcatraz" UserInfo={NSLocalizedFailureReason=The bundle is damaged or missing necessary resources., NSLocalizedRecoverySuggestion=Try reinstalling the bundle., NSFilePath=/Users/developerclan/Library/Application Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin/Contents/MacOS/Alcatraz, NSDebugDescription=dlopen_preflight(/Users/developerclan/Library/Application Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin/Contents/MacOS/Alcatraz): no suitable image found.  Did find:
	/Users/developerclan/Library/Application Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin/Contents/MacOS/Alcatraz: mmap() error 1 at address=0x112244000, size=0x00018000 segment=__TEXT in Segment::map() mapping /Users/developerclan/Library/Application Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin/Contents/MacOS/Alcatraz, NSBundlePath=/Users/developerclan/Library/Application Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin, NSLocalizedDescription=The bundle ‚ÄúAlcatraz‚Äù couldn‚Äôt be loaded because it is damaged or missing necessary resources.}
** BUILD FAILED **


The following build commands failed:
	CompileSwift normal x86_64
	CompileSwiftSources normal x86_64 com.apple.xcode.tools.swift.compiler
(2 failures)
/Users/developerclan/Desktop/Shahriyar(Work)/API document/GarbageProd/Carthage/Checkouts/Alamofire/Source/TaskDelegate.swift:218:70: error: use of undeclared type 'CachedURLResponse'
/Users/developerclan/Desktop/Shahriyar(Work)/API document/GarbageProd/Carthage/Checkouts/Alamofire/Source/TaskDelegate.swift:273:45: error: use of undeclared type 'CachedURLResponse'
/Users/developerclan/Desktop/Shahriyar(Work)/API document/GarbageProd/Carthage/Checkouts/Alamofire/Source/TaskDelegate.swift:274:39: error: use of undeclared type 'CachedURLResponse'
/Users/developerclan/Desktop/Shahriyar(Work)/API document/GarbageProd/Carthage/Checkouts/Alamofire/Source/SessionDelegate.swift:89:75: error: use of undeclared type 'CachedURLResponse'
/Users/developerclan/Desktop/Shahriyar(Work)/API document/GarbageProd/Carthage/Checkouts/Alamofire/Source/SessionDelegate.swift:93:89: error: use of undeclared type 'CachedURLResponse'
/Users/developerclan/Desktop/Shahriyar(Work)/API document/GarbageProd/Carthage/Checkouts/Alamofire/Source/SessionDelegate.swift:532:45: error: use of undeclared type 'CachedURLResponse'
/Users/developerclan/Desktop/Shahriyar(Work)/API document/GarbageProd/Carthage/Checkouts/Alamofire/Source/SessionDelegate.swift:533:39: error: use of undeclared type 'CachedURLResponse'
/Users/developerclan/Desktop/Shahriyar(Work)/API document/GarbageProd/Carthage/Checkouts/Alamofire/Source/TaskDelegate.swift:276:29: error: use of undeclared type 'CachedURLResponse'
A shell task (/usr/bin/xcrun xcodebuild -workspace "/Users/developerclan/Desktop/Shahriyar(Work)/API document/GarbageProd/Carthage/Checkouts/Alamofire/Alamofire.xcworkspace" -scheme "Alamofire macOS" -configuration Release ONLY_ACTIVE_ARCH=NO CODE_SIGNING_REQUIRED=NO CODE_SIGN_IDENTITY= CARTHAGE=YES clean build) failed with exit code 65:
2016-11-09 17:57:56.855 xcodebuild[5784:145495] [MT] PluginLoading: Required plug-in compatibility UUID 8A66E736-A720-4B3C-92F1-33D9962C69DF for plug-in at path '~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/RealmPlugin.xcplugin' not present in DVTPlugInCompatibilityUUIDs
2016-11-09 17:57:57.036 xcodebuild[5784:145495] WARNING: Failed to load plugin at path: "/Users/developerclan/Library/Application Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin", skipping. Error: Error Domain=NSCocoaErrorDomain Code=3587 "dlopen_preflight(/Users/developerclan/Library/Application Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin/Contents/MacOS/Alcatraz): no suitable image found.  Did find:
	/Users/developerclan/Library/Application Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin/Contents/MacOS/Alcatraz: mmap() error 1 at address=0x112244000, size=0x00018000 segment=__TEXT in Segment::map() mapping /Users/developerclan/Library/Application Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin/Contents/MacOS/Alcatraz" UserInfo={NSLocalizedFailureReason=The bundle is damaged or missing necessary resources., NSLocalizedRecoverySuggestion=Try reinstalling the bundle., NSFilePath=/Users/developerclan/Library/Application Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin/Contents/MacOS/Alcatraz, NSDebugDescription=dlopen_preflight(/Users/developerclan/Library/Application Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin/Contents/MacOS/Alcatraz): no suitable image found.  Did find:
	/Users/developerclan/Library/Application Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin/Contents/MacOS/Alcatraz: mmap() error 1 at address=0x112244000, size=0x00018000 segment=__TEXT in Segment::map() mapping /Users/developerclan/Library/Application Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin/Contents/MacOS/Alcatraz, NSBundlePath=/Users/developerclan/Library/Application Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin, NSLocalizedDescription=The bundle ‚ÄúAlcatraz‚Äù couldn‚Äôt be loaded because it is damaged or missing necessary resources.}
** BUILD FAILED **


The following build commands failed:
	CompileSwift normal x86_64
	CompileSwiftSources normal x86_64 com.apple.xcode.tools.swift.compiler
(2 failures)


 How does your `Cartfile` look?
 @eimantas Here's the screenshot of my Cartfile
![cartfile](https://cloud.githubusercontent.com/assets/23359630/20167250/1ab5c86e-a73c-11e6-850e-87bde5668a78.png)
 What command are you using for building through Carthage?
 @eimantas i 've tried carthage update, and carthage update --platform iOS. both commands results the same
 Can you try updating to the latest Xcode (8.1)?
 @eimantas yes, i've installed xcode 8.1 and tried, but again failed. I've 7.3, 8.0 and, 8.1 xcode versions installed in my system and default is 8.1, yesterday i installed carthage on a system successfully and working, that contains only xcode 8.0. This looks not logical but could this be the reason?
 It depends on which version you see in Xcode's Preferences.
 Thanks a lot, it helped when changed the command line tool from xcode 8.0 to 8.1 from xcode preferences.
  I know that this has already been discussed, but I guess that the decision of Apple to drop SWIFT 2.3 support in xcode releases after 8.2 could open different scenarios.
I've already read the reason around making Alamofire 4 available only from iOS9 and I agree, but after this Apple decision this means that for further apps release we are obliged to migrate to Alamofire 4 and drop iOS8 support.

This is quite a big issue (most of clients still request for iOS8 support), I'd like to know if there are plans to migrate Alamofire 3 to SWIFT 3.

Thank you,
Andrea - 1 like for you.
  The same to you :-(
  Please!
 @cnoon awesome. Thank you!
  Hi! After migrating and converting my code to swift 3 I have this troubles:
`Alamofire.request(url, method: .get, parameters: data, encoding: .URL, headers: headers).responseJSON...` shows error "Extra argument 'method' in call".

aslo trouble with multipart upload:

`Alamofire.upload(
            multipartFormData: { mfdata in
              // ... code ...
            },
            treshhold: SessionManager.multipartFormDataEncodingMemoryThreshold,
            to: baseURL + url,
            method: .post,
            headers: headers
        )` { encoding result in
          // ... code ...
         }

shows "Ambigious reference to member 'upload(_:to:method:headers:)'"    Is multipart/mixed content type supported?

A real-world requirement: https://developer.ringcentral.com/api-docs/latest/index.html#!#RefCreateFaxMessage Hey @tylerlong, Alamofire.upload() has a variant for this. There's this example in readme.md:

``` swift
Alamofire.upload(
    multipartFormData: { multipartFormData in
        multipartFormData.append(unicornImageURL, withName: "unicorn")
        multipartFormData.append(rainbowImageURL, withName: "rainbow")
    },
    to: "https://httpbin.org/post",
    encodingCompletion: { encodingResult in
        switch encodingResult {
        case .success(let upload, _, _):
            upload.responseJSON { response in
                debugPrint(response)
            }
        case .failure(let encodingError):
            print(encodingError)
        }
    }
)
```
 @rudedogg  thank you for your response. I am not sure if it's what I want because `multipart/form-data` is not identical to `multipart/mixed`.
 @tylerlong No problem, I didn't know that! I found this comment from last year: https://github.com/Alamofire/Alamofire/issues/591#issuecomment-145278550

Maybe it's been added. Good luck üçÄ 
 @cnoon 

Hi Christian,

Our backend is expecting multipart/mixed and right now is there a different way than editing the source code of Alamofire? It works when I go in the MultipartFormData() class and change the multipart/form-data to multipart/mixed. 

I hope you can help me out!

Cheers,
Kevin  
I have successfully got keychain for my token and passing it to AccessTokenAdapter class shown below. http127.0.0.1:8000/api2/projects/?format=json is passed as projectsURL.
however, from print(error), my Xcode shows error like Error Domain=NSURLErrorDomain Code=-999 "cancelled" UserInfo={NSErrorFailingURLKey=http://127.0.0.1:8000/api2/projects/?format=json, NSLocalizedDescription=cancelled, NSErrorFailingURLStringKey=http127.0.0.1:8000/api2/projects/?format=json}

Any ideas?
Alamofire 4.0
Keychain
Xcode 8.1
Swift3
Using JWT for authentication 
Using Postman with header, key = "Authentication", value = "JWT (token generated here)" works fine




        class AccessTokenAdapter: RequestAdapter {
            private let accessToken: String
            
            init(accessToken: String) {
                self.accessToken = accessToken
            }
            
            func adapt(_ urlRequest: URLRequest) throws -> URLRequest {
                var urlRequest = urlRequest
             //   print("JWT \(accessToken)")
                urlRequest.setValue("JWT \(accessToken)", forHTTPHeaderField: "Authorization")
                
                return urlRequest
            }
        }
 
        
        let sessionManager = SessionManager()
        sessionManager.adapter = AccessTokenAdapter(accessToken: self.keychain["token"]!)
        
        sessionManager.request(self.projectsURL, method: .get, encoding: JSONEncoding.default).responseJSON{ response in
            switch response.result {
            case .success:
                print("yey I made it")
            case .failure(let error):
                print(error)
            }
        }
 Just solved.

```
    let url = URL(string: "http://127.0.0.1:8000/api2/projects/?format=json")
    var urlRequest = URLRequest(url:url!)
    urlRequest.httpMethod = HTTPMethod.get.rawValue
    urlRequest.addValue("JWT \(self.keychain["token"]!)", forHTTPHeaderField: "Authorization")
    urlRequest.addValue("application/json", forHTTPHeaderField: "Accept")
    Alamofire.request(urlRequest)
        .responseJSON { response in
            debugPrint(response)
    }
```
  I receive data in windowsCP1251 encoding, so very often .responseJSON fails.
Now I use this solution:

```
let originalString = NSString(data:data!, encoding:String.Encoding.windowsCP1251.rawValue)
let utf8data = originalString?.data(using: String.Encoding.utf8.rawValue)     
if let jsonResult = try JSONSerialization.jsonObject(with: utf8data!, options: JSONSerialization.ReadingOptions.allowFragments) as?
```

But how to do this using Alamofire?  Using Alamofire (4.0.1)

I just upload a sample to demonstrate memory leak, it is just a demo project without any other frameworks. Would you like to check it out? 

https://github.com/wongzigii/AlamofireMemoryLeak

<img width="1282" alt="memoryleak" src="https://cloud.githubusercontent.com/assets/7384288/20035352/5500d7e4-a41b-11e6-9b8a-71dbd1ee7fab.png">



  After I update Alamofire my project not work
here the problem

http://stackoverflow.com/questions/40442675/alamofire-not-working-well-with-swift-3?noredirect=1#40442675 I have had some weird issues with this type of stuff. One time it took me cleaning the build folder and restarting Xcode a few times to resolve.

The other thing you could try is:
1. **Make sure your project is committed to Git, or create a backup folder**
2. Install [cocoapods-deintegrate](https://github.com/CocoaPods/cocoapods-deintegrate)
3. Close Workspace
4. `pod deintegrate`
5. `pod install`
6. Open Workspace
7. Run "Clean Build Folder" (alt + Product->Clean Build Folder)
8. Build
  time to updata please Just starting out with swift this week, and I am getting this error:

> No such module 'Alamofire'

is it because of Swift 3.0.1?
 @CompassCanJV no ,it is because you have not build it ,make sure you Installation the module in the right way ,and try shift+command +B 
 Same problem here. Any updates?
 pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :tag => '4.0.0'

This worked for me
 I got it working with Carthage using $carthage update --platform iOS --no-use-binaries
 I found what helped is that after updating is deleting your derived data (Preferences > Locations > Derived Data). @nassarofficial That did the trick for me too. Thanks much!   I am using Alamofire 3.5.0 to upload assets (image/video) as multipart form data. It works fine for file sizes below 300MB (app). When I try to upload a file greater than 300MB, app crashes.

```swift
if let video = self.avPlayerItem?.asset as? AVURLAsset {
    if let assetData = NSData(contentsOfURL: video.URL) {
        multipartFormData.appendBodyPart(data: assetData, name: "file", fileName: "video", mimeType: "video/mp4") // Execution stops here
    }
}
```
I also get the below message from Xcode
![wsdga](https://cloud.githubusercontent.com/assets/15630031/19995143/82402d60-a27a-11e6-85a3-bb406622d5bd.png)
How would I support uploading huge sized videos using Alamofire?

[My StackOverflow post](http://stackoverflow.com/questions/40398201/alamofire-upload-huge-file) 
![Uploading Screen Shot 2017-04-07 at 2.08.11 PM.png‚Ä¶]()
Hi 
when try to upload the assetURL.url to sever im getting the error 


ErrorReportmultipartEncodingFailed(Alamofire.AFError.MultipartEncodingFailureReason.bodyPartURLInvalid(assets-library://asset/asset.mp4?id=1CEBF789-632D-4634-839E-5707D18CEBE9&ext=mp4))  ![screen shot 2016-11-04 at 9 58 43 am](https://cloud.githubusercontent.com/assets/8614189/19994535/604f5654-a275-11e6-8844-138f6fedd475.png)
 Please add a description for your issue more informations would be really helpful...
  ÊàëÊÉ≥ËØ∑Êïô‰∏™ÈóÆÈ¢ò,‰∏∫‰ªÄ‰πàÊñ∞ÁâàÊú¨ÁöÑalamofireÊîØÊåÅ‰∫Üxcode8‰ΩÜÊòØ‰∏∫‰ªÄ‰πà‰∏çÊîØÊåÅios8‰∫ÜÂë¢,Â∞±ËøûËãπÊûúÂÆòÊñπÈÉΩËøòÊîØÊåÅios8Âë¢,ËÄå‰∏îËøòÊúâÂ•ΩÂ§ß‰∏ÄÈÉ®ÂàÜÁî®Êà∑ËøòÂú®‰ΩøÁî®ios8ÁöÑÁ≥ªÁªü,Â¶ÇÊûú,ÊàëÈúÄË¶ÅÊîØÊåÅios8-ios10ÁöÑÁ≥ªÁªüÁöÑÁî®Êà∑,Êúâ‰ªÄ‰πàÂäûÊ≥ïÂèØ‰ª•ÂÆûÁé∞Âë¢?ÊàñËÄÖÊäõÂºÉalamofire‰ΩøÁî®AFN???  In my application, the URL to which the Alamofire will make the requests is provided by the user. SO as a developer I don't know what he'll be using. The URL would be accessed over:

1. HTTP
2. HTTPS (Certificate issued by a certified CA)
3. HTTPS (self-signed certificate)

For case 1 and 2, the default `SessionManager` works fine but in case of self-signed certificates I need to create a custom `SessionManager` to override the SSL check.

So, is there a way I can verify whether I need to create a custom `SessionManager` or not? Maybe by using somme exception handling (I did it in this way for Android).
[StackOverflow question](http://stackoverflow.com/questions/40402854/alamofire-ssl-check-at-runtime) This is off the top of my head, but this should do what you want. This assumes you have a bool variable isSelfSignedCert or whatenot, and you can also use host to verify the host is what you would expect with your self signed cert. The normal disclaimers of not going live with anything that bypasses any security without fully understanding it apply. It is a little more verbose than it needs to be in order to be a little more readable.

```
let requestManager = { ()->Alamofire.SessionManager in
    let configuration = URLSessionConfiguration.default

    let manager=Alamofire.SessionManager(configuration: configuration)
    manager.delegate.sessionDidReceiveChallenge = { session, challenge in
        var disposition: URLSession.AuthChallengeDisposition = .performDefaultHandling
        var credential: URLCredential?
        if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
            let host = challenge.protectionSpace.host
            if let serverTrust = challenge.protectionSpace.serverTrust {
                let serverTrustPolicy = isSelfSignedCert ?
                    ServerTrustPolicy.performDefaultEvaluation(validateHost: true) :
                    ServerTrustPolicy.disableEvaluation

                if serverTrustPolicy.evaluate(serverTrust, forHost: host) {
                    disposition = .useCredential
                    credential = URLCredential(trust: serverTrust)
                    return (disposition, credential)
                } else {
                    disposition = .cancelAuthenticationChallenge
                    return (disposition, credential)
                }
            }
        }
        disposition = .cancelAuthenticationChallenge
        return (disposition, credential)
    }
    return manager
}()
```
 @bot2600 Thank you for the code snippet.
As per your explanation, I should know the value of `isSelfSignedCert` before. But in my application, some users may connect using self-signed certificate and some may not. So I don't know in advance, what would be the value for `isSelfSignedCert`. Correct me if I understood it in a wrong way.
  FAILURE: Error Domain=NSPOSIXErrorDomain Code=100 "Protocol error" UserInfo={_kCFStreamErrorCodeKey=100, _kCFStreamErrorDomainKey=1}

Try load JSON with 300 objects.

Thanks for any help!  Hi, last version (4.0.1) contains `Package.swift` that can't be used with 3.0.1 swift toolchain. Master branch already has it fixed (excluded Tests). I would like to create a PR for RxAlamofire to add `Package.swift` there, but not having working package on this repo is blocking me.
Any chance for a new tag soon?  I need to solve a multipart login process (stuck on how to wrap logic around serial GET/POST requests)

also on Stackoverflow as
http://stackoverflow.com/questions/40384341/sequential-requests-with-logic-swift-3-xcode-8-alamofire-4

step 1 validate user/pw with basic authentication header
step 2 use returned token (from step 1) in new authentication header and fetch from server a list
step 3 user selects from returned list (or does another request to create new if thing not found on list)
step 4 use guid from selected/created thing to generate auth token to fetch yet another new general use auth token and refresh token

I can do each of these individually (set headers, set parms, validate and parse result, etc), BUT I do not understand how to create the logic flow around the requests.  Do I have to nest all of the requests inside each other so that I step 2 happens inside step 1, step 3 happens inside step 2, etc.  Or is there a simple example application somewhere that shows how execute multiple requests with logic around the requests - Not interested in simply queueing the requests as I have to run logic around the requests. Events? Managed queue?  Looking for guidance and ideally a downloadable sample app that I can play with and learn from. 

I originally built this without Alamofire and had the timing/logic problem and thought Alamofire might make this easier but after switching to Alamofire I find myself stuck at the same point.  Building the framework with Carthage on Swift 3.0.1 produces following warnings:

/Carthage/Checkouts/Alamofire/Source/Request.swift:474:47: warning: expression implicitly coerced from 'URLSessionTask?' to Any See https://github.com/Alamofire/Alamofire/issues/1732, fixed in https://github.com/Alamofire/Alamofire/pull/1735 . üëç 
 Ok, I may just be a real noob but I have tried compiling via carthage with version 4.0.1 and I still get this warning. My project will not compile as a result. If this is fixed, which version do we need to target when building with Carthage in order to use it? I guess I am asking: what should my cartfile entry look like for this to pull down properly. 

Thanks!
 Just put 

```
github "Alamofire/Alamofire"
```

it will take the last version.

and check what version of Swift you are using!
mine is:

```
swift --version

Apple Swift version 3.0.1 (swiftlang-800.0.58.6 clang-800.0.42.1)
Target: x86_64-apple-macosx10.9
```
 But @Erulezz  and @DanBurkhardt 

The PR is not merged yet, so the warning is still there, we need to wait for #1735 
  In a https connection, when the host in requested URL is an *IP address*, the host can‚Äôt match with domain during certificate validation, which leads to failure of SSL/TLS hand shake. it‚Äôs better to allow user define Host in HTTPS header and this would be helpful for httpdns.

```
IP: 192.168.0.1
Certificate domain: *.example.com

request: https://192.168.0.1/

let serverTrustPolicies: [String: ServerTrustPolicy] = [
    "test.example.com": .performDefaultEvaluation(validateHost: true)
]
``` **Problem: DNS Pollution**
In some country(like China), domain name hijacking is serious, in some areas even over 20% of the user domain name resolution was hijacked. Carrier's LocalDNS expires NAT according to the authoritative DNS destination IP address or forwards the resolution request to another DNS server, which causes the authoritative DNS can not correctly identify the local IP address of the carrier, and it will cause the domain name resolution error and the traffic inter-network.

**Solution: Connected via IP Address**
All anti-DNS Pollution solutions are Connected via IP Address.
Instead of using the existing UDP-based DNS protocol, the domain name resolution request is sent directly to the server that provides DNS queries (such as [Google Public DNS](https://dns.google.com)), bypassing the local DNS of the carrier and avoiding the domain name caused by the local DNS Hijacking problems and scheduling inaccuracies.

In the HTTPS service scenario, during a handshake the client needs to verify the certificate issued by the server, check the domain and extension fields of the certificate to confirm if the URL's hostname matched the peer's identification hostname. When connected via IP address, the domain mismatch occurs. The SSL/TLS handshake won't success.

So we need to replace the IP address in the verification process of the original domain name.

``` swift
let configuration = URLSessionConfiguration.default
var httpHeaders = SessionManager.defaultHTTPHeaders
httpHeaders["Host"] = "test.example.com"
configuration.httpAdditionalHeaders = httpHeaders

let serverTrustPolicies: [String: ServerTrustPolicy] = [
    "test.example.com": .performDefaultEvaluation(validateHost: true)
]

let sessionManager = Alamofire.SessionManager(configuration: configuration, serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies))

sessionManager.request("https://192.168.0.1/get")
```

[AFNetworking #2954](https://github.com/AFNetworking/AFNetworking/issues/2954)
[Developer Docs](https://developer.apple.com/library/content/technotes/tn2232/_index.html)
[Aliyun HttpDns](https://help.aliyun.com/document_detail/30143.html?spm=5176.doc30102.6.147.o5RLgH)
 Hi @cnoon 

Thanks for your example. But unfortunately, it doesn't work.

In my use case the biggest problem is that the domain name in the certification didn‚Äôt match  `challenge.protectionSpace.host`, which leads to SSL handshake fail, but not to find the specific  `ServerTrustPolicy`.

So in your example, `trustIsValid(_:)` method and `evaluate(_:forHost:)` method in `ServerTrustPolicy` will return false.

And in DNS Pollution, we get IP address from remote server. it maybe change sometimes.

üôèüçª
  **Pod version:** 3.5.1
**Swift version:** 2.2

<img width="571" alt="screen_shot_2016-06-29_at_00_01_59" src="https://cloud.githubusercontent.com/assets/3541185/19840559/3cefe120-9ef0-11e6-99f5-c3a2e69a5d20.png">

I found the [source of the problem](https://github.com/Alamofire/Alamofire/blob/769818dc764dc2dd465ff64ba413af6acc729b2f/Source/Upload.swift#L324). The temporary file should be removed after the operation ends. According to the [documentation](https://developer.apple.com/library/mac/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html#//apple_ref/doc/uid/TP40010672-CH2-SW4), the temporary folder only gets cleaned when the app is not running so, basically, it means that if the user never decides to kill the app or never reboots his device then, the temporary folder will remain.

Any clue on where to put the code to clean up the temporary file?
 I noticed that the `multipartFormData` has been reimplemented on 4.0.0 version but unfortunately I'm still using Xcode 7.3.1 and I can't update the project right now.
 Assigning a `taskDidComplete` in the [moment of the task](https://github.com/Alamofire/Alamofire/blob/769818dc764dc2dd465ff64ba413af6acc729b2f/Source/Upload.swift#L45) could be a solution, right?
 @cnoon Thanks üëç 

BTW, on 3.x, how can I remove the temporary file if it fails?
  Hi when I have updated xcode 8.1 and got exception 
//  SessionManager.swift line 152
 let queue = DispatchQueue(label: "org.alamofire.session-manager." + UUID().uuidString) 
bad access
 Hi, I have the same exception and I can't release the new version of my app until this issue be fixed. How can I help you to solve this?
Thks
 Hi,

Same for me since i have updated to Xcode 8.1
 Hi, I have the same exception 
 i don't know why but when copy workspace into another folder and work form this place everything is fine. i dont have same exception. but when try to work in from old folder it has exception ü§îüò≥
  ![2a90b150-b877-41ed-8ca0-a738a088331b](https://cloud.githubusercontent.com/assets/1953494/19835135/f96376a2-9eb7-11e6-8ecb-22adb8006ed1.png)
 swift3 xcode 8.1
 I have same problem after update Xcode to 8.1
 I use Alamofire by cocoaPods,I  tried to add  files to project, then remove it, this worked to me.
 I currently having the exact same issue on Xcode 8.1 / Swift 3 using Alamofire 4.2.0 from cocoapods.

It crashes when trying to access the underlying `task` from it's `delegate`

```
/// The request sent or to be sent to the server.
open var request: URLRequest? { return task?.originalRequest }
```

Here is the underlying exception sent :
`'NSInvalidArgumentException', reason: '*** -[NSProxy doesNotRecognizeSelector:originalRequest] called!'`

 We finally resolved the issue with our team, it was due to Crittercism SDK.

Here is the fix :
```
let configuration = CrittercismConfig()
    configuration.monitorNSURLSession = false
    configuration.monitorNSURLConnection = false
    Crittercism.enable(withAppID: "appIDxxxxx", andConfig: configuration)
```  I am using Alamofire 4.0.1, and swift 3, Xcode 8.0. Please help!

![screen shot 2016-10-29 at 3 42 38 pm](https://cloud.githubusercontent.com/assets/8404682/19832369/110e6820-9df0-11e6-81e6-bfb33a1c4151.png)
 I am using photoURL to get an image from a web server. I am not sure what causes this issue. It should be something very simple. Thanks, 
 The closure for the .response call has changed with AlamoFire 4. It now only takes a single parameter.
  hi

how can I make a soap request 
call web service like http://www.w3schools.com/xml/tempconvert.asmx
and call method CelsiusToFahrenheit with send parameter and get response

can you please share a sample 
i have tried many times 
but did not get the true result
please me 
 http://webindream.com/soap-with-swift/
  ![screen shot 2016-10-29 at 2 32 29 pm](https://cloud.githubusercontent.com/assets/19979997/19829534/91a6cc72-9de4-11e6-9bad-37246e7cbd74.png)
  @jshier did occur a build fail, can you check it?
 I still have the warnings after updated to v4.2.0

Do I have something to do? I did it before writing the comment! I reinstalled the pods too to be sure. These are the warnings I have:

Expression implicitly coerced from 'URLRequest?' to Any
Expression implicitly coerced from 'Data?' to Any Is this what you wanted?

> Le 22 nov. 2016 √† 12:43, Christian Noon notifications@github.com a √©crit :
> 
> Screenshot? What version of Xcode are you running? We only support Xcode 8.1 currently. If you're running a beta that is producing those errors, then that's the problem.
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub https://github.com/Alamofire/Alamofire/pull/1735#issuecomment-262311466, or mute the thread https://github.com/notifications/unsubscribe-auth/AEKfkwsf9GF9yQk41I7i7GK16r2JgTNrks5rAynMgaJpZM4Kj8e8.
 So, no ideas of what is going on? ;-) Maybe you can help here.

```
            switch response.result {

            case .success:

            case .failure(let error):
                print(response.request)
                print(response.data)
            }
```

I have the warnings at these 2 lines (print). Maybe I‚Äôm doing something wrong here. Is it the good way to do it?

Thanks for your help!

FG

> Le 23 nov. 2016 √† 11:43, Jon Shier notifications@github.com a √©crit :
> 
> There are no warnings using Xcode 8.1 and the latest Alamofire release. If you see any new ones, please open a new issue with the exact warnings you're seeing and the lines in Alamofire that trigger them
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub https://github.com/Alamofire/Alamofire/pull/1735#issuecomment-262567938, or mute the thread https://github.com/notifications/unsubscribe-auth/AEKfk5gdyJ0NSjo_Xubod3Aam4PYGmWCks5rBG09gaJpZM4Kj8e8.
 Thanks!

> Le 23 nov. 2016 √† 11:52, Jon Shier notifications@github.com a √©crit :
> 
> Cast them as Any and be done with it or put them into string values that are then printed.
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub https://github.com/Alamofire/Alamofire/pull/1735#issuecomment-262570412, or mute the thread https://github.com/notifications/unsubscribe-auth/AEKfk53YmOt5w3qAUxI2eY33yRtYIOw_ks5rBG9TgaJpZM4Kj8e8.
    Getting random crashes that are coming from DataTaskDelegate (line 282).

XCode Version 8.0 (8A218a)
Apple Swift version 3.0 (swiftlang-800.0.46.2 clang-800.0.38)

<img width="1437" alt="screen shot 2016-10-28 at 8 55 44 pm" src="https://cloud.githubusercontent.com/assets/10481739/19802889/a2639a24-9d51-11e6-85e6-13b74747a883.png">
 Ok i'll start with a little background, I'm a hobbyist programer so bear with me...  

It's an OS X app (10.12) which polls a number of apis (JSON in this case & XML for others) reasonably frequently (4 times a second).  The app was running without any crashes using Swift 2 and the problems started when I upgraded to Swift 3.  The app crashes at random intervals (maybe after a few hours maybe after a few minutes) and as you can see from the screenshot above it looks like it is coming from line 282 in TaskDelegate.swift.  It's not really possible to create a sample project as it has to login to a number of personal accounts.  There isn't any output in the console except for 'lldb' so i'm not sure i can provide much more information than this.  

As for the reason for the number of threads.  I'm using a background thread to do the polling and updating the UI on the main thread so i'm not sure about the others.

Hope this is helpful.
 I use a repeating timer to call a method which then calls downloadData.

Timer.scheduledTimer(timeInterval: 0.250, target: self, selector: #selector(Coordinator.worker), userInfo: nil, repeats: true)

func downloadData(_ referenceToCoordinator : Coordinator) {

```
  var idsArray : [String] = []

  // setup ids string to be used in the json call.
  for venue in referenceToCoordinator.venuesBeingMonitored {
     idsArray.append(venue.vId!)
  }

  let headers = [
     "X-Application" : self.appKey,
     "X-Authentication" : self.token!,
     "Content-Type" : "application/json",
     "accept" : "application/json"
  ]

  let parameters = [
     "jsonX" : "3.0",
     "method" : "someMethod",
     "params" : [
        "ids" : idsArray,
        "arg1" : [
           "arg1a" : ["someValue"],
           "agr1b" : "true"
        ]
     ],
     "id" : 1
  ] as [String : Any]



  Alamofire.request("https://api.XXX.com/YYY/ZZZ/AAA/BBB", method: HTTPMethod.post, parameters : parameters, encoding: JSONEncoding.default, headers: headers)
     .responseJSON { response in

        switch response.result {
        case .success:

           let json = JSON(response.result.value!)
           for (index, subJson) : (String, JSON) in json {
              if index == "result" {
                 if let jsonVenues = subJson.array {
                    for jsonVenue in jsonVenues {
                       for venue in referenceToCoordinator.venuesBeingMonitored {
                          if venue.vId! == jsonVenue["vId"].stringValue {
                             venue.updateVenueData(jsonVenue)
                          }
                       }
                    }
                 }
              }
           }

        case .failure(let error):
           print("error in downloadData - \(error)")
        }
  }
```

   }
 I haven't been able to replicate the problem again, so i suspect it's something outside of Alamofire.  Feel free to close this issue.
  This is in `Request.swift` in master

<img width="242" alt="screen shot 2016-10-27 at 4 32 56 pm" src="https://cloud.githubusercontent.com/assets/14205877/19787998/268409d2-9c63-11e6-8b90-b9c28bffb814.png">

<img width="625" alt="screen shot 2016-10-27 at 4 34 14 pm" src="https://cloud.githubusercontent.com/assets/14205877/19788016/3e1ad724-9c63-11e6-8458-6a3fe0fc2c5f.png">
 With carthage I have these errors:

```
/Carthage/Checkouts/Alamofire/Source/Request.swift:474:47: warning: expression implicitly coerced from 'URLSessionTask?' to Any
/Carthage/Checkouts/Alamofire/Source/Request.swift:474:47: warning: expression implicitly coerced from 'URLSessionTask?' to Any
/Carthage/Checkouts/Alamofire/Source/Request.swift:474:47: warning: expression implicitly coerced from 'URLSessionTask?' to Any
/Carthage/Checkouts/Alamofire/Source/Request.swift:474:47: warning: expression implicitly coerced from 'URLSessionTask?' to Any
```

My cartfile:

```
github "Alamofire/Alamofire" == 4.0.1
```
 I receive the same Carthage warning 
 +1
 Thank you @jshier :)
  Hello, I got this error when using Alamofire in my Swift3 project.

![screen shot 2016-10-27 at 4 13 58 am](https://cloud.githubusercontent.com/assets/21965189/19752308/f25f733c-9c2e-11e6-8be4-5e4b8f0a29ae.png)

What is the solution to this issue?
 i've same error :(
 It's not the greatest solution, but if you want to get through it you can unlock the permissions for the Alamofire source file, find the interface function (downloadProgress() in your case), and remove the "internal" modifier, so your function call is valid.
  Is it possible to return JSON instead of NSDictionary in responseJson?
 I was thinking of JSON string instead of NSDictionary but I figured it out, tnx.
  I'm trying to upload a image with other parameters the issue occurs when my one of my parameters are a datatype of `Array<String>`. The array is empty on the server side.:/

``` swift
         self.manager.upload(
                multipartFormData: { multipartFormData in
                    multipartFormData.append(imgData, withName: imgKey, fileName: "image.jpg", mimeType: "image/jpg")

                    for (key, value) in params {
                        multipartFormData.append(value.data(using: .utf8)!, withName: key)
                    }

                },
                to: path,
                encodingCompletion: { encodingResult in
                    switch encodingResult {
                    case .success(let upload, _, _):
                        upload.responseJSON { response in
                            debugPrint("SUCCESS RESPONSE: \(response)")
                        }
                    case .failure(let encodingError):
                        print("ERROR RESPONSE: \(encodingError)")

                    }
                }
            )
```

The datatype of my  parameters are `[String : Any]`

What I'm exactly doing wrong? :( the same here plz need to fix it 
 Also having this issue, just after I updated to the most recent iOS 10.1
 The type of my params are [String : String]
the same issue is faced by me Please help
 @BilalReffas 
I solved the issue by setting time out for request using SessionManager

 `
//Class variable
var alamoManager: SessionManager?

//viewdidload or in viewwillappear
let configuration = URLSessionConfiguration.default
        configuration.timeoutIntervalForRequest = 30
        alamoManager = Alamofire.SessionManager(configuration: configuration)

//In your method
self.alamoManager.upload(
                multipartFormData: { multipartFormData in
                    multipartFormData.append(imgData, withName: imgKey, fileName: "image.jpg", mimeType: "image/jpg")

```
                for (key, value) in params {
                    multipartFormData.append(String(describing: value).data(using: .utf8)!, withName: key)
                }

            },
            to: path,
            encodingCompletion: { encodingResult in
                switch encodingResult {
                case .success(let upload, _, _):
                    upload.responseJSON { response in

                          print(response.response?.statusCode)
                          print(response.request)  // original URL request
                          print(response.response) // URL response
                          print(response.data)     // server data
                          print(response.result)   // result of response serialization
                          print(response.result.value)   
                    }
                case .failure(let encodingError):

                        print(encodingError)
                        print(self.response)

                }
            }
        )`
```
 @yadavanand it's not working for me
 I've got it working now. For me, turns out it was something pretty stupid, but perhaps it will help someone here anyway:

In Swift 2.2 `NSURL.path` returns the entire URL. In Swift 3 however `URL.path` returns only the file path and not the entire URL. Since all Alamofire functions take an URL as argument this is mostly not a problem, but for this scenario it is, since it takes a string.

So for `http://www.yoursite.com/api/dosomething.php`
Swift 2.2 `NSURL.path` returns `http://www.yoursite.com/api/dosomething.php`
Swift 3 `URL.path` returns `/api/dosomething.php`

Replacing `URL.path` with `URL.absoluteString` resolved it for me.
 @guidove thank you maybe it will help other people in the community.:) 
Anyway it's still not working for me. :/ 
 I've got the same problem and couldn't find a solution for Alamofire **4**
 I just realized that the order is important:

```
for (key, value) in parameters {
        multipartFormData.append(value.data(using: .utf8)!, withName: key)
}
multipartFormData.append(imageData, withName: "user", fileName: "user.jpg", mimeType: "image/jpeg")
```

works. Whereas 

```
multipartFormData.append(imageData, withName: "user", fileName: "user.jpg", mimeType: "image/jpeg")
for (key, value) in parameters {
        multipartFormData.append(value.data(using: .utf8)!, withName: key)
}
```

won't work. Is this expected behaviour?
 Not working for me. Does is working for you @LucidityDesign ?
 Here's my full and working (Swift 3 / Alamofire 4) code. Few global variables in there but you get the point i guess.

```
func uploadImage(_ imageFileName: String) {


        if let imageData = try? Data(contentsOf: localFolder.images.appendingPathComponent(imageFileName)) {
            let parameters = ["imageFileName":imageFileName, "userID":UD.userID!]
            let URL = serverURL.appendingPathComponent("image_upload.php")

            Alamofire.upload(multipartFormData: {
                multipartFormData in
                multipartFormData.append(imageData, withName: "file", fileName: "file.png", mimeType: "image/png")

                for (key, value) in parameters {
                    multipartFormData.append(value.data(using: String.Encoding.utf8)!, withName: key)
                }

                }, to: URL.absoluteString, method: .post
                ,encodingCompletion: {
                    encodingResult in

                    switch encodingResult {
                    case .success(let upload, _, _):
                        upload.responseString { response in

                            switch response.result {
                            case .failure(let err):
                                printError("image upload failed: \(err)")
                                break
                            case .success(let str):
                                if str == "error" {
                                        printError("image upload failed. check server logs")
                                }
                                else {
                                        print("image upload successfull")
                                }
                            }

                        }
                    case .failure(let encodingError):
                        print(encodingError)
                    }
            })
        }

    }

```

My php server code echo's a string "OK" or "Error"
 @guidove your example works only if your parameters are a type of `Array<String>`
 @BilalReffas OK. Perhaps something to do with the parameter encoding you can add as a variable to the normal Alamofire.request methods? Have you tried JSONenconding your parameter values inside the for loop (as a first line, so before the .append?) Just a hunch as I didn't need to do this myself.

Also... just to be sure. You are saying `<String>Array`, but I'm guessing you mean `Array<String>` or in another notation `[String]`, right? So, your parameter declaration would be something like this:
`let params = ["key1":["string1", "string2", "string3"]]`, correct?  If not, can you show us the code where you declare your params?
 You should not use this for creating the data representation: `String(describing: value).data(using: .utf8)!`. The problem with that is, that it's just printing a debug representation of the object and transforms that String to Data. What you really need (in case of the `[String]` argument is using JSONSerialization instead of printing the object.
I would suggest introducing a serializer which gives you an appropriate data representation like this:

``` Swift
enum DataSerializer {

    static func serialize(_ value: Any) -> Data? {
        if JSONSerialization.isValidJSONObject(value) {
            return try? JSONSerialization.data(withJSONObject: value, options: [])
        }
        else {
            return String(describing: value).data(using: .utf8)
        }
    }

}
```

You could then check if the data could be serialised and if, set it in the request parameters.
I am really excited, if that fixes your problem :)
 @guidove Yes I mean `Array<String>`  :)    `let params:[String: Any] = ["text":text, "[friend_ids":friend_ids]`  This is how my params declaration look's like `friend_ids` is a type of `[String]`
  I get this issue 
[!] Unable to find a specification for `Alamofire (~> 4.0)`
with pod installing the following;

source 'https://github.com/CocoaPods/Specs.git'
platform :ios, ‚Äô10.0‚Äô
use_frameworks!

target 'ekko' do
    pod 'Alamofire', '~> 4.0'
end

anyone else have this issue?
 tried that also 
[!] CocoaPods was not able to update the `master` repo. If this is an unexpected issue and persists you can inspect it running `pod repo update --verbose`

[!] CocoaPods was not able to update the `master` repo. If this is an unexpected issue and persists you can inspect it running `pod repo update --verbose`
Analyzing dependencies
[!] Unable to find a specification for `Alamofire (~> 4.0)`
 Anyone find a solution.  I am also getting same error on running 'pod install'

Analyzing dependencies
[!] Unable to find a specification for `Alamofire (~> 4.0)`

I have run pod update and have also run 'pod repo update --verbose' I get no errors from the update, but I can pod install does not find Alamofile ???

Is it a github timeout problem?
 I had the same issue. I needed to up the platform version.

Before:

```
platform :ios, '8.0'
```

After:

```
platform :ios, '9.0'
```
 Still having the same issue here, using platform: ios, '10.0'
 Try running
`pod repo remove master`
`pod setup`
`pod update`
  Hi, I'm migrating from `3.1.5` to `4.0.1` I'm using a podspec creating my own library, Using Xcode 8.0 and cocoapods `1.1.1` , but when I update to this version I get this error

```
[!] Unable to satisfy the following requirements:

- `ExpSwift (from `../`)` required by `Podfile`
- `ExpSwift (from `../`)` required by `Podfile`

Specs satisfying the `ExpSwift (from `../`)` dependency were found, but they required a higher minimum deployment target.
```

I did updated the deployment target to 10.0 but I get the same error. Do I need to update something else, here us my podspec and podfile

```
 s.platform     = :ios, '10.0'
  s.requires_arc = true

 s.source_files = 'Pod/Classes/**/*'
 #s.resource_bundles = {
 #  'ExpSwift' => ['Pod/Assets/*.png']
 #}

 # s.public_header_files = 'Pod/Classes/**/*.h'
 # s.frameworks = 'UIKit', 'MapKit'
  s.dependency 'PromiseKit','4.0'
  s.dependency 'Alamofire','4.0.0'
  s.dependency 'Socket.IO-Client-Swift','8.0.2'
  s.dependency 'JSONWebToken','2.0.1'
end
```

And my podfile just reference to my local pod

```
source 'https://github.com/CocoaPods/Specs.git'
use_frameworks!
platform :ios, '9.0'

target 'ExpSwift_Example' do
  pod "ExpSwift", :path => "../"
end

target 'ExpSwift_Tests' do
  pod "ExpSwift", :path => "../"
end
```
 @jshier I think this is a problem with Alamofire beacuse if I try with version 3.5 it works with no problem, the problem is just with the last version.
 @jshier OK I found the problem is that you need to add `platform :ios, '10.0'` to your local podfile, I was using 9.0. Are you guys going to support ios 9??,  Is not taking the platform from the podspec file, I need to add it always in the local podfile. I did had to change it in both places to 9.0 otherwise doesn't work
  Setup

Fresh, brand new Xcode 8 project.
Added  Alamofire to my Podfile:

```
source 'https://github.com/CocoaPods/Specs.git'
platform :ios, '10.0'
use_frameworks!

target ‚Äòweatherkaka‚Äô do
    pod 'Alamofire', '~> 4.0'
end
```

Ran the command $ `pod install`
Install worked fine, and project compiles via workspace file
Import: `import AlamoFire`

I get the issue: "No such module: Alamofire". What's missing?

Note: I've done clean, re-open Xcode, clean more, re-compile etc. I've added the Alamofire framework to Linked Frameworks and Build phases

<img width="687" alt="screen shot 2016-10-23 at 9 14 40 pm" src="https://cloud.githubusercontent.com/assets/14961322/19631125/c3ac77a4-9965-11e6-80ac-f124dc974b31.png">
 You need to add .swift-version file with 3.0

Run the following command in your terminal 

```
cd YourProject
echo 3.0 > .swift-version
```
  Nest Terminal commands and a blockquote under their respective instructions
  On https:// received challenge demand user client certificate. How can i pick certificate from profile (General/DeviceManagement/DigitalWorkSpace/Profile and pass it to for? using Alamofire?

The same certificate prompted on Safari Browser while accessing.
  Hi @adrimarti I think I have the same issue. Where do you set the Release optimization level? Thanks I am experiencing the same issue but only with a really small % of my app users. Tested setting the optimizatiob level to the same as main target to Fast, Single-File and Whole module optimization without any success. Any other workaround? Hi @adrimarti seems to be working for me. Thanks! We are experiencing this issue too, in Objective-C project. Changing Optimization Level didn't worked for us.   Memory issue in every request,  **requests** parameter in **SessionDelegate** class have some issue.
It can be reproduced by making a request and then check in debug memory graph.

<img width="1266" alt="screen shot 2016-10-21 at 12 25 22 pm" src="https://cloud.githubusercontent.com/assets/8539678/19589484/0114b22e-978a-11e6-94db-991a6db47ffe.png">
 <img width="1347" alt="screen shot 2016-10-25 at 11 35 42 am" src="https://cloud.githubusercontent.com/assets/1097640/19673130/48cc56a6-9aa7-11e6-88a5-ac65aa0c5610.png">

There are leaks that are detected by the Instrument's Leaks with Demo iOS Example (Xcode 8.0, Alamorefire 4.0.1)
 @jshier I tried it using Instrument's Leaks template and it is detected as @windyit08 posted.
 Also I've been able to detect @hamzaansari09 leaks using the Leaks instrument in my project. 
<img width="1280" alt="2016-12-14 11 42 28" src="https://cloud.githubusercontent.com/assets/2895753/21175257/78c9a4ae-c1f2-11e6-8b13-b7f474aa1934.png">
<img width="1279" alt="2016-12-14 11 44 14" src="https://cloud.githubusercontent.com/assets/2895753/21175321/b79522ee-c1f2-11e6-8464-8c43d19c2e4e.png">

 I tested it with Xcode 8.2 and i got Leaks with Instruments Leak template.

> _NativeDictionaryStorageOwner<Int, Request>	1	0x174076040	64 Bytes	libswiftCore.dylib	swift_slowAlloc
> _NativeDictionaryStorageImpl<Int, Request>	1	0x1740fc300	128 Bytes	libswiftCore.dylib	swift_slowAlloc
  Does it handle "br" responses?
  I have had Alamofire with SwiftyJSON set up within my app for a while now and it has been working great for get and post restful api calls. I am implementing a new filter using a post call and the results are as expected when the filter is applied but when I go to turn off the filter the results I am getting returned are the same results from when the filter was applied. Any ideas? Appreciate any help!

**Alamofire Configuration:** 

```
    class func beforeAndAfterFilterCall(page:Int, onCompletion: ([Case]) -> Void) {

        let url = "https://"+UserDefaults.getIPAddress()+"/someurlstuffhere/"+String(page)
        runGetCommand(url, onCompletion: { json, err in

            var cases = [Case]()

            if json != nil && json.array != nil {

                for jsonFound:JSON in json.array! {

                    cases.append(Case(json:jsonFound))
                }
            }

            onCompletion(cases as [Case])
        })
    }

    class func filterCall(filterOnThis:[String:AnyObject], onCompletion: ([Case]) -> Void) {

        let url = "https://"+UserDefaults.getIPAddress()+"/someurlstuffhere/filter"
        runPostCommand(url, post: filterOnThis, onCompletion: { json, err in

            var cases = [Case]()

            if json != nil && json.array != nil {

                for jsonFound:JSON in json.array! {

                    cases.append(Case(json:jsonFound))
                }
            }

            onCompletion(cases as [Case])
        })
    }

    /* Run a get rest call and return the JSON found. */
    class func runGetCommand(url:String, onCompletion: ServiceResponse) {

        let task = getAlamofireManager().request(.GET, url, headers:getHeaders())
            .responseJSON { response in

                if((response.result.value) != nil){

                    print(response.debugDescription)

                    onCompletion(JSON(response.result.value!), nil)

                } else{
                    print("Something went wrong when running the get command. Maybe bad credentials or ip!")
                    onCompletion(nil, nil)
                }
            }
        task.resume()
    }

    /* Run a post rest call and return the JSON found. */
    class func runPostCommand(url:String, post:[String: AnyObject], onCompletion: ServiceResponse) {

        let task = getAlamofireManager().request(.POST, url, parameters: post, encoding:.JSON, headers:getHeaders())
            .responseJSON { response in

                if((response.result.value) != nil){

                    print(response.debugDescription)

                    onCompletion(JSON(response.result.value!), nil)

                } else{
                    print("Something went wrong when running the get command. Maybe bad credentials or ip!")
                    onCompletion(nil, nil)
                }
        }
        task.resume()
    }

    /* Initialize the headers for the api call */
    private static func getHeaders() -> [String:String] {

        let user = UserDefaults.getUsername()
        let password = UserDefaults.getPassword()
        let credentialData = "\(user):\(password)".dataUsingEncoding(NSUTF8StringEncoding)!
        let base64Credentials = credentialData.base64EncodedStringWithOptions([])
        let headers = [
            "Authorization": "Basic \(base64Credentials)",
            "Accept": "application/json"
        ]

        return headers
    }

    /* Initialize the Alamofire manager */
    private static func getAlamofireManager() -> Manager {

        let manager = Alamofire.Manager.sharedInstance
        manager.session.configuration.timeoutIntervalForRequest = 5

        manager.delegate.sessionDidReceiveChallenge = { session, challenge in
            var disposition: NSURLSessionAuthChallengeDisposition = .PerformDefaultHandling
            var credential: NSURLCredential?

            if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
                disposition = NSURLSessionAuthChallengeDisposition.UseCredential
                credential = NSURLCredential(forTrust: challenge.protectionSpace.serverTrust!)
            } else {
                if challenge.previousFailureCount > 0 {
                    disposition = .CancelAuthenticationChallenge
                } else {
                    credential = manager.session.configuration.URLCredentialStorage?.defaultCredentialForProtectionSpace(challenge.protectionSpace)

                    if credential != nil {
                        disposition = .UseCredential
                    }
                }
            }
            return (disposition, credential)
        }

        return manager
    }
```

**Debugging output from the print(response.debugDescription) calls:**

When filter is called:

```
[Request]: <NSMutableURLRequest: 0x7fe8334f0bf0> { URL: https://127.0.0.1/someurlstuffhere/filter }
[Response]: <NSHTTPURLResponse: 0x7fe8340c8b20> { URL: https://127.0.0.1/someurlstuffhere/filter } { status code: 200, headers {
    "Cache-Control" = "no-store, no-cache, must-revalidate, post-check=0, pre-check=0";
    Connection = "Keep-Alive";
    "Content-Encoding" = gzip;
    "Content-Length" = 765;
    "Content-Type" = "text/html; charset=UTF-8";
    Date = "Thu, 20 Oct 2016 13:53:08 GMT";
    Expires = "Thu, 19 Nov 1981 08:52:00 GMT";
    "Keep-Alive" = "timeout=5, max=100";
    Pragma = "no-cache";
    Server = "Apache/2.2.22 (Ubuntu)";
    Vary = "Accept-Encoding";
} }
[Data]: 4140 bytes
[Result]: SUCCESS:
```

Get call after the filter call is to be removed:

```
[Request]: <NSMutableURLRequest: 0x7fe8341321b0> { URL: https://127.0.0.1/someurlstuffhere/0 }
[Response]: <NSHTTPURLResponse: 0x7fe834402990> { URL: https://127.0.0.1/someurlstuffhere/0 } { status code: 200, headers {
    "Cache-Control" = "no-store, no-cache, must-revalidate, post-check=0, pre-check=0";
    Connection = "Keep-Alive";
    "Content-Encoding" = gzip;
    "Content-Length" = 765;
    "Content-Type" = "text/html; charset=UTF-8";
    Date = "Thu, 20 Oct 2016 13:55:02 GMT";
    Expires = "Thu, 19 Nov 1981 08:52:00 GMT";
    "Keep-Alive" = "timeout=5, max=100";
    Pragma = "no-cache";
    Server = "Apache/2.2.22 (Ubuntu)";
    Vary = "Accept-Encoding";
} }
[Data]: 4140 bytes
[Result]: SUCCESS:
```
  I got the same problem here. I was supposing the .head request would have a specific response type other than JSON, since it doesn't have a body to parse. But I can't find documentation about it.

Any thoughts or directions?

**Edit:** Changing the response type to .responseString works.
  This is either an issue or a question. I'm aware of the contributing guidelines, however I've searched around for an answer to this inconvenience and didn't find any‚Äîplease direct me to an answer if there is one!

---

When I stop in a breakpoint that has a valid request, from the console `print request.debugDescription` does not return a cURL command that I can simply copy-paste-run in a Terminal. _The escaping seems to be wrong_.
I would prefer not to put print statements in my code to circumvent this.

Example:
Breakpoint on line 2.

``` swift
Line 1: let request = Alamofire.request(‚Ä¶ usual setup)
Line 2:         request.validate().responseJSON { response in
```

In Xcode console:

``` bash
(lldb) print request.debugDescription
(String) $R4 = "$ curl -i \\\n\t-X POST \\\n\t-H \"User-Agent: myApp\" \\\n\t-H \"Accept-Encoding: gzip;q=1.0, compress;q=0.5\" \\\n\t-H \"Accept-Language: en-US;q=1.0\" \\\n\t-H \"Content-Type: application/json\" \\\n\t-d \"{\\\"type\\\":\\\"cake\\\"}\" \\\n\t\"https://someURL\""
```

Taking the string starting with `curl` and ending with the before-last `"`, pasting that in Terminal throws errors:

```
curl: (6) Could not resolve host: \nt-X
curl: (6) Could not resolve host: POST
curl: (6) Could not resolve host: \nt-H
curl: (6) Could not resolve host: "User-Agent
‚Ä¶
```

---

Xcode Version 7.3.1 (7D1014)
iOS 9 & 10
 Tnx that worked!
  Do you have a list of the error messages you throw back if the request fails?

this for example

Domain=NSURLErrorDomain Code=-1009 "The Internet connection appears to be offline." UserInfo={NSUnderlyingError=0x174845370 {Error Domain=kCFErrorDomainCFNetwork Code=-1009 "(null)" UserInfo={_kCFStreamErrorCodeKey=50, _kCFStreamErrorDomainKey=1}}, NSErrorFailingURLStringKey=https://app-measurement.com/config/app/1:581104381739:ios:7c52dceae6c38413?platform=ios&app_instance_id=CF122423165645C389B26CC220830354&gmp_version=3402, NSErrorFailingURLKey=https://app-measurement.com/config/app/1:581104381739:ios:7c52dceae6c38413?platform=ios&app_instance_id=CF122423165645C389B26CC220830354&gmp_version=3402, _kCFStreamErrorDomainKey=1, _kCFStreamErrorCodeKey=50, NSLocalizedDescription=The Internet connection appears to be offline.}
 Ohhh. I thought that came from Alamofire, Thank's I'll be looking into URLError
  Last couple lines of `swift build`  below. 

I don't think its a "me" issue, because I got RXSwift to work, and then all I did was add Alamofire. 

thanks a lot if anyone has any ideas.

```
                                                             ^
/Users/Joe/Projects/Mine/Apollo/Packages/Alamofire-4.0.0/Source/SessionDelegate.swift:117:61: note: add @available attribute to enclosing class
    open var streamTaskBetterRouteDiscovered: ((URLSession, URLSessionStreamTask) -> Void)?
                                                            ^
/Users/Joe/Projects/Mine/Apollo/Packages/Alamofire-4.0.0/Source/SessionDelegate.swift:120:70: error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer
    open var streamTaskDidBecomeInputAndOutputStreams: ((URLSession, URLSessionStreamTask, InputStream, OutputStream) -> Void)?
                                                                     ^
/Users/Joe/Projects/Mine/Apollo/Packages/Alamofire-4.0.0/Source/SessionDelegate.swift:120:70: note: add @available attribute to enclosing class
    open var streamTaskDidBecomeInputAndOutputStreams: ((URLSession, URLSessionStreamTask, InputStream, OutputStream) -> Void)?
                                                                     ^
<unknown>:0: error: build had 1 command failures
error: exit(1): /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift-build-tool -f /Users/Joe/Projects/Mine/Apollo/.build/debug.yaml
```
 `error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer.`  I'm trying to build on OS X on Sierra. This should work. it looks like the minimum target is not being set right. 
 I'm seeing this too. Setting Alamofire as a dependency in Package.swift as `.Package(url: "https://github.com/Alamofire/Alamofire", majorVersion: 4)`.
[Here's the output](http://pastebin.com/bePxNyCj) at build time. I put it on pastebin due to how long it is
 spoke too soon, this dupes #1544
  I have a need to request data from a REST API where the parameters I am seeking have a duplicate name.

```
    Alamofire.request(.GET, "https://XXXX.com/ewws/EWSearch/.json", parameters: parameters)
        .responseJSON { response in
```

The parameters I need to pass are:

```

    let parameters = [
        "$KB": "ITIL",
        "search": "Inventory_Manufacturers",
        "field": "manu_short",
        "field": "company_name",
        "$table": "company",
        "$login": "name",
        "$password": "pwd",
        "$lang": "en"    
    ]
```

It takes the second "field" as a dupicate, however the name "field" is the name of the parameter I need to pass.

Any ideas on how to get around this?
  Randomly have crashes in TaskDelegate from download task on background session on line 335: 

```
        let result = destination(location, downloadTask.response as! HTTPURLResponse)
```

The download task response is nil that's why it's crashing. Is it normal that there is no safe unwrapping ?
  [coÃÅpia de Podfile.txt](https://github.com/Alamofire/Alamofire/files/537652/copia.de.Podfile.txt)

MacBook-Air:AZKBLUE WP usergarciax$ cd ..
MacBook-Air:GitHub usergarciax$ cd NewApp/
MacBook-Air:NewApp usergarciax$ ls
NewApp          NewApp.xcodeproj
MacBook-Air:NewApp usergarciax$ cd NewApp
MacBook-Air:NewApp usergarciax$ pod init
[!] No Xcode project found, please specify one
MacBook-Air:NewApp usergarciax$ cd ..
MacBook-Air:NewApp usergarciax$ ls
NewApp          NewApp.xcodeproj
MacBook-Air:NewApp usergarciax$ pod init
MacBook-Air:NewApp usergarciax$ pod install
Analyzing dependencies
Pre-downloading: `Alamofire` from `https://github.com/Alamofire/Alamofire.git`, branch `swift3`

[!] Error installing Alamofire
[!] /usr/bin/git clone https://github.com/Alamofire/Alamofire.git /var/folders/vf/..hide./T/..hide. --template= --single-branch --depth 1 --branch swift3

Cloning into '/var/folders/vf/..hide../T/....hide'...
warning: Could not find remote branch swift3 to clone.
fatal: Remote branch swift3 not found in upstream origin
  In the README, it says you can check for download errors like so:

``` swift
Alamofire.download(urlString, to: destination).response { response in
    print(response)

    if response.result.isSuccess, let imagePath = response.destinationURL?.path {
        let image = UIImage(contentsOfFile: imagePath)
    }
}
```

But `response`, a `DefaultDownloadResponse`, doesn't have a `result` property. I guess you can just check to see if `error` was `nil` or not:

``` swift
Alamofire.download(urlString, to: destination).response { response in
    guard response.error == nil else {
        print(response.error!)
        return
    }

    if let imagePath = response.destinationURL?.path {
        let image = UIImage(contentsOfFile: imagePath)
    }
}
```

I'd suggest we either add the `result` property, or update the README.
  Installation Alamofire for swift package manager, Compile error
 On Tue, Oct 18, 2016 at 11:46 AM, honbo notifications@github.com wrote:

> Installation Alamofire for swift package manager, Compile error
> 
> Did you try to build
> ‚Äã ?‚Äã S
> ometimes work
> ‚Äã.‚Äã

Saygƒ±larƒ±mla | Best Regards

Ekrem TA≈ûKIRAN
 Have you checked #1544 ?
 is any compiler or linker logs?
 @jshier
Compile in  xcode8

``` swift
import PackageDescription

let package = Package(
    name: "PerfectTemplate",
    targets: [],
    dependencies: [
        .Package(url: "https://github.com/PerfectlySoft/Perfect-HTTPServer.git", majorVersion: 2, minor: 0),
        .Package(url: "https://github.com/PerfectlySoft/Perfect-Curl.git", majorVersion: 2, minor: 0),
        .Package(url: "https://github.com/Alamofire/Alamofire.git", majorVersion: 4, minor: 0)
    ]
)

```

`swift build`

``` shell
Cloning https://github.com/Alamofire/Alamofire.git
HEAD is now at 668cc5a Added release notes to the CHANGELOG and bumped the version to 4.0.1.
Resolved version: 4.0.1
2016-10-19 13:40:18.734 xcodebuild[17344:2382843] [MT] PluginLoading: Required plug-in compatibility UUID 8A66E736-A720-4B3C-92F1-33D9962C69DF for plug-in at path '~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/VVDocumenter-Xcode.xcplugin' not present in DVTPlugInCompatibilityUUIDs
Compile Swift Module 'Alamofire' (17 sources)
Compile Swift Module 'PerfectCURL' (1 sources)
Compile Swift Module 'PerfectLib' (10 sources)
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:111:50: error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer
    open var streamTaskReadClosed: ((URLSession, URLSessionStreamTask) -> Void)?
                                                 ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:111:50: note: add @available attribute to enclosing class
    open var streamTaskReadClosed: ((URLSession, URLSessionStreamTask) -> Void)?
                                                 ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:114:51: error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer
    open var streamTaskWriteClosed: ((URLSession, URLSessionStreamTask) -> Void)?
                                                  ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:114:51: note: add @available attribute to enclosing class
    open var streamTaskWriteClosed: ((URLSession, URLSessionStreamTask) -> Void)?
                                                  ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:117:61: error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer
    open var streamTaskBetterRouteDiscovered: ((URLSession, URLSessionStreamTask) -> Void)?
                                                            ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:117:61: note: add @available attribute to enclosing class
    open var streamTaskBetterRouteDiscovered: ((URLSession, URLSessionStreamTask) -> Void)?
                                                            ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:120:70: error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer
    open var streamTaskDidBecomeInputAndOutputStreams: ((URLSession, URLSessionStreamTask, InputStream, OutputStream) -> Void)?
                                                                     ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:120:70: note: add @available attribute to enclosing class
    open var streamTaskDidBecomeInputAndOutputStreams: ((URLSession, URLSessionStreamTask, InputStream, OutputStream) -> Void)?
                                                                     ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:111:50: error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer
    open var streamTaskReadClosed: ((URLSession, URLSessionStreamTask) -> Void)?
                                                 ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:111:50: note: add @available attribute to enclosing class
    open var streamTaskReadClosed: ((URLSession, URLSessionStreamTask) -> Void)?
                                                 ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:114:51: error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer
    open var streamTaskWriteClosed: ((URLSession, URLSessionStreamTask) -> Void)?
                                                  ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:114:51: note: add @available attribute to enclosing class
    open var streamTaskWriteClosed: ((URLSession, URLSessionStreamTask) -> Void)?
                                                  ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:117:61: error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer
    open var streamTaskBetterRouteDiscovered: ((URLSession, URLSessionStreamTask) -> Void)?
                                                            ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:117:61: note: add @available attribute to enclosing class
    open var streamTaskBetterRouteDiscovered: ((URLSession, URLSessionStreamTask) -> Void)?
                                                            ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:120:70: error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer
    open var streamTaskDidBecomeInputAndOutputStreams: ((URLSession, URLSessionStreamTask, InputStream, OutputStream) -> Void)?
                                                                     ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:120:70: note: add @available attribute to enclosing class
    open var streamTaskDidBecomeInputAndOutputStreams: ((URLSession, URLSessionStreamTask, InputStream, OutputStream) -> Void)?
                                                                     ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:111:50: error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer
    open var streamTaskReadClosed: ((URLSession, URLSessionStreamTask) -> Void)?
                                                 ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:111:50: note: add @available attribute to enclosing class
    open var streamTaskReadClosed: ((URLSession, URLSessionStreamTask) -> Void)?
                                                 ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:114:51: error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer
    open var streamTaskWriteClosed: ((URLSession, URLSessionStreamTask) -> Void)?
                                                  ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:114:51: note: add @available attribute to enclosing class
    open var streamTaskWriteClosed: ((URLSession, URLSessionStreamTask) -> Void)?
                                                  ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:117:61: error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer
    open var streamTaskBetterRouteDiscovered: ((URLSession, URLSessionStreamTask) -> Void)?
                                                            ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:117:61: note: add @available attribute to enclosing class
    open var streamTaskBetterRouteDiscovered: ((URLSession, URLSessionStreamTask) -> Void)?
                                                            ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:120:70: error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer
    open var streamTaskDidBecomeInputAndOutputStreams: ((URLSession, URLSessionStreamTask, InputStream, OutputStream) -> Void)?
                                                                     ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:120:70: note: add @available attribute to enclosing class
    open var streamTaskDidBecomeInputAndOutputStreams: ((URLSession, URLSessionStreamTask, InputStream, OutputStream) -> Void)?
                                                                     ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:111:50: error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer
    open var streamTaskReadClosed: ((URLSession, URLSessionStreamTask) -> Void)?
                                                 ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:111:50: note: add @available attribute to enclosing class
    open var streamTaskReadClosed: ((URLSession, URLSessionStreamTask) -> Void)?
                                                 ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:114:51: error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer
    open var streamTaskWriteClosed: ((URLSession, URLSessionStreamTask) -> Void)?
                                                  ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:114:51: note: add @available attribute to enclosing class
    open var streamTaskWriteClosed: ((URLSession, URLSessionStreamTask) -> Void)?
                                                  ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:117:61: error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer
    open var streamTaskBetterRouteDiscovered: ((URLSession, URLSessionStreamTask) -> Void)?
                                                            ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:117:61: note: add @available attribute to enclosing class
    open var streamTaskBetterRouteDiscovered: ((URLSession, URLSessionStreamTask) -> Void)?
                                                            ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:120:70: error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer
    open var streamTaskDidBecomeInputAndOutputStreams: ((URLSession, URLSessionStreamTask, InputStream, OutputStream) -> Void)?
                                                                     ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:120:70: note: add @available attribute to enclosing class
    open var streamTaskDidBecomeInputAndOutputStreams: ((URLSession, URLSessionStreamTask, InputStream, OutputStream) -> Void)?
                                                                     ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:111:50: error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer
    open var streamTaskReadClosed: ((URLSession, URLSessionStreamTask) -> Void)?
                                                 ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:111:50: note: add @available attribute to enclosing class
    open var streamTaskReadClosed: ((URLSession, URLSessionStreamTask) -> Void)?
                                                 ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:114:51: error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer
    open var streamTaskWriteClosed: ((URLSession, URLSessionStreamTask) -> Void)?
                                                  ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:114:51: note: add @available attribute to enclosing class
    open var streamTaskWriteClosed: ((URLSession, URLSessionStreamTask) -> Void)?
                                                  ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:117:61: error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer
    open var streamTaskBetterRouteDiscovered: ((URLSession, URLSessionStreamTask) -> Void)?
                                                            ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:117:61: note: add @available attribute to enclosing class
    open var streamTaskBetterRouteDiscovered: ((URLSession, URLSessionStreamTask) -> Void)?
                                                            ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:120:70: error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer
    open var streamTaskDidBecomeInputAndOutputStreams: ((URLSession, URLSessionStreamTask, InputStream, OutputStream) -> Void)?
                                                                     ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:120:70: note: add @available attribute to enclosing class
    open var streamTaskDidBecomeInputAndOutputStreams: ((URLSession, URLSessionStreamTask, InputStream, OutputStream) -> Void)?
                                                                     ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:111:50: error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer
    open var streamTaskReadClosed: ((URLSession, URLSessionStreamTask) -> Void)?
                                                 ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:111:50: note: add @available attribute to enclosing class
    open var streamTaskReadClosed: ((URLSession, URLSessionStreamTask) -> Void)?
                                                 ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:114:51: error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer
    open var streamTaskWriteClosed: ((URLSession, URLSessionStreamTask) -> Void)?
                                                  ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:114:51: note: add @available attribute to enclosing class
    open var streamTaskWriteClosed: ((URLSession, URLSessionStreamTask) -> Void)?
                                                  ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:117:61: error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer
    open var streamTaskBetterRouteDiscovered: ((URLSession, URLSessionStreamTask) -> Void)?
                                                            ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:117:61: note: add @available attribute to enclosing class
    open var streamTaskBetterRouteDiscovered: ((URLSession, URLSessionStreamTask) -> Void)?
                                                            ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:120:70: error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer
    open var streamTaskDidBecomeInputAndOutputStreams: ((URLSession, URLSessionStreamTask, InputStream, OutputStream) -> Void)?
                                                                     ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:120:70: note: add @available attribute to enclosing class
    open var streamTaskDidBecomeInputAndOutputStreams: ((URLSession, URLSessionStreamTask, InputStream, OutputStream) -> Void)?
                                                                     ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/Request.swift:590:51: error: 'streamTask(withHostName:port:)' is only available on OS X 10.11 or newer
                task = queue.syncResult { session.streamTask(withHostName: hostName, port: port) }
                                                  ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/Request.swift:590:51: note: add 'if #available' version check
                task = queue.syncResult { session.streamTask(withHostName: hostName, port: port) }
                                                  ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/Request.swift:590:51: note: add @available attribute to enclosing instance method
                task = queue.syncResult { session.streamTask(withHostName: hostName, port: port) }
                                                  ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/Request.swift:590:51: note: add @available attribute to enclosing enum
                task = queue.syncResult { session.streamTask(withHostName: hostName, port: port) }
                                                  ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/Request.swift:592:51: error: 'streamTask(with:)' is only available on OS X 10.11 or newer
                task = queue.syncResult { session.streamTask(with: netService) }
                                                  ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/Request.swift:592:51: note: add 'if #available' version check
                task = queue.syncResult { session.streamTask(with: netService) }
                                                  ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/Request.swift:592:51: note: add @available attribute to enclosing instance method
                task = queue.syncResult { session.streamTask(with: netService) }
                                                  ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/Request.swift:592:51: note: add @available attribute to enclosing enum
                task = queue.syncResult { session.streamTask(with: netService) }
                                                  ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:111:50: error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer
    open var streamTaskReadClosed: ((URLSession, URLSessionStreamTask) -> Void)?
                                                 ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:111:50: note: add @available attribute to enclosing class
    open var streamTaskReadClosed: ((URLSession, URLSessionStreamTask) -> Void)?
                                                 ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:114:51: error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer
    open var streamTaskWriteClosed: ((URLSession, URLSessionStreamTask) -> Void)?
                                                  ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:114:51: note: add @available attribute to enclosing class
    open var streamTaskWriteClosed: ((URLSession, URLSessionStreamTask) -> Void)?
                                                  ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:117:61: error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer
    open var streamTaskBetterRouteDiscovered: ((URLSession, URLSessionStreamTask) -> Void)?
                                                            ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:117:61: note: add @available attribute to enclosing class
    open var streamTaskBetterRouteDiscovered: ((URLSession, URLSessionStreamTask) -> Void)?
                                                            ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:120:70: error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer
    open var streamTaskDidBecomeInputAndOutputStreams: ((URLSession, URLSessionStreamTask, InputStream, OutputStream) -> Void)?
                                                                     ^
/Users/liuhongbao/Downloads/PerfectTemplate/Packages/Alamofire-4.0.1/Source/SessionDelegate.swift:120:70: note: add @available attribute to enclosing class
    open var streamTaskDidBecomeInputAndOutputStreams: ((URLSession, URLSessionStreamTask, InputStream, OutputStream) -> Void)?
                                                                     ^
<unknown>:0: error: build had 1 command failures
error: exit(1): /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift-build-tool -f /Users/liuhongbao/Downloads/PerfectTemplate/.build/debug.yaml
```
 This is exactly what #1544 describes. 
 ËØ∑Âú®ÊèêÂá∫ issue ‰πãÂâçÊ£ÄÊü•ÊòØÂê¶Â∑≤ÁªèÊúâÂ≠òÂú®ÁöÑ issue„ÄÇ

Please search for existing issues before creating a new one.
  Hi - I am finding that lots of servers are respecting the order parameters that are added with json encoding.  This means that alamofire is breaking and causing issues that are difficult and time consuming to debug ( especially for us newbies to AF) 

Suggest that we have a method of sending our own "pre-encoded" body would be the ideal way to resolve this. ( and letting the server owner which in this case is a big enterprise) to sort out their api

example: 

`> Alamofire.request(endpoint, method: .post, parameters: myPre-encodedJsonBody, encoding: RawBody, headers: headers)`
Not sure if this is possible already - but its not immediately clear how to do it.
  I'm trying to save the request from a multipart upload call (snippet below), but I keep getting Error: cannot assign value of type '()' to type 'Request?'.. upload clearly has a return type of Request, so I'm not really sure why..

```
let request:Request = Alamofire.upload(.POST, myUrl!,
                            multipartFormData: {
                                multipartFormData in
                                ...
                            },
                            encodingCompletion: {
                                encodingResult in
                                print("encodingCompletion")
                                switch encodingResult {
                                case .Success(let upload, _, _):
                                    ...
                                    upload.responseJSON {
                                        response in
                                        debugPrint(response)
                                        ...
                                    }
                                case .Failure(let _):
                                    reject(Error.GenericError())
                                }
                            })
```
 Github is not a place for technical support. You can just google the error, or ask a question on [StackOverflow](http://stackoverflow.com/).
  Hi all,

First off thanks for the awesome library. I have made successful HTTP POST requests with Alamofire to my personal online server with a basic PHP script but now I am using PHP framework [Laravel 5.3](https://laravel.com/docs/5.3) and I can't seem to make a successful request to my local environment.

I am running a Laravel web application on Homestead virtual server on "192.168.10.10" which translates to [mysite].dev and works fine over a browser but I cannot seem to make a successful connection via X-code (8) and Swift (3).

Can anyone offer me some advice or share some resources please?

> @IBAction func signUp(_ sender: UIButton) {
> 
> ```
>     let parameters: Parameters = [
>         "name": nameTextField.text,
>         "username": usernameTextField.text,
>         "email": emailTextField.text,
>         "password": passwordTextField.text
>     ]
> 
> 
>     Alamofire.request("http://[mysite].dev/register.php", method: .post, parameters: parameters).responseJSON { response in
> 
>         debugPrint("All Response Info: \(response)") 
>          // FAILURE: Error Domain=NSURLErrorDomain Code=-1001 \"The request timed out.\"
> 
>  }
> ```

Thanks
 Github is not a place for technical support. You can just google the error, or ask a question on [StackOverflow](http://stackoverflow.com/).
  Is there a risk that when using `RequestRetrier` that you end up in an endless loop? 

... Where the `should(...)` implementation indicates the response be retried and the retry then fails with the same error as the original....  resulting in an endless fail/retry loop.  Do we need to code for this scenario or does the framework cover this?

If you're updating your session/token via REST in `should(...)` then I assume you have to ensure you're not using the same retrier so you don't get in an endless loop?   But wasn't sure about the actual request retry.
 I am also curious about this. I think it would be great if there was some kind of built in mechanism that allows you to set the number of retries to perform on a particular request before giving up.
  I am having trouble finding where this problem lies. I am using Alamofire to get a JSON array and then I iterate through each item and append it to my swift array which then displays it on a UITable.

``` swift
Alamofire.request("http://104.131.134.48:8090/all", method: .get).responseJSON { response in
            if let JSON = response.result.value {
                for title in JSON as! [AnyObject]{
                    self.shows.append(Show(name: title as! String, description: "Is the best", image: #imageLiteral(resourceName: "blowgun")))
                }
                print("JSON: \(JSON)")
                print("Shows: \(self.shows)")
            }
```

It works fine and populates the Table on the simulator but it does not when I test on a real device. My server still says it sent the JSON but I cannot find out why it will not work on the real device.
 Have you seen any error message?
  Alamofire.request(.POST, parameters: Parameters, encoding: .JSON, headers: requestHeader).responseJSON { response in

Error: Extra argument 'parameters' in call.
Swift iOS error. Please help.
 # Github is not for general support, it's only for bugs.

Questions belong on Stackoverflow and tons of people have had the exact same question : http://stackoverflow.com/search?q=%5Balamofire%5D+extra+argument
They all have the same issue and same solution : don't port your code to Swift 3.0 / Alamofire 4.0 without reading the [Migration Guide](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%204.0%20Migration%20Guide.md) and the new API guidelines for Swift 3.0. However I'll admit the Swift interpreter is extremely laconic here.
**Hint** : write something like `Alamofire.request("my.request.com", method: .post, parameters: parameters, encoding: JSONEncoding.defaut, headers: requestHeader).responseJSON { response in`
  When set target to deploy version IOS 8 in Xcode,  Almofire prompt alert (IOS Not supporting).
 Looks like iOS 8 will no longer be supported. They've set the minimum version to 9.0.
 Can they support iOS8 - a feature request please!
 They refused the support and closed the discussion thread. 

YOu can read their justification here #1367 
 Thanks.
 btw one guy has ported it with iOS8 support

Try this and see whether it works
pod 'Alamofire', :git => 'https://github.com/Homely/Alamofire.git', :branch => 'ios8'
  I'm making a request using Alamofire using the following code.

```
let headers: HTTPHeaders = [
    "myheader": "test",
]

Alamofire.request("http://localhost:3000/user", headers: headers).authenticate(user: "test@test.com", password: "testtedfnajksdst").validate().responseJSON { response in
```

On the server end I'm using Express.js and Node.js to handle the requests. For some reason tho my `/user` route gets called 3 times even tho I'm only calling Alamofire once. It seems to happen three times when I provide incorrect login information. The server responds with a 401 status code all 3 times. Only one of those requests actually includes the auth information tho.

When I provide the correct login information the route only gets called twice looks like. First time gives a 401 status code, second time responds with a 200 status code. After that if I make another request on the client side I get one 304 status code.

My question is why is the server showing multiple requests even tho on the client it looks like Alamofire is only making one request. Why also would only one request include the auth information? I'm using Xcode 8 on the iPhone Simulator 10.0
  This:

``` swift
Alamofire.request(endpoint, method: .post, parameters: GFCIdentifiers().toJSON(), encoding: JSONEncoding.default)
```

With `GFCIdentifiers().toJSON()` returning the following:

``` JSON
‚ñø Optional<Dictionary<String, Any>>
  ‚ñø some : 7 elements
    ‚ñø 0 : 2 elements
      - .0 : "deviceUdid"
      ‚ñø .1 : Optional<String>
        - some : "E74D0C00-7122-4F9C-AD91-1FE0D5A3D9A8"
    ‚ñø 1 : 2 elements
      - .0 : "accountEmail"
      - .1 : "sssilver@gmail.com"
    ‚ñø 2 : 2 elements
      - .0 : "platform"
      - .1 : "IOS"
    ‚ñø 3 : 2 elements
      - .0 : "userUuid"
      - .1 : "5FUD7DNHKVGDBMIKO4C2REBSGQ"
    ‚ñø 4 : 2 elements
      - .0 : "sessionId"
      - .1 : "c39a309d-04ce-4d50-b6a1-16a861d24bac"
    ‚ñø 5 : 2 elements
      - .0 : "channelId"
      - .1 : nil
    ‚ñø 6 : 2 elements
      - .0 : "userQualifier"
      - .1 : "HLSTUYTY5NFBBHCI3SFOMEPOX4"
```

Ends with a runtime crash:

> **\* Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: 'Invalid type in JSON write (_SwiftValue)'

I'm guessing it's caused either by `channelId` being `nil`, or by `deviceUdid` being a Swift Optional. In case of first, that should just be serialized as a [JSON null](https://en.wikipedia.org/wiki/JSON#Data_types.2C_syntax_and_example), in case of the second, the value should properly be unwrapped and set to either the unwrapped value, or JSON null.
 Well since Swift 3, the following constructs no longer compile:

``` swift
let data: JSON = [
    // ...
    "deviceUdid": self.deviceIdentifiers.deviceUDID ?? NSNull(),
    "channelId": self.deviceIdentifiers.channelID ?? NSNull()
]
```

> Optional chain has no effect, expression already produces 'String?'
 @jshier I suppose a worthy discussion to have is whether it's Alamofire's job to reasonably serialize and deserialize JSON supporting optionals and nils, and whether Alamofire users should know/care whether it uses JSONSerialization under the hood to get that job done, or something else if JSONSerialization is not up to the expectations/standard.

It's a tricky one, and a matter of core design philosophy.
 What about `let parameters = ["what": nil]`?
 I think we can close this then.

I'm assuming `[String: Any]` is just becoming `[String Any?]`
  Hello!
I have an authentication process that I need to implement and it's done via basic-auth. It's working via Paw and Postman and via an old Objective-C app, but now I started a new Swift 3 app with Alamofire 4 and RxSwift and I'm having issues sending it.
My problem is that the `authorizationHeader(user: String, password: String) -> (key: String, value: String)` method is the exact thing I need.
I just don't know how to access it and add it to the request headers (since the URLRequest is static now, instead of the mutable on as in Alamofire 3 had)

Can anyone point me into a right direction?
I have also tried using the `authenticate` method directly, but to no avail:

``` swift
class func Authenticate(router: Router, username: String, password: String) -> Observable<Any> {
        return Observable.create({ observer in
            let request = Alamofire.request(router)
                .authenticate(user: username, password: password, persistence: URLCredential.Persistence.forSession)
                .responseJSON(completionHandler: {
                    response in

                    switch response.result {
                    case .success(let value):
                        if Router.debugNetworking {
                            print("printing json directly from response: \(value)")
                        }
                        observer.on(.next(value))
                        observer.on(.completed)

                    case .failure(let error):
                        print("Error: \(error)")
                        observer.on(.error(NetworkError.ServerConnectionProblems(message: error.localizedDescription)))
                    }

                })
            request.resume()
            return Disposables.create {
                request.cancel()
            }
        })
    }
```

So I either need to attach this exact key-value pair to the request header:

``` swift
open static func authorizationHeader(user: String, password: String) -> (key: String, value: String)? {
        guard let data = "\(user):\(password)".data(using: .utf8) else { return nil }

        let credential = data.base64EncodedString(options: [])

        return (key: "Authorization", value: "Basic \(credential)")
    }
```

or the `authenticate` method working as expected
 I actually tested and can tell for sure that `.athenticate()` is not working. I had to add custom header for it to work
 I can confirm my server allows basic-auth. Tested with Postman and Paw as well.

I can do additional tests if you need me to, just tell me which ones, cause I already switched my implementation
 thanks. I already did it that way üòÑ 
  `JSONEncoding` and `PropertyListEncoding` now consider HTTP method. 
In case of GET, HEAD or DELETE parameters are not serialised into request body.

Addressing https://github.com/Alamofire/Alamofire/issues/1530
 The `GET` part I get it. But the `HEAD` and `DELETE` part seems to be violating HTTP semantics. AFAIK, there is not defined semantics for body in `HEAD` and `DELETE` request.
 @skyline75489, `HEAD` method is actually a `GET`, which does not expect a body in response.
It serves to fetch HEADers without obtaining much data. For instance, you may send a `HEAD` request to check `Last-Modified` date and send subsequent equal `GET` request in case if update is needed.

This means `HEAD` requests cannot contain body.

Body in `DELETE` requests violate HTTP semantics.
According to [section 4.3](https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3):

> if the request method does not include defined semantics for an entity-body, then the message-body SHOULD be ignored when handling the request.

And `DELETE` method specs [(section 9.7)](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.7) do not define semantics for the body. 

Moreover, ADO.NET Data Services Framework clearly [says](https://msdn.microsoft.com/en-us/library/dd541340.aspx):

> If a Delete request type (section 2.2.7.4) includes a request payload, it MUST be ignored and the request MUST be treated as if no entity body was provided.

‚Äî and I'm tending to trust Microsoft in this case. They're really competent when it comes to define integration architecture.
 Hey @cnoon 
Thanks for your detailed answer.

> In most cases, using JSON parameter encoding for a GET is going to be incorrect, but not always. There could be some crazy set of services that decided to deviate from the norm (we've all been there sadly). We want Alamofire to clearly do what it is you're instructing it to do. If a user is saying "I want a GET request with some JSON encoded in the HTTP body", well then that's what we want to them.

I hope you guys know your onions. Still, I would be glad to hear your answer on my comment below.

You see, whether your webservice is crazy or not, your iOS and tvOS won't be able to interact with it in case the server waits for the `GET` request to have a body.

On the SDK level, the `URLSession` framework won't give you any chance to send a `GET` request with a body ‚Äî your app will simply freeze until the request is timed out; needless to say, the app won't receive any response.

You may send a `GET` request with a non-empty body when your app operates on macOS, that's true. But for the mobile development your framework will simply cause a non-debugable behaviour, detected only by sniffing the traffic with third party instruments like Wireshark or Charles. 

The question is, why `AFNetworking`, the predecessor of the `Alamofire`, [do care](https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking/AFURLRequestSerialization.m#L1240) about its users, but your library cannot afford it? Should we fall back to the more reliable transport?
 @jshier, gotcha.

So, you [assume](https://github.com/Alamofire/Alamofire/blob/master/Source/ParameterEncoding.swift#L128) the method type (`GET`, `POST` etc.) to define where to put the request parameters (`body` or `URL`) for your URL encoder, but refuse to do the same thing for other encoders?

Such that, when I use an URL encoder with all its default settings, I [can be sure](https://github.com/Alamofire/Alamofire/blob/master/Source/ParameterEncoding.swift#L226) that my parameters are serialised correctly **automatically**, but the JSON encoder doesn't deserve the same thing. To behave well "out of the box" without additional tuning.

Okay, my pull request didn't contain the `destination` enumeration property for the JSON encoder, so we could have a consistent flexible behaviour between all your encoders, but I didn't hear such an argument from you. All I see is that you are trying to achieve some dubious simplicity.

You say that

> Alamofire's serializers are intended to be simple ... for users to switch serialization type based on request

but man, that's a lie. You don't have any "request-based" builders, like [the one](https://square.github.io/okhttp/2.x/okhttp/com/squareup/okhttp/Request.Builder.html) that `OkHttp` library offers. You've got a wildcard `request` method, which doesn't tell me a word if I call it like this:

``` swift
request(
    URL(string: "https://google.com")!,
    method: HTTPMethod.get,  // Hi, I'm an HTTP GET method
    parameters: [:],         // Hi, I'm an empty dictionary
    encoding: JSONEncoding.default
)
```

Empty brackets `{}` inside the request body make Google to respond with a `400 Bad Request`, by the way.

Your design doesn't give any hints to the end user about the best practices. Instead, you give the green light to the **bad code**.

I simply don't understand your trade-offs, guys. You are talking about flexibility. But hey, someone can invent a completely new HTTP method, say, `UPDATE`, and he [can actually use](https://developer.apple.com/reference/foundation/urlrequest/2011415-httpmethod) this method in scope of his own API. Because method names are basically strings and the SDK doesn't prohibit this. 

But no, you don't go so far, your list of methods is quite limited:

``` swift
public enum HTTPMethod: String {
    case options = "OPTIONS"
    case get     = "GET"
    case head    = "HEAD"
    case post    = "POST"
    case put     = "PUT"
    case patch   = "PATCH"
    case delete  = "DELETE"
    case trace   = "TRACE"
    case connect = "CONNECT"
}
```

So where is the line between your ultimate flexibility and solid RFC standards?

It happened that your library inherited most of the `AFNetworking` users, which is a half of the iOS developers out there, but it looks like you refuse to accept any responsibility for your bad design choices, which is really-really sad.

Please, excuse me for disturbing you. I understood your position, hope you will understand mine.
  What method would be used to remove response.data from memory as when I make a request and get a response the response.data is retained in memory? Is it supposed to be removed via ARC or do we have to manually remove it? If the latter is the case how?
    <unknown>:0: error: build had 1 command failures
error: exit(1): /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift-build-tool -f /Users/Xboy/Desktop/SPMDemo/.build/debug.yaml
 I'm seeing similar issues?  @brilliance-boy are you receiving errors prior to the line specified?  If so then can you added them to this issue?
  xCode 8.1 beta, iOS 10.1 beta, swift 3.0, real device iPhone 5 (at simulator works great!)
crash when calling Alamofire.request(request).responseJSON{....}

 Request.swift

```

// MARK: State

    /// Resumes the request.
    open func resume() {
        guard let task = task else { delegate.queue.isSuspended = false ; return }

        if startTime == nil { startTime = CFAbsoluteTimeGetCurrent() }

        task.resume()

        NotificationCenter.default.post(
            name: Notification.Name.Task.DidResume,
            object: self,
            userInfo: [Notification.Key.Task: task] <<<<=== EXC_BAD_ACESS
        )
    }
```

back trace
  STAR thread #1: tid = 0x73404, 0x00a92bbe libswiftCore.dylib`swift::metadataimpl::ValueWitnesses<swift::metadataimpl::OpaqueExistentialBox<0u> >::initializeWithCopy(swift::OpaqueValue*, swift::OpaqueValue*, swift::TargetMetadata<swift::InProcess> const*) + 12, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x2)
    frame #0: 0x00a92bbe libswiftCore.dylib`swift::metadataimpl::ValueWitnessesswift::metadataimpl::OpaqueExistentialBox<0u >::initializeWithCopy(swift::OpaqueValue_, swift::OpaqueValue_, swift::TargetMetadataswift::InProcess const_) + 12
    frame #1: 0x00a8f9ba libswiftCore.dylib`swift::OpaqueValue_ tuple_initializeWithCopy<false, false>(swift::OpaqueValue_, swift::OpaqueValue_, swift::TargetMetadataswift::InProcess const*) + 38
    frame #2: 0x008a6750 libswiftCore.dylib`Swift._ArrayBuffer.getElement (Swift.Int, wasNativeTypeChecked : Swift.Bool) -> A + 112
    frame #3: 0x008b7c30 libswiftCore.dylib`Swift.Array.subscript.getter : (Swift.Int) -> A + 152
    frame #4: 0x008b8d64 libswiftCore.dylib`protocol witness for Swift.Collection.subscript.getter : (A.Index) -> A.Iterator.Element in conformance <A> Swift.Array<A> : Swift.Collection in Swift + 24
    frame #5: 0x00a70548 libswiftCore.dylib`protocol witness for Swift.IndexableBase.subscript.getter : (A.Index) -> A._Element in conformance <A> Swift.Array<A> : Swift.IndexableBase in Swift + 24
    frame #6: 0x0088fe18 libswiftCore.dylib`Swift.IndexingIterator.next () -> Swift.Optional<A._Element> + 528
    frame #7: 0x009091c4 libswiftCore.dylib`static Swift._NativeDictionaryStorage.fromArray (Swift.Array<(A, B)>) -> Swift._NativeDictionaryStorage<A, B> + 436
    frame #8: 0x00908f7c libswiftCore.dylib`Swift.Dictionary.init (dictionaryLiteral : Swift.Array<(A, B)>...) -> Swift.Dictionary<A, B> + 80
  STAR frame #9: 0x00443450 Alamofire`Request.resume(self=<unavailable>) -> () + 736 at Request.swift:205
    frame #10: 0x00494e3c Alamofire`SessionManager.request(urlRequest=<unavailable>, self=<unavailable>) -> DataRequest + 716 at SessionManager.swift:260
    frame #11: 0x004948b4 Alamofire`SessionManager.request(url=<unavailable>, method=<unavailable>, parameters=<unavailable>, encoding=<unavailable>, headers=<unavailable>, self=<unavailable>) -> DataRequest + 776 at SessionManager.swift:237
    frame #12: 0x00423514 Alamofire`request(url=<unavailable>, method=<unavailable>, parameters=<unavailable>, encoding=<unavailable>, headers=<unavailable>) -> DataRequest + 536 at Alamofire.swift:146
    frame #13: 0x0013f4ec MyApp`ContentManager.(self=0x17653c70) -> ()).(closure #1) + 240 at ContentManager.swift:86
    frame #14: 0x000d53d8 MyApp`thunk + 56 at SELiveVC.swift:0
    frame #15: 0x010e1d66 libdispatch.dylib`_dispatch_call_block_and_release + 10
    frame #16: 0x010e1d52 libdispatch.dylib`_dispatch_client_callout + 22
    frame #17: 0x010e65f0 libdispatch.dylib`_dispatch_main_queue_callback_4CF + 1006
    frame #18: 0x1e006a16 CoreFoundation`__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 8
    frame #19: 0x1e004cfe CoreFoundation`__CFRunLoopRun + 1422
    frame #20: 0x1df54072 CoreFoundation`CFRunLoopRunSpecific + 486
    frame #21: 0x1df53e80 CoreFoundation`CFRunLoopRunInMode + 104
    frame #22: 0x1f700bfc GraphicsServices`GSEventRunModal + 156
    frame #23: 0x2310e82e UIKit`-[UIApplication _run] + 574
    frame #24: 0x23108f60 UIKit`UIApplicationMain + 150
    frame #25: 0x0008abd8 MyApp`main + 172 at AppDelegate.swift:13
    frame #26: 0x1d71e50a libdyld.dylib`start + 2
 Seeing this too on iOS 10.0.2
 It doesn't happen consistently. Using the same params, it seems to only crash 50% of the time.
 On https:// challenge demand user client certificate. How can i pick certificate from profile (General/DeviceManagement/DigitalWorkSpace/Profile  and pass it to for?

The same certificate prompted on Safari Browser while accessing.
 Any way we can help with this? iOS 10 has been out for quite some time. It'll be awesome if we can get this resolved soon. Our development is on a stand-still. I am seeing this on 10.0.2 (not the beta 10.1)
 @jshier This does not happen in simulator. Only happens on a device (in my case, iPad Air 2). 

There is nothing special with the call itself. It's just a vanilla request:

```
let params:[String:Any] =
[
    "TemplateId": "12345",
    "TemplateModel": templateModel,
    "From": "\(companyName) <\(orderEmail)>",
    "To": email
]

Alamofire.request("someHttpsURL", method: .post, parameters: params, encoding: JSONEncoding.default, headers: headers).responseJSON
{
    response in
}
```
 @AleyRobotics @jshier  I hava encountered a similar problem ,do you know how to fix it?
 I have similar issue and due to this my app is rejected by Apple.The crash occurred on iPad devices while the app is working fine on iPhone devices. I am attaching the Apple crash log file.It seems that the error occurred in Request handler of Alamofire
![screen shot 2016-11-10 at 11 06 41 am](https://cloud.githubusercontent.com/assets/13067085/20165782/50838770-a736-11e6-9a17-ae3dd7ae9e32.png)
Please try to fix this as soon as possible 
 Anyone tried on iOS 9.1? Tagging @cnoon. Thanks!  Hi there,

I'm struggling with creating a request which continues to run even if the app enters background, however I keep getting the code mentioned in the title, I try to make the request as followed:

```
let configuration = URLSessionConfiguration.background(withIdentifier: "com.company.myapp.background")
        let manager = Alamofire.SessionManager(configuration: configuration)

manager.request(url, method: .get, parameters: params, headers: headers())
            .responseJSON{response in switch response.result {
             ...
```

The error follows:

`Error Domain=NSURLErrorDomain Code=-999 "cancelled" UserInfo={NSErrorFailingURLStringKey=http://url, NSLocalizedDescription=cancelled, NSErrorFailingURLKey=http://url?params}
`

What am I doing wrong? I've stumbled over a couple of recent questions on stackoverflow, but they didn't seem resolved. Is my approach towards letting the request continue with the app in the background even correct?

Feel free to close this if it's encountered as support, I just feel I'm quite lost.

Cheers, and thanks.
 **Best Practice** 

```
open class API_Manager : Alamofire.SessionManager {


    public static let sharedManager: Functions = {
        let configuration = URLSessionConfiguration.default // or your configuration
        configuration.httpAdditionalHeaders = SessionManager.defaultHTTPHeaders // or your headers
        configuration.timeoutIntervalForRequest = 30
        configuration.timeoutIntervalForResource = 30

        let manager = Functions(configuration: configuration, delegate: SessionManager.default.delegate)
        return manager
    }()

    override init(configuration: URLSessionConfiguration, delegate: SessionDelegate, serverTrustPolicyManager: ServerTrustPolicyManager? = nil) {
        super.init(configuration: configuration, delegate: delegate, serverTrustPolicyManager: serverTrustPolicyManager)

    }

    required public init(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
}
```

**After that** 

```

API_Manager.sharedManager.request(url, method: .get, parameters: params, headers: headers())
            .responseJSON{response in switch response.result {

}
```
 @jshier Agree. 

More proper will be just like this

```
public static let sharedManager: SessionManager = {
    let configuration = URLSessionConfiguration.default
    configuration.httpAdditionalHeaders = SessionManager.defaultHTTPHeaders
    configuration.timeoutIntervalForRequest = 40
    configuration.timeoutIntervalForResource = 40

    let manager = Alamofire.SessionManager(configuration: configuration)
    return manager
}()
```

**Subclass** of `SessionManager` is needed from my side but in General not recommended or not required.  
  This looks good to me. Agree with the `AdaptError` solution to avoid accidental retry loops, and it solves the promblem I posted in https://github.com/Alamofire/Alamofire/issues/1674.
 This seems to properly address issue in #1674 
  Hi, 

i like your Tool very much but i have a problem with the Network Spinner / Indicator. If i open a ViewController (Alamofire imported) and get some Data from Webserver all works fine only the Iphone Networt Indicator is not hiding. It spinns permanently like a endless loop. 

Any idea why? 

Thanks for support!
 Hey mate,

This is the correct **repo**. Please follow that.
https://github.com/Alamofire/AlamofireNetworkActivityIndicator

Also please provide some code how your calling?
  Hi! this is using Alamofire 4.0.1 on Xcode 8 and with Swift 3.0 (targeting iOS 9)

I want to call the response function of the DataRequest like this:

```
 request.response { response in
                    self.handleCallbackWithResponse(response.response, rawData: response.data, error: response.error, emptySucessBlock: emptySucessBlock,
                        errorBlock: errorBlock, completionHandler: completionHandler)
                }

```

but get this compiler error:
Cannot call value of non-function type 'HTTPURLResponse?'

The variable is declared in Request.swift:

```
    /// The response received from the server, if any.
    open var response: HTTPURLResponse? { return task?.response as? HTTPURLResponse }

```

... and the function is declared in an extension to DataRequest in ResponseSerialization.swift:
e.g.: 

```
    @discardableResult
    public func response(queue: DispatchQueue? = nil, completionHandler: @escaping (DefaultDataResponse) -> Void) -> Self {

```

The error is gone, when I rename the function in the ResponseSerialization.swift code (and in my code, when I call it)

Kind regards, Marc
 Please check method step by step let me help you,
Post method **prototype** of 

`handleCallbackWithResponse`

I think you are not passing the correct **parameters** while calling this function.
  Hello,

I'm trying to make to call to Medium (https://www.medium.com/@username?format=json), but Medium adds "])}while(1);</x>" to avoid JSON Hijacking... 
So the .responseJSON make error : Alamofire.AFError Code=4 "JSON could not be serialized because of error..."

Have you any solution to work with this with ? 

Thank you ! 
 Looks like you should use the official API: https://github.com/Medium/medium-api-docs
 I already user the official API, but some information are only available by this way... 
  The 'Use Legacy Swift Language Version' setting is changed from 'No' to 'Unspecified'. This breaks my build and I have to manually reset the value. Can you please submit a fix for this or tell me how to fix it within the Cocoapod so my CI doesn't fail?
  Hi,

We're building an auth handler using RequestAdapter and RequestRetrier to handle token refresh. Following your OAuth2 example in the documentation will work, but it will also trigger a bunch of 401:s every time our app starts (where triggering multiple requests on wakeup). 

Our token refresh response contains an 'expires_in' parameter, which means the app will know if the access token has expired before a new request is made. It would be nice if we could check if the access token has expired in the RequestAdapter.adapt, and if so throw an error that we could catch in RequestRetrier.should.

We would like to avoid the 401:s, and also, this mechanism wouldn't require you to run a full request to know if a token is expired.

Thanks
 So it seems that if an error is thrown in the RequestAdapter (`adopt`) method, the RequestRetrier (`should`) method is _not_ called...
 After a couple of false starts in my code (now that it actually does short-circuit) I have verified that this works for me with the changes in #1682 
  When making a request that only has header info and an empty body, the request never returns. 

Here is a test case, that always times out:

``` swift
    func testThatShowsSuccessHeadAlwaysTimesOut() {
        let asyncExpectation = expectation(description: "Wait for response")
        Alamofire.request("http://httpbin.org/status/200").responseJSON { response in
            switch response.result {
            case .success:
                asyncExpectation.fulfill()
            case .failure(_):
                XCTFail("The call returned a failure")
            }
        }
        waitForExpectations(timeout: 20)
    }
```

Using curl 'curl -I http://httpbin.org/status/200', the header reports 'Content-Length: 0'.

If I change to a status of 204 (no content), the test passes.

Alamofire Version: I am using head of master.
 In My Case it  **Returns** and displayed error 

> ‚ñø FAILURE: responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.inputDataNilOrZeroLength)
>   ‚ñø failure : AFError
>     - responseSerializationFailed : Alamofire.AFError.ResponseSerializationFailureReason.inputDataNilOrZeroLength

Which i case its perfect because it doesn't content any **Body**. 
  Hi,

I've been working with the request retrier to reauthenticate when the request fails due to an expired token.

Is there a way to limit the number of retries ? This would be needed in case of a server bug that would send the expired token error when that's not the problem. There we have an infinite loop.

There may be other cases where this is needed.

I've seen this question unanswered on SO so I guess/hope I'm not the only one needing this. If you have some alternative way of doing this, please let me know.

Thanks,
 Hi @cnoon,

Thanks for your answer! The recent pull request was exactly what I was hoping, this is the simplest way to achieve that. And I could indeed have thought about a timer to do that.

Here is the [SO question](http://stackoverflow.com/questions/39713280/alamofire-session-manager-limit-retry-count). I'll let you post the answer :)

Cheers.
  See #1658 

And Cheers üçª 
  I guess this needs to be DownloadRequest
  I'd like to write adapter for Alamofire which let me always use Cached data even when it's expired, and in case it's expired call remote and update cache?

Is this case very rare so Apple didn't include it in their policies, or it just doesn't make sense?
  Occurs in the 'Alamofire.swift' file

There there's also 'Use of undeclared type 'AFError' and Use of unresolved identifier 'AFError' in 'MultipartFormData.swift'.

Use of unresolved identifier 'AFError' also occurs in ParameterEncoding.swift.
 How did you configure your project ? 
Manual or Cocoapods?

Alternatively,If you are using latest Alamofire which is **4.0+** than please make sure you are depolying Alamofire in `Xcode 8`
 Cocoapods, and I am using Xcode 8.
  Hey all, I'm currently working on a project as specified above and need to implement Alamofire, as I cannot update my pods because we haven't migrated the project to Swift 3 yet, I can't install Alamofire directly, so I wanted the manual install, can anyone direct me the right way to download Alamofire 3? not sure which commit it is... 

Thanks!
  Hi Team Alamofire,

I have added Alamofire using cocoa pods - pod 'Alamofire', '~> 4.0'
I am Using Xcode 8.0 and getting a popup to convert to latest Syntax while as per the documentation here it states that it already supports Swift3.
 Please make sure few things 
1. You have Cleaned and Clear `Derived data` 
2. Make sure you are running **CocoaPods 1.1.0+** 
 This worked for me

pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'master'
 @jorgecasariego 

By default it takes `master` branch no need to specify this 

**Recommended way** 
`pod 'Alamofire', '~> 4.0'` // Support from **iOS 9**
OR 
`pod 'Alamofire', '~> 3.5'` // Support rom **iOS 8**
 @hardikdevios First, I tried adding pod 'Alamofire', '~> 4.0' but it doesn't worked, so I changed to the way I posted before

This was the output: [!] Unable to find a specification for `Alamofire (~> 4.0.0)`
 @jorgecasariego Few things to try 

```
1. gem install cocoapods --pre // just to make sure you are updated 
2. pod repo update --verbose //May take time if you are not using `pod update`
3. pod install 
```
  request.response(completionHandler: { response in
                if response.error != nil {
                    completionHandler(success: false, errorResult: ErrorResult(request: request, error: error))
                    return
                }
                self.requests.removeFirst()
                self.start(completionHandler)
            })

error : **cannot call value of non-function type 'HTTPURLResponse?'**

![screen shot 1395-07-12 at 17 55 08](https://cloud.githubusercontent.com/assets/4400137/19050804/15cb39de-89bd-11e6-8afc-53427ac5e14e.png)

it was working in Alamofire 3 :(
 try to write the method step by step you will see the exact error.
  Using 4.0.1.

I completely turned of the phone from any internet connection and tried to upload something via Multipart Form Data. This part of the code becomes relevant:

```
switch encodingResult {
        case .success(let upload, _, _):
            upload.responseJSON { response in
                debugPrint(response)
            }
        case .failure(let encodingError):
            print(encodingError)
        }
}
```

I expected the `.failure` case, but for some reason the `.success` case gets returned. Also the inner closure of `upload.responseJSON` never gets called, but still it enters into the `.success` case. 

Why is that? Is that on purpose? With internet connection the method works completely fine and also the inner closure of `upload.responseJSON` gets called.
  I am sending a request to server with .Validate() but I am facing a little bit of error
I am using..

`Alamofire.request(getUrl("category"),method: .get, parameters:params, headers: 
    customHeader).validate().responseJSON {`
     `response in`
             `switch response.result{`
                `case .success:`
                   `if let value = response.result.value {`
                    `result = JSON(value)`
                    `//completion(result)`
                    `resolve(result)`
                `}`
               `case .failure(let error):`
                  `reject(error)`
                `print("\(error)")`
       `}`
  `}`

`responseValidationFailed(Alamofire.AFError.ResponseValidationFailureReason.unacceptableStatusCode(400))`

How to resolve this?? Please suggest me..
 is This error printing in the Logs ?
 yes I don't know why this error arise?
 Update following to for Alamofire :
fileprivate var acceptableStatusCodes: [Int] { return Array(200..<500) }
 This error mostly occurs because of empty JSON  I am getting this error
![screen shot 2016-10-03 at 5 19 28 pm](https://cloud.githubusercontent.com/assets/16931145/19036461/995df122-898d-11e6-8676-4ab66089e849.png)
please help me out
 Use `manger.multipartFormDataEncodingMemoryThreshold`
  I am using alamofire '4.0' In that library I didn't find out the validate() in Request class. could you please check this issue.
 Please provide your code and how you are calling 
 ![screen shot 2016-10-03 at 5 50 00 pm](https://cloud.githubusercontent.com/assets/16931145/19037073/f5f249d4-8991-11e6-955e-56a37220b9e4.png)
 `Request` is now `DataRequest`

so in you Method please change request variable Type  to `DataRequest`

**Please read Migration guide for 4.0**
[Migration Guide](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%204.0%20Migration%20Guide.md)
 thanq
  How to resolve this issue
 Please provide more information with Proper code.
 ![screen shot 2016-10-03 at 4 41 23 pm](https://cloud.githubusercontent.com/assets/16931145/19035644/556c1b56-8988-11e6-81d2-9351dae554d9.png)
 `Method`  is Now `HTTPMethod`

`Alamofire.HTTPMethod(rawValue: method)
`
This will work

**Please read Migration guide for 4.0**
[Migration Guide](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%204.0%20Migration%20Guide.md)
  I tried to use the new feature, RequestRetrier, and followed the official document. 

```
class AuthHandler: RequestRetrier {
    public func should(_ manager: SessionManager, retry request: Request, with error: Error, completion: RequestRetryCompletion) {
        if let response = request.task?.response as? HTTPURLResponse, response.statusCode == 401 {
            completion(true, 1.0)
        }
        else {
            completion(false, 0.0)
        }
    }
}
```

Setup a session manager in a controller and set the retrier

```
let sessionManager = SessionManager()
sessionManager.retrier = AuthHandler()
sessionManager.request(...
```

But it always popup the message in AuthHandler.swift
`Type 'AuthHandler' does not conform to protocol 'RequestRetrier'`
 AuthHandler RequestRetrier
 Thanks! It works üëç 
I used the Xcode autofilled format (including `public` ACL without `@escaping`). They might need to be modified
  Hi. I'm using Alamofire for requests to my Magento server. Everything works perfectly until I have to request by one different kind of url which use for searching.
The url is like this:
`
http://mymagento.com/index.php/rest/V1/products/?searchCriteria[filter_groups][1][filters][0][field]=category_id&searchCriteria[filter_groups][1][filters][0][value]=33&searchCriteria[filter_groups][1][filters][0][condition_type]=eq
`

I use it like other normal Alamofire request:

```
       let requestURL = "http://mymagento.com/index.php/rest/V1/products/?searchCriteria[filter_groups][1][filters][0][field]=category_id&searchCriteria[filter_groups][1][filters][0][value]=33&searchCriteria[filter_groups][1][filters][0][condition_type]=eq"

        Alamofire.request(requestURL)
            .validate()
            .responseArray { (response: DataResponse<[Product]>) in

                let result = response.result

                switch result {
                case .success :
                    if let products = result.value {
                        for product in products {
                            debugPrint(product.sku)
                            productList.append(product)
                        }
                        onSuccess(productList)
                        break
                    }
                case .failure :
                    onError(result.error! as NSError)
                }
        }
```

But the response result always fail. I tested the url on The RESTful client side Chrome plugin and it's working well. 
Do I miss something ?
Thank you.
 Oh I should read the doc carefully. thank you for your reply 
  I'm trying to send parameters with uploading an image like so:

```
Alamofire.upload(
    multipartFormData: { multipartFormData in
        multipartFormData.append(UIImagePNGRepresentation(tempImage!)!, withName: "file", fileName: "picture.png", mimeType: "image/png")

        // Send parameters
        multipartFormData.append((UserDefaults.standard.value(forKey: Email) as! String).data(using: .utf8)!, withName: "email")
        multipartFormData.append("png".data(using: .utf8)!, withName: "type")

    },
    to: "user/picture",
    encodingCompletion: { encodingResult in
        switch encodingResult {
        case .success(let upload, _, _):
            upload.responseJSON { response in
                debugPrint("SUCCESS RESPONSE: \(response)")
            }
        case .failure(let encodingError):
            self.removeSpinnerFromView()
            print("ERROR RESPONSE: \(encodingError)")

        }
    }
)
```

The send parameters (email and type) are not appearing on my sailsjs server. Is there something I'm doing wrong here? This is what the documentation says?
 When I lave out the part where I put:

```
multipartFormData.append(UIImagePNGRepresentation(tempImage!)!, withName: "file", fileName: "picture.png", mimeType: "image/png")
```

THEN the parameters are uploaded. I think this is a bug. I'm using 4.0.1.
 @cnoon: I use the same server side code for Alamofire 3.x.x and AFNetworking and it works. The problem is that the "type" and "email" data is not being added. I believe this is a real bug in 4.0.1 for Alamofire. My server side code has also be thoroughly tested :)

Can you show me an example of what I have above with the picture and form parameters all being sent? I cannot seem to get them sent together. My server side complains it only gets image with no form data other than that.
 let imageData = UIImagePNGRepresentation(self.signatureImgView.image!)

```
            let defaultHTTPHeaders: HTTPHeaders =
                           [
                            "token": AFWrapperClass.User_Token,
                           ]

            let URL2 = try! URLRequest(url: "http://.....", method: .post, headers: defaultHTTPHeaders)

    let multipartFormData = MultipartFormData()


    Alamofire.upload(multipartFormData: { (multipartFormData) in

        multipartFormData.append(imageData!, withName: "signImg", fileName: "signature.png", mimeType: "image/png")
```

//            for (key, value) in self.parameters
//            {
//                multipartFormData.append(value.data(using: String.Encoding.utf8)!, withName: key)
//            }
            }, with: URL2, encodingCompletion: { (result) in

```
            switch result {
            case .success(let upload, _, _):

                upload.responseJSON
                    {

                    response in

                    print(response.request)  // original URL request
                    print(response.response) // URL response
                    print(response.data)     // server data
                    print(response.result)   // result of response serialization

                    if let JSON = response.result.value
                    {
                        print("JSON: \(JSON)")
                    }
                }

            case .failure(let encodingError):
                print(encodingError)

            }

    })
}
```

  }

it shows error while uploading image please help me.
  ```
        self.manager.upload(multipartFormData: { multipartFormData in
            if let imageData = UIImageJPEGRepresentation(file, 0.6) {
                multipartFormData.append(imageData, withName: "upload", fileName: "jpeg", mimeType: "image/jpeg")
            }
            multipartFormData.append(xxx.data(using: String.Encoding.utf8, allowLossyConversion: false)!, withName :"xxx")
            multipartFormData.append(xxx.data(using: String.Encoding.utf8, allowLossyConversion: false)!, withName :"xxx")
            multipartFormData.append(xxx.data(using: String.Encoding.utf8, allowLossyConversion: false)!, withName :"xxx")
            multipartFormData.append(xxx.data(using: String.Encoding.utf8, allowLossyConversion: false)!, withName :"xxx")
       }, to: "http://example.com/r", encodingCompletion: { encodingResult in
                switch encodingResult {
                case .success(let upload, _, _):
                    upload.uploadProgress{(progress: Progress)  in
                        reqProgress(progress.fractionCompleted)

                    }
                    upload.responseJSON { response in
                        switch response.result {
                        case .success(let JSON):
                            guard let response = JSON  as? [AnyObject] else{
                                completion(nil)
                                return
                            }
                            completion(response)
                        case .failure( _):
                            completion(nil)
                        }

                    }
                case .failure(let encodingError):
                    completion(nil)
                }
        })
```

upload.uploadProgress gives me error:

> Cannot call value of non-function type 'Progress'
 @GZaccaroni Did you ever figure this out? I've run into this issue and can't figure out what's going on.

From what I've read, Request has a conflicting progress field? I found a lot of people with the same issue, and I wonder if this should be opened and addressed? The MultipartFormData example should maybe show the correct usage of .uploadProgress in the encodingCompletion closure.

Related discussions/issues:
https://github.com/Alamofire/Alamofire/issues/679#issuecomment-222371221
https://github.com/Alamofire/Alamofire/issues/989#issuecomment-251508846
Discussing v3: http://stackoverflow.com/a/39075334/1575489
 I don't understand why, but this works:

``` swift
.uploadProgress { progress in
    self.ProgressBar.progress = Float(progress.fractionCompleted)
}
```

And this gives the `Cannot call value of non-function type 'Progress'` compiler error:

``` swift
.uploadProgress { progress in
    self.ProgressBar.setProgress(Float(progress.fractionCompleted), animated: true)
}
```
 @rudedogg For me: 

This doesn't work:

```
.uploadProgress { progress in
    self.progressBar.setProgress(progress.fractionCompleted, animated: true)
}
```

This works: 

```
.uploadProgress { progress in
    self.progressBar.setProgress(Float(progress.fractionCompleted), animated: true)
}
```

Strange bug. `Alamofire.upload(
                multipartFormData: { multipartFormData in
                    if let imageData = UIImageJPEGRepresentation(image, 0.5) {
                        multipartFormData.append(imageData, withName:imageType ,fileName: "file", mimeType: "image/jpeg")
                    }
                    for (key, value) in parameter {
                        multipartFormData.append(String(describing: value).data(using: .utf8)!, withName: key)
                    }
            },  to: url, method: .put, headers:headers,
                encodingCompletion: { encodingResult in
                    switch encodingResult {
                    case .success(let upload, _, _):
                        .uploadProgress{ progress in
                                ProgressBar.setProgress(Float(progress.fractionCompleted), animated: true)
                            }
                        upload.responseJSON { response in
                            debugPrint(response)
                            let statusCode = response.response?.statusCode
                            var errorMessage = ""
                            if((response.result.error != nil)) {
                                errorMessage = (response.result.error?.localizedDescription)!
                            }
                            var status = false
                                status = true
                            if(statusCode == 200) {
                                
                            }
                            completion(status, statusCode!, errorMessage)
                        }
                    case .failure(let encodingError):
                        print(encodingError)
                        completion(false, 500, "error")
                    }
                
                
            }
                
            )
`



For Alamofire I'm Using Object mapper so how I'm create on class file and use in my view controller swift file..??
  I want some information stored in the database server  if  disconnected the Internet stored database sqlite when  Internet connection to send data to the server (even when the app is closed) What is your suggestion for the job
  Hi guys,
converting my code base to swift 3.0, I solved whole compile error except this issue :)

I looked up here and google but couldn't find proper solution

my request:

request = Alamofire.request(imageURL, method: .get).validate(contentType: ["image/*"]).response(completionHandler: { (request: URLRequest?, response: HTTPURLResponse?, data: NSData?, error: NSError?) -> Void in

how can I overcome this?

Thanks in advance.
 Please see [this post](http://stackoverflow.com/questions/39602347/cannot-call-value-of-non-function-type-httpurlresponse-alamofire-4-0/39800571#39800571)
  Using Alamofire 4.0.1 after building the app, an error pops up alerting that "Bundle at path */Frameworks/Alamofire.framework did not have a CFBundleIdentifier in its Info.plist"

This happened exactly after updating to 4.0.0, is there some workaround to it.

Thanks in advance.
  I am using Alamofire for posting login information to server. In a first request, i can read "set-cookie" header from response. But if i try to post login information again, response don't have "set-cookie" header. If i restart simulator, it works in a first request again. I did'n understand the problem. Maybe a caching issue?
  Alamofire.request("https://httpbin.org/get").responseJSON { response in
                debugPrint(response)

```
            if let json = response.result.value {
                let ip = json["url"] as! String
            }
        }
```

Error : üëé  Type 'Any' has no subscript members
 ```
            if response.result.value is NSNull {
                return
            }
            let JSON = response.result.value as? NSDictionary
            let id = JSON?["id"] as! String
```

I think you need the ? before ["url"]
 This is how I always handle my JSON responses.

``` Swift
.responseJSON {
    response in

    switch response.result {
    case .failure(let error):
        // Do whatever here
        return

    case .success(let data):
        // First make sure you got back a dictionary if that's what you expect
        guard let json = data as? [String : AnyObject] else {
            NSAlert.okWithMessage("Failed to get expected response from webserver.")
            return
        }

        // Then make sure you get the actual key/value types you expect
        guard var points = json["points"] as? Double,
            let additions = json["additions"] as? [[String : AnyObject]],
            let used = json["used"] as? [[String : AnyObject]] else {
                NSAlert.okWithMessage("Failed to get data from webserver")
                return
        }
```
  This fixes the problem where Xcode pops a warning that it needs to convert the project source into Swift 3, since it isn't sure that the code's been converted already.
  How to set timeoutIntervalForRequest in Alamofire 4.0 and swift 3.0.
Bellow code working for me swift 2.2 and Alamofire 3.0.

`Alamofire.Manager.sharedInstance.session.configuration.timeoutIntervalForRequest = 300`
 Use this 
`Alamofire.SessionManager.default.session.configuration.timeoutIntervalForRequest = 300
`

**Please read Migration guide for 4.0**
[Migration Guide](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%204.0%20Migration%20Guide.md)
 Thanks @hardikdevios  its works üëç 
  I'm currently trying to upload video using a multipartform.

XCode 8, Swift 3

```
Alamofire.upload(
     multipartFormData: { (multipartFormData) in
        multipartFormData.append(videoData, withName: "video", fileName: "video.mp4", mimeType: "application/octet-stream")
      },
      to: urlYoutube,
      encodingCompletion: { (result) in
                    switch result {
                    case .success(let upload, _, _):
                        upload.responseJSON { response in
                            debugPrint(response)
                        }
                    case .failure(let encodingError):
                        print(encodingError)
                    }
            })
```

I'm getting this error -> "Expression type '()' is ambiguous without more context."

Not sure what I'm doing wrong here. Please advise.
 See

 `videoData` is **NSData** but multipartFormData need **Data** from Swift 3

**Solution**

`multipartFormData.append(data as! Data, withName: "video", fileName: "video.mp4", mimeType: "application/octet-stream")
`
  Greetings, I'm using Alamofire 3.5 in my Swift 2.2 app and have been researching the best way to add offline support to my iOS app.  I was happily surprised to learn about NetworkReachabilityManager, and to read that it can be used to "retry network requests when a connection is established". I'm confused about how this works, however.

How does one cause these requests to retry?
Is it automatic, or do I need to check for connectivity when my app opens and call some method on NetworkReachabilityManager?

Will it work for all kinds of requests, including Alamofire.upload() requests?

My thanks for adding this cool feature. I was all set on adding fields to each table to tombstone records and keep track of lastSync time on each record. This could be much more elegant, as it sounds like it effectively makes it so my app is never really offline.
  I'm in need to run an swift app in background Even when close  app
whatsapp for example  close get data
 It is related to remote notification. Whatsapp cannot start (as far as I know) a task on its own when "totally" closed and removed from app stack. It does sth when receives a remote notif.
  **pod 'Alamofire',
:git => 'https://github.com/Alamofire/Alamofire.git',
:branch => 'swift3'**
Pre-downloading: `Alamofire` from `https://github.com/Alamofire/Alamofire.git`, branch `swift3`

[!] Error installing Alamofire
[!] /usr/bin/git clone https://github.com/Alamofire/Alamofire.git /var/folders/9b/nfkhxvps0lnfv842q42k90mm0000gp/T/d20160929-6166-htbeyy --template= --single-branch --depth 1 --branch swift3

Cloning into '/var/folders/9b/nfkhxvps0lnfv842q42k90mm0000gp/T/d20160929-6166-htbeyy'...
warning: Could not find remote branch swift3 to clone.
fatal: Remote branch swift3 not found in upstream origin
# 

**pod 'Alamofire', '~> 4.0'**
[!] Unable to satisfy the following requirements:
- `Alamofire (~> 4.0)` required by `Podfile`

Specs satisfying the `Alamofire (~> 4.0)` dependency were found, but they required a higher minimum deployment target.

I used Coacoapods newest version + Xcode 8.

What can I do now?
 Please try add 
platform :ios, '9.0' 
to your Podfile
 It's okie for me now. Thank you!
 There is no branch name called swift3?
 One guy has ported the 4.0.0 version to the iOS 8. Though it's not official worth the try since we are being forced by our managers to support iOS 8.

pod 'Alamofire', :git => 'https://github.com/Homely/Alamofire.git', :branch => 'ios8'
  Showing All Issues
Check dependencies

‚ÄúUse Legacy Swift Language Version‚Äù (SWIFT_VERSION) is required to be configured correctly for targets which use Swift. Use the [Edit > Convert > To Current Swift Syntax‚Ä¶] menu to choose a Swift version or use the Build Settings editor to configure the build setting directly.
 I installed Alamofire  using Cocoapods and have the same error. 
Xcode8

### my Podfile

use_frameworks!

target "eWayCRM" do
        pod 'Alamofire', '~> 4.0'
end
 Have same issue for Alamofire Version 4.0.1
 Please, check this reference: https://github.com/Alamofire/Alamofire/issues/1639
 Could this cause the problem? CocoaPods are still in release candidate 2, I am waiting for stable 1.1.0 version.

kolisko$ pod --version
1.0.1
  Our app in TestFlight crashed. On investigating the crash report, we identified that app had crashed in ResponseSerialization.swift file. 

Debug information:
Alamofire 3.5.0
Xcode: 8.0
Captain: 10.11.6

![screen shot 2016-09-29 at 1 46 41 pm](https://cloud.githubusercontent.com/assets/15630031/18946352/23cb5452-864c-11e6-9493-cf3b9870b573.png)

But it is not a reproducible issue and we do no have any clue from the Crash report.
 I have the same thing and in debug I get: 
"Project name" was compiled with optimization - stepping may behave oddly; variables may not be available.
 Guys, I resolved this issue when I set in pods and in project the same "Optimization level". 
 @adrimarti, is changing the Optimization level the solution for @kakilan's problem? I am experiencing the same issue and changed it to whole optimization level and I am still getting crashes at the same point as @kakilan 

EDIT: I have also tried all pods and the app with fast, single-file optimization level and crashes still happen... Any suggestion? I am running 3.5.1  i was just use af_setImageWithURL() to async download image and all download was stop at here
![image](https://cloud.githubusercontent.com/assets/9428073/18943860/b6aa78c2-8654-11e6-87e0-6cc90522e297.png)

in debug navigator , this is the last

![image](https://cloud.githubusercontent.com/assets/9428073/18944095/fc68a1bc-8655-11e6-8f30-ee8fdaa19386.png)
    Im sending a body that has in it an empty json.

`["and": [["id": ["inq":["1", "2", "3"]]], [:]]]`

Im using a URLRequestConvertible enum.
after the encoding in asURLRequest 
`try URLEncoding.default.encode(urlRequest, with: params)`

I get  

`query[and][][id][inq][]=55b6725435c49b0300a1f979`
and its missing the empty json.

Is there a way to leave the empty json in the body?

Thanks  
 Thanks @cnoon .
This doesn't work.

Using `.methodDependent`, `.httpBody`  gives me the same result (missing empty json).
Using `.queryString` appends the body to the query instead of the http body.
 Can you give us your brief function code how you are calling and adding perams.?
 ``` Swift
enum AssignmentRouter: URLRequestConvertible {

    case assign(params:[String:Any])


    var method: Alamofire.HTTPMethod {
        switch self {
        case .assign:
            return .post
        }
    }

    var path: String {
        switch self {

        case .assignForms(params: _):
            return "/**/a"
        }
    }

    var params: [String: Any]? {
        switch self {
        case .assign(let params):
            return params
        }
    }

    func asURLRequest() throws -> URLRequest {
        let url = (APIManager.baseURL + path).encodeUrl()
        var urlRequest = URLRequest(url: URL(string: url!)!)

        urlRequest.httpMethod = method.rawValue

        //add headers
        APIManager.addHeraders(urlRequest: &urlRequest)

        return  try URLEncoding.default.encode(urlRequest, with: params)
    }
}
```
 **Please Try this** 
first convert your `parameter` in to `JSON` string and use this 

`try! StringBodyEncoding(string: JSONString ).encode(urlRequest,with:nil)
`

**Custom Encoding Struct** 

```
struct StringBodyEncoding: ParameterEncoding {
    private let string: String

    init(string: String) {
        self.string = string
    }

    func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -> URLRequest {
        var urlRequest = urlRequest.urlRequest
        urlRequest?.httpBody = string.data(using: String.Encoding.utf8, allowLossyConversion: false)
        return urlRequest!
    }
}

```
 Not working for me, the empty JSON is still missing.

``` Swift
if let data = try? JSONSerialization.data(withJSONObject: params!, options: []), let s = String(data: data, encoding: String.Encoding.utf8)  {

            return try! StringBodyEncoding(string: s).encode(urlRequest, with:nil)

        }
```
 @cnoon i want to send this JSON:

``` javascript
{"and": {{"id": {"inq":{"1", "2", "3"}}}, {}}}
```
 Thanks @cnoon 
My problem was using `URLEncoding` instead of 'JSONEncoding'
The invalid JSON was a mistake in the comment.
  ```
    func downloadProgress(bytesRead: Int64, totalBytesRead: Int64,
        totalBytesExpectedToRead: Int64) {
        let percent = Float(totalBytesRead)/Float(totalBytesExpectedToRead)

        dispatch_async(dispatch_get_main_queue(), {
            self.progress.setProgress(percent,animated:true)   
        })
        print("ProgressÔºö\(percent*100)%")
    }

    func downloadResponse(request: NSURLRequest?, response: NSHTTPURLResponse?,
        data: NSData?, error:NSError?) {
        if let error = error {
            if error.code == NSURLErrorCancelled {
                self.cancelledData = data 
            } else {
                print("Failed to download file: \(response) \(error)")
            }
        } else {
            print("Successfully downloaded file: \(response)")
        }
    }

    @IBAction func continueBtnClick(sender: AnyObject) {
        if let cancelledData = self.cancelledData {
            self.downloadRequest = Alamofire.download(resumeData: cancelledData,
                destination: destination)

            self.downloadRequest.progress(downloadProgress) 

            self.downloadRequest.response(completionHandler: downloadResponse) 

            self.stopBtn.enabled = true
            self.continueBtn.enabled = false
        }
    }
```

The codes works fine on version 3.1, but it refuse to work after upgrading to 4.0
The following two line shows error "no such memeber fo progress" and " no such member of response"
1. self.downloadRequest.progress(downloadProgress) 
2. self.downloadRequest.response(completionHandler: downloadResponse) 

How to solve these two problem? Thanks.
 Thanks your guidance, I finally found the key.
 @jdleung, could you help me out? What is this key you are referring to?

I also had a `error.code == NSURLErrorCancelled`comparison, but I'm now unable to get this error.
 
I also tried to go trough the `downloadProgress` API, but was unable to get a way of knowing the request failed because it was user canceled. @nmdias I just meant I found the solution. I'm sorry that I forgot how I solved it, it's been some days after all. You can post your code here ;-)  ![screen shot 2016-09-28 at 11 13 15 am](https://cloud.githubusercontent.com/assets/16931145/18901925/a3181640-856c-11e6-9d0e-e952ba838ac2.png)
Please chech Once. How to install supported alamofire into swift3.0
  I want to profile an app that uses Alamofire 4.0, on Mac OS 10.12, with Xcode 8.0.

Alamofire is installed using the recommended Carthage method.

The build log is attached but the error is this:

```

Showing Recent Messages
GenerateDSYMFile /Users/Ben/Library/Developer/Xcode/DerivedData/Workspace2-fykqduoinplovpdrskgnrjfxasra/Build/Products/Release-iphonesimulator/Alamofire.framework.dSYM /Users/Ben/Library/Developer/Xcode/DerivedData/Workspace2-fykqduoinplovpdrskgnrjfxasra/Build/Products/Release-iphonesimulator/Alamofire.framework/Alamofire
    cd /Users/Ben/Projects/Apps/Workspace2/Carthage/Checkouts/Alamofire
    export PATH="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/dsymutil /Users/Ben/Library/Developer/Xcode/DerivedData/Workspace2-fykqduoinplovpdrskgnrjfxasra/Build/Products/Release-iphonesimulator/Alamofire.framework/Alamofire -o /Users/Ben/Library/Developer/Xcode/DerivedData/Workspace2-fykqduoinplovpdrskgnrjfxasra/Build/Products/Release-iphonesimulator/Alamofire.framework.dSYM

error: lipo: can't move temporary file: /Users/Ben/Library/Developer/Xcode/DerivedData/Workspace2-fykqduoinplovpdrskgnrjfxasra/Build/Products/Release-iphonesimulator/Alamofire.framework.dSYM/Contents/Resources/DWARF/Alamofire to file: /Users/Ben/Library/Developer/Xcode/DerivedData/Workspace2-fykqduoinplovpdrskgnrjfxasra/Build/Products/Release-iphonesimulator/Alamofire.framework.dSYM/Contents/Resources/DWARF/Alamofire.lipo (No such file or directory)
Command /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/dsymutil emitted errors but did not return a nonzero exit code to indicate failure

```

[Build Project_2016-09-28T12-53-16.pdf](https://github.com/Alamofire/Alamofire/files/497035/Build.Project_2016-09-28T12-53-16.pdf)
  Hi,
I was wondering how to send a image in swift 3 to a local ftp server.Here is the server I'm using:https://github.com/benelog/one-ftpserver
  ```
                                        ^~
```

/Users/yokesh/Desktop/SwiftHTTP/Source/Request.swift:248:29: error: boolean condition requires 'where' to separate it from variable binding
        if let u = self.url , queryString.characters.count > 0 {
  Hi,

I was debugging the Application and it looks like Alamofire 3.5 has memory leaks:

Debug information:
Alamofire 3.5
Xcode: 8.0
Captain: 10.11.6

General view memory leak (every leak has something to do with a request)
![screen shot 2016-09-27 at 10 43 26](https://cloud.githubusercontent.com/assets/7165151/18866250/6eed967e-849f-11e6-81c8-ccba891cb471.png)

The following lines are highlighted if you click on a leak.
![screen shot 2016-09-27 at 10 44 04](https://cloud.githubusercontent.com/assets/7165151/18866248/6ecc50ae-849f-11e6-9416-e5b57a91ed51.png)

![screen shot 2016-09-27 at 10 43 47](https://cloud.githubusercontent.com/assets/7165151/18866249/6eed2072-849f-11e6-8fc6-07a77ca0a1e2.png)
 @cnoon Thank you for your respond, I need some time to create a demo app, demonstrating this.

1) I Use the regular Alamofire.request(method, path, parameters).responseJSON {  } method.
2) OS is macOS Captain: 10.11.6. I run this in the simulator (Version 10.0 (SimulatorApp-700.5.3 )
3) I'll need some time, but will come back on this!
 @jshier thank you very much!
 this save me ~~great thx!
    I am trying to encode array of Int with .get request but Alamofire 4.0 is escaping "[]" those brackets with percentage escaping.

......?locationId%5B%5D=11&pageNumber=0

Any idea how to solve it?
 What are you trying to solve?  You can't really just pass [] characters in a URL, they get encoded.  In whatever script you're getting just decode the %5B and %5D back into [] if you really have to pass them.  
  Hi,

Why does the parameters being sent over gets an optional prefix? The parameters being passed in the request are not optional so why is it being converted and even being sent with unwrapped value (with optional prefix). Any solution on this?

Thanks!
 Hi @cnoon ,

I've tried sending a request from my mobile app to my web service (by query or body or default encoding, basically tried all types) and the parameter values being sent has the optional prefix. I have here one of the logged request received in my web service:

Info:   content-type:application/x-www-form-urlencoded; charset=utf-8
Info:   accept:_/_
Info:   connection:keep-alive
Info:   content-length:204
Info:   user-agent:TestExercise/0.1.0 (com.vandt.app.Hate2Exercise; build:1; iOS 10.0.0) Alamofire/4.0.1
Info:   accept-language:en;q=1.0
Info:   authorization:Basic MjI3WkhCOjMwOWVhO....
Info:   accept-encoding:gzip;q=1.0, compress;q=0.5
Info:   request: client_id=Optional%28%222A3D%22%29&code=Optional%28%2249fb9ec9d73988a8e313285%22%29&grant_type=Optional%28%22authorization_code%22%29&redirect_uri=Optional%28%22testexercise%3A//%22%29

Notice the Optional word prefix on every parameter value. Same goes even on body type and so on.
 i'm passing them as string literals. like ["client_id": "blah_blah_blah", ....].
  using alamofire4 cant request data in post method 

```
 let parameters = [
            "name": "xx",
            "encoding": "utf8",
            "data": "1"
            ]
Alamofire.request(urlString, method: .post, parameters: parameters, encoding: JSONEncoding.default).responseJSON { response in
        if(response.result.isFailure){
               print("no data!");
        }else{
              print(response.result.value);
       }
}
```
 my console always print no data
 Please check Url type : http or https
 you can use to configure App Transport Security:


 <key>NSAppTransportSecurity</key>
    <dict>
      <key>NSExceptionDomains</key>
     <dict>
       <key>yourserver.com</key>
      <dict>
      <!--Include to allow subdomains-->
      <key>NSIncludesSubdomains</key>
      <true/>
      <!--Include to allow HTTP requests-->
      <key>NSTemporaryExceptionAllowsInsecureHTTPLoads</key>
      <true/>
      <!--Include to specify minimum TLS version-->
      <key>NSTemporaryExceptionMinimumTLSVersion</key>
      <string>TLSv1.1</string>
    </dict>
  </dict>
</dict>

 @phanisai4u
i already set NSAllowsArbitraryLoads to true
my server is using http , previous alamofire3 no problem , but alamofire version 4 got problem
 i fixed already , just change the encoding

`encoding: URLEncoding.httpBody`
 I have this identical problem...  its not fixed by changing the encoding
  I'm curious why the minimum deployment target was upgraded to 9.0? After upgrading to Swift 3, I use `pod 'Alamofire', '~> 4.0.0'`, which only support iOS 9.0 or later. But my project still wants to support 8.x.
`s.ios.deployment_target = '9.0'`
  Hi there,

I'm trying to get a responseJSON containing JSON with √¶, √∏ and √•, however it appears like this, for example:

`U00e6`

My call looks like this: 

```
Alamofire.request(specificURL, method: .get, parameters: param, encoding: URLEncoding.default, headers: nil).responseJSON { (response: DataResponse<Any>) in
            print(response)
        }

```
 @Dbigshooter that U00e6 you're getting is utf32 hex. You're gonna want to do some checks, and then get that converted over to the character you want. I wrote a function for you. Unless someone has a better way, this one works. Example:  

```
//say you get "//U00e6" from a GET request called  "response"

Alamofire.request(specificURL, method: .get, parameters: param, encoding: URLEncoding.default, headers: nil).responseJSON { (response: DataResponse<Any>) in
            let convertedHex = convertFromUnicode(myString: response)
            print(convertedHex) //this will print what you want :)
        }

//the function i wrote to convert unicode to string
func convertFromUnicode(myString:String) -> String {
    var myString = myString
    let convertDict:[String:String] = ["\\U00c0":"√Ä", "\\U00c1" :"√Å","\\U00c2":"√Ç","\\U00c3":"√É","\\U00c4":"√Ñ","\\U00c5":"√Ö","\\U00c6":"√Ü","\\U00c7":"√á","\\U00c8":"√à","\\U00c9":"√â","\\U00ca":"√ä","\\U00cb":"√ã","\\U00cc":"√å","\\U00cd":"√ç","\\U00ce":"√é","\\U00cf":"√è","\\U00d1":"√ë","\\U00d2":"√í","\\U00d3":"√ì","\\U00d4":"√î","\\U00d5":"√ï","\\U00d6":"√ñ","\\U00d8":"√ò","\\U00d9":"√ô","\\U00da":"√ö","\\U00db":"√õ","\\U00dc":"√ú","\\U00dd":"√ù","\\U00df":"√ü","\\U00e0":"√†","\\U00e1":"√°","\\U00e2":"√¢","\\U00e3":"√£","\\U00e4":"√§","\\U00e5":"√•","\\U00e6":"√¶","\\U00e7":"√ß","\\U00e8":"√®","\\U00e9":"√©","\\U00ea":"√™","\\U00eb":"√´","\\U00ec":"√¨","\\U00ed":"√≠","\\U00ee":"√Æ","\\U00ef":"√Ø","\\U00f0":"√∞","\\U00f1":"√±","\\U00f2":"√≤","\\U00f3":"√≥","\\U00f4":"√¥","\\U00f5":"√µ","\\U00f6":"√∂","\\U00f8":"√∏","\\U00f9":"√π","\\U00fa":"√∫","\\U00fb":"√ª","\\U00fc":"√º","\\U00fd":"√Ω","\\U00ff":"√ø"]

    for (key,value) in convertDict {
        myString = myString.replacingOccurrences(of: key, with: value)

    }
    return myString
}
```
 @Dbigshooter I take that back, with my function, if it's not unicode, it will just literally return the original string. So you can put anything thru that. I just have the respective strings for each unicode value in that dictionary if you couldn't tell. If you're getting just U00e6 instead of //U00e6 like some people do, then just swap all the backslashes out
  Hello - I have spent the whole weekend trying to sort out this problem. What I want to do is to convert the Parameter object into a Data object. The code I have at the moment is: 

`let url = URL(string: urlString)!`
`let urlRequest = URLRequest(url: url)`
`let encodedURLRequest = try JSONEncoding.default.encode(urlRequest, with: parameters)`  
`let data = encodedURLRequest.httpBody`

I want to use this data object in Alamofire.upload
 can use swiftyjson also
  Hi there!

Which version do I have to use if I want to compile my project with Alamofire on Swift 2.3?

Cheers!

Matthijs
 Use this:
pod 'Alamofire', '~> 3.5'
 I just used that, and enabled 'Use Legacy Swift Version' (set it to yes), but now when I try to run my project I get 275 errors?
  Alamofire 4.0.1 with Swift 3.0 
one more minor bug in the [Response Validation](https://github.com/Alamofire/Alamofire#manual-validation) section.

**Error**: Value of type 'DefaultDataResponse' has no member 'result'.

Looks like code section should be using responseData / responseJSON / other response handlers which provides access to the `result` member on `response` object like below:

```
Alamofire.request("https://httpbin.org/get")
    .validate(statusCode: 200..<300)
    .validate(contentType: ["application/json"])
    .responseData { response in
        switch response.result {
        case .success:
            print("Validation Successful")
        case .failure(let error):
            print(error)
        }
    }
```

<img width="1207" alt="screen shot 2016-09-25 at 12 20 17 am" src="https://cloud.githubusercontent.com/assets/8782776/18813675/db5751a0-82b6-11e6-94f7-9fc308cb7768.png">

Thanks!
  Hi guys im on the latest version of X code and followed the instructions here but I get a load of errors

does anyone know why this is happening?

this is my pod file, all installed fine no errors
# Uncomment this line to define a global platform for your project

 platform :ios, '9.0'

target 'PartyRockApp' do
  # Comment this line if you're not using Swift and don't want to use dynamic frameworks
  use_frameworks!

  # Pods for PartyRockApp
  pod 'Alamofire', '~> 4.0'

end
thanks

![screen shot 2016-09-25 at 08 08 29](https://cloud.githubusercontent.com/assets/1871219/18813590/4846eeac-82f7-11e6-88fa-fa0e2af82c75.png)
  I got very slow response. but for the same request, I got response right way in postman. maybe something I didn't set up right?

```
Timeline: { "Latency": 20.261 secs, "Request Duration": 20.262 secs, "Serialization Duration": 0.001 secs, "Total Duration": 20.263 secs }
```

Here is my requset

```
manager.request(Router.getAlbums())
            .validate(statusCode: 200..<300)
            .responseJSON { (response) in

                print(response.timeline)

                switch response.result {

                case .success(let json):

                    let albumsJSON = JSON(json)
                    print(json)
                    completion(albumsJSON.arrayValue)

                case .failure(let error):

                    print(error)                    
                    completion([])
                }
        }
```

Router is adopting  from URLRequestConvertible
  While learning Alamofire 4.0 with Swift 3.0 from the README samples, I encountered a minor bug in the [Response Handler](https://github.com/Alamofire/Alamofire#response-handler) section.

`Error: Use of unresolved identifier data`

Looks like code section should be 

```
if let data = response.data, let utf8Text = String(data: data, encoding: .utf8) {
                print("Data: \(utf8Text)")
            }
```

instead of 

```
if let data = data, let utf8Text = String(data: data, encoding: .utf8) {
                print("Data: \(utf8Text)")
            }
```

<img width="1232" alt="screen shot 2016-09-24 at 4 34 50 pm" src="https://cloud.githubusercontent.com/assets/8782776/18811892/e5bd9528-8275-11e6-9f44-73c2ba7422aa.png">

Thanks!
  In the earlier version of Alamofire, when the params had an empty list then it would still get sent as a parameter in the request and get received in the response. However with the new version of Alamofire for Swift 3.0, this is no longer the case. How are you looking to resolve this issue? 
 Ok, your comments just helped solve the issue. I was not specifying an encoding in my requests. I added JSON encoding default and it works fine now.
  Current Code is: 

let mutableURLRequest = NSMutableURLRequest(url: URL(string: urlString)!)
mutableURLRequest.httpMethod = HTTPMethod.post.rawValue
let encodedURLRequest = ParameterEncoding.JSON.encode(mutableURLRequest, parameters: parameters).0
let data = encodedURLRequest.HTTPBody!

Alamofire.upload(mutableURLRequest, data: data)...

The line ParameterEncoding.JSON.encode is failing when upgraded to Alamofire4 - please help - have been pulling my hair out for days.
  what's wrong with blow   imgae.   when I bulid program  
![image](https://cloud.githubusercontent.com/assets/20221361/18807344/f56b92da-8276-11e6-93c6-d4f48ed77425.png)
 OKÔºÅ Thank youÔºÅ
  ### I have installed the latest Alomofire by cocoaPods.
### But there is still an issue that is not compatible.
### Why?

> If I click the convert button , there will be thousands of mistakes with Alomofire. 

![snip20160924_22](https://cloud.githubusercontent.com/assets/19633979/18806371/2cb4c06e-825d-11e6-8196-280c28c4cb07.png)

![snip20160924_19](https://cloud.githubusercontent.com/assets/19633979/18806314/ab508932-825b-11e6-924f-8102a9bd04ce.png)

![snip20160924_21](https://cloud.githubusercontent.com/assets/19633979/18806315/ab527184-825b-11e6-854d-1006f46b96d7.png)
 Added Podfile last

```
post_install do |installer|
    installer.pods_project.targets.each do |target|
        target.build_configurations.each do |config|
            config.build_settings['SWIFT_VERSION'] = '3.0'
        end
    end
end
```

### frome #1526

### Problem has been solved
 I have tried using the command line to update CocoaPods to 1.1.0, but the updated version is still 1.0.1
 you need uninstall the CocoaPods 1.0.1
  ![f8f50a83-11e2-4891-9e41-8177b87af741](https://cloud.githubusercontent.com/assets/16027278/18806193/568d301c-8256-11e6-850d-b1d036ad2adb.png)
    Hi, I'm having some problems with Alamofire.upload() method. I'm trying to upload an image from my library photos in iphone simulator. When I send the image an error is received.

`"SUCCESS RESPONSE: FAILURE: responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.jsonSerializationFailed(Error Domain=NSCocoaErrorDomain Code=3840 \"Invalid value around character 0.\" UserInfo={NSDebugDescription=Invalid value around character 0.}))"`

This is my code to upload:

```
Alamofire.upload(
                    multipartFormData: { multipartFormData in

                        multipartFormData.append(imgData, withName: "image", mimeType: "image/jpg")
                        multipartFormData.append(keyData!, withName: "key")
                        multipartFormData.append(keyJSON!, withName: "format")


                    },
                    to: urlStr,
                    encodingCompletion: { encodingResult in

                        switch encodingResult {

                        case .success(let upload, _, _):
                            upload.responseJSON { response in

                                debugPrint("SUCCESS RESPONSE: \(response)")

                                if let info = response as? Dictionary<String, AnyObject> {

                                    if let links = info["links"] as! Dictionary<String, AnyObject>? {
                                        if let imgLink = links["image_link"] as? String {

                                            print("LINK: \(imgLink)")

                                        }
                                    }

                                }

                            }//upload.responseJSON


                        case .failure(let encodingError):
                            print("ERROR RESPONSE: \(encodingError)")

                        }//switch

                    }
                )
```
 The error is pretty clear. The response from server is not a valid JSON string. 
 My photo is not uploaded to server. But my data has updated.I get success too from response. Given code below-

```
 let params: Parameters = [
            "user_id": userArr.value(forKey: "user_id") as! String,
            "mobile": numberField.text! as String,
            "email":  "",
            "secret_key": userArr.value(forKey: "secret_key") as! String,
            "name" : nameField.text! as String
        ]

        let imageData = UIImageJPEGRepresentation(pickedImage, 0.8)
        Alamofire.upload(multipartFormData:{ multipartFormData in
            for (key, value) in params {
                multipartFormData.append((value as! String).data(using: .utf8)!, withName: key)
            }
               multipartFormData.append(imageData!, withName: "photo", mimeType: "image/jpg")
            
            },
                    usingThreshold:UInt64.init(),
                    to:UPDATE_PROFILE_API,
                    method:.post,
                    headers:nil,
                    encodingCompletion: { encodingResult in
                       switch encodingResult {
                        case .success(let upload, _, _):
                            upload.responseString(completionHandler: { response in
                                print("success", response.result.value)
                            })
                        case .failure(let encodingError):
                                print("en eroor :", encodingError)
                }
        })

 Why This issue is closed here ? I am too having the same problem and cannot get resolved. I am trying but no luck. If this issue is to be closed then please "Provide the solution" before closing !  I have exactly same error for GET Method.

Using Alamofire (4.4.0)

> FAILURE: responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.jsonSerializationFailed(Error Domain=NSCocoaErrorDomain Code=3840 "Invalid value around character 0." UserInfo={NSDebugDescription=Invalid value around character 0.})) Whenever I compile, it says success of 50 percent or failure of 50 percent, even if the received result is same. Seems the problem is in backend, I did try debugging for several days and finally got clue that my backend (php) server was the cause. If we removed compressing logic from backend then the server throws positive response and image gets uploaded. Hope this information will help some one here. This error is happening because of backend.
If you try responseJson you will get response as failure and if you try with responseString we will get the response. but the response string format won't be in right formatting. 
I was getting this error "A PHP Error was encountered".  compile error when drag source to project
 Just add one line
`import Foundation`
why failed? üò†
 reproduce step by step:
Just drag source code without `Alamofire.h` and `*.plist` into project, then build.
Thanks
  Regarding this issue - https://github.com/Alamofire/Alamofire/issues/1425
After server return 401, request calling second time and only after second call it stops. It behaves the same with previous Alamofire version.

After investigation I find that challenge.previousFailureCount still 0 after first 401 error. 
I try code suggected by @cnoon but it doesn't change anything, the code is:

```
let delegate = Alamofire.SessionManager.shared.delegate

delegate.taskDidReceiveChallengeWithCompletion = { session, task, challenge, completion in
    completion(.performDefaultHandling, nil)
}
```

Only this little fix suggested in this PR helps me. After first 401 error if credential is nil I cancel authentication challenge. If this is doesn't brake anything for you please apply this PR.

I call my request like this:

```
let aReq = Alamofire.request(myRequest)
aReq.responseJSON { response in
    //do something with response
}
```

Login and password inside myRequest parameters. If they wrong server return 401. I didn't store they in URLCredentialStorage and I didn't use .authenticate Alamofire closure(because my server require sending login and password in parameters). 

![screen shot 2016-09-23 at 10 22 22](https://cloud.githubusercontent.com/assets/8593066/18779183/2c8825e4-8178-11e6-8336-73683f149d9b.png)
  fixed typo / spelling error
  Hello,

I'm facing some problems with the migration, I don't know why I can't access JSONResponseSerializer with DataRequest, any help pls ?

![capture d ecran 2016-09-22 a 13 05 32](https://cloud.githubusercontent.com/assets/10846581/18746059/926bbe06-80c5-11e6-81c2-f88286b6c083.png)
 Thank you, it worked, sorry that I didn't saw that before posting.

Fixed.
  There is a noticably weird bug I have found in Alamofire.

This problem only occur when the screen is locked when the app is on the foreground

Steps to Reproduce
1. While App in the Foreground
2. Lock Phone
3. Unlock Phone
4. Trigger a request with Alamofire. <- This first request will always fail `Error Domain=NSURLErrorDomain Code=-1005 ‚ÄúThe network connection was > lost.`
5. Every single request after this will get a proper response. Unless if the phone is locked again while it is in the foreground.

Can anyone using Alamofire find a fix to this?

N.B.: This problem found on Alamofire 4.0. I have also tested this on Alamofire 2.0 and it also has the same problem.
 I see you posted #1586. It seems to be the same bug so I'd suggest closing #1586 and changing this one's title to something a bit less vague (like #1586)
 So thank you @cnoon for clarifying. I just checked your example to verify the problem. When I execute the request to httpbin on the simulator (iOS10) and device (iOS9) it works fine. But when I connect to my own server it won't work anymore on my device. So with that knowlegde I came by this [https://github.com/facebook/react-native/issues/7943](link). Seems to be an issue with nginx 1.10.1

I've checked my servers nginx version which is 1.10.0 assuming it has the same issue, I'm now trying to update my nginx package. Will keep you posted.
 My intuition says it has to do with the Keep-Alive setting. I think there was a bug in iOS 8 where the connection stayed open longer than the Keep Alive told it to (Don't know if it's still an issue). 

Do you cancel all open requests and then close all your connections when the app enters the background?
 Well the problem for me occurs when I start the app for the first time. So at that moment there are zero requests done, until the request get triggered by UI which results in a failure. So I don't think that has something to do with it.
 Take a look at Issue #872. 

https://github.com/Alamofire/Alamofire/issues/872
 OK. Sounds like the similar thing indeed. The only 'strange' thing is, when my first request is a GET request it works like a charm the first time, it only fails consistently the first time when it's a POST request.
 Bump. Somebody found a solution or workaround already?
 @NielsKoole  Initialize your Network Manager class again, in applicationWillEnterForeground and it will solve the problem. The reason for this issue is, when you lock your device , the OS locks the sockets and doesn't release them when the phone is unlocked. So please again initialize your network manager class and it will solve your problem. Reference : https://github.com/Alamofire/Alamofire/issues/872  Hey. Migrating to Alamofire 4 and I am trying to initialize a session manager like so:

```
let configuration = URLSessionConfiguration.default
configuration.timeoutIntervalForRequest = 20
configuration.httpAdditionalHeaders = ["MyCompany-User-Agent": Config.MyCompanyUserAgentDataString]
var alamoManager: SessionManager = Alamofire.SessionManager(configuration: configuration)
```

However I keep getting the error _"Cannot invoke SessionManager with an argument list of type(configuration: URLSessionConfiguration)"_. I am following the syntax at https://github.com/Alamofire/Alamofire#modifying-the-session-configuration but mine has errors. What am I doing wrong here? Also I can't do a request from the `SessionManager`. For example:

```
Alamofire.request(url, method: .get, parameters: parameters, encoding: JSONEncoding.default).responseObject { (response: DataResponse<MyCustomResponse>) in
            if let result = response.result.value {} }
```

Works with no issues, BUT (where alamoManager is a SessionManager):

```
alamoManager.request(url, method: .get, parameters: parameters, encoding: JSONEncoding.default).responseObject { (response: DataResponse<MyCustomResponse>) in
            if let result = response.result.value {} }
```

doesn't work. I get the error _"Value of type SessionManager has no member request"_. Very confused as to why I am getting that error. The docs clearly show an example of a SessionManager object using a request method. Could you please point me in the right direction for this? Thanks

**NOTE:** I have noticed that the above works if I create a fresh project. No issues at all. But in my existing project I am getting these errors. What on earth is going wrong? Pease help! üç™ 
 Oddly enough the methods above work if I create a brand new project. But why am I getting errors in an existing project? iOS Deployment target is set to iOS 9.0 in project info. Also set Deployment target to 9.0 under build settings in each individual target. 
 I am getting an error after install alamofire on xcode 8 with swift 3
I updated CocoaPods 1.1.0.rc.2 for Xcode 8: gem update cocoapods --pre
Then also its giving number of errors and asking me to update pods for swift 3 
please resolve
 If you try to make the session manager global I see the same error. New project using Swift 3 and latest alamofire version. If you specify it each time in your calls, it won't show the error. Looks like a bug to me. I don't believe this is just a support issue. If you attempt to use anything but the "default" SessionManager (i.e. try initialising a SessionManager with your own URLSession & Delegate) then a nil value is returned.  I have facing some question after I update my Xcode and Alamofire.

Previously I use Alamofire like this
![screen shot 2016-09-22 at 11 29 04 am](https://cloud.githubusercontent.com/assets/19340910/18736288/268e5f7a-80b8-11e6-8e8c-2d69f2e5b5f4.png)

But somehow after I update I show me extra argument in call.

How can I solve this problem?

Thanks
 Please check new API,
it's should be instead
Alamofire.request(url: URLConvertible method: HTTPMethod, parameters: Parameters?, encoding: ParameterEncoding, headers: HTTPHeaders?)
 I've encountered the same issue after migrating to **Swift3** / Xcode 8.

Following the new API, it gave some results...

> `Alamofire.request("https://httpbin.org/post", method: .post, parameters: parameters, encoding: JSONEncoding(options: []))
> `

You can see at the end the request that worked... but it doesn't apply everywhere.
Almost the same request works in a place but in another doesn't:
**DOESN'T WORK in this case**: // _giving extra argument **method** in call_
`
        Alamofire
            .request(strURL,
                     method: .post,
                     parameters: params,
                     encoding: ParameterEncoding.JSON,
                     headers: headers)
            .responseJSON { (responseObject) -> Void in ... 
`
How should I send headers in this call?

On the other hand, this request **works**:
`Alamofire.request(myUrl, method: .post, parameters: [
            "check_login": 2,
            "ios_userlogin":user,
            "ios_userpassword":password
            ]).responseJSON { response in ...`

Now, what I see ... it doesn't support both **method** and **headers** params in same call ... can anyone give me a suggestion regarding how to pass the method through **params** or **headers** and avoid this annoying compiler error? Or is there something I'm doing wrong?

_To avoid the step where you're interested in the context, here's the wrapper class that uses the code that doesn't work:_
`class func requestPOSTURL(_ strURL : String, params : [String : AnyObject]?, headers : [String : String]?, success:@escaping (JSON) -> Void, failure:@escaping (NSError) -> Void){
        Alamofire
            .request(strURL,
                     method: .post,
                     parameters: params,
                     encoding: ParameterEncoding.JSON,
                     headers: headers)
            .responseJSON { (responseObject) -> Void in
                if responseObject.result.isSuccess {
                    let resJson = JSON(responseObject.result.value!)
                    success(resJson)
                }
                if responseObject.result.isFailure {
                    let error : NSError = responseObject.result.error!
                    failure(error)
                }
        }
    }`
 @grngc I also curious what should put in headers.

So the way to write is like this?

> Alamofire.request(myUrl, method: .post, parameters: [ "check_login": 2, "ios_userlogin":user, "ios_userpassword":password ]).responseJSON { response in ...}
    Why not support iOS9 Alamofire
 „ÄÇsorry Alamofire4.0.0 in iOS8
  He said yes it supports Swift 3.0?
I used Xcode8 create a new project, and then use Cocoapod add AL, how to compile without success, I set the AL User Legacy Swift Language Version = NO, but it still has been given:
ld: /Users/dudu1/Library/Developer/Xcode/DerivedData/AIOwnerSwift-fyeaigfkddahqlayqfugrezxgtfc/Build/Products/Debug-iphonesimulator/Alamofire.framework/Alamofire compiled with newer version of Swift language (3.0) than previous files (2.0) for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
How can I do? This error can be eliminated.
 I user AL 4.0
 Which CocoaPods version do you use? `pod --version`
CocoaPods 1.**1**.0+ is required (and not 1.0.**1**), currently in pre-release, installed with `sudo gem update cocoapods --pre`
 Clearing derived data did the trick for me. I also made sure I was on cocoa pods 1.1 
  I am using Alamofire for requesting data from my server. It works great 

But if I turn off the screen/lock the phone while my app in foreground and then unlock the phone. The first request will always fail.

Any thought on why is this happening? I am using Alamofire 2.0
 I have the same issue, cannot find why this is happening.

FWIW, the is the response object the first time:
`[Request]: <NSMutableURLRequest: 0x15f594a70> { URL: https://xxxxx/1/register }

[Data]: 0 bytes
[Result]: FAILURE: Error Domain=NSURLErrorDomain Code=-1004 "Geen verbinding met de server mogelijk." UserInfo={NSUnderlyingError=0x161127d10 {Error Domain=kCFErrorDomainCFNetwork Code=-1004 "(null)" UserInfo={NSErrorPeerAddressKey=<CFData 0x15f6e1d50 [0x1a08a8150]>{length = 16, capacity = 16, bytes = 0x100201bb80c7276a0000000000000000}, _kCFStreamErrorCodeKey=-2200, _kCFStreamErrorDomainKey=4}}, NSErrorFailingURLStringKey=https://xxxxx/1/register, NSErrorFailingURLKey=https://xxxxx/1/register, _kCFStreamErrorDomainKey=4, _kCFStreamErrorCodeKey=-2200, NSLocalizedDescription=Geen verbinding met de server mogelijk.}
[Timeline]: Timeline: { "Request Start Time": 496338624.807, "Initial Response Time": 496338624.901, "Request Completed Time": 496338624.901, "Serialization Completed Time": 496338624.901, "Latency": 0.094 secs, "Request Duration": 0.094 secs, "Serialization Duration": 0.000 secs, "Total Duration": 0.094 secs }
  ‚ñø request : Optional<NSURLRequest>
    - Some : <NSMutableURLRequest: 0x15f594a70> { URL: https://xxxxx/1/register }
- response : nil
  ‚ñø data : Optional<NSData>

```
- Some : <>
```

  ‚ñø result : FAILURE: Error Domain=NSURLErrorDomain Code=-1004 "Geen verbinding met de server mogelijk." UserInfo={NSUnderlyingError=0x161127d10 {Error Domain=kCFErrorDomainCFNetwork Code=-1004 "(null)" UserInfo={NSErrorPeerAddressKey=<CFData 0x15f6e1d50 [0x1a08a8150]>{length = 16, capacity = 16, bytes = 0x100201bb80c7276a0000000000000000}, _kCFStreamErrorCodeKey=-2200, _kCFStreamErrorDomainKey=4}}, NSErrorFailingURLStringKey=https://xxxxx/1/register, NSErrorFailingURLKey=https://xxxxx/1/register, _kCFStreamErrorDomainKey=4, _kCFStreamErrorCodeKey=-2200, NSLocalizedDescription=Geen verbinding met de server mogelijk.}
  ‚ñø timeline : Timeline: { "Request Start Time": 496338624.807, "Initial Response Time": 496338624.901, "Request Completed Time": 496338624.901, "Serialization Completed Time": 496338624.901, "Latency": 0.094 secs, "Request Duration": 0.094 secs, "Serialization Duration": 0.000 secs, "Total Duration": 0.094 secs }
    - requestStartTime : 496338624.80719
    - initialResponseTime : 496338624.90076298
    - requestCompletedTime : 496338624.90076298
    - serializationCompletedTime : 496338624.90092599
    - latency : 0.09357297420501709
    - requestDuration : 0.09357297420501709
    - serializationDuration : 0.00016301870346069336
    - totalDuration : 0.093735992908477783 { ... }`
  "CocoaPods 1.1.0+ is required to build Alamofire 4.0.0+."
 No it's no joke : CocoaPods 1.0.1 has been released before Xcode 8, Swift 3, iOS 10, etc. CocoaPods 1.1.0 is currently at Release Candidate 2 and is **required** because else your project will _not_ compile. Install using `sudo gem update cocoapods --pre`
  Hi there,

I'm having a hard time migrating, how would this look with the new syntax? I get a JSON response, and using it with AlamofireJSONToObjects.

```
`Alamofire.request(.GET, apiURL + "users", headers: headers).responseObject { (response: Result<User, NSError>) in
                if let user = response.value {
                    print(user)`
```
 1. Read the [Migration Guide](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%204.0%20Migration%20Guide.md), it's a real page-turner
2. Replace `.GET` with `.get` because that's usually the one that gives you misleading errors
  I'm trying to figure out how to use the SPM and struggling. I understand it's still very early days for it but it appears Alamofire is trying to support it as well so I had a couple issues:

If I try to pull down the master branch and run "swift build" I get:

```
error: the module at Tests/Resources has an invalid name ('Resources'): the name of a test module has no ‚ÄòTests‚Äô suffix
fix: rename the module at ‚ÄòTests/Resources‚Äô to have a ‚ÄòTests‚Äô suffix
```

To get around that for now I just added Tests/Resources to the "exclude" tag in the Package.swift file. When I do that and try "swift build" again I get a lot of error messages similar to:

```
/Alamofire/Source/SessionDelegate.swift:120:70: error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer
    open var streamTaskDidBecomeInputAndOutputStreams: ((URLSession, URLSessionStreamTask, InputStream, OutputStream) -> Void)?
```

I'm thinking when I run "swift build" it's trying to build for all platforms which maybe why I'm seeing these? Everything compiles just fine if I just pull up the original Xcode project. I'm thinking I need to figure out how to define targets in the Package.swift file and regenerate the Xcode project... Anyone else have any experience with this?
 Yes. The Package Manager integration is broken. Also see #1544 that was closed prematurely for some reason.
  In `POST` when I pass an empty `String` in parameters for example:`["Term" :    ]`, I get an error that value is `null`. How to pass an empty string `"   "` properly? 
@mk 
@robrasmussen 
@mattt 
@technomage 
@mthole 
Thanks!
  Is anyone else having any problems on devices with iOS 10? Everyone on my team downloaded the app via the app store onto their iOS 10 devices and none of the networking calls are going through (can't pull or send any data). Everything is working perfectly fine on the simulator running iOS 9.
 i have the same issue. only few network calls are responded.
 @muzammilpeer Check the logic in your app. The headers we were using were stored locally using Keychain-Swift, and apparently they were removed after installing iOS 10. I am not getting any more errors now after logging in again.
  Ater pod update I have this:

[!] /usr/local/bin/git clone https://github.com/Alamofire/Alamofire.git /var/folders/cx/y7x6j6cj2h588krpgxb36jsh0000gn/T/d20160920-4474-1eylyse --template= --single-branch --depth 1 --branch swift3

Cloning into '/var/folders/cx/y7x6j6cj2h588krpgxb36jsh0000gn/T/d20160920-4474-1eylyse'...
warning: Could not find remote branch swift3 to clone.
fatal: Remote branch swift3 not found in upstream origin

from pod:
pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'swift3'
....

post_install do |installer|
    installer.pods_project.targets.each do |target|
        target.build_configurations.each do |config|
            config.build_settings['SWIFT_VERSION'] = '3.0'
        end
    end
end
 why not manually go to pod directory and git clone it 

http://open-source-customization.com/question/pod-install-unable-to-setting-up-cocoapods/57
 if `'~>4.0'` doesn't work , try to use this and check

  ```
pod 'Alamofire',
    :git => 'https://github.com/Alamofire/Alamofire.git',
    :branch => 'master'
```
   @hemanthpeela09 Looks like you should run `pod repo update` for fetching new podspecs. :branch => 'master' worked for me :branch => 'master' worked for me  i updated xcode to 8 and its force me to do covert code in to current syntax with this message. 

> ‚ÄúUse Legacy Swift Language Version‚Äù (SWIFT_VERSION) is required to be configured correctly for targets which use Swift. Use the [Edit > Convert > To Current Swift Syntax‚Ä¶] menu to choose a Swift version or use the Build Settings editor to configure the build setting directly.

any have idea about that?
![screen shot 2016-09-20 at 1 45 27 pm](https://cloud.githubusercontent.com/assets/9278751/18662678/032b829a-7f39-11e6-879f-2e242c5d3eb0.png)
 to resolve your problem set Pods>Alamofire>Use Legacy ... to No (look at the screenshot)
<img width="1184" alt="capture d ecran 2016-09-20 a 15 05 20" src="https://cloud.githubusercontent.com/assets/14089551/18671274/ca063c02-7f43-11e6-9419-a03d42aa5ed4.png">

but after this i have lot of issues, so if someone know how to resolve these please tell me
<img width="311" alt="capture d ecran 2016-09-20 a 15 09 42" src="https://cloud.githubusercontent.com/assets/14089551/18671424/4ee4585a-7f44-11e6-969a-3388475ee715.png">
 same problem here, and the solution on #1526 does not work. 
 Same problem for me too. After changing it to NO getting Plethora of errors. any solution guys???
 solution #1526 not working
 same error. I tried to force a specific version of the pod, but still the same. üò¢
 Looks like you are using a older release. You must use
- 3.5.0 for Swift 2.3
- 4.0.0 for Swift 3.0

and also CocoaPods 1.1.0.rc.2 for Xcode 8: `gem update cocoapods --pre`.
 Same error.I need use Alamofire in swift2.3&Xcode8.0. But have not found any solution
 Hi @cnoon I am using  CocoaPods 1.1.0.rc.2 with Xcode 8 but still when I compile my project got above errors. I think solution should work for all. What do you suggest?

thanks
  Hello,

I'm trying to update my project with the 4.0 version.
But got one issue with the upload. Even if I copy/past the upload multipart form form the README, I got this error :

<img width="890" alt="capture d ecran 2016-09-20 a 09 23 55" src="https://cloud.githubusercontent.com/assets/21126201/18661033/0b019c54-7f14-11e6-831d-7cd5e23b7930.png">

With the old version I used this for upload image to my backend service : 

```
            Alamofire.upload(multipartFormData: { multipartFormData in
                multipartFormData.appendBodyPart(data: imgData, name: "file", fileName: "image", mimeType: "image/jpeg")
                },
                             to: url, encodingCompletion: { (encodingResult) in
//
            })
```

Have you any solution to do it with Alamofire 4.0 ?

Thank you
 I'm also getting this issue as well as many other "ambiguous without more context" errors. My feeling is that the fact that Alamofire doesn't use named first parameters but overloads them with multiple types AND the fact that many functions have default values is confusing the Swift 3 parser.
 The documentation/readme at this point is very unreliable.  It must match the method definitions exactly as provided by the library, so I would refer to the source code of the request/upload functions instead of the readme.

I got mine to work by letting XCode autocomplete what parameters I would need and fill those in.

In your specific example, don't state the `data:` part  and `name` is renamed to `withName`.  So `multipartFormData.append(imgData, withName: "file", fileName: "image", mimeType: "image/jpeg")`
 I had the same issue guys, here's how I solved it! Go down to the accepted answer

http://stackoverflow.com/questions/39592085/swift-3-alamofire-multipart-upload/39593545
 Hey i am using Alamofire 4.0 image uploading is done successfully with the following code but i am unable to send parameters with image. Please help me.

let imageData = UIImagePNGRepresentation(self.signatureImgView.image!)

let defaultHTTPHeaders: HTTPHeaders = [
"token": "F3pObDt2G832hfAaBhZDHekNHUhT62URXPApKkfPQBb9enSy",
"Accept": "application/json",
]

let URL2 = try! URLRequest(url: "http://52.66..........", method: .post, headers: defaultHTTPHeaders)

Alamofire.upload(multipartFormData: { (multipartFormData) in

multipartFormData.append(imageData!, withName: "signImg", fileName: "picture.png", mimeType: "image/png")

// for (key, value) in self.parameters {
// multipartFormData.append(value.data(using: String.Encoding.utf8)!, withName: key)
// }
}, with: URL2, encodingCompletion: { (result) in

switch result {
case .success(let upload, _, _):

upload.responseJSON
{
response in

print(response.request) // original URL request
print(response.response) // URL response
print(response.data) // server data
print(response.result) // result of response serialization

if let JSON = response.result.value
{
print("JSON: (JSON)")
}
}

case .failure(let encodingError):
print(encodingError)

}

})
}

i have tried this
let parameters: [String: AnyObject] =
                    [
                        "email":"abc@gmail.com" as AnyObject
                     ]

for (key, value) in parameters
{
        multipartFormData.append(value.data(using: "email".Encoding.utf8)!, withName: "abc@gmail.com")
} 
but it's not working!!! Please help me.
 `func upload(_ url:String, parameters: [String:Data], callback:@escaping (Bool, JSON?,JSON?) -> Void){
        
        let URL2 = try! URLRequest(url: mainUrl+"user/upload_profile", method: .post, headers: head)
        
        Alamofire.upload(multipartFormData: { (multipartFormData) in
            for (key, value) in parameters {
                multipartFormData.append(value, withName: key, fileName: "picture.png", mimeType: "image/png")
            }
            
        }, with: URL2, encodingCompletion: { (result) in
            
            switch result {
            case .success(let upload, _, _):
                
                upload.responseJSON{
                    response in
                    if let data = response.result.value{
                        DispatchQueue.main.async {
                            if(response.response?.statusCode == 200){
                                callback(true, JSON(data), JSON((response.response?.statusCode)!))
                            } else{
                                callback(false, JSON(data), JSON((response.response?.statusCode)!))
                            }
                        }
                    }
                    
                }
                
            case .failure(let encodingError):
                print(encodingError)
                DispatchQueue.main.async {
                    callback(false,JSON(self.getStatusCodeString(408)),JSON(408))
                }
                
            }
            
        })
    }`
**Usage**
`  let parameters:[String:Data] = [
            "image" : UIImagePNGRepresentation(imageProfile)!
        ]
        Http.upload("api/user/upload_profile", parameters: parameters) { (success, json, header) -> Void in
            if success {
                print(json!)
            }else{
                print(json!)
            }
        }`
 Thanks!  i have solved the problem. your code is very optimised & good.
Once agin thanks for sharing.


*Purvi Jani*
iOS Application Developer
Phone: +919998009783 | Skype: purvi.pardypanda

*Pardy Panda Studios*
LinkedIn <http://linkedin.com/company/pardy-panda-studios> | Facebook
<http://facebook.com/pardypandastudios> | Twitter
<http://twitter.com/pardypanda> | Youtube <http://youtube.com/pardypanda>

On Fri, Jan 13, 2017 at 10:00 AM, Mengheang Rat <notifications@github.com>
wrote:

> `func upload(_ url:String, parameters: [String:Data], callback:@escaping
> <https://github.com/escaping> (Bool, JSON?,JSON?) -> Void){
>
>     let URL2 = try! URLRequest(url: mainUrl+"user/upload_profile", method: .post, headers: head)
>
>     Alamofire.upload(multipartFormData: { (multipartFormData) in
>         for (key, value) in parameters {
>             multipartFormData.append(value, withName: key, fileName: "picture.png", mimeType: "image/png")
>         }
>
>     }, with: URL2, encodingCompletion: { (result) in
>
>         switch result {
>         case .success(let upload, _, _):
>
>             upload.responseJSON{
>                 response in
>                 if let data = response.result.value{
>                     DispatchQueue.main.async {
>                         if(response.response?.statusCode == 200){
>                             callback(true, JSON(data), JSON((response.response?.statusCode)!))
>                         } else{
>                             callback(false, JSON(data), JSON((response.response?.statusCode)!))
>                         }
>                     }
>                 }
>
>             }
>
>         case .failure(let encodingError):
>             print(encodingError)
>             DispatchQueue.main.async {
>                 callback(false,JSON(self.getStatusCodeString(408)),JSON(408))
>             }
>
>         }
>
>     })
> }`
>
> *Usage*
> let parameters:[String:Data] = [ "image" : UIImagePNGRepresentation(imageProfile)!
> ] Http.upload("api/user/upload_profile", parameters: parameters) {
> (success, json, header) -> Void in if success { print(json!) }else{
> print(json!) } }
>
> ‚Äî
> You are receiving this because you commented.
> Reply to this email directly, view it on GitHub
> <https://github.com/Alamofire/Alamofire/issues/1575#issuecomment-272358539>,
> or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AVm5JbIv757lFDeuTIwQNDqVD_UAhKCKks5rRv3pgaJpZM4KBTTP>
> .
>

-- 
This email and any files transmitted with it are confidential and intended 
solely for the use of the individual or entity to whom they are addressed. Any 
views or opinions expressed are solely those of the sender and do not 
necessarily represent those of Pardy Panda Studios. If you have received 
this email in error please notify the sender.
   Swift 3 is compatible with iOS 8 and newer.

So the same question here, why did limit to the minimum iOS Platform 9? 

Or some way to work around when use iOS 8 with Alamofire 4.0. Thanks.
 #1367  look this
 Same question . Consider whether or not to change a library...drive me mad...
 @cnoon It looks not tasteful, we cannot drop iOS 8 users. Is there any chance to support iOS 8 with Alamofire 4.0+? We have to support iOS 8+, and we need Swift 3+.
 Similar issue here. I want Swift 3.0, but then I have to drop macOS 10.10 support. It's really a hard decision.

I am currently investigating alternatives
 I want both Swift3 and iOS8 too„ÄÇwhere
is my way?
 Similar situation here, temporarily forked Alamofire to support iOS 8 until we drop it. You can find it here: https://github.com/rebe1one/Alamofire

Given that all the iOS 9+ functionality I see being used is streaming, I am wondering why you guys didn't just mark them available for 9+ only. It doesn't seem like much to support.
  When I run pod update:

> [!] The `*** [Debug]` target overrides the `ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES` build setting defined in `Pods/Target Support Files/Pods-bootmark/Pods-bootmark.debug.xcconfig'. This can lead to problems with the CocoaPods installation
>     - Use the`$(inherited)` flag, or
>     - Remove the build settings from the target.
> 
> [!] The `*** [Release]` target overrides the `ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES` build setting defined in `Pods/Target Support Files/Pods-bootmark/Pods-bootmark.release.xcconfig'. This can lead to problems with the CocoaPods installation
>     - Use the`$(inherited)` flag, or
>     - Remove the build settings from the target.

I am using cocoapods 1.1.0.rc.2 with a deployment target of 10.0. I am also using alamofire 4.0. Any suggestions?

These people are also experiencing the same issue so far:
@GZaccaroni @jonybur @SMR @realmike33 @msilva

I thought I would make this it's own issue since no one seemed to be getting back to the closed issue (which totally makes sense). SEE ISSUE: #1531
 @GZaccaroni @jonybur @SMR @realmike33 @msilva @PlayApple

Alright guys not the cleanest solution to the problem, but here is how I fixed it. Turns out this isn't really an Alamofire issue and shouldn't be on here specifically. Basically I went into the build settings and just cleared all the settings to default. So anything that was bold coloured, I selected and then I pushed delete. This is what worked for me.

![screen shot 2016-09-19 at 7 53 54 pm](https://cloud.githubusercontent.com/assets/10747839/18655201/080afd8a-7ea4-11e6-922d-eb290bed7d04.png)
 Thanks for posting this - It really needs to go in the Cocoapods Readme. 
 Pleae check issue <a href="https://github.com/CocoaPods/CocoaPods/issues/5981">#5981</a> and follow the steps posted by johnantoni on 9 Jan 2017. It worked for my project with cocoapod dependencies. Xcode Version 8.1 @jshier I'm still seeing this bug.  Im currently on cocoapods 1.2.1, any ideas?  It shows 
`
dyld: Library not loaded: @rpath/Alamofire.framework/Alamofire
Referenced from: /private/var/containers/Bundle/Application/DDF7C0FB-382F-4B5C-9A98-E5482AA10230/Giphy.app/PlugIns/MessagesExtension.appex/MessagesExtension
Reason: image not found
`
...
I set the Podfile with 
`
platform :ios, '10.0'
target 'MessagesExtension' do
use_frameworks!
pod 'Alamofire', '~> 4.0.0'
end    
`
Any suggest? 
  I'm a mistake to use the alamofire in xcode 8.0 with 3.0 swift .
I tried many ways to work , updated in the pod lib alamofire to 4.0 the last came out with swift supports 3.0 and I'm in trouble .
Problem is in the picture below , if someone can help me with this problem thanks
![erro alamofire](https://cloud.githubusercontent.com/assets/15039214/18648186/e1aa0618-7e8f-11e6-9c34-731476ba1722.jpg)
 I believe this is solved by updating the Cocoapods correctly, referring back to the Documentation, it states.

CocoaPods 1.1.0+ is required to build Alamofire 4.0.0+.

The current gem install cocoapods doesn't install 1.1.0+, you need to do gem install cocoapods --pre to install the beta version which is in 1.1.0+
 Can ALF4.0 been used on platform ios8?
 This is a bigger problem than updating cocoapods, since I'm using carthage (which is resolving to 4.0.0) and I'm receiving the same exact error.

It probably has to do with `@escaping` being used, although not sure what that does to the scope that causes the compiler to get confused.
 <img width="798" alt="screen shot 2016-09-20 at 12 25 34 pm" src="https://cloud.githubusercontent.com/assets/17274199/18661077/73e43f7e-7f2d-11e6-9231-b08ea6b24225.png">
 I'm receiving the same exact error
 Ok folks, so turns out that this is a super misleading error from the compiler that causes you to focus on the wrong area when troubleshooting. The source of the problem lies when the closure parameters are either incorrect or being misused (which will be common for old code since there's many signature changes from 3.0 -> 4.0). For instance, take the following code:

```
        Alamofire.upload(fileData, to: uploadUrl, method: .put)
            .uploadProgress { progress in
                // print("Upload Progress: \(progress.fractionCompleted)")
                // callback([Int(totalBytesExpectedToWrite/totalBytesWritten) as AnyObject])
            }
            .response { response in
                print(response.statusCode)
        }
```

This will give the infamous error:

![image](https://cloud.githubusercontent.com/assets/29085/18661825/7d56bd9a-7ecc-11e6-9599-f97f79b2f474.png)

The problem here is that the response _parameter_ does not actually have a statusCode. Instead, the location of that property is at `response.response?.statusCode`, so the correct code that compiles is:

```
        Alamofire.upload(fileData, to: uploadUrl, method: .put)
            .uploadProgress { progress in
                // print("Upload Progress: \(progress.fractionCompleted)")
                // callback([Int(totalBytesExpectedToWrite/totalBytesWritten) as AnyObject])
            }
            .response { response in
                print(response.response?.statusCode)
        }
```

I'm sure this will manifest quite differently in various use cases across the 4.0 api in swift 3, but hopefully this gives a better clue than the compiler where to look.
 I've commented my code but still getting error
 Any solution with tis? I m facing it too
 Same error there, any news ?
 I am getting this error too
  Use Legacy Swift Language Version‚Äù (SWIFT_VERSION) is required to be configured correctly for targets which use Swift. Use the [Edit > Convert > To Current Swift Syntax‚Ä¶] menu to choose a Swift version or use the Build Settings editor to configure the build setting directly
 hi mengheangrat

it is a duplicated issue. you can find the correct answer and solution there: https://github.com/Alamofire/Alamofire/issues/1526

Cheers, 
Daniel
 Thanks you @leinadoknilik 
  There is a Result project which ReactiveCocoa uses:
https://github.com/antitypical/Result

Existing Result class conflicts with RAC one making it hard to use both libraries at the same time.
  Hi,
Like many other developers using Alamofire for our networking needs i'm limited by me customer on iOS target support.

Despite Apple's recommendation of supporting the current & previous iOS version my customer requires my to support iOS 8 as well for the foreseeable future.

Please make Alamofire 3.X legacy branch available for us poor developers that are restricted from moving to newer tech by business needs
 Joining your request as well.
 I also have app that has to support iOS 8. 
 Is is possible to use Alamofire Swift 3 on iOS 8 apps? 
  Hey there,

I need to do multiple requests asynchronously at the same time, but it crashes sometimes. Is there any way to prevent this? For example the method do get profile pictures of people and set them in an imageview is bellow. Multiple instances of this should be able to run at the same time.

```
func GetActualImageUrl(imageView: UIImageView, requestUrl: String){

    Alamofire.request(.GET, requestUrl).response { response in
        let fixedString = String(data: response.2!, encoding: NSUTF8StringEncoding)
        let imageUrl = MyConstants.WEBURL_NO_SLASH + fixedString!
        imageView.kf_setImageWithURL(NSURL(string: imageUrl)!)
    }
}
```
 Thanks for the quick reply, I will provide all the info you might need now:

Alamofire version: 3.4.1
Xcode version: 7.3.1
iOS version: 9.2.1 (Deployment Target)

Crash Log:

```
2016-09-19 10:34:46.640 MyProjectName[11126:61287] Attempted to create a task in a session that has been invalidated
2016-09-19 10:34:46.691 MyProjectName[11126:61287] *** Terminating app due to uncaught exception 'NSGenericException', reason: 'Task created in a session that has been invalidated'
*** First throw call stack:
(
    0   CoreFoundation                      0x000000010ade7d85 __exceptionPreprocess + 165
    1   libobjc.A.dylib                     0x000000010f4eddeb objc_exception_throw + 48
    2   CFNetwork                           0x000000010c8e98ed -[__NSURLSessionLocal taskForClass:request:uploadFile:bodyData:completion:] + 386
    3   CFNetwork                           0x000000010c8ea960 -[__NSURLSessionLocal dataTaskForRequest:completion:] + 77
    4   Alamofire                           0x000000010a6318fb _TFFC9Alamofire7Manager7requestFPS_21URLRequestConvertible_CS_7RequestU_FT_T_ + 187
    5   Alamofire                           0x000000010a61d4c7 _TTRXFo__dT__XFdCb__dT__ + 39
    6   libdispatch.dylib                   0x000000010ffcd3eb _dispatch_client_callout + 8
    7   libdispatch.dylib                   0x000000010ffb1ef5 _dispatch_barrier_sync_f_invoke + 393
    8   Alamofire                           0x000000010a620f78 _TFC9Alamofire7Manager7requestfPS_21URLRequestConvertible_CS_7Request + 520
    9   Alamofire                           0x000000010a620bcf _TFC9Alamofire7Manager7requestfTOS_6MethodPS_20URLStringConvertible_10parametersGSqGVs10DictionarySSPs9AnyObject___8encodingOS_17ParameterEncoding7headersGSqGS3_SSSS___CS_7Request + 735
    10  Alamofire                           0x000000010a61823b _TF9Alamofire7requestFTOS_6MethodPS_20URLStringConvertible_10parametersGSqGVs10DictionarySSPs9AnyObject___8encodingOS_17ParameterEncoding7headersGSqGS2_SSSS___CS_7Request + 603
    11  MyProjectName                          0x0000000109be0d62 _TF10MyProjectName17GetActualImageUrlFTCSo11UIImageView10requestUrlSS_T_ + 1346
    12  MyProjectName                          0x0000000109be07ee _TF10MyProjectName22MakeUserProfilePictureFTCSo11UIImageView6userIdSS15withPlaceHolderSb8intervalOS_21TimeStampTimeInterval_T_ + 334
    13  MyProjectName                          0x0000000109c5b91e _TZFC10MyProjectName6Inputs7Input15fTV10SwiftyJSON4JSON6parentCSo6UIView12isRepeatableSb19isBackgroundColoredSb_S3_ + 6238
    14  MyProjectName                          0x0000000109c873c2 _TZFC10MyProjectName6Inputs7Input20fTV10SwiftyJSON4JSON6parentCSo6UIView12isRepeatableSb7inputIdSS_CS_13MyInput20View + 9794
    15  MyProjectName                          0x0000000109aee573 _TFC10MyProjectName23FeedTableViewController9tableViewfTCSo11UITableView21cellForRowAtIndexPathCSo11NSIndexPath_CSo15UITableViewCell + 138307
    16  MyProjectName                          0x0000000109af0caf _TToFC10MyProjectName23FeedTableViewController9tableViewfTCSo11UITableView21cellForRowAtIndexPathCSo11NSIndexPath_CSo15UITableViewCell + 79
    17  UIKit                               0x000000010da994f4 -[UITableView _createPreparedCellForGlobalRow:withIndexPath:willDisplay:] + 766
    18  UIKit                               0x000000010da9962c -[UITableView _createPreparedCellForGlobalRow:willDisplay:] + 74
    19  UIKit                               0x000000010da6dd4f -[UITableView _updateVisibleCellsNow:isRecursive:] + 2996
    20  UIKit                               0x000000010daa2686 -[UITableView _performWithCachedTraitCollection:] + 92
    21  UIKit                               0x000000010da89344 -[UITableView layoutSubviews] + 224
    22  UIKit                               0x000000010d9f6980 -[UIView(CALayerDelegate) layoutSublayersOfLayer:] + 703
    23  QuartzCore                          0x000000010d6d9c00 -[CALayer layoutSublayers] + 146
    24  QuartzCore                          0x000000010d6ce08e _ZN2CA5Layer16layout_if_neededEPNS_11TransactionE + 366
    25  QuartzCore                          0x000000010d6cdf0c _ZN2CA5Layer28layout_and_display_if_neededEPNS_11TransactionE + 24
    26  QuartzCore                          0x000000010d6c23c9 _ZN2CA7Context18commit_transactionEPNS_11TransactionE + 277
    27  QuartzCore                          0x000000010d6f0086 _ZN2CA11Transaction6commitEv + 486
    28  QuartzCore                          0x000000010d6feb5c _ZN2CA7Display11DisplayLink14dispatch_itemsEyyy + 576
    29  CoreFoundation                      0x000000010ad41074 __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__ + 20
    30  CoreFoundation                      0x000000010ad40c21 __CFRunLoopDoTimer + 1089
    31  CoreFoundation                      0x000000010ad02b11 __CFRunLoopRun + 1937
    32  CoreFoundation                      0x000000010ad020f8 CFRunLoopRunSpecific + 488
    33  GraphicsServices                    0x00000001126d7ad2 GSEventRunModal + 161
    34  UIKit                               0x000000010d93bf09 UIApplicationMain + 171
    35  MyProjectName                          0x0000000109a9df12 main + 114
    36  libdyld.dylib                       0x000000011000192d start + 1
    37  ???                                 0x0000000000000001 0x0 + 1
)
libc++abi.dylib: terminating with uncaught exception of type NSException
```

And it points to this line when crashed:

`dispatch_sync(queue) { dataTask = self.session.dataTaskWithRequest(URLRequest.URLRequest) }`
 I ended up doing something like this:

```
class NetworkManager {

    let manager: Manager = {
        let configuration: NSURLSessionConfiguration = {
            let identifier = "com.company.app.background-session"
            let configuration = NSURLSessionConfiguration.backgroundSessionConfigurationWithIdentifier(identifier)
            return configuration
        }()

        return Manager(configuration: configuration)
    }()

    static let sharedInstance = NetworkManager()
}
```

```
    NetworkManager.sharedInstance.manager.request(.GET, requestUrl, headers: headersAuth)
        .response { response in
            let fixedString = String(data: response.2!, encoding: NSUTF8StringEncoding)
            let imageUrl = MyConstants.WEBURL_NO_SLASH + fixedString!
            imageView.kf_setImageWithURL(NSURL(string: imageUrl)!)
    }
```

Seems to work okay at the moment. Will update if any crashes occur.
  I have the same problemÔºåif I use swift3.0-Alamofire4.0,iOS8.0 is not support,but I need support iOS8.0;
 sorryÔºå i see
  Error: Cannot call value of non-function type 'HTTPURLResponse'.
Problem is in the row "imageRequest.request.response" after updating to Swift 3.0

`   func getNetworkImage(_ urlString: String, completion: @escaping ((UIImage) -> Void)) -> (ImageRequest) {
        let queue = decoder.queue.underlyingQueue
        let request = Alamofire.request(urlString)
        let imageRequest = ImageRequest(request: request)

```
    imageRequest.request.response(
        queue: queue,
        responseSerializer: Request.imageResponseSerializer(),
        completionHandler: { response in
            guard let image = response.result.value else {
                return
            }
            let decodeOperation = self.decodeImage(image) { image in
                completion(image)
                self.cacheImage(image, urlString: urlString)
            }
            imageRequest.decodeOperation = decodeOperation
        }
    )

    return imageRequest
}`
```
 @elena-dare did you find the solution for this issue?

I want to do this:

**request.response {(req, resp, _, _) in
}.resume()**

the **request** is a Request (Alamofire) and i'm getting the same error:

_**Cannot call value of non-function type 'HTTPURLResponse'.**_  When i parse the JSON xCode return "type Any? has no subscriptor"
`if let JSON = response.result.value {
    let c = (JSON as AnyObject).count!
         for index in 0..<c {
                    print(JSON[index]) //Here is my error
        }
}
`
  Undefined symbols for architecture x86_64:
  "Alamofire.Request.responseJSON (queue : __ObjC.OS_dispatch_queue?, options : __C.NSJSONReadingOptions, completionHandler : (Alamofire.Response<Swift.AnyObject, __ObjC.NSError>) -> ()) -> Self", referenced from:

How to solve the above problem?
 Update to Alamofire 4.0? Or is there a specific reason you don't want to?
 > Update to Alamofire 4.0? Or is there a specific reason you don't want to?

Not speaking for @duanyicanyuan, but its Swift >= 3.0 requirement is a pretty big one if you have larger codebase...
 @iliubave I need to support iOS8, but Alamofire 4.0 does not support
 I have the same problem.
and cannot use Alamofire 4.0 since it required iOS 9.0
 I need to support iOS 8+, I also want to use Alamofire 4.0 ~~~~(>_<)~~~~
 Stick with AFNetworking and Objective C was the best decision I have ever made. no hassle with updates 
  I've updated Alamofire to version 4.0, my project is also updated to Swift 3.0 but still I'm geting issue.

> "Use Legacy Swift Language Version‚Äù (SWIFT_VERSION) is required to be configured correctly for targets which use Swift. Use the [Edit > Convert > To Current Swift Syntax‚Ä¶] menu to choose a Swift version or use the Build Settings editor to configure the build setting directly."
 Try #1552.
 @waseefakhtar , thanks for the suggestion. It worked for me!
 @waseefakhtar,  my project is also updated to Swift 3.0 but I need support iOS 8.0, so I cannot use Alamofire 4.0 and 3.0? I must use AFNetworking?
 @jshier , thank you, I already update to Swift 3.0, so the Alamofire 3.5.0 is not meet the requirements...
 I have the same problemÔºåif  I use swift3.0-Alamofire4.0,iOS8.0 is not support,but I
 need support iOS8.0;
 I have the same problemÔºåif I use swift3.0-Alamofire4.0,iOS8.0 is not support,but I
need support iOS8.0;
 I have the same problemÔºåif I use swift3.0-Alamofire4.0,iOS8.0 is not support,but I
need support iOS8.0;
  Hi,
iOS URLSessionDownloadTask.cancel(byProducingResumeData:) gives unusable resume data. To rectify these data you can add my tricky method to your project:

http://stackoverflow.com/questions/39346231/resume-nsurlsession-on-ios10/39347461#39347461

Best Regards
  @amosavian  I use oc ,so i don't familiar with swift.So i can't understand a part of code. Can you use oc for writing Solution again ,or tell me how to solve this by oc in detail? thank you very much! 
 @imfaker I know literally nothing on objc. However you can either bridge this code using bridge-header to objective c or convert it.
 I have slove this problem that use your way by objc.Thank you very much for your idea .You're genius.hahah.
 Hey @cnoon , This problem will occur when you use background session configuration.
 @cnoon I can reproduce this behavior in both simulator and device. You will get error -3003 in case you try to use resume data to start and resume a new background download task.
 Any news on this?
 Hi @cnoon 

Thanks for your attention. Your decision makes sense. It's enough to inform users about this bug and the workaround so they won't be like a headless chicken when they encounter this issue.
The interesting point is I didn't test this issue on macOS and tvOS and this is first time I found out it's universal. 

Thanks much üçª
 Hi @amosavian 

I'm having the same problem and, quite frankly, don't know how to implement your workaround in Alamofire. I've tried replacing the `session.downloadTask(withResumeData: resumeData)` function with `session.correctedDownloadTask(withResumeData: resumeData)` in the `DownloadRequest` class but the problem is that the download task fails (instead of being suspended) as soon as the user loses internet connection.

Thanks!
 @neducatio-content 

`"unsupported url"` (-1002) error which you get can't be fixed though it's due to exactly the same underlying bug. I tried to fix this issue but found out nsurlsessiond deamon not only doesn't return `NSURLSessionDownloadTaskResumeData` userInfo object but also deletes temporary file which is unrecoverable with standard methods.

Quinn the Eskimo, the support guy of Apple team is aware of this issue and emailed me an official workaround which is principally improved version of mine, and solves the same issue. But he said they are working to fix the bug.

Unfortunately for now, there is not workaround to overcome this issue

"Share and Enjoy"
 @jshier I asked him and he told me I'm not allowed. But the improvement is they use a `NSKeyedUnarchiver` with `archiver.requiresSecureCoding = true` instead of directly mangling with keyed archived object in `correct(requestData:)` method to change top level key from `"NSKeyedArchiveRootObjectKey"` to `NSKeyedArchiveRootObjectKey = "root"`, otherwise it's the same with exhaustive documentation.
 @amosavian thanks for your help!
  I‚Äôm getting an error:

`‚ÄúUse Legacy Swift Language Version‚Äù (SWIFT_VERSION) is required to be configured correctly for targets which use Swift. Use the [Edit > Convert > To Current Swift Syntax‚Ä¶] menu to choose a Swift version or use the Build Settings editor to configure the build setting directly.
`

Possibly wants me to migrate to Swift 3. Am I using the right version of Alamofire for Swift 2.3?
 @waseefakhtar workaround: just add to your Podfile

```
post_install do |installer|
  installer.pods_project.targets.each do |target|
    target.build_configurations.each do |config|
      config.build_settings['SWIFT_VERSION'] = '2.3'
    end
  end
end
```
 @ben73 thanks! that worked.
 worked for me too, thx
 No need to do that. You should use CocoaPods 1.1.0 (currently rc2) to be used with Xcode 8: `gem update cocoapods --pre`
 Thank you @ikesyo. Though I had CocoaPods 1.1.0 RC2, I rerun `sudo gem update cocoapods --pre` and this worked better. I tried @ben73 method but it gave me issues with other dependencies.
  Hi,

I think that I have identified a memory leak when I am using uploadProgress or downloadProgress in my code.

Here is the code example that is generating memory leak.

```
func sendcapturedPhoto(_ id: String, capturedPhoto: UIImage, progress: @escaping ((_ progressValue: Progress) -> Void), completed: @escaping ((_ success: Bool, _ contributionId: String?, _ error: AppError?) -> Void)) -> Alamofire.Request {

        var endPoint = Router.addImageToSweebi(id: id)

        return Alamofire.upload(UIImageJPEGRepresentation(capturedPhoto, 0.8)!, with: endPoint)
            .validate()
            .uploadProgress(closure: { (prog) in
                progress(prog)
            })
            .responseOMObject { (request, success, data: Image?, error) in
                completed(success, data?.id, error)
        }
    }
```

If I don't use uploadProgress I don't have memory leaks and all my objects are correctly deinit. But I want to know the progression of an upload.
 I find a way to avoid this problem in Alamofire. In UploadRequest I have replaced uploadProgress with this one:

```
@discardableResult
    open func uploadProgress(queue: DispatchQueue = DispatchQueue.main, closure: @escaping ProgressHandler) -> Self {
        uploadDelegate.uploadProgressHandler = ({(progress) in
            closure(self.uploadProgress)
            if progress.fractionCompleted == 1.0 {
                self.uploadDelegate.uploadProgressHandler = nil
            }
            }, queue)
        return self
    }
```

After that, memory leaks disappeared. I think the same thing could be done with downloadProgress.

I want to open issue on this because I am sure that my solution is not the the good one.
 I've encountered a memory leak in AlamofireImage and found the leak is linked to the Request.validate() method. If I remove the validate() the memory leak disappears.
 The validate() leaks appear related to Validate.swift building closures while capturing strong self... e.g. lines 165, 241.  These need changing to unowned self or refactored for weak self

For example: Around Validation.swift Line 165

``` swift
let validationExecution: () -> Void = {
            if
                let response = self.response,
                self.delegate.error == nil,
                case let .failure(error) = validation(self.request, response, self.delegate.data)
            {
                self.delegate.error = error
            }
        }
```

Suggested change:

``` swift
let validationExecution: () -> Void = {  [unowned self] in 
            if
                let response = self.response,
                self.delegate.error == nil,
                case let .failure(error) = validation(self.request, response, self.delegate.data)
            {
                self.delegate.error = error
            }
        }
```

There are several of these throughout the code that need to be handled.
   I am sorry, I was adding that for iOS target and checking for twos. resolved that day only.closing the issue.
  Hi,

I am trying to update Alamofire to version 4.0. When I run `carthage update` I get many errors when building Alamofire scheme. It looks like files weren't updated to Swift 3.0 syntax. What I am doing wrong? Log from terminal:

```
*** Checking out Alamofire at "4.0.0"
*** xcodebuild output can be found in /var/folders/ls/6t_b5mqx5s187hq2dtts6ys00000gn/T/carthage-xcodebuild.ORghi2.log
*** Building scheme "Alamofire watchOS" in Alamofire.xcworkspace
/Users/liborzapletal/Documents/Aplikace/PNG/PNG/Carthage/Checkouts/Alamofire/Source/NetworkReachabilityManager.swift:36:1: error: expressions are not allowed at the top level
/Users/liborzapletal/Documents/Aplikace/PNG/PNG/Carthage/Checkouts/Alamofire/Source/NetworkReachabilityManager.swift:36:5: error: consecutive statements on a line must be separated by ';'
/Users/liborzapletal/Documents/Aplikace/PNG/PNG/Carthage/Checkouts/Alamofire/Source/NetworkReachabilityManager.swift:74:5: error: expected declaration
/Users/liborzapletal/Documents/Aplikace/PNG/PNG/Carthage/Checkouts/Alamofire/Source/NetworkReachabilityManager.swift:74:9: error: consecutive declarations on a line must be separated by ';'
/Users/liborzapletal/Documents/Aplikace/PNG/PNG/Carthage/Checkouts/Alamofire/Source/NetworkReachabilityManager.swift:77:5: error: expected declaration
/Users/liborzapletal/Documents/Aplikace/PNG/PNG/Carthage/Checkouts/Alamofire/Source/NetworkReachabilityManager.swift:77:9: error: consecutive declarations on a line must be separated by ';'
/Users/liborzapletal/Documents/Aplikace/PNG/PNG/Carthage/Checkouts/Alamofire/Source/NetworkReachabilityManager.swift:80:5: error: expected declaration
/Users/liborzapletal/Documents/Aplikace/PNG/PNG/Carthage/Checkouts/Alamofire/Source/NetworkReachabilityManager.swift:80:9: error: consecutive declarations on a line must be separated by ';'
/Users/liborzapletal/Documents/Aplikace/PNG/PNG/Carthage/Checkouts/Alamofire/Source/NetworkReachabilityManager.swift:83:5: error: expected declaration
/Users/liborzapletal/Documents/Aplikace/PNG/PNG/Carthage/Checkouts/Alamofire/Source/NetworkReachabilityManager.swift:83:9: error: consecutive declarations on a line must be separated by ';'
/Users/liborzapletal/Documents/Aplikace/PNG/PNG/Carthage/Checkouts/Alamofire/Source/NetworkReachabilityManager.swift:89:5: error: expected declaration
/Users/liborzapletal/Documents/Aplikace/PNG/PNG/Carthage/Checkouts/Alamofire/Source/NetworkReachabilityManager.swift:89:9: error: consecutive declarations on a line must be separated by ';'
/Users/liborzapletal/Documents/Aplikace/PNG/PNG/Carthage/Checkouts/Alamofire/Source/NetworkReachabilityManager.swift:92:5: error: expected declaration
....... and many others
```
  There are plenty of devices still running iOS 8, would it be possible to lower the podspec to use iOS 8.
 iOS8 is no longer supported by [Apple](https://en.wikipedia.org/wiki/List_of_products_discontinued_by_Apple_Inc.#Software) - it doesn't make sense to support it in libraries.  Just release new versions of your app for iOS9+ and your existing iOS8 users will still be ok.

[iOS8 usage](https://david-smith.org/iosversionstats/) is 5.5% but I doubt those are the devices actively doing app updates.
 Please add Support for iOS 8.0. drop supporting iOS 8 leads to a situation that Swift 3 developers have to choose between Alamofire or iOS 8.0 users.
 Just stick with Swift 2.3 (instead of 3) with Alamofire 3.x and you'll be fine with iOS8+.  iOS 8 isn't even supported by Apple anymore.  
  Hello,

Today I migrate to Xcode 8.0 and Swift 3.0 with your new release Alamofire 4.0

I have this podfile :

`# Uncomment this line to define a global platform for your project`
`platform :ios, '9.0'`

`project 'Morning.xcodeproj'`

`target 'Morning' do`
  `# Comment this line if you're not using Swift and don't want to use dynamic frameworks`
  `use_frameworks!`

  `# Pods Fabric`
  `pod 'Fabric', '~> 1.6.7'`
  `pod 'Crashlytics', '~> 3.7.2'`

 `# Pods for Morning`
 `pod 'Alamofire', '~> 4.0'`
  `pod 'SwiftyJSON', git: 'https://github.com/acegreen/SwiftyJSON.git', branch: 'swift3'`
  `pod 'PKHUD', :git => 'https://github.com/toyship/PKHUD.git'`
  `# pod 'Loggerithm', '~> 1.3'`

  `target 'MorningTests' do`
   `inherit! :search_paths`
   `# Pods for testing`
  `end`

 `target 'MorningUITests' do`
   `inherit! :search_paths`
   `# Pods for testing`
  `end`

`end`

`post_install do |installer|`
    `installer.pods_project.targets.each do |target|`
        `target.build_configurations.each do |config|`
            `config.build_settings['SWIFT_VERSION'] = '3.0'`
        `end`
    `end`
`end`

And when I launch Xcode I have some issue: 188.

<img width="325" alt="screen shot 2016-09-15 at 17 02 04" src="https://cloud.githubusercontent.com/assets/4347183/18555398/076c4026-7b68-11e6-9efc-46a36c955805.png">

Do you have any idea about my problem ?

Thank you for your reply !

@cnoon 
 Same problem here. After update the Alamofire version to 4.0.0

![captura de tela 2016-09-15 as 13 16 07](https://cloud.githubusercontent.com/assets/12235426/18557757/a14e979c-7b46-11e6-837b-d35befd50ea2.png)
 It looks like you guys didn't update Alamofire correct to the new version. You have to update your cocoapods first to a version that uses 1.1.0.+.

sudo gem install cocoapods --pre
pod update
 Thanks for your reply.

 I have already tryed this way. So in my case, I have the last version version of cocoapods. This solution does not fix my issue.

Do you have another idea ?
 In your Podfile.lock file which version does it show for you for Alamofire?
 In my Podfile.lock :
`COCOAPODS: 1.1.0.rc.2`
 Can you post your Podfile.lock? Or if you know the version of Alamofire you can post that.
 Yes of course :
PODS:
- Alamofire (4.0.0)
- Crashlytics (3.7.3):
  - Fabric (~> 1.6.3)
- Fabric (1.6.8)
- PKHUD (3.2.1)
- SwiftyJSON (2.3.2)

DEPENDENCIES:
- Alamofire (~> 4.0)
- Crashlytics (~> 3.7.2)
- Fabric (~> 1.6.7)
- PKHUD (from `https://github.com/toyship/PKHUD.git`)
- SwiftyJSON (from `https://github.com/acegreen/SwiftyJSON.git`, branch `swift3`)

EXTERNAL SOURCES:
  PKHUD:
    :git: https://github.com/toyship/PKHUD.git
  SwiftyJSON:
    :branch: swift3
    :git: https://github.com/acegreen/SwiftyJSON.git

CHECKOUT OPTIONS:
  PKHUD:
    :commit: 28fb970b41d63134e962f9da766b96670c0f55f0
    :git: https://github.com/toyship/PKHUD.git
  SwiftyJSON:
    :commit: 8971384559780e631b041ac91b16734a396d4c14
    :git: https://github.com/acegreen/SwiftyJSON.git

SPEC CHECKSUMS:
  Alamofire: fef59f00388f267e52d9b432aa5d93dc97190f14
  Crashlytics: 76f6beaff70acf226139582c09c78461597c2b98
  Fabric: 5755268d0171435ab167e3d0878a28a777deaf10
  PKHUD: 001c11518f125a273ddf026bcc64918423744ea2
  SwiftyJSON: 04ccea08915aa0109039157c7974cf0298da292a

PODFILE CHECKSUM: 95ffb93589959087c06fecd62b7c58e4b5eff3a4

COCOAPODS: 1.1.0.rc.2
 Hmm okay thanks, so your alamofire is up-to-date. I wonder if its something with the cache. 

Try running:
pod cache clean --all
pod update

If that doesn't work, try cleaning the project before running
Let me know how that goes.

Next I would look into looking at your build settings and making sure the versions align there as well with 9.0.
 Okay, thanks for your reply. I didn't think about `pod cache clean -all` it was a good idea but does not work ...

I clean my ios project with product->clean and with product->(shift)clean build folder
and it does not work again. I have 188 issue again.

My project support iOS 9.0 and pod project too.
My Podfile have this line : `platform :ios, '9.0'`

So I think it's ok about iOS version.

About my build settings what do you want to see ?

Thx !
 @jshier 

Hi!

Yes I agree with you about best practice to migrate a project on Swift 3.0. And the problem is I made this exact process.

And I have 188 issue for Alamofire. I don't have problem with other library.

So I open an issue on your github because I looking for your help. 
Can you reopen my issue to keep looking for a solution ?

Thx!
 Ok my bad.

I made `pod install` after convert my code in Swift 3.0.

If I convert my personal code and I launch `pod update` after modify my podfile my project build properly ! Maybe an error on cocoapods ? Or `pod install` is not a best practice ? I don't know but my problem is solve !!

Thank you for your reply @jshier & @codymoorhouse and have a good day ;-)
  I am trying to install Alamofire on a blank xcode project and am getting 829 runtime errors. I am installing via Cocoapods, and it is successfully installing 4.0.0:

```
source 'https://github.com/CocoaPods/Specs.git'
platform :ios, '10.0'
use_frameworks!

target 'BlankProject' do

    pod 'Alamofire', '~> 4.0'

end
```

Whenever I launch Xcode it asks me to upgrade the Swift Syntax. 

I have the latest version of Cocoapods installed too. Any help would be great.
  I just updated to swift 3 - and finally Alamofire is giving me more info on a problem I've had since I started my current project.

GET requests work fine. But when I try to POST with JSON encoded parameters it seems like the app is using a socket that was already closed.

I've tried everything to get this solved but could it be an underlying issue in iOS?

The only solutions that have worked for me have been to:
1. - encode the parameters in the URL. Not a solution that will work for my project.
2. - just resend the POST until it works. This is the ugly solution I'm using at the moment.

These are the errors I get:

> nw_socket_get_input_frames recvmsg(fd 24, 1024 bytes): [54] Connection reset by peer
> __tcp_connection_write_eof_block_invoke Write close callback received error: [57] Socket is not connected

My GET requests and POSTs without any parameters work just fine - any idea to why this is?
  I'm using Xcode 8 and the official SPM.  I try to use Alamofire through SPM:

``` swift
import PackageDescription

let package = Package(
    name: "swift-playground",
    dependencies: [
        .Package(url: "https://github.com/Alamofire/Alamofire.git", majorVersion: 4)
    ]
)
```

However, `swift build` gives me a lot of errors:

``` plaintext
Cloning https://github.com/Alamofire/Alamofire.git
HEAD is now at 5fe5b20 Added release notes to the CHANGELOG and bumped the version to 4.0.0.
Resolved version: 4.0.0
Compile Swift Module 'Alamofire' (17 sources)
/Users/skyline/Projects/Github/swift-playground/Packages/Alamofire-4.0.0/Source/DispatchQueue+Alamofire.swift:33:25: error: use of undeclared type 'TimeInterval'
    func after(_ delay: TimeInterval, execute closure: @escaping () -> Void) {
                        ^~~~~~~~~~~~
/Users/skyline/Projects/Github/swift-playground/Packages/Alamofire-4.0.0/Source/SessionDelegate.swift:111:50: error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer
    open var streamTaskReadClosed: ((URLSession, URLSessionStreamTask) -> Void)?
                                                 ^
/Users/skyline/Projects/Github/swift-playground/Packages/Alamofire-4.0.0/Source/SessionDelegate.swift:111:50: note: add @available attribute to enclosing class
    open var streamTaskReadClosed: ((URLSession, URLSessionStreamTask) -> Void)?
                                                 ^
/Users/skyline/Projects/Github/swift-playground/Packages/Alamofire-4.0.0/Source/SessionDelegate.swift:114:51: error: 'URLSessionStreamTask' is only available on OS X 10.11 or newer
```
 I'm indeed using Xcode 8 and Swift 3. I think there may be some kind of bug in SPM.
 I used Xcode8 too, got the same errors
(https://cloud.githubusercontent.com/assets/8327777/18612992/2221341e-7da0-11e6-9f58-73a57e8451d0.png)
 Package Manager integration is broken? Similar issue as reported + and Swift seems confused by the tag if I also include AlamofireNetworkActivityIndicator. It will choose "4.0.0-beta.2" over "4.0.0". Perhaps the patch number should be increased?
 @jshier  Please consider reopening this. I think maybe #1549 is also related to this.
 Also now #1582!
 @jshier  @cnoon  Thanks for the feedback. Really appreciate it. 
 @cnoon When I tried generating the xcodeproj following those steps I got a Swift compiler error: "Illegal Instruction: 4".
 Hm nvm, doesn't happen anymore. It's still not working 100%, though - while I can work on the project in Xcode, running "swift build" from the command line gives the same error as before.
 @cnoon how does this work if I'm trying to get Alamofire building for iOS with swift package manager?

I'm working on https://github.com/Moya/Moya/pull/643, and I'm having trouble getting the project to `swift build` - the same issues that @skyline75489 was having in https://github.com/Alamofire/Alamofire/issues/1544#issue-177155724. Moya doesn't have a `main.swift`, so I'm not sure if the instructions you gave in https://github.com/Alamofire/Alamofire/issues/1544#issuecomment-250995345 apply here.
 @cnoon so there is no known solution that supports `swift build` from the command line without using Xcode? 
 @cnoon thx for the temporary solution. +1 for this issue.
  Swift 3 is compatible with iOS8. why the library needs iOS9 ?
 Yeah, I think it would be nice if we support past 3 iOS versions (8,9,10) if possible.
 The reason why they target IOS 9 is supporting URLSessionStreamTask. I created a fork https://github.com/tonyli508/AlamofireDomain which disabled URLSessionStreamTask, and will pull the latest changes from time to time. 
  This is a must, and the future will always be like thisÔºü
 @jshier  got it, thank you so much
  ![fd774a26-2c00-4b13-b3ba-711a64bc47d2](https://cloud.githubusercontent.com/assets/16864923/18537614/76d599fa-7b39-11e6-9861-d43e6e5e0f34.png)
Alamofire/Source/ServerTrustPolicy.swift:243:41: Use of unresolved identifier 'kSecTrustResultInvalid'
 Update your library,

updated now and in ServerTrustPolicy file i can see:

`
private func trustIsValid(_ trust: SecTrust) -> Bool {
        var isValid = false

```
    var result = SecTrustResultType.invalid
    let status = SecTrustEvaluate(trust, &result)

    if status == errSecSuccess {
        let unspecified = SecTrustResultType.unspecified
        let proceed = SecTrustResultType.proceed


        isValid = result == unspecified || result == proceed
    }

    return isValid
}
```

`
 I am using Appropriate version. I tried Alamofire 3.1.4, 3.5.0, 3.5.1 with Xcode 8. Use Legacy swift version = YES. Still unresolved identifier error is appearing !
Any other solution ?
 Try Below Code. This worked for me. You've to capitalised enum type for swift 2.3 and Smaller for 3.0

```
var result = SecTrustResultType.Invalid
let status = SecTrustEvaluate(trust, &result)

if status == errSecSuccess {
       let unspecified = SecTrustResultType.Unspecified
       let proceed = SecTrustResultType.Proceed


       isValid = result == unspecified || result == proceed
}

return isValid
```
  Hi after expending 4 hours I think that this is a problem with Alamofire, I'm trying to add generic response in a collection but I'm getting compiler error. Here is the error

`Undefined symbols for architecture arm64: "ExpSwift.SearchResults.generate () -> Swift.IndexingGenerator<[A]>", referenced from: ExpSwift_Example.ViewController.(viewDidLoad () -> ()).(closure #1).(closure #3) in ViewController.o ld: symbol(s) not found for architecture arm64 clang: error: linker command failed with exit code 1 (use -v to see invocation)`

Here are my classes

``` swift
    public final class SearchResults<T> {

    var results: [T] = []
    let total: Int64

    required public init?(results: [T], total: Int64) {
        self.results = results
        self.total = total
    }

    public func getResults() -> [T] {
        return self.results
    }

    public func getTotal() -> Int64 {
        return self.total
    }

    }

    extension SearchResults : SequenceType {
    public func generate() -> IndexingGenerator<Array<T>> {
        return results.generate()
    }
    }
```

Here is my call with alamofire

``` swift
ExpSwift.findLocations(["limit":10, "skip":0, "sort":"name"]).then { (locations: SearchResults<Location>) -> Void in
            for location:Location in locations{
                debugPrint(location.get("name"))
            }

            }.error { error in
                debugPrint(error)
        }
    }
```

I did test the same code on a single class and it works, so my only guess is something related to Alamofire or cocoapods I'm using alamofire version 3.1.5
 I did post the problem in stackoverflow, I will try updating to Alamofire 3.5 but I post the problem here because I get the error only when I use the class with alamofire, if I use the class alone I don't have that compiler error.
 thanks I will, I think you're right is something maybe with cocoapods
  Use of undeclared type 'TimeInterval'
Thanks
  I'm getting this error everywhere i used `Response` in my code and i don't get it. `Request` is ok but `Response` is undeclared? what is wrong?
 pff same problem here.
 I had to change them to 
`response: DataResponse<Class>`
  It was needed to specify the Swift version to validate against in a .swift-version file.

See CocoaPods/CocoaPods#5841 for more details.

![pod lib lint](http://i.imgur.com/c6F6ldS.png)
  Hi, in the past we can set cookie in the following way
Alamofire.Manager.sharedInstance.session.configuration.HTTPCookieStorage?.setCookies

Now the manager is replaced with SessionManager, but it doesn't have the sharedInstance anymore.

How to do this now in the new version?
Thanks!
    # Question: cocoapods version is 1.1.0+ Ôºåbut I can't install Alamofire.  How to solve it?

**Terminal command as followsÔºö**

macMBP:DailyNews cdmac$ pod --version
1.1.0.beta.2
macMBP:DailyNews cdmac$ pod install
Re-creating CocoaPods due to major version update.
Analyzing dependencies
[!] Unable to satisfy the following requirements:
- `Alamofire (~> 4.0)` required by `Podfile`

Specs satisfying the `Alamofire (~> 4.0)` dependency were found, but they required a higher minimum deployment target.

[!] Your Podfile has had smart quotes sanitised. To avoid issues in the future, you should not use TextEdit for editing it. If you are not using TextEdit, you should turn off smart quotes in your editor of choice.
 I also experience this one, I had to use the "tag" podfile.
 I update Xcode 8 too fast, should wait for a period of time.Too many project errors, it was crazy.
 I used pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :tag => '4.0.0', it was working fine on me and compiled successfully.
 I was getting this error 

`[!] The`*****\* [Debug]`target overrides the`ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES`build setting defined in`Pods/Target Support Files/Pods-***_/Pods-**_*.debug.xcconfig'. This can lead to problems with the CocoaPods installation`

adding this to the podfile solved it 

`post_install do |installer|
    installer.pods_project.targets.each do |target|
        target.build_configurations.each do |config|
            config.build_settings['ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES'] = 'NO'
        end
    end
end`

Might be unrelated but still worth trying
 @lawgimenez @amolgupta @jshier  Thanks guys!  I decided to wait for a period of time, I will reinstall Xcode7.3.
 I have 1.1.0.rc.2, deployment target versions  = 10.0. I also get the same error
 @jshier I am getting the same error as @amolgupta 

When I run pod update:

> [!] The `*** [Debug]` target overrides the `ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES` build setting defined in `Pods/Target Support Files/Pods-bootmark/Pods-bootmark.debug.xcconfig'. This can lead to problems with the CocoaPods installation
>     - Use the`$(inherited)` flag, or
>     - Remove the build settings from the target.
> 
> [!] The `bootm***ark [Release]` target overrides the `ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES` build setting defined in `Pods/Target Support Files/Pods-bootmark/Pods-bootmark.release.xcconfig'. This can lead to problems with the CocoaPods installation
>     - Use the`$(inherited)` flag, or
>     - Remove the build settings from the target.

I am using cocoapods 1.1.0.rc.2 with a deployment target of 10.0. I am also using alamofire 4.0. Any suggestions?
 I have the same problem of @codymoorhouse and @amolgupta , my target is 9.0
 Same here
 I am also facing Same problem
 me too.  Xcode Version 8.0 (8A218a), target macOS 10.11

[!] The `JsonKitTests [Debug]` target overrides the `ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES` build setting defined in `Pods/Target Support Files/Pods-JsonKitTests/Pods-JsonKitTests.debug.xcconfig'. This can lead to problems with the CocoaPods installation
    - Use the`$(inherited)` flag, or
    - Remove the build settings from the target.

[!] The `JsonKitTests [Release]` target overrides the `ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES` build setting defined in `Pods/Target Support Files/Pods-JsonKitTests/Pods-JsonKitTests.release.xcconfig'. This can lead to problems with the CocoaPods installation
    - Use the`$(inherited)` flag, or
    - Remove the build settings from the target.

[!] The `JsonKitUITests [Debug]` target overrides the `ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES` build setting defined in `Pods/Target Support Files/Pods-JsonKitUITests/Pods-JsonKitUITests.debug.xcconfig'. This can lead to problems with the CocoaPods installation
    - Use the`$(inherited)` flag, or
    - Remove the build settings from the target.

[!] The `JsonKitUITests [Release]` target overrides the `ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES` build setting defined in `Pods/Target Support Files/Pods-JsonKitUITests/Pods-JsonKitUITests.release.xcconfig'. This can lead to problems with the CocoaPods installation
    - Use the`$(inherited)` flag, or
    - Remove the build settings from the target.
 @GZaccaroni @PlayApple @SMR @jonybur 

I don't know if this will work for you guys or not, but worth a try?
See Issue: #1573
 Same here with `platform :ios, '9.0'`

It fails only when you add pod AlamofireObjectMapper

![screen shot 2016-09-20 at 4 54 53 pm](https://cloud.githubusercontent.com/assets/1725945/18668490/579bfd86-7f53-11e6-8790-b554ff51ef18.png)
 @stephen-talari AlamofireObjectMapper has a new release 4.0.0 which depends on Alamofire >= 4.0.0 (and uses Swift 3), so you should probably use that newer version instead.
 @dusek Yes, it resolved my issue. Thanks
 I was changing target in Xcode, and after a while i realized that is in PodFile, so i changed it and it works :'D
 Use,
`platform :ios, '10.0'`

in your pod file
 I tried @Lasithih similar fix but I used iOS 9.0 (was iOS 8) and it worked! Thanks!

`platform :ios, '9.0'`

in pod file
 @ stephen-talari 
I have a same issue
How to solve this issue??
 I am using legacy swift (`Build Settings > Use Legacy Swift Language Version = Yes`).
In my Podfile

```
  pod 'Alamofire', '~> 3.0'
  pod 'AlamofireObjectMapper', '~> 2.1'

```

This is for those who support legacy swift.
  I could have this wrong, but the following doesn't work in master:

manager.request("....", method: .get, parameters: parameters, encoding: JSONEncoding.default)

As far as I can tell Alamofire eats the request, doesn't send anything out on the wire, and just times-out after a while.

Whereas this works perfectly:

manager.request("....", method: .post, parameters: parameters, encoding: JSONEncoding.default)

The only difference being the get versus post method. Furthermore, if I do the get but use URLEncoding it works fine.

Is there a bug?
 https://github.com/Alamofire/Alamofire/issues/1528 could this issue be somehow related, I'm using headers. Also, only POST are working right now except GET.
 Whoa. Did you just close my bug report because the legitimate call I was trying to make was not as common as some others? I'm aware I'm trying to JSON encode the body for a HTTP GET but that is what the web service that I'm using requires. It's still a perfectly normal operation though.

I know your library has many tests and examples, I had to use them to work out how to do certain things because your documentation was lacking in some areas. I would note that you don't have a test for this particular operation.

It still could be user error on my part, but I'm beginning to feel more confident that it's a bug in your library. Maybe you could reopen this issue for me, and I'll see if I can add a bit more, although you only need to do the one line I gave to demonstrate the problem.
  I am trying to download [this picture](https://slove.tulleb.com/uploads/6/6/0/2/66027561/2791411.jpg-1447979839.png) in my code using Alamofire 4.0.0 with Xcode 8.0 and Swift 3.0.

Here is my request:

```
    func download(_ path: String, _ completionHandler: @escaping (Any?) -> ()) {
        let stringURL = "https://slove.tulleb.com/uploads/6/6/0/2/66027561/2791411.jpg-1447979839.png"

        print("Requesting \(stringURL)...")

        _ = Alamofire.download(stringURL)
            .responseData { response in
                print(response)

                if let data = response.result.value {
                    completionHandler(UIImage(data: data))
                } else {
                    completionHandler(nil)
                }
        }
    }
```

I have the following error:

> FAILURE:
> responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.inputFileReadFailed(file:///private/var/mobile/Containers/Data/Application/50400F41-47FD-4276-8903-F48D942D064A/tmp/CFNetworkDownload_D1Aqkh.tmp))

This problem occures whatever image link I am using.
Any help would be very appreciated, thanks :)
 How can send http post request using Almofire with http header .and authentication?

1.parameters

let parameters: Parameters = ["username ": "Henry","password":"xxxx","key"="ewq2356"]
2.http header

let headers = [ "Authorization": "Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==", "Content-Type": "application/x-www-form-urlencoded" ]
3.Authentication with URLCredential

let user = "user1" let password = "password1"
4.URL

http://myapi.com/rest/index.php
So how could I use it using Almofire http post method ?
 @jshier @cnoon just to remind you that I still have this download issue...

**It doesn't seem related to @rakeshbiswalmobileprogrmming's problem :(**
 For me, some is success, some is always fail.

```
[Alamofire] download : https://0.s3.envato.com/files/47374385/akedodee_avatar.jpg
[Alamofire] download : https://preview-tf.s3.envato.com/files/200537021/Thumbnail.png
[Alamofire] failure : https://preview-tf.s3.envato.com/files/200537021/Thumbnail.png
[Alamofire] failure : https://0.s3.envato.com/files/47374385/akedodee_avatar.jpg
[Alamofire] download : https://preview-tf.s3.envato.com/files/126954540/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/198807153/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/128581452/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/148293837/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/130631924/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/128056772/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/68729806/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/134305582/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/135205962/Thumbnail.png
[Alamofire] success : https://preview-tf.s3.envato.com/files/126954540/Thumbnail.png
[Alamofire] success : https://preview-tf.s3.envato.com/files/128581452/Thumbnail.png
[Alamofire] success : https://preview-tf.s3.envato.com/files/130631924/Thumbnail.png
[Alamofire] success : https://preview-tf.s3.envato.com/files/68729806/Thumbnail.png
[Alamofire] failure : https://preview-tf.s3.envato.com/files/198807153/Thumbnail.png
[Alamofire] failure : https://preview-tf.s3.envato.com/files/134305582/Thumbnail.png
[Alamofire] failure : https://preview-tf.s3.envato.com/files/148293837/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/126954540/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/198807153/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/128581452/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/148293837/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/130631924/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/128056772/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/68729806/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/134305582/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/135205962/Thumbnail.png
[Alamofire] failure : https://preview-tf.s3.envato.com/files/135205962/Thumbnail.png
[Alamofire] failure : https://preview-tf.s3.envato.com/files/126954540/Thumbnail.png
[Alamofire] failure : https://preview-tf.s3.envato.com/files/198807153/Thumbnail.png
[Alamofire] failure : https://preview-tf.s3.envato.com/files/128056772/Thumbnail.png
[Alamofire] failure : https://preview-tf.s3.envato.com/files/128581452/Thumbnail.png
[Alamofire] failure : https://preview-tf.s3.envato.com/files/148293837/Thumbnail.png
[Alamofire] failure : https://preview-tf.s3.envato.com/files/130631924/Thumbnail.png
[Alamofire] failure : https://preview-tf.s3.envato.com/files/128056772/Thumbnail.png
[Alamofire] failure : https://preview-tf.s3.envato.com/files/68729806/Thumbnail.png
[Alamofire] failure : https://preview-tf.s3.envato.com/files/134305582/Thumbnail.png
[Alamofire] failure : https://preview-tf.s3.envato.com/files/135205962/Thumbnail.png
```

Test via simulator, BTW **this never happen before**, just after migrate both `Swift` and `Alamofire` everything (you know what I mean) gone wrong.
 @katopz is it a ResponseSerializationFailureReason issue too?
Plus, the picture which are working/not working are always the same? Or does it change when you try to download them again?
 @Tulleb Here's 7 hrs later results

// First page

```
[Alamofire] download : https://0.s3.envato.com/files/47374385/akedodee_avatar.jpg
[Alamofire] download : https://preview-tf.s3.envato.com/files/202311201/Thumbnail.png
[Alamofire] failure : https://preview-tf.s3.envato.com/files/202311201/Thumbnail.png
[Alamofire] error : responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.inputFileReadFailed(file:///Users/katopz/Library/Developer/CoreSimulator/Devices/E22F2B6B-FF24-45E4-8FA6-6028FF89AA8A/data/Containers/Data/Application/EF57E55A-FDEE-4683-9AA1-C46BECD69DD5/tmp/CFNetworkDownload_3HGEhQ.tmp))
[Alamofire] failure : https://0.s3.envato.com/files/47374385/akedodee_avatar.jpg
[Alamofire] error : responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.inputFileReadFailed(file:///Users/katopz/Library/Developer/CoreSimulator/Devices/E22F2B6B-FF24-45E4-8FA6-6028FF89AA8A/data/Containers/Data/Application/EF57E55A-FDEE-4683-9AA1-C46BECD69DD5/tmp/CFNetworkDownload_kOpQFs.tmp))
```

// Wait for a while Click and go to second page

```
[Alamofire] download : https://preview-tf.s3.envato.com/files/126954540/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/198807153/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/128581452/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/148293837/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/130631924/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/128056772/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/68729806/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/134305582/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/135205962/Thumbnail.png
[Alamofire] success : https://preview-tf.s3.envato.com/files/198807153/Thumbnail.png
[Alamofire] failure : https://preview-tf.s3.envato.com/files/130631924/Thumbnail.png
[Alamofire] error : responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.inputFileReadFailed(file:///Users/katopz/Library/Developer/CoreSimulator/Devices/E22F2B6B-FF24-45E4-8FA6-6028FF89AA8A/data/Containers/Data/Application/EF57E55A-FDEE-4683-9AA1-C46BECD69DD5/tmp/CFNetworkDownload_csuAV9.tmp))
[Alamofire] failure : https://preview-tf.s3.envato.com/files/148293837/Thumbnail.png
[Alamofire] error : responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.inputFileReadFailed(file:///Users/katopz/Library/Developer/CoreSimulator/Devices/E22F2B6B-FF24-45E4-8FA6-6028FF89AA8A/data/Containers/Data/Application/EF57E55A-FDEE-4683-9AA1-C46BECD69DD5/tmp/CFNetworkDownload_5GdHjl.tmp))
[Alamofire] download : https://preview-tf.s3.envato.com/files/126954540/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/198807153/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/128581452/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/148293837/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/130631924/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/128056772/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/68729806/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/134305582/Thumbnail.png
[Alamofire] download : https://preview-tf.s3.envato.com/files/135205962/Thumbnail.png
[Alamofire] failure : https://preview-tf.s3.envato.com/files/128056772/Thumbnail.png
[Alamofire] error : responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.inputFileReadFailed(file:///Users/katopz/Library/Developer/CoreSimulator/Devices/E22F2B6B-FF24-45E4-8FA6-6028FF89AA8A/data/Containers/Data/Application/EF57E55A-FDEE-4683-9AA1-C46BECD69DD5/tmp/CFNetworkDownload_AT2GKj.tmp))
[Alamofire] failure : https://preview-tf.s3.envato.com/files/68729806/Thumbnail.png
[Alamofire] error : responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.inputFileReadFailed(file:///Users/katopz/Library/Developer/CoreSimulator/Devices/E22F2B6B-FF24-45E4-8FA6-6028FF89AA8A/data/Containers/Data/Application/EF57E55A-FDEE-4683-9AA1-C46BECD69DD5/tmp/CFNetworkDownload_5RRaCL.tmp))
[Alamofire] failure : https://preview-tf.s3.envato.com/files/135205962/Thumbnail.png
[Alamofire] error : responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.inputFileReadFailed(file:///Users/katopz/Library/Developer/CoreSimulator/Devices/E22F2B6B-FF24-45E4-8FA6-6028FF89AA8A/data/Containers/Data/Application/EF57E55A-FDEE-4683-9AA1-C46BECD69DD5/tmp/CFNetworkDownload_xUtpSE.tmp))
[Alamofire] failure : https://preview-tf.s3.envato.com/files/126954540/Thumbnail.png
[Alamofire] error : responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.inputFileReadFailed(file:///Users/katopz/Library/Developer/CoreSimulator/Devices/E22F2B6B-FF24-45E4-8FA6-6028FF89AA8A/data/Containers/Data/Application/EF57E55A-FDEE-4683-9AA1-C46BECD69DD5/tmp/CFNetworkDownload_8nu8sb.tmp))
[Alamofire] failure : https://preview-tf.s3.envato.com/files/198807153/Thumbnail.png
[Alamofire] error : responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.inputFileReadFailed(file:///Users/katopz/Library/Developer/CoreSimulator/Devices/E22F2B6B-FF24-45E4-8FA6-6028FF89AA8A/data/Containers/Data/Application/EF57E55A-FDEE-4683-9AA1-C46BECD69DD5/tmp/CFNetworkDownload_Mx5IQS.tmp))
[Alamofire] failure : https://preview-tf.s3.envato.com/files/128581452/Thumbnail.png
[Alamofire] error : responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.inputFileReadFailed(file:///Users/katopz/Library/Developer/CoreSimulator/Devices/E22F2B6B-FF24-45E4-8FA6-6028FF89AA8A/data/Containers/Data/Application/EF57E55A-FDEE-4683-9AA1-C46BECD69DD5/tmp/CFNetworkDownload_oV4xjD.tmp))
[Alamofire] failure : https://preview-tf.s3.envato.com/files/148293837/Thumbnail.png
[Alamofire] error : responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.inputFileReadFailed(file:///Users/katopz/Library/Developer/CoreSimulator/Devices/E22F2B6B-FF24-45E4-8FA6-6028FF89AA8A/data/Containers/Data/Application/EF57E55A-FDEE-4683-9AA1-C46BECD69DD5/tmp/CFNetworkDownload_PGQyhr.tmp))
[Alamofire] failure : https://preview-tf.s3.envato.com/files/126954540/Thumbnail.png
[Alamofire] error : responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.inputFileReadFailed(file:///Users/katopz/Library/Developer/CoreSimulator/Devices/E22F2B6B-FF24-45E4-8FA6-6028FF89AA8A/data/Containers/Data/Application/EF57E55A-FDEE-4683-9AA1-C46BECD69DD5/tmp/CFNetworkDownload_hm7i4d.tmp))
[Alamofire] failure : https://preview-tf.s3.envato.com/files/130631924/Thumbnail.png
[Alamofire] error : responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.inputFileReadFailed(file:///Users/katopz/Library/Developer/CoreSimulator/Devices/E22F2B6B-FF24-45E4-8FA6-6028FF89AA8A/data/Containers/Data/Application/EF57E55A-FDEE-4683-9AA1-C46BECD69DD5/tmp/CFNetworkDownload_VpiYPk.tmp))
[Alamofire] failure : https://preview-tf.s3.envato.com/files/134305582/Thumbnail.png
[Alamofire] error : responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.inputFileReadFailed(file:///Users/katopz/Library/Developer/CoreSimulator/Devices/E22F2B6B-FF24-45E4-8FA6-6028FF89AA8A/data/Containers/Data/Application/EF57E55A-FDEE-4683-9AA1-C46BECD69DD5/tmp/CFNetworkDownload_sWPj6h.tmp))
[Alamofire] failure : https://preview-tf.s3.envato.com/files/68729806/Thumbnail.png
[Alamofire] error : responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.inputFileReadFailed(file:///Users/katopz/Library/Developer/CoreSimulator/Devices/E22F2B6B-FF24-45E4-8FA6-6028FF89AA8A/data/Containers/Data/Application/EF57E55A-FDEE-4683-9AA1-C46BECD69DD5/tmp/CFNetworkDownload_Thkfnl.tmp))
[Alamofire] failure : https://preview-tf.s3.envato.com/files/128056772/Thumbnail.png
[Alamofire] error : responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.inputFileReadFailed(file:///Users/katopz/Library/Developer/CoreSimulator/Devices/E22F2B6B-FF24-45E4-8FA6-6028FF89AA8A/data/Containers/Data/Application/EF57E55A-FDEE-4683-9AA1-C46BECD69DD5/tmp/CFNetworkDownload_OxyIf5.tmp))
[Alamofire] failure : https://preview-tf.s3.envato.com/files/134305582/Thumbnail.png
[Alamofire] error : responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.inputFileReadFailed(file:///Users/katopz/Library/Developer/CoreSimulator/Devices/E22F2B6B-FF24-45E4-8FA6-6028FF89AA8A/data/Containers/Data/Application/EF57E55A-FDEE-4683-9AA1-C46BECD69DD5/tmp/CFNetworkDownload_hgkxpi.tmp))
[Alamofire] failure : https://preview-tf.s3.envato.com/files/128581452/Thumbnail.png
[Alamofire] error : responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.inputFileReadFailed(file:///Users/katopz/Library/Developer/CoreSimulator/Devices/E22F2B6B-FF24-45E4-8FA6-6028FF89AA8A/data/Containers/Data/Application/EF57E55A-FDEE-4683-9AA1-C46BECD69DD5/tmp/CFNetworkDownload_dQuDpf.tmp))
[Alamofire] failure : https://preview-tf.s3.envato.com/files/135205962/Thumbnail.png
[Alamofire] error : responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.inputFileReadFailed(file:///Users/katopz/Library/Developer/CoreSimulator/Devices/E22F2B6B-FF24-45E4-8FA6-6028FF89AA8A/data/Containers/Data/Application/EF57E55A-FDEE-4683-9AA1-C46BECD69DD5/tmp/CFNetworkDownload_Cl2stR.tmp))
```

Seem like when we load same image e.g. `https://preview-tf.s3.envato.com/files/198807153/Thumbnail.png` can be both success and failed.

But anyhow 2 image at first page always failed for some reason.
Did it work on your machine?

Thanks
 @Tulleb FYI In my case simple load with `URLSession` is working just fine tho üç∞ 

``` swift
                let _url = NSURL(string: url) as! URL
                let dataTask = URLSession.shared.dataTask(with: _url) {
                    data, response, error in
                    if error == nil {
                        if let  data = data,
                            let image = UIImage(data: data) {
                            fulfill(image)
                        }
                    } else {
                        reject(error as! NSError)
                    }
                }
                dataTask.resume()
```
 Yes I presume I'll use good old `URLSession` if Alamofire support is too busy at the moment.
Thanks for your help @katopz!
 Thanks @cnoon 

We follow [README](https://github.com/Alamofire/Alamofire#downloading-data-to-a-file) which apparently suggest us to use download image.

From my noob point of view, Please add this to `README` 

```
Alamofire.request(url).responseData { response in
    guard let data = response.result.value else { return }
    let image = UIImage(data: data)
    print(image)
}
```

and everyone should be happy. :)

Thanks guys, You're awesome.
 @katopz says it all already.
Thanks a lot guys!!
 @cnoon 
So on `macOS` the `location` should not be removed after the delegate message returns?

but in my test result the file is also removed.

I think destination should be a required parameter. @cnoon thank for your info about it.

I've found a strangeness: with something requests you can have a forbidden access (403) but data is valid: 

**Debug console** during 403 forbidden with a valid response.result.value:
```
(lldb) po response.result.value
‚ñø Optional<Data>
  ‚ñø some : 0 bytes
    - count : 0
    ‚ñø pointer : 0x0000bad0
      - pointerValue : 47824
    - bytes : 0 elements
```

Anyway, I've solved with this code:

```
Alamofire.download(url, to :destination)
            .downloadProgress { progress in
                     print(progress)
            }
            .responseData { response in
                     let statusCode = response.response?.statusCode
                     if statusCode == 403 {  // here response.result.value is valid 
                           print("forbidden")
                     }
                     if let data = response.result.value {
                           let image = UIImage(data: data)  // 403 status code come here if I don't stop before..
                           print(image)
                     } else {
                           print("Data was invalid")
                     }
            }
}
```
There is another way to write this code? 

  Just migrated to
`pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :tag => '4.0.0'`
and also to the latest XCode 8 and it seems our HTTP headers are not working anymore. It was working on the last version before migrating. I double checked on the migration guide and it seems fine to me. Below are some code snippets

```
internal var sessionManager: SessionManager

override init() {
        sessionManager = Alamofire.SessionManager()
        super.init()
        initHeader()
    }

func initHeader() {
        var defaultHeaders: HTTPHeaders = Alamofire.SessionManager.default.session.configuration.httpAdditionalHeaders as! HTTPHeaders? ?? [:]
        if let token = UserDefaultStorage.sharedInstance.getToken() {
            defaultHeaders["Authorization"] = "Bearer " + token
        } else {
            defaultHeaders["Authorization"] = nil
        }
        let configuration = URLSessionConfiguration.default
        configuration.httpAdditionalHeaders = defaultHeaders
        sessionManager = Alamofire.SessionManager(configuration: configuration)
    }
```

Am I doing it correctly? Thanks in advance for the help
 I don't know about the `httpAdditionalHeaders` attribute but in your code `as! HTTPHeaders?` seems not to be a good practice..
Seems better to do a `as? HTTPHeaders`

If you had crash, that could be origin of the pb
 I removed the HTTPHeaders implementation and just 
`var defaultHeaders = Alamofire.SessionManager.default.session.configuration.httpAdditionalHeaders ?? [:]`
still the same result. I did not experience any crash, it's just the HTTP header is not picking up the parameters because the API is returning some error. Previous version it was working fine on production.
  XCode:Version 8.0 (8A218a) release
Alamofire:4.0.0
Cocoapods:1.1.0.rc.2

Podfile:
    source 'https://github.com/CocoaPods/Specs.git'
    platform :ios, '9.0'
    use_frameworks!
    inhibit_all_warnings!

<img width="1135" alt="screen shot 2016-09-14 at 5 55 12 pm" src="https://cloud.githubusercontent.com/assets/3182964/18507874/b3d15686-7aa4-11e6-8173-a33e566b0880.png">
 I am facing the same issue. I created a new project using `Xcode 8`, copy-pasted the content of `podfile` from another project here (created in `Xcode 7.3`). Installed pod.

Error:
_~/Pods/Alamofire/Source/AFError.swift:255:78: Definition conflicts with previous value_

Downgraded to `3.5`, got other set of errors.
**Edit -> Convert -> To Latest Swift Syntax**, still getting errors like

_~/Pods/Alamofire/Source/ParameterEncoding.swift:248:32: Editor placeholder in source file_

@hengchengfei can you please let me know how you got this fixed?

-Thanks
 make sure you running xcode 8 , check version of swift in terminal using 'xcrun swift -version' should be on Apple Swift Version 3.0 for Alamofire 4.0 to build .
 @userShak verified, I am using Xcode 8-GM + Swift 3

`/Developer/usr/bin/xcodebuild -version` 
Xcode 8.0
Build version 8A218a

`xcrun swift -version`
Apple Swift version 3.0 (swiftlang-800.0.46.2 clang-800.0.38)
Target: x86_64-apple-macosx10.9
 Same error here !
Any suggestion please ???
 @AnnieNinaJoyceV 
worked as follows:

<img width="694" alt="screen shot 2016-09-18 at 11 11 45 am" src="https://cloud.githubusercontent.com/assets/3182964/18612672/97e227c0-7d92-11e6-8eba-eaf05c8d4347.png">
<img width="824" alt="screen shot 2016-09-18 at 11 25 48 am" src="https://cloud.githubusercontent.com/assets/3182964/18612676/ab321074-7d92-11e6-99ce-7d502f7cb20b.png">
  I have to convert my project from XCode 7 to 8. But and i have following in my pod file:     pod 'Alamofire', '~> 4.0'

And i get this error on compilation.

‚ÄúUse Legacy Swift Language Version‚Äù (SWIFT_VERSION) is required to be configured correctly for targets which use Swift. Use the [Edit > Convert > To Current Swift Syntax‚Ä¶] menu to choose a Swift version or use the Build Settings editor to configure the build setting directly.

How to fix this.
 Have the same error
 Same here
 Have you tried this? http://stackoverflow.com/a/38466703/1054550

```
post_install do |installer|
    installer.pods_project.targets.each do |target|
        target.build_configurations.each do |config|
            config.build_settings['SWIFT_VERSION'] = '3.0'
        end
    end
  end
```
 Thanks! Worked for me. Hope there are no side-effects.
 I'm having the same issue and the above fix resulted in:

```
Module file was created by an older version of the compiler; rebuild 'Alamofire' and try again:
.../path/to/Alamofire.framework/Modules/Alamofire.swiftmodule/arm64.swiftmodule
```

Here's my Podfile if it helps..

```
platform :ios, '9.0'
use_frameworks!

target 'my-project' do

  pod 'Firebase'
  pod 'Firebase/Auth'
  pod 'Firebase/Messaging'
  pod 'ChameleonFramework/Swift', :git => 'https://github.com/ViccAlexander/Chameleon.git', :branch => 'swift3'
  pod 'SwiftyJSON', :git => 'https://github.com/acegreen/SwiftyJSON.git', :branch => 'swift3'
  pod 'Alamofire', '~> 4.0'

end

post_install do |installer|
  installer.pods_project.targets.each do |target|
    target.build_configurations.each do |config|
      config.build_settings['SWIFT_VERSION'] = '3.0'
    end
  end
end
```

EDIT: Seem to have fixed it by deleting my app's entry in DerivedData and cleaning the project
 Hi,
  I even deleted derived folder added above code in Podfile but still getting same error "‚ÄúUse Legacy Swift Language Version‚Äù (SWIFT_VERSION) is required to be configured correctly for targets which use Swift. Use the [Edit > Convert > To Current Swift Syntax‚Ä¶] menu to choose a Swift version or use the Build Settings editor to configure the build setting directly."

What exactly need to change? 

Thanks,
Amir
 @amirpervaiz086  update your cocoapods
1. `sudo gem install cocoapods --pre`
2. `pod install`
  when I run above command it says:

ERROR:  While executing gem ... (Errno::EPERM)
    Operation not permitted - /usr/bin/xcodeproj
 @mengheangrat my current pod version is 1.0.1
 update your pod version to 
1.1.0.rc.2
 <img width="325" alt="screen shot 2016-09-22 at 9 55 51 am" src="https://cloud.githubusercontent.com/assets/10340553/18735854/5c5f6e8a-80ab-11e6-83e3-cd8c56d79430.png">
 Hi @mengheangrat. I successfully upgraded to 1.1.0.rc.2 but when I run pod install it says this:

Setting up CocoaPods master repo
Unknown option: -C
usage: git [--version] [--help] [-c name=value]
           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]
           [-p|--paginate|--no-pager] [--no-replace-objects] [--bare]
           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]
           <command> [<args>]
[!] Unable to add a source with url `https://github.com/CocoaPods/Specs.git` named `master-1`.
You can try adding it manually in `~/.cocoapods/repos` or via `pod repo add`.
 it was never happened with pod 1.0.1. Any idea?
 use terminal 

> cd ~/.cocoapods/repos 
> cd master || if don't have should create by using `mkdir master`
> `git clone https://github.com/CocoaPods/Specs.git` into master folder
 thanks man. I manually installed but 'pod install' says:
 [!] Unable to add a source with url https://github.com/CocoaPods/Specs.git named master-1. so I renamed master folder to master-1 and now when I run 'pod install' its stuck on 'Setting up CocoaPods master repo..' on terminal. Seems like its taking time in setting up. let me know if I am doing it wrong.

Thanks.
 Yes, you have to wait it until finish, because it has big size.
 @amirpervaiz086 sudo gem install -n /usr/local/bin cocoapods --pre this worked for me.
 @mengheangrat thanks man. I waited for 15 mins and cancelled it since it didnt show any progress... but gonna try again now. I really need to fix it out. Thanks for your help. 
 @cnrblm yes it worked for me too. 
 @mengheangrat Still getting error when I run "Pod install"

RuntimeError - Unable to create a source with URL https://github.com/CocoaPods/Specs.git
/Library/Ruby/Gems/2.0.0/gems/cocoapods-1.1.0.rc.2/lib/cocoapods/sources_manager.rb:42:in `find_or_create_source_with_url'
/Library/Ruby/Gems/2.0.0/gems/cocoapods-1.1.0.rc.2/lib/cocoapods/installer/analyzer.rb:784:in`block in sources'
/Library/Ruby/Gems/2.0.0/gems/cocoapods-1.1.0.rc.2/lib/cocoapods/installer/analyzer.rb:783:in `map'
/Library/Ruby/Gems/2.0.0/gems/cocoapods-1.1.0.rc.2/lib/cocoapods/installer/analyzer.rb:783:in`sources'
/Library/Ruby/Gems/2.0.0/gems/cocoapods-1.1.0.rc.2/lib/cocoapods/installer.rb:143:in `resolve_dependencies'
/Library/Ruby/Gems/2.0.0/gems/cocoapods-1.1.0.rc.2/lib/cocoapods/installer.rb:110:in`install!'
/Library/Ruby/Gems/2.0.0/gems/cocoapods-1.1.0.rc.2/lib/cocoapods/command/install.rb:37:in `run'
/Library/Ruby/Gems/2.0.0/gems/claide-1.0.0/lib/claide/command.rb:334:in`run'
/Library/Ruby/Gems/2.0.0/gems/cocoapods-1.1.0.rc.2/lib/cocoapods/command.rb:50:in `run'
/Library/Ruby/Gems/2.0.0/gems/cocoapods-1.1.0.rc.2/bin/pod:55:in`<top (required)>'
/usr/local/bin/pod:23:in `load'
/usr/local/bin/pod:23:in`<main>'
 i try this , and it work for me.

platform :ios, '9.0'
use_frameworks!

target 'mkhPush' do
    pod 'Alamofire', '~> 3.3'
end

post_install do |installer|
  installer.pods_project.targets.each do |target|
    target.build_configurations.each do |config|
      config.build_settings['SWIFT_VERSION'] = '2.3'
    end
  end
end
 See this [link](https://medium.com/@ziminalex/xcode-8-0-cocoapods-95d8e7a769a9#.sb579owdm). He explains, what's going on in detail. And how to fix it.
 http://stackoverflow.com/questions/38446097/xcode-8-beta-3-use-legacy-swift-issue/40482708#40482708  @ostatnicky's solution worked for me too. happen to the same  problem!   must i update my cocoapods to 1.1.0 version to solve this problem?..
who can help me?  tks

OK!  i have solved it!  
you can read [SwiftÂºÄÂèë‰ΩøÁî®CocoapodsÂºïÂÖ•Á¨¨‰∏âÊñπÂ∫ìÂºÇÂ∏∏Â§ÑÁêÜÊñπÊ≥ï](http://www.jianshu.com/p/23f13be525a0) I just do Edit->Convert->Current Swift Syntax and error has gone. I did't make any changes in code or Xcode.

It works for me.  Tried to install pod with `CocoaPods 1.1.0.rc.2`, running `Xcode Version 8.0 (8A218a)`

Error:

```
Ld /Users/Robert/Library/Developer/Xcode/DerivedData/SnapMeApp-bdhntvipgfszuvbselinvxhsyxnk/Build/Products/Debug-iphonesimulator/Alamofire/Alamofire.framework/Alamofire normal x86_64
    cd /Users/Robert/Documents/Workspace/snapmeapp/ios/Pods
    export IPHONEOS_DEPLOYMENT_TARGET=8.0
    export PATH="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -arch x86_64 -dynamiclib -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator10.0.sdk -L/Users/Robert/Library/Developer/Xcode/DerivedData/SnapMeApp-bdhntvipgfszuvbselinvxhsyxnk/Build/Products/Debug-iphonesimulator/Alamofire -F/Users/Robert/Library/Developer/Xcode/DerivedData/SnapMeApp-bdhntvipgfszuvbselinvxhsyxnk/Build/Products/Debug-iphonesimulator/Alamofire -filelist /Users/Robert/Library/Developer/Xcode/DerivedData/SnapMeApp-bdhntvipgfszuvbselinvxhsyxnk/Build/Intermediates/Pods.build/Debug-iphonesimulator/Alamofire.build/Objects-normal/x86_64/Alamofire.LinkFileList -install_name @rpath/Alamofire.framework/Alamofire -Xlinker -rpath -Xlinker @executable_path/Frameworks -Xlinker -rpath -Xlinker @loader_path/Frameworks -mios-simulator-version-min=8.0 -Xlinker -object_path_lto -Xlinker /Users/Robert/Library/Developer/Xcode/DerivedData/SnapMeApp-bdhntvipgfszuvbselinvxhsyxnk/Build/Intermediates/Pods.build/Debug-iphonesimulator/Alamofire.build/Objects-normal/x86_64/Alamofire_lto.o -Xlinker -export_dynamic -Xlinker -no_deduplicate -Xlinker -objc_abi_version -Xlinker 2 -fobjc-arc -fobjc-link-runtime -fapplication-extension -L/Applications/Xcode.app/Contents/Developer/Toolchains/Swift_2.3.xctoolchain/usr/lib/swift/iphonesimulator -Xlinker -add_ast_path -Xlinker /Users/Robert/Library/Developer/Xcode/DerivedData/SnapMeApp-bdhntvipgfszuvbselinvxhsyxnk/Build/Intermediates/Pods.build/Debug-iphonesimulator/Alamofire.build/Objects-normal/x86_64/Alamofire.swiftmodule -framework Foundation -single_module -compatibility_version 1 -current_version 1 -Xlinker -dependency_info -Xlinker /Users/Robert/Library/Developer/Xcode/DerivedData/SnapMeApp-bdhntvipgfszuvbselinvxhsyxnk/Build/Intermediates/Pods.build/Debug-iphonesimulator/Alamofire.build/Objects-normal/x86_64/Alamofire_dependency_info.dat -o /Users/Robert/Library/Developer/Xcode/DerivedData/SnapMeApp-bdhntvipgfszuvbselinvxhsyxnk/Build/Products/Debug-iphonesimulator/Alamofire/Alamofire.framework/Alamofire
```

> **ld: framework not found Foundation
> clang: error: linker command failed with exit code 1 (use -v to see invocation)**

![screen shot 2016-09-14 at 11 54 31](https://cloud.githubusercontent.com/assets/446619/18507772/1252c9de-7a72-11e6-81ab-25563a9e37dc.png)

Update:
The same issue appears to happen with Alamofire 4.0.0.

This Issue is reproducible by just creating a new project and adding just Alamofire to the Podfile.
 [TestProject.zip](https://github.com/Alamofire/Alamofire/files/471803/TestProject.zip)
Here is a project that reproduces this issue.
 @jshier Sorry about that. Thanks for trying the test project!
 @RobertBiehl 

The test project builds successful for me, but my original project i am getting the same issue which you mentioned, finally I fix it simply go to build settings then search Framework Search Paths

Add: $(CONFIGURATION_BUILD_DIR) and select recursive

Hope this helps you.
  How to use Alamofire 4.0(swift3.0) on IOS8?
my app's Deployment Target is 8.0,but i want use swift3.0 and Alamofire.how can i do?
 From the 4.0 Migration Guide;

> iOS and tvOS 9.0+, macOS 10.11.0+, watchOS 2.0+
> Xcode 8.0+
> Swift 3.0+
> 
> For those of you that would like to use Alamofire on iOS 8 or macOS 10.9, please use the latest tagged 3.x release which supports both Swift 2.2 and 2.3.
 So there is no Alamofire version that supports both, iOS 8 and Swift 3.0?
 Since Swift 3 is compatible with iOS 8, I do not understand why Alamofire made iOS 9 the minimum deploy target. Seems like a mistake.
 I'm trying to do exactly the above Xcode 8, Alamofire 3.5.0 via Cocoapods, set 'use legacy swift version' to yes and I get:

sanitize=address' is not supported on the Swift 2.3 toolchain

Any ideas please?
 Please ignore that. It seems I had to turn off address sanitiser within the scheme to get it to compile.
 @yn288163 For Swift 3, you can use this https://github.com/onmyway133/Alamofire/tree/fix/ios_8. I removed the stream delegate
 Target IOS 8, you can try this, https://github.com/tonyli508/AlamofireDomain
 I can use Alamorfire 4.0 with swift 3 and iOS8+ by use submodule:

Manually
If you prefer not to use either of the aforementioned dependency managers, you can integrate Alamofire into your project manually.

Embedded Framework

Open up Terminal, cd into your top-level project directory, and run the following command "if" your project is not initialized as a git repository:

$ git init
Add Alamofire as a git submodule by running the following command:

$ git submodule add https://github.com/Alamofire/Alamofire.git
Open the new Alamofire folder, and drag the Alamofire.xcodeproj into the Project Navigator of your application's Xcode project.

It should appear nested underneath your application's blue project icon. Whether it is above or below all the other Xcode groups does not matter.
Select the Alamofire.xcodeproj in the Project Navigator and verify the deployment target matches that of your application target.

Next, select your application project in the Project Navigator (blue project icon) to navigate to the target configuration window and select the application target under the "Targets" heading in the sidebar.
In the tab bar at the top of that window, open the "General" panel.
Click on the + button under the "Embedded Binaries" section.
You will see two different Alamofire.xcodeproj folders each with two different versions of the Alamofire.framework nested inside a Products folder.

It does not matter which Products folder you choose from, but it does matter whether you choose the top or bottom Alamofire.framework.
Select the top Alamofire.framework for iOS and the bottom one for OS X.

You can verify which one you selected by inspecting the build log for your project. The build target for Alamofire will be listed as either Alamofire iOS, Alamofire macOS, Alamofire tvOS or Alamofire watchOS.
And that's it!

The Alamofire.framework is automagically added as a target dependency, linked framework and embedded framework in a copy files build phase which is all you need to build on the simulator and a device.

- see on Manual Setup:
Link: https://github.com/Alamofire/Alamofire  Hello.

I'm trying to do an upload with Alamofire using this code (where `photo.image` is a `UIImage`)

``` swift
let imageData = UIImageJPEGRepresentation(photo.image, 1.0)

Alamofire.upload(
    multipartFormData: { multipartFormData in
        multipartFormData.append(data: imageData!, withName: "unicorn")
    },
    to: "https://httpbin.org/post",
    encodingCompletion: { encodingResult in
        switch encodingResult {
        case .success(let upload, _, _):
            upload.responseJSON { response in
                debugPrint(response)
            }
        case .failure(let encodingError):
            print(encodingError)
        }
    }
)
```

However, this tells me "Expression type '()' is ambiguous without more context.

I am confused as to what the right way to do this is and I think there should be an example of how to do this kind of upload in the README. I consider this as a kind of "documentation bug", which is why I'm filing an issue rather than asking the question on Stack Overflow.

Could you please add an example of this sort of upload to the README so that I and others can learn from that example?

Thank you.
 Same issue here :) 
 I have a related question: with v3 of Alamofire, we could receive regular "progress" callbacks during a multipart form data file upload. I'm not 100% clear on how we achieve that now, and couldn't find a documentation example. Is the following adaptation of radar's code the correct way to request .uploadProgress() callbacks during a multipart form data upload?

```
Alamofire.upload(multipartFormData: { multipartFormData in
    multipartFormData.append(data: imageData!, withName: "unicorn")
},
to: "https://httpbin.org/post",
encodingCompletion: { encodingResult in
    switch encodingResult {
    case .success(let upload, _, _):
        upload.uploadProgress{ progress in
            // Update progress indicator
        }.responseJSON { response in
            debugPrint(response)
        }
    case .failure(let encodingError):
        print(encodingError)
    }
})
```
 Same here :) , does anyone have any pointers?
 Thanks cnoon, but my question was about how/where to specify the .uploadProgress closure. In v3 of Alamofire, the .upload(multipartFormData:) method returned a request, to which you could then append .progress{ } closures. In v4, the Alamofire.upload(multipartFormData:) method doesn't have a return value. So I'm unsure how or where to specify the .uploadProgress{} closure.

Can you please point me in the right direction? Many thanks!
 Many thanks, cnoon!
 Thanks @cnoon for your help here :)
 Hey i am using Alamofire 4.0 image uploading is done successfully with the following code but i am unable to send parameters with image. Please help me.

let imageData = UIImagePNGRepresentation(self.signatureImgView.image!)

let defaultHTTPHeaders: HTTPHeaders = [
"token": "F3pObDt2G832hfAaBhZDHekNHUhT62URXPApKkfPQBb9enSy",
"Accept": "application/json",
]

let URL2 = try! URLRequest(url: "http://52.66..........", method: .post, headers: defaultHTTPHeaders)

Alamofire.upload(multipartFormData: { (multipartFormData) in

multipartFormData.append(imageData!, withName: "signImg", fileName: "picture.png", mimeType: "image/png")

// for (key, value) in self.parameters {
// multipartFormData.append(value.data(using: String.Encoding.utf8)!, withName: key)
// }
}, with: URL2, encodingCompletion: { (result) in

switch result {
case .success(let upload, _, _):

upload.responseJSON
{
response in

print(response.request) // original URL request
print(response.response) // URL response
print(response.data) // server data
print(response.result) // result of response serialization

if let JSON = response.result.value
{
print("JSON: (JSON)")
}
}

case .failure(let encodingError):
print(encodingError)

}

})
}

even i tried for(key, value) in parameters 
multipartFormData.append(parameters.data(using: "ap_type".Encoding.utf8)!, withName: value)
still it's not working
  Hi,

I hit the error on below on Xcode 8, can you help to solve it.
My application need to support iOS 8 and above.

> Alamofiire will not be code signed because its settings don't specify a development team.
> ‚ÄúUse Legacy Swift Language Version‚Äù (SWIFT_VERSION) is required to be configured correctly for targets which use Swift. Use the [Edit > Convert > To Current Swift Syntax‚Ä¶] menu to choose a Swift version or use the Build Settings editor to configure the build setting directly.

Thanks
 @Canmmy http://stackoverflow.com/a/38466703/2854405 this answer might help you.
  This is the pull request corresponding to #1506.
1. Rename target `Alamofire OSX` to `Alamofire macOS`.
2. Rename target `Alamofire OSX Tests` to `Alamofire macOS Tests`.
3. Rename scheme `Alamofire OSX` to `Alamofire macOS`.
4. Replace `os(OSX)` with `os(macOS)`.
5. Update README.md.
6. Update CONTRIBUTING.md.
7. Update .travis.yml (also change `xcpretty -c` to `xcpretty` since `-c` is the default argument).
8. User agent's OS version is NOT changed (still `OS X`). 

`AlamofireNetworkActivityIndicator`: no change needed
`AlamofireImage`: https://github.com/Alamofire/AlamofireImage/pull/181
  if i want to use my project with swift 2.3 together with Alamofire SDK (that is installed through Cocoapods), what should i do when i open Xcode and it asks me to convert Alamofire.framework to swift 2.3?
 still asks me to upgrade it.
 @jshier any advice?
 actually after installing AF 4.0, it also asks to convert AF's swift framework to swift 3.0

what am i doing wrong here?
  I'm new to Alamofire and I'm trying to start out with 4.0 but all the tutorials out there explaining the router pattern are now not applicable and I'm a little lost as a newb. In the guide it says that router patterns will need to change:

> You will now implement the asURLRequest method instead of the property which gives you the ability to throw an error if necessary

 Is there a possibility that an example could be provided for people as a reference to change over their router designs to use the new `asURLRequest` method?
  After pulling updates from repository i can no longer build. I get a ton of errors which all appear to be related to swift 3. On a Stack Overflow post i found this pertaining to the swift "open" keyword: "It is available with the Swift 3 snapshot from August 7, 2016, and with Xcode 8 beta 6." I am assuming that it is not building because I am not running xcode 8 beta 6.   

Currently using "Commit: 8ac0e19".

EDIT: 
I apologize for my ignorance. I just looked at the requirements in the README and im clearly not meeting the requirement of xcode 8+.
Since i am unable to update to xcode 8 as it is not publicly available Is there a place that shows a commit i can go back to, in order to keep using Alamofire with xcode 7.3.1 for now?
 try this [https://github.com/Alamofire/Alamofire/releases/tag/3.4.2](url)
 Thanks that release worked.
 @jshier thank you. I will checkout 3.5.x instead
  hello guys
Just upgraded for Alamofire 4 in Xcode 8 and Swift 3 and this issue started to happen

var alamoFireManager : Alamofire.Manager?
On this line
No type named 'Manager' in module 'Alamofire'
Tried to look all around in stackoverflow and many others sources with no success. Is there an upgrade issue ?

Thanks
 @jshier i'm having both error.
Changed to `SessionManager` and now have: No type named 'SessionManger' in module 'Alamofire' Yes, you will get the error if you just blindly copy and paste from the internet.

Try **SessionManager** not SessionManger  Typo: Reponse -> Response
  In the 3.x we could get progress for downloads and in the closure we would get:  bytesRead, totalBytesRead, totalBytesExpectedToRead

And for upload: bytesWritten, totalBytesWritten, totalBytesExpectedToWrite

In 4.0 we have a uploadProgress and downloadProgress which both take  the new progress Handler. Is fractionCompleted the only thing on that object or can we still get access to the same values as before. I would often use them to calculate fraction completed but it was also nice to know the totalBytesReadOrWritten and totalBytesExpectedToReadOrWrite.

Any way to still get those values in 4.0?
 I see those overrides were removed here: 

Is there a way to use the new Progress API to still get those values?

https://github.com/Alamofire/Alamofire/commit/91208b44be53a1fff81c344e848a2fb009da7274
 I'll take a look at those two. Thanks!
 They worked perfectly. I have no need for the other closure style. Thanks @jshier. This new release rocks.
  My app uses the Twitter User Streams API, and previously I'd been using NSURLConnection, which Xcode warns me has been deprecated, and that I should instead be using NSURLSession. I'd been setup to use it like so:

```
func startStreaming() {
    let client = TWTRAPIClient(userID: self.twitterSession.userID)

    let request = client.URLRequestWithMethod(
        "GET",
        URL: "https://userstream.twitter.com/1.1/user.json",
        parameters: parameters,
        error: &error)
    let mutableRequest = request.mutableCopy() as! NSMutableURLRequest
    mutableRequest.timeoutInterval = 20
    self.urlConnection = NSURLConnection(request: mutableRequest, delegate: self, startImmediately: false)
    self.urlConnection!.start()
}

func connection(connection: NSURLConnection, didReceiveData data: NSData) {
    print("did receive data")
}
```

TWTRAPIClient builds the NSURLRequest with appropriate headers to be a valid API call.

I've decided to move to doing this via NSURLSession and using Alamofire, which I use for all other API calls and downloads in my app. So far my code looks like this:

```
func startStreaming() {
    let client = TWTRAPIClient(userID: twitterSession.userID)

    let parameters: Dictionary<String, AnyObject> = Dictionary()
    var error: NSError?
    let request = client.URLRequestWithMethod(
        "GET",
        URL: "https://userstream.twitter.com/1.1/user.json",
        parameters: parameters,
        error: &error)

    let sessionConfig = NSURLSessionConfiguration.defaultSessionConfiguration()
    let session = NSURLSession(configuration: sessionConfig, delegate: self, delegateQueue: nil)        
    self.alamofireManager = Alamofire.Manager(session: session, delegate: self)!
    self.alamofireRequest = self.alamofireManager!.request(request)

    self.alamofireRequestStream = self.alamofireRequest!.stream {
        (data) in
        print("did receive data")
    }
}

override func URLSession(session: NSURLSession, task: NSURLSessionTask, didCompleteWithError error: NSError?) {
    super.URLSession(session, task: task, didCompleteWithError: error)
    print("url session task did complete with error: \(error)")
}
```

I'm using properties for the request and stream, just to make sure nothing is being de-allocated. The result is that I get the initial data that Twitter sends after starting a stream, but a few seconds after that, I get this timeout error:

> url session task did complete with error: Optional(Error Domain=NSURLErrorDomain Code=-1001 "The request timed out." UserInfo={NSUnderlyingError=0x7f87d9570960 {Error Domain=kCFErrorDomainCFNetwork Code=-1001 "(null)" UserInfo={_kCFStreamErrorCodeKey=-2102, _kCFStreamErrorDomainKey=4}}, NSErrorFailingURLStringKey=https://userstream.twitter.com/1.1/user.json, NSErrorFailingURLKey=https://userstream.twitter.com/1.1/user.json, _kCFStreamErrorDomainKey=4, _kCFStreamErrorCodeKey=-2102, NSLocalizedDescription=The request timed out.})

I've tried setting the timeout intervals for the `sessionConfig`, but those default values are quite high anyway (7 days and 60 seconds), where I'm getting this timeout after about 10 seconds.
  I run test of Alamofire OS X on my Mac, and the code deleted the whole of `applicationSupportDirectory` of macOS. And then üí• 

So I think we need to consider more about those code, and take care of it on different platforms.
https://github.com/Alamofire/Alamofire/blob/master/Tests/BaseTestCase.swift#L35-L37

``` swift
FileManager.removeAllItemsInsideDirectory(atPath: FileManager.applicationSupportDirectoryPath)
FileManager.removeAllItemsInsideDirectory(atPath: FileManager.cachesDirectoryPath)
FileManager.removeAllItemsInsideDirectory(atPath: FileManager.documentsDirectoryPath)
```
 @cnoon üëç 
  Hi,

I updated my code to use version 4.0
Now I have a Problem, with uploadProgress within a MultipartUpload

Here is the shortened code:

```
Alamofire.upload(multipartFormData: { (multipartFormData) in

// handle multipart data

}, to: url) { (encodingResult) in

    switch encodingResult {
    case .success(let upload, _, _):
        upload.uploadProgress(closure: { (progressData:Progress) in
            print(progressData.fractionCompleted)
        })

        upload.responseObject(completionHandler: { (response: DataResponse<ResponseJson>) in
            // handle response
        })
    case .failure(_):
        // handle failure
    }
}
```

With that, "progressData.fractionCompleted" always goes up to only 0.5...
Tests with Version 3.0 against the same server is working fine.

Thanks,
Stefan
    I'm trying to use Alamofire 4 through Cocoapods. However when I install it, XCode 8 still thinks it needs upgrading. 

Looks like the pod spec is not setting up the target correctly.
 Use:

```
gem install cocoapods --pre 
```

As of today worked for me. 
 Yep. Had to go to pre-release version of CocoaPods.
  This line doesn't work on 4.0.0:

`Alamofire.request("https://httpbin.org/post", method: .post, parameters: [], encoding: JSONEncoding.default)`

I get "Extra argument 'method' in call" error.
I'm using XCode8 GM and your latest version.
 First of all : don't post this here, post it on Stack Overflow and tag it with Alamofire (I'm also monitoring those so you'd get the same answer but others could see it). As stated in the README, Github is for **bugs** and this isn't one.
Anyhow : `parameters` is of type `Parameters?` aka `[String : Any]?` and therefore giving it `[]` aka an empty `Array` is wrong (I'll admit that the error message is very misleading). You can write `parameters: [:]` (empty `Dictionary`), write `nil` or leave the whole `parameters` part out.
 I'm getting the same issue, with the same error message ("Extra argument 'method' in call"), with correct `parameters:` syntax. The exact same argument structure worked before the latest project update. Are you sure this shouldn't be noted as a bug?

`Alamofire.request("https://servername.org/post", method: .post, parameters: [:], encoding: JSONEncoding.default)`
 I'm quite sure, because I'm able to reproduce the issue and fix it with all three options I presented. Nevertheless, I'm happy to help you out if you could post the surrounding code to reproduce the issue with `parameters: [:]`. And truthfully, I believe leaving out the `parameters:` part is the most elegant way IMO. Are you using the Alamofire 4.0.0 **release**?
 @thebluepotato  Thanks for clarifying when to use Stackoverflow and when to use GitHub.

Turns out my original error was that I was trying to pass a URLRequest and not a URLConvertible. While reproducing I ended up with the string i presented when creating this topic which only led to more confusion. But now it works for me. Thank you.
 If you can give a hand even though the issue belongs on Stackoverflow, I truly appreciate it - here's the code I'm running (using Alamofire 4.0.0):

`Alamofire.request("http://\(ipAddr)/YamahaRemoteControl/ctrl", method: .post, parameters: [:], encoding: .custom({
        (convertible, params) in
        var mutableRequest = convertible.urlRequest as URLRequest
        mutableRequest.httpBody = "<YAMAHA_AV cmd=\"PUT\"><Main_Zone><Input><Input_Sel>\(input)</Input_Sel></Input></Main_Zone></YAMAHA_AV>".data(using: String.Encoding.utf8, allowLossyConversion: false)
        return (mutableRequest, nil)
        }
        ))`

The request sends a UTF8 string to an AV receiver to control the input, volume etc, depending on the content of the string. The code above results in the "Extra argument 'method' in call" error whether I include the `parameters: [:]` argument or not.

I used the exact same code successfully yesterday, using the swift3 branch via Cocoapods.
 @otherbuns Any time one argument is of the wrong type, the Swift interpreter here believes that you're wrongly using `request(urlRequest:URLRequestConvertible)` and therefore believes there's an extra `method:` argument.
What you should have done is **read the release notes**. Because one of the very last-minute and very nice additions to 4.0.0 is the `ParameterEncoding` protocol. More info here #1465 and here https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%204.0%20Migration%20Guide.md#parameter-encoding-protocol and mostly here https://github.com/Alamofire/Alamofire/#custom-encoding. Basically, you have to write your own struct conforming to ParameterEncoding with a function returning the encoded parameters.
EDIT: Oh well, I'm too slow to type üòÖ, already closed!
 Now that you point it out, I really wonder how I managed to miss it. Thanks a lot for your help, even if the answer was right before my nose!
 @thebluepotato Thank you for clarifying about Swift's non helpful response.

My issue was that Alamofire will not accept parameters which are arrays of the form `[1,2,3]`, they have to be dictionaries like `["list": [1,2,3]]`.
 Hi, guys. I should must use array value([Int]) for parameter. How to solve my problem?
Please help me.
 Hi Guys:
I also meet Extra argument 'method' in call, still cannot find one solution.
 This one worked for me. 
No need to remove encoding parameter

Swift 3.0

Alamofire.request("https://yourServiceURL.com", method: .post, parameters: parameters, encoding: JSONEncoding.default, headers: nil).responseJSON { (response:DataResponse<Any>) in

        switch(response.result) {
        case .success(_):
            if let data = response.result.value{
                print(response.result.value)
            }
            break

        case .failure(_):
            print(response.result.error)
            break

        }
    }
and make sure that the parameters are of type

[String:Any]?
In case of Get

Alamofire.request("https://yourGetURL.com", method: .get, parameters: ["":""], encoding: URLEncoding.default, headers: nil).responseJSON { (response:DataResponse<Any>) in

        switch(response.result) {
        case .success(_):
            if let data = response.result.value{
                print(response.result.value)
            }
            break

        case .failure(_):
            print(response.result.error)
            break

        }
    }
Even works with

JSONEncoding.default 
For Headers

If you are passing headers, make sure their type should be [String:String]

Go through the Parameter Encoding Link https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%204.0%20Migration%20Guide.md#parameter-encoding-protocol

 @cnoon I'm having the same problem. I read the doc and added extra struct as suggested in the readingMe.
//Add below two struct for data upload efficiency test
struct JSONDocumentArrayEncoding: ParameterEncoding {
    private let array: [Document]
    init(array:[Document]) {
        self.array = array
    }
    func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -> URLRequest {
        var urlRequest = urlRequest.urlRequest
        
        let data = try JSONSerialization.data(withJSONObject: array, options: [])
        
        if urlRequest!.value(forHTTPHeaderField: "Content-Type") == nil {
            urlRequest!.setValue("application/json", forHTTPHeaderField: "Content-Type")
        }
        
        urlRequest!.httpBody = data
        
        return urlRequest!
    }
}
Then use this method for request using Alamofire.SessionManager as custom manager, parameter is an array of document object. The purpose of this custom encoding is to encode the array of objects.

request = customAlamofireManager.request(
            ServerURL,
            method: .post,
            parameters: [documents],
            encoding: JSONDocumentArrayEncoding,
            headers: headers
        )
        request!.validate{ request, response, data in
            return .success
            }
            .responseJSON { 

Same error, because param is not a dictionary. However there need a way to pass in this array param. I'm also having another Struct to make Gzip array of objects. I get the same error as this one. There must be a way to pass in body data for encode.
Thanks @thebluepotato Did as same as the instruction suggested, but how to pass in the array parameter? Thanks Answer my own question here, find a way to pass in custom encoded request to Alamofire.DataRequest to escape the above mentioned method with parameters, which is not used anyway.
  func uploadBatchDocumentsWithDocs(_ documents: [Any]) {
        let headers = NetworkManager.sharedInstance.headers
         var urlRequest = URLRequest(url: URL(string: (ServerURL + Api))!)
         urlRequest.httpMethod = "post"
         urlRequest.allHTTPHeaderFields = headers
         let jsonArrayencoding = JSONDocumentArrayEncoding(array: documents)           
         let jsonAryEncodedRequest = try? jsonArrayencoding.encode(urlRequest, with: nil)

        var request: Alamofire.DataRequest? = customAlamofireManager.request(jsonAryEncodedRequest!)
        request?.validate{request, response, data in
            return .success
            }
            .responseJSON {
...
} FTR, this happened to me when i was using an optional variable in the parameters attribute
variable?.toJSON() @popsware You can use the method I mentioned above to avoid that. It works.  Hi,
I have installed you library with Cocoapods (1.0.0) with this command:
pod 'Alamofire', '~> 4.0'
and when i tried to open my project, XCode 8 (beta 6) displayed popup to convert your code to swift 3.0.
After conversion to swift 3.0 , received errors on your files:

Validation.swift:164:41: @escaping attribute only applies to function types
Request.swift:392:85: @escaping attribute only applies to function types
...

I removed all @escaping word and now build succeeded.

Could you please fixed this issue.
Thanks.
 I had the same issue
 fresh install with Xcode 8 GM, cocoapod 1.1.0 rc1, in a swift 3 project, all correct now.
 @RebeccaB89 & @loryhuz : Could you please run `sudo gem update cocoapods --pre` to get 1.1.0.rc1 and try again? Cocoapods 1.0.0 doesn't handle Swift 3.0 correctly, i.e. it doesn't tell Xcode that the Pods are already written in Swift 3.0.
 I am using Xcode 8 GM, ran pod install with 1.1.0.rc1 version of cocoapods still getting the same error. Yes, I also did run the pod repo update command as well. Please see the attached picture
![screen shot 2016-09-11 at 1 55 11 pm](https://cloud.githubusercontent.com/assets/13564400/18420446/b3ea9ed6-7827-11e6-8732-bf62b0461a37.png)
 @kthotav How are you getting the compile errors? It seems Alamofire isn't even installed yet... Try running `pod repo update`. Now that Alamofire 4.0.0 has been released, it _is_ in the Master repo and shouldn't have issues being found.
 @thebluepotato  yes, I already did run 'pod repo update'. Same issues. 
 @kthotav Sorry if I'm insisting but are you sure you're having the issues as the OP? To get Alamofire to install, try removing the source line in your Podfile. If it still fails, write `pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :tag => '4.0.0'`
 I ran `pod cache clean --all` and also `rm -rf Pods`. I still get the same error (still using 1.1.0.rc1)  Please see the attached image. 
![screen shot 2016-09-11 at 3 45 21 pm](https://cloud.githubusercontent.com/assets/13564400/18421118/d3023f68-7836-11e6-808b-9562a393c2e4.png)
 Same for me ‚Äî Xcode says Alamofire contains swift 2.3 code, but I have Alamofire 4.0.0 installed.

What I've tried:
- Removing Pods folder;
- Removing workspace;
- Executing `pod repo update`;
- Executing `pod cache clean --all`.

What I'm using:
- macOS 10.12 GM (16A320) [Sierra];
- CocoaPods 1.1.0 rc1;
- Xcode 8.0 GM (8A218a).

What's more interesting, creating empty project and integrating Alamofire in it gives no errors. So I can say it's config-related issue, but I can't say what is it exactly.

I'll appreciate if you say what exactly to compare between my projects.
 Hi @thebluepotato,

Why did you closed the issue if it still happen?
When i download you library (ZIP file) without cocoapods, and open your IOS example project i receive the same errors (need to remove @escaping word)
Thanks.
 Looks like a Swift bug (https://bugs.swift.org/browse/SR-2522) where `@escaping` type aliases throw at compile.

While the issue has been resolved, I‚Äôm not quite sure how to update Swift from its repo.
 Yup, sorry for not being clear about the issue not being related to Alamofire. Saw the Xcode GM release a few minutes ago, currently downloading. Would‚Äôve edited my comment for future readers, but thanks for the follow up üëç 
 Thanks, fixed with Xcode 8 production.
  Affected places:
1. Target name (shared scheme): `Alamofire OSX` to `Alamofire macOS`.
2. `.travis.yml`: `OSX_FRAMEWORK_SCHEME="Alamofire OSX"` to `MACOS_FRAMEWORK_SCHEME="Alamofire macOS"`. PS: `xcpretty -c` can remove `-c` since it is now the default option.
3. Other places: `os(OSX)` to `os(macOS)`.
4. I'm not sure if [this](https://github.com/Alamofire/Alamofire/blob/e50160acda93a4309dc862fcbec32602cf805528/Source/SessionManager.swift#L87) needs to be updated.
  "- `Request.UploadTaskDelegate` is now `UploadTaskDelegate`" is removed
  - `Alamofire (~> 4.0)` required by `Podfile`

None of your spec sources contain a spec satisfying the dependency: `Alamofire (~> 4.0)`.

You have either:
- out-of-date source repos which you can update with `pod repo update`.
- mistyped the name or version.
- not added the source repo that hosts the Podspec to your Podfile.

How can I fix this? Thanks.
 Same problem here.
 NB : this is not a bug, more like a question that ~~could~~ **should** be asked on Stack Overflow, tagged with `alamofire`. Anyhow, that's an easy answer : how could Cocoapods get Alamofire 4.0 if it hasn't been released yet? It's still beta so even though the podspec says 4.0.0, there's no 4.0.0 tag yet!
TL;DR : write `pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'master'`
 @thebluepotato Thank you for the explanations. 
  The file was likely renamed without the comment being updated. Comment used to read:

```
//  Error.swift
```
  i'm using Alamofire v 3.5.0 that was installed with Cocoapods 1.0.1
and after trying to test the app with Xcode 8 GM version, i got the swift convert tool option, with the Alamofire checkbox marked.

running it on the Alamofire SDK generates tones of errors...

then saw somewhere a suggestion to upgrade the Cocoapods to the latest beta versions.
updated it to 1.1.0.beta.2 but when trying to install pods after that, i'm getting an error:
"...target has frameworks with conflicting names: XXX"
the conflicting name is not related to Alamofire, but still i can't find a solution to make it work.

any suggestions?
 needs to be reopened:

[!] Unable to satisfy the following requirements:
- `Alamofire (~> 4.0)` required by `Podfile`

None of your spec sources contain a spec satisfying the dependency: `Alamofire (~> 4.0)`.

You have either:
- out-of-date source repos which you can update with `pod repo update`.
- mistyped the name or version.
- not added the source repo that hosts the Podspec to your Podfile.

Note: as of CocoaPods 1.0, `pod repo update` does not happen on `pod install` by default.
 @Gargo Read the instruction it gives. Run 'pod repo update' and the problem will be solved.
 @matthijsotterloo already tried - no effect
 @jshier seriously? then why do you have an instruction in readme about 4.0 version?

@cnoon ok how to install it then?
 ok so what should i write into podfile? Or is 4.0 too different from the previous version? My project is just started - should i wait for a newer version of alamofire?
 @jshier ok, cocoapods don't work, will carthage and manual ways work?
 which version of CocoaPods does it require? is 1.0.1 good enough or it has to be the latest 1.1.0 beta? 
 stop it
$ sudo gem which cocoapods
/Library/Ruby/Gems/2.0.0/gems/cocoapods-1.1.0.rc.1/lib/cocoapods.rb

1.1.0 is installed and i still get the same error
  I've seen a couple of these issues coming up already today.  People are trying to get the version of Alamofire that is Swift 3 ready.  So they are following the installation instructions in the README, which currently says to use v3.5, and they end up with a lot of build errors.  Part of the issue seems to be that earlier in the README, Swift 3.0+ is listed as a requirement.

It would probably help to note in the README that v3.5 is only supported up to Swift 2.3 to help with the confusion.
 I apologize for seeming a bit overzealous.  I honestly wasn't trying to be difficult.  Obviously, all the contributors on Alamofire are doing fantastic work.  I didn't mean any offense to you or the other contributors.  I just wanted to try and help the community out.  Thank you for all the great work you do on Alamofire.  
  Hi there,

I've upgraded my project to Swift 3 and updated Alamofire to version 3.5.
But now I have 190 issues getting from Xcode. Do I forget something while converting?

![Screenshot](http://i.imgbox.com/T838Fax8.png)

Thanks!
 @cnoon Can you update the README to reflect that?  Currently, it is saying that Swift 3.0+ is a requirement, but if it's not been officially released, that is misleading.
 I understand that Alamofire 4.0.0 hasn't been released.  What I'm saying is that the common user's first stop when they search for Alamofire is your Github page, which, by default, points to your master branch.  The README file there has conflicting information which is obviously confusing users, since they are writing issues here.

As for "unreleased branches", people are looking at master, not swift3.  Honestly, I wasn't asking for you to release v4.0.0.  I just thought that seeing Swift 3.0 as a requirement, and then a few lines down see that we should be installing v3.5 is presenting conflicting information and that maybe the requirements listed in the README that everyone is looking at (whether the master branch is unreleased or not) should match the version that same README is directing users to install.
  Hi!

This is the line I placed in my Podfile: 

pod 'Alamofire', '~> 3.5'

But when I open xcode and build I still get like 190 errors? (yes I did the pod install command).

Thanks!

Matthijs
 I'm using Swift 2.3, that should work right? Even when I try to use the master branch (so just removing the version from the line) I keep getting 190 errors.
  I¬¥m trying to install Alamofire to an iMessage extension app via cocoapods.
here¬¥s my pod:

target 'MyExtension' do
  use_frameworks!
    pod 'Alamofire',
        :git => 'https://github.com/Alamofire/Alamofire.git',
        :branch => 'swift3'

end

target 'MyApp' do
  use_frameworks!

end

I set the "Use Legacy Swift Language Version" to No in the "Build Settings" tab
![screen shot 2016-09-09 at 12 33 09 pm](https://cloud.githubusercontent.com/assets/14424870/18392813/9d46b056-7689-11e6-910e-a3d1cf829575.png)

It builds and run correctly but immediately and i get the following error in the console output:

dyld: Library not loaded: @rpath/Alamofire.framework/Alamofire
  Referenced from: /Users/xxxxxx/Library/Developer/CoreSimulator/Devices/xxxxxxxxxxx/data/Containers/Bundle/Application/xxxxxxxxx/xxxxxx.app/PlugIns/MessagesExtension.appex/MessagesExtension
  Reason: image not found

I found a couple of solutions for this but couldn't make them work, many of them included adding the framework to the "Embedded binaries" section in the "General" tab but I don¬¥t have such section in project.

Any ideas?
Thanks!
 You need to add a both targets for iMessages apps for it to work. e.g.

```
target 'MyApp Messages' do
end

target 'MessagesExtension' do
pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'swift3'
end
```
 I tried many different ways like:

```
def shared_pods
  pod 'Alamofire',
  :git => 'https://github.com/Alamofire/Alamofire.git',
  :branch => 'swift3'

  pod 'SwiftyJSON',
  :git => 'https://github.com/acegreen/SwiftyJSON.git',
  :branch => 'swift3'
end

target 'MessagesExtension' do
  use_frameworks!
  shared_pods

end

target 'MyApp' do
  use_frameworks!
  shared_pods

end
```

or

```
target 'MessagesExtension' do
  use_frameworks!
  pod 'Alamofire',
    :git => 'https://github.com/Alamofire/Alamofire.git',
    :branch => 'swift3'

end

target 'MyApp' do
  use_frameworks!
   pod 'Alamofire',
    :git => 'https://github.com/Alamofire/Alamofire.git',
    :branch => 'swift3'
end
```

but i¬¥ts the same error over and over..
 Only put the pods inside `MessagesExtension`. Leave the other one empty. You don't need both.
 You might also need to use a local gemfile for master version of cocoapods. See https://github.com/CocoaPods/CocoaPods/issues/5594
  So I've used AlamoFire for years and getting ready for the new Swift3 Xcode8 update.  I've installed Xcode8 GM and then used the instructions to pull the Swift3 branch:

`source 'https://github.com/CocoaPods/Specs.git'
platform :ios, '9.0'
use_frameworks!

target 'MySwift3Test' do
    pod 'Alamofire', '~> 3.4'
end
`
However when I open up the newly created workspace (brand new project), Xcode is telling me that AlamoFire has not been converted and attempts to update the code?

What am I missing?
 Turns out that needed to change it to 
pod 'Alamofire', :git => 'git@github.com:Alamofire/Alamofire.git', :branch => 'swift3'

and then let xCode "attempt to update to Swift 3" which when it gets done it says no updates however has some 800 "warnings" which are bogus.  If you then do a CLEAN and BUILD, it appears to work just fine.  However... it can't find 

print(UIDevice.deviceModel()) // x86_64 / iPhone7,2

(this is running 0.39.0 of CocoaPods - due to other projects that don't yet run 1.1.0Beta2)
 @jshier it would probably help to update the README to make this clearer.  Currently, the README lists Swift 3.0+ as a requirement, but then in the installation instructions, it says to use v3.5, which is not Swift 3...
  Hi,

I'm in the process of migrating my projects to XCode 8 / Swift 3.

Currently most stuff works, however I can't find how to get the suggestedFilename from the response?

```
self.downloadManager.request(requestString, method:.get, parameters: nil, encoding:URLEncoding.default).response { response in
                 if let filename = response.suggestedFilename {
         }
    }
```

This gives me the error: Value of type 'DefaultDataResponse' has no member 'suggestedFilename'.

How should I access the suggested filename in Alamofire 4?

Thanks a lot!
 First of all, `suggestedFilename` is a member of `NSURLResponse`, so you first need to access the `DefaultDataReponse`'s `response` member : 

``` swift
self.downloadManager.request(requestString, method:.get, parameters: nil, encoding:URLEncoding.default).response { response in
        if let filename = response.response?.suggestedFilename {
    }
}
```

Moreover, what filename are you expecting to get using `request(_:method:parameters:encoding)`? Shouldn't you be using `download(_:method:parameters:encoding)`to actually write something to disk?
  ```
                let destination: (NSURL, HTTPURLResponse) -> (NSURL) = {
                    (temporaryUrl, response)  in
                    if response.statusCode == 200 {
                        return NSURL(fileURLWithPath:PPMusicFolder.pathForSong(songid))
                    }
                    else {
                        return temporaryUrl
                    }
                }

                Alamofire.download(songLink.string!, to: destination)
                    .downloadProgress(closure: { (bytesRead, totalBytesRead, totalBytesExpectedToRead) in
                        let progress :Float = Float(totalBytesRead)/Float(totalBytesExpectedToRead)
                        print(progress)
                        DispatchQueue.main.async {
                            cell.downloadProgress(progress)

                        }
                    })
                    .responseString(completionHandler: { (response) in
                        print("Success: \(response.result.isSuccess)")
                        print("Response String: \(response.result.value)")
                    })
```
 Thanks,i find

ÂéüÂßãÈÇÆ‰ª∂
Âèë‰ª∂‰∫∫:Christian Noonnotifications@github.com
Êî∂‰ª∂‰∫∫:Alamofire/AlamofireAlamofire@noreply.github.com
ÊäÑÈÄÅ:zxcv740zxcv740@qq.com; Authorauthor@noreply.github.com
ÂèëÈÄÅÊó∂Èó¥:2016Âπ¥9Êúà9Êó•(Âë®‰∫î)‚Äá16:32
‰∏ªÈ¢ò:Re: [Alamofire/Alamofire] Swift3.0 Xcode8 gm download file to custompath issue (#1493)

The destination closure signature has changed. You now need to return the DownloadOptions along with the URL to allow you to custom how the file is moved.
public typealias DownloadFileDestination = ( _ temporaryURL: URL, _ response: HTTPURLResponse) - (destinationURL: URL, options: DownloadOptions)
‚Äî
You are receiving this because you authored the thread.
Reply to this email directly, view it on GitHub, or mute the thread.
  This has broken AlamofireImage 

<img width="1628" alt="screen shot 2016-09-09 at 12 49 52" src="https://cloud.githubusercontent.com/assets/1426233/18386015/f1bd0a2a-768b-11e6-8a19-63df048928bb.png">

See https://github.com/Alamofire/AlamofireImage/issues/174
 For what it's worth, I definitely agree that this is a better solution than my approach in #1488 
 @cnoon @tremblay I just noticed the same issue, strangely enough the Carthage dependency compiles and the app crashes at runtime with a `dyld: lazy symbol binding failed: Symbol not found` error. I would have expected that Carthage would have failed to build AlamofireImage. Any idea why?
  I was reading over the similar [issue for iOS 8/9](https://github.com/Alamofire/Alamofire/issues/1367), and I understand the reasoning in general (iOS major versions are adopted _rapidly_, even just the current version gets you almost everyone within a month or two), but things are quite a bit different on OS X.

Stats for OS X adoption are a bit harder to find than iOS, but it looks like 10.11 adoption was [hovering around 40%](http://www.computerworld.com/article/3029090/mac-os-x/os-x-el-capitan-adoption-lags-behind-predecessors.html) even 4 months after it was released. Mac users just don't update as quickly, [even when their hardware is supported by newer versions](https://duo.com/blog/duolytics-os-x-upgrade-adoption).

Current median adoption stats I can come up with, according to [GoSquared](https://www.gosquared.com/global/mac/el-capitan/#month):
- 10.9: **~10%**
- 10.10: **~32%**
- 10.11: **~55%**
- 10.12: **~3%**

To get a number similar to the 92%+ iOS stat you would currently have to go 2 versions back to OS X 10.10, which gives you ~90%. That will likely still be the case for several months, and as Apple will also still be supporting 10.10 with security patches for another year (they support $current - 2), that seems like a better choice of cutoff.

Thanks :)

P.S. does anyone know of a good chart showing which machines are left behind by specific versions of OS X? The data is available but I haven't found an existing site for it yet, I might have to make one.
 I'd be so very happy if this still supported 10.10
  Allows the `RequestRetrier` to perform async work before executing the `completion` closure.

I‚Äôm in need of this since I‚Äôm using this a point to handle 401 errors and kick off re-authentication (refreshing the access token). Having those requests re-tried automatically once the access token has arrived. As such the `completion` closure needs to be ‚Äústored away‚Äù for a bit.
  using `_` causes any existing code that called `request(urlRequest)` to
compile but potentially fail. because it needs to be updated to
`request(resource: request)` but this is not caught by the compiler
because `URLRequest` apparently conforms to `URLStringConvertible`.

This issue is evident in some of the tests, which compiled and actually
passed, but were in fact calling the wrong `request`. 

I added a test that would fail if the wrong `request` is called to
illustrate this point.
  We are using the 4.0.0-beta2 version to develop our app.

When we try to upload it to the app store for test flight internal testing purpose, iTunes Connect tells us that `-` character is not allowed in version number.

We achieved to do the upload to iTunes Connect for TestFlight internal testing purpose by removing the `-` character.

Is it possible to change the version number to remove the `-` character in the version number ?

Thanks :)
 beta version 
  This is the error I get when I create a playground, import Foundation, import Alamofire, and try and instantiate a SessionDelegate. So far I've tried this on iOS playgrounds in Xcode 8 GM.

<img width="1228" alt="screen shot 2016-09-08 at 1 53 27 pm" src="https://cloud.githubusercontent.com/assets/23498/18360424/fcc13bf0-75cb-11e6-8c3c-4ba3c2ea1021.png">
 Can you please post the code you're using in your playground? I've tried instantiating a `SessionManager` and successfully called a `DownloadRequest` on it so the issue might be with the configuration you've set?
 It's just a playground, inside a workspace, with the Alamofire project as a sub project, in the playground itself I have the following:

```
import Foundation
import Alamofire

let manager = SessionManager()
```

It's an iOS playground.
 Hmm that's weird because I have workspace created by Cocoapods with Alamofire taken from the `master` branch included in the Pods project, a playground in my main project and the exact same code as you and it's running fine...
 Some more details, I am using carthage to prebuild some frameworks, and I've also included the frameworks for Playground's sake, but they aren't built when my targets are build.
 Oh I see! I have never used Carthage but could it be linked to #1485 in some way? If not, I'm sorry you'll have to wait for someone who knows Carthage to come by (but it might not be related to Carthage at all for all I know).
 Fair enough, thanks!
 Did you find a solution? My code was working before and I updated Alamofire and now it crashes with this same error.  All was well when using Carthage with Xcode 8 beta but after moving to the GM version yesterday, `carthage update` fails on the alamofire build.  I was using Swift3 when I successfully ran this yesterday.  You'll see below that I deleted the Carthage folder in the project so there should be no build artifacts:

``` bash
01:43:43 ~/dev/smallr:[master !x+] $ rm -rf Carthage/
01:44:40 ~/dev/smallr:[master !x+] $ carthage update
*** Fetching Alamofire
*** Checking out Alamofire at "4.0.0-beta.2"
*** xcodebuild output can be found in /var/folders/vf/3rsfnspx2z995zyfst389tm80000gp/T/carthage-xcodebuild.7tWrvU.log
*** Building scheme "Alamofire tvOS" in Alamofire.xcworkspace
** BUILD FAILED **


The following build commands failed:
        CompileSwift normal arm64
        CompileSwiftSources normal arm64 com.apple.xcode.tools.swift.compiler
(2 failures)
/Users/adamn1/dev/smallr/Carthage/Checkouts/Alamofire/Source/SessionDelegate.swift:198:15: warning: instance method 'urlSession(_:didReceive:completionHandler:)' nearly matches optional requirement 'urlSession(_:didReceive:completionHandler:)' of protocol 'URLSessionDelegate'
/Users/adamn1/dev/smallr/Carthage/Checkouts/Alamofire/Source/Validation.swift:54:44: error: closure use of non-escaping parameter 'validation' may allow it to escape
/Users/adamn1/dev/smallr/Carthage/Checkouts/Alamofire/Source/SessionManager.swift:353:24: error: closure use of non-escaping parameter 'destination' may allow it to escape
/Users/adamn1/dev/smallr/Carthage/Checkouts/Alamofire/Source/TaskDelegate.swift:199:10: warning: instance method 'urlSession(_:dataTask:didReceive:completionHandler:)' nearly matches optional requirement 'urlSession(_:dataTask:didReceive:completionHandler:)' of protocol 'URLSessionDataDelegate'
/Users/adamn1/dev/smallr/Carthage/Checkouts/Alamofire/Source/TaskDelegate.swift:251:10: warning: instance method 'urlSession(_:dataTask:willCacheResponse:completionHandler:)' nearly matches optional requirement 'urlSession(_:dataTask:willCacheResponse:completionHandler:)' of protocol 'URLSessionDataDelegate'
A shell task (/usr/bin/xcrun xcodebuild -workspace /Users/adamn1/dev/smallr/Carthage/Checkouts/Alamofire/Alamofire.xcworkspace -scheme "Alamofire tvOS" -configuration Release -sdk appletvos ONLY_ACTIVE_ARCH=NO BITCODE_GENERATION_MODE=bitcode CODE_SIGNING_REQUIRED=NO CODE_SIGN_IDENTITY= CARTHAGE=YES clean build) failed with exit code 65:
** BUILD FAILED **


The following build commands failed:
        CompileSwift normal arm64
        CompileSwiftSources normal arm64 com.apple.xcode.tools.swift.compiler
(2 failures)

01:45:08 ~/dev/smallr:[master !x+] $
```
 Master is ahead of 4.0.0-beta.2 so it's just a matter of minting a new version.  Looking into this now.
 For those in need, change your Cartfile to:

`github "Alamofire/Alamofire" "master"`

I was going to fork and PR a change but there's nothing really to be done aside from tagging 4.0.0-beta.3.
  Today I updated from Xcode 8 beta6 to Xcode 6 GM.

Now my Today Extension stoped working on the device.
In Simulator everything is fine.

I tracked everything down to this code (need to change url...):

```
    let url = "http://www.domain.com/test"
    let headers = ["Accept": "application/json"]
    Alamofire.request(url, method: .get, parameters: nil, encoding: JSONEncoding(), headers: headers)
        .responseString(completionHandler: { (response: DataResponse<String>) in
            print(response)
        }
    )
```

On the device the response is never called...
There is no crash, only this line as log output:
Program ended with exit code: 0(lldb) 
 I'm getting a similar result, except the completion block runs, but my response is nil. Was working in beta 6. Anyone have a solution?
 So it looks like my issue might more related to AlamofireObjectMapper. A coworker of mine is looking into this issue right now and I'll post an update here if it turns out to be an Alamofire issue.
 @cnoon Sorry for the delay. We found the solution and it was unrelated to Alamofire, so my apologies. Not sure if @Urkman is still having issues, but I am not.
 This is definitely not Alamofire related, so it can be closed ...
There was a timing problem in my extension, so the "crash" was forced from an "addSubview".
  I upgraded my Cocoapods and implemented use_frameworks!, which worked for all libraries I used, but didn't worked for Alamofire. I realized that every library have Framework file inside. However, Alamofire doesn't have that. So the problem is, my workspace doesn't recognize the static swift libraries like Alamofire. 

Do you have a workaround on this issue?
 @cyurtbil 

Hi, I recommend you to use [carthage](https://github.com/Carthage/Carthage). Is very simple.
  <img width="461" alt="captura de tela 2016-09-08 as 11 01 20" src="https://cloud.githubusercontent.com/assets/8302454/18352230/edfa28c4-75b3-11e6-8814-3b539f0ea5c2.png">

in swift 3, Type ParameterEncoding has no member JSON.

someone more this with this problem?

thanks
 I _think_ in Swift 3 those are lowercase `.json`
 You should check the PR: #1465
 @timlehr 

the problem is the same, I tried in lowercase to. :/
 @ikesyo 

Thanks @ikesyo, I solved this problem. 

I used JSONEncoding(), no .json.
  Hello there ! 

We are upgrading our code to Swift 2.3 (Road to Swift 3.0 ...) but we are facing problems with Almofire . The compiler gives us these errors : 

<img width="259" alt="capture d ecran 2016-09-08 a 15 39 01" src="https://cloud.githubusercontent.com/assets/17471117/18351432/738ee562-75da-11e6-844c-ac5993883992.png">

And the most important one of the, the unresolved identifier ... 

Any help ? 

Thank you 
 In my case, I only have issues with ServerTrustPolicy.swift under the private function

```
// MARK: - Private - Trust Validation

    private func trustIsValid(trust: SecTrust) -> Bool {
        var isValid = false

        var result = SecTrustResultType(rawValue: SecTrustResultType.Invalid)
        let status = SecTrustEvaluate(trust, &result)

        if status == errSecSuccess {
            let unspecified = SecTrustResultType(rawValue: SecTrustResultType.Unspecified)
            let proceed = SecTrustResultType(rawValue: SecTrustResultType.Proceed)

            isValid = result == unspecified || result == proceed
        }

        return isValid
    }
```

The issues are:
- Cannot convert value of type 'SecTrustResultType' to expected argument type 'UInt32'

They are almost the same issues with @parkego above. I upgraded to Swift 2.3.
 Adding the .rawValue resolves identification here. Without it, is like pointing to a directory instead of an index file:

```
    var result = SecTrustResultType(rawValue: SecTrustResultType.Invalid.rawValue)
    let status = SecTrustEvaluate(trust, &result!)

    if status == errSecSuccess {
        let unspecified = SecTrustResultType(rawValue: SecTrustResultType.Unspecified.rawValue)
        let proceed = SecTrustResultType(rawValue: SecTrustResultType.Proceed.rawValue)
```
 Dude Change: "var result = SecTrustResultType(rawValue: SecTrustResultType.Invalid.rawValue)"....... for: "var result = SecTrustResultType(kSecTrustResultInvalid)" is Work for me..  Thanks It helped me...!!!  Hi I using the branch swift3 to use with Swift 3.0 but today now appear Build Failed in carthage update.

```

** BUILD FAILED **


The following build commands failed:
    CompileSwift normal arm64
    CompileSwiftSources normal arm64 com.apple.xcode.tools.swift.compiler
(2 failures)
/Users/andre/Documents/**App/Carthage/Checkouts/Alamofire/Source/SessionDelegate.swift:198:15: warning: instance method 'urlSession(_:didReceive:completionHandler:)' nearly matches optional requirement 'urlSession(_:didReceive:completionHandler:)' of protocol 'URLSessionDelegate'
/Users/andre/Documents/**App/Carthage/Checkouts/Alamofire/Source/SessionManager.swift:353:24: error: closure use of non-escaping parameter 'destination' may allow it to escape
/Users/andre/Documents/**App/Carthage/Checkouts/Alamofire/Source/TaskDelegate.swift:199:10: warning: instance method 'urlSession(_:dataTask:didReceive:completionHandler:)' nearly matches optional requirement 'urlSession(_:dataTask:didReceive:completionHandler:)' of protocol 'URLSessionDataDelegate'
/Users/andre/Documents/**App/Carthage/Checkouts/Alamofire/Source/TaskDelegate.swift:251:10: warning: instance method 'urlSession(_:dataTask:willCacheResponse:completionHandler:)' nearly matches optional requirement 'urlSession(_:dataTask:willCacheResponse:completionHandler:)' of protocol 'URLSessionDataDelegate'
/Users/andre/Documents/**App/Carthage/Checkouts/Alamofire/Source/Validation.swift:54:44: error: closure use of non-escaping parameter 'validation' may allow it to escape
A shell task failed with exit code 65:
** BUILD FAILED **


The following build commands failed:
    CompileSwift normal arm64
    CompileSwiftSources normal arm64 com.apple.xcode.tools.swift.compiler
(2 failures)
```

I change to Alamofire 3.5 and carthage update again, but to build project the xcode show this error.(Sorry for my english)

```
/Users/andre/Documents/**App/Carthage/Build/iOS/Alamofire.framework/Alamofire compiled with older version of Swift language (2.0) than previous files (3.0) for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
```
  I have a typealias for ParameterEncoding in my code
now I get "'ParameterEncoding' has no member 'json'" 

any other changes I should be considering?

Thanks
 Also I have something like this to follow upload progress:

```
...
case .success(let upload, _, _):
                    DispatchQueue.main.async {
                        UIApplication.shared.isNetworkActivityIndicatorVisible = true
                    }

                    upload.progress  { bytesWritten, totalBytesWritten, totalBytesExpectedToWrite in ...
```

"Cannot call value of non-function type 'Progress'" ...
  Hi,

I just like to know how your plans are about a Swift 3 compatible version?

Thanks,

Tobi
 @twiedow Have you tried?

```
pod 'Alamofire',
    :git => 'https://github.com/Alamofire/Alamofire.git',
    :branch => 'swift3'
```

or 

```
pod 'Alamofire',
    :git => 'https://github.com/Alamofire/Alamofire.git',
    :branch => 'swift3-rebased'
```
 I saw those branches, but what about an official release?
  Steps to reproduce:
1. Add Alamofire (branch `swift3`) to your project
2. Try to submit app to iTunes Connect
3. üí•

```
ERROR ITMS-90060: "This bundle is invalid. The value for key CFBundleShortVersionString '4.0.0-beta.2' in the Info.plist file must be a period-separated list of at most three non-negative integers."
```

Looks like versions in embedded framework's `.plist` files should not contain strings
### Workaround

Locate Alamofire's `Info.plist` and change the version to `4.0.1`
  Hi there,

So, today I've decide to give Xcode-8 GM a go, and tried to update Alamofire to version `3.5` from Cocoapods. Unfortunately, it's not finding this version in Cocoapods specs repo. 
https://github.com/CocoaPods/Specs/tree/master/Specs/Alamofire

Could you push `3.5` to the specs repo? 
 the same problem~ and the branch 2.3 is not exit too.
 Bumped into the same. Would be great if you could push 3.5 to the CocoaPods spec repo.
 Until this is resolved, you can use the 3.5.0 release by specifying the tag directly. 

`pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :tag => '3.5.0'`
 Hi @emrekyv After doing that XCode 8 GM asks me to convert to swift syntax.
Is :tag => '3.5.0' is pointing to swift3 merge? 
 Thanks @jshier I was using swift3 branch but now with Xcode GM doesn't work... Maybe will be useful to open another issue...
 There are 194 issues in the master branch 3.5.0 when trying to compile with Xcode 8 GM.
 If I force master doesn't work also with XCode 8 GM... Installing Alamofire 4.0.0-beta.2 
I'm getting the same message saying I need to convert the swift syntax.
 I am using the latest prerelease of CocoaPods 1.1.0.beta2. Just double checked to make sure.
 Sorry my mistake, i was using

pod 'Amamofire'

Had to force it and it works now. Thanks.

pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'master'
  I want to Pass JSON ARRAY like this - 

[
       {
                OrgId: 1001,
                ClassworkId: 999800580,
            }, {
                OrgId: 1001,
                ClassworkId: 0,
      }
]

I am Using this Method - I want to solve parameter - [String : AnyObject] -> Array

func delateClasswork (parameters: [String: AnyObject],completion: (success : Bool) -> Void) {
        request(.POST, "strURL", parameters: parameters, encoding:.JSON).responseJSON
            {
                response in switch response.result {
                case .Success(let JSON):
                   if((JSON.valueForKey("StatusId")) as! NSNumber == 1){
                       completion(success: true)
                        break
                    }else{
                        completion(success: true)
                        break
                    }
                case .Failure(let error):
                   completion(success : false)
                    break
                }
        }
    }
 You just posted some JSON and some code.  What's your question?  If you're reporting a bug, please give details.  If you're asking a question, add MUCH more information, and post it to Stack Overflow instead of here.
 I want to pass JSON Array My post Parameter is :-¬†
[
{
OrgId: 1001,
ClassworkId: 999800580,
}, {
OrgId: 1001,
ClassworkId: 0,
}
]

How can i Pass this and get Response - can you need any other things?
I already post in Stack. 
Thanks,
Waiting For your postive feedback. 
  What to use for xcode 8 for swift 2.3 ?

Thanks.
  This fixes build failures in the GM seed of Xcode 8.
 No prob!  As long as I can build it, I'm happy.
  You're probably aware of this but Alamofire won't compile on Xcode 8 GM.
 See: https://github.com/Alamofire/Alamofire/pull/1469
 @cnoon how do we get this?  My 'pod update' gives me version 4.0.0-beta.2.  I'm guessing I need something different in my Podfile.  I'm just pointing at the swift3 branch.
  PR #1455 introduced a few very nice additions to handle progress of various requests.

``` swift
Alamofire.download(url)
.downloadProgress { progress in
    // Called on main dispatch queue by default
    print("download progress: \(progress.fractionCompleted)")
}
.downloadProgress { bytesRead, totalBytesRead, totalBytesExpectedToRead in
    // Called on main dispatch queue by default
    print("Read: \(bytesRead), Total Read: \(totalBytesRead), Total Expected: \(totalBytesExpectedToRead)")
}
.response { response in
    debugPrint(response)
}
```

There's no issue using `.downloadProgress { bytesRead, totalBytesRead, totalBytesExpectedToRead in`, with or without parenthesis, because the context is clear.
However for the `ProgressHandler` closure, the compiler complains that `.downloadProgress { progress in` is an "ambiguous use of 'downloadProgress(queue:closure:)'". It seems to be somehow mixing up the one-argument `ProgressHandler` with the three-argument `DownloadProgressHandler` for some reason.  The workaround is writing :

``` swift
Alamofire.download(url)
.downloadProgress { (progress: Progress) in
    // Called on main dispatch queue by default
    print("download progress: \(progress.fractionCompleted)")
}
```

I think this is mostly a Swift interpreter bug because I can't fathom why it's mixing these up. Because the current implementation is _very_ elegant, I'd say it's only something to take into account when rewriting the README examples.
 The time I get home it'll be the start of Apple's presentation but I'll try my best to provide a sample just after it!
 But I can already tell you that this bug is really "bugging" me because I've reproduced it a few times, fixing it with the workaround. However one time it compiled _with_ the workaround, I removed the workaround (i.e. had only `{progress in`) and it compiled fine (!!!) but only once then it complained about ambiguity again when compiling again. I'm guessing it "remembered" the explicit `Progress` annotation for a short while but at the next compilation it type-checked it again and couldn't infer type from context...
 Sample code producing the bug : 

``` swift
func downloadTest(progressHandler: @escaping (Double) -> Void, completion: @escaping (URL) -> ()) {
    let url = "https://s3.amazonaws.com/x265.org/video/BigBuckBunny_2000h264.mp4"
    let destination = Alamofire.DownloadRequest.suggestedDownloadDestination()

    Alamofire.download(url, to: destination)
        .downloadProgress { progress in
            progressHandler(progress.fractionCompleted)
            print(progress)
        }
        .response { downResponse in
            if let error = downResponse.error {
                print("ERROR: \(error)")
                print("REQUEST: \(downResponse.request)")
                print("RESPONSE: \(downResponse.response)")
            } else {
                completion(downResponse.destinationURL!)
            }
    }
}
```

![bug](https://cloud.githubusercontent.com/assets/2539639/18325671/99f48a92-7542-11e6-8562-6a70d65fa5d7.jpeg)

An easy way in this sample to fix it, aside from the explicit type annotation, would be to modify the supplied `progressHandler`closure to be of type `ProgressHandler` directly but then you couldn't just print the progress for example...
 Now I'll wait for the GM to download test it again. I see the gm-feature branch adds `@escaping`to the `closure:` parameter and maybe it'll help? I'll check back with.

PS: I've seen you work at Nike! Kudos on the new Watch üëç 
 So here are the results : I've added the `@escaping` tags to Alamofire in the GM and it doesn't help my bug. It still finds `.downloadProgress{ progress in` ambiguous...
 I'm glad to help! üçª 
  This is my code.
Alamofire.request(.POST, "http://tiku.zhan.com/ielts/speaking/recall/fetch", parameters: ["publishTime": 0 ,"cityCode":"000"])
            .responseJSON { response in
                if let JSON = response.result.value {
                    print("JSON: (JSON)") //**This is away failure!**
                }
        }

This is debug log!
Optional(<NSMutableURLRequest: 0x7fbca9db3410> { URL: http://tiku.zhan.com/ielts/speaking/recall/fetch })
Optional(<NSHTTPURLResponse: 0x7fbca9db5390> { URL: http://tiku.zhan.com/ielts/speaking/recall/fetch } { status code: 406, headers {
    Connection = "keep-alive";
    "Content-Language" = en;
    "Content-Length" = 1110;
    "Content-Type" = "text/html;charset=utf-8";
    Date = "Tue, 06 Sep 2016 03:12:58 GMT";
    Server = "***********";
} })
FAILURE
error: Optional(Error Domain=NSCocoaErrorDomain Code=3840 "Invalid value around character 0." UserInfo={NSDebugDescription=Invalid value around character 0.})

But I can receive JSON when I use postman. I'm confused .Why? I need help.Thanks!
  Thanks so much, we need this so bad in swift 2.2 otherwise we'll be forced to switch to swift 3 and da heck we're gonna get by doing this for big project
  Proposed fix for https://github.com/Alamofire/Alamofire/issues/1458
  An API I'm using will sometimes pass back an error message as JSON with additional information on why the request failed.

Currently I have to implement turning the  NSData in response.data into a JSONDictionary when validation fails. 

It would be convient for me to have Alamofire take care of this. 

I would like a way to flag requests individual and/or globally to force Alamofire to attempt to convert the response.data using the same serializer type as I would have used on the response data even if the validate method fails?

I believe in the 1.0 or 2.0 version of Alamofire you could still get a converted object from result.value even if validation failed. It would be nice to have that ability again, so I'm not implementing the same logic that already exists in Alamofire's ResponseSerializers. 

Thank you for your time and I hope you consider this request. 
 üëç 
 @gchaturvedi  do you have an example how to get the error from the server, do I have to deserialize the data ?
  In `ParameterEncoding.queryComponents()` method, `value` is checked against `Bool` (see below pasted code). But in Swift 3 if `value` is of type `NSNumber`, this check will always succeed. So even though `value` might contain `NSNumber` of value, say 25, queryComponent will always return 1. 

Proposed Fix: `if let bool = value as? Bool, !(value is NSNumber)`

``` Swift
        } else if let bool = value as? Bool {
            components.append((escape(key), escape((bool ? "1" : "0"))))
        } else {
            components.append((escape(key), escape("\(value)")))
        }
```
   I download  file url is  http://10.7.7.100:8080/auth0919.tar.gz progress always 0.0,BTW Other url(not .tar.gz ) is ok  Whenever I send some request with basic parameters, it works like a charm, for example:

```
                            let parametersServices  = [
                                "name": [
                                    "first": "\(givenName)",
                                    "last": "\(familyName)"
                                ]
                            ]
```

But if I send parameters with deep nesting, it does not make any effect on those deeply nested parameters, for example:

```
                            let parametersServices  = [
                                "name": [
                                    "first": "\(givenName)",
                                    "last": "\(familyName)"
                                ],
                                "services" : [
                                    "mentoring": [
                                        "profileId" : "id123",
                                        "title" : "mentor"     
                                    ]
                                ]
                            ]
```

Am I doing something wrong or is such type of PATCH does not supported to modify deeply nested profileId ?

Because if I try simply create new user with same parameters, it works fine, however there it does not accept changes with PATCH for existing items.
 This isn't an issue with Alamofire, since as you state it is sending the data correctly with the correct HTTP method. It is more likely an issue with the application's API you are trying to use.  The better place to ask a question is Stackoverflow or ask the developer of the API you are trying to use. 
  Adding this Podspec configuration line means that the SWIFT_VERSION does not need to manually set to 3.0 in Xcode and is done on install. This configuration is being followed conventionally by many Pods being updated for Swift 3.
  The 3.4.2 update of Alamofire creates a user agent string with an extra close paren in Manager.swift line 95. This causes certain web servers to fail when validating the user agent string.

`return "\(executable)/\(bundle) (\(appVersion)/\(appBuild)); \(osNameVersion))"`

should be:

`return "\(executable)/\(bundle) (\(appVersion)/\(appBuild); \(osNameVersion))"`
  `‚ÄúUse Legacy Swift Language Version‚Äù (SWIFT_VERSION) is required to be configured correctly for targets which use Swift. Use the [Edit > Convert > To Current Swift Syntax‚Ä¶] menu to choose a Swift version or use the Build Settings editor to configure the build setting directly.`

Have to convert the code each time pod install is run. Is there any work around?

I am using Xcode 8.0 beta 6, Swift 3.0, Alamofire swift3 branch.
   Hi everyone, 

I am using Alamofire with carthage in my latest project, and the build time is slow, because the framework needs to be created both for iOS, macOS, tvOS, and watchOS. This could be improved if Alamofire would have a multi-platform single scheme Xcode project. 

This is already implemented by some of the major libraries like [PromiseKit](http://promisekit.org/news/2016/08/Multiplatform-Single-Scheme-Xcode-Projects/). The method is [well documented](http://ilya.puchka.me/xcode-cross-platform-frameworks/), and I think it would be a huge advantage for this project in the future to have a single shared target. 

Is there any chance that this request is going to be implemented at some point in the future?
I'd like to contribute if we can make this happen. :) 
  I got this kind of issue when I try to install Alamofire 3.4

```
[!] Unable to satisfy the following requirements:

- `Alamofire (~> 3.4)` required by `Podfile`

None of your spec sources contain a spec satisfying the dependency: `Alamofire (~> 3.4)`.

You have either:
 * out-of-date source repos which you can update with `pod repo update`.
 * mistyped the name or version.
 * not added the source repo that hosts the Podspec to your Podfile.

Note: as of CocoaPods 1.0, `pod repo update` does not happen on `pod install` by default.
```

Thank you. Please advice.
  I want to Pass Three Parameter in post I am trying This code please check -

func uploadCreateHWAttahment(parameters: [String: AnyObject],imageData: NSData, uuid: String, imageExtension: String, completion: (success : Bool) -> Void){

```
    PKHUD.sharedHUD.contentView = PKHUDTextView(text: "Loading...")
    PKHUD.sharedHUD.show()

    let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
    configuration.timeoutIntervalForResource = 3600000 // seconds
    alamofireManager = Manager(configuration: configuration)

    alamofireManager!.upload(.POST, "http://dev.onlinevidyalaya.net/api/academicdetail/uploadclassworkattachment",  multipartFormData:

        {
            multipartFormData in
            multipartFormData.appendBodyPart(data: imageData, name:"6cc50832-6d0f-4cd6-a6bb-57de691e10ce",  mimeType:"JPG")
        },

        encodingMemoryThreshold: Manager.MultipartFormDataEncodingMemoryThreshold,
        encodingCompletion: { encodingResult in

            switch encodingResult {

            case .Success(let upload, _, _):

                upload.progress { bytesRead, totalBytesRead, totalBytesExpectedToRead in

                    let progress: Float = Float(totalBytesRead)/Float(totalBytesExpectedToRead)
                    let value = String(progress * 100)
                    print(progress,value)
                }
                upload.responseJSON { response in
                    PKHUD.sharedHUD.hide()
                    print(response)
                    // CHEKCK VIDEO UPLOAD RESPOSE - PENDING
                }
            case .Failure(let encodingError):

                PKHUD.sharedHUD.hide()

                print(encodingError)
            }
    })
}
```
  Hello there.

I have three background task üëç
1. 1st task is to upload data of type 1 (say)
2. 2nd task is to upload data of type 2 (say)
3. 3rd task is to upload N number of images. 

i want all the task to run in priorities.
1. task 1 has the highest priority
2. task 2 with lower priority
2. and uploading of images in lowest priority

Is there any way i can put all these request in different queues with different priorities. ??

I am Using Swift 2.2
and pointing to iOS 8.0 and above.
 Ok can we have a new feature for having Custom Queues in Request objects ?
  Build attempt using Xcode 8 Beta 6
Toolchain: Swift 3, 08-29
Branch: swift3

Alamofire/Source/SessionManager.swift:353:24: Closure use of non-escaping parameter 'destination' may allow it to escape

Also a similar error:
Alamofire/Source/Validation.swift:54:44: Closure use of non-escaping parameter 'validation' may allow it to escape
 I also get this issue while compiling with Xcode 8 GM that was released this afternoon.
 Same here
 is this issue got fixed ?
 Yes, this issue has been resolved in the 4.0 release of Alamofire.
  Xcode :Version 8.0 beta 6 
Cocopods:/cocoapods-1.0.1
Almofire version : Alamofire 3.4.2 (was 3.4.1)
Swift : 3.0

![screen shot 2016-09-02 at 6 33 40 pm](https://cloud.githubusercontent.com/assets/10405305/18204775/203b9d1c-713c-11e6-8be3-7ae218f21467.png)
![screen shot 2016-09-02 at 6 38 38 pm](https://cloud.githubusercontent.com/assets/10405305/18204842/84dfacae-713c-11e6-9103-350c70065378.png)

Is there any issue in converting the Existing code to swift-3.There are lot's of error in current version of almofire .

Even added below line in Podfile :
Pod update

post_install do |installer|
    installer.pods_project.targets.each do |target|
        target.build_configurations.each do |config|
            config.build_settings['SWIFT_VERSION'] = '3.0'
        end
    end
  end

Could you help in above scenario.....
 You can use

```
pod 'Alamofire', :git => 'git@github.com:Alamofire/Alamofire.git', :branch => 'swift3'
```

In your Podfile to get the Swift 3 version for Alamofire (4.0.0-beta.2). That should give you much better results
 Thanks. 
After pod update , I could see below error which was not occurring before .

![screen shot 2016-09-02 at 7 04 10 pm](https://cloud.githubusercontent.com/assets/10405305/18205579/5c6dc78e-7140-11e6-8777-ee003b07b58f.png)
 Above issue of Pod Update is solved by Adding new SSH key .

But now it  require higher deployment target . Since the existing product deployment target is iOS-8 . Now what is next **Deployment** **target** for Swift-3.

![screen shot 2016-09-02 at 7 37 26 pm](https://cloud.githubusercontent.com/assets/10405305/18206572/f3ccd13e-7144-11e6-8026-a425e3cf4dc5.png)
 The minimum deployment target for Alamofire 4.0.0 is iOS 9, see the README for the swift3 branch
 ok .Thanks a lot.
  Environment: Xcode 8 beta 6 / Swift 3 beta 6 / Carthage / Alamofire `swift3` branch

`Request` contains a `response` property [here](https://github.com/Alamofire/Alamofire/blob/master/Source/Request.swift).

``` swift
public var response: NSHTTPURLResponse? { return task.response as? NSHTTPURLResponse }
```

However, `Request` extension also defines a `response` function [here](https://github.com/Alamofire/Alamofire/blob/swift3/Source/ResponseSerialization.swift).

``` swift
@discardableResult public func response<T: ResponseSerializerType>(queue: DispatchQueue? = nil, responseSerializer: T, completionHandler: @escaping (Response<T.SerializedObject>) -> Void) -> Self
```

Due to some changes in Swift 3, the following code listed in [README.md](https://github.com/Alamofire/Alamofire#creating-a-custom-response-serializer) can't be compiled anymore. Basically, it is not possible to call `response()` inside `Request` extension outside `Alamofire` module.

``` swift
extension Request {
    public func responseXMLDocument(completionHandler: Response<ONOXMLDocument, BackendError> -> Void) -> Self {
        // Error: Cannot call value of non-function type 'HTTPURLResponse?'
        return response(responseSerializer: Request.XMLResponseSerializer(), completionHandler: completionHandler)
    }
}
```

I don't know if this is Swift's bug, but I think it would be better to rename `response` to something else.

A few possible solutions:
1. Rename `response` to `urlResponse`? What about `request`, should it be renamed to `urlRequest` as well? Other possible names: `responseMeta`, `httpResponse`...
2. Rename `response()` to `rawResponse()`? Other possible names: `originalResponse()`, `plainResponse()`...
3. Do nothing. Hope Apple will fix it before Swift 3 release.
 ~~The issue is: I can't call `response()` inside `Request` extension outside the Alamofire module,  because `Request` already contains another **property** with the same name (this is really weird). IMO it is Swift's bug, but I don't know if it will be fixed before the Swift 3 release.~~

The error is misleading. I think it was caused by not adding the newly added `@escaping` modifier. Sorry.
  How can I load data from cache if network is not available and force load data from origin source if network is available?
Currently, there is a cache policy which do the opposite `NSURLRequestCachePolicy.ReturnCacheDataElseLoad`
  I am getting this error 

> Value of type Error has no member 'code'

Here is the code i am using in Alamofire version 3.4.1 

```
var retryErrorCodes: Set<Int> = [NSURLErrorTimedOut,
                                            NSURLErrorCannotFindHost,
                                            NSURLErrorCannotConnectToHost,
                                            NSURLErrorDNSLookupFailed,
                                            NSURLErrorNetworkConnectionLost

if retryErrorCodes.contains(response.result.error!.code) {

}
```

Could you please help me upgrading this code for 4.0.0-beta.2.
 Ok, I did an NSError cast üëçüèª.
 @jshier Even Better. Thank you.
  public func appendBodyPart(data data: NSData, name: String)

In this func, name is required. I want to add json string, but found no func.

Could you help me?
 Check this out: https://www.w3.org/TR/html401/interact/forms.html#h-17.13.4
to get an idea what the `appendBodyPart` is for.

Here an example of an assembled body:

```
   Content-Type: multipart/form-data; boundary=AaB03x

   --AaB03x
   Content-Disposition: form-data; name="submit-name"

   Larry
   --AaB03x
   Content-Disposition: form-data; name="files"; filename="file1.txt"
   Content-Type: text/plain

   ... contents of file1.txt ...
   --AaB03x--
```
 @trichner 

Unable to realize, has asked the server changes.
  I have a dictionary of [String: Anyobject] and am converting NSFetchRequest object into json adding it to the dictionary in short this is my code 

`var xyt = JSON(vrt)`

```
    var tt = xyt.object

    for var i = 0; i < restu_id.count; ++i{
        print("RET:\(restu_id[i])")
        let param: [String : AnyObject] = ["customer_id":user_id!, "customer_name":customer_name!,"customer_phone":customer_phone!,"total": 3223, "delivery_fee": 200, "restaurant_id": restu_id[i], "card_id": card_id!,"customer_address_id": 20,"customer_street_address": customer_address!, "customer_address_coordinates": customer_coordinate!, "Order_details": tt]

        print(param)
    }
```

`

This is what is printed 

`{
    imageUrl = "http://res.cloudinary.com/max-ng/image/upload/v1470172475/kjmfyurwnnhvthyxj6z4.jpg";
    "item_id" = 6;
    name = "Avocado Salad";
    price = 1000;
    "rest_id" = 6;
}`

Instead of 

`{
  "price" : "1000",
  "imageUrl" : "http:\/\/res.cloudinary.com\/max-ng\/image\/upload\/v1470172475\/kjmfyurwnnhvthyxj6z4.jpg",
  "item_id" : "6",
  "rest_id" : "6",
  "name" : "Avocado Salad"
}`

My backend will not recognise the `=`
 Can you post the relevant code. The output doesn't correspond to the `print(param)` statement. Also you might want to consider moving this to Stackoverflow, since it looks like a question about how to use Alamofire more than an issue with Alamofire. 
  When building with the 4.0.0-beta.1 tag on Xcode 8 Beta 6, I receive a number of errors due to syntax that is no longer valid as of Swift 3.

It appears that when #1420 was merged into the `swift3` branch it resulted in the addition of `Manager.swift` which was removed/renamed as part of an earlier commit in the `swift3` branch.

The last working commit was 3a9f9ef7a1135560a763f24ef54525ecf8e4b62a

Please let me know if additional details are needed. 

Thank you for your time,
Noah
 @nmccann just noticed this too -- more specifically, the Alamofire project builds fine independently. I imagine `Manager.swift` was removed from the `swift3` branch all together, but was added back here: https://github.com/Alamofire/Alamofire/commit/e1cc66446c635cb593eaf4f7635d64242cf5a9e9

Edit: It was renamed `SessionManager`, it seems
 @cnoon thanks!
   any particular reason why you're not planning on support iOS 8?
  ``` swift
Alamofire.request(.GET, imgURLString).response {
    (request, response, data, error) in
    let image = UIImage(data: data!, scale: 7)
    onComplete(image: image!)
```

Doesn't compile because:
`Ambiguous reference to member 'request(_:withMethod:parameters:encoding:headers:)'`
  During upload resource, progress of sending data and receiving response progress are mixed into same NSProgress. First it is changed in didSendBodyData, and then it is changed in didReceiveData. So imagine case we fully uploaded file fractionCompleted becomes == 1, but then we start to receive response from server and fractionCompleted again changes from 0 to 1.

Moreover this behavior breaks fractionCompleted of parent progresses (iOS issue)

Our project supports iOS8, so we are using implicit child composition. And to workaround this first we should ignore created by alamofire request progress, and then to create own:

```
      let uploadProgress = NSProgress(totalUnitCount: 0)
      request.progress { _, totalBytesReceived, totalBytesExpected in
         uploadProgress.totalUnitCount = totalBytesExpected
         uploadProgress.completedUnitCount = totalBytesReceived
      }
```

Can it be fixed in Alamofire?
Possible solutions:
1) Divide into two different progresses and add them to one parent. But it is not good as it is not easy to estimate costs of two progresses
2) For upload requests just monitor upload progress

Thanks!
 Great to know it is separated now. Thanks for response!
  I‚Äôm trying to install AlamofireImage swift3 branch via CocoaPods. It depends on Alamofire 4.0.0-beta.1, but I can‚Äôt find 4.0.0-beta.1 anywhere. Did you remove the tag?

My Podfile:

```
target ‚ÄòMyProject‚Äô do
  use_frameworks!
  pod 'AlamofireImage', :git => 'https://github.com/Alamofire/AlamofireImage.git', :branch => 'swift3'
end
```

Error message from CocoaPods:

```
[!] Unable to satisfy the following requirements:

- `Alamofire (= 4.0.0-beta.1)` required by `AlamofireImage (3.0.0-beta.1)`

None of your spec sources contain a spec satisfying the dependency: `Alamofire (= 4.0.0-beta.1)`.
```
 I have the same issue... Should we solve it by specifying the swift3 branch, instead of a tag?
 Not really.

Use that:

```
target 'Project' do
    pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'swift3'
    pod 'AlamofireImage', :git => 'https://github.com/Alamofire/AlamofireImage.git', :branch => 'swift3'
end
```

Then `pod update` or `pod update Alamofire`. It's works well.

Learn more. [AlamofireImage#153](https://github.com/Alamofire/AlamofireImage/pull/153)
 @MainasuK hehe yeah exactly what I wrote... specifying branch, not "~> 4.X.Y..."
 It happened to me too - locally i was able to get it to build by removing the Manager.swift file.   Looking at previous commits it looks like this got added accidentally 
 The Alamofire.Manager class has been renamed SessionManager @edwardvalentini
 exactly.  so why was it added back into the repo in this commit e1cc66446c635cb593eaf4f7635d64242cf5a9e9 ?
 @edwardvalentini good question! As @cnoon proposed, maybe we should specify a commit rather than branch. Try `3cc5b4e`, it worked for me
 Pointing `Alamofire` and `AlamofireImage` both to the `swift3` won't work at the moment because `AlamofireImage`'s podspec file requires `Alamofire (= 4.0.0-beta.1)`. Are there plans to push one of these betas to Cocoapods trunk soon, or is there any other workaround? :)
 I couldn't find any commit that both:
- Compiles under Swift 2
- Targets a correct version of Alamofire to satisfy the Cocoapods dependency resolver.

:(
 Anyone found any way to resolve or workaround this yet? Following errors received when targeting Alamofire and AlamofireImage swift3 branches.

[!] Unable to satisfy the following requirements:
- `Alamofire (from`https://github.com/Alamofire/Alamofire.git`, branch `swift3`)`required by`Podfile`
- `Alamofire (= 4.0.0-beta.1)` required by `AlamofireImage (3.0.0-beta.1)`
 I moved over to Carthage as a work-around for the time being:

```
github "Alamofire/Alamofire" "swift3"
github "Alamofire/AlamofireImage" "swift3"
```
 +1

I have the same issue here and I'm so lazy to move all my project to Carthage üòÖ It would be great resolve that dependency. Thanks!
 Anyone found a non carthage workaround? GM dropped today so if ever there is a time?...
 @danielgalasko this works for me:

```
pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :commit => '3cc5b4e'
```
 but hmm was a couple of days ago since I ran `pod install`
 Perfect, that got it. Thanks @Sajjon 

```
pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire', :commit => '3cc5b4e'
pod 'AlamofireImage', :git => 'https://github.com/Alamofire/AlamofireImage', :branch => 'swift3'
```
 @danielgalasko I can't get Alamofire to compile using this commit...
 @KelvinJin commit `418b0fc` is ok for me.
 @bizhara For me, the issue is that I'm also using `AlamofireImage` at branch `swift3` which requires 4.0.0-beta.1 `Alamofire`. And that will conflict with `418b0fc`.

Updated:

Using the [pull request](https://github.com/Alamofire/AlamofireImage/pull/167) solved my problem!
 @KelvinJin How were you able to reference the pull request in your Podfile? 

I've tried referencing the latest commit SHA from the pull request:

``` ruby
pod 'Alamofire',
  git: 'https://github.com/Alamofire/Alamofire.git'

pod 'AlamofireImage',
  git: 'https://github.com/Alamofire/AlamofireImage.git',
  commit: '0469d9ebab544478ba6644a9881aba3833ce1a'
```

but this is the error I get:

``` bash
Analyzing dependencies
Pre-downloading: `Alamofire` from `https://github.com/Alamofire/Alamofire.git`
Pre-downloading: `AlamofireImage` from `https://github.com/Alamofire/AlamofireImage.git`, commit `0469d9ebab544478ba6644a9881aba3833ce1a`

[!] Error installing AlamofireImage
[!] /usr/local/bin/git checkout --quiet 0469d9ebab544478ba6644a9881aba3833ce1a

error: pathspec '0469d9ebab544478ba6644a9881aba3833ce1a' did not match any file(s) known to git.
```
 @adimitri not sure you can use that syntax (maybe I am wrong...), but I use this syntax:

``` swift
pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire', :commit => '3cc5b4e'
```
 Until the cocoapods spec gets updated, I've managed to get `pod install` to work with:

```
pod 'Alamofire',
  :git => 'https://github.com/Alamofire/Alamofire',
  :commit => '76558cf44275cc6a6b9ebee9e3ac53b281d504b2'
pod 'AlamofireImage', :git => 'https://github.com/Alamofire/AlamofireImage.git'
```

I guess all is in flux these days with developers catching up with Swift 3 and the new Xcode release, so this will probably be outdated pretty quickly.
 ```
pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire', :commit => '4.0.0'
pod 'AlamofireImage', :git => 'https://github.com/Alamofire/AlamofireImage'
```

This worked for me. 
 This was likely just a vestige of issues of getting ready to launch the new versions.

This works:

``` ruby
pod 'Alamofire', '~> 4.0.0'
pod 'AlamofireImage', '~> 3.0.0'
```
 Oh, i couldn't get that to work for me just now, but I will try it again. 
 I get this error when doing it that way

```
- `Alamofire (~> 4.0.0)` required by `Podfile`
None of your spec sources contain a spec satisfying the dependency: `Alamofire (~> 4.0.0)`.
```
 You might need to run the following command in your terminal first:

``` bash
$ pod repo update
```
  Hello, I have a share extension, and when i try to make the requests, it responds with nil immediately and no call is made.

the code is:

```
let configuration = NSURLSessionConfiguration.backgroundSessionConfigurationWithIdentifier(kAppGroup)

var manager = Alamofire.Manager(configuration: configuration)

...

manager.request(.POST, WS_URL_SHARE.stringByReplacingOccurrencesOfString("{type}", withString: type),
            parameters: [
                "name" : username!,
                "email" : email!,
                "message" : message,
                "file" : file //base64 string
            ],
            encoding: .JSON,
            headers: headers)
            .responseJSON { response in
                print(response.request)  // original URL request
                print(response.response) // URL response
                print(response.data)     // server data
                print(response.result)   // result of response serialization

                if let JSON = response.result.value {
                    print("JSON: \(JSON)")
                    self.delegate?.reportDidFinishLoading()
                } else {
                    self.delegate?.reportDidFinishLoadingWithError()
                }
        }
```

Is there something wrong?
  Hi, i'm using `pod 'Alamofire', :git => 'git@github.com:Alamofire/Alamofire.git', :branch => 'swift2.3'` to build with XCode 8 beta 6 and got some unwrapping errors.

> ‚Ä¶/AlamofireImage/Source/UIImage+AlamofireImage.swift:109:55: error: value of optional type 'CGImage?' not unwrapped; did you mean to use '!' or '?'?CGDataProviderCopyData(CGImageGetDataProvider(CGImage))
> ‚Ä¶/Pods/AlamofireImage/Source/UIImage+AlamofireImage.swift:109:32: error: value of optional type 'CGDataProvider?' not unwrapped; did you mean to use '!' or '?'? CGDataProviderCopyData(CGImageGetDataProvider(CGImage))
> ‚Ä¶/Pods/AlamofireImage/Source/UIImage+AlamofireImage.swift:118:45: error: value of optional type 'CGImage?' not unwrapped; did you mean to use '!' or '?'? let alphaInfo = CGImageGetAlphaInfo(CGImage)

It can be locally fixed by the xcode 8 conversion tool. But it would be nice if you guys could update those fixes into the pod.
Thanks.
 So far, I haven't had any issue using the `swift2.3` branch, although an official release supporting it would be nice! üëç 
 [!] Error installing Alamofire
[!] /usr/bin/git clone git@github.com:Alamofire/Alamofire.git /var/folders/nr/y4b16yzd3fz755xgzwr82t6h0000gn/T/d20161001-3415-hm57ut --template= --single-branch --depth 1 --branch swift2.3

Cloning into '/var/folders/nr/y4b16yzd3fz755xgzwr82t6h0000gn/T/d20161001-3415-hm57ut'...
Permission denied (publickey).
fatal: Could not read from remote repository.

Please make sure you have the correct access rights
and the repository exists.
  `debugPrint(response)` **without** `validate()`:

```
[Request]: <NSMutableURLRequest: 0x10040ddd0> { URL: https://platform.devtest.ringcentral.com/restapi/oauth/token }
[Response]: <NSHTTPURLResponse: 0x10025f980> { URL: https://platform.devtest.ringcentral.com/restapi/oauth/token } { status code: 400, headers {
    Connection = "keep-alive";
    "Content-Language" = en;
    "Content-Length" = 83;
    "Content-Type" = "application/json;charset=UTF-8";
    Date = "Fri, 26 Aug 2016 15:03:27 GMT";
    RCRequestId = "3e87d7de-6b9e-11e6-a8f4-005056bb594d";
    RoutingKey = SJC11P01PAS01;
    Server = "nginx/1.8.0";
    "Www-Authenticate" = "Basic realm=\"RingCentral REST API\"";
    "X-LoadMetric" = 4;
} }
[Data]: 83 bytes
[Result]: SUCCESS: {
  "error" : "invalid_request",
  "error_description" : "Unsupported grant type"
}
[Timeline]: Timeline: { "Request Start Time": 493916605.929, "Initial Response Time": 493916607.145, "Request Completed Time": 493916607.146, "Serialization Completed Time": 493916607.146, "Latency": 1.217 secs, "Request Duration": 1.217 secs, "Serialization Duration": 0.000 secs, "Total Duration": 1.217 secs }
```

`debugPrint(response)` **with** `validate()`:

```
[Request]: <NSMutableURLRequest: 0x10040a5b0> { URL: https://platform.devtest.ringcentral.com/restapi/oauth/token }
[Response]: <NSHTTPURLResponse: 0x100365bd0> { URL: https://platform.devtest.ringcentral.com/restapi/oauth/token } { status code: 400, headers {
    Connection = "keep-alive";
    "Content-Language" = en;
    "Content-Length" = 83;
    "Content-Type" = "application/json;charset=UTF-8";
    Date = "Fri, 26 Aug 2016 15:05:49 GMT";
    RCRequestId = "9328183a-6b9e-11e6-b36a-005056bb26b9";
    RoutingKey = SJC11P01PAS01;
    Server = "nginx/1.8.0";
    "Www-Authenticate" = "Basic realm=\"RingCentral REST API\"";
    "X-LoadMetric" = 4;
} }
[Data]: 83 bytes
[Result]: FAILURE: Error Domain=com.alamofire.error Code=-6003 "Response status code was unacceptable: 400" UserInfo={StatusCode=400, NSLocalizedFailureReason=Response status code was unacceptable: 400}
[Timeline]: Timeline: { "Request Start Time": 493916746.708, "Initial Response Time": 493916749.121, "Request Completed Time": 493916749.121, "Serialization Completed Time": 493916749.122, "Latency": 2.413 secs, "Request Duration": 2.413 secs, "Serialization Duration": 0.001 secs, "Total Duration": 2.414 secs }
```

So where has the following data gone:

```
{
  "error" : "invalid_request",
  "error_description" : "Unsupported grant type"
}
```

The data is very useful message from server. But `validate()` "eats" it.
 I'm getting the same issue...
 If you guys are referring to swift3 in Xcode8b6, then I can confirm that I am seeing this issue too :)
 @jkoepcke I am referring to Swift 2.2 in XCode 7.3.1 It seems this issue has nothing to do with Swift version.
 Agreed I'm also seeing it on XCode 7.3.1 and Swift 2.2.  I think it's happening because it overrides the NSError with this new object that contains the domain, code and UserInfo.  Instead it should probably leave the original object intact.  See this line: https://github.com/Alamofire/Alamofire/blob/1fc8fb2bedb6045741f39d6c82e9cba6fdf36050/Source/Validation.swift#L86
 Did someone found a workaround for this?
 Why not use the response passed into the callback method? I don't think it deletes the content in the response just signals their is an error and you can do some extra processing to read the error message in the response' content. 

'''
Alamofire.request(.GET, "https://httpbin.org/get", parameters: ["foo": "bar"])
         .validate()
         .responseJSON { response in
             switch response.result {
             case .Success:
                 print("Validation Successful")
             case .Failure(let error):
                 print(error)
                 print(response) //do extra stuff here. 
             }
         }
'''
 @jonathanpdiaz I gave up `validate()` and do the validate myself by checking status code.

@tobiasoleary I print the `response` in the body of this issue. And you can see that the useful message in response is gone. And that's why we have this issue here.
 I also gave up on using validate() for now and am checking the status code manually.

> On Aug 30, 2016, at 7:31 PM, Tyler Long notifications@github.com wrote:
> 
> @jonathanpdiaz I gave up validate() and do the validate myself by check status code.
> 
> @tobiasoleary I print the response in the body of this issue. And you can see that the useful message in the response is gone. And that's why we have this issue here.
> 
> ‚Äî
> You are receiving this because you commented.
> Reply to this email directly, view it on GitHub, or mute the thread.
 @gchaturvedi Are you using Alamofire 3.0? Because I having the full response even when their was an error was one of the major selling points for migrating to 3.0.

Second Bullet Point under [Benefits of Upgrading](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%203.0%20Migration%20Guide.md#benefits-of-upgrading)
 If you're using 2.0 here's an example of code I use to grab a custom error message from JSON.

```
class func completeAssignment(completeAssignmentURLPath completeAssignmentURLPath: String, musicNotation: String, completionHandler: (Result<JSONDict?>) -> Void) {
    let timeOfRequest = NSDate()
    Alamofire.request(SRFRouter.CompleteAssignment(completeAssignmentURLPath:completeAssignmentURLPath, musicNotation: musicNotation))
        .validate()
        .responseString {
            (request, response, result) in

            let deltaTime = -timeOfRequest.timeIntervalSinceNow
            Analytics.trackTimedEvent(category: "API", timeInterval:deltaTime, name: "Complete Assignment", label: request?.URL?.absoluteString ?? "Unknown URL Path")

            if let error = result.error as? NSError {
                trackAPIErrorEvent(error, name: "Complete Assignment")
            }

            if (API.DEBUG_printErrorResponses && result.error != nil)
                || API.DEBUG_printAllResponses
                || API.DEBUG_printCompleteAssignmentResponse
            {
                APIDebug.printResponseString(request, response, result.value, result.error as? NSError, printCookies: API.DEBUG_printCookies)
            }

        }
        .responseJSON {
            (request, response, result) in

            switch result {
            case let .Success(value):
                if let JSONDict = value as? JSONDict {
                    completionHandler(Result.Success(Box(JSONDict)))
                } else {
                    completionHandler(Result.Success(Box([:])))
                }
            case let .Failure(data, error):

                printError("API - Complete Assignment: \((error as NSError).description)")

                // Treat No Value error as successful. Error Domain=NSCocoaErrorDomain Code=3840 "No value." UserInfo={NSDebugDescription=No value.}
                let acceptableStatusCodes = 200..<300
                if let response = response, let data = data where acceptableStatusCodes.contains(response.statusCode) && data.isEqualToData(NSData()) {
                    completionHandler(Result.Success(Box([:])))
                } else {
                    let appError = APIErrorFactory.errorWithResponse(response, responseJSON:result.value as? JSONDict, error: error as NSError)
                    completionHandler(Result.Failure(appError))
                }
        }
    }
}
```
 @tobiasoleary Thanks, I'm doing something similar with the chaining since I'm using .responseObject with ObjectMapper.  I just think it's unfortunate to have to do .validate().responseString.responseJSON.  Ideally, you should just have to use .responseJSON and if it's not a 2xx response, it'll trigger .Failure.  In addition, it's very strange to have a non-2xx response actually bubble up in .Success.  I will try to upgrade to 3.0 if it solves the issue, we're on Swift 2.2 so I'll have to see if it's even possible for me.
 I just checked, I'm using pod 'Alamofire', '~> 3.4.1'.  Still see this issue. @tobiasoleary 
 @tobiasoleary 

> Because I having the full response even when their was an error was one of the major selling points for migrating to 3.0.

Do you mean something like this `[Result]: FAILURE: Error Domain=com.alamofire.error Code=-6003 "Response status code was unacceptable: 400" UserInfo={StatusCode=400, NSLocalizedFailureReason=Response status code was unacceptable: 400}`  ? But this is not the original message from server side.
 Same problem here. I have to use my own validation method.
 @tylerlong Does result.value not contain the error message from the server? 
 @tobiasoleary  No, it doesn't. And that's why this issue was created in the first place.

It does contain some quite useless message like `Response status code was unacceptable: 400` which is not the message from the server at all.
 @cnoon, the data is not gone, but it's **changed**.  In my example above It was "Unsupported grant type" from the server, but was changed to "status code was unacceptable: 400" by AF 3, which is **indeed useless / redundant** because it could be inferred by `response.response!.statusCode`. The server told me why it is 400 status code which is useful but was changed to something useless. Correct me if I am wrong.
 @tylerlong Try this

```
if let responseData = response.data {
    let responseDataString = NSString(data: responseData, encoding:NSUTF8StringEncoding)
    print(responseDataString)
}
```

Does that print the JSON, you expected? 
 Thanks @cnoon somehow I missed "data" by itself in the response..still new to debugging in Xcode I guess.  I still think it's sort of strange for the API to change responseData / responseDataString and instead have you look at "data" for what you were originally returning from the backend.  I was initially just paying attention to statusCode, json, msg, responseData & responseDataString.  Perhaps I can help contribute to the docs to ensure no one else gets confused, clearly it's quite a few of us.  üëç 

The above worked @tobiasoleary and I'm able to see the correct response.  @tylerlong you should be able to do the same.  If not please let me know and I can try and help.

Cheers,
Gaurav.
 Guys I've got your point. But why is it behaving like this, so weird. There are other 4 people in this thread who were confused by it. `debugPrint` gave me the illusion that `response.result.value` contained message from server. 

Thank you for the clarification!
 I've added a Stackoverflow question about similar to this and Mr. Noon responded. 

http://stackoverflow.com/questions/39323247/alamofire-parse-response-data-when-validate-fails/39335811#39335811

Also I've added a feature request that I think could be helpful. If any of you agree, please +1. 

https://github.com/Alamofire/Alamofire/issues/1459
  Hi, I want to send my JSON string directly to Server body. But here now im coverting my json string to dictionary and that dictiaonry passing to parameters.

 So is there any alternative to send plain json object. 
 Had the same thing today and I searched backwards in closed tickets and found this.  
    https://github.com/Alamofire/Alamofire/issues/1103

Passing in JSON works in his initial comment if you also add the following to it
            mutableRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")
 Sure, i will request in stack overflow. but in Swift we care objctes file look like follwoing. 

Class Obj : NSObject {
var name : String?
var emial : String?

}

So, how can we send like this object to server. i tried to convery above object to jsonstirng and then i need to convery jsonstring to dictionary like above you mentions. but too many steps to do.
 did you found any solution, for me I'm using struct, but the same problem on alamofire.upload  I repeatedly receive this error message when trying to build my test project. It seems somewhat intermittent, though when I receive it I don't know how to fix it. Sometimes it goes away when I re-install cocoapods. Not sure if it's an issue with Alamofire or Cocoapods, but I thought I would start here.

It's of interest to note that my actual project builds just fine, this is only an issue with my test project.

`ld: framework not found Alamofire for architecture i386
clang: error: linker command failed with exit code 1 (use -v to see invocation)`
 @mattnedrich 

I finally managed to resolve this for my case. My setup is a little different from you, but the symptoms were exactly the same. Could not build test target, but the project built just fine.

I use carthage, and the issue ended up being Xcode trying to link an OS X framework in an iOS project.

The solution was to change the Build Setting: "Framework Search Paths" to point at the iOS build folder, instead of it being blank.

While it might not work exactly for you, verifying that setting could be illuminating.
 I do also have this issue. Installing Alamofire through CocoaPods.
  I had a question [here](https://github.com/Alamofire/Alamofire/issues/1376) 
So let's take a simple example
I have a controller that stores a reference for my request

``` swift
class ViewController: UIViewController {
    var mrRobot: MRRobot = MRRobot()
    var request: Request!

    @IBAction func ElliotsTime(sender: AnyObject) {
        self.requres = self.mrRobot.hackSociety().response...
    }
}
```

and I want to wrap the generation/creation of my request. Just to reduce the code inside controller.

``` swift
func hackSociety() -> Alamofire.Request {
    var request: Alamofire.Request! = nil
    Alamofire.upload(CRUDRouter(self, options: options).method(.POST), multipartFormData: { (multipartFormData) in
        multipartFormData.appendBodyPart(fileURL: self.pentagonSecrets, name: "kitty")
    }) { (encodingResult) in
        switch encodingResult {
        case .Success(let upload, _, _):
            request = upload // My request here only
        case .Failure(let encodingError):
            print(encodingError)
        }
    }
    return request
}


```

So it becomes a problem. If I want instantly return a reference on that request I am not able to do this. As solution I can add completion block to that method to handle encoding error. But it is not tasty. In that case it becomes 100 completion blocks when you have 100 multipart requests.

Did I miss something? How I can handle that situation in correct way to have clear chaining without extra completions? I also checked other branches but they have the same logic. Is it only by forking?
  > ```
> func requestForData() {
>     let url = domain + inputTextfield.text!.lowercased()
>     let request = Alamofire.request(url, withMethod: .get)
>     request.responseJSON(completionHandler: {response in
>         let error = response.result.error
>         if error == nil {
>             let dict = response.result.value as? NSDictionary
>             self.viewModel.update(with: false, with: dict?["message"] as! String, with: "Send")
>             if dict?["error"] as! Bool {
>                 print("error!!!!")
>             }else {
>                 print(dict)
>                 self.requestStatus = .succeed
>                 return
>             }
>         }else {
>             self.viewModel.update(with: false, with: "Network Error!", with: "Send")
>         }
>         self.requestStatus = .error
>         return
>     })
> }
> ```
## Could you help me to code to set timeout of the request?
  I updated to Xcode 8b6 from Xcode 8b5
I just updated the pods.. Nothing else :(

Now I get this error:

> Module 'Alamofire' has no member named 'Manager'

on line:
`var alamoFireManager = Alamofire.Manager.sharedInstance`
 try replace `Alamofire.Manager` with `SessionManager`
  Hello dear Alamofire developers, I have a problem now that after server returns "401 Authorization Required" your library calling  same request second time, receive the same error and only after that stopping and make callback with error.

My code is super standard:

```
let aReq = Alamofire.request(mutableURLRequest) //request with some parameters
aReq.responseJSON { response in
    //do something with response
}
```

After some investigation I find that in file Request.swift in line 304:

```
if challenge.previousFailureCount > 0 {
                    disposition = .RejectProtectionSpace
                } else {
                    credential = self.credential ?? session.configuration.URLCredentialStorage?.defaultCredentialForProtectionSpace(challenge.protectionSpace)

                    if credential != nil {
                        disposition = .UseCredential
                    }
                }
```

challenge.previousFailureCount is 0 after first call and first error, why it behaves like this ??? Only after second call it equal 1 and Alamofire make callback with error. Can I setup library somehow to stop request and return with error after first call ?

iOS 9.3.1, Alamofire 3.4.1
 @cnoon Hi, sorry for late answer. I didn't use .authenticate method, only in parameters I add login and password and if they true I receive Code 200 from server if not server returns Error 401 Authorization Required and after that Alamofire (or core iOS api) again doing the same request and again receive 401, but where is the sense if server return 401 it must stop.

I call only:

```
let aReq = Alamofire.request(mutableURLRequest) //request with some parameters
aReq.responseJSON { response in
    //do something with response
}
```

and in parameters I have 
 @cnoon after deeper investigation, everything working for me if in Request.swift in line 293 I add:

```
if credential != nil {
       disposition = .UseCredential
  } else {
       disposition = .CancelAuthenticationChallenge
}
```

After first request with error 401 

`challenge.previousFailureCount = 0`

and

`credential = self.credential ?? session.configuration.URLCredentialStorage?.defaultCredentialForProtectionSpace(challenge.protectionSpace)`

credential = nil, 

You sad "If there's no credential, then the request will immediately fail and won't be retried" but request still resending.
  This line `Alamofire.request(link, withMethod: .POST, parameters: parameter, encoding: .json).responseJSON` keep getting this below error 

> Expression type 'Request' is ambiguous without more context

```
let parameter:[String:Any] = [
        "scope":"\(scope)",
        "client": "\(clientId)"
    ]

Alamofire.request(link, withMethod: .POST, parameters: parameter, encoding: .json).responseJSON{

}
```

I'm using Alamofire 4.0.0 beta 1 & xcode 8 beta 6
  I'm using AIamofire 4.0.0 with xcode 8 beta 6 and keep getting these errors: Expression type 'Request' is ambiguous without more & [String:String] is not convertible to [String : AnyObject]. Is it a bug?

http://stackoverflow.com/questions/39098799/alamofire-4-0-0-stringstring-is-not-convertible-to-string-any-request?noredirect=1#comment65544539_39098799
  The User-Agent header is grabbing the infoDictionary object for the kCFBundleVersionKey key which is the app build number. It should be grabbing the object for the CFBundleShortVersionString key which is the actual version number. Same issue was fixed in AFNetworking, [issue 1907.](https://github.com/AFNetworking/AFNetworking/issues/1907)
 Great! Thanks for keeping my commit :)
  Hi,

I am using Alamofire by using URLRequestConvertible (API Parameter Abstraction) method. It simplifies a communication in lot easier way. Thanks a lot to Alamofire and Team.

I have one query which I already searched in Issues & Pull Request but didn't found solution anywhere. If I want to pass a custom object to my POST request body, then how to Serialize the custom object with Alamofire. Will this be possible with URLRequestConvertible methods?

I saw various example which shows the serialization of Response. But I need to Serialize the Request object with Alamofire.

Is there such a provisioning? If not, can I intercept any request method to serialize the custom object?
  ![screen shot 2016-08-17 at 4 27 30 pm](https://cloud.githubusercontent.com/assets/17093329/17757351/09a90a7e-64b4-11e6-8cc9-f08c69be039a.png)
  Hi,

When I cancel the download request and close the app, I found there is still big data in my app.
I think it may be resume data. I don't want to resume the download.
I wanna delete the resume data after canceling the download request.
How can I do it?

Thanks!
  Hi im getting this error

Optional(Error Domain=com.alamofire.error Code=-6006 "JSON could not be serialized. Input data was nil or zero length." UserInfo={NSLocalizedFailureReason=JSON could not be serialized. Input data was nil or zero length.})

``` swift
 let parameters: [String: AnyObject] = [
    "orderNo":orderId,
    "cart": [
        [
            "name": cartItem.name,
            "quantity": cartItem.quantity,
            "amount": cartItem.amount,
            "description": cartItem.description
        ]
    ],
    "description": description
]

let headers = ["Content-Type": "application/json"]

Alamofire.request(.POST, UrlManager.someUrl, parameters: parameters, encoding: .JSON, headers: headers).responseJSON { response in
    debugPrint(response)
}
```

So this req is not happening, i need in cart send array of unescaped json.
Also found http://stackoverflow.com/questions/37310679/alamofire-json-serialization-error-swift-2-0
Its possible sending array of dict as param?

Regards
  Brings Swift 3 into balance with Xcode Beta 6.
All Tests pass.
Also, brings back iOS 8 compatibility via @availability for streaming functions and properties.
  Hello!
I have some problems with validating an answer from a server.
I need to know if it is an image, or an error in json format by content-type header.
Here is my code:

```
_ = APIClient.sharedInstance.defaultManager.download(
            APIClient.Router.BackgroundForLoginScreen(self.backgroundImageCreationTimestamp ?? "0"),
            destination: {
                (_,_) in
                return NSURL(fileURLWithPath: self.newBackgroundImageFilePath!)
            }
            )
             .validate(statusCode: 200..<300)
             .validate(contentType: ["image/jpeg"])
            .progress {
                [weak self] bytesRead, totalBytesRead, totalBytesExpectedToRead in

            }.response{
..
}

```

With `validate(statusCode: 200..<300)` all is ok.
But content type validation is not working. I have investigate into why it is returning success when I getting html/text answer from server instead image/jpeg. 
I found that reason is the 
`guard let validData = self.delegate.data where validData.length > 0 else { return .Success }` 
in validate(statusCode: ) in Validation.swift.
When I comment this line all is looks like working good. Also I have checked that validData is not used anymore in validate(contentType:). 

Is it anything that I have missed out?
  Branch swift3 version 4.0.0 is currently not supported for Xcode 8 Beta 6.
@cnoon: Feel free to ask if you need some help with a PR?
 i got some changes for Xcode 8 Beta 6.
Feels like some fundamental refactoring is necessary.
You can have a look here.
Some parts feel quite _hacky_.
https://github.com/elm4ward/Alamofire/commit/7f74c6dcdc249c7d9cf2f742441c91ad9f2f8981
 Hi guys!
How long does it take to adopt Alamofire to Xcode 8 beta 6?
   AFAIK Alamofire is supporting iOS 9.0 and up because they're dropping support for the two year-old iOS 8.0 in Alamofire version 4.0. So either you can stay on the commit before "update podspec" or you can use the master branch for now (before it gets bumped to 4.0 too). The median solution would be to deploy your app for iOS 9.

See this explanation : https://github.com/Alamofire/Alamofire/issues/1316#issuecomment-239899428
  "https://httpbin.org/get" works when doing a get but "http://httpbin.org/get" doesn't (response is nil)
  I'm using the latest xcode beta (downloaded two days ago) with swift 3 and I've tried six different solutions to the "No such module 'Alamofire'" error, with no success. I've used cocoapods, i've tried following instructions to install manually. Every time, same error. 
 This is also happening on xcode Version 7.3.1 with swift 2. :(
 You need to open a command line and go to the root of your project. Then do "pod install" so that cocoa pods installs all the specified pods mentioned in your podfile
 Yes, I've used cocoapods to install 8 out of 10 times.
 Can you post the content of your podfile ?
  Hello,

I have to connect to a strange webservice were i have to attach parameter to the url and as json body. How can I accomplish this in alamofire?

The request should look like this:

```

https://www.example.com/getFoo?Bar=True

HTTP-header values: Content-Type:application/json
Body: { "ParameterA": "Test" }
```

 For my requests I have a custom URLRequestConvertible class.
  > Error Domain=NSCocoaErrorDomain Code=3840 "Unescaped control character around character 114." UserInfo={NSDebugDescription=Unescaped control character around character 114.
 > Error Domain=NSCocoaErrorDomain Code=3840 "Unescaped control character around character 981." UserInfo={NSDebugDescription=Unescaped control character around character 981.}

I am receiving above **error**. Any solution please....
 @maniyarpayal  I escaped from client side and Unescaped from client side, so it solved my error.
  Refactored All APIs for Swift 3
  Hello @cnoon,

I am using Alamofire but right now i am facing issue on swift 3. so please help me. Here i am adding my pod file text and also error.

My Deployment target is 8.0 

source 'https://github.com/CocoaPods/Specs.git'
platform :ios, '8.0'
use_frameworks!
target 'project' do

pod 'Alamofire', '~> 4.0'

end
If i am wrong then suggest me.
![error](https://cloud.githubusercontent.com/assets/16097116/19337266/394c2a8c-9131-11e6-9d3b-151e5a4b793f.png)
 so i want  to use alamofire library in deployment target 8.0 and also use in swift 3, so plz suggest better option. @cnoon 
  after adding the Alamofire pod and installing it, i started getting alerts, such as:
...target overrides the `EMBEDDED_CONTENT_CONTAINS_SWIFT` build setting defined...
...target overrides the `OTHER_SWIFT_FLAGS` build setting defined in...

without the Alamofire, everything is fine, and every install and update goes smoothly, but once i add the Alamofire, BOOM! alerts.....
any advice?
 i'm actually using Xcode 7.3.1
 Xcode Version 7.3.1 (7D1014)
CocoaPods version 1.0.1

not sure if that was clear, but the alerts i'm getting are during the CocoaPods update/installation process, right after completing it, it throws me these alerts for every target i have, and they appear only for Alamofire (i.e. removing pod 'Alamofire' from the Podfile doesn't give any alert).
 any news?
  Refactored All APIs for Swift 3
  Does Alamofire automatically compress the multi-part requests/POST/PUT request with Gzip, or do we have to specify or use any extra frameworks to achieve the Gzip compression.
  For the function of Manager:   

 public func request(
        method: Method,
        _ URLString: URLStringConvertible,
        parameters: [String: AnyObject]? = nil,
        encoding: ParameterEncoding = .URL,
        headers: [String: String]? = nil)

Shouldn't the type of parameters be 'AnyObject?' instead of '[String: AnyObject]?' ? Because if I want to make a POST request and encode parameters as json, type 'AnyObject?' will be more flexible.

Thanks.
  I updated from Beta 4 to Beta 5 and now I'm getting this error all over my project:
'URLSessionStreamTask' is only available on iOS application extension 9.0 or newer

The deployment target is 10.0 and my App has an today extension...
 I went back to commit "a94323c6e556d47408b6186c948324b040d7ffc8"
There is everything fine and it works again for now...
 Adjusting the Deployment Target for Alamofire Pod to iOS 10.0 fixes that
 I also experienced the same thing. Bumped the version to 9.0 and all was fine.
 I believe this will be fixed by https://github.com/Alamofire/Alamofire/pull/1401
  fix MultippartFormData.append overload parameter name withN -> withName. This matches the rest of the append overloads in this file
  i install Alamofire from cocoapod 
`pod 'Alamofire', '3.3.1'`

but i get alot errors , i using xcode 8 beta and not update to swift 2.3 or swift3

![screen shot 2016-08-10 at 8 50 38 pm](https://cloud.githubusercontent.com/assets/1476754/17566718/d85c7b26-5f3c-11e6-8c49-9351cdcdca53.png)
 @jshier thanks I found it in stackoverflow.
 http://stackoverflow.com/a/38085003/3393841
  i want to pass custom header in Alamofire.

[String : AnyObjetc]
I have surfed a lot on internet but fails to get the answer.

all the solutions are [String : String]

let headers = [
        "Authorization": "Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==",
        "Content-Type": "application/x-www-form-urlencoded"
    ]
 let Header =
        [
            "ActorImageDetails" : [

```
                                "TokenId":"bwymina009aEMyCknQHi87B2r0RNhffnrj8sXayGt1OSWsRmj2+daw==",
                                "UserId":"400295",
                                "AppId":"1"
                            ]

    ]
```
 How can i pass like above
 the header in your 2nd comment is a [String: [String:String]]. It should work if you're doing a request which accepts [String: AnyObject] as one of the parameters.
  ServerTrustPolicy has some compile errors due to swift3 updates.

function "public static fun certificatesInBundle" does not compile due to "bundle.paths(forResourcesOfType: fileExtension, inDirectory: nil)". This call is now to be replaced by bundle.pathsForResources(ofType: fileExtension, inDirectory: nil)
  This gets the swift 2.3 branch compiling on latest XCode
  Hello Everybody,

I am have a issue to load my embedded certificate string from my code and transform in a valid certificate. I have de follow code

```
let strCert: String = ""
+ "-----BEGIN CERTIFICATE-----\r\n"
//MY CERTIFICAT CRT 
+ "-----BEGIN CERTIFICATE-----\r\n"

var result: UnsafeMutablePointer<Unmanaged<AnyObject>?> = nil
var error = noErr
let data = strCert.dataUsingEncoding(NSUTF8StringEncoding)
let cert = SecCertificateCreateWithData(kCFAllocatorDefault, data!)

var serverTrustPolicy = ServerTrustPolicy.PinCertificates(
    certificates: [cert!],
    validateCertificateChain: true,
    validateHost: true)
```

The main problem is its works if I load the .CER and .DER version from bundle, but when I try to load from string of my .CRT its not working =( .

I can't put the certificate file at my project, because of security policy of my compony, and to help the situation on Android project works with the string but on IOS not =( .

Some one could help me with this?
  - I'm configuring the Alamofire Manager with HTTPMaximumConnectionsPerHost equals to 4.
- And I'm start Downloading 5 items, then 4 items start downloading and the the 5th item is waiting in queue.
- When I Pause one of the first 4th item, I'm expecting the 5th item to start downloading. This is not happening and this is my issue üíÉ üëØ 
  <img width="423" alt="screen shot 2016-08-08 at 3 49 05 pm" src="https://cloud.githubusercontent.com/assets/1938047/17481922/03cfd7a0-5d88-11e6-8c6d-be73ae3c2f0e.png">
  <img width="423" alt="screen shot 2016-08-08 at 3 49 12 pm" src="https://cloud.githubusercontent.com/assets/1938047/17481945/2c8329fe-5d88-11e6-9a58-b1185f9a6567.png">
  Hi there,
I'm seeing crash with this crashlog:

```
0   Alamofire                            0x0000000100604888 Alamofire.Manager.((download in _AC30EB7DC0B48675890BB32A64AA629E) (Alamofire.Manager.(Downloadable in _AC30EB7DC0B48675890BB32A64AA629E), destination : (__ObjC.NSURL, __ObjC.NSHTTPURLResponse) -> __ObjC.NSURL) -> Alamofire.Request).(closure #3) (Download.swift:49)
1   Alamofire                            0x00000001006031b4 partial apply forwarder for reabstraction thunk helper from @callee_owned (@owned __ObjC.NSURLSession, @owned __ObjC.NSURLSessionDownloadTask, @owned __ObjC.NSURL) -> (@owned __ObjC.NSURL) to @callee_owned (@in (__ObjC.NSURLSession, __ObjC.NSURLSessionDownloadTask, __ObjC.NSURL)) -> (@out __ObjC.NSURL) (Download.swift:0)
2   Alamofire                            0x0000000100604080 function signature specialization <Arg[0] = Owned To Guaranteed, Arg[1] = Owned To Guaranteed, Arg[2] = Owned To Guaranteed> of Alamofire.Request.DownloadTaskDelegate.URLSession (__ObjC.NSURLSession, downloadTask : __ObjC.NSURLSessionDownloadTask, didFinishDownloadingToURL : __ObjC.NSURL) -> () (Download.swift:199)
3   Alamofire                            0x0000000100603b6c Alamofire.Request.DownloadTaskDelegate.URLSession (__ObjC.NSURLSession, downloadTask : __ObjC.NSURLSessionDownloadTask, didFinishDownloadingToURL : __ObjC.NSURL) -> () (Download.swift:192)
4   Alamofire                            0x000000010060d9d8 function signature specialization <Arg[0] = Owned To Guaranteed, Arg[1] = Owned To Guaranteed, Arg[2] = Owned To Guaranteed> of Alamofire.Manager.SessionDelegate.URLSession (__ObjC.NSURLSession, downloadTask : __ObjC.NSURLSessionDownloadTask, didFinishDownloadingToURL : __ObjC.NSURL) -> () (Manager.swift:657)
5   Alamofire                            0x000000010060a4b4 @objc Alamofire.Manager.SessionDelegate.URLSession (__ObjC.NSURLSession, downloadTask : __ObjC.NSURLSessionDownloadTask, didFinishDownloadingToURL : __ObjC.NSURL) -> () (Manager.swift:0)
6   CFNetwork                            0x00000001813a1bb8 __82-[NSURLSession delegate_downloadTask:didFinishDownloadingToURL:completionHandler:]_block_invoke + 32
7   Foundation                           0x000000018164c540 __NSBLOCKOPERATION_IS_CALLING_OUT_TO_A_BLOCK__ + 12
8   Foundation                           0x000000018159e870 -[NSBlockOperation main] + 92
9   Foundation                           0x000000018158ee48 -[__NSOperationInternal _start:] + 600
10  Foundation                           0x000000018164e934 __NSOQSchedule_f + 220
11  libdispatch.dylib                    0x00000001806dd47c _dispatch_client_callout + 12
12  libdispatch.dylib                    0x00000001806e94c0 _dispatch_queue_drain + 860
13  libdispatch.dylib                    0x00000001806e0f80 _dispatch_queue_invoke + 460
14  libdispatch.dylib                    0x00000001806eb390 _dispatch_root_queue_drain + 724
15  libdispatch.dylib                    0x00000001806eb0b0 _dispatch_worker_thread3 + 108
16  libsystem_pthread.dylib              0x00000001808f5470 _pthread_wqthread + 1088
17  libsystem_pthread.dylib              0x00000001808f5020 start_wqthread + 0
```

Alamofire used by SwiftyDropbox. It happens occasionally and I cannot find a way to reproduce it. SDK v3.3.1

Does anyone has any tips? Thanks
 @jshier Sorry for the delay.
Alamofire v3.3.1, seeing logs on devices with iOS 9.3.2-4, Xcode 7.3.1.
  It is possible to override `request()` because it is in the body of the `Manager` class, but `download()` is defined in an extension - attempting to override it results in a "Declarations from extensions cannot be overridden yet" compiler error.

Would it be possible to put the public signatures for `download()`, `upload()`, etc. into the main `Manager` class, so that they can be overridden just like `request()`?
  I was wondering in what case the `NSHTTPURLResponse` of the completion handler might be nil when calling the following `response` method on a `Request`. Same question goes actually for `NSURLRequest`.

```
func response(queue queue: dispatch_queue_t? = default, completionHandler: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Void) -> Self
```

Thank you.
 Okay thanks guys.
  Actually this is my first time using ALAMOFIRE in my new Framework : Its really frustrating when trying to invoke its method
and not executing : HELP !!!!! 

 var rest: MockupClass!
    override func setUp() { [self] 
        super.setUp()
        // Put setup code here. This method is called before the invocation of each test method in the class.
        self.rest = RestfulServiceImpl.sharedInstance
    }

```
override func tearDown() {
    // Put teardown code here. This method is called after the invocation of each test method in the class.
    super.tearDown()
}

func testExample() { [self]
    // This is an example of a functional test case.
    // Use XCTAssert and related functions to verify your tests produce the correct results.
    self.rest.get("http://demo5908705.mockable.io/",
                  path: "demo",
                  params: ["name" : "moses"],
                  headers: ["contentType": "application/json"],
                  completion: { (result) in

                // Expected Data
                let dict = ["name" : "fjf"]
                let expected = try! NSJSONSerialization.dataWithJSONObject(dict, options: NSJSONWritingOptions.PrettyPrinted)

                  XCTAssertEqual(String(data: expected, encoding: NSUTF8StringEncoding),
                    String(data: result as! NSData, encoding: NSUTF8StringEncoding))

    })

}
```
  Sorry for opening an issue for this, but I'm trying to use the Swift 2.3 version of Alamofire in my project. But what version do I need to use in my Podfile?
  I try use this example:

```
Alamofire.upload(
    .POST,
    "https://httpbin.org/post",
    multipartFormData: { multipartFormData in
        multipartFormData.appendBodyPart(fileURL: unicornImageURL, name: "unicorn")

    },
    encodingCompletion: { encodingResult in
        switch encodingResult {
        case .Success(let upload, _, _):
            upload.responseJSON { response in
                debugPrint(response)
            }
        case .Failure(let encodingError):
            print(encodingError)
        }
    }
)

```

my unicornImageURL is: file:///var/mobile/Containers/Data/Application/B57B4D83-0485-4946-B615-81FC3E0FC0B6/Documents/videoFileName.mp4

but i get this error: Error Domain=NSURLErrorDomain Code=-1000 "The file URL does not point to a file URL
 Kshysius,
I am having the same exact response that you are.  I am not sure if it is unable to pull the file out of the document directory or I am not creating the NSURL object correctly.

> let fileName = "2016-7-8-KAC0000398.pdf"
> let documentDirectory: AnyObject = path.objectAtIndex(0)  
> let pdfPathWithFileName = documentDirectory.stringByAppendingPathComponent(fileName as String)
> let NSfilename = NSURL(fileURLWithPath: pdfPathWithFileName)

The URL show almost exactly as yours does:

file:///Users/test/Library/Developer/CoreSimulator/Devices/
4F411B43-C96E-4DD4-A2B6-00486FDC4AFA/data/Containers/Data/Application/348A6BA6-8E43-4975-A537-F4C8C42F5B7E/Documents/2016-7-8-KAC0000398.pdf
  Xcode beta seed 4 included `ErrorProtocol` being renamed to `Error` and also implicit bridging from `NSError` to `Error`. 

This leads to quite of a lot of confusion between classes/structs/enums which are named directly `Error` such as in here.  It may be better to come to a discussion around possibly renaming the Error.swift struct rather than mark each instance of `Error` with `Swift.Error` instead.

Second, there is currently a regression (possibly a permanent change) which causes Swift's `URL` object to return nil when created with an empty path (https://github.com/apple/swift/pull/3910).  This causes the test `MultipartFormDataFailureTestCase.testThatAppendingFileBodyPartWithInvalidLastPathComponentReturnsError()` to crash due to force unwrapping.  I have disabled that test for the time being with a comment as I've seen with a few other tests being disabled.  A workaround would be to use NSURL which continues to return a non-nil empty URL object.

Finally, there is a change in the error returned in this test `testThatAppendingFileBodyPartThatIsNotFileURLReturnsError`.  The string has changed, I've included a macro around for Swift 3. If the error message is actually an OS change and not a swift change it may be better to switch that test to check OS version.

Other then these points, all the tests passed.
Let me know if theres anything else that I need to fix! :)
  Need help with syntax to find a file in the documents directory not the main bundle so that I can upload the file with:

Alamofire.upload(.POST, updateCriteria, file: resourceUrl)

The example shows taking the file from the main bundle.  I can seem to figure out how to get the file out of the documents directory into an object that i can pass to the upload routine so Alamofile will upload it.  Any hints or examples?

Thanks
 Hey @jrlanders were you able to find a solution to this?   I started to use Alamofire and faced with a lot of issues during request building.
Alamofire is super async it is nice but at the same time it is stateless. For example, I am building multipart request and it immediately goes to encode my data and parameters using another queue. Only after successful encoding I can obtain real Request reference. So it requires from me create extra `var request: Request?` somewhere and wait when encoding will finish. So literally we have 2 completion blocks one is for encoding and one is for response. Why it is like this? Why it is not merged to the same completion that I expect into response?
  When I want to get the image from my school website,there are some error.
I found if the url with **Chinese words(maybe other languages)**,the init of NSURL return **nil**.(It's the swift bug,not your code )
So I add an String extension in the file to make the framework stronger, and run the demo,the Problem solved .I'm sorry I cant read all files at once ,so maybe It's not the best position to code,but I wish it will help you .Thanks
 Thank you so much to tell me these things.
  Hello! 
I have a problem with sending files in array. I need send array of files with key(for example "images).
How can I do it?
  i used alamofire for the other requests where is sets the content type as follows 
**{ status code: 200, headers {
    Connection = "keep-alive";
    "Content-Length" = 179;
    "Content-Type" = "application/json; charset=utf-8";
    Date = "Wed, 27 Jul 2016 11:16:25 GMT";
    Etag = "W/\"b3-vhys+vZ9h+PEYCvzLEflJw\"";
    "X-Powered-By" = Express;
} }**

but for this specific request it sets the content type as text/html

**{ status code: 500, headers {
    Connection = "keep-alive";
    "Content-Length" = 1773;
    "Content-Type" = "text/html; charset=utf-8";
    Date = "Wed, 27 Jul 2016 11:16:36 GMT";
    Etag = "W/\"6ed-VP4lf3zxrU/ssT2vFK37nw\"";
    "X-Powered-By" = Express;
} }**

what could be the problem?
 thanks @cnoon 
  Hi.

I have set the custom header to issue  #111 as a reference.
But it does not work.

https://github.com/Alamofire/Alamofire/issues/111#issuecomment-56440394

```
    // Creating an Instance of the Alamofire Manager
    var manager = Manager.sharedInstance

    // Specifying the Headers we need
    manager.session.configuration.HTTPAdditionalHeaders = [
        "Content-Type": "application/x-www-form-urlencoded",
        "Accept": "application/vnd.lichess.v1+json",
        "User-Agent": "007"
    ]
```

How can I solve?

This does not work...

```
manager.session.configuration.HTTPAdditionalHeaders.updateValue("007", forKey: "User-Agent")
```

This does work!

```
let headers = [
    "User-Agent": "007"
]
Alamofire.request(.GET, "http://headers.jsontest.com/", encoding: .JSON, headers: headers)
            .validate()
            .responseJSON { response in
                print(response.result.value)
            }
```

Is this the right approach?
  Hi,

I just updated my XCode this morning and since then the response.data in case of error is in hexa instead of getting my dict.

Here's my request output with curl: 

```
HTTP/1.0 400 Bad Request
Date: Wed, 27 Jul 2016 10:02:20 GMT
Server: WSGIServer/0.2 CPython/3.4.3
X-Frame-Options: SAMEORIGIN
Content-Type: application/json
Vary: Accept, Cookie
Allow: POST, OPTIONS

{"username":["A user with that username already exists."]}%
```

My swift code:

```
let answer = Alamofire.request(.POST, url, parameters: parameters, headers: headers, encoding: encoding)
                let validated = answer.validate(statusCode: 200..<300)
                if jsonResponse{
                    validated.responseJSON { response in
                        switch response.result {
                            case .Success:
                                resultHandler(data: response.result.value!, errorMessage: nil)
                            case .Failure(let error):
                                resultHandler(data: nil, errorMessage: error.localizedDescription)
                                print("------------------")
                                print("ERROR: ", error)
                                print("RESPONSE: ", response.response)
                                print("RESULT: ", response.result)
                                print("DATA: ", response.data!)
                                print(error.localizedDescription)
                                print("--------END POST ERROR----------")
                        }
                    }
                }
```

My output debug:

```
------------------
ERROR:  Error Domain=com.alamofire.error Code=-6003 "Response status code was unacceptable: 400" UserInfo={StatusCode=400, NSLocalizedFailureReason=Response status code was unacceptable: 400}
RESPONSE:  Optional(<NSHTTPURLResponse: 0x146f16ff0> { URL: http://10.1.10.194:8000/auth/v1/register/ } { status code: 400, headers {
    Allow = "POST, OPTIONS";
    "Content-Type" = "application/json";
    Date = "Wed, 27 Jul 2016 10:23:04 GMT";
    Server = "WSGIServer/0.2 CPython/3.4.3";
    Vary = "Accept, Cookie";
    "X-Frame-Options" = SAMEORIGIN;
} })
RESULT:  FAILURE
DATA:  <7b227573 65726e61 6d65223a 5b224120 75736572 20776974 68207468 61742075 7365726e 616d6520 616c7265 61647920 65786973 74732e22 5d7d>
L‚Äôop√©ration n‚Äôa pas pu s‚Äôachever. Response status code was unacceptable: 400
--------END POST ERROR----------
```
 Hi Christian,

Thank you very much for your help I will test that and sorry if I put it on the wrong channel. I did that because yesterday before upgrade to Xcode 7.3.1 the error dictionary was parsed and in my error variable... This morning the error var content changed to a generic message so I did search my previous datas elsewhere.

Cheers !
  When request is cancelled or request is timed out callback is called with response.response = nil and there is no way to differentiate it.
  When you try to use the Alamofire from branch swift3 with Xcode Version 8.0 beta 2 (8S162m), the compiler complains about the old statements used. Like:  

Old one:
guard let validData = self.delegate.data, validData.count > 0 else { return .success }

New one
guard let validData = self.delegate.data where validData.count > 0 else { return .success }

This pull request updates all statements on this branch.
 Hello Cnoon, How it's going?

Thank you for your replay, but what is the purpose of the comma instead of where? 
 `where` in those cases is deprecated now.
 Thanks for all fellows..
 https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md
  With the coming release of Xcode 8/iOS 10/Swift 3 a lot of developers will probably move to the new Swift syntax when updating their apps, but this will most likely also include apps that still require iOS 8 compatibility. By making the Swift 3 branch iOS9+-only this will make it not easy for developers to switch over, especially since Apple is using a very aggressive iOS release cycle:

iOS 8: Sep 17, 2014
iOS 9: Sep 16, 2015
iOS 10: Sep 2016(?)

Is there a big reason to drop iOS 8 support now? I understand the need to keep the code clean and up-to-date, but I don't think iOS 8 compatibility is something that will disappear overnight for most developers (I am aware that all iOS 8 devices can be updated to iOS 9, but that's not something everyone does).

It would be very nice to have at least an initial release using Swift 3 that's compatible with iOS 8 and then moving away from iOS 8 for next releases (or make the Swift 3 branch require iOS 8.4 if it's mostly related to bugs in 8.1 and 8.2).

FWIW: the current head in the swift3 branch still compiles for iOS 8.
 The same problem .
Anyone has the idea?
 Thanks for the explanation, I'm sure I'll find a suitable workaround (currently I'm fixed on the commit just before the version bump), my main concern was that the move to Swift 3 doesn't mandate moving to iOS9+, so it might be an issue for other developers as well.

Also, can you link to something that shows that Apple recommends supporting only the current and previous iOS version. I did a quick Google but came out empty (might be useful to help convince clients).

Hopefully this will all be a thing of the past soon(ish):

https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20160725/002520.html

> To make this more concrete, suppose an application is written to use Swift 4, but uses packages via SwiftPM that are written using Swift 3. A single compiler would build both the app and the packages ‚Äî thus ensuring that all the compiled sources are binary compatible. It would not be the case that a framework built with the Swift 3 compiler could be used by an app built using the Swift 4 compiler. That kind of library binary stability (ABI) will be a key goal of the Swift 4 release.
 The same recommendation was made by Woody Lidstone in [WWDC 2016 Session 213](https://developer.apple.com/wwdc16/213), "Improving Existing Apps with Modern Best Practices":

> What are some things that you can start doing to get ready for the fall?
> 
> First of all, if you were to support a deployment target of iOS 8 and 9, you would cover 95% of the devices.
> 
> So, there's really no need any more to have any of those deployment targets set to 7.
> 
> Let's get rid of that.
> 
> In fact, the general idea is that you take the current shipping version, so 9.3, and then set your deployment target to one version back, maybe 8.4.
> 
> But don't go to 8.3 or 8.2 anymore because then you and your customers don't benefit from the improvements that we've implemented under the hood in that 8.4 release.
> 
> **When we come out with iOS X in the fall for the public, set your deployment target to 9.3.**

Also note that iOS 9 adoption was [at 86% on 18 July 2016](https://developer.apple.com/support/app-store/) (not > 90% per mixpanel).
 Adding my voice to this discussion, I'd like to say that I strongly disagree with the decision to no longer support iOS 8.  In particular, you state:

```
When app developers are ready to embrace Swift 3, we feel that the majority of apps will be leaving behind support for iOS 8 deployment targets 
```

With iOS 9 support at 86% as @jamesk-au states, why would you assume major developers would be willing to make the switch so early. Dropping support for 14% of a large userbase is likely to have a huge impact on revenues.  I understand what you're saying about supporting two versions at a time, but iOS 10 isn't even out yet until later this fall. It seems reasonable to maintain iOS 8 support for a few months at minimum.
 OK cool, I thought iOS 10 was coming out in October. Thanks for that update.

I have one question: For Alamofire 3.x with Swift 2.3, if I'm on Cocoapods, will this play nicely with my other pods (and my main project) that do use Swift 3? If so, I can't find any good documentation on whether I need to do anything explicit in my Podfile to support different versions of Swift for my different Pods.  I currently have this at the end of my Podfile (as suggested [here](https://stackoverflow.com/questions/38446097/xcode-8-beta-3-use-legacy-swift-issue)) to avoid having to do `Xcode > Edit > Convert > To Current Swift Syntax...` every time I run `pod install`:

``` ruby
post_install do |installer|
    installer.pods_project.targets.each do |target|
        target.build_configurations.each do |config|
            config.build_settings['SWIFT_VERSION'] = '3.0'
        end
    end
end
```

I'm assuming this will need to change in some way to support some Swift 3 pods and other Swift 2.3 pods. Any guide or reference you can point us to @jshier @cnoon ? Thanks in advance.
 Just in case anyone is interested, I have forked and created a brach that adds back `iOS 8` support. I had to remove support to `URLSessionStream*` for that tho.

https://github.com/Homely/Alamofire/tree/ios8
 @jshier I don't have any plans to actively maintain that fork. I created it to postpone the need to drop support to iOS 8 on the app I'm working at the moment, although I'll be doing that in the near future.

I shared it here so other devs can use it as well, without having to do the same work I had already done.

I think I'll update the README file on that branch to make it clear.
 @cnoon Why can't we prefix the classes / methods using iOS9+ API with #available() check?

I believe https://github.com/Homely/Alamofire/commit/a0608c2db96c7d98d066f8fd72c5f19b89339fc2

only the streaming classes are affected? or Do we depend on iOS9+ API for basic functionality?
  Hello,

I am trying to automate my build setup with JENKINS.
At the end of script build failed with error:

The following build commands failed:
    CodeSign /Users/Shared/Jenkins/Home/jobs/********/workspace/build/Alamofire.framework

Could you please help!!
  When I try to make POST request to my server, my server actually receives GET. For more info, see my [question](http://stackoverflow.com/questions/38507997/swift-alamofire-post-request-becomes-get) on StackVerflow
 I had the same issue and adding a "/" on the url was not working for me.
But, changing the url from "http://" to "https://" made it work. (The server is making a redirection from http to https)
  Hi , I am using Alamofire to download a image from a remote location. I am using this code to download image

`Alamofire.request(.GET, urlString).response() {
            (_, _, data, _) in
            self.currentImage = UIImage(data: data! )
            self.carouselView.image = self.currentImage
        }
`

But the completion block is never called. 
  How can I implement this method from python with Alamofire response: [http://docs.python-requests.org/en/master/user/quickstart/#redirection-and-history](url)

In python it look's like:  `r1.history[0].headers`  - headers of first request in redirects stack
  In Upload.swift in the swift3 branch you're check for OSXApplicationExtension to use the qosDefault property.  That needs to check for OSX instead.
  I used .responseJSON 

```
        ApiManagement.manager.request(router.getHashCourse).responseJSON {
            response in
            debugPrint(response)
        }
```

but it return:
FAILURE: Error Domain=NSCocoaErrorDomain Code=3840 "Unable to convert data to string around character 8342." UserInfo={NSDebugDescription=Unable to convert data to string around character 8342.}

But when i use .responseString then I convert the responseString to JSON, it success.

```
        ApiManagement.manager.request(router.getHashCourse).responseString { response in
            if let data = response.result.value?.dataUsingEncoding(NSUTF8StringEncoding) {
                do {
                    let json = try NSJSONSerialization.JSONObjectWithData(data, options: .AllowFragments) as? [String:AnyObject]
                    print(json)
                } catch {
                    print(error)
                }
            }
        }
```

Anyone can help me to use .responseJSON, thank so much
 Thank for your response üëç 

But i wonder can we have a function to set the Encoding of the data ? :D 
 Maybe i know the issue :D 

My JSON response a string that contains Unicode Character: "\u0110\u0103ng k√≠ th√†nh c√¥ng vui l√≤ng v√†o mail \u0111\u1ec3 x√°c nh\u1eadn."  so that it can't be decoded 

So can you help me with this :( Thank so much
 Oh, sorry, I know. My server uses charset=ISO-8859-1 :(( 
  I need to do my unit tests make sure that we have set the correct ParameterEncoding, but when I try:

<img width="897" alt="screen shot 2016-07-20 at 14 41 51" src="https://cloud.githubusercontent.com/assets/5968478/16996560/3972d9c0-4e88-11e6-82cc-bbdff6b65e46.png">

How can I do it?
 @jshier 
It isn't not working!!!
<img width="1134" alt="screen shot 2016-07-24 at 05 50 04" src="https://cloud.githubusercontent.com/assets/5968478/17082855/9847cfdc-5162-11e6-817e-5ab3a4ebdf87.png">
 Thanks, I did exactly that: 

``` swift
//
//  ParameterEncoding.swift
//  iShopSDK
//
//  Created by Rafael Ferreira on 7/24/16.
//  Copyright ¬© 2016 Swift Yah. All rights reserved.
//

import Alamofire

/// An way to compare two instances of `ParameterEncoding`.
extension ParameterEncoding: Equatable { }

/// Compares two instances of `ParameterEncoding`.
/// Already, it cannot compare two instances of `ParameterEncoding.Custom`.
///
/// - Parameters:
///     - lhs: The first `ParameterEncoding` instance.
///     - rhs: The `ParameterEncoding` parameter that it will be comparable to `lhs`.
///
/// - Returns: True when both instances are completely equal, otherwise false.
public func == (lhs: ParameterEncoding, rhs: ParameterEncoding) -> Bool {
    switch (lhs, rhs) {
    case (.JSON, .JSON):
        return true

    case (.URL, .URL):
        return true

    case (.URLEncodedInURL, .URLEncodedInURL):
        return true

    case (.PropertyList(let lFmt, let lWOpt), .PropertyList(let rFmt, let rWOpt)) where (lFmt == rFmt && lWOpt == rWOpt):
        return true

    default:
        return false
    }
}
```
 @jshier man how can I compare ParameterEncoding objects, once now they are structs?
 good idea @jshier implement equatable is a very good solution, but just a cast solve my problem, thanks...
  it shows this code leaks : `let JSON = try NSJSONSerialization.JSONObjectWithData(validData, options: options)`
the method is     ```
public static func JSONResponseSerializer(
        options options: NSJSONReadingOptions = .AllowFragments)
        -> ResponseSerializer<AnyObject, NSError>
    {
        return ResponseSerializer { _, _, data, error in
            guard error == nil else { return .Failure(error!) }

```
        guard let validData = data where validData.length > 0 else {
            let failureReason = "JSON could not be serialized. Input data was nil or zero length."
            let error = Error.errorWithCode(.JSONSerializationFailed, failureReason: failureReason)
            return .Failure(error)
        }

        do {
            let JSON = try NSJSONSerialization.JSONObjectWithData(validData, options: options)
            return .Success(JSON)
        } catch {
            return .Failure(error as NSError)
        }
    }
}
```

```
```
 @cnoon  
Just the example project. 

![image](https://cloud.githubusercontent.com/assets/6587734/17389407/9294c612-5a36-11e6-8107-caa1494f9ed9.png)

Yes, there are leaks occured on sending network requests.

BTW, when running objective-c sample project of AFNetworking, no leaks at all.
But I've tried to use AFNetworking in my swift project through bridging header, leaks on every network request.

Through searching I found this blog:
http://footle.org/2015/10/10/fixing-a-swift-memory-leak/
  I'm doing a simple download via Alamofire's .request method, which automatically passes along the Accept-Encoding of gzip.  If I run curl against that same website with and without the encoding  header I get back content lengths of 9037 and 108303.  

When the .progress method is called it's just spitting out the 108303 value instead of the 9037.   The download should just be 9037, even though the uncompressed total is 108,303.  
  In callback closures like the following:

``` Swift
self.manager.request(.GET, url, parameters: parameters, encoding: .URLEncodedInURL)
            .response { request, response, data, error in

        }
```

Alamofire does not use parameter names for the parameters of the closure. Xcode offers a very good autocompletion if those are specified and they don't have to be typed each type the method is called.
I propose adding those names and would like to help adding them if you are ok with the change, maybe you have some good reasons to not add them. Would love to discuss about it!
 @cnoon awesome, thanks for the update!
  If the json string has the make-table signal, the json can't be change to data. It's the service problem, but sometimes it is Inevitable in some APPs, just like the book-reader or writer APP.
How about add a function to ignore the make-table signal?
 For example, a json like this 
{
    "cid": "109", 
    "intro": "a intro.
  and so on.",
}
It is not a valid json, between "a intro." and "and so on." has a tabs. I hope to add a function to ignore tabs ,So this is what I mean.
  <img width="1440" alt="screen shot 2016-07-19 at 11 08 50" src="https://cloud.githubusercontent.com/assets/1780156/16936422/78718db6-4da1-11e6-9695-73689eaa9087.png">
  [VeeWee's blog post](http://veewee.github.io/blog/authenticating-with-x509-client-certificates/) shows what I'm trying to do. 

Basically OAuth is a PITA to setup and this seems much easier and more secure.  I can just generate a certificate on the server that lasts for 20 years, create a client one that lasts just as long, and then bundle that client one inside my application.  Now I know that even if somebody figures out a person's user/pwd they still can't connect to the web API because they're not providing the properly signed certificate.
 Any thoughts on when this might be able to happen?  I've been trying to make it work myself but I'm pretty clueless as to what I'm doing here. 
 I ended up getting this working with the following code.  Not sure if it's _right_ or not, but it seems to work, and hopefully saves you some time on implementation.  See specifically the note on passing nil for the certificates.  

``` Swift
        manager.delegate.sessionDidReceiveChallenge = {
            session, challenge in

            guard challenge.previousFailureCount == 0 else {
                challenge.sender?.cancelAuthenticationChallenge(challenge)
                return (.CancelAuthenticationChallenge, nil)
            }

            let url = NSBundle.mainBundle().URLForResource("Certificates", withExtension: "p12")!
            let data = NSData(contentsOfURL: url)!

            var importResult: CFArray? = nil
            SecPKCS12Import(data, [kSecImportExportPassphrase as String : "qwer1234ASDF"], &importResult)

            let result = (importResult! as NSArray as! [[String : AnyObject]]).first!

            let identity = result[kSecImportItemIdentity as String] as! SecIdentity

            // See oso.com.pl/?p=207&lang=en for why certificates is nil
            let credential = NSURLCredential(identity: identity, certificates: nil, persistence: .ForSession)

            return (.UseCredential, credential)
        }
```
 Hi, @jshier.  I'm sure you guys are swamped with the new GM release, but was just wondering if there was any progress on this one?
  We creating vpn app. If I send request immediately after vpn state was connected, request will be send with old ip address. I think this happened because request has been sent in old alive connection (connection pool). 

How can I clear connection pool?

Or something else?

I use 

``` Swift
NSNotificationCenter.defaultCenter().addObserver(
            self,
            selector: #selector(ConnectionManager.VPNStatusDidChange(_:)),
            name: NEVPNStatusDidChangeNotification,
            object: nil)
```

to to determine VPN status
 Then vpn status changed to CONNECTED, I create new AlamofireManager. And seems like this is working.

@cnoon, thank you!
  Undefined symbols for architecture arm64:
  "Alamofire.Request.(responseJSON (options : __C.NSJSONReadingOptions, completionHandler : (Alamofire.Response<Swift.AnyObject, __ObjC.NSError>) -> ()) -> Self).(default argument 0)", referenced from:

...

ld: symbol(s) not found for architecture arm64
clang: error: linker command failed with exit code 1 (use -v to see invocation)

still can be compiled and loaded if app is sent via crashlytics
  ![image](https://cloud.githubusercontent.com/assets/16380379/16864458/635cf7c2-4a8f-11e6-95a2-97a0c0d704b1.png)
 Same issue is recurring for me. 
I didnt get the solution to this anywhere else, that is why I have to open this issue once again.

Here is my pod details 

platform :ios, '10.0'

```
use_frameworks!
target 'PhotoTagger' do
    pod 'Alamofire'
end
```

Also the only thing being auto completed is `AlamofireVersionNumber` and i cannot access anything when I am trying to use the auto complete feature. Now if i write Alamofire by hand then I can access some methods, but then again something is going wrong and code is not compiling, which i think boils down to the issue that the class isnt being fetched by auto complete.

I have tried - 

In Project settings > Build settings
1. Always search user path To YES 
2. Header search path to only include "$(inherited)" as non-recursive


All other pods are working fine, except Alamofire.
Also after writing class name by hand or copy pasting, some of the methods that are being auto completed does not have the same signature of the actual method of the Alamofire class 

Please please please !! help me sort this out, so that someone out there when facing this can help themselves too. There isnt any solution to this as of now.
  Hi,
I am unable to install Alamofire 3.4 via CocoaPods. I am getting an error as below,

```
Analyzing dependencies
[!] Unable to satisfy the following requirements:

- `Alamofire (~> 3.4)` required by `Podfile`

None of your spec sources contain a spec satisfying the dependency: `Alamofire (~> 3.4)`.

You have either:
 * out-of-date source repos which you can update with `pod repo update`.
 * mistyped the name or version.
 * not added the source repo that hosts the Podspec to your Podfile.

Note: as of CocoaPods 1.0, `pod repo update` does not happen on `pod install` by default.
```

and my Podfile is as below,

```
source 'https://github.com/CocoaPods/Specs.git'
platform :ios, '9.0'
use_frameworks!

target '<My Target>' do
    pod 'Alamofire', '~> 3.4'
end 
```

Please help me resolving the issue. thanks for all the help
 Thanks for the help. Much appreciated.
  Hello!
I just have a quick question about `response.result.value`. I see that it is defined as optional. I was wondering if I can safely guarantee(assuming I give a valid API endpoint and parameters) that this value is always not nil, or should I handle the case where it is nil. In the latter case, What exactly could have happened for it to be set to nil, so that I know what errors to handle/report. 

Thank you!
Ryan.
 Thank you for your expedient reply! Yay!

On Wed, Jul 13, 2016 at 8:10 PM, Christian Noon notifications@github.com
wrote:

> Hi @ebbnormal https://github.com/ebbnormal,
> 
> It was definitely intentional to have result.value be optional. The value
> exists in a .Success case and not in a .Failure case. The property is
> merely for convenience. You certainly need to handle it being optional.
> 
> Cheers. üçª
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> https://github.com/Alamofire/Alamofire/issues/1346#issuecomment-232545573,
> or mute the thread
> https://github.com/notifications/unsubscribe/AEE8ibkv4q8yO2VuYvcjUXGnDKIUz7PIks5qVaiYgaJpZM4JLFPX
> .

## 

‡•ê ‡§®‡§Æ‡§É ‡§∂‡§ø‡§µ‡§æ‡§Ø
  I am trying to send POST request to server using the below code 
 `Alamofire.request(.POST,requestString, parameters:["existDeviceId":GlobalVariable.roomNumber,"newDeviceId":roomNumber, "key" : GlobalVariable.uniqueKey])
            .responseJSON {response in
                     print(response)
         }`

When i try to print the response , the block is never getting called. This happens for some requests but some requests are getting response. When i try to access the request that did not receive response in browser , i get response in browser. 
  download.response { request, response, data, error in }

after download response data always return nil

actually i want to get download data & append in existing file & save

Thank you.
 hi @cnoon 
so how to access downloaded data ?
i want daownload data bcz i download large file in chunk manner i request server to give me 1 mb byte & i append las saved file .

Thank you
 Thank you @cnoon 
  Hi , 

After my App is updated all  error , data & response becoming nil. 
   let manager = Manager.sharedInstance

```
    // Specifying the Headers we need
    manager.session.configuration.HTTPAdditionalHeaders = [
        "Content-Type": "application/x-www-form-urlencoded",
        "Accept": "application/vnd.lichess.v1+json",
        "User-Agent": "CustomAgent"
    ]
    manager.request(.GET, "https://api.lolsummoners.headlezz.net/v2/summoner/eune/52096153")
        .response { request, response, data, error in
            print(request)
            print(response)
            print(error)
    }
```

but it didn't work :(
  Did resolve swift 3 errors
 The project builds using Xcode 8 Beta, all tests pass. But Travis doesn't like it because he is using Xcode 7.3
 I know that there is a branch for swift3, but it doesn't compile with Xcode 8 beta and I needed to fix that for my project anyway. That was the first time I tried to contribute to a project. Maybe forking was the right choice?
 Indeed I missed the update, thank you!
    If you use some characters with basic authentication.
the header is not filled in.

```
    let cred = NSURLCredential(user: "AnthonyTest1", password: "‚Ç¨‚Ç¨‚Ç¨", persistence: .None)
    print(cred.password)

    var request = Alamofire.request(.GET, "http://httpbin.org/basic-auth/user/passwd")
        .authenticate(usingCredential: cred)
        .response { (request, response, data, error) in

    }
```

for instance if you use the `‚Ç¨` sign.
the request is performed but without a basic authentication header.
I'm not sure if this is a bug in `NSURLSession` or in `Alamofire`
 it's not a bug with `httpbin.org` (in fact it is just a test service, I have the same issue with my production server)

If is use password `test123`, I get the following headers:

```
GET /basic-auth/user/passwd HTTP/1.1
Host: httpbin.org
Connection: keep-alive
Accept: */*
User-Agent: app/com.test.app (22; OS Versie 9.3 (build 13E230))
Accept-Language: nl;q=1.0
Authorization: Basic eDp0ZXN0MTIz
Accept-Encoding: gzip;q=1.0, compress;q=0.5
```

when using the `‚Ç¨` character inside the password field, I get the following:

```
GET /basic-auth/user/passwd HTTP/1.1
Host: httpbin.org
Accept: */*
User-Agent: app/com.test.app (22; OS Versie 9.3 (build 13E230))
Accept-Language: nl;q=1.0
Accept-Encoding: gzip;q=1.0, compress;q=0.5
Connection: keep-alive
```
  Hi Team,

I am trying to make network call when my app is background. So I am using background manager configuration API in the iOS Sample App.

But I get the following error. I am wondering how to proceed.
Any help is appreciated.

FAILURE: Error Domain=NSURLErrorDomain Code=-999 "cancelled" UserInfo={NSErrorFailingURLStringKey=https://httpbin.org/post, NSLocalizedDescription=cancelled, NSErrorFailingURLKey=https://httpbin.org/post}
  For example, all *.apple.com should use a same serverTrustPolicy.   

``` Swift
    let certificates = ServerTrustPolicy.certificatesInBundle(NSBundle.mainBundle())
    let serverTrustPolicy = ServerTrustPolicy.PinCertificates(
        certificates: certificates,
        validateCertificateChain: true,
        validateHost: true
    )

    let manager = Manager(
        configuration: NSURLSessionConfiguration.defaultSessionConfiguration(),
        serverTrustPolicyManager: ServerTrustPolicyManager(policies: [
            "apple.com": serverTrustPolicy,
            "*.apple.com": serverTrustPolicy
        ])
    )
```
 OK. I'm now checking the document in the source file.

```
Subclasses could override
        this method and implement more complex mapping implementations such as wildcards.
```
  Hi,
If Alamofire is compatible with [SwiftPM](https://swift.org/package-manager/) you can add [![SwiftPM Compatible](https://img.shields.io/badge/SwiftPM-Compatible-brightgreen.svg)](https://swift.org/package-manager/)  on top of your `README.md` and add section for the installation with SwiftPM
 According to [the documentation](https://github.com/apple/swift-package-manager/blob/master/Documentation/Reference.md):

> At this time there is no explicit support for depending on Foundation, AppKit, etc, though importing these modules should work if they are present in the proper system location. We will add explicit support for system dependencies in the future. Note that at this time the Package Manager has no support for iOS, watchOS, or tvOS platforms.

But I'm willing to help after they support all Apple platforms.
  This problem occurs if it's the first time you kick off an upload with multipart form data, and you kick off multiple uploads at the same time. The directory creation is done in a background thread and with some possibility, multiple uploads will try to create the directory at the same time, which causes a cocoa error 516. The createDirectoryAtURL:withIntermediateDirectories:attributes: method is not supposed to fail if the directory already exists with the parameters AlamoFire passes, but it seems it does throw an exception if 2 threads attempt to create it at the same time. The result is that a few of the uploads you launched will completely fail. Beware this is not easy to reproduce.

An easy fix would be to create the directory preemptively before any upload can reach this point. 
  I am currently trying to decrease the default values for `timeoutIntervalForRequest` and `timeoutIntervalForResource` of `NSURLSessionConfiguration` for every Alamofire remote calls in my iOS app since I don't want it to wait 60 seconds and 7 days respectively.

This is my code:

```
Alamofire.Manager.sharedInstance.session.configuration.timeoutIntervalForRequest = 30
Alamofire.Manager.sharedInstance.session.configuration.timeoutIntervalForResource = 30

let parameters = [
    "foo": [1,2,3],
    "bar": [
        "baz": "qui"
    ]
]

Alamofire.Manager.sharedInstance.request(.POST, "someURL", parameters: parameters, encoding: .JSON) {
    (response) in

    print(response.timeline)
}
```

This is my log:

`Timeline: { "Latency": 60.977 secs, "Request Duration": 60.977 secs, "Serialization Duration": 0.000 secs, "Total Duration": 60.977 secs }`

As you can see the `Request Duration` value is over 30 seconds.

Does this depends on the fact that I use `Alamofire.Manager.sharedInstance.request` instead of `Alamofire.request`?
 Hello @jshier, first of all thank you for your reply. I am sorry but I don't agree with that, because I have place the following code

`Alamofire.Manager.sharedInstance.session.configuration.timeoutIntervalForRequest = 30
Alamofire.Manager.sharedInstance.session.configuration.timeoutIntervalForResource = 30`

before performing a request, as you can see from my question aswell. Maybe I made the mistake not to explain it any further in the question post but I can confirm you 100% I did not had any other Alamofire request opened and that was also the first performed in the app. So: what session could be active in this situation?.

I have also tried to place the configuration code in the `didFinishLaunchingWithOptions` func but it didn't work.
  Hey
Many http framwork, like okhttp have support for [interceptors](https://github.com/square/okhttp/wiki/Interceptors) that allow you to modify the request receive the response. This can be pretty useful for many features like oauth2, content md5 and so on. Is there a way to achieve something similar with alamofire? 
Thanks,
Omer
 I want to achieve the following: Writing an interceptor that add authorization header (I've already saw multiple approach to achieve this with alamofire) and invalidate the token if the request failed with 401. But, I also want that other developers in our company could easily use this and have the full alamofire api (for example, choosing serializer, custom validation etc). With interceptors, they can simply add this to their request...
 Yes, but this is a bit cumbersome, I was looking for something that is easier to use. Such an approach also is a bit error prone - more things to remember, meaning probably someone will forget to add them someday... 
 I second this request. I am trying to write tests that ensure my outgoing requests contain the right body and the right headers. With AFNetworking, I had a simple RequestSerializer in my unit tests that stored the request body on the request object before it was wiped by the framework. Now, that no longer seems possible.
 You might be able to solve this with custom encoding, but it will not be pretty...
 This request might be solved with the `RequestAdapter`. 
  I think the original NSMutableURLRequest's property should hold, not create just from request URL!
  The google api still uses the old fashioned 
forward slash url omitting the scheme in the url, like so:
`//lh6.googleusercontent.com/-y7auqvtnhCg/AAAAAAAAAAI/AAAAAAAAN70/MXzXyHW0lQw/photo.jpg`

This causes Alamofire network requests to retrieve that image to fail, and print an error message that reads the url being invalid, despite it being correct. 
Please read this article by Paul Irish:
http://www.paulirish.com/2010/the-protocol-relative-url/

Companies use this url when an asset is available in both the HTTPS and HTTP domains, so throwing in `HTTPS:` before urls that have a prefix of two forward slashes will always work.

`self.fullUrl = urll.hasPrefix("//") ? "https:\(url)": relativeUrl`

Can I add this fix as a pull request, what are your thoughts on this? 
  Hi, i need send array like this in multipartFormData

my array: 

["t": "aa", 
 "t2": 0, 
 "t3": {
  "t3_2" = EHU123;
}]

t3 array in array how send this with multipartFormData?
 Possible duplicate of #1309 .

Tag: Help wanted.
 As far implementation are you thinking about how Ruby on Rails implements building forms for sending hierarchical data? http://guides.rubyonrails.org/form_helpers.html
  We're using Jenkins server to build/release our app, this is our build command:

```
xcodebuild clean archive -workspace XXXX.xcworkspace -scheme XXXX -configuration Release -archivePath /tmp/XXXX.xcarchive -destination generic/platform=iOS -derivedDataPath build PROVISIONING_PROFILE=xxxxxx PRODUCT_BUNDLE_IDENTIFIER=xxxxxx
```

But after integrate Alamofire, the archive still succeed but the install will fail, and the log says: `the parent bundle has the same identifier as sub-bundle`. I tried both to use CocoaPods and manually integrate Alamofire, and the error is same.

I'm not sure but it seems due to the `PRODUCT_BUNDLE_IDENTIFIER=xxxxxx` in our build command, so I tried to remove this line, and the archive will fail due to the code sign error `No matching provisioning profile found`

I'm also very confused if this problem is from Apple's xcodebuild command, I thought it's not good enough support to Swift written frameworks, I mean the dynamic frameworks (it works well on Objective-C static library)
    Is there a way to create an hmac sh1 signature to add to a get request url header in Alamofire?
Thanks
  I am trying to upgrade a tvOS project to XCode 8 and Swift 3 to start integrating the latest APIs. My project depends on Alamofire and AlamofireImage. I switched to the swift3 branch on both those dependencies. Then I ran pod install and I opened my workspace in XCode, and I ignored the conversion wizard since my own code has already been migrated to Swift 3. Now when I try to build my project, I'm getting the following compiler error on the 'import Alamofire' statement:

/Users/sarbogast/dev/tvoxx-ios/TVoxx/SpeakerCollectionViewCell.swift:10:8: Module file was created by an older version of the compiler; rebuild 'AlamofireImage' and try again: /Users/sarbogast/Library/Developer/Xcode/DerivedData/Build/Products/Debug-appletvsimulator/AlamofireImage.framework/Modules/AlamofireImage.swiftmodule/x86_64.swiftmodule

Any idea how to fix this?
 Wow, @jshier Thank You!!! I've been screwing around with stuff in a massive project for 2 hours and deleting the derived data finally fixed everything!!!
 Also if you use Cocoa Pods you have to do a **pod deintegrate** and **pod update** to reinstall the frameworks.  Hi, I am doing an app which has numerous APIs, each API's response has to be imported into the core data. I am aware **Alamofire** completion handler will be in main thread by default. I would like to change this into background thread as i would do core data import operation in the request completion. Can you please guide me how can I set my background thread as default thread in the request completion?

I hate to set this in each API request, Instead i would like to set this in single place as I always do in AFNetworking which had property called **completionQueue** in the **AFHTTPSessionManager**  so I created subclass for AFHTTPSessionManager then I easily changed the default thread. I don't find similar thing in **Alamofire**. Please guide me with better solution

http://stackoverflow.com/questions/37938280/how-to-change-default-request-completion-queue
  This fixes the unit [test failure](https://travis-ci.org/Alamofire/Alamofire/jobs/137143030) on iOS 8.1 and 8.2 simulator.

The cause of the issue was that the order of items in a dictionary is different between iOS 8 and iOS 9.
  install compatibility with cocoapods? @kcharwood 

EDIT: use

```
  pod 'Alamofire',
  :git => 'https://github.com/Alamofire/Alamofire.git',
  :branch => 'swift3'
```
 Using the provided code on the Alamofire page, when creating a generic ResponseObjectSerializable, I get the following error: `Member 'failure' in 'Result<T, NSError>' produces result of type 'Result<Value, Error>', but context expects 'Result<T, NSError>'`.  This occurs on the following line: `return .failure(.ObjectSerialization(reason: "JSON could not be serialized into response object"))`. I am using the swift 3.0 branch.
 Could it be installed via carthage? As I'm getting compile errors
 I am able to install using carthage, have you set the correct version of XCode in Terminal?

`sudo xcode-select -s /Applications/Xcode-beta.app/Contents/Developer/`
 Indeed. Forgot to switch XCode version. All works fine.
Cartfile:
`github "Alamofire/Alamofire" "swift3"`
 I am stuck with "error: Found an unexpected Mach-O header code: 0x72613c21" because of the pod, ideas will be highly appreciated.
 @fancytapsio That is a CocoaPods issue, try [https://github.com/CocoaPods/CocoaPods/issues/5598#issuecomment-230662508](url)
 @ronaldmannak Thank you, I needed that, it finally worked!
 I have installed Cocoa pods in xcode 8.1. I add like this:
pod 'Alamofire',
  :git => 'https://github.com/Alamofire/Alamofire.git',
  :branch => 'swift3'
when I complie my app, Its getting so many error. 
 Xcode Beta3, using pod and getting ...
‚ÄúUse Legacy Swift Language Version‚Äù (SWIFT_VERSION) is required to be configured correctly for targets which use Swift. Use the [Edit > Convert > To Current Swift Syntax‚Ä¶] menu to choose a Swift version or use the Build Settings editor to configure the build setting directly.
 Can you explain how to use this please?  I created a brand new project and used the Pod configuration that @dipang90 showed.   When Xcode starts it immediately wants to do a conversion to Swift 3, and I get 346 issues in Alamofire framework.  

I'm using Xcode 8 Beta 3
 @jshier pod --version says 1.0.0.  I did the pod install followed by a pod update, then opened my project.  I clicked 'Later' to the conversion and when I build I get the error that @vladgon shows. Then I went ahead and ran the 'convert' and get the 348 errors in the Alamofire library.
 It seems to compile after running 

```
sudo gem install cocoapods --pre
pod update
```
 Thanks, @jshier and @vladgon.  I did the gem install to get the BETA version and now it's working properly.
 Though I will point out, if you still go ahead and do a convert it'll then start failing again, so just make sure you never convert the alamofire pod :)
 Worked for me after installing the `--pre` version of cocoapods.
 Ouch, Xcode 8 beta4 is out and breaks the `swift3` branch :/
 @Grmiade yes, I was trying today to update and after losing some hours I decided to keep with Swift 2.2 and xc 7.3 until everything is ok.. =/
 It seems like the current version is based on Beta 4. When I compile today, there are a fews errors.(such as..  NSError is migrating to Error.)  
 Hi @vladgon 
I installed the --pre version, but it didn't work.
Can you tell me which is the right order?
My order: pod init -> modify the podfile -> pod install -> pod update ?
I use Xcode beta 3, cocoapods-1.1.0.beta.1.
 @KhoaVanNguyen You need to say something more than "It didn't work".  What, exactly, is happening for you?  Using the same steps as you I was able to use this version successfully.  However, note my statement from above that you can NOT run the converter on the Alamofire framework or it will then indeed break things.
 @grosch
I‚Äôm sorry. I just think I get stuck on that step, so I didn‚Äôt write the details.
Here what I did, can you figure out what I did wrong?
I install cocoapods. Then install ‚Äîpre version by:
`sudo gem install cocoapods --pre`
then
I create a xcode project without a Git repo. I modify the Podfile
Here are my Podfile

```
# Uncomment this line to define a global platform for your project
source 'https://github.com/CocoaPods/Specs.git'
platform :ios, '9.0'
use_frameworks!
target 'Test' do
pod 'Alamofire', 
  :git => 'https://github.com/Alamofire/Alamofire.git', 
  :branch => 'swift3' 
end‚Äô

```

I install by: 
`pod install`
Then update by:
`pod update`
I also try:

> pod init -> modify the podfile -> sudo gem install cocoapods --pre -> pod install -> pod update

Then I open .xcworkspace and get this error:
![my error](https://cloud.githubusercontent.com/assets/13306003/17454975/e5f21b4a-5bd3-11e6-8f83-e1b814556432.png)
Of course, I try many scenarios like uninstall cocoapods and repeat the process. Sometimes, Xcode appears a pop-up to request converting to Swift 3 but I cancel it.
 Are you sure you're running the beta 4 version of Xcode?  When you go to Xcode -> About does it say Version 8.0 beta 4?
 No, I run beta 3
 Well there you go :)  Alamofire has been updated for Beta 4 already.  If you're using the Beta Xcode versions, you pretty much have to upgrade every other Monday when they release a new version.
 Thank you. I don't know about this. It means there will be a Xcode beta 5 next Monday. And I have to update to latest version of Xcode beta to install Alamofire with Swift 3, right?
 Well, "maybe".  I think Apple has been releasing a new Xcode beta every other Monday.  The Alamofire guys have been keeping up with the upgrades.  So yes you should always upgrade to the new Beta when they come out for your NON-PRODUCTION work, but that doesn't mean that the Alamofire developers are going to immediately upgrade this branch to work with it.
  create swift4.0 branch in pod file? In using Xcode 10 beta 4
 Swift 3 isn't even done and you want them to start a Swift 4?  Wow 
 I mean when Xcode update with beta version then swift 3.0 is ok or we have create new branch 4.0 ?
 You should only be using this specific branch of Alamofire for your testing with the BETA version of Xcode.  When Xcode 8 goes production, then they'll migrate this branch into the master branch of Alamofire.  Once the Swift team starts doing things with Swift 4, the Alamofire people will eventually create a branch for that, I'm sure.  But that's a long time away I would think.  
 I've noticed that when using the swift3 branch with Carthage I cannot use target 8.4 anymore. I must select deployment target 9.0+. Is that a bug/am I doing anything wrong? As far as I know, Alamofire was iOS 8+ compatible...
 I've noticed that Apple just released Xcode beta5. 
 Hi, thanks for your job. There is a problem of compatibility with iOS 8 and the used of `URLSessionStreamTask` (iOS 9.0+) in `SessionManager` and `SessionDelegate`.

![screen shot 2016-08-11 at 08 44 44](https://cloud.githubusercontent.com/assets/4869580/17580583/f8bb47d6-5f9f-11e6-8142-c1e669868bb4.png)

Thanks
 @kapellanos @cnoon I'm getting similar errors, even though my app is iOS 9-only. I think this is because the Podfile still indicates iOS 8 support, which means CocoaPods sets the deployment version to 8.0. It looks like #1401 should fix it, though that has a couple other changes as well.
 I'm getting errors now about requiring a higher deployment target.  I'm targeting iOS 9 and OS X 10.10 in my Podfile.  Are you removing support for those?  That's going to hurt :(
 @jshier Was afraid you'd say that.  I have a client who is stuck on 10.10 for at least another year as the primary 3rd party software they use from a major vendor isn't upgrading, and they aren't big enough to force the issue.  Suggestions on how I handle something like that?  I have to keep his project at 10.10, and I depend on Alamofire, but I also need to upgrade to Xcode 8 when it releases for everyone else.
 Branch has been updated for beta 6?
 @jshier Any updates regarding beta 6? Let me know if you need any help.
 I stuck with beta 6 

I did all

in my main directory 
`sudo gem install cocoapods --pre`
than move to my project directory 
`pod init`
edit my podfile

`# Uncomment this line to define a global platform for your project
source 'https://github.com/CocoaPods/Specs.git'
platform :ios, '9.0'
use_frameworks!
target 'MyAlamo' do
pod 'Alamofire',
  :git => 'https://github.com/Alamofire/Alamofire.git',
  :branch => 'swift3'
end`

than 

`pod install`

and after install i 
`pod update`

![snimek obrazovky 2016-08-16 v 12 09 04](https://cloud.githubusercontent.com/assets/15859450/17695730/45085ae4-63aa-11e6-8190-6108b5a2b7a1.png)

![snimek obrazovky 2016-08-16 v 12 05 02](https://cloud.githubusercontent.com/assets/15859450/17695633/c4f812ea-63a9-11e6-9f7e-746fa95dd681.png)
 @RobinKment : As was said two replies before yours, beta 6 introduced many changes for Swift 3 which affected Alamofire and therefore there's nothing wrong with your install or Podfile, you just have to wait until the swift3 branch is updated for these changes.
 @thebluepotato  yes i red that but i didn't know if to delete my post or not probably good was to delete it. Sorry
 @jshier Any updates on this?
 @danstepanov As you can see in the commits, the Swift 3 branch has been updated for beta 6. Happy testing!
 Using beta 6, I am having problems with cocoapods linking with AlamofireNetworkActivityIndicator. If I remove AlamofireNetworkActivityIndicator pod everything works.

This is the error:

```
- `Alamofire (from `https://github.com/Alamofire/Alamofire.git`, branch `swift3`)` required by `Podfile`
- `Alamofire (~> 3.3)` required by `AlamofireNetworkActivityIndicator (1.0.1)`
```
 I am receiving multiple compiler errors. I am using the swift 3 branch.
![screen shot 2016-08-18 at 11 11 01 pm](https://cloud.githubusercontent.com/assets/21002733/17797758/7e86cb7a-6599-11e6-905f-05e23dfd4114.png)
 I am unable to build a project using CocoaPods. I'm using Xcode 8 beta 6 and my Podfile has:
pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'swift3'

First there is a warning about required architectures 'i386 x86_64', so I set Build Active Architectures Only to "No".

Then there's a warning about Use Legacy Swift Language Version so I set that to "No".

I'm left with an error on import Alamofire in one of my Swift files that states "Module file was created by an older version of the compiler; rebuild 'Alamofire' and try again".

UPDATE:
I was not using CocoaPods beta. Thanks @jshier !
 Got so many errors while building : 
![screen](https://cloud.githubusercontent.com/assets/15719068/17856795/764880aa-687f-11e6-9d5d-c6165c5fca35.png)

This is my podfile : 

> platform :osx, "10.12"
> use_frameworks!
> 
> target 'MyApp' do
>     pod 'SwiftyJSON', :git => 'https://github.com/SwiftyJSON/SwiftyJSON.git', :branch => 'swift3'
>     pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'swift3'
> end

I am using Cocoapods beta and Xcode Version 8.0 beta (8S128d).
MacOS version : b√™ta 10.12 (16A294a)

Thanks
 @cnoon Excellent, it works now ! Thanks !
 Hey guys,
I am using latest pre release beta of CocoaPods, and Xcode Version 8.0 beta 6 (8S201h)

My pod file:

# Uncomment this line to define a global platform for your project

# platform :ios, '9.0'

target 'Sharqona Afif' do
  # Comment this line if you're not using Swift and don't want to use dynamic frameworks
  use_frameworks!
  pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'swift3'
end

![screen shot 2016-08-25 at 15 14 00](https://cloud.githubusercontent.com/assets/10615196/17970409/c452588a-6ad6-11e6-949a-3ba9ad3c9a25.png)

Still Xcode forces me to convert
Any Suggestions ? 
 @Turgunov try add code below to your Podfile, then `pod install`

```
post_install do |installer|
    installer.pods_project.targets.each do |target|
        target.build_configurations.each do |config|
            config.build_settings['SWIFT_VERSION'] = '3.0'
        end
    end
end
```
 So, I am able to build my project in Swift 3 Xcode beta 6 and sudo gem install cocoapods --pre, using this branch in my podfile.  

**pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'swift3'**

All good.

But I cannot use Alamofire as an object, for instance in Xcode. 

Alamofire.request(.GET, "https://httpbin.org/get") throws a Swift compiler error:

**Ambiguous reference to member 'request (_:withMethod:Parameters:encoding:headers:)'**
 @davidoliverdoswell If you look at the "ambiguous" member, or try to write `Alamofire.requ...` and look at Xcode's suggestions you'll see what's changed : the URL is now the first parameter and the method the second one. Therefore it's `Alamofire.request("https://httpbin.org/get", withMethod: .get)`.
 @thebluepotato that did it! Thanks!
 Hi guys, I'm getting these errors. How do i fix it?. I'm using Xcode beta 6.
<img width="575" alt="screen shot 2016-08-29 at 4 44 43 pm" src="https://cloud.githubusercontent.com/assets/12514532/18047605/f490e726-6e07-11e6-9f4a-4904ec03fa5e.png">
<img width="261" alt="screen shot 2016-08-29 at 4 44 00 pm" src="https://cloud.githubusercontent.com/assets/12514532/18047617/fc5c9946-6e07-11e6-9078-21635f8d7090.png">
 same like @chieudai14kytu

You need to remove Manager.swift file in source with pods i think.

When i open your projet, this file is not visible in projet, but in the finder, i can see it.
 @lowki93 It works now. Thank you.
 @chieudai14kytu your welcome ;)
 @lowki93 
have the same issue as @chieudai14kytu. After removing it into a trash get an error

`Command /Applications/Xcode-beta.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swiftc failed with exit code 1`
help please.
 don't remove in folder.

Clone the repo, move to branch swift3, and import .workspace in your project
 In swift3 branch now that Alamofire.Method has become an opaque pointer, can somebody tell me how to handle it in an URLRequestConvertible Router class?

<img width="760" alt="screen shot 2016-08-31 at 15 15 05" src="https://cloud.githubusercontent.com/assets/1210535/18130194/5551ccf6-6f8e-11e6-970d-e53ac8c383e5.png">

<img width="734" alt="screen shot 2016-08-31 at 15 18 26" src="https://cloud.githubusercontent.com/assets/1210535/18130188/4ad10e86-6f8e-11e6-9546-da5435021a82.png">
 In original post,  there is a checkbox for Documentation/README

Is it time to file a separate standalone issue for that? If there is not already someone working on updated README, etc., I think its own issue could be useful for tracking. 
 @fprosper If I'm not mistaken, the change isn't that Method is an OpaquePointer but that according to Swift 3.0 API guidelines, enum cases are to be written in lowerCamelCase (just like you did in your own enum I see).
Therefore the methods are `.get`, `.put`, `.post`, etc.
 @thebluepotato you are right!
 Thank you @thebluepotato, just noted, thanks!
 @thebluepotato but i get error : 

```
 Type 'Method' (aka 'OpaquePointer') has no member 'get'
```

any suggestion?
 @jshier oh thank you for mention it!
 How to call POST method with encoding as JSON, with some header and Passing some parameter 

![screen shot 2016-09-19 at 1 30 29 am](https://cloud.githubusercontent.com/assets/19710059/18618650/bcb9e274-7e08-11e6-9b97-f6dba23d5772.png)

How can I call this method with JSON response?

Thanks for any help in advance
 [!] /usr/bin/git clone https://github.com/Alamofire/Alamofire.git /var/folders/_2/cfgf2q2x7n7g3881kmbqvh4m0000gp/T/d20160919-5162-1u99gbn --template= --single-branch --depth 1 --branch swift3

Cloning into '/var/folders/_2/cfgf2q2x7n7g3881kmbqvh4m0000gp/T/d20160919-5162-1u99gbn'...
warning: Could not find remote branch swift3 to clone.
fatal: Remote branch swift3 not found in upstream origin
  Add the 'public' identifier to the 'BackendError' enum in the part about using Generics for Serialization. 

Reason:

The extension of Request throws an error ("Method cannot be declared public because its parameter uses an internal type") unless the enum is public.
  i fired a GET request to a URL, got a weird string result instead of JSON.
like this : 

"HTTP/1.1 1102 

Server: Apache-Coyote/1.1

Content-Type: application/json

Content-Length: 126

Date: Wed, 15 Jun 2016 08:40:17 GMT

{
  "httpStatusCode" : 1102,
  "message" : "foo-bar",
  "payload" : null
}"

any idea why this happened ? i tried to test the url using POSTMAN and it worked normally.
 hi @cnoon , thanks for replying.
yes, sorry, should be posted at stackoverflow.
turns out somehow iOS won't process weird status codes like 1102.

thanks!
  I would like to point out that I've got a Swift 3 compiling branch over [here.](https://github.com/avaidyam/Alamofire/tree/swift-3.0)
 I'm the coworker. Going to follow up in the labs. When appending a path component to a file reference URL (those look like `file://some-identifier-string`), it `stat`s the file to see if it exists, and if it doesn't, it returns nil. Apparently.
 > Explicitly unwrap SecPolicy creations. It appears that arrays with nil objects will not bridge to AnyObject's, that CFType expects to be an array.

How about instead of explicit unwrapping SecPolicy you try:

```
let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
SecTrustSetPolicies(serverTrust, [policy].flatMap { $0 })
```

Would that allow `trustIsValid(serverTrust)` to return expected results for policy unhappy path?
 Before this is merged can it use `#ifswift`? I would love to have my Swift 2.2 and Swift 2.3 code be the same code, so I can use Xcode 8 as my main driver and submit with Xcode 7.3.
 I was told in the labs that it's not really supported to target multiple versions of Xcode or the SDK :\
 @KingOfBrian Any updates to your PR as regards the failing tests?

From TravisCI, the unwrapping causes the error, in line _313_ of _Uploader.swift_

```
let directoryURL = tempDirectoryURL.URLByAppendingPathComponent("com.alamofire.manager/multipart.form.data")!
```
  What release of Alamofire supports Swift 2.3? Can I install it via CocoaPods? Thanks.
 yes.of course.according to government document,we can install it.
 try this:

`pod 'Alamofire', :git => 'git@github.com:Alamofire/Alamofire.git', :branch => 'swift2.3'`

and set this under the Alamofire build settings:

<img width="487" alt="screen shot 2016-06-28 at 2 39 15 pm" src="https://cloud.githubusercontent.com/assets/1724896/16428166/a3ef33d0-3d3e-11e6-8fad-a2fa2768d1ec.png">
 I tried this. I pulled in the 2.3 branch. Still have a ton of errors. 130+ to be exact.
 how can I use Xcode8 with swift 2.3?  
I tried this but many errors.....
 I solved the problems ,thanks for sharing!
 @Cj370118568 would be good to know how you resolved it
 @Cj370118568 how did you solve  the problem? Thanks.
 There have been no updates to the 2.3 branch in 15-16 days. If you have a solution @Cj370118568 please update the branch. Thanks.
 Thanks @jshier I'm assuming I need to drop in the files rather than pull as a cocoapod?
 Nobody's got a solution for this yet? :T
 The build failures with swift 2.3. :/
 @Lukaz32 I've had a ton of issues with this as well. I've managed to get the swift 2.3 branch to compile but only after about four or five attempts.
 I've tried a few more times and managed to solve the issues with Alamofire, but now I'm getting `Found an unexpected Mach-O header code: 0x72613c21` =/
 Thanks! I did install the beta version using `sudo gem install cocoapods --pre` however when I ask for the current version with `pod --version` it still gives me `1.0.0` . How do I set it to use the beta version?
 It seems like the 2.3 branch doesn't exist anymore Is that true?
 Thanks!

On 11 Sep 2016, 14:41 +0300, Christian Noon notifications@github.com, wrote:

> Yes, no more Swift 2.3 branch. The Alamofire 3.5.0 release supports Swift 2.3 and is what you should be using from now on @tal-sh (https://github.com/tal-sh).
> 
> Cheers. üçª
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub (https://github.com/Alamofire/Alamofire/issues/1312#issuecomment-246175938), or mute the thread (https://github.com/notifications/unsubscribe-auth/AALNMR2ji-_bMffq0fsvyZOPIYy9KCO4ks5qo-j8gaJpZM4I04mr).
 Make sure to set the "use legacy swift language version" flag to Yes as well
 [!] Unable to satisfy the following requirements:
- `Alamofire (~> 3.5.0)` required by `Podfile`

None of your spec sources contain a spec satisfying the dependency: `Alamofire (~> 3.5.0)`.

You have either:
- out-of-date source repos which you can update with `pod repo update`.
- mistyped the name or version.
- not added the source repo that hosts the Podspec to your Podfile.

Note: as of CocoaPods 1.0, `pod repo update` does not happen on `pod install` by default.

I tried pod update and pod install either of the commands fail at this point.
 [!] Unable to satisfy the following requirements:

Alamofire (~> 3.5.0) required by Podfile

i am facing the same above issue, how can this be resolved. 

thanks
 @SunilProgramobil @FezMatech 

I got the same problem.
how do you fix it?
 Genrally,
`pod repo update` fixes problem for you but if you running on detached HEAD state it fails to do so.

So what i have did just go to this **path** 
`
~/.cocoapods
`

And **Remove** All data from that folder and after that 
`pod repo update` and then `pod install`

> Note: It takes time to Update
 @Chakery 
instead of "pod install" please do "pod update"  in terminal , actually when you i do "pod install" and you already have that framework installed in project , it doesn't update and gives error 
  Hi guys. I'm having trouble passing some parameters for the query of an API. The "+" is being converted to %2B. Does anyone have any idea how to solve?

```
    let pullRequestUrl = "https://api.github.com/search/issues"     
    Alamofire.request(
        .GET,
        pullRequestUrl,
        parameters: ["q": "repo:\(repo)+is:\(status)+type:pr", "sort": "created", "page": page],
        encoding: .URLEncodedInURL)
        .validate()
        .responseJSON { (response) -> Void in
            guard response.result.isSuccess else {
                print("Error fetching pull requests: \(response.result.error)")
                completion(nil)
                return
            }

            if let data = response.result.value {
                let json:JSON = JSON(data)
                completion(PullRequest(fromJson: json))
            }

            completion(PullRequest(fromJson: ""))
    }
```
  I hope this is the right place to post this. I would love to start testing Alamofire with swift 3.0 soon :) Thanks!
 After I upgraded to swift 3.0, just a mention :)
<img width="603" alt="screen shot 2016-06-14 at 14 37 04" src="https://cloud.githubusercontent.com/assets/3411255/16041382/a77ca444-323d-11e6-9fc9-db92d6152f9e.png">
 I would like to point out that I've got a Swift 3 compiling branch over [here.](https://github.com/avaidyam/Alamofire/tree/swift-3.0)
 @avaidyam i have 150 error with your Swift 3 compiling branch :\ 
 @mattcianna The tests don't compile; I just built the framework to continue migrating my own project over. I can't guarantee it even works. All I did was migration assistant and find/replace until it built. It's a good platform since there are no more build errors though.
 @avaidyam I think it's very import that the tests do compile for Swift 3, as some frameworks are changing whether they are value or reference type. The tests will be needed to confirm this has no unexpected side results!
 @dgsmith Totally understand! Problem: I was in the middle of phasing out Alamofire from my project (no hard feelings) and just needed the framework to compile so I could go ahead and do that. 

Anyone is welcome to fork my fork and continue where I left off in the `swift-3.0` branch. I figured since I had done some hard labor (Xcode is near useless for migration, honestly) I would share it.
 Is there a release date for Alamofire for swift 3?
  Alamofire can't download this image:
http://img.bleacherreport.net/img/images/photos/003/603/842/hi-res-7e80f8cf338ffd57b5fb47f7ab774a4c_crop_exact.jpg?w=1500&h=1500&q=85

Here's my code to download the image:

`
        let urlToRequest = "BROKEN LINK SEEN ABOVE"

```
    let manager = MediaStorageManager().checkIfImageIsCachedLocally(urlToRequest)

    log.pr(getDocumentsDirectory())


    downloadImage(urlToRequest) { (progress, error, data) in
        log.pr(progress)
        log.pr(error)


        if manager == true && progress! == 1.0 {
            log.pr("DONE!")

        } else if progress! == 1.0 {
            log.CRITICAL("IT's STILL BROKEN!!!")

        }

    }


func downloadImage(url: String, completionHandler: (Double?, NSError?, NSData?) -> Void) {
    let destination = Request.suggestedDownloadDestination(directory: .DocumentDirectory, domain: .UserDomainMask)

    download(.GET, url, destination: destination)
        .progress { bytesRead, totalBytesRead, totalBytesExpectedToRead in
            //                print("TOTAL BYTES READ: " + String(totalBytesRead))
            //                print("TOTAL BYTES EXPECTED: " + String(totalBytesExpectedToRead))

                // SEND NSNotification ABOUT DOWNLOAD PROGRESS:
                let progress = Double(totalBytesRead) / Double(totalBytesExpectedToRead)

                completionHandler(progress, nil, nil)

        }
        .responseData { response in

            log.pr(destination)

            completionHandler(1, response.result.error, response.data)
    }
}
```

`

When I download the image from that specific URL, I get this error on the first download attempt:

`[üíÄüíÄüíÄCRITICALüíÄüíÄüíÄ]: IT's STILL BROKEN!!!

Error Domain=com.alamofire.error Code=-6004 "Data could not be serialized. Input data was nil." UserInfo={NSLocalizedFailureReason=Data could not be serialized. Input data was nil.}`

And at the second download attempt, I'll get his error:

`[üíÄüíÄüíÄCRITICALüíÄüíÄüíÄ]: IT's STILL BROKEN!!!

Error Domain=NSCocoaErrorDomain Code=516 "‚ÄúCFNetworkDownload_NmzEaq.tmp‚Äù couldn‚Äôt be moved to ‚ÄúDocuments‚Äù because an item with the same name already exists." UserInfo={NSSourceFilePathErrorKey=/private/var/mobile/Containers/Data/Application/D154BDCE-5756-4554-86A3-622E8472D705/tmp/CFNetworkDownload_NmzEaq.tmp, NSUserStringVariant=(
    Move
), NSDestinationFilePath=/var/mobile/Containers/Data/Application/D154BDCE-5756-4554-86A3-622E8472D705/Documents/hi-res-7e80f8cf338ffd57b5fb47f7ab774a4c_crop_exact.jpg, NSFilePath=/private/var/mobile/Containers/Data/Application/D154BDCE-5756-4554-86A3-622E8472D705/tmp/CFNetworkDownload_NmzEaq.tmp, NSUnderlyingError=0x144f36310 {Error Domain=NSPOSIXErrorDomain Code=17 "File exists"}}`

But I can use the Alamofire GET request function and the image downloads just fine.
 I'm going to be digging around to find a quick solution, I'll post it up here if I find it.
  When encoding(URL or URLEncodeInURL) a dictionary with array as value
the result combinations of main dictionary key and array elements must
be indexed.
 When using next structure as parameter
{"filter": [ {"field": "user_id",
              "type": "eq",
              "value": 2 },
             {"field": "someField",
              "type": "eq",
              "value": 0 }]}
then the formatted string for url(before encoding) must be

filter[0][field]=user&filter[0][value]=7&filter[0][type]=eq&filter[1][field]=someField&filter[1][type]=eq&filter[1][value]=0

and not

filter[][field]=user&filter[][value]=7&filter[][type]=eq&filter[][field]=someField&filter[][type]=eq&filter[][value]=0
  hi
how to resolve this error
i want to upload data in background

if i use multipart from data then its increase data length which is not match to original so my image not perfactly upload to server

but if i use data then its upload perfactly

but when i try upload with manager then its fire not supported background session error

Thank you
  When I print `request.debugDescription` from a multipart upload request (I'm guessing it doesn't matter what kind of request this is), I'm noticing duplicate fields:

```
$ curl -i \
    -X POST \
    -H "Content-Type: multipart/form-data; boundary=alamofire.boundary.ac7f77e2ea014347" \
    -H "Content-Type: application/json" \
    "http://..."
```

Looking at [the code](https://github.com/Alamofire/Alamofire/blob/f443cd8a76024224ef57cd9aaf8d04480627e036/Source/Request.swift#L531), I'm guessing that perhaps by using `NSObject` as the dictionary key instead of something like `String`, we are putting different `NSObject`s in there (one from `session.configuration.HTTPAdditionalHeaders` and one from `request.allHTTPHeaderFields`), and the request-specific ones aren't overwriting the session-specific ones, as is the intention.
  I'm new to Alamofire, so something like this might be already possible.
Anyways, can we create request with multiple options like headers, parameters, file, authentication with a single statement?
addParameters(parameters).addHeaders(headers).addCookies(cookies).addFile(file.addData(data).addAuthentication(user, password).response{}
This would be amazing!
  I need to perform a **multipart-data** request to upload an image on an API.
What I want to do it's to predict the length of the HTTPBody, because I need this value in my header, for the authentication. Is there a way after building the request to know the total length ?

In the **encodingCompletion** I get my Request called upload, but the **upload.request** is nil.
So I can't check for example the length like : `upload.request.HTTPBody.lenght`.

``` swift
Alamofire.upload(method, path, headers: headers, multipartFormData: { multipartFormData in
            multipartFormData.appendBodyPart(data: data, name: "picture")
            if let parameters = parameters {
                for (key, value) in parameters {
                   multipartFormData.appendBodyPart(data: value.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!, name :key)
                }
            }
            }, encodingCompletion: { encodingResult in
                switch encodingResult {
                case .Success(let upload, _, _):
                    self.request = upload
                    self.handleJSONResponse(upload, blockSuccess: blockSuccess, blockError: blockError)
                case .Failure(let encodingError):
                    print(encodingError)
                    blockError(.None)
                }
        })
```

Maybe there is an issue in the server side to determine the length body, but impossible to get the same value in the client (üì±), not even close.

Thanks in advance üê®üëç
  Hi, I discovered that Alamofire does not work with multi part jpeg streams from ip cameras, though NSURLSession with **dataTaskWithRequest** method works fine.
When I try this:

```
Alamofire.request(.GET, "http://wmccpinetop.axiscam.net/mjpg/video.mjpg")
            .responseData { response in
                switch response.result {
                case .Success:
                    success(response.data)
                case .Failure:
                    failure(response.result.error)
                }
        }
```

It does not even get any response.

Try this url http://wmccpinetop.axiscam.net/mjpg/video.mjpg (not working), other image streaming formats seem to work fine. Can you check?
  Hi,
I am doing an image upload using Alamofire.upload().response.

However, sometimes user press the home button(not lock button) and the app go into background when it is uploading. 
I noticed that Alamofire response closure does not run when it happens. Causing my app to think that upload has failed, even thou it has succeed.

Is it the default behavior of nsurlconnection? How do I avoid this issue?

Thanks
  Hi, 

I got an issue sending a POST request to our API when using Alamofire on iOS 9.1 +, minor iOS versions seem to be fine and the problem occurs afaik on several versions of Alamofire (2.0, 3.0 - 3.4 tested).

I created a simple sample code to test this case: 

In detail my first request I send always fails with "Could not connect to server":

`Alamofire.request(.POST, "https://...", parameters: parameters, encoding: .JSON, headers: nil)
            .authenticate(user: "<user>", password: "<password>")
            .responseString { (response: Response<String, NSError>) in
                print(response)
        }`

> FAILURE: Error Domain=NSURLErrorDomain Code=-1004 "Could not connect to the server." UserInfo={NSUnderlyingError=0x7f7f90e12cc0 {Error Domain=kCFErrorDomainCFNetwork Code=-1004 "(null)" UserInfo={NSErrorPeerAddressKey=<CFData 0x7f7f90e35f60 [0x1062637b0]>{length = 16, capacity = 16, bytes = 0x100201bb59bf42510000000000000000}, _kCFStreamErrorCodeKey=-2200, _kCFStreamErrorDomainKey=4}}, NSErrorFailingURLStringKey=<url>, NSErrorFailingURLKey=<url>,n, _kCFStreamErrorDomainKey=4, _kCFStreamErrorCodeKey=-2200, NSLocalizedDescription=Could not connect to the server.}

The FAILURE is thrown immediately and there's no incoming request on our server side, at least the error message is true in this case. 

Sending the same request again once the application was started works like charm, furthermore using the NSURLConnection approach works fine aswell, even on startup:

`        let req = NSMutableURLRequest(URL: NSURL(string: "https://...")!)

```
    req.HTTPMethod = "POST"
    req.setValue("Basic ...", forHTTPHeaderField: "Authorization")
    req.setValue("application/json", forHTTPHeaderField: "Content-Type")

    req.HTTPBody = self.reqString.dataUsingEncoding(NSUTF8StringEncoding)

    let data = try! NSURLConnection.sendSynchronousRequest(req, returningResponse: nil)

    print(String(data: data, encoding: NSUTF8StringEncoding))
```

`

The only clue I have so far is that this is the only POST request in my app that uses Authorization atm, the others do their job as expected.

I'm grateful for any hint pointing in the right direction or if anyone faced similar problems and I'll will continue debugging for a while till I decide to implement a workarround.

Thx
 Update: It's not the Authentication, removed it from the logic and still getting the same behaviour
 I am getting the exact same error. It happens on the first request only. After that it works like a charm. Its weird. Tested on device and simulator. It always fail the first request. Why closing this @cnoon? Maybe a hint to swift newbies like me?
 @cnoon oh! Got it!
So for now `pod 'Alamofire', 'https://github.com/Alamofire/Alamofire.git'` is a workaround?
 #1 The request I'm doing is not triggered upon launch (App is running for quite a while and I even do some GET requests before that)
#2 I only get the bug on POST requests so as far as I see I don't even need to try this sample.
#3 As I don't have the problem with iOS 8.1, or NSURLConnection or NSURLSession I consider it a bug and thought you might wanna know about it.

FYI I implemented a retry counter which ignores the first (n) -1004 errors (according to my settings) and actually it works fine after the first request was discarded.
 Last comment:

Was able to reproduce the behaviour using NSURLSession approach (iOS 8 its fine iOS 9.0 first request fails) so it's not an Alamofire issue.

Thanks :)
 I am getting the exact same error. I installed pod as was supposed  pod 'Alamofire', 'https://github.com/Alamofire/Alamofire.git'
though that did not change the thing.  
I get the bug on GETrequests every time I push start button.  It happens on the every request. So i completely stuck with it, donnu know what to do.
Could you help me?
 Same here. None of the solutions helped.
 I found solution. 
In Terminal try  ifconfig.

i f you have ip address 192.168.0.20 - change you local agress to this one.
 Hey guys! 
Seems like the core of this issue is in nginx, as described here:

http://stackoverflow.com/questions/36907767/nsurlerrordomain-code-1004-for-few-seconds-after-app-start-up

There is a release of nginx, that fixes underlying issue - 1.11.0, however it's not stable, so we might have to wait until it's released.

For now switching to HTTP 1.1 seems like the most sane solution to this problem.
 Great we suspected some problems with our nginx but couldn't find the issue yet. Might have a look into that.
 We also have the same issue, and are also using nginx. Though the really strange part of this, is that it only occurs on iPhones running iOS 9.3 and up (9.3.1 and 9.3.2). We've tested it on iPod's running iOS 9.3 and iPads running iOS 9.3 and on those devices everything is working perfectly fine. 
 setting the encoding parameter worked for me
  **Alamofire.request(.GET, requestUrlString, encoding: .JSON).responseJSON { response in } .**
If i don't set encoding parameter. i am getting above error.
 Make sure you are not running your phone through a proxy... that threw me for a loop for a few mins.    For a request that i expect a 204 (No Content) to be returned as a status code, Alamofire instead infers this as an error. It returns an error which has the same status code as an request that times out.

The following code was used (very basic usage of Alamofire)

```
alamofireManager.request(request)
        .validate(statusCode: 200..<400)
        .responseJSON(options: .AllowFragments) { (response: Response<AnyObject, NSError>) in
                handleAlamofireResponse(response)
         }
```
 hey @borek2 can you make sure that your api does't send content-length header grater then zero , i had the same issue after digging 3 days in it i found the solution

**Problem**  
the actual problem is that my api sending content-length header with value grater then 0 as response  so Alamofire check the content length and he founds that ohh there is content-length grater then zero so i need to read response data so Alamofire going to read it and the server doesn't return anything and there is timeout happened  Server doesn't return anything and Alamofire trying to read response 

**Solution**
make sure that api does't return content-length header value grater then 0 when  status code is  204 

@cnoon  we also need to change the logic how  Alamofire deal with 204 request code  because we are going to read  data but case like above dose't have any response  data in 204 so we don't have to read data if the response code is 204 no content 

 Cheers. üçª
 Thanks for the suggestion @indrajitsinh ! After an alamofire update I did not have the problem anymore, but I will remember your suggestion when I am having trouble again. Thanks for replying!
  Hello,

I am using AlamoFire and AlamoFireImage

and in the wild I am randomly getting random network crashes

```
CFNetwork: SessionConnectionLoadable::_loaderClientEvent_DidReceiveConnectionCacheKey(HTTPConnectionCacheKey*) + 56
```

looks similar to AFNetworking one:
https://github.com/AFNetworking/AFNetworking/issues/2866
https://github.com/AFNetworking/AFNetworking/issues/3530

so I wondered I would open a issue just to discuss this

`Thread 5 name:
Thread 5 Crashed:
0   libobjc.A.dylib                 0x0000000181d31b88 objc_msgSend + 8 (objc-msg-arm64.s:257)
1   CFNetwork                       0x0000000182d12d4c SessionConnectionLoadable::_loaderClientEvent_DidReceiveConnectionCacheKey(HTTPConnectionCacheKey*) + 56 (SessionConnection.mm:197)
2   CFNetwork                       0x0000000182d97718 ___ZN19URLConnectionLoader36protocolDidReceiveConnectionCacheKeyEP22HTTPConnectionCacheKey_block_invoke + 40 (URLConnectionLoader.cpp:1061)
3   libdispatch.dylib               0x00000001821054bc _dispatch_call_block_and_release + 24 (init.c:760)
4   libdispatch.dylib               0x000000018210547c _dispatch_client_callout + 16 (object.m:506)
5   libdispatch.dylib               0x00000001821114c0 _dispatch_queue_drain + 864 (inline_internal.h:1063)
6   libdispatch.dylib               0x0000000182108f80 _dispatch_queue_invoke + 464 (queue.c:3644)
7   libdispatch.dylib               0x0000000182113390 _dispatch_root_queue_drain + 728 (inline_internal.h:1043)
8   libdispatch.dylib               0x00000001821130b0 _dispatch_worker_thread3 + 112 (queue.c:4249)
9   libsystem_pthread.dylib         0x000000018231d470 _pthread_wqthread + 1092 (pthread.c:1990)
10  libsystem_pthread.dylib         0x000000018231d020 start_wqthread + 4 (pthread_asm.s:190)
Activity ID:             0x0000000000271062
Activity Name:           starting resolver activity
Activity Image Path:     /usr/lib/system/libsystem_network.dylib
Activity Image UUID:     A8E4200A-ECC7-3E56-A845-8A0E9CB4A6F0
Activity Offset:         0x0003333c
Activity Running Time:   74.000651 sec`
 https://forums.developer.apple.com/message/131367#131367
 I have the same issue and have asked on SO here:
http://stackoverflow.com/questions/35387246/how-to-debug-and-solve-a-crash-in-afnetworking

I don't use NSURLProtocol. Just AFNetworking. Very rare - happens in 1%-3% of the devices and could never reproduce it :(

Any advice on how to debug this would be highly appreciated!
 I also use only Alamofire for networking, so I am not sure what other part of my app could trigger CFNetwork. 

I will try to see if i can reproduce but it is random and in the wild :D
 @cnoon thank you very much for the swift response!
The reason we believe this is related to AFN is the fact that in all instances of this crash I see the following thread as well, always in this state:

```
AFNetworking
0  libsystem_kernel.dylib         0x180d054bc mach_msg_trap + 8
1  libsystem_kernel.dylib         0x180d05338 mach_msg + 72
2  CoreFoundation                 0x181134ac0 __CFRunLoopServiceMachPort + 196
3  CoreFoundation                 0x1811327c4 __CFRunLoopRun + 1032
4  CoreFoundation                 0x181061680 CFRunLoopRunSpecific + 384
5  Foundation                     0x181a5921c -[NSRunLoop(NSRunLoop) runMode:beforeDate:] + 308
6  Foundation                     0x181aae874 -[NSRunLoop(NSRunLoop) run] + 88
7  *******                      0x1004fbefc +[AFURLConnectionOperation networkRequestThreadEntryPoint:] + 4300603132
8  Foundation                     0x181b3fc40 __NSThread__start__ + 1000
9  libsystem_pthread.dylib        0x180de7b28 _pthread_body + 156
10 libsystem_pthread.dylib        0x180de7a8c _pthread_body + 154
11 libsystem_pthread.dylib        0x180de5028 thread_start + 4
```

(sorry for posting a stack trace, but wanted to back my claim)

We would really appreciate any kind of pointers on how to proceed investigating this... If you can point to some resource that you personally find helpful with debugging such issues (i'm feeling pretty comfortable with debugging assembly code... it's just that I'm not that fluent in iOS+ARM environment. have way more experience in x86/x64 with gdb/windbg)
As @racer1988 pointed out this is practically impossible to reproduce. Always happens in the wild and on rare occasions. However I do believe this is related to situations where a network time out occurred (based on our internal logging). For example I can see a request being made, and after 1-2 hours based on logs timestamps) we get the timeout error (see below) + a crash is recorded at that very moment with Crashlytics.
`Error Domain=NSURLErrorDomain Code=-1001 "The request timed out." UserInfo={NSErrorFailingURLStringKey=https://******************/****/***, NSErrorFailingURLKey=https://******************/****/***, _kCFStreamErrorDomainKey=4, _kCFStreamErrorCodeKey=-2103, NSLocalizedDescription=The request timed out.`

Just sharing as much info as I can in hope that you can point me to any kind of leads to investigate :)

Thank you in advance for the time and effort!
 Adding more information to the issue.
I still get crashes all the time, and the only network connections I am doing is using AlamoFire.

My crashes are like this:
    `___ZN19URLConnectionLoader36protocolDidReceiveConnectionCacheKeyEP22HTTPConnectionCacheKey_block_invoke ()
SessionConnectionLoadable::_loaderClientEvent_DidReceiveConnectionCacheKey(HTTPConnectionCacheKey*) ()`
 I am using NSURLProtocol and NSURLSession 
and in the wild I am randomly getting random network crashes too.

This problem has occurred 3 times today.

`Thread 15 name:  Dispatch queue: com.apple.NSURLSession-work
Thread 15:
0   libsystem_kernel.dylib          0x35060210 __kill + 8
1   libsystem_platform.dylib        0x350fc85e _sigtramp + 42
2   CFNetwork                       0x229e6636 SessionConnectionLoadable::_loaderClientEvent_DidReceiveConnectionCacheKey(HTTPConnectionCacheKey*) + 110
3   CFNetwork                       0x22a48be6 ___ZN19URLConnectionLoader36protocolDidReceiveConnectionCacheKeyEP22HTTPConnectionCacheKey_block_invoke + 18
4   libdispatch.dylib               0x34f68ed6 _dispatch_call_block_and_release + 10
5   libdispatch.dylib               0x34f7304e _dispatch_queue_drain + 1762
6   libdispatch.dylib               0x34f6c02e _dispatch_queue_invoke + 282
7   libdispatch.dylib               0x34f743dc _dispatch_root_queue_drain + 400
8   libdispatch.dylib               0x34f7424a _dispatch_worker_thread3 + 94
9   libsystem_pthread.dylib         0x350fde28 _pthread_wqthread + 1024
10  libsystem_pthread.dylib         0x350fda18 start_wqthread + 8`
  Hello,

When I upload my app to the Appstore, I have the warning as follows,

Non-PIE Binary - The executable 'Payload/Myapp.app/Frameworks/Alamofire.framework' is not a Position Independent Executable. Please ensure that your build settings are configured to create PIE executables. For more information, refer to Technical Q&A QA1788 - Building a Position Independent Executable

I have integrated the Alamofire using cocoa pods. I have no idea of what I am doing wrong on the integration. Please do the needful on this issue.
  If I have multiple `.responseJSON()` handlers installed on a given request, does each one deserialize the JSON from the underlying data? (Just want to confirm)

Is there any mechanism by which I could pass the deserialized JSON `AnyObject` along to further `responseJSON` handlers?

For example, let's say that at a lower level (of my code), I want to ensure that I received a valid JSON response from the server - if not, I want to print a message or handle this in a common/centralized way. So I install a `.responseJSON` handler (or a `response(request, response, data, error)` handler and attempt to do the deserialization myself). Then higher up, the code responsible for making the request has its own `.responseJSON` handler. In the case of a successful result.. I've already deserialized the JSON.. but now I'm doing it again (?).

I could make a custom response serializer... but it looks like that's always given the `NSData` again. For the default case of the response handlers running on the main queue (so, serially).. it would be nice to have a mechanism to pass data from one to the other.

Thank you.
  hi @cnoon 
Alamofire provide resumable upload?

Thank You.
 Yes, inside `Request`. There is `NSProgress` property. It gives you abilities such as resume, pause, upload status, etc.
 ``` swift
public func upload(
        method: Method,
        _ URLString: URLStringConvertible,
        headers: [String: String]? = nil,
        multipartFormData: MultipartFormData -> Void,
        encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
        encodingCompletion: (MultipartFormDataEncodingResult -> Void)?)
{
...
}
```

`MultipartFormDataEncodingResult` contains `Request`
 Okey Thank You @huy-le 
 Could you show a code example of a MultipartFormData upload where you Resume an upload after a connection timeout and the upload is halfway done and the resume and keep on from where it was? Could you please give example? @huy-le  @cnoon I would love to know how you tested this. I [mentioned](https://github.com/Alamofire/Alamofire/issues/1269#issuecomment-224777738) that I tried a few things, but couldn't get the `operatingSystemVersionString` value to change.  Thanks for providing a fix we can all benefit from!
 Thanks! But the strange thing is, we've had reports of this happening in
languages our app isn't localized in üòñ. Anyway, thanks again for providing
more info!
On Fri, Jun 17, 2016 at 7:31 AM Christian Noon notifications@github.com
wrote:

> Hi @bgerstle https://github.com/bgerstle,
> 
> One of the apps I work on is localized in 20 languages. All I did was drop
> some log messages into our AppDelegate printing out the
> operatingSystemVersionString values and ran it in the different languages
> posted above as an experiment.
> 
> You can easily add additional localizations to a sample project by adding
> a new localization in your project's Info settings. Here's a link
> http://www.appcoda.com/localization-tutorial-ios8/ to get you started
> if you haven't done this before. Then you can switch between locales when
> launching by switching Scheme's runtime language which can be done by Edit
> Scheme -> Run -> Options -> Application Language.
> 
> Cheers. üçª
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> https://github.com/Alamofire/Alamofire/pull/1292#issuecomment-226784450,
> or mute the thread
> https://github.com/notifications/unsubscribe/AAbHOTHWyBvox391AH3niBFc3B7zQjaeks5qMq-3gaJpZM4IuS5b
> .
  Hi,

I have set `timeoutIntervalForRequest` and `timeoutIntervalForResource` both for `NSURLSessionConfiguration` but service stop directly when I use below code.

```
func callService() {
       // var alamoFireManager : Alamofire.Manager?
var alamoFireManager = Alamofire.Manager.sharedInstance
        let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
        configuration.timeoutIntervalForRequest = 10 // seconds
        configuration.timeoutIntervalForResource = 10

        alamoFireManager = Alamofire.Manager(configuration: configuration)
        alamoFireManager.request(.GET, RequestCall.API_URL + request, parameters: parameters, encoding: .URL)
            .responseJSON { response in

                if let JSON = response.result.value {
                    print(JSON)
                    callback!((JSON as! NSDictionary))
                }
        }
}
```

Is any wrong with code? I want timeout when response not retrieve after 10 seconds.
  I have added a bool in return in addImage function in imageCache just to get first-hand knowledge that either my image is being cached or not. 
if let imageIsInCache = self.cachedImages[identifier]{
            if imageIsInCache.totalBytes > 0 {
                cacheStatus = true
       } //thats all i did
Before i was getting false than tried through download manager like this

  let imageDownloader = ImageDownloader(
            configuration: ImageDownloader.defaultURLSessionConfiguration(),
            downloadPrioritization: .FIFO,
            maximumActiveDownloads: 15,
            imageCache: AutoPurgingImageCache()
        )
       let downloader = imageDownloader
        Alamofire.request(.GET, request, headers: headers)
            .responseJSON { response in
        if let JSON = response.result.value {
        self.imagesArray = NSMutableArray()
        self.imagesArray = JSON["results"] as! NSMutableArray
            for results in self.imagesArray{
            let URLRequest = NSURLRequest(URL: NSURL(string:results["url"] as! String)!)
            downloader.downloadImage(URLRequest: URLRequest, filter: nil, completion: { response in
                if response.response?.statusCode == 200{
                    print("In the house fetching url: (results["url"] as! String)")
                    let image = response.result.value
                    print("Size of image: (image?.size)")
                    let returnValue = downloader.imageCache?.addImage(image!, withIdentifier: results["url"] as! String)
                    print("return status: (returnValue)")
                    if results .isEqual(self.imagesArray.lastObject){
                        self.activityIndicatorView.stopAnimating()
                        self.activityIndicatorView.hidden = true
                        let fic = self.imagesArray.firstObject
                        print("getting image for this url : (fic!["url"] as! String)")
                        var imageC = UIImage()
                        imageC = (downloader.imageCache?.imageWithIdentifier(fic!["url"] as! String))!
                        self.ssImage.image = imageC
                        print("Image : (imageC.size))")
                    }
                }
            })
        }  
        }
        }

I am getting true each time now. Even if that logic is a completely wrong,  size of the image I am printing before adding the image to cache is proof for that I am giving image to cache.  I don't know when I am trying to retrieve it I am getting nil. I was trying with different method before and through debugging i noticed that whenever i iterate over breakpoints one by one i got images from cache, i believe that it is because it gets some time to play may be, but i am really very unsure about everything which is going on. Please if you can suggest me something i can do ? Just would like to add before i was caching 30 images may be those images were of small size than these ones. 
 @cnoon Oh i am really sorry about that. let me take another path. 
  Hi, I just tried to upload my app binary to AppStore, but this warning returned to me from Apple:

> WARNING ITMS-90080: "The executable 'Payload/MyApp.app/Frameworks/Alamofire.framework' is not a Position Independent Executable. Please ensure that your build settings are configured to create PIE executables. For more information refer to Technical Q&A QA1788 - Building a Position Independent Executable in the iOS Developer Library."

I checked Alamofire target settings and all seems to be set correctly. Any ideas? Thank you.
 I got the same warning with all my cocoapods after switching from google cloud messaging to firebase messaging. Before I had to disable bitcode in my project, because of GCM. Now with firebase bitcode needs to be enabled. Maybe this helps.
 Hi, thank you for your answers. The most weird thing is, that I've seen this message for the first time today and I haven't changed anything in the build settings since my first app release version. I submitted 24 builds into AppStore without any problem until today.

I added Alamofire manually as embedded framework and bitcode is enabled in my project. 
 Same problem here.

Just started yesterday.  I had uploaded several builds with no errors before that, and no changes to the framework or my project.
 Got the same problem starting today. it was fine yesterday with the same config.
 This is more likely issue from Apple side considering a binary as `PIE` and checking that flag so no need to worry for any libs üëç 
 It seems this is something happening everywhere at the moment. I just uploaded an app that doesn't use Alamofire and got a bunch of this warning. Must be some bullshit in the Apple's servers. Never seen this before btw.
 I had this warning too about PIE for Alamofire but also for all frameworks I used on my application
It's could be an issue on Apple's end... or not
Many applications used CocoaPods or Carthage to manage components. If Apple change this Warning to an Error they can block all applications that use those tools to manage their components. Maybe Apple wants to force us to use an official tool like SwiftPM instead. Perhaps with a new version of Xcode that supports SwiftPM? If that's we'll surely know at WWDC. 
 I just had this issue with Firebase. Never have gotten the message before. 
 Same here. Uploaded a build with the following message:

> We have discovered one or more issues with your recent delivery. Your delivery was successful, but you may wish to correct the following issues in your next delivery:
> 
> Non-PIE Binary - The executable 'Payload/Property.app/Frameworks/Alamofire.framework' is not a Position Independent Executable. Please ensure that your build settings are configured to create PIE executables. For more information, refer to Technical Q&A QA1788 - Building a Position Independent Executable

However, I have about 4 or 5 pods and half a dozen in-house built and manually imported frameworks. All of them give this warning, without exception. I've successfully uploaded and distributed a build to internal testers with TestFlight.
 Me too.  They send me message by email:

> We have discovered one or more issues with your recent delivery for "MyApp". Your delivery was successful, but you may wish to correct the following issues in your next delivery:
> 
> Non-PIE Binary - The executable 'Payload/MyApp.app/Frameworks/Alamofire.framework' is not a Position Independent Executable. Please ensure that your build settings are configured to create PIE executables. For more information, refer to Technical Q&A QA1788 - Building a Position Independent Executable
> 
> Non-PIE Binary - The executable 'Alamofire.framework' is not a Position Independent Executable. Please ensure that your build settings are configured to create PIE executables. For more information, refer to Technical Q&A QA1788 - Building a Position Independent Executable
 Got same issue. All my cocoapods  got this warning. 
  Update cocoapod install to be compatible with cocoapod 1.x as it now requires a concrete target.
  Hi there, I am writing a project in swift 3 that also uses a library written in swift 3. Is there a way to convert the current Alamofire to Swift 3 or is there a beta for swift 3 that I might be able to use?
Thanks
 Hi. Since Swift 3 tools have been released couple of days ago, what is the status on this? 
  I just ran "carthage update --platform iOS" as always, but this time it failed on Alamofire.

Cartfile line: 

```
github "Alamofire/Alamofire" ~> 2.0
```

Output: 

```
*** Building scheme "Alamofire iOS" in Alamofire.xcworkspace
2016-05-31 07:56:44.884 xcodebuild[10788:886338]  DVTAssertions: Warning in /Library/Caches/com.apple.xbs/Sources/IDEFrameworks/IDEFrameworks-10188.1/IDEFoundation/Playgrounds/IDEPlaygroundAuxiliarySourceCompilerOperation.m:312
Details:  Unable to read diagnostics from file "/Users/Joe/Library/Developer/Xcode/DerivedData/Alamofire-ajabxbvtiltrbmdcuvcrervytkwn/Build/Intermediates/Alamofire.build/Release-iphoneos/Alamofire iOS Tests.build/Objects-normal/armv7/ManagerTests.dia" (Invalid File): Invalid diagnostics signature
Function: void XCGenerateDiagnosticsFromFile(NSString *__strong, NSString *__strong, NSDictionary *__strong, NSDictionary *__strong, IDEActivityLogSectionRecorder *__strong, BOOL (^__strong)(IDEActivityLogMessage *__strong))
Thread:   <NSThread: 0x7f9f927a6070>{number = 8, name = (null)}
Please file a bug at http://bugreport.apple.com with this warning message and any useful information you can provide.
** BUILD FAILED **


The following build commands failed:
    CreateUniversalBinary /Users/Joe/Library/Developer/Xcode/DerivedData/Alamofire-ajabxbvtiltrbmdcuvcrervytkwn/Build/Products/Release-iphoneos/Alamofire\ iOS\ Tests.xctest/Alamofire\ iOS\ Tests normal armv7\ arm64
(1 failure)

fatal error: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/lipo: can't open input file: /Users/Joe/Library/Developer/Xcode/DerivedData/Alamofire-ajabxbvtiltrbmdcuvcrervytkwn/Build/Intermediates/Alamofire.build/Release-iphoneos/Alamofire iOS Tests.build/Objects-normal/armv7/Alamofire iOS Tests (No such file or directory)
A shell task failed with exit code 65:
2016-05-31 07:56:44.884 xcodebuild[10788:886338]  DVTAssertions: Warning in /Library/Caches/com.apple.xbs/Sources/IDEFrameworks/IDEFrameworks-10188.1/IDEFoundation/Playgrounds/IDEPlaygroundAuxiliarySourceCompilerOperation.m:312
Details:  Unable to read diagnostics from file "/Users/Joe/Library/Developer/Xcode/DerivedData/Alamofire-ajabxbvtiltrbmdcuvcrervytkwn/Build/Intermediates/Alamofire.build/Release-iphoneos/Alamofire iOS Tests.build/Objects-normal/armv7/ManagerTests.dia" (Invalid File): Invalid diagnostics signature
Function: void XCGenerateDiagnosticsFromFile(NSString *__strong, NSString *__strong, NSDictionary *__strong, NSDictionary *__strong, IDEActivityLogSectionRecorder *__strong, BOOL (^__strong)(IDEActivityLogMessage *__strong))
Thread:   <NSThread: 0x7f9f927a6070>{number = 8, name = (null)}
Please file a bug at http://bugreport.apple.com with this warning message and any useful information you can provide.
** BUILD FAILED **
```

If I switch back to 2.0.2, it builds file:

```
github "Alamofire/Alamofire" == 2.0.2
```
  I am trying to manually add this to my project however, its not attached to it. Its not getting imported.
 Is there any reason why you're not using cocoapods?
 I had to run build to fix import error.  found solution here: https://github.com/Alamofire/Alamofire/issues/441
  Data from my API takes 5s to be retrieve in those 5 s if I disconnect internet app crashes
  I created a small protocol named `URLRequestConfigurable` which works in similar fashion to `URLRequestConvertible` but in my opinion makes Routers more readable.

You can find it (and the reasoning behind it) [here](https://github.com/gmarm/AlamofireURLRequestConfigurable). It's easy to integrate via CocoaPods and comes with a small example project.

I wanted to ask you, is this protocol something you would consider merging? Thanks!
 Thanks for your feedback! 

@cnoon, it definitely makes sense to turn the `typealias` into a `struct`, and @jshier you make some very valid points indeed.

I think I will then keep iterating on this in a separate repo, and lets see what will be announced at WWDC.

Cheers!
 I've updated `URLRequestConfigurable` for Swift 3.0, also taking into consideration the feedback posted above.

You can find it [here](https://github.com/gmarm/AlamofireURLRequestConfigurable).

If it's something you would consider merging let me know, otherwise I'm gonna keep it as a separate repo. :)
  I am not able to cancel below multipart data upload request when internet connection not available. Any suggestions?

```
Alamofire.upload(
    .POST,
    "https://httpbin.org/post",
    multipartFormData: { multipartFormData in
        multipartFormData.appendBodyPart(fileURL: unicornImageURL, name: "unicorn")
        multipartFormData.appendBodyPart(fileURL: rainbowImageURL, name: "rainbow")
    },
    encodingCompletion: { encodingResult in
        switch encodingResult {
        case .Success(let upload, _, _):
            upload.responseJSON { response in
                debugPrint(response)
            }
        case .Failure(let encodingError):
            print(encodingError)
        }
    }
)
```
 @cnoon I've followed the steps you placed above, but my app crashed when the upload request cancel, can you help on [SO](http://stackoverflow.com/questions/40819710/alamofire-3-5-1-crashed-when-cancel-the-upload-request)? That's awesome @cnoon thanks a lot for the code! Hello Help me How to Store Multiple Upload Requests and  delete based on selected request array in Alamofire i've used swift 2.3 and Alamofire '3.4'   Hi All
We dowload files with ALamofire with file names including non-unicode charachters and Alamofire saves the file with wrong charachters. How could we fix that Alamofire downloads and save the file name correctly?

Thanks
Gurkan
  It looks like if the Content type set to be URL, the parameters don't get serialized. by debugging it it seems this switch statement only cares about `URLEncodedInURL` and ignores if the type is `URL` and parameters are present.

https://github.com/Alamofire/Alamofire/blob/master/Source/ParameterEncoding.swift#L116
  For example:

``` swift
{
    response =     {
        docs =         (
                        {
                "_version_" = 15352wqwd18967678812160;
                active =                 (
                    1
                );
                email =                 (
                    "me@me.com"
                );
                firstName =                 (
                    Nehlo
                );
                id = NehloTestUser1464098899306;
                lastName =                 (
                    Test
                );
                mode =                 (
                    User
                );
                password =                 (
                    wear21zero
                );
            }
        );
        numFound = 1;
        start = 0;
    };
    responseHeader =     {
        QTime = 1;
        params =         {
            indent = true;
            q = "mode:* AND active:true AND email:(me@me.com) AND password:(wear21zero)";
            rows = 10;
            wt = json;
        };
        status = 0;
    };
}
```

is a json I am receiving from the server. How do I check for the "numFound" value? Like if it is 1, i should push the user to the main screen else ask him to input correct username/password. Help please??
 The responseJSON parameter use the iOS native JSON parser, which returns a NSDictionary or NSArray, you need to check the object type. For your case, you can try the code below(although you need to check the object type step by step in practice or use 3rd-party library like SwiftyJSON):

> object["response"]["numFound"].intValue
 Thank you so much. But is it intValue or just int? 
 @Dershowitz011 ,as you see from the document, the return value is id, which may be NSDictionary,NSArray,NSNumber,NSString. In your case, you will get a NSNumber, if you want to get the scalar int, you can use -[NSNumber intValue] to obtain it.
  Pretty simple update. `errorWithCode` functions are deprecated, yet the new `error()` weren't made public yet.
  I propose that, instead of using `Result.swift`, Alamofire switches to using [Result](https://github.com/antitypical/Result). It would make it possible for projects that use Result to also import Alamofire without a type-conflict.

Currently, if you do:

``` swift
import Result
import Alamofire

func someMethod() -> Result<Int, NSError> { }
```

the return value can't be qualified. It can be qualified as `Alamofire.Result` but not the other way around (`Result.Result` is another error complaining about generic type constraints). There are a bunch of libraries that use Result, ReactiveCocoa and SugarRecord are the ones that come to mind.
 The biggest benefit I'd say is making Alamofire more compatible with other libraries that use `Result`, and making that library the single source of truth. Plus, removing result would reduce the amount of code you have to maintain in Alamofire itsefl.
 No you can't, not if you're using `Result` from the `Result` package. In fact there's a very ugly workaround here: https://github.com/antitypical/Result/issues/77. What you've said only is true for using Alamofire's `Result` class but if using Results `Result`s class, you're pretty much out of luck, short of the workaround.
 @cnoon I think you should re-open this issue. For several reasons:

1) The answer you gave is incorrect.

You said that you can simply namespace `Result` and in fact, you've said that across all the issues you've linked to but it's just wrong.

From #764:

> The fact that the two Result types collide is something you can easily resolve on your end by adding the framework namespace.

That's true when you're using Alamofire's `Result` but not if you're using Result's `Result` class. As I explained above, and listed in antitypical/Result#77, you can't namespace `Result` because the package name is the same as the class and the compiler complains about generics.

2) There have been multiple issues opened about this.

This causes a problem with a ton of people, at least with #1167, #1072, and #764 as far as I can find. I'd argue it causes more issues then it solves and that you'd see less issues were you to incorporate `Result` as a dependency.

3) Anittypical's result is objectively better.

The result framework in question has a ton of advantages, largely the `map` and `flatMap` functions.

4) Dependencies are a good thing, not bad

Plenty of other large libraries use `Result` as an external dependency and over the course of my career programming, have never run into an issue or conflict with a `Result` dependency. The biggest one that comes to mind is ReactiveCocoa.

I would ask that you please take what I've said into consideration and simply don't say:

> I'm not interested in discussing this further.

as in #764.

There's a valuable discussion to be had here and a feature that a lot of people want. It's worth at least discussing. And I suspect, although you may be tired of responding to issues about the same topic, that the same issue will come up time and time again for as long as Alamofire exists.
 Another HUGE downside is that for any public apis that use `Result` from antitypical, they're forever bound to using a dirty work around and exposing that workaround in their api.

For example, the library I'm working on, [feathers-ios](https://github.com/feathersjs/feathers-ios), uses a network provider protocol:

``` swift
public protocol Provider {

    init(baseURL: NSURL)

    func find(parameters: [String: AnyObject], callback: (Result<[AnyObject], ServiceError>) -> ())
    func get(id: String, parameters: [String: AnyObject], callback: (Result<AnyObject?, ServiceError>) -> ())
    func create(data: [String: AnyObject], parameters: [String: AnyObject], callback: (Result<AnyObject, ServiceError>) -> ())
    func update(id: String, data: [String: AnyObject], parameters: [String: AnyObject], callback: (Result<AnyObject, ServiceError>) -> ())
    func patch(id: String, data: [String: AnyObject], parameters: [String: AnyObject], callback: (Result<AnyObject, ServiceError>) -> ())
    func remove(id: String, parameters: [String: AnyObject], callback: (Result<AnyObject, ServiceError>) -> ())

}
```

with concrete implementations such as `SocketProvider` and `RestProvider` but because of the aforementioned silliness in not using the 3rd party library, I now have to change my entire public api to use a workaround, brought upon by Alamofire. 
 @startupthekid While I'm completely on your side with this, there is indeed a workaround that you could use in the meantime:

``` swift
import enum Result.Result
import Alamofire
```

Then the two types can be differentiated by the module namespace: `Result` (this is `Result.Result`) and `Alamofire.Result`.
 Thanks @nubbel, didn't know you could do that!
 Fair enough @cnoon! Thank you so much for the detailed response and thank you for making Alamofire the awesome library it is! üíØ 
  When using the link "VPN network.Alamofire monitoring network, the network status to: NotReachable.But the current network is available.

```
    var manger: NetworkReachabilityManager?


    func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {
        // Override point for customization after application launch.

        manger = NetworkReachabilityManager(host: "https://www.apple.com")
        manger?.listener = { status in
            switch status {
            case .NotReachable:
                print("NotReachable")

            case .Unknown:
                print("NotReachable")

            default:
                break
            }
        }
        self.manger?.startListening()

        return true
    }
```

How can I solve this problem?
 I am having the same issue. Listener is not working when the network goes off. The callback function is not getting called once the network went off.
 Even I am also facing the same issue. Listener is giving true false status correctly on iOS 9 but not in iOS   8. Please try to figure out and fix the issue as soon as possible. 
  Hi, I see that `User-Agent` in `Manager` https://github.com/Alamofire/Alamofire/blob/master/Source/Manager.swift#L64 is localized

because of this 

``` swift
let os = NSProcessInfo.processInfo().operatingSystemVersionString
```

> The operating system version string is human readable, localized, and is appropriate for displaying to the user. This string is not appropriate for parsing.

is this good?
 We've discovered this as well in our own internal attempts to set headers w/ the current OS version. Has anyone had success actually getting `NSProcessInfo.operatingSystemVersionString` to output a string with a different locale?  I've tried using Xcode scheme language options and the launch arguments (`-AppleLocale` and `-AppleLanguages`) to no avail.  Of course I also tried changing my Mac and iOS simulator language & region settings with no luck.
 This is my temp solution

``` swift
public static let osInfo: (version: String, build: String) = {
    let version = UIDevice.currentDevice().systemVersion

    var build = ""
    let os = NSProcessInfo.processInfo().operatingSystemVersionString
    let regex = try? NSRegularExpression(pattern: "\\(.*\\)", options: [])
    if let range = regex?.firstMatchInString(os, options: [], range: NSRange(location: 0, length: os.characters.count))?.range {
      let parts = (os as NSString).substringWithRange(range)
        .replace("(", with: "")
        .replace(")", with: "")
        .split(" ")

      if parts.count == 2 {
        build = parts[1]
      }
    }

    return (version: version, build: build)
  }()
```
  Hi,
I would like to know if it's possible to avoid alamofire to output all responses to console and if it is, how can I do it ?

Thanks
    I've read the document but doesn't understand.

`timeoutIntervalForRequest`
This will cause a timeout if no data is transmitted for the given timeout value, and is reset whenever data is transmitted

`timeoutIntervalForResource`
This will cause a timeout if a resource is not able to be retrieved within a given timeout

What do these mean?
I understand the first one, if there's no data is transmitted for the given timeout value.
But the second one, what is "resource" ?

If i want to set timeout is 20 second, during this time if the server is unreachable, it will be timeout, the first value is a correct choice?
  Some requests always failed, and after debugging requests with backend developer, we found lack of indexes of objects in array parameter. I'm not sure is it error or not.
ParametersEncoding.swift, line: 192-194, after adding 'index' requests succeeded:
 for (index,value) in array.enumerate() {
                components += queryComponents("(key)[(index)]", value)
            }
 I might add that there is an easier solution (workaround is probably the more appropriate wording): rather than having an array, use a `NSMutableDictionnary` and set your indices as the key. Since you can nest dictionnaries this shouldn't be an issue and avoids the need to write a custom `ParameterEncoding`.
  I use dispatch_group to wait the result of Alamfire, since I need to change async to sync. However since I call alamfire nest, it cause dead lock. 
I have to use another lib to call HTTP in the second call to work around it. 
  A test that will fail in order to investigate #1122 

=> session:didReceiveChallenge is being called when using default configuration but won't be called when using background session configuration
  100% okay with this! I agree that it should be each developer's choice to use the AF domain or their own. I personally use my own currently, but I could think of scenarios where it would make sense to use the AF domain.
 > It's their decision as to whether they should use the AF domain or their own.

I strongly disagree. Errors with the Alamofire domain should come from the Alamofire framework. You can even replace Alamofire with any framework or component actually.

While I agree that creating a NSError object with a userInfo dictionary is rather verbose, it‚Äôs not Alamofire's job to provide a public function to simplify NSError creation.

> I personally use my own currently, but I could think of scenarios where it would make sense to use the AF domain.

Could you please elaborate on those scenarios ?
 If I were creating a custom response serializer for a library that was meant to be an extension for Alamofire, I feel that it would be appropriate. 
 By doing so you would be using a code not defined in Error.Code and thus breaking the NSError contract, wouldn't you ?
 > anything outside the Alamofire framework should always use a different domain and not use the AF error codes

Yes

> even if the error code is applicable

No, but I fail to see how an error code from `Error.Code` could be applicable. If someone has written an custom response serializer I‚Äôd love to see the actual code to have some concrete stuff to discuss. I have a feeling that this problem could be better solved with `NSUnderlyingErrorKey` but I‚Äôd love to see some actual code to comment on.

> My main point is that we cannot stop people from doing this, so why not provide them the APIs to make error construction easier?

Indeed, we can not, NSError having an `Int` code is unfortunate, but it was designed decades ago.

Quick reminder about the [NSError contract](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ErrorHandlingCocoa/ErrorObjectsDomains/ErrorObjectsDomains.html#//apple_ref/doc/uid/TP40001806-CH202-SW2)

> An error code identifies a particular error in a particular domain.

Swift is the perfect fit to enforce this contract, but by providing `public static func error(domain domain: String = Error.Domain, code: Int, failureReason: String) -> NSError` Alamofire would be actively encouraging creating an error from the Alamofire domain with a code outside of its domain, thus breaking the NSError contract. Removing the default domain would help of course.

> why not provide them the APIs to make error construction easier?

Because that‚Äôs outside the scope of Alamofire. I‚Äôm pretty sure [@mattt would agree](https://github.com/AFNetworking/AFNetworking/issues/674#issuecomment-11007733). üòâ
 Its worth mentioning that `AlamofireImage` now has deprecated method warnings for `errorWithCode(_:failureReason:)`. 
  How to add url parameters to alamofire so i can limit my search results?

I want to be able to do something similar to:

abc.com/api/v1/search/?term=abc?limit=3

``` swift
let parameters = ["term":"abc", "limit":3]
Alamofire.request(.GET,'abc.com/api/v1/search',parameters:parameters)
.responseJSON {
    ...
}
```

I keep getting Missing argument for parameter #2 in call. Is a workaround for this? Thanks!
  Usage of `Error.errorWithCode` have been deprecated in the project.

Updating README.md to reflect that change
 Sorry for no response. Currently on holidays :)

@jshier I see you already have pull request for solving this issue. Perhaps this one can be closed now?
  Hi guys, I'm wondering if would be a good idea on README to use a protocol extension instead of a direct implementation of `ResponseCollectionSerializable` on `User`. This way it's easier to make any type conform to `ResponseCollectionSerializable`.

If you guys feel like a more functional approach I can change to 

``` Swift
extension ResponseCollectionSerializable where Self: ResponseObjectSerializable {
    static func collection(response response: NSHTTPURLResponse, representation: AnyObject) -> [Self] {
        guard let representation = representation as? [[String: AnyObject]] else { return [] }
        return representation.flatMap { Self(response: response, representation: $0) }
    }
}
```

Happy to hear your thoughts. üôÇ
 I think that in the [Generic Response Object Serialization](https://github.com/Alamofire/Alamofire#generic-response-object-serialization) section on README
```
struct User: ResponseObjectSerializable, ResponseCollectionSerializable, CustomStringConvertible {
    let username: String
    let name: String

    var description: String {
        return "User: { username: \(username), name: \(name) }"
    }

    init?(response: HTTPURLResponse, representation: Any) {
        guard
            let username = response.url?.lastPathComponent,
            let representation = representation as? [String: Any],
            let name = representation["name"] as? String
        else { return nil }

        self.username = username
        self.name = name
    }
}
```
should be
```
struct User: ResponseObjectSerializable, CustomStringConvertible {
    let username: String
    let name: String

    var description: String {
        return "User: { username: \(username), name: \(name) }"
    }

    init?(response: HTTPURLResponse, representation: Any) {
        guard
            let username = response.url?.lastPathComponent,
            let representation = representation as? [String: Any],
            let name = representation["name"] as? String
        else { return nil }

        self.username = username
        self.name = name
    }
}
```

`User` shouldn't  adopt the `ResponseCollectionSerializable` protocol. Hi @giofid, why are you suggesting `User` should not be able to be parsed as a collection of `User`s?  Hi @raphaeloliveira, you're absolutely right! My mistake, sorry.  I'm using Cocoapods to install Alamofire, and it's giving me a ton of errors. I've tried creating a brand new, test project with the only pod being Alamofire, and I'm having the same issue so I don't think it is project-specific. I'm using Xcode 7.2.1 and cocoapods version 1.0.0 with Alamofire version 3.4.0. The following screenshot shows the errors:
<img width="1512" alt="screenshot 2016-05-19 16 56 31" src="https://cloud.githubusercontent.com/assets/312095/15413210/c66d11e6-1de2-11e6-8d68-74fc26324ca6.png">
  Howdy, I had a long flight recently and decided it would be a good time to contribute a bit to the project.  I've begun updating code to Swift 3.0 (based on the 2016-05-09 snapshot).  Do you want to open up a 3.0 branch and have me open up a PR to it?
  My request response has a 200 status code while the isSuccess flag is false, the error is the following:

FAILURE: Error Domain=NSCocoaErrorDomain Code=3840 "Invalid value around character 0." UserInfo={NSDebugDescription=Invalid value around character 0.}

<img width="438" alt="screenshot 2016-05-19 11 08 29" src="https://cloud.githubusercontent.com/assets/6850571/15388488/6cdb7a94-1db2-11e6-858c-812ce291968e.png">
    With version 3.3.1 it was possible to get the successful request with:

.validate().responseJSON { response in switch response.result {
case .Success:
 ...

with 3.4 the case .Success is not called. But response.result.isSuccess is true.

Why that? Did I miss some changes?
  Hi, 
I want to use same session cookie with different urls
Like , I am getting session cookie from url "http://example.com/login"
After getting session cookie from above step, I could set cookie using 

Alamofire.Manager.sharedInstance.session.configuration.HTTPCookieStorage?.setCookies(cookies, forURL: URL, mainDocumentURL: nil)

Also, I think this needs to be done only one time because Alamofire Manager is a Singleton class.

Now, I want to use this session cookie with URL "http://example.qa/mobile/alerts" (please note this time domain changes from .com to .qa),but I think Alamofire Manager is sending the default session cookie, not the one which I set previously.

In this case, it seems that session cookie is dependent on domain name. Is there any workaround
to make this work?
  I'm getting the following swift errors from Alamofire when I'm trying to compile through XCode. Please advise. Thanks!

Is anybody else having the same issue?

The following is how I'm installing Alamofire with cocoapods

```
pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git'
```

My version of XCode is 7.2.1

```
/Users/XXX/Projects/MY_APP/MY_APP/Pods/Alamofire/Source/Manager.swift:736:32: Expected expression after operator
/Users/XXX/Projects/MY_APP/MY_APP/Pods/Alamofire/Source/Manager.swift:736:117: Braced block of statements is an unused closure
/Users/XXX/Projects/MY_APP/MY_APP/Pods/Alamofire/Source/Manager.swift:742:18: Expected pattern
/Users/XXX/Projects/MY_APP/MY_APP/Pods/Alamofire/Source/Manager.swift:742:18: Expected ':' after 'case'
/Users/XXX/Projects/MY_APP/MY_APP/Pods/Alamofire/Source/Manager.swift:742:18: Expected expression
/Users/XXX/Projects/MY_APP/MY_APP/Pods/Alamofire/Source/Manager.swift:744:18: Expected pattern
/Users/XXX/Projects/MY_APP/MY_APP/Pods/Alamofire/Source/Manager.swift:744:18: Expected ':' after 'case'
/Users/XXX/Projects/MY_APP/MY_APP/Pods/Alamofire/Source/Manager.swift:744:18: Expected expression
/Users/XXX/Projects/MY_APP/MY_APP/Pods/Alamofire/Source/Manager.swift:746:18: Expected pattern
/Users/XXX/Projects/MY_APP/MY_APP/Pods/Alamofire/Source/Manager.swift:746:18: Expected ':' after 'case'
/Users/XXX/Projects/MY_APP/MY_APP/Pods/Alamofire/Source/Manager.swift:746:18: Expected expression
/Users/XXX/Projects/MY_APP/MY_APP/Pods/Alamofire/Source/Manager.swift:748:18: Expected pattern
/Users/XXX/Projects/MY_APP/MY_APP/Pods/Alamofire/Source/Manager.swift:748:18: Expected ':' after 'case'
/Users/XXX/Projects/MY_APP/MY_APP/Pods/Alamofire/Source/Manager.swift:748:18: Expected expression
/Users/XXX/Projects/MY_APP/MY_APP/Pods/Alamofire/Source/Request.swift:505:17: Expected expression in list of expressions
/Users/XXX/Projects/MY_APP/MY_APP/Pods/Alamofire/Source/Request.swift:504:51: Expected ',' separator
/Users/XXX/Projects/MY_APP/MY_APP/Pods/Alamofire/Source/Request.swift:505:17: Expected ')' in expression list
/Users/XXX/Projects/MY_APP/MY_APP/Pods/Alamofire/Source/Request.swift:505:25: Expected identifier in protocol declaration
/Users/XXX/Projects/MY_APP/MY_APP/Pods/Alamofire/Source/ResponseSerialization.swift:34:5: Expected declaration
/Users/XXX/Projects/MY_APP/MY_APP/Pods/Alamofire/Source/Manager.swift:737:28: Reference to property 'sessionDidFinishEventsForBackgroundURLSession' in closure requires explicit 'self.' to make capture semantics explicit
/Users/XXX/Projects/MY_APP/MY_APP/Pods/Alamofire/Source/Manager.swift:736:117: Expression resolves to an unused function
```
 Is there a specific version that could work with XCode 7.2.1? 
 @jshier I tried doing what was suggested. Using the cocoapod app with installing but I keep getting the following error:

What does this mean? How do I fix this?

```
Analyzing dependencies
[!] Unable to satisfy the following requirements:

- `Alamofire (~> 3.2.1)` required by `Podfile`
- `Alamofire (~> 3.2.1)` required by `Podfile`

None of your spec sources contain a spec satisfying the dependency: `Alamofire (~> 3.2.1)`.

You have either:
 * out-of-date source repos which you can update with `pod repo update`.
 * mistyped the name or version.
 * not added the source repo that hosts the Podspec to your Podfile.

Note: as of CocoaPods 1.0, `pod repo update` does not happen on `pod install` by default.

```
   Hi @cnoon,

Are you guys planning to support the ISO8601 date format for query params?

jamaal
 @cnoon thank you for your help. I really appreciate you taking the time to respond to me.

Ok...If I have to, i will go about converting NSdate to String. But for now I am going to continue using my forked version of alamofire, which is formatting dates in ISO8601 format.

**Note well - the remainder of this statement refers to Swagger and its use of Alamofire. I am just trying to shed some light on what I am doing**

Also, I am using a Swift code swagger client which has Alamofire as a dependency. So I am using the swagger generated client to make the necessary requests(with the dates)

Also I didn't have this issue when i was using Objective C swagger client which was using CFNetworking, which i believe Alamofire uses(CFNetworking that is?...or i could be wrong)

Ok thank you.
Jamaal
  As far as I know, NSURLProtocl could intercepts all reqeuests sent by URL Loading System. But after testing Alamofire (as well as AFN), My custom NSURLProtocol couldn't intercepts those requests sent by it, whici means the protocol's "canInitWithRequest" won't be consulted,  but for those sent by NSURLSession, this method could be invoked.

anyone could help me ?
thx
 @cnoonÔºåit turns out that if you use a custom `NSURLSessionConfiguration` (rather than `sharedSession()`), you are gonna have to do the following to make your NSURLProtocol make difference:

```
        let sessionConfiguration = NSURLSessionConfiguration.defaultSessionConfiguration()

         if sessionConfiguration.protocolClasses != nil {
                sessionConfiguration.protocolClasses!.insert(KLXFakeDataProtocol.self, atIndex: 0)
         }
        // use custom sessionConfiguration to initialize your NSURLSession / Alamofire.Manager
```

this part is neither documented in the NSURLProtocol References nor majority of tutorials on the internet.
Hope may helop someone.
  Encountered Chinese, more out of the \346 and other characters, unable to carry out JSON analysis
![2016-05-13 4 32 51](https://cloud.githubusercontent.com/assets/10280215/15242356/6169c726-1928-11e6-8a2c-c85578af07a2.png)
  I'm using this method to get an object named "data" 

.responseObject("data") { (response: Response<User, NSError>) in

everything works fine if I build for the simulator but when I try to build for device i get this error 
Missing argument label 'queue:' in call 
It's like it is using a different kind of method that requires a queue.
  Thank you for wonderful cocoapod!

Our project minimum deploy target is iOS9. We use `Alamofire` as cocoapod, required by `Moya` pod.
Compiler gives us a lot of warnings such as:

```

‚ö†Ô∏è  project/Pods/Alamofire/Source/ParameterEncoding.swift:240:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 8.3, OSX 10.10, *) {
           ^
‚ö†Ô∏è  project/Pods/Alamofire/Source/NetworkReachabilityManager.swift:124:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 9.0, OSX 10.10, *) {
           ^
‚ñ∏ Compiling Download.swift
‚ö†Ô∏è  project/Pods/Alamofire/Source/ParameterEncoding.swift:240:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 8.3, OSX 10.10, *) {
           ^
‚ö†Ô∏è  project/Pods/Alamofire/Source/NetworkReachabilityManager.swift:124:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 9.0, OSX 10.10, *) {
           ^
‚ñ∏ Compiling Error.swift
‚ö†Ô∏è  project/Pods/Alamofire/Source/NetworkReachabilityManager.swift:124:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 9.0, OSX 10.10, *) {
           ^
‚ö†Ô∏è  project/Pods/Alamofire/Source/ParameterEncoding.swift:240:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 8.3, OSX 10.10, *) {
           ^
‚ñ∏ Compiling Manager.swift
‚ö†Ô∏è  project/Pods/Alamofire/Source/ParameterEncoding.swift:240:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 8.3, OSX 10.10, *) {
           ^
‚ö†Ô∏è  project/Pods/Alamofire/Source/NetworkReachabilityManager.swift:124:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 9.0, OSX 10.10, *) {
           ^
‚ñ∏ Compiling MultipartFormData.swift
‚ö†Ô∏è  project/Pods/Alamofire/Source/NetworkReachabilityManager.swift:124:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 9.0, OSX 10.10, *) {
           ^
‚ö†Ô∏è  project/Pods/Alamofire/Source/ParameterEncoding.swift:240:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 8.3, OSX 10.10, *) {
           ^
‚ñ∏ Compiling NetworkReachabilityManager.swift
‚ö†Ô∏è  project/Pods/Alamofire/Source/NetworkReachabilityManager.swift:124:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 9.0, OSX 10.10, *) {
           ^
‚ö†Ô∏è  project/Pods/Alamofire/Source/ParameterEncoding.swift:240:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 8.3, OSX 10.10, *) {
           ^
‚ñ∏ Compiling Notifications.swift
‚ö†Ô∏è  project/Pods/Alamofire/Source/NetworkReachabilityManager.swift:124:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 9.0, OSX 10.10, *) {
           ^
‚ö†Ô∏è  project/Pods/Alamofire/Source/ParameterEncoding.swift:240:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 8.3, OSX 10.10, *) {
           ^
‚ñ∏ Compiling ParameterEncoding.swift
‚ö†Ô∏è  project/Pods/Alamofire/Source/ParameterEncoding.swift:240:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 8.3, OSX 10.10, *) {
           ^
‚ö†Ô∏è  project/Pods/Alamofire/Source/NetworkReachabilityManager.swift:124:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 9.0, OSX 10.10, *) {
           ^
‚ñ∏ Compiling Request.swift
‚ö†Ô∏è  project/Pods/Alamofire/Source/NetworkReachabilityManager.swift:124:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 9.0, OSX 10.10, *) {
           ^
‚ö†Ô∏è  project/Pods/Alamofire/Source/ParameterEncoding.swift:240:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 8.3, OSX 10.10, *) {
           ^
‚ñ∏ Compiling Response.swift
‚ö†Ô∏è  project/Pods/Alamofire/Source/NetworkReachabilityManager.swift:124:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 9.0, OSX 10.10, *) {
           ^
‚ö†Ô∏è  project/Pods/Alamofire/Source/ParameterEncoding.swift:240:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 8.3, OSX 10.10, *) {
           ^
‚ñ∏ Compiling ResponseSerialization.swift
‚ö†Ô∏è  project/Pods/Alamofire/Source/NetworkReachabilityManager.swift:124:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 9.0, OSX 10.10, *) {
           ^
‚ö†Ô∏è  project/Pods/Alamofire/Source/ParameterEncoding.swift:240:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 8.3, OSX 10.10, *) {
           ^
‚ñ∏ Compiling Result.swift
‚ö†Ô∏è  project/Pods/Alamofire/Source/NetworkReachabilityManager.swift:124:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 9.0, OSX 10.10, *) {
           ^
‚ö†Ô∏è  project/Pods/Alamofire/Source/ParameterEncoding.swift:240:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 8.3, OSX 10.10, *) {
           ^
‚ñ∏ Compiling ServerTrustPolicy.swift
‚ö†Ô∏è  project/Pods/Alamofire/Source/NetworkReachabilityManager.swift:124:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 9.0, OSX 10.10, *) {
           ^
‚ö†Ô∏è  project/Pods/Alamofire/Source/ParameterEncoding.swift:240:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 8.3, OSX 10.10, *) {
           ^
‚ñ∏ Compiling Stream.swift
‚ö†Ô∏è  project/Pods/Alamofire/Source/NetworkReachabilityManager.swift:124:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 9.0, OSX 10.10, *) {
           ^
‚ö†Ô∏è  project/Pods/Alamofire/Source/ParameterEncoding.swift:240:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 8.3, OSX 10.10, *) {
           ^
‚ñ∏ Compiling Timeline.swift
‚ö†Ô∏è  project/Pods/Alamofire/Source/NetworkReachabilityManager.swift:124:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 9.0, OSX 10.10, *) {
           ^
‚ö†Ô∏è  project/Pods/Alamofire/Source/ParameterEncoding.swift:240:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 8.3, OSX 10.10, *) {
           ^
‚ñ∏ Compiling Upload.swift
‚ö†Ô∏è  project/Pods/Alamofire/Source/ParameterEncoding.swift:240:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 8.3, OSX 10.10, *) {
           ^
‚ö†Ô∏è  project/Pods/Alamofire/Source/NetworkReachabilityManager.swift:124:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 9.0, OSX 10.10, *) {
           ^
‚ñ∏ Compiling Validation.swift
‚ö†Ô∏è  project/Pods/Alamofire/Source/NetworkReachabilityManager.swift:124:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 9.0, OSX 10.10, *) {
           ^
‚ö†Ô∏è  project/Pods/Alamofire/Source/ParameterEncoding.swift:240:12: unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
        if #available(iOS 8.3, OSX 10.10, *) {
           ^
```

Those warnings unfortunately show up even when we set `:inhibit_warnings => true` in our `Podfile`.

Would it be possible to have a version of Alamofire for iOS9? Or would it be possible to start version 4.0 with minimum requirements of iOS9?
  When downloading a file, there does not seem to be a way to throw an error or pass it along if something goes wrong in the destination closure.

if I try to download a file to a location where it can't be written, I could prevent the download to happen as my program had figured out that the location could not be reached when running this closure.
(It is especially true when I use the suggestedFilename property if the response)

It would be a very nice feature to be able to get this error in the response closure.
 Sorry for replying so late, my guess would be to either use the error property or to have the possibility to throw an exception in the destination closure, which would be translated into an error in the process.
  In 3.4.0 both of the errorWithCode() methods were marked deprecated, but there are no public versions available to replace them.   I'm wondering if the "error(domain:code:failureReason:)" methods I'm seeing in Error.swift were supposed to be marked as public?

Also, the github page shows the deprecated methods being used still in the example for a custom serializer.
 Hello?  Anyone?  I see 4 thumbs up on this now from other people.
   thanks, i try to make sure
  I'm pretty sure it was working before but recently when I turn my Mac's wifi (I'm testing on Simulator by the way) the requests don't fail at all and I don't got to completion handler. Where can be the problem?
 This happens if I don't use the default manager and create a manager with backgroundSessionConfigurationWithIdentifier
  Dear friends,
Could you help me how to set timeout with Alamofire?

Thanks in advance
  I just started getting this XCode warning tonight. Any way to resolve it?
 You can use following code:

``` swift
let userInfo: Dictionary<NSObject, AnyObject> = [NSLocalizedFailureReasonErrorKey: failureReason, Error.UserInfoKeys.StatusCode: response!.statusCode]
let error = NSError(domain: Error.Domain, code: Error.Code.StatusCodeValidationFailed.rawValue, userInfo: userInfo)
```

BTW, I guess that functions:

``` swift
static func error(domain domain: String = Error.Domain, code: Code, failureReason: String) -> NSError
```

and

``` swift
static func error(domain domain: String = Error.Domain, code: Int, failureReason: String) -> NSError
```

would be **public** in file Source/Error.swift.
 +1 that the the two functions @rafalkitta mentioned should be public..?
 Here's a good explanation of a fix for this warning:
http://www.swiftbyexamples.com/2016/05/12/alamofire-custom-nserror-implementation-to-avoid-using-deprecated-errorwithcode-_-failurereason/
  my package.swift entry looks as following

```
import PackageDescription

let package = Package(
  name: "Alamofire",
  dependencies: [
        .Package(url: "https://github.com/Alamofire/Alamofire.git", majorVersion: 3)
        ]
)
```

but when i run `swift build` i get following error

```
error: NoSources("/Users/agaikwad/git/swift-crash-course/Packages/Alamofire-3.4.0/Tests/Resources")

```
 anyone else facing this issue?
 Cheers. üçª
  Two quick questions/clarifications (forgive me if this post belongs on StackOverflow, rather than GitHub Issues -- I can move it, if necessary): 
1. Is there a reason that the `download` method does not support returning the file contents straight to memory as an `NSData` object, rather than only as a file? Is the best way to achieve this functionality simply to use the `request` method?
2. In the event of a download error, to avoid having a superfluous file written (whose contents are the server error message), I check for an error HTTP response code in the `destination` closure, and if so, I supply Alamofire with a "/dev/null" destination. Is there a better way of doing this?
 Thanks @cnoon, really appreciate you taking the time to clarify. Super helpful! Have a good one.
    Hello,
  I noticed that in my code , when use 

``` swift
print(response.debugDescription) 
or
print(request.debugDescription)
```

There will be a memory leak shows in instrument.

Here is my code:

``` swift
 Alamofire.request(.GET, "https://www.github.com").responseJSON { (response) in
    print(response.debugDescription)
}
```

and this is the screenshoot of instrument
![](https://raw.githubusercontent.com/sosng/AlamofireMemoryLeakSample/master/screenshoot.png)

you can see more in my [repo](https://github.com/sosng/AlamofireMemoryLeakSample)

thanks a lot ~
 Good Job!
  I find that Alamofire use one NSURLSession for all tasks, but I have tried it seems that each download with one NSURLSession is faster than only shared one NSURLSession instance?
  **IMO** I think this PR provides following advantages.
- Ensure unique notification name
- If receive multiple notifications in one method we can write more efficiently by using switch statement like below.

``` swift
func observeNotification(notification: NSNotification) {
    guard let taskName = Notifications.Task(notification.name) else {
        return
    }
    switch taskName {
        case .DidResume:
            //Do anything ...
        case .DidSuspend:
            //Do anything ...
        ...
    }
}
```

Please review when you have enough time üôá 
  It's confused to contain content-type header field in GET request
  Hello,

Due to http://9to5mac.com/2016/05/04/apple-will-require-ios-app-store-apps-to-support-ipv6-only-networks-from-june-1/

I am opening this for raising a small issue, but also to ask a question.

Is alamofire fully supporting IPv6?
referencing the doc from Apple 
https://developer.apple.com/library/mac/documentation/NetworkingInternetWeb/Conceptual/NetworkingOverview/UnderstandingandPreparingfortheIPv6Transition/UnderstandingandPreparingfortheIPv6Transition.html#//apple_ref/doc/uid/TP40010220-CH213-SW1

I haven't found any hardcoded IP address or reference to low level api apart those:

NetworkReachabilityManager.swift  
is using IPv4 only:
`AF_INET`
and
`sockaddr_in`

Apple suggest to support also IPv6 counterparts:
https://developer.apple.com/library/mac/documentation/NetworkingInternetWeb/Conceptual/NetworkingOverview/UnderstandingandPreparingfortheIPv6Transition/UnderstandingandPreparingfortheIPv6Transition.html#//apple_ref/doc/uid/TP40010220-CH213-SW12

If your code handles IPv4 types, make sure the IPv6 equivalents are handled too.

IPv4
IPv6
AF_INET
AF_INET6
PF_INET
PF_INET6
struct in_addr
struct in_addr6
struct sockaddr_in
struct sockaddr_in6
kDNSServiceProtocol_IPv4
kDNSServiceProtocol_IPv6

Thanks
 iOS 8 didn't have NAT64 support, so any iOS 8 device on an IPv6-only network would be hopelessly crippled.  Based on that, I'm pretty sure that as long as your code uses the IPv4 APIs only when actually running on iOS 8 and earlier (i.e. run-time checks, not build-time checks), you should be fine.
 @cnoon @dgatwood Thanks :D

if the issue is < iOS 9 why not putting the IPv6 code wrapped in 

`if #available(iOS 9, *)`

and in a else the IPv4 support for all other iOS versions?
 AND LOL! üò´ 

I did a grep and didn't see it :D 
 So if we are already checking for iOS 9, then this isn't an issue, right? 
 The current implementation of Alamofire's Reachability just uses `sockaddr_in6` on iOS 9 or later. Will this cause any problem if the device happens to be connecting to a IPv4-only network?

However in the [README](https://developer.apple.com/library/ios/samplecode/Reachability/Listings/ReadMe_md.html#//apple_ref/doc/uid/DTS40007324-ReadMe_md-DontLinkElementID_11) of the [Reachability sample](https://developer.apple.com/library/ios/samplecode/Reachability/Listings/Reachability_Reachability_m.html#//apple_ref/doc/uid/DTS40007324-Reachability_Reachability_m-DontLinkElementID_9), it says

> Reachability fully supports IPv6.  More specifically, each of the APIs handles IPv6 in the following way:
> 
> ...
> 
> **_reachabilityForInternetConnection:  This monitors the address 0.0.0.0, which reachability treats as a special token that causes it to actually monitor the general routing status of the device, both IPv4 and IPv6.**_

and the implementation actually uses `sockaddr_in`

``` objc
+ (instancetype)reachabilityForInternetConnection {
    struct sockaddr_in zeroAddress;
    bzero(&zeroAddress, sizeof(zeroAddress));
    zeroAddress.sin_len = sizeof(zeroAddress);
    zeroAddress.sin_family = AF_INET;
    return [self reachabilityWithAddress: (const struct sockaddr *) &zeroAddress];
}
```
 @cnoon 
Why would you say that?
https://github.com/Alamofire/Alamofire/blob/master/Source/NetworkReachabilityManager.swift#L125

I just think the implementation of Alamofire's Reachability might be problematic on IPv4 only network
 @cnoon 
Would you explain why Alamofire need to use sockaddr_in6 for iOS 9 or later, while apple's official sample of Reachability claims that 0.0.0.0 is treated as a special token?

Also, there is a similar issue in AFNetworking, since it has pretty much the same implementation for Reachability: https://github.com/AFNetworking/AFNetworking/issues/3498#issuecomment-220506514

You may refer to the discussion at the bottom
 I agree. Why should we adopt a potentially problematic implementation, while we already have a apple-verified implementation(which is exactly the same as Alamofire's old implementaation)? I'd rather trust apple's official sample.
 Thanks, I got it.

And also I guess the original IPv6 support change was kind of like a miscomprehension of apple's guideline.

> If your code handles IPv4 types, make sure the IPv6 equivalents are handled too.

doesn't necessarirly mean that we should handle IPv6 types only, which is the current status for iOS >= 9.
 Yikes. Most devices are still on IPv4-only networks, so yes, it definitely needs to support both.

Sent from my iPhone

> On May 22, 2016, at 11:44 PM, Ce Zheng notifications@github.com wrote:
> 
> Thanks, I got it.
> 
> And also I guess the original IPv6 support change was kind of like a miscomprehension of apple's guideline.
> 
> If your code handles IPv4 types, make sure the IPv6 equivalents are handled too.
> 
> doesn't necessarirly mean that we should handle IPv6 types only, which is the current status for iOS >= 9.
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly or view it on GitHub
 @cnoon Hey man I've a question, 

I know this issue is closed but, the current version of Alamofire (v3.4.1) supports IPv6-only networks? Because Apple is rejecting my application saying that the HTTPs requests are failing.

Any idea? I'm running out of time and don't know what else could be the problem :S
 > Because Apple is rejecting my application saying that the HTTPs requests are failing.

This issue is only related to Reachability which is just an optional feature, and it does not seem to be related to the failing HTTPS requests. Did apple provide any more details?
 This is what they told me

> We discovered one or more bugs in your app when reviewed on iPad and iPhone running iOS 9.3.2 on Wi-Fi connected to an IPv6 network.
> 
> Specifically, your app returns an error message when we sign in using Facebook and or when attempting to register. 

Any idea? 

Edit: The error could be in the server?
 Thanks man
 Same thing happened again i also did changes in Alamofire NetworkReachabilityManager as per @cnoon for IPv6 network but today again Apple rejected my app with the same issue.

   Your app still still crashes on iPad and iPhone running iOS 9.3.4 connected to an IPv6 network when we:

This occurred when your app was used:
- Offline
- On Wi-Fi
 @cnoon we got application rejected by Apple for IPV6 reason. We are using 3.4.1 and we are iOS 9.0 app now. What would be you recommend set of actions?
 @cnoon it also worth to mention that previous version with 3.4.1 passed apple review, so likely they just do not this checks often. I assume this is how multiple apps passed into App Store. 
 It seems that current approach works only because of mixed networks. IPV6 only network will not handle current Network Reachability approach. Apple explicitly mentioned this in their documentation  regarding 0.0.0.0 calls. Check "Connect without Preflight" section ‚Äî¬†https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/NetworkingOverview/UnderstandingandPreparingfortheIPv6Transition/UnderstandingandPreparingfortheIPv6Transition.html#//apple_ref/doc/uid/TP40010220-CH213-SW25
 > it also worth to mention that previous version with 3.4.1 passed apple review, so likely they just do not this checks often. I assume this is how multiple apps passed into App Store.

@nikita-leonov If that's the case, you should check what changes you added in your rejected version. Current implementation is exactly the same as apple's updated version of [Reachability Sample](https://developer.apple.com/library/ios/samplecode/Reachability/Listings/Reachability_Reachability_m.html#//apple_ref/doc/uid/DTS40007324-Reachability_Reachability_m-DontLinkElementID_9), where Apple explicitly stated 

> reachabilityForInternetConnection: This monitors the address 0.0.0.0, which reachability treats as a special token that causes it to actually monitor the general routing status of the device, both IPv4 and IPv6.
 "Connect without Preflight" section only says it is not recommended to rely on preflight. Alamofire's ReachabilityManager is just an optional feature. If you are not using it then it has no impact on Alamofire's other functionalities.
 @cnoon  Thanks for the suggestion successfully approve my app 20 days before. 
 @kcharwood it was likely some network disturbance that confused apple. We got our application approved afterward with close to nothing changes in a networking code. 

As for IPV6 support, I do agree that it is not only frontend problem, but also something that backend team should work on as well. We investigated our backend setup and found a couple of potential problems that need to be addressed to support IPV6 better.
 @nikita-leonov Hi nikita, we are having exactly the same problem. What have you changed in your network code ?
Thank you in advance
 @YacineVC nothing _facepalm_ it could be that it was some other interference on an Apple side while they were doing a test, as the result they decided that our app is not IPV6 complaint. As @kcharwood  mentioned it seems that existing reachability code with 0.0.0.0 is ok from an Apple standpoint. 
 @nikita-leonov Thank you for your reactivity ! We will see with our backend and Apple 
Finger crossed 
 I know this issue is marked closed but we faced the same issue when we are submitting an update to our app. We have Alamofire 3.4 running and iOS version is 8.0+ . our app got accepted once but now the update submission keeps getting rejected  from Apple. Our servers can handle both IPv6 and IPv4 but unfortunately we don't have an IPv6 network to test out our app with.

Do I have to change something in my NetworkReachabilityManager.swift file, like AF_INET to AF_INET6 or something? Really desperate for the answer here.
 @niennonno After our reject we asked a review to the App Review Submission Community. 
It has been accepted afterwards. 
As @nikita-leonov said, the problem may come from there testing infrastructure.
 I also got my app rejected yesterday due to "NOT SUPPORTING IPV6". I only use AlamoFire and AWS IOS SDK for communicating to APIs. 
 As @cnoon has stated, this library has full IPV6 support. This is very likely not an issue with `Alamofire` and is rather due to IPV6 compatibility issues with your server, a third-party service you are using, or possibly, as @YacineVC suggested, an error in Apple's testing infrastructure.
 @cnoon I can confirm from our recent Apple submission, that the reachability check fails in IPv6-only networks as @nikita-leonov described. In our case that was actually the reason for getting rejected by Apple, because we were relying on that functionality as preflight check. Once we removed the reachability check (that was the only change) and re-submitted, we passed review.

It's a bit tricky, as the failing cannot be reproduced in a mixed environment mit DNS64/NAT64 networks. But it will fail in the IPv6-only network which Apple is using (at least for spot tests) when submitting iOS apps for review.

I'd suggest to either remove the reachability check completely as implemented at the moment - and/or make it more clear to users of Alamofire that the reachability check must not be used for preflight check but only for diagnostic purposes on IPv4 or mixed networks AFTER identifying a connectivity issue, as suggested by Apple: https://developer.apple.com/library/content/documentation/NetworkingInternetWeb/Conceptual/NetworkingOverview/UnderstandingandPreparingfortheIPv6Transition/UnderstandingandPreparingfortheIPv6Transition.html#//apple_ref/doc/uid/TP40010220-CH213-SW25
Otherwise there is a high chance that quite a few more developers are encountering this pitfall.
 @hellmund can you help as to how to remove this check?
 @niennonno @adrimarti We simply ended up removing the call to NetworkReachabilityManager and its "isReachable" check from our app's loading sequence. Now we are only checking ourselves if the loading sequence exceeds a certain threshold number of seconds. If so, we display a dialog to the users, giving them the option to restart the loading process.
 @hellmund not able to find any call to the manager on my side. Can you please help out?
 @niennonno Then it's a different problem in your case, which I can't help much with I'm afraid. If you have a chance to set up a IPv6-only network for testing (not just DNS64/NAT64), that should help you to narrow down where the issue is with your app.
  Hi, I am cancelling a request but after .cancel() callback is called without errors and with a valid response. I call the cancel on the viewDidDisappear method because users can leave the screen while continue loading.
 But it should prevent calling the callback... Which is the workaround? I don't want to block the screen during the request. If users want to go back, they should be able to do that action.
 Same problem with response.response = nil and cannot differentiate is this nil from cancel or timeout. Request did not finish and cancel still calls callback.
  Analyzing statement must before assignment
  There is a need to run Alamofire on Open Swift server platforms 
 https://github.com/apple/swift-evolution#development-major-version--swift-30
 Development of Swift 3 is almost finished and dispatch/NSURLSession will be supported on Linux. It would be great to start considering working on the possibility to port Alamofire to Linux.
 Any news on the development of the above function?
 agree any news?
 I subclassed the swift 3 docker container and added a sshd daemon / zsh 
https://gist.github.com/johndpope/01a74ffb93921df48e334097117be1b3
![screen shot 2016-10-21 at 16 13 39](https://cloud.githubusercontent.com/assets/289994/19610224/47fa3e56-97a9-11e6-837a-65a478093cff.png)

As the trend of backend development is to go microservices - swift  will likely find it's niche / foothold there. 

UPDATE - so after some faffing around - running with above swift3 ubuntu docker container and patching Package.swift to 4.0.2 tag -> 

I get ....
/tmp/SPMTester/Packages/Alamofire-4.0.2/Source/NetworkReachabilityManager.swift:28:8: error: no such module 'SystemConfiguration'
![screen shot 2016-10-20 at 18 05 44](https://cloud.githubusercontent.com/assets/289994/19580618/715a381e-96f5-11e6-8ff4-4311240657dc.png)

One shot script to download + patch alamofire run from inside docker container...
eg. 

```
wget https://gist.githubusercontent.com/johndpope/e590169f7a0aaf08e52ba25a75bcd8d1/raw/5f1a3743e61224f7ae7963d4c61d79a5233c531f/cloneAlamofire.sh
chmod +x cloneAlamofire.sh
```

![screen shot 2016-10-21 at 14 25 44](https://cloud.githubusercontent.com/assets/289994/19607788/2f115b5e-979a-11e6-92d2-ceeea8a16ab6.png)
https://gist.github.com/johndpope/e590169f7a0aaf08e52ba25a75bcd8d1

with my docker container + ssh - you can then simply configure cyberduck to edit files in container. N.B. rather than version bumping package each time to test - you can fork and update script above to point your own files - blow away stuff and recompile. 

I added code to bypass systemconfiguration 
https://gist.githubusercontent.com/johndpope/b09b4560d7a91b638c4ffab356be3516/raw/e3e8f6cb6ac6f8f9706c196a9c100c0a330a488d/NetworkReachabilityManager.swift

but looks like there's wider troubles now
error: use of undeclared type 'NetService'
error: use of undeclared type 'DispatchQueue'

still digging...
https://gist.github.com/johndpope/5d619cd851613515db767c28feeb7105

tried adding import Dispatch - but no joy.

As an alternative - probably safest to go with vapor 
https://vapor.github.io/documentation/http/client.html
 This Edge framework seems like another nice alternative to alamofire for server side swift https://github.com/SwiftOnEdge/Edge

so this looks blocked until Apple implement NSURLSession  - shared 
http://stackoverflow.com/questions/38419999/swift-3-preview-2-linux-error-use-of-unresolved-identifier

One path forward could be to use libcurl -
IBM has libcurl c wrapper in swift for linux - and someone recently made a swifty wrapper for this.
https://github.com/dmcyk/SwiftyCurl

 Suggestion: we should move this discussion to #1935   I have import the Alamofire, but the code completion doesn't work.
However the code works as well
  Using `stringByAddingPercentEncodingWithAllowedCharacters()` to promise the URL encoding;

Changes to be committed:
    modified:   Source/Alamofire.swift
 use this for Swift 3,

addingPercentEncoding(withAllowedCharacters:NSCharacterSet.urlQueryAllowed)  Hi,

Due to some problems i cannot upgrade to Xcode 7.3, what is the Alamofire version that can be used for Xcode 7.2. 
  Hey there,
I hope I'm not just too dumb. I'm currently trying to use the download example with the destination closure.

```
        Alamofire.download(.GET, "https://httpbin.org/stream/100") { temporaryURL, response in
            let fileManager = NSFileManager.defaultManager()
            let directoryURL = fileManager.URLsForDirectory(.DocumentDirectory, inDomains: .UserDomainMask)[0]
            let pathComponent = response.suggestedFilename

            return directoryURL.URLByAppendingPathComponent(pathComponent!)
        }
```

However, the closure is never getting accessed. What am I doing wrong? Or am I'm encountering a generall isue? My Cocapads is is set to use the current version

> pod 'Alamofire'

Thanks guys. 
 Hi @SantoDE

Try please 
`Alamofire.Manager.sharedInstance.startRequestsImmediately = true`
or  call the `resume()` method

``` swift
Alamofire.download(.GET, "https://httpbin.org/stream/100") { temporaryURL, response in
    let fileManager = NSFileManager.defaultManager()
    let directoryURL = fileManager.URLsForDirectory(.DocumentDirectory, inDomains: .UserDomainMask)[0]
    let pathComponent = response.suggestedFilename

    return directoryURL.URLByAppendingPathComponent(pathComponent!)
} .resume()
```
  Updated to a different unicode dash (U+002D rather than U+2013) so that it is parsed correctly by markdown, when converting the CocoaPods Acknowledgements.markdown to HTML.

Please see https://github.com/AFNetworking/AFNetworking/pull/3488 for a screenshot of the effect this change has.
 Works for me, thanks @cnoon. 
  Users are sign in using basic auth. If the sign in is successful, I store the returned JSON for the signed in user in a dictionary in a User class.

```
import Foundation
import UIKit

class User {
    var userJSON: [String:AnyObject]?
}

let sharedUser = User()
```

My issue is that when the app is launched signing in works fine, but if you log out and then try to log in as another user without closing and relaunching the app, the JSON for the first user that was just signed out is stored in the userJSON dictionary instead of the info for the new user who is trying to log in.

Here is the code for signing in:

```
Alamofire.request(.GET, "https://gyminyapp.azurewebsites.net/api/User").authenticate(user: emailTextField.text!, password: passwordTextField.text!)
            .responseJSON {
                son in
                self.responseJSON = json.result.value as? [String: AnyObject]
                print("JSON: \(self.responseJSON)")
                if self.responseJSON!["message"] != nil {
                    let errorMessage = self.responseJSON!["message"] as! String
                    alert = UIAlertController(title: "Error", message: errorMessage, preferredStyle: .Alert)
                    alert?.addAction(okButton)
                    alert!.view.tintColor = BarItems.greenTintColor
                    self.presentViewController(alert!, animated: true, completion: nil)
                } else {
                    if self.responseJSON != nil {
                        sharedUser.userJSON = self.responseJSON
                        print(sharedUser.userJSON)
                    }  
                    self.performSegueWithIdentifier("tabSegue", sender: nil)
                }
            }
```

When the user signs out, they are returned to the sign in screen and the dictionary in the User class is set to nil

```
sharedUser.userJSON = nil
 // Return user to sign in screen
 self.dismissViewControllerAnimated(true, completion: nil)
```
  I'm currently using the [Oatmeal Framework](https://github.com/OatmealCode/Oatmeal), and part of it is making network requests with the Networking component. Now, under the hood, the framework uses Alamofire to make its requests, but it ensures we only run one request at a time (I'm not sure exactly why, I'll inquire about this with the creator). Now, the code for doing that is the following:

``` swift
public func fire(route : Route, completion:(response: ResponseHandler) -> Void)
{
    //Networking is meant as a one track lane, but if the developer puts two cars in the lane, we'll create a fork in the road to let the other in
    var currentRoute = route
    if(currentRequests >= requestCap)
    {
        NSThread.sleepForTimeInterval(1)
    }
    if(pendingRequest)
    {
        if let networking : Networking = ~Oats()
        {
            self.currentRequests += 1
            networking.fire(currentRoute, completion: completion)
        }
    }
    else
    {
        self.currentRoute = route
        if let events : Events = ~Oats()
        {
            events.fire("NetworkingRequest", payload: ["networking" : self])

        }
        //First we create the context of the request
        //Allowing for the developer to have full control over the request
        self.pendingRequest = true

        if let config  = currentRoute.customConfiguration
        {
            manager = Alamofire.Manager(configuration: config, serverTrustPolicyManager: nil)
        }
        else
        {
            let config = NSURLSessionConfiguration.defaultSessionConfiguration()
            config.timeoutIntervalForResource = 600
            config.HTTPAdditionalHeaders      = Manager.defaultHTTPHeaders

            manager = Alamofire.Manager(configuration: config, serverTrustPolicyManager: currentRoute.sslPolicy)
        }

        if(headers.count >= 1)
        {
            currentRoute.headers = headers
        }

        switch(currentRoute.type)
        {
        case .ShouldSendUrlAndReturnJson, .ShouldSendJsonAndReturnIt:
            print("Making request")
            manager.request(currentRoute.compose()).responseJSON { result in
                var handler = self.getHandler(result.response,result: result.result)
                handler     = self.adjustToExpectation(currentRoute, handler: handler)
                self.pendingRequest = false
                self.currentRequests -= 1
                completion(response: handler)
            }
        case .ShouldSendJsonAndReturnString,.ShouldSendUrlAndReturnString:
            manager.request(currentRoute.compose()).responseString{ result in
                var handler = self.getHandler(result.response,result: result.result)
                handler     = self.adjustToExpectation(currentRoute, handler: handler)
                self.pendingRequest = false
                self.currentRequests -= 1
                completion(response: handler)
            }
        }
    }
}
```

The problem is, this gets me stuck in an infinite loop when I make two requests right after each other, as  it appears the handler is never run for the first request. My top contender is the theory that the check for `pendingRequest` is being run on the main thread, and when Alamofire returns with a response, it tries to run the handler on the main thread, but that isn't possible cause it's already hogged by the second request waiting to be dispatched.

My question here is:
1. Am I correct as to what's causing this error?
2. Is this something that should be fixed in Alamofire or is it actually a bug/bad design in the framework
3. (Optional) Help me find a better solution

I'm fairly new to Swift programming, so I'm not the best at debugging these kinds of issues, but I have narrowed it down to the error arising from `manager.request(currentRoute.compose()).responseJSON`, as everything up until that point appears to run.
  Is it possible to modify Request.swift so that it does NOT print out the Accept-Encoding header in the cURLRepresentation method?  If we're running the curl command it's probably because we need to see the actual output, and so having it gzip'd isn't helpful as we have to manually go and remove the encoding param every time.
  After a little bit of frustration, we discovered that Alamofire requires validation before defining the response handler.  While the documentation page mentions it, this seems to severely undercut the importance of validation; Alamofire is next to useless if it returns a success code from an http 400 code.  Being users of AFNetworking 2.x.x, this caught us off guard.

My suggestion would be to include a simple .validate() example in ALL of the response handling examples.  Validation in this context is part of response handling, and should be mentioned as such.

An alternative I would suggest is that since validation procedurally preempts the response handling, the validation section should be covered before the response handling section.
 Thanks @cnoon!  It looks good.  I certainly hope it'll help future devs that give Alamofire a go will have a much more enjoyable time learning it, rather than being temporarily frustrated by it.

I didn't mean it was completely useless; I did say it was "next to" useless without validation.  But next time I use a networking library, and I have a use case where I want to ignore any network errors, I'll let you know  ;)
  I am getting these errors , I am using Xcode 7.2 

![alamofire copy](https://cloud.githubusercontent.com/assets/12180894/14840267/4ae0851a-0c50-11e6-9b07-78322360f16d.png)
 Hi,

Due to some problems i cannot upgrade to Xcode 7.3, what is the Alamofire version that can be used for Xcode 7.2.
  Now my project using 

```
public func download(URLRequest: URLRequestConvertible, destination: Request.DownloadFileDestination) -> Request {
    return Manager.sharedInstance.download(URLRequest, destination: destination)
}
```

to handle download stuff

I also keep refference of `Request` in a dict

when I stop all `Request` and then I `resume()` certain `Request`  in dict 

It isn't just `resume()` that one I chosen, also other request in dict will  `resume()` too.

Any Help?
  When I run a Request object through debugPrint, the -d output is like so:

`-d "{\"key\" : \"value\"}"`

That's OK in a bash shell, but in tcsh that doesn't work because it thinks the quotes are bad.  If you replace the outside quotes with an apostrophe, and then don't escape the inner quotes (or even escaping is technically OK) then it should work fine in either shell.
 What do you mean it's not parsed correctly?  I simply changed Request.swift so that instead of wrapping the entire -d parameters with quotes it wraps them with apostrophe instead.  That's worked against all my API calls so far.

I also personally got rid of the \ escaping across each line as that's painful to work with when doing copy/paste and editing, but that's just me :) 

What would be great would be some config options so we could say things like don't split the parameters across lines, use apostrophe instead of quote, etc...  Defaults would all stay like they are now, but for those of us that have been in UNIX for so long that we use tcsh instead of (shudder) bash (lol) it would work well.
  Hi @cnoon,

I'm having the same exact problem described in [Stackoverflow](http://stackoverflow.com/questions/30344732/is-there-any-limit-on-a-post-request-using-alamofire-in-ios).

Basically I'm adding base64 equivalent of an image to the request POST parameters. The request is failing always with a 400 status code whenever the image size is bigger than 80x80 with a 0.7 compression ratio.

I'd really appreciate your help. Thanks!
 This is the response:

{ status code: 400, headers {
    "Cache-Control" = "no-cache";
    Connection = close;
    "Content-Length" = 727;
    "Content-Type" = "text/html; charset=utf-8";
    Pragma = "no-cache";
} })

The error is nil.

@cnoon Is there any limitation to your knowledge to POST param size?
  Hi guys,

I am newbie in Swift 1.2.0 and I wanted to use Alamorfire library for my project. Kindly let me know how I can use older and compatible version of Alamofire with Swift1.2.0. Currently I am getting 3.+ version of Alamofire which is not compatible with Swift 1.2.0

Thanks
  It seems like responseString is ignoring the HTTP Status code when determining success or failure.  If I do this chaining:

``` swift
            .response {
                request, response, data, error in
                print("Status code is \(response!.statusCode)")
                if let data = data {
                    debugPrint(String(data: data, encoding: NSUTF8StringEncoding)!)
                }
            }
            .responseString {
                [weak self] response in

                print("Success is \(response.result.isSuccess)")
                switch response.result {
                case .Failure(let error):
                    print(error.localizedDescription)

                case .Success(let ident):
```

I see from the first block that the status code is 400 (as i'm expecting in this test) and then I see the data sent back with the reply.  Then it hits the responseString, and the print says success it TRUE instead of false and drops into the .Success part of the switch response.

I know this code is kinda convoluted, but it got built out to isolate the error.
 That wasn't really clear to me from the docs.  What does a failure response mean then in this type of context if you're not looking at response code?
 Thanks.
  Hi guys. I am using Alamofire to submit a JSON object to an api which is expecting a base64 image as one of the key-value pairs. Everything is working fine except that the API I am hitting does not decode the request and I need a way to prevent Alamofire from escaping the base64 string in the object because it escapes "/" with "\/" (as it should), but unfortunately the API i am working with is rejecting my request because it cannot decode the base64 image due to backslashes in string.

Any help would be appreciated, thank you very much guys.

Details:
Xcode 7.3 | Swift 2.2, Alamofire 3.3.0 installed using Carthage.
 @jshier My apologies for not updating the ticket, I was able to resolve the issue by sending blank parameters and changing the encoding type to custom and doing the following in the custom encoding closure closure:

mutableRequest.HTTPBody = paramBlob.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)

thank you for the response, support and excellent library!
  When I delete a half download task, 
there was still a file name like "CFNetworkDownload_6PLBS5.tmp" in the /Developer/tmp folder.
How to delete the file?
 Was my problem is unclear?
I called cancel() method in Request.swift When I delete a downloadTask.
But I think the cancel() method has a problem, because the cancelByProducingResumeData func will leave tmp file...
 I have the same problem. Do you have any idea how to solve this problem?
  I'm currently making HTTP calls to a server that authenticates with Kerberos. Should I expect the override closure `Alamofire.Manager.sharedInstance.delegate.sessionDidReceiveChallenge` to execute **only** after a failed or accepted authentication by the operating system, and not **before** as well?
  I am trying to pass my OAuth 2.0 Token to my web service and it does not appear that Alamofire is even appending the Authentication header to my request.

let header = ["Authentication", "some-oauth-token"]

Alamofire.request(.GET, url, headers: header, encoding .JSON).responseJSON
{
  response in (code)
}
This always results in a response from my server that the Authentication Header is missing. Should I not be doing it this way? I see there is Authentication methods on the request but I do not see one specifically for passing a token over just other auth methods. Is this frowned upon and I should change the way I am doing my REST Auth stuff?
  +1
<img width="1286" alt="screen shot 2016-05-02 at 2 29 56 pm" src="https://cloud.githubusercontent.com/assets/1042992/14954385/3d7370b0-1072-11e6-898b-cdfde7102d76.png">
  Hi Dear @mattt : 
     when  I used Alamofire 3.3.1  by Xcode 7.3,I get some questions . Domain=NSCocoaErrorDomain Code=3840 "JSON text did not start with array or object and option to allow fragments not set." UserInfo={NSDebugDescription=JSON text did not start with array or object and option to allow fragments not set.}

I try to use some idea  Ôºåbut I'm fail.

My code  is below:
Alamofire.request(.POST, url, parameters: dic, encoding: .JSON, headers: nil).responseJSON(options: .MutableLeaves) { (response) in

}

Thanks for your helping
 Thanks for your helps.

> Âú® 2016Âπ¥4Êúà21Êó•Ôºå‰∏ãÂçà10:23ÔºåChristian Noon <notifications@github.com <mailto:notifications@github.com>> ÂÜôÈÅìÔºö
> 
> Hi @crash-wu https://github.com/crash-wu,
> 
> Your error message is encouraging you to use options: .AllowFragments instead of options: .MutableLeaves. That will allow whatever valid JSON object that isn't currently a collection to be parsed successfully.
> 
> In the future, I'd encourage you to instead open a question on Stack Overflow. We use our GitHub project with bug reports and feature requests.
> 
> Cheers. üçª
> 
> From our Contribution Guidelines https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md
> Asking Questions
> 
> We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on Stack Overflow https://stackoverflow.com/ instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly or view it on GitHub https://github.com/Alamofire/Alamofire/issues/1199#issuecomment-212940401
  I'm planning to add logging to one of our app. When debugging we want to log all requests and their response. The README mentions that SessionDelegate can be subclassed to add logging functionality. However, SessionDelegate is marked as final and therefore cannot be subclassed.

Is it the README that needs to be updated or is it not the intention to have SessionDelegate marked as final? If SessionDelegate is not meant to be subclassed, then what would be the best way to add logging of all requests and responses?
 Closing. I overlooked this commit from 11 days ago, which removes the `final` keyword. https://github.com/Alamofire/Alamofire/commit/971e2f808daede617e61753efea6993a639ca649
  Hello,

I'm using:

XCode: 7.3
Swift 2.2
Target: iOS 9.3
Alamofire version 3.3.0

In Alamofire.swift the following line causes a crash:

`let mutableURLRequest = NSMutableURLRequest(URL: NSURL(string: URLString.URLString)!)`

Errormessage:
fatal error: unexpectedly found nil while unwrapping an Optional value

How to reproduce:

let url = "http://abc.company.de/rest/mobile/something/suche/Fris√∂r"
Alamofire.request(.GET, url, parameters: nil, encoding: ParameterEncoding.JSON, headers: Config.NetworkConfig.HTTPRequestHeader)

where the url parameter contains a special character like √∂ or √§ or √º like above.

I don't know whether I should take care and encode the URL or whether Alamofire should take care about the url param?
 Try with encoding URLString before API Call

let safeURL = url.stringByAddingPercentEncodingWithAllowedCharacters(NSCharacterSet.URLQueryAllowedCharacterSet())!
 For swift 3 users :- 

    addingPercentEncoding(withAllowedCharacters:NSCharacterSet.urlQueryAllowed)  I tried to post a large json (contain base64 image string) by using

 Alamofire.request(.POST, "https://httpbin.org/post", parameters: parameters, encoding: .JSON,).progress {  (bytesWritten, totalBytesWritten, totalBytesExpectedToWrite)  in }.

 I understand that I can use upload or formdata to achieve that. I wonder to know if we can use the request function to do that instead of upload().
  Logging in to the app with new credential authenticates with the old credential. 

The credentials are picked from the textFields. Login for the first time works fine. After logout, if I try to login with another account, Alamofire authenticates with the previous credentials.

Say, initially when I login, I authenticate the request with some USERNAME and PASSWORD. Say USERNAME is JOHN and PASSWORD is 1234.

I logout immediately and I login with some other credential, say USERNAME is PETER and PASSWORD is 4321. App logs in again with the old credential JOHN and 1234 only. The new credential is not at all applied

```
func login(userName: String!, password:String!, completion: (error: NSError?) -> Void) {
        print(userName)  // Prints PETER for second attempt
        Alamofire.request(
            .GET,
            Management.LOGIN_URL)
            .authenticate(user: userName , password: password)
            .responseJSON { response in
                // But gives JOHN's data for second attempt
                switch response.result {
                case .Success(let JSON):
                    print(JSON)
                    self.setCookies(response)
                    self.setUserData(JSON as! NSDictionary)
                    completion(error: error)  
                    }

                case .Failure(let error):
                    completion(error: error)
                }
        }
    }

func logout() {
        Alamofire.Manager.sharedInstance.session.resetWithCompletionHandler { () -> Void in
            print("Resetted")
        }
    }

private func setCookies(response: Alamofire.Response<AnyObject, NSError>) {
        if let
            headerFields = response.response?.allHeaderFields as? [String: String],
            URL = response.request?.URL
        {
            let cookies = NSHTTPCookie.cookiesWithResponseHeaderFields(headerFields, forURL: URL)
            Alamofire.Manager.sharedInstance.session.configuration.HTTPCookieStorage?.setCookies(cookies, forURL: response.response!.URL!, mainDocumentURL: nil)
        }
    }
```
  I am using the latest Alamofire and have problem with request response headers. We are changing the access-token each request to the server. 
Unfortunately randomly there is no access-token inside allHeaderFields.

let headers = ["uid": "(reqUid)", "client": "(reqClient)", "access-token": "(reqToken)"]

Alamofire.request(.GET, postsEndpoint, encoding: .JSON, parameters: nil, headers: headers)
                .responseJSON {response in ...

inside  response.response!. allHeaderFields  
sometimes there is no access-token property but it should be every time. We have checked the server side and the access-token is always sent properly back to the app.

Any ideas / fixes ? Please help.
 Hi.

Thank you for the reply.
Thats some information that clear some ways - thank you. According to your
question - our server team changes the accesToken each time we make a
request so thats why i have to read from response headers.

Thanks for you suggestions
Regards Chris

2016-04-21 16:30 GMT+02:00 Christian Noon notifications@github.com:

> Hi @keisyrzk https://github.com/keisyrzk,
> 
> Are the headers missing when using curl @keisyrzk
> https://github.com/keisyrzk? That's the only thing we can really
> suggest to try to help out here. Alamofire does not handle building the
> allHeaderFields
> https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSHTTPURLResponse_Class/#//apple_ref/occ/instp/NSHTTPURLResponse/allHeaderFields
> dictionary in the response. That's all handled internally by Apple's APIs.
> 
> The only thing we can really do here is suggest you try to reproduce the
> issue with curl and try to get the results to your server team.
> Additionally, you could consider why your needing to extract that header in
> the first place. Aren't you sending up the accessToken already? Why do you
> need to check the header in the response?
> 
> Best of luck! üçª
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly or view it on GitHub
> https://github.com/Alamofire/Alamofire/issues/1192#issuecomment-212943578
 Hi @cnoon

We use [devise_token_auth](https://github.com/lynndylanhurley/devise_token_auth) in our project. The default policy is to change tokens in HTTP headers with every request. The library is not widely used but it was tested. The headers are definitely not missing.

The `access-token` is changed with every successful request as outlined in the library. You need to extract the header value to make another request. As this is currently not possible we changed the default settings NOT to change the token on every single request. Is it absolutely not possible to read the value from the HTTP response?
 @cnoon our backend uses [devise_token_auth](https://github.com/lynndylanhurley/devise_token_auth) to provide clients with token authentication while @keisyrzk is working on an iOS client and he is trying to connect to the aforementioned backend using Alamofire.
 Facing the exact same issue. @keisyrzk did you ever find a solution?
@jshier Which delegate method should i exactly inspect to see the headers? I skimmed the classes, but couldn't find the correct method.  Hi!

I made an installation using Podfile, then I open the project through .xcworkspace file and tried to build the project, but received these error messages:

![captura de tela 2016-04-17 as 01 00 24](https://cloud.githubusercontent.com/assets/3158966/14585014/3d690f48-0439-11e6-8210-d190ec5ca6fb.png)

For more information:

*\* My version Swift:*\* Apple Swift version 2.1.1 (swiftlang-700.1.101.15 clang-700.1.81)
Target: x86_64-apple-darwin15.2.0

**Pod version:** 0.39.0

**Target:** iOS 8+
 Having the same issue after a pod install upgraded Alamofire to 3.3.1
  Xcode 7.3 to update the message I have deprecated functions, setting the language swift to version 3, the libraries will be updated soon or manually update functions?

<img width="372" alt="alamofire issue" src="https://cloud.githubusercontent.com/assets/9319430/14571176/2d781fe6-031e-11e6-8e04-365c91b921f0.png">
  Hello everybody. I was wondering what where the reasons to make such classes as UploadTaskDelegate, DataTaskDelegate and DownloadTaskDelegate internal? They have a bunch of closure-typed properties that, if exposed, would allow to easily add different handlers for NSURLSessionTaskDelegate methods for each individual Request.
    This addresses the issue that the `Request.authenticate` function can‚Äôt be used to authenticate on servers that don‚Äôt send an authentication challenge.

This new function is roughly the equivalent of AFNetworking‚Äôs -[AFHTTPRequestSerializer setAuthorizationHeaderFieldWithUsername:password:]

Related to #1159.
     Uh huh. I haven't tried to read the code thoroughly, and wasn't sure whether to add that line or remove the failing assertion üòÖ 

Thanks for the response, @cnoon !
  If a header is overridden in a request a debugPrint will show both versions and it isn't clear whether the overwriting actually works.

e.g. if I set "Accept-language" to "en-us" in my NSURLRequest and then do a startDataRequest and do a debugPrint on the Request I get back I see:
...
    -H "Accept-Language: en-us" \
    -H "Accept-Language: en-US;q=1.0, ar-US;q=0.9, ja-US;q=0.8, pt-US;q=0.7" \
...
 See pull request #1186  
  ![screen shot 2016-04-13 at 3 42 12 am](https://cloud.githubusercontent.com/assets/15179345/14486222/c1c88c5e-0129-11e6-8270-60bd472e8739.png)

A bunch of errors when I try to compile.

![screen shot 2016-04-13 at 3 42 50 am](https://cloud.githubusercontent.com/assets/15179345/14486237/cf9730ce-0129-11e6-9eee-f9ca402cf023.png)
 You need to have at least Xcode 7.3 because Alamofire 3.3 use swift 2.2
 Okay thank you, it works now
  While trying to mock the `request` method, I found that the class collision of `Method` is not allowing this. For example:

``` swift
override func request(method: Method, _ URLString: URLStringConvertible, parameters: [String : AnyObject]?, encoding: ParameterEncoding, headers: [String : String]?) -> Request {

    Request.response.data = response
    Request.response.json = json

    return Request(request: "mock")
  }
```

Fails with `'Method' is ambiguous for type lookup in this context`, but if I try to add the module to `Method` like `Alamofire.Method`, then the function is "different" and the compiler won't let be use the `override` keyword.
 @raulriera  renaming function will solve this issue.
 Hi, @sairamkotha but "Method" is from the iOS standard library in runtime.h. As mentioned in the description, I can't rename the function or add Alamofire.Method to it because otherwise it won't be overriding it
  Getting issue with Almofire version "3.3.1" but its working fine with version "2.0"
 Required plug-in compatibility UUID 0420B86A-AA43-4792-9ED0-6FE0F2B16A13 for plug-in at path '~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/Unity4XC.xcplugin' not present in DVTPlugInCompatibilityUUIDs
*\* BUILD FAILED **
  I am currently writing a function to get the user's avatar after successfully login. 

```
Alamofire.request(.GET, filePath)
     .response { request, response, data, error in
        if error != nil {
            print(error)
        } else {
            let imageData = UIImagePNGRepresentation(UIImage(data: data!)!)
            let documentsURL = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true)[0]
            let pathComponent = "/avatar.png"
            let destination = documentsURL.stringByAppendingString(pathComponent)
            print(response)
            if !(imageData?.writeToFile(destination, atomically: true))! {
                print("not saved")
            } else {
                print("saved")
            }
       }
}
```

The filePath is the images url. No matter how many times that i uploaded a new avatar, it keeps showing the very first one that i have uploaded to the server and saved locally. I saw the image that this above function returned. It is still the first one. And if i used a browser to browse that avatar, it perfectly shows the latest one.

In addition, i checked the access history in nginx server. It only has access history of browser "GET" request. It seemed like the "GET" request of image from phone is not recorded or something else.
  Always when I try to use the request:
`Alamofire.upload(.POST, request, file: fileURL)`

Gives me the error behind without compile:
`Ambiguous reference to member 'upload(_:_:headers:file:)'`

It shows me the same for every Alamofire.upload that I try to use.
Alamofire.request works fine on the project.
 Hey I am using Alamofire 4.0 swift3 i am trying to upload image but i don't know where should i add my authorization token. please help me.

let url = URL(string: "http://......")

```
    Alamofire.upload(
        multipartFormData:
        {
            multipartFormData in
            multipartFormData.append(UIImagePNGRepresentation(self.signatureImgView.image!)!, withName: "signImg", fileName: "picture.png", mimeType: "image/png")

            // Send parameters
```

//                multipartFormData.append((UserDefaults.standard.value(forKey: Email) as! String).data(using: .utf8)!, withName: "email")
                multipartFormData.append("png".data(using: String.Encoding.utf8)!, withName: "type")

```
        },
        to: url!,
        encodingCompletion:
        {
            encodingResult in
            switch encodingResult
            {

            case .success(let upload, _, _):
                upload.responseString { response in
                    debugPrint("SUCCESS RESPONSE: \(response)")
                }
            case .failure(let encodingError):

                print("ERROR RESPONSE: \(encodingError)")

            }
        }
    )

}
```
 Add the headers:

Alamofire.upload(
            .POST,
            "http://someurl.com/apicall",
            headers: headers,
..... Hello,

You can use common method class for API. Here is the link :

http://ashishkakkad.com/2016/03/how-to-create-a-wrapper-for-alamofire-and-swiftyjson-swift-ios/

*Purvi Jani*
iOS Application Developer
Phone: +919998009783 | Skype: purvi.pardypanda

*Pardy Panda Studios*
LinkedIn <http://linkedin.com/company/pardy-panda-studios> | Facebook
<http://facebook.com/pardypandastudios> | Twitter
<http://twitter.com/pardypanda> | Youtube <http://youtube.com/pardypanda>

On Tue, Jan 31, 2017 at 10:05 AM, Jeremy Snow <notifications@github.com>
wrote:

> This really seems like a bug either in documentation or in the library
> itself. By just following the example code in the docs I and several others
> are running into the same issue. A rather poor user experience in my humble
> opinion.
>
> ‚Äî
> You are receiving this because you commented.
> Reply to this email directly, view it on GitHub
> <https://github.com/Alamofire/Alamofire/issues/1177#issuecomment-276272967>,
> or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AVm5Jfa_zcR5SrJ2FG0OB0th0nfKdOhuks5rXroEgaJpZM4IE6ec>
> .
>

-- 
This email and any files transmitted with it are confidential and intended 
solely for the use of the individual or entity to whom they are addressed. Any 
views or opinions expressed are solely those of the sender and do not 
necessarily represent those of Pardy Panda Studios. If you have received 
this email in error please notify the sender.
 I have use the following code & it works perfectly fine but make sure the
size of image from server side as well.

 func CallAPIForPANCard()

    {



        let imageData1 = UIImageJPEGRepresentation(resizeImage(image:
seguePANCardFrontImage!), 0)

        let imageData2 = UIImageJPEGRepresentation(resizeImage(image: self.
pancardSelfImgview.image!), 0)





        let defaultHTTPHeaders: HTTPHeaders =

            [

            "token": "Your Token"

        ]



        let URL2 = try! URLRequest(url: "https:// .....Your URL", method:
.post, headers: defaultHTTPHeaders)





        Alamofire.upload(multipartFormData: { (multipartFormData) in



            multipartFormData.append(imageData1!, withName: "pan_img",
fileName: "PanCard.jpg", mimeType: "image/jpg")

            multipartFormData.append(imageData2!, withName: "pan_selfie_img",
fileName: "PanCardWithSelfImage.jpg", mimeType: "image/jpg")

            }, with: URL2, encodingCompletion: { (result) in



                switch result {

                case .success(let upload, _, _):



                    upload.responseJSON

                        {

                            response in



                            print(response.request!)  // original URL
request

                            print(response.response!) // URL response

                            print(response.data!)     // server data

                            print(response.result)   // result of response
serialization



                            if response.result.value != nil

                            {



                                let resJson = JSON(response.result.value!)

                                print(resJson)



                                //

                                let message = resJson.dictionary?["Message"
]?.description

                                print(message!)





                                if(message == "Success")

                                {


self.navigationController?.popViewController(animated:
true)


self.navigationController?.popViewController(animated:
true)



                                }



                            }

                    }



                case .failure(let encodingError):

                    print(encodingError)



                }



        })

    }

*Purvi Jani*
iOS Application Developer
Phone: +919998009783 | Skype: purvi.pardypanda

*Pardy Panda Studios*
LinkedIn <http://linkedin.com/company/pardy-panda-studios> | Facebook
<http://facebook.com/pardypandastudios> | Twitter
<http://twitter.com/pardypanda> | Youtube <http://youtube.com/pardypanda>

On Tue, Jan 31, 2017 at 10:19 AM, Purvi Jani <purvi@pardypanda.com> wrote:

> Hello,
>
> You can use common method class for API. Here is the link :
>
> http://ashishkakkad.com/2016/03/how-to-create-a-wrapper-
> for-alamofire-and-swiftyjson-swift-ios/
>
> *Purvi Jani*
> iOS Application Developer
> Phone: +919998009783 | Skype: purvi.pardypanda
>
> *Pardy Panda Studios*
> LinkedIn <http://linkedin.com/company/pardy-panda-studios> | Facebook
> <http://facebook.com/pardypandastudios> | Twitter
> <http://twitter.com/pardypanda> | Youtube <http://youtube.com/pardypanda>
>
> On Tue, Jan 31, 2017 at 10:05 AM, Jeremy Snow <notifications@github.com>
> wrote:
>
>> This really seems like a bug either in documentation or in the library
>> itself. By just following the example code in the docs I and several others
>> are running into the same issue. A rather poor user experience in my humble
>> opinion.
>>
>> ‚Äî
>> You are receiving this because you commented.
>> Reply to this email directly, view it on GitHub
>> <https://github.com/Alamofire/Alamofire/issues/1177#issuecomment-276272967>,
>> or mute the thread
>> <https://github.com/notifications/unsubscribe-auth/AVm5Jfa_zcR5SrJ2FG0OB0th0nfKdOhuks5rXroEgaJpZM4IE6ec>
>> .
>>
>
>

-- 
This email and any files transmitted with it are confidential and intended 
solely for the use of the individual or entity to whom they are addressed. Any 
views or opinions expressed are solely those of the sender and do not 
necessarily represent those of Pardy Panda Studios. If you have received 
this email in error please notify the sender.
  Hi guys,

Is there an issue for caching on 8.x ?

this: 

```
public func URLSession(
            session: NSURLSession,
            dataTask: NSURLSessionDataTask,
            willCacheResponse proposedResponse: NSCachedURLResponse,
            completionHandler: ((NSCachedURLResponse?) -> Void))
        {
            if let dataTaskWillCacheResponse = dataTaskWillCacheResponse {
                completionHandler(dataTaskWillCacheResponse(session, dataTask, proposedResponse))
            } else if let delegate = self[dataTask] as? Request.DataTaskDelegate {
                delegate.URLSession(
                    session,
                    dataTask: dataTask,
                    willCacheResponse: proposedResponse,
                    completionHandler: completionHandler
                )
            } else {
                completionHandler(proposedResponse)
            }
        }
```

is never called in iOS 8.X but it's is in iOS 9.X...i have nothing in my code to differentiate iOS 8 and 9 (maybe that's the issue)

I'm currently on Alamofire 3.2.1 maybe the 3.3 fixed the issue but i didn't to go to swift 2.2 right now..

Thanks for future answers
 Sure but do you have any idea how i can demonstrate the issue ?
I dont have any error in the logs, it's just that the cache worked on iOS 9 and not iOS 8 

i can post you some of the code we are using:
Our service class:

```
import Foundation
import Alamofire

class MyCCHTTPService: NSObject {

    var manager : Manager?

    var cachePolicy : NSURLRequestCachePolicy = .UseProtocolCachePolicy

    var cacheDuration : NSTimeInterval = 24*60*60

    var timeOut : NSTimeInterval = 30

    var debugMode : Bool = false

    override init(){
        super.init()
        self.manager = Manager(configuration: urlSessionConfiguration())
        self.manager?.delegate.dataTaskWillCacheResponse = {
            (urlSession : NSURLSession, dataTask : NSURLSessionDataTask, cachedResponse : NSCachedURLResponse) -> NSCachedURLResponse in

            let response = cachedResponse.response as! NSHTTPURLResponse
            var headers = response.allHeaderFields as! [String : String]

            headers.removeValueForKey("Expires")
            headers.removeValueForKey("s-maxage")
            headers["Cache-Control"] = String(format: "max-age=%li",self.cacheDuration)

            let modifiedResponse = NSHTTPURLResponse(
                URL: response.URL!,
                statusCode: response.statusCode,
                HTTPVersion: "HTTP/1.1",
                headerFields: headers)

            let modifiedCachedResponse = NSCachedURLResponse(
                response: modifiedResponse!,
                data: cachedResponse.data,
                userInfo: cachedResponse.userInfo,
                storagePolicy: cachedResponse.storagePolicy)

            return modifiedCachedResponse
        }
    }

    private func urlSessionConfiguration() -> NSURLSessionConfiguration{
        let urlSessionConfiguration = NSURLSessionConfiguration.defaultSessionConfiguration()
        urlSessionConfiguration.requestCachePolicy = cachePolicy
        urlSessionConfiguration.timeoutIntervalForResource = timeOut
        urlSessionConfiguration.timeoutIntervalForRequest = timeOut
        return urlSessionConfiguration
    }

    func logOperation<T>(response : Response<T,NSError>){
        if(self.debugMode){
            print(response.debugDescription)
        }
    }
}
```

Our router class:

```
import Alamofire
import Foundation


enum CMSRouter: URLRequestConvertible {
    static let hostURL = NSURL(string: NSUserDefaults.standardUserDefaults().objectForKey(NSUserDefaults.SettingsKeys.CMS, forceLoadSettings: true) as! String)!

    static let baseURL = NSURL(string: "/base/url",relativeToURL: hostURL)


    var URL : NSURL { return CMSRouter.baseURL!.URLByAppendingPathComponent(route.path) }


    // Router Cases
    case ActiveStores
    case EmailDomain
    case Languages(String)
    case FieldControlDisplay(String)
    case Texts(String,String)
    case Titles(String,String)
    case Countries(String,String)
    case Nationalities(String,String)
    case AddressFieldsOrder(String,String)
    case ClientType

    // MARK: Route from cases

    var route : (path: String, parameters: [String: AnyObject]?) {
        switch self{
        case .ActiveStores:
            return ("/api1",nil)
        case .EmailDomain:
            return ("/api2",nil)
        case .Languages(let zoneCode):
            return ("/api3/\(zoneCode)",nil)
        case .FieldControlDisplay(let zoneCode):
            return ("/api4/\(zoneCode)",nil)
        case .Texts(let zoneCode, let lang):
            return ("/api5/\(zoneCode)/\(lang)",nil)
        case .Titles(let zoneCode, let lang):
            return ("/api6/\(zoneCode)/\(lang)",nil)
        case .Countries(let zoneCode, let lang):
            return ("/api7/\(zoneCode)/\(lang)",nil)
        case .Nationalities(let zoneCode, let lang):
            return ("/api8/\(zoneCode)/\(lang)",nil)
        case .AddressFieldsOrder(let zoneCode, let lang):
            return ("/api9/\(zoneCode)/\(lang)",nil)
        case .ClientType:
            return ("/api10/",nil)

        }

    }

    var URLRequest: NSMutableURLRequest {
        return
            Alamofire
                .ParameterEncoding
                .URL
                .encode(NSURLRequest(URL: URL), parameters: route.parameters).0
    }
}
```

And the service child which implement the functions we are calling:

```
import Foundation
import Alamofire

class MyCCCMSHTTPService: MyCCHTTPService, MyCCCMSService {

    // MARK: configuration/stores/active
    func fetchStoresActive(completionHandler : CountryStores -> Void, failureHandler : NSError -> Void) -> Void{
        self.manager!.request(CMSRouter.ActiveStores)
            .responseModelRocketJSON { (response : Response<CountryStores,NSError>) -> Void in
                self.logOperation(response)
                if(response.result.error != nil){
                    failureHandler(response.result.error!)
                }
                else{
                    completionHandler(response.result.value!)
                }
        };
    }
```

so the problem is that self.manager?.delegate.dataTaskWillCacheResponse is never used on iOS8...
I got nothing to specify to use cache, and receiving nothing in the response header. For iOS 9 it's works perfectly :/
 Hello, thanks for the link to tests, really great 

I tried and check a lot with the test to so what the problem was. The test are working great with iOS 8 and 9 so it's not coming from here. So i just the problem is coming from the fact that my response has nothing about cache in the headers
Since i can't touch the server i did a fix by stocking in the NSSharedCache manually the response and it's working ^^
  If you carthage update on the latest version of the 3.3 branch you will get error included:

**\* Building scheme "Alamofire iOS" in Alamofire.xcworkspace
**\* Building scheme "Alamofire OSX" in Alamofire.xcworkspace
*\* BUILD FAILED **

The following build commands failed:
    CompileSwift normal x86_64 /Carthage/Checkouts/Alamofire/Tests/MultipartFormDataTests.swift
    CompileSwift normal x86_64 /Carthage/Checkouts/Alamofire/Tests/ServerTrustPolicyTests.swift
    CompileSwift normal x86_64 /Carthage/Checkouts/Alamofire/Tests/CacheTests.swift
    CompileSwift normal x86_64 /Carthage/Checkouts/Alamofire/Tests/SessionDelegateTests.swift
    CompileSwiftSources normal x86_64 com.apple.xcode.tools.swift.compiler
(5 failures)
/Carthage/Checkouts/Alamofire/Tests/SessionDelegateTests.swift:23:18: error: module 'Alamofire' was not compiled for testing
/Carthage/Checkouts/Alamofire/Tests/ResultTests.swift:23:18: error: module 'Alamofire' was not compiled for testing
/Carthage/Checkouts/Alamofire/Tests/ManagerTests.swift:23:18: error: module 'Alamofire' was not compiled for testing
/Carthage/Checkouts/Alamofire/Tests/ValidationTests.swift:23:18: error: module 'Alamofire' was not compiled for testing
/Carthage/Checkouts/Alamofire/Tests/NetworkReachabilityManagerTests.swift:23:18: error: module 'Alamofire' was not compiled for testing
/Carthage/Checkouts/Alamofire/Tests/SessionDelegateTests.swift:23:18: error: module 'Alamofire' was not compiled for testing
/Carthage/Checkouts/Alamofire/Tests/ResultTests.swift:23:18: error: module 'Alamofire' was not compiled for testing
/Carthage/Checkouts/Alamofire/Tests/ManagerTests.swift:23:18: error: module 'Alamofire' was not compiled for testing
/Carthage/Checkouts/Alamofire/Tests/ValidationTests.swift:23:18: error: module 'Alamofire' was not compiled for testing
/Carthage/Checkouts/Alamofire/Tests/NetworkReachabilityManagerTests.swift:23:18: error: module 'Alamofire' was not compiled for testing
/Carthage/Checkouts/Alamofire/Tests/SessionDelegateTests.swift:23:18: error: module 'Alamofire' was not compiled for testing
/Carthage/Checkouts/Alamofire/Tests/ResultTests.swift:23:18: error: module 'Alamofire' was not compiled for testing
/Carthage/Checkouts/Alamofire/Tests/ManagerTests.swift:23:18: error: module 'Alamofire' was not compiled for testing
/Carthage/Checkouts/Alamofire/Tests/ValidationTests.swift:23:18: error: module 'Alamofire' was not compiled for testing
/Carthage/Checkouts/Alamofire/Tests/NetworkReachabilityManagerTests.swift:23:18: error: module 'Alamofire' was not compiled for testing
/Carthage/Checkouts/Alamofire/Tests/SessionDelegateTests.swift:23:18: error: module 'Alamofire' was not compiled for testing
/Carthage/Checkouts/Alamofire/Tests/ResultTests.swift:23:18: error: module 'Alamofire' was not compiled for testing
/Carthage/Checkouts/Alamofire/Tests/ManagerTests.swift:23:18: error: module 'Alamofire' was not compiled for testing
/Carthage/Checkouts/Alamofire/Tests/ValidationTests.swift:23:18: error: module 'Alamofire' was not compiled for testing
/Carthage/Checkouts/Alamofire/Tests/NetworkReachabilityManagerTests.swift:23:18: error: module 'Alamofire' was not compiled for testing
  Fixed some minor typos in README.md.
    This looks great to me.
 I'm happy with this too. I agree with @jshier about adding an example of improper usage. Otherwise, great job @cnoon!
  Hi All,
I have installed Alamofire with CocoaPods. The app has any problem if running on Simulator but it makes  this error when I test the app on the iPad device:

dyld: Library not loaded: @rpath/Alamofire.framework/Alamofire
  Referenced from: /var/mobile/Containers/Bundle/Application/xxx/xxx.app/xxx
  Reason: no suitable image found.  Did find:
    /private/var/mobile/Containers/Bundle/Application/xxx/xxx.app/Frameworks/Alamofire.framework/Alamofire: mmap() errno=1 validating first page of '/private/var/mobile/Containers/Bundle/Application/xxx/xxx.app/Frameworks/Alamofire.framework/Alamofire'
    /private/var/mobile/Containers/Bundle/Application/xxx/xxx.app/Frameworks/Alamofire.framework/Alamofire: mmap() errno=1 validating first page of '/private/var/mobile/Containers/Bundle/Application/xxx/xxx.app/Frameworks/Alamofire.framework/Alamofire'
    /private/var/mobile/Containers/Bundle/Application/xxx/xxx.app/Frameworks/Alamofire.framework/Alamofire: mmap() errno=1 validating first page of '/private/var/mobile/Containers/Bundle/Application/xxx/xxx.app/Frameworks/Alamofire.framework/Alamofire'

Could you help me, please?
I using Xcode 7.3
 Nice cnoon, great man!!! Thankssss!!!  I am using Alamofire on a project with API to Client HMAC. My first thought was to use a custom validation to verify the incoming signature against the response and mark the request as `.Success` or `.Failure` depending on how the signature verification went. Something like this:

```
request.validate({ (req, res) -> Request.ValidationResult in
      if hasValidSignature(){
        .Success()
      }else{
        .Failure(someError)
      }
    })
```

However, I noticed that in the `validate` method, there is no access to the `HTTPBody` so I cannot properly generate the expected HMAC signature.

My next attempt was using a custom `ResponseSerializer` which I was able to implement using the example in the readme, however it does not appear that any subsequent chained calls to `.responseJSON()` know that the custom `ResponseSerializer` returned a failure so when I try and switch on the `response.result` it is always `.Success`. This makes sense given how I see most people are using the custom `ResponseSerializers`.

I can think of a few other ways to solve this problem, but I am trying to find the most "Alamofire" way of _sometimes_ validating the signature of a response such that the downstream code making the requests does not need to know anything about signature validation and can simply rely on the `.Success` or `.Failure` of the response.
  This really isn't a bug, but you might want to correct the README.md to indicate that with the changes made as of March 23, 2016 (to Manager.swift in particular). the use of #selector requires Swift 2.2

Swift 2.2 comes with Xcode 7.3, El Capitain.

I ran into this issue since I am still running Yosemite with Swift 2.1.1 and Xcode 7.2.1.  I just thought others might want to know...
Thanks.
 Cool - this is all new to me :)   Thanks so much!
  Hi,

I apologise for asking of help here, but I've spends days trying to get my head around this and I've getting nowhere.

I'd like to user Alamofire to create a background session upload that sends a file in chunks to a server. Each chuck in be in multipart format.

I can't find any details information on how Amalofire handles background sessions. In my particular case this is what I need to handle:

I wish to upload a video file from either my main OSX application, or from an OSX sharing extension.
The server endpoint requires that I send the files in chucks of a given size.
I need to use backgrounds sessions for this, so I'll need session delegates
I don't understand how to use Alomafire with background sessions and session delegates and I can't find any documentation on the subject. 
I'm also not sure if Alamofire helps with the delegate callbacks - does it recreate the tasks? The related code i've seen appear to only refer to iOS9, not OSX.

Thanks,

Tim
 any examples for this?  Hi,

We come across this issue where you won't be able to do this inside a project that has both Alamofire and Result framework:

import Alamofire
import Result

The compiler will start immediately complaining about Result being an ambiguous type.

Is there any reason why Result is not decleared as a dependency? Would it be possible to move it inside the "Alamofire" class, to namespace it?

Thanks a lot!
 @cnoon I understand your concern, but the number of issues people have opened because of exactly the same problem indicates that this is actually a problem of the users of Alamofire.

I've looked through the linked issues, and I understand that Alamofire wouldn't like to:
- Add 3rd party dependency to its projects
- Rename a struct to be something less descriptive

Has it been considered to namespace the Result struct?
All that would take is to move its definition inside the Alamofire class:

```
extension Alamofire {
  struct Result {
   ... definition goes here
  }
}
```

This would avoid both of your original concern, and it would also make it explicit that Alamofire uses its own Result implementation, and not the one that the community is otherwise familiar with.

Unfortunately Swift has its limitations at the moment, and we were promised to abandon namespacing completely, but in real life, it does cause issues. It would be very considerate of you guys if a utility data structure, that many people use in their own projects would be named by keeping these limitations in mind.
  Here‚Äôs a proposition to improve how some errors are handled.
 Ok, `Error.errorWithCode` is deprecated so I should replace it with what?

README should be updated:

> `let error = Error.errorWithCode(.DataSerializationFailed, failureReason: failureReason)`
  I have a request that returns 301 with header `"Location": "another_url_link"` but my `response` block get called without redirection :cry: 

``` swift
request
        .validate()
        .response { request, response, data, error in
   // response contains status code 301 with header containing "Location"
}
```

I configure @cnoon  https://github.com/Alamofire/Alamofire/pull/317 `taskWillPerformHTTPRedirectionWithCompletion` but it does not get called. 
 @cnoon Can you try the following URL.
`http://www.hkpro.com/forum/attachment.php?attachmentid=104674`
It would response a 301 error code, but didn't work with latest Alamofire.
Here is the header of the response.
<img src="https://cloud.githubusercontent.com/assets/1223339/25225320/96920d68-25f3-11e7-9ee2-cb0c6d474d67.png" alt="" width="400">

Do you have any idea?  As defined in RFC 7235 https://tools.ietf.org/html/rfc7235#section-3.1

Fixes #1159
  Hi,
I'm try to use self signed server using Alamofire 3.0. When I use _sessionDidReceiveChallenge_ for _Alamofire.request()_, it works good. But when I try to use _sessionDidReceiveChallenge_  for _Alamofire.upload multipartFormData_, i got a bug: 
`[Result]: FAILURE: Error Domain=NSURLErrorDomain Code=-1206 "The server ‚Äúservername.net‚Äù requires a client certificate." UserInfo={NSUnderlyingError=0x7fc8515f90b0 {Error Domain=kCFErrorDomainCFNetwork Code=-1206 "(null)" UserInfo={NSErrorPeerAddressKey=<CFData 0x7fc85143aab0 [0x10bbe2a40]>{length = 16, capacity = 16, bytes = 0x100201bb1b78530b0000000000000000}}}, NSErrorFailingURLStringKey=https://servername.net/sapi/index.php?control=upload_img_ps&action=upload_img_mobile, NSErrorFailingURLKey=https://servername.net/sapi/index.php?control=upload_img_ps&action=upload_img_mobile, NSLocalizedDescription=The server ‚Äúservername.net‚Äù requires a client certificate.}`

Thank you for creating a awesome library and sorry for my english.
This is my code:

```
    func uploadFile(){

        let manager = Alamofire.Manager.sharedInstance
        manager.delegate.sessionDidReceiveChallenge = { session, challenge in

            let identityAndTrust:IdentityAndTrust = self.extractIdentity();
            let urlCredential:NSURLCredential = NSURLCredential(
                identity: identityAndTrust.identityRef,
                certificates: identityAndTrust.certArray as? [AnyObject],
                persistence: NSURLCredentialPersistence.ForSession);
            return (NSURLSessionAuthChallengeDisposition.UseCredential, urlCredential)

        }

        let params = ["user_id":"1331","user_name":"Tho MNB-NEXT 30","lat":"10.776103","lon":"106.689743","comment":"123","danger_level":"1"]
        let URL = "https://servername.net/sapi/index.php?control=upload_img_ps&action=upload_img_mobile"
        let image = UIImage(named: "blue_dot.png")

        Alamofire.upload(.POST, URL, multipartFormData: {
            multipartFormData in

            if let _image = image {
                if let imageData = UIImageJPEGRepresentation(_image, 0.8) {
                    multipartFormData.appendBodyPart(data: imageData, name: "uploadfile", fileName: "file.png", mimeType: "image/png")
                }
            }

            for (key, value) in params {
                multipartFormData.appendBodyPart(data: value.dataUsingEncoding(NSUTF8StringEncoding)!, name: key)
            }

            }, encodingCompletion: {
                encodingResult in

                switch encodingResult {
                case .Success(let upload, _, _):
                    upload.responseJSON { response in
                        debugPrint(response)
                    }
                case .Failure(let encodingError):
                    print(encodingError)
                }
        })
    }


struct IdentityAndTrust {
        var identityRef:SecIdentityRef
        var trust:SecTrustRef
        var certArray:AnyObject
    }

    func extractIdentity() -> IdentityAndTrust {
        var identityAndTrust:IdentityAndTrust!
        var securityError:OSStatus = errSecSuccess

        let bundle:NSBundle = NSBundle(forClass: self.dynamicType);
        let bundleCertPath:NSString = bundle.pathForResource(Certificate.kPKCS12Data, ofType: "p12")!;
        let PKCS12Data = NSData(contentsOfFile: bundleCertPath as String)!;

        let key : NSString = kSecImportExportPassphrase as NSString
        let options : NSDictionary = [key : Certificate.kCertifier]
        var items : CFArray?

        securityError = SecPKCS12Import(PKCS12Data, options, &items)

        if securityError == errSecSuccess {
            let certItems:CFArray = items as CFArray!;
            let certItemsArray:Array = certItems as Array
            let dict:AnyObject? = certItemsArray.first;
            if let certEntry:Dictionary = dict as? Dictionary<String, AnyObject> {

                // grab the identity
                let identityPointer:AnyObject? = certEntry["identity"];
                let secIdentityRef:SecIdentityRef = identityPointer as! SecIdentityRef!;
                print("\(identityPointer)  :::: \(secIdentityRef)")
                // grab the trust
                let trustPointer:AnyObject? = certEntry["trust"];
                let trustRef:SecTrustRef = trustPointer as! SecTrustRef;
                print("\(trustPointer)  :::: \(trustRef)")
                // grab the cert
                let chainPointer:AnyObject? = certEntry["chain"];
                identityAndTrust = IdentityAndTrust(identityRef: secIdentityRef, trust: trustRef, certArray:  chainPointer!);
            }
        }
        return identityAndTrust;
    }

```
  s there a way to make a request by alamofire in the forground, not the background. I need data from the request, before the code goes on.
  By default, the session delegate executes a delegate block property if it exists
and then stops. If we set delegateBlocksPreventsDefaultDelegation to 'false'
delegation will continue after calling the block (new behavior). 'true' is the
default value, which is the old behavior. The main purpose of this change is to
allow the various session delegate properties to be called with custom logic that 
**also** allows the default behavior to continue after.
See issue:  https://github.com/Alamofire/Alamofire/issues/1145 for discussion.
  I'm following https://github.com/Alamofire/Alamofire/issues/794 tips to write some tests for my code. 

I saw that in Alamofire there is a `URLProtocolTests` class where a `ProxyURLProtocol` (a subclass of `NSURLProtocol`) is defined.

I completely removed the `ProxyURLProtocol` class and the line `configuration.protocolClasses = [ProxyURLProtocol.self]` in the `setUp` method, and the test is still passing. So I'm a bit confused, since I was expecting the test to fail without the custom URL protocol. 

How am I suppose to use `NSURLProtocol`?
 thank you @cnoon now it works :+1: 
  When doing a .GET with authentication, things work fine if I give the right user/pwd.  If I give the incorrect user or pwd with Alamofire 3.2.1, response.response from the responseJSON method is getting nil, and the error being passed to the .Failure enum is -999.

My request manager is NOT going out of scope.  
 I've seen multiple issues here on Github on the 401 status code (when providing bad credentials for example) that are being closed as support questions or as "works as intended". While I agree that cancelling the request is somewhat defendable when authentication doesn't work, the fact that you cannot access the response body is inconvenient.

The HTTP spec suggests that the user agent should be able to use the response body (https://tools.ietf.org/html/rfc7235#section-3.1):

> If the 401 response contains the same challenge as the prior response, and the user agent has already attempted authentication at least once, then the user agent SHOULD present the enclosed representation to the user, since it usually contains relevant diagnostic information.

Currently Alamofire prevents developers from actually accessing this content unless they insert the `Authorization` header manually instead of using the `authenticate` method (at least, that's a workaround I've seen around here but haven't tested myself #1031). For example, a lot of API's return JSON-encoded error messages to present to the user.

Any thoughts?
 I wholeheartedly agree with @tieleman.  There's a big difference between "The request was canceled" and "Your credentials were incorrect"
 @tieleman is right and @grosch was right to report this as a bug. I spent about 3 hours today trying to work out why the request returned "cancelled" instead of a 401 error because I want to display the response body to the user. Please include this in an update!
 I think the main culprit and source of confusion here is the fact that the README lists two separate ways to do HTTP Basic Auth (https://github.com/Alamofire/Alamofire#http-basic-authentication), but it isn't made clear that they will trigger entirely different behaviour:
- One using `authenticate`, which will cancel your request (and thus trigger a failure) without providing any clues as to why this happened and you cannot access the status code or response body.
- One using a manual insertion of the `Authorization` header which will trigger a success (that you can turn into a failure using `validate` if you want) which _does_ give you access to the status code and the response body.

Now, the `authenticate` method is obviously more elegant to use, but using it withholds important information from the developer (and `validate` doesn't work on this as you'd expect). This might just be caused by the fact that using `NSURLCredential` triggers this behaviour and Alamofire can do nothing to prevent that, but it should be made clear (and hence I guess this was labelled as a support question) that this difference in behaviour exists.

@cnoon: If it's not a bug report or a feature request, than at least it's a request for better documentation of this (somewhat unexpected) behaviour. üëæ
 Thanks for reopening. I have reviewed the two linked AFN issues, and while there are some similarities, I do believe that they cater to a different class of problems (cert or key pinning failures). These are typical examples of errors that occur early at the secure transport level, while the issue with 401's (and other HTTP status codes) resides at the application level after the server has attempted to process the request.

There's also a slight discrepancy between the described behaviour of Alamofire in the docs and what actually happens when you insert the `authenticate` method. The docs state:

> By default, Alamofire treats any completed request to be successful, regardless of the content of the response. Calling validate before a response handler causes an error to be generated if the response had an unacceptable status code or MIME type.

Using `authenticate` breaks this default (without warning) and renders `validate` unusable. Therefore, it makes sense (to me) to have cert and key failures trigger a failure (because the request is denied before it is even processed on the application server), but have 401's and other faulty status codes trigger a success (as is the default per the docs) and the ability to force that into a failure with `validate`.

In other words: `authenticate` should simply insert credentials into the request but not change the default behaviour. Pinning certificates that fail validation should of course trigger a failure/cancellation.

Does that make sense in this context?
  I changed the .authenticate(user:password:) parameters in my source code from valid to completely invalid credentials and reran the app.  The app continues to get data from the webserver with those invalid credentials.

I then did a debugPrint() of the request and ran the curl command shown from Terminal, and the connection properly failed with a 401 saying authorization was required. 

How do I ensure that _only_ the user/pwd that is sent through the authenticate method is used when making connections?
 Sorry, this is Alamofire 3.2.1, and I'm using the Alamofire.request(.GET, "", parameters:) method, which then chains to a .authenticate
  Our download progress calculation have been broken after ios 9.3 update. The parameter totalBytesExpected is always -1, however the server returns response with correct expectedContentLength. Some investigations led me to the point of setting  
 dataProgress?(
                    bytesReceived: Int64(data.length),
                    totalBytesReceived: totalBytesReceived,
                    totalBytesExpectedToReceive: totalBytesExpected
                )

can you pls investigate?
 @cnoon @nickkhod 

The expected content length is always -1 for me! Why do you think that is? Below is my response. As you can see, the "Content-Length" header is present.

```
(lldb) po downloadTask.response
‚ñø Optional<NSURLResponse>
  - Some : <NSHTTPURLResponse: 0x7fbf8ee5daa0> { URL: https://v4-dev.getsigneasy.com/v4/files/original/3130118/download } { status code: 200, headers {
    "Access-Control-Allow-Credentials" = true;
    "Access-Control-Allow-Headers" = "Accept,Authorization,Cache-Control,Content-Type,DNT,If-Modified-Since,Keep-Alive,Origin,User-Agent,X-Mx-ReqToken,X-Requested-With";
    "Access-Control-Allow-Methods" = "GET, POST, PUT, DELETE, OPTIONS";
    "Access-Control-Allow-Origin" = "*";
    "Access-Control-Expose-Headers" = "Content-Disposition, Content-Length";
    "Cache-Control" = "public, max-age=43200";
    Connection = "keep-alive";
    "Content-Encoding" = gzip;
    "Content-Length" = 59274;
    "Content-Type" = "application/pdf";
    Date = "Mon, 19 Sep 2016 07:04:54 GMT";
    Etag = "\"flask-1444909447.0-129511-4246673535\"";
    Expires = "Mon, 19 Sep 2016 19:04:54 GMT";
    "Last-Modified" = "Thu, 15 Oct 2015 11:44:07 GMT";
    Server = "nginx/1.4.6 (Ubuntu)";
    Vary = "Accept-Encoding";
} }

```

```
(lldb) po downloadTask.response?.expectedContentLength
‚ñø Optional<Int64>
  - Some : -1

```
 @cnoon @nickkhod Any help?
 Check http headers and request to make sure everything is equal in your requests from the device and postman
 The response shows content-Length, thats all that is required for expectedContentlength right? 
  Here in this example:

``` swift
let URL = MY_URL
let parameters = [:]
let headers    = SharedItemResources.addAuthenticationTokenToHeader()

Alamofire.request(.GET, URL, parameters: parameters, encoding: .JSON, headers: headers).validate().responseJSON { response in
    switch response.result {
            case .Success:
        // Success
            case .Failure:
        // Failure
    }
}
```

I am adding `encoding: .JSON` whereas I am not passing any parameters. It used to work in the previous version (3.1.4) but I just did a `pod install` and now (version 3.3.0) it sends a `FAILURE` without any information. Here's the response object in XCode:

<img width="498" alt="screen shot 2016-03-31 at 13 50 28" src="https://cloud.githubusercontent.com/assets/3611896/14174880/a122e120-f747-11e5-975b-6c102c7f82c6.png">

I tried everything I could but it seems like it is an internal error,

Cheers
  # I am trying to update Alamofire for carthage but it is failing repeatedly. Please help

> The following build commands failed:
>   CompileSwift normal x86_64 <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Timeline.swift
>   CompileSwift normal x86_64 <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Upload.swift
>   CompileSwift normal x86_64 <Project DIrectory>Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift
>   CompileSwift normal x86_64 <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Request.swift
>   CompileSwiftSources normal x86_64 com.apple.xcode.tools.swift.compiler
> (5 failures)
> 
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Request.swift:487:17: error: expected expression in list of expressions
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Request.swift:486:51: error: expected ',' separator
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Request.swift:487:17: error: expected ')' in expression list
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Request.swift:487:25: error: expected identifier in protocol declaration
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift:32:5: error: expected declaration
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:734:32: error: expected expression after operator
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:734:117: error: braced block of statements is an unused closure
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:740:18: error: expected pattern
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:740:18: error: expected ':' after 'case'
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:740:18: error: expected expression
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:742:18: error: expected pattern
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:742:18: error: expected ':' after 'case'
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:742:18: error: expected expression
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:744:18: error: expected pattern
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:744:18: error: expected ':' after 'case'
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:744:18: error: expected expression
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:746:18: error: expected pattern
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:746:18: error: expected ':' after 'case'
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:746:18: error: expected expression
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Request.swift:487:17: error: expected expression in list of expressions
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Request.swift:486:51: error: expected ',' separator
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Request.swift:487:17: error: expected ')' in expression list
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Request.swift:487:25: error: expected identifier in protocol declaration
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift:32:5: error: expected declaration
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:734:32: error: expected expression after operator
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:734:117: error: braced block of statements is an unused closure
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:740:18: error: expected pattern
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:740:18: error: expected ':' after 'case'
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:740:18: error: expected expression
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:742:18: error: expected pattern
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:742:18: error: expected ':' after 'case'
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:742:18: error: expected expression
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:744:18: error: expected pattern
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:744:18: error: expected ':' after 'case'
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:744:18: error: expected expression
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:746:18: error: expected pattern
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:746:18: error: expected ':' after 'case'
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:746:18: error: expected expression
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Request.swift:487:17: error: expected expression in list of expressions
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Request.swift:486:51: error: expected ',' separator
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Request.swift:487:17: error: expected ')' in expression list
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Request.swift:487:25: error: expected identifier in protocol declaration
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift:32:5: error: expected declaration
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:734:32: error: expected expression after operator
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:734:117: error: braced block of statements is an unused closure
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:740:18: error: expected pattern
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:740:18: error: expected ':' after 'case'
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:740:18: error: expected expression
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:742:18: error: expected pattern
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:742:18: error: expected ':' after 'case'
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:742:18: error: expected expression
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:744:18: error: expected pattern
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:744:18: error: expected ':' after 'case'
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:744:18: error: expected expression
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:746:18: error: expected pattern
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:746:18: error: expected ':' after 'case'
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:746:18: error: expected expression
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Request.swift:487:17: error: expected expression in list of expressions
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Request.swift:486:51: error: expected ',' separator
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Request.swift:487:17: error: expected ')' in expression list
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Request.swift:487:25: error: expected identifier in protocol declaration
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift:32:5: error: expected declaration
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:734:32: error: expected expression after operator
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:734:117: error: braced block of statements is an unused closure
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:740:18: error: expected pattern
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:740:18: error: expected ':' after 'case'
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:740:18: error: expected expression
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:742:18: error: expected pattern
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:742:18: error: expected ':' after 'case'
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:742:18: error: expected expression
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:744:18: error: expected pattern
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:744:18: error: expected ':' after 'case'
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:744:18: error: expected expression
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:746:18: error: expected pattern
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:746:18: error: expected ':' after 'case'
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Manager.swift:746:18: error: expected expression
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift:111:39: error: 'SerializedObject' is not a member type of 'T'
> <Project DIrectory>Carthage/Checkouts/Alamofire/Source/Request.swift:484:55: error: missing argument for parameter 'protocol' in call
> A shell task failed with exit code 65:
> *\* BUILD FAILED **
 I'm having the same problem
 what version of Xcode are you guys using?
 Using Xcode 7.2
I got lot of error  in Manager.swift when i used this:
pod 'Alamofire', '~> 3.3'
So i replaced it with:
pod 'Alamofire' , '2.0.2'
And all fixed
:)
 Is there a reason why version 3 is not backwards compatible? I would have assumed pods not be the problem. 
  Hello,

I'm trying to use Alamofire with Server Sent Events, and unfortunately, it seems that the `stream` API retrieves chunks not synchronized with the events. In fact, when the size of events is too big, or when the events are too fast, some chunks can contain only parts of an event, or sometimes even multiple parts of different events.

Is there a way to have a closure returning each event, or do we have to implement it ourself?

Thanks in advance.
 Ok thanks, I'm working on something limited to my narrow usage of sse, but I'll share it when it's ready if you wish.
  My code starts failing when I install alamofire from pod, there are compilation issue with new version. I am not sure if some new settings need to be done for v 3.3.0. However same project build fine with older version 3.2.1
 I believe the problem had already been mentioned here: https://github.com/Alamofire/Alamofire/issues/1137

The solution was to use XCode 7.3 to build Alamofire 3.3.0
   My issue is alamofire.request does not contain .responseObject object
My error code is ,
   Alamofire.request(.POST, baseURL, parameters: emptyString , encoding: .JSON, headers: nil).responseObject { (response: Mapper?, error: ErrorType?) -> Void in
            completionHandler(model: response, error: error)
  After I install by CocoaPods, then open workspace i had this compile error:
Help me please!
![screen shot 2016-03-30 at 2 07 17 pm](https://cloud.githubusercontent.com/assets/10986151/14134391/2c078bdc-f681-11e5-9bf5-5f87b2c85ef5.png)
 You need to upgrade your XCode, this is the latest swift 2.2 convention

On Wed, Mar 30, 2016 at 12:10 AM, B·∫°n Nguy·ªÖn Ng·ªçc notifications@github.com
wrote:

> After I install by CocoaPods, then open workspace i had this compile error:
> Help me please!
> [image: screen shot 2016-03-30 at 2 07 17 pm]
> https://cloud.githubusercontent.com/assets/10986151/14134391/2c078bdc-f681-11e5-9bf5-5f87b2c85ef5.png
> 
> ‚Äî
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly or view it on GitHub
> https://github.com/Alamofire/Alamofire/issues/1149

## 

http://grou.ps
 Thanks you @esokullu  :+1: 
  Xcode 7.2
In my Cartfile:

`github "Alamofire/Alamofire" ~> 3.0`

After I ran carthage update, I met this:

```
2016-03-30 10:35:00.517 xcodebuild[3025:42805] [MT] PluginLoading: Required plug-in compatibility UUID F41BD31E-2683-44B8-AE7F-5F09E919790E for plug-in at path '~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/VVDocumenter-Xcode.xcplugin' not present in DVTPlugInCompatibilityUUIDs
** BUILD FAILED **

The following build commands failed:
    CompileSwift normal armv7k /Users/linsw/Desktop/MongoDBPlayground/Carthage/Checkouts/Alamofire/Source/Timeline.swift
    CompileSwift normal armv7k /Users/linsw/Desktop/MongoDBPlayground/Carthage/Checkouts/Alamofire/Source/NetworkReachabilityManager.swift
    CompileSwift normal armv7k /Users/linsw/Desktop/MongoDBPlayground/Carthage/Checkouts/Alamofire/Source/Upload.swift
    CompileSwift normal armv7k /Users/linsw/Desktop/MongoDBPlayground/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift
    CompileSwiftSources normal armv7k com.apple.xcode.tools.swift.compiler
(5 failures)

```

How can I deal with it?
  Hi!

While asynchronous calls are indeed a great feature of Alamofire, it is only sufficient if one would like to delegate the job of doing asynchronous calls to it or would like to directly start network calls from ViewControllers.

In a multi-layered architecture however where all business logic is done asynchronously from the point where a user-triggered event leaves the UI, it only complicate things. For example I would like to use RxSwift to handle all my business logic in a separate thread and retreive business entites using the Repository pattern, where the cloud storage (that basically means API calls) is a Repository itself which is called when the requested data is not found locally (in the database, which is another Repository). The fact that Alamofire only allows asynchronous calls makes it impossible to implement this without much pain.

**Would you please consider addign a way to make request synchronously with Alamofire?**

I do think it would be useful in many complex applications. You could of course emphasize in the docs that the recommended way is to call Alamofire asynchronously, and one should only call it synchronously if he or she implement asynchronity manually.
 Hi @cnoon!

Thank you for your response. I fully understand your reasoning and this queue parameter seems to be a good solution in my usecase, I'll try it out!
 Something that might be useful then, is an example showing how to use the queue parameter to make synchronous calls.

The problem with this design in my opinion is that it makes you design your whole call chain to be callback-based.
I believe it is much better to handle this at the bottom level.

Also, since this might be a common request, maybe it is preferable to expose such api instead of having users implement it from scratch every time - maybe even put it in a different module so people won't confuse the two

P.S. Would love to get an example of how to make this synchronous :)
 Synchronous JSON request.
But I would not recommend this to use because you cannot cancel the request.

``` swift
extension Alamofire.Manager {

    func syncRequest(URLRequest: URLRequestConvertible) -> Response<AnyObject, NSError> {

        var outResponse: Response<AnyObject, NSError>!
        let semaphore: dispatch_semaphore_t! = dispatch_semaphore_create(0)

        self.request(URLRequest).responseJSON { (response: Response<AnyObject, NSError>) -> Void in

            outResponse = response
            dispatch_semaphore_signal(semaphore)
        }
        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);

        return outResponse
    }
}
```
 Thank you @Alexander-Ignition !!
 how to use this extension???please give me a demo.
 It would be a amazing feature. I really need this.
 @Alexander-Ignition Aside from some syntax upgrades (`DispatchSemaphore` is a thing now), this does not always work for me. If the Alamofire [request uses the main thread, we get a deadlock](http://stackoverflow.com/q/42644111/539599). While there is a workaround for XCTest, what to do about Swift scripts?

I second this request. An easy way to make Alamofire work synchronously is needed. Not for production use in apps, but for testing and scripting. @reitzig for testing it is better to use XCTestExpectation

for scripts you can try this, but this example does not support `RequestRetrier`
```swift
extension SessionManager {
    
    func syncRequest(_ urlRequest: URLRequestConvertible) -> DataResponse<Any> {
        
        let request: DataRequest = self.request(urlRequest)
        var outResponse: DataResponse<Any>!
        
        request.responseJSON { (dataResponse: DataResponse<Any>) in
            outResponse = dataResponse
        }
        
        let task = request.dataDelegate.dataTask
        let timeout = Date(timeIntervalSinceNow: request.request?.timeoutInterval ?? 10)
        while task.state == .running && !RunLoop.current.run(mode: .defaultRunLoopMode, before: timeout) {
        }
        
        return outResponse
    }
}
```  MacBook-Pro:Diary nader$ pod install
Analyzing dependencies
Pre-downloading: `AsyncSwift` from `https://github.com/100mango/Async.git`, branch `master`
Pre-downloading: `ExSwift` from `https://github.com/ayn/ExSwift.git`, branch `Swift-2.0`
Pre-downloading: `SwiftCharts` from `https://github.com/i-schuetz/SwiftCharts.git`
Downloading dependencies
Installing Alamofire (3.3.0)
Installing AlamofireImage (2.4.0)
Installing AsyncSwift (1.7.2)
Installing Dodo (2.0.13)
Installing Eureka (1.5.0)
Installing ExSwift (0.1.9)
Installing ObjectMapper (1.2.0)
Installing Realm (0.98.6)
Installing RealmGeoQueries (1.1)
Installing RealmSwift (0.98.6)
Installing SnapKit (0.15.0)
Installing SwiftCharts (0.3)
Installing SwiftDate (2.0.2)
Installing SwiftyJSON (2.3.2)
Installing Watchdog (2.0)
Generating Pods project
Integrating client project
Sending stats
Pod installation complete! There are 14 dependencies from the Podfile and 15 total pods installed.
MacBook-Pro:Diary nader$ pod update
Update all pods
Updating local specs repositories
Analyzing dependencies
Pre-downloading: `AsyncSwift` from `https://github.com/100mango/Async.git`, branch `master`
Pre-downloading: `ExSwift` from `https://github.com/ayn/ExSwift.git`, branch `Swift-2.0`
Pre-downloading: `SwiftCharts` from `https://github.com/i-schuetz/SwiftCharts.git`
Downloading dependencies
Using Alamofire (3.3.0)
Using AlamofireImage (2.4.0)
Installing AsyncSwift 1.7.2 (was 1.7.2)
Using Dodo (2.0.13)
Using Eureka (1.5.0)
Installing ExSwift 0.1.9 (was 0.1.9)
Using ObjectMapper (1.2.0)
Using Realm (0.98.6)
Using RealmGeoQueries (1.1)
Using RealmSwift (0.98.6)
Using SnapKit (0.15.0)
Installing SwiftCharts 0.3 (was 0.3)
Using SwiftDate (2.0.2)
Using SwiftyJSON (2.3.2)
Using Watchdog (2.0)
Generating Pods project
Integrating client project
Sending stats
Pod installation complete! There are 14 dependencies from the Podfile and 15 total pods installed.

dyld: Library not loaded: @rpath/Alamofire.framework/Alamofire
  Referenced from: /var/containers/Bundle/Application/AB5A3CA6-5BD7-476C-A081-6058196CC7CE/Diary.app/Diary
  Reason: no suitable image found.  Did find:
    /private/var/containers/Bundle/Application/AB5A3CA6-5BD7-476C-A081-6058196CC7CE/Diary.app/Frameworks/Alamofire.framework/Alamofire: mmap() errno=1 validating first page of '/private/var/containers/Bundle/Application/AB5A3CA6-5BD7-476C-A081-6058196CC7CE/Diary.app/Frameworks/Alamofire.framework/Alamofire'
    /private/var/containers/Bundle/Application/AB5A3CA6-5BD7-476C-A081-6058196CC7CE/Diary.app/Frameworks/Alamofire.framework/Alamofire: mmap() errno=1 validating first page of '/private/var/containers/Bundle/Application/AB5A3CA6-5BD7-476C-A081-6058196CC7CE/Diary.app/Frameworks/Alamofire.framework/Alamofire'
    /private/var/containers/Bundle/Application/AB5A3CA6-5BD7-476C-A081-6058196CC7CE/Diary.app/Frameworks/Alamofire.framework/Alamofire: mmap() errno=1 validating first page of '/private/var/containers/Bundle/Application/AB5A3CA6-5BD7-476C-A081-6058196CC7CE/Diary.app/Frameworks/Alamofire.framework/Alamofire'
  By default, the session delegate executes a delegate block property if it exists and then stops. I would like to be able to set various delegate closure properties that get executed but also continue with default handling. I need to be notified of a few methods being called (along with their args), but I want the default behavior to continue. I have a PR on a forked Alamofire open: https://github.com/taquitos/Alamofire/pull/1/files

I'm open to suggestions on how to accomplish, or make it better. I know that it isn't perfect as we can't add this feature to every delegate callback (because some require completion blocks to be called as part of the delegate callback), but I think keeping clear documentation and comments is the best solution.

Note: I didn't include unit tests yet as I'd like to make sure this approach is something people agree on before I invest the time. Also note that It seems like there are no tests that ensure the block properties are called in the SessionDelegate yet.
 Anyway we can discuss this suggestion?
 I love this idea. 
 @cnoon I don't have any problem with this in general, but we did discuss something similar in #1099 and decided against it. These were your words:

> An alternative approach to this PR would be to remove the `final` modifier from the `SessionDelegate` declaration. This would allow users to subclass the `SessionDelegate` which would remove the need for these variant closures. I feel though that this is not a good idea since the `SessionDelegate` does not publicly expose the subdelegates and opening this up could lead to misuse when subclassing.

What "misuse" were you referring to here? I think we should consider that before making this change. 

Generally, I feel like this is an advanced use case, and anyone who needs to do this should be taking the responsibility to not misuse the subclass and dealing with any bugs that come of it. I think that there is a balance between making things simple for most users and protecting them from bugs and allowing the flexibility for advanced users to customize. This proposal seems to keep that balance intact to me.
 I tend to agree, make things simple for normal users, but allow advanced use cases. Perhaps a good balance would be: remove final keyword from SessionDelegate, and add extra documentation and maybe an example of proper usage for advanced users in the documentation? I know we want to make it hard for people to do the wrong thing, but we also should balance that with enabling more advanced uses.

Another alternative approach could entail posting notifications for each delegate method call, and stuffing the same arguments into the userInfo object as the delegate methods. IMO this feels worse than removing "final" from the delegate, but we already have a few notifications for task lifecycle events.
  I import Alamofire using CocoaPod, but it shows a lot of errors. I am using cocoa pods 0.39.0, Xcode 7.2.1

![screen shot 2016-03-27 at 12 34 40 am](https://cloud.githubusercontent.com/assets/11523438/14061497/f6ae9f40-f3b3-11e5-9465-39a892cb8db1.png)
 I'm seeing the same errors.

FWIW, using cocoa pods 0.39.0, Xcode 7.2.1. Tried both iOS 8.0 and 9.0 in the 'platform' declaration.
 Issue was resolved upon upgrading to Xcode 7.3.
 Thanks, but is there any way else to solve this? 
 @khuong291  It happened because last version is updated for Swift 2.2
So if you're not ready to update your XCode to v7.3, then downgrade the Alamofire to previous version.

just replace in your podfile with:
pod 'Alamofire', '~> 3.2.1'
 Thanks a lot, @ludoded . Your solution really helps me :cupid: 
  After upgrading our code base to swift 2.2 and bringing in AlamoFire 3.3, our OAuth flow is failing because `taskWillPerformHTTPRedirection` callback is not being called.  I've confirmed that reverting back to AF 3.2 fixes this.  Something broke in 3.3.
  Hello,I am new to Alamofire here which i just change from SwiftHTTP.I want to know how to upload Multiple Images send by UIImagePickerController using Alamofire.I also ask about general help at SO.But,nobody answered.So,Please don't mind me that i created an issue here.Its not issue.Its general Usuage of this library.I want to know how to upload multiple images (eg.2 Images picked by UIImagePickerController) with some parameters.Any Help?

Here is my UIImagePickerController : 

```

import Foundation

class Photo: NSObject {
    var image: String

    init(image: String) {
        self.image = image
    }
}



var photo = [Photo]()

func imagePickerController(picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : AnyObject]) {
        var newImage: UIImage

        if let possibleImage = info["UIImagePickerControllerEditedImage"] as? UIImage {
            newImage = possibleImage
        } else if let possibleImage = info["UIImagePickerControllerOriginalImage"] as? UIImage {
            newImage = possibleImage
        } else {
            return
        }

        let imageName = NSUUID().UUIDString
        let imagePath = getDocumentsDirectory().stringByAppendingPathComponent(imageName)

        print(imagePath)

        if let jpegData = UIImageJPEGRepresentation(newImage, 80) {
            jpegData.writeToFile(imagePath, atomically: true)
        }

        let finalPhoto = Photo(image: imageName)
        photo.append(finalPhoto)

        print(photo)

        photoCollectionView.reloadData()

        dismissViewControllerAnimated(true, completion: nil)
    }
```
  Would the use of "#if swift(>=2.2)" have allowed Alamofire to continue to compile with Xcode 7.2 ?
  Please check the errors in attached file.

![screen shot 2016-03-24 at 14 55 35](https://cloud.githubusercontent.com/assets/2293605/14018944/9546654c-f1d0-11e5-9abd-ae8875554add.png)
![screen shot 2016-03-24 at 14 55 51](https://cloud.githubusercontent.com/assets/2293605/14018945/95494c30-f1d0-11e5-9b67-c6c4c7be5e3a.png)
![screen shot 2016-03-24 at 14 56 05](https://cloud.githubusercontent.com/assets/2293605/14018946/9550494a-f1d0-11e5-9bd5-8a5a94cdca9c.png)
 Cool, Thanks !
  My `Cartfile` contains:

```
github "Alamofire/Alamofire" ~> 3.2
```

We are still using Xcode 7.2 / Swift 2.1. Today I made a `carthage bootstrap` and it downloaded Alamofire 3.3, which of course breaks the compilation.

IMHO this new version should have been a 4.x.

Any thoughts?

Edit: I could fix it with `github "Alamofire/Alamofire" == 3.2.1` of course. But I bet I'm not the only one that will run into this problem.
 I completely agree. I am still able to move to 2.2, so no major issue for me, but it should _at the very least_ be in the upgrade notes, as it breaks compilation at 21 places for me in Swift 2.1/Xcode 7.2.1.
 Thanks for the update. I understand your position üëç
  In the `Manager.swift` you use the `#selector` and `#if` syntax, but it is introduced in swift 2.2 and will build fails before that version.

``` Swift
        public override func respondsToSelector(selector: Selector) -> Bool {
            #if !os(OSX)
                if selector == #selector(NSURLSessionDelegate.URLSessionDidFinishEventsForBackgroundURLSession(_:)) {
                    return sessionDidFinishEventsForBackgroundURLSession != nil
                }
            #endif

            switch selector {
            case #selector(NSURLSessionDelegate.URLSession(_:didBecomeInvalidWithError:)):
                return sessionDidBecomeInvalidWithError != nil
            case #selector(NSURLSessionDelegate.URLSession(_:didReceiveChallenge:completionHandler:)):
                return sessionDidReceiveChallenge != nil
            case #selector(NSURLSessionTaskDelegate.URLSession(_:task:willPerformHTTPRedirection:newRequest:completionHandler:)):
                return taskWillPerformHTTPRedirection != nil
            case #selector(NSURLSessionDataDelegate.URLSession(_:dataTask:didReceiveResponse:completionHandler:)):
                return dataTaskDidReceiveResponse != nil
            default:
                return self.dynamicType.instancesRespondToSelector(selector)
            }
        }
```
  Hello. The problem comes after update from 7.2 to 7.3.
[Screenshot](http://images.illuzor.com/uploads/xcode-7.3.png)
Is it alamofire bug? Maybe my mistake or problem of project configuration? 

Even simple code causes this problem:

`Alamofire.request(.POST, "", parameters: ["test":"test"], headers: ["test":"test"])`

ios target - 8.4
  Hi everyone. I know this is not the place for. But my question is very simple. I search stackoverflow but i cant found working example. 

I want get cookie with alamofire request. And save this cookie on userdefaults or keychain. And i want use this cookie with new alamofire request. Any example code for this?
  Hi, 
I am trying to use Alamofire 3.0 with Xcode 7.2 [swift 2.0]. With the code as follows, the compiler gives error on .POST, Type of Expression without more context.
I checked parameters definition for unwrapping issues, could not find anything wrong. In fact it gives error irrespective whether parameters is there.
Any help will be appreciated

Alamofire.upload (.POST,
        URL,
        parameters:params,
        multipartFormData: { multipartFormData in
            multipartFormData.appendBodyPart(fileURL: filename!, name: namewithoutpath!)

```
    },
    encodingCompletion: { encodingResult in
        switch encodingResult {
        case .Success(let upload, _, _):
            upload.responseJSON { response in
                debugPrint(response)
            }
        case .Failure(let encodingError):
            print(encodingError)
        }
    }
)
```
  i just updated to xcode 7.3 and from that moment i am getting this error :- No such module Alamofire. I have updated the Alamofire pod to 3.2.1 , then also the issue remains.Please guide
 i have updated the alamofire to 3.3.0, converted code to latest syntax, running xcode 7.3 and still facing the issue on my another project. I always face this issue once a while ,can u resolve this . Thanks
  After upgrading to Xcode 7.3, I have encountered these errors during linking:

```
Undefined symbols for architecture x86_64:
  "Alamofire.upload (Alamofire.URLRequestConvertible, multipartFormData : (Alamofire.MultipartFormData) -> (), encodingMemoryThreshold : Swift.UInt64, encodingCompletion : (Alamofire.Manager.MultipartFormDataEncodingResult) -> ()?) -> ()", referenced from:
...
"Alamofire.Request.responseJSON (options : __C.NSJSONReadingOptions, completionHandler : (Alamofire.Response<Swift.AnyObject, __ObjC.NSError>) -> ()) -> Self", referenced from:
```

for Alamofire.

I have tried cleaning, doing `pod update`, removing caches/the `Pod` directory, `Podfile.lock`, the `xcworkspace`, etc., and rebuilding, and it does not resolve. Everything built fine on Xcode 7.2.1.
 Is this fixed yet? I tried 3.4.0, getting same error.
 I'm also getting 
`Undefined symbols for architecture x86_64:
  "Alamofire.Request.responseJSON (options : __C.NSJSONReadingOptions, completionHandler : (Alamofire.Response<Swift.AnyObject, __ObjC.NSError>) -> ()) -> Self", referenced from:`

In Alamofire 3.4.0 , but I didn't have this issue with 3.3.1
 Ok fixed it by deleting derive data like in https://github.com/CocoaPods/CocoaPods/issues/5072
 Its not a bug in Alamofire. check #1242 
  Updated to fix warnings related to Swift 2.2 in Manager and ResponseSerialization. Also fixed one warning in the example project.

[There was one catch](https://github.com/nickskull/Alamofire/blob/680c1fad020fe0eeb541a99d9415774fa374a00d/Source/Manager.swift#L680) however for OS X version, where I had to take a switch `case` out of the switch and make it an `if`.

If you have any other idea how to improve, I will gladly change the implementation.
 @cnoon Great, thanks! If you need any more changes done or something updated let me know. 

Also, I tried to get Travis to work but it somehow fails every time and I am not quite sure what is the issue. I ran all tests for all platforms on my computer and everything passed without any problems, so can't see why is Travis complaining.
 @nickskull  I am getting warning for Alamofire/Source/ParameterEncoding.swift  247:29: 'init(start:end:)' is deprecated: it will be removed in Swift 3.  Use the '..<' operator.

Are you going to change it as well?
 @Trhacz That was already fixed on the swift_2.2 branch by @Baza207 :) 
 For some reason, Alamofire is not compiling for x86_64 (but does for the device). On the simulator build, it complains about the generics.
 @danielrhodes I can't reproduce your issue. Are you using the newest Xcode version? Also what does it complain about?
 I think there is also one more fix for Swift 2.2 

# Manager.swift

``` swift
   public func URLSession(
            session: NSURLSession,
            task: NSURLSessionTask,
            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
        {


            if let taskDidReceiveChallenge = taskDidReceiveChallenge {
                completionHandler(taskDidReceiveChallenge(session, task, challenge))
```

gives 

> Passing 2 arguments to a callee as a single tuple value is deprecated

I fixed by manually creating the tuple.

``` swift
                let (disposition,credential) = taskDidReceiveChallenge(session, task, challenge)
                completionHandler(disposition,credential)
```

The reason is stated in [here](https://github.com/apple/swift/blob/master/test/Misc/misc_diagnostics.swift#L139)
 @tosbaha That is fixed in my commit.
 @nickskull I'm going to create a fresh project and get back to you
 Ok created a fresh project and it seems to work fine. I'm totally confused then what that issue is. :-P
 @cnoon Thanks, will update all my projects then! :beers: 
  To get response size I use `response.data.length`. But this is the size of the response after content is ungzipped.

I know this is in domain on `NSHTTPURLResponse` but is there a way to get response size before gzip decompression occurs? So I want to know actual server response size.

Thanks!
 [NSURLResponse](https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSURLResponse_Class/index.html) has [expectedContentLength](https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSURLResponse_Class/index.html#//apple_ref/occ/instp/NSURLResponse/expectedContentLength).

``` objc
@property(readonly) long long expectedContentLength
```

``` swift
var expectedContentLength: Int64 { get }
```

If unknown, it returns `NSURLResponseUnknownLength`. And it's the case with GZip compression because data flow is compressed on the fly.
 @florentmorin expectedContentLength returns uncompressed response size. Obviously there is no way to determine response size before unzip occurs. Thanks anyway for clarification.
 @jshier @borut-t @florentmorin 

The expected content length is always -1 for me! Why do you think that is? Below is my response. As you can see, the "Content-Length" header is present.

```
(lldb) po downloadTask.response
‚ñø Optional<NSURLResponse>
  - Some : <NSHTTPURLResponse: 0x7fbf8ee5daa0> { URL: https://v4-dev.getsigneasy.com/v4/files/original/3130118/download } { status code: 200, headers {
    "Access-Control-Allow-Credentials" = true;
    "Access-Control-Allow-Headers" = "Accept,Authorization,Cache-Control,Content-Type,DNT,If-Modified-Since,Keep-Alive,Origin,User-Agent,X-Mx-ReqToken,X-Requested-With";
    "Access-Control-Allow-Methods" = "GET, POST, PUT, DELETE, OPTIONS";
    "Access-Control-Allow-Origin" = "*";
    "Access-Control-Expose-Headers" = "Content-Disposition, Content-Length";
    "Cache-Control" = "public, max-age=43200";
    Connection = "keep-alive";
    "Content-Encoding" = gzip;
    "Content-Length" = 59274;
    "Content-Type" = "application/pdf";
    Date = "Mon, 19 Sep 2016 07:04:54 GMT";
    Etag = "\"flask-1444909447.0-129511-4246673535\"";
    Expires = "Mon, 19 Sep 2016 19:04:54 GMT";
    "Last-Modified" = "Thu, 15 Oct 2015 11:44:07 GMT";
    Server = "nginx/1.4.6 (Ubuntu)";
    Vary = "Accept-Encoding";
} }
```

```
(lldb) po downloadTask.response?.expectedContentLength
‚ñø Optional<Int64>
  - Some : -1
```
  In `ParameterEncoding.swift` there is a part:

```
    public func queryComponents(key: String, _ value: AnyObject) -> [(String, String)] {
        var components: [(String, String)] = []

        if let dictionary = value as? [String: AnyObject] {
            for (nestedKey, value) in dictionary {
                components += queryComponents("\(key)[\(nestedKey)]", value)
            }
        } else if let array = value as? [AnyObject] {
            for value in array {
                components += queryComponents("\(key)[]", value)
            }
        } else {
            components.append((escape(key), escape("\(value)")))
        }

        return components
    }
```

The problem it that in case when value is `Bool?`, it gets converted to `__NSCFBoolean`, which transforms to `"0"` or `"1"`. How to make this convert to `"false"` and `"true"`?
 @orkenstein I believe you can try a type cast `if` check, then pass through a new `Bool` variable. Something like : 
`(value as! Bool) ? true:false`

cheers! :beers: 
 @oursevendev thanks
The question: where to do this?
The `value` came from here:

```
    public func encode(
        URLRequest: URLRequestConvertible,
        parameters: [String: AnyObject]?)
        -> (NSMutableURLRequest, NSError?)
    {
        var mutableURLRequest = URLRequest.URLRequest

        guard let parameters = parameters else { return (mutableURLRequest, nil) }

        var encodingError: NSError? = nil

        switch self {
        case .URL, .URLEncodedInURL:
            func query(parameters: [String: AnyObject]) -> String {
                var components: [(String, String)] = []

                for key in parameters.keys.sort(<) {
                    let value = parameters[key]!
                    components += queryComponents(key, value)
                }
```

And it's always `optional`.
 @orkenstein I would fit it in your for loop

`if let boolVal = value as? Bool {
(boolVal == 0) ? false:true
var tF:Bool = boolVal?
components += queryComponents(key, tF)  
} else {
//value was some other type of AnyObject, throw exception or alternate conditions...
}`

idk why github code formatter is munging this; so here's a gist link:

https://gist.github.com/oursevendev/dc8f4ed6b023f2c672a7

Hope this helps, I can take a deeper look later...
 @oursevendev 
It's a method `encode` defined in `ParameterEncoding`. So this must be fixed on framework level I guess.
 Hi, @cnoon and thanks!
Oh, that's sad and looks a lot like a workaround.
Probably it's possible to check for `Bool` in `queryComponents`?
 @oursevendev thanks for your snippet.
I'm trying to use something like this:

```
  static func convertBoolToString(source: [String:AnyObject]) -> [String:AnyObject]? {
    var destination = [String:AnyObject]()
    for (key, value) in source {
      if value is Bool, let boolValue = value as? Bool {
        destination[key] = "\(boolValue)"
      } else {
        destination[key] = value
      }
    }

    if destination.isEmpty {
      return nil
    }
    return destination
  }
```

The problem, that if the `value` is any type convertible to `Bool` if will be converted. `29.4234234`, `100`, etc. will be replaced with `true/false`. Which is incorrect.
How to make sure that the `value` is exactly and only a bool?
 @orkenstein ahhhhh I was unaware you had possible values for Floats, I thought just 1 or 0 which is often an old caveat for converting in objc BOOL types.
 Possible workaround described here:
http://stackoverflow.com/questions/36185530/how-to-check-dictionary-value-to-be-exactly-a-bool/36186159#36186159
  Hi there,

I used Alamofire to make requests.
In my app, I have a table view of almost 1500 users.
I make requests for each user, to load the user image.
The memory goes up, without never coming back to normal.

After a quick check on instruments, I saw some issues, but I'm surely not experienced enough to solve it.
You can reproduce the problem with this repository : https://github.com/arn00s/AlamofireMemory

Anyway, If I made a bad usage, please tell me how I should proceed :+1: 

Using xCode 7.2.1, and iOS 9.2.1 on an iPhone 5s
 No problem from Alamofire. There's no memory leak.
 HI @florentmorin , have you tested the sample app ?
Can you explain why does the memory never goes down ?

Thanks,
  Our app is written in ObjC and uses AFNetworking and JSONModel for all server interaction.

In the end I would like to replace AFNetworking by Alamofire and get rid of JSONModel completely. However, its kinda unrealistic to do so in a single release/development cycle.

So the question: can I use AFNetworking (on the ObjC side) and Alamofire (on the Swift side) in the same app or will I get in in trouble? I'm worried about stuff like queues, locks, handler etc...

Stefan
 @skerkewitz I'm thinking it's safe to assume you are using JSONModel for parsing your AFN response? I would recommend `replacing` AFN with Alamofire, and then
[git@github.com:SwiftyJSON/SwiftyJSON.git](url)
 `SwiftyJSON` is great for handling the parsing; they are both lightweight `Swift` libraries that play well with `Mix&Match` projects.
 Also, for future; questions like this are probably more well suited for Stack Overflow...

cheers! :beers:
 @cnoon 
Thanks for the answer, I will give it a try.
  When using a Background Session Configuration instead of the default to call a HTTPS URL the serverTrustPolicyManager is never used and the download fails with "An SSL error has occured and a secure connection to the server cannot be made.".

I create my Manager like this

```
let serverTrustPolicies: [String: ServerTrustPolicy] = [
    Consts.host: .PinCertificates(
        certificates: ServerTrustPolicy.certificatesInBundle(),
         validateCertificateChain: true,
         validateHost: false
     )
]
let configuration = NSURLSessionConfiguration.backgroundSessionConfigurationWithIdentifier("projectid.background")
let downloadManager = Alamofire.Manager(
    configuration: configuration,
    serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies)
)
```

The `didReceiveChallenge` of the SessionDelegate is never called. Using `NSURLSessionConfiguration.defaultSessionConfiguration()` everything works as expected and the SSL certificate is successfully validated. Does anyone have an idea why the didReceiveChallenge is not called when using a background configuration? I couldn¬¥t figure it out yet.

I am using XCode 7.2.1 testing on iOS 9.2.1.
 This problem directly occurs regardless of whether in foreground or background. In my usecase we are communicating with a server running on a hardware we are producing using certificate pinning for security reasons. When we are downloading files from this server I want the app to continue in the background so the download is finished even when the user leaves the app.

The interesting part is that without putting the app into background `didReceiveChallenge`is not called just because the session configuration is different.

@cnoon: do you have a rough idea where I can look at for further investigation? Thanks for your help! :-D
 Hi @cnoon ,

thanks for your answer :beer:. Our App is successfully running with the defaultConfiguration in production, so no problems with the server or certificate pinning in general. As I wrote, while troubleshooting I recognized that `didReceiveChallenge` is never called after I switched from the defaultConfiguration to the backgroundSession (no other changes). I couldn¬¥t find out yet what¬¥s the reason for that. I am thankful for any idea where to continue my troubleshooting.

Cheers
 Sure, I hope to find some time this weekend for further troubleshooting and writing a testcase for this.
 Hi @cnoon and @matthiaslau,

I wrote a test, checking whether didReceiveChallenge will be called, when using a background configuration. It fails even w/o Certification Pinning. (Alamofire 3.4.0, Xcode 7.3.1, iOS 9.3)

@cnoon wrote a test where it does succeed with default config. 

It seems, session:didReceiveChallenge won't be called with a background configuration at all, even tough the SessionDelegate and the implementations do exist. Also session:task:didReceiveChallenge won't be called. (in the default Alamofire implementation of SessionDelegate, it would call session:didReceiveChallenge)

I couldn't find any hints in Apple's documentation, mentioning restrictions regarding authentication and background sessions.
[Background Transfer Considerations](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/URLLoadingSystem/Articles/UsingNSURLSession.html#//apple_ref/doc/uid/TP40013509-SW44)

**possible next steps**
Next thing I would like to try is whether the delegate's function still won't be called when setting up a NSURLSession w/ background config but w/o Alamofire.

Also, I would like to try whether it would help, adding the certificate to the shared NSURLCredentialStorage (which is used by default and background sessions) or to a custom Request object before starting a request (as a possible fix). [Because iOS will look there before calling didReceiveChallenge](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/URLLoadingSystem/Articles/AuthenticationChallenges.html#//apple_ref/doc/uid/TP40009507-SW3).

> Next, if your delegate agrees to handle authentication and there are no valid credentials available, either as part of the requested URL or in the shared NSURLCredentialStorage, the delegate receives one of the following messages:
> URLSession:didReceiveChallenge:completionHandler:
> URLSession:task:didReceiveChallenge:completionHandler:

Or whether using a download task rather than a data task would make a difference. Data tasks were not supported in background sessions prior to iOS 8 and may still be more restricted.
 Hi @cnoon,

thank you for investigating this!

That seems to be quite an edge case we got ourselves into here... 

Cheers!
  Added ability to specify queue for serializer, for me its highly usable if you have framework (like Realm) which don't allow to pass serialized objects between threads.
 Hi @cnoon,

unfortunately I can't create my own `Request` extension, because in this way I will not be able to access 
`self.delegate.data,
                self.delegate.error
` etc.,
from my extension (they are don't have public declaration and will not be visible outside Alamofire framework). Or you suggestion was about to create new extension for `Request` as a part of Alamofire framework?
  I using django-reat-framework as backend and using SessionAuthentication and TokenAuthentication. This work well when I use httpie send request

http POST http://127.0.0.1:8000/api/users/ email="abc@abc.com" user_name="abc" passwod="1234"

but when I use Alamofire

```
Alamofire.request(.POST, "http://127.0.0.1:8000/api/users/", parameters: ["email": emailField.text!, "user_name": usernameField.text!, "password": passwordField.text!], encoding: .URL )
            .responseJSON { response in
                print(response.request)  // original URL request
                print(response.response) // URL response
                print(response.data)     // server data
                print(response.result)
                if let JSON = response.result.value {
                    print("JSON: \(JSON)")
                }
        }
```

return this

```
Optional(<NSMutableURLRequest: 0x7fe24e15d640> { URL: http://127.0.0.1:8000/api/users/ })
Optional(<NSHTTPURLResponse: 0x7fe24bf3a080> { URL: http://127.0.0.1:8000/api/users/ } { status code: 403, headers {
    Allow = "GET, POST, HEAD, OPTIONS";
    "Content-Type" = "application/json";
    Date = "Fri, 11 Mar 2016 13:09:59 GMT";
    Server = "WSGIServer/0.2 CPython/3.4.3";
    Vary = "Accept, Cookie";
    "X-Frame-Options" = SAMEORIGIN;
} })
Optional(<7b226465 7461696c 223a2243 53524620 4661696c 65643a20 43535246 20746f6b 656e206d 69737369 6e67206f 7220696e 636f7272 6563742e 227d>)
SUCCESS
JSON: {
    detail = "CSRF Failed: CSRF token missing or incorrect.";
}
```

But 127.0.0.1:8000/api/users/ don't need any permission, and I didn't send csrf token when I using httpie. So, What's wrong here?
  Hello,

I am rejecting a promise with the custom error below:

`let error = Error.errorWithCode(Error.Code.InputStreamReadFailed, failureReason: "reason")
                            reject(error)`

I have also tried the following:

`reject(NSError(domain: "somedomain", code: 123, userInfo: [:]))`

In either case I receive the following message in the xCode console: 
"...**_PromiseKit: Unhandled Error:_** Error Domain=com.alamofire.error Code=-6000 "reason" UserInfo={NSLocalizedFailureReason=reason}"

Is this something on my end or a bug?

Here is the complete function:

```
func getImageByID(imageID : String) -> Promise<UIImage> {
        return Promise { fulfill, reject in
            Alamofire.request(.GET, getImageURL(imageID)).responseData {response in
                if response.result.isSuccess {
                    if response.data != nil {
                        if let image = UIImage(data: response.data!) {
                            fulfill(image)
                        } else if UIImage(data: response.data!) == nil {

                            let error = Error.errorWithCode(Error.Code.InputStreamReadFailed, failureReason: "reason")
                            reject(error)
                            //reject(NSError(domain: "somedomain", code: 123, userInfo: [:]))
                            //reject(NSError(domain: "somedomain", code: 123, userInfo: nil))
                        } else {
                          .....
                        }
                    }
                } else {
                    reject(response.result.error!)
                }
            }
        }
    }
```

Any help is most appreciated!

Thanks!
  Adding the possibility to receive the callback to a different queue to all `response*` methods.

I'm not sure why it's not like that at the moment, maybe I'm missing something üôÉ
  The NSStream code is synchronized. As for the doc of Apple, we needn't schedule the NSInput/OutputStream on a runloop, which will make the stream event delivered to the delegate of NSStream (which is the stream itself as we haven't set it).
 I think we are not talking about the same issue. But from the document of Apple, NSStream can work on 2 modes: sync or async.
If you schedule the stream on a runloop as you can see in Alamofire, it's async. We can get notified and get data from the delegate method.
But Alamofire use the blocking api -[NSStream read:maxLength:]. In such case, we need not schedule it on a runloop.

I don't know if it will cause the deadlock issue, but it's obvious a misunderstanding of NSStream.

Correct me if I'm wrong.
Thanks!
 hi, @KingOfBrian . So if it's a issue, I think we should open a PR to fix it. Will you do it? Or I will do it tomorrow.
 @cnoon. You can find the example code from Apple's Stream Programming Guide.
The Run-Loop Scheduling code can be found in:
https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Streams/Articles/WritingOutputStreams.html#//apple_ref/doc/uid/20002274-BAJCABBC
The Polling code can be found in:
https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Streams/Articles/PollingVersusRunloop.html#//apple_ref/doc/uid/20002275-CJBEDDBG

You can see there is no need to schedule on a runloop using the polling mode stream .

Hope this can help you!
  - stringResponseSerializer on Testing JSONResponseSerializer

I think this must be typo.
 @cnonn Thx.~~
If I found other, I would PR.
Have nice day.~
  Hi,
    When attempting to use `swift build` , there a `swift error: NoSources(...` for `/Tests/Resources/` . At the moment I don't have a need for your libraries unit tests, and the sources were fetched just fine. However just a heads up; and seeing if there is a fix for this. Seeing that SPM is pretty new.
Any insights appreciated!

Cheers! :beer:
 I don't know if is an bad approach, but I deleted Tests folder before run `swift build` again. 

`rm -rf Packages/Alamofire-3.3.0/Tests/*`
 thanks @vsouza I'll attempt that, for now just sticking to cocoapods on the project until SPM is stable and Swift3...
  In [Manager.init:delegate:serverTrustPolicyManager:](https://github.com/Alamofire/Alamofire/blob/master/Source/Manager.swift#L141), why is it enforced that "The delegate of the URL session. Must equal the URL session's delegate.", i.e. why is the following line required?

```
guard delegate === session.delegate else { return nil }
```

My use case: I obtain an initialized NSURLSession from a security library (out of my control), which provides it own internal proxy object for NSURLSession.delegate, which checks and forwards NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate and NSURLSessionDownloadDelegate calls.

To clarify, my initialization code looks something like this:

```
let delegate = Manager.SessionDelegate()
let session: NSURLSession = SecurityLib.initialize(sessionDelegate: delegate,
    taskDelegate: delegate, dataDelegate: delegate, downloadDelegate: delegate)
let manager = Manager(session: session, delegate: delegate)
```

The last line currently fails because session.delegate is a proxy object internal to SecurityLib (which forwards all delegate methods to our delegate). If I remove the guard line from Manager.swift things seem to work.
 Because Alamofire use its SessionDelegate subclass to the real delegate work. It can provide block api of NSURLSessionDelegate(and its subclasses), and also provide a way to fallback to TaskDelegate, which is to each NSURLSessionTask and can provide a more specialized impementation.

If you insist using your delegate, you will lose a lot convenience of the library. I think you can try to make your delegate be a proxy of SessionDelegate by applying all callbacks to the blocks of SessionDelegate.

Hope this can help you.
 OK, thanks for taking the time to answer this.
  I found a issue with isReachable in NetworkReachabilityManager when network condition is 100% loss.
My code :
let isReachable = NetworkReachabilityManager(host:"192.168.3.1:3000")!.isReachable
In ios8 isReachable is false
In ios9 isReachable is true
I hope you can solve my doubts.
  I want continue download After I press 'startDownload' button, (Use resumeData)
when I second time enter app after app terminated.

Here is my Example code:
https://github.com/wgywgy/AlamofireDownloadDemo/tree/master

where to find resumeData?
 I still don't understand how to get resumeData. I know how to continue download after pause without App terminate, but how to get resumeData when user terminate app and second time come in. 
Can you Give me a Exmaple? Thank you.
 I got the same problem, I save the resume data before cancel()

Alamofire.download(resumeData: cancelledData, destination: self.destination)
and when reopen the App It runs well in iOS 9 but doesn't work in iOS 8(simulator), saying: error 2 opening resume file
 @cnoon OK, Thx.
 Hello @cnoon,

sorry to use this closed thread to ask you something but last time I have tried to use the stackoverflow with the _Alamofire_ tag and no one answered me üòû

So, I think I am facing the same problem as they were. I did understand what you have said and how to proceed if the app is still running when the download is cancelled. However, when the app is killed (by user interaction or crash) idk how to store the `resumeData` to resume the request when the app starts again. Any thoughts on how I can implement this when that happens?

Thanks  I'm trying to post to a service that only takes XML format as the body of the post.

My code so far is:

```
        let bodyString = "<Command>" +
                            "<Name>get_network_info</Name>" +
                            "<Protocol>ZigBee</Protocol>" +
                            "<MacId>" + rainForest.macId + "</MacId>" +
                            "<Format>JSON</Format>" +
                         "</Command>"

        let custom: (URLRequestConvertible, [String: AnyObject]?) -> (NSMutableURLRequest, NSError?) = {
            (convertible, parameters) in
            let mutableRequest = convertible.URLRequest.copy() as! NSMutableURLRequest
            let bodyData:NSData = bodyString.dataUsingEncoding(NSUTF8StringEncoding)!
            mutableRequest.HTTPBody = bodyData
            return (mutableRequest, nil)
        }


        return Promise { fulfill, reject in
            Alamofire.request(.POST, rainForest.url, parameters: [:], encoding: .Custom(custom), headers: headers).responseJSON { response in

                print(response.request)
                print(response.request?.allHTTPHeaderFields)
                print(response.request?.HTTPBody?.debugDescription)

                switch response.result {
                case .Success(let json):
                    fulfill(Mapper<NetworkInfo>().map(json["NetworkInfo"])!)
                case .Failure(let error):
                    if response.response?.statusCode < 200  || response.response?.statusCode > 299 {
                        reject(ServerError.Invalid)
                    }
                    else {
                        reject(error)
                    }
                }
            }
        }
```

I get a nil response.  I'm able to get the API response find in PostMan.  What am I going wrong?
 Thanks, that was helpful.  I will use StackOverflow in future.  The issue is that it's not hitting my custom code block so there is no body added to the post.  Not sure why yet. 
 I think I know why.  I'm on version 3.1.5.  I just read https://github.com/Alamofire/Alamofire/issues/1032
 3.2.1 fixed it!  Thanks
  Hi all!
How to upload multi file with alamofire? Thank
  when i want to get data from a html page,something goes wrong.
`Alamofire.request(.GET, QJApi.QJVideo).validate().responseString(encoding: NSUTF8StringEncoding)`,in the code , `QJApi.QJVideo` is the `.html`page,but i use `print("request=\(response)")`  ,the console prints `request=FAILURE: Error Domain=com.alamofire.error Code=-6005 "String could not be serialized with encoding: 4" UserInfo={NSLocalizedFailureReason=String could not be serialized with encoding: 4}`
  Hello
In Manager.defaultHTTPHeaders print out the userAgent

> ```
>     // User-Agent Header; see https://tools.ietf.org/html/rfc7231#section-5.5.3
>     let userAgent: String = {
>         if let info = NSBundle.mainBundle().infoDictionary {
>             let executable = info[kCFBundleExecutableKey as String] ?? "Unknown"
>             let bundle = info[kCFBundleIdentifierKey as String] ?? "Unknown"
>             let version = info[kCFBundleVersionKey as String] ?? "Unknown"
>             let os = NSProcessInfo.processInfo().operatingSystemVersionString ?? "Unknown"
>             var mutableUserAgent = NSMutableString(string: "\(executable)/\(bundle) (\(version); OS \(os))") as CFMutableString
>             let transform = NSString(string: "Any-Latin; Latin-ASCII; [:^ASCII:] Remove") as CFString
>             if CFStringTransform(mutableUserAgent, UnsafeMutablePointer<CFRange>(nil), transform, false) {
>                 return mutableUserAgent as String
>             }
>         }
>         return "Alamofire"
>     }()
>     print("useragent__\(userAgent)")
>     return ["Accept-Encoding": acceptEncoding, "Accept-Language": acceptLanguage, "User-Agent": userAgent]
> ```

the output
`useragent__Optional(Hello)/Optional(com.test.Hello) (Optional(1); OS Version 9.2 (Build 13C75))`

It turns out that the executable, bundle, version is Optional
`info[kCFBundleExecutableKey as String] as? String ?? "Unknown"`
will be ok

xcode 7.2.1 iOS 9.2.1

ignore me if you already know that^^
 Sorry about the title.
The userAgent is String indeed.
What I mean is these three
`let executable = info[kCFBundleExecutableKey as String] ?? "Unknown"`
`let bundle = info[kCFBundleIdentifierKey as String] ?? "Unknown"`
`let version = info[kCFBundleVersionKey as String] ?? "Unknown"`
they are optional
If you do this
`let executable: String = info[kCFBundleExecutableKey as String] ?? "Unknown"`
you will get a error
  I'm wondering whether just adding blocks for all the delegate methods is a good approach. The "old" cocoa-pattern of having a delegate possibly implement a set of methods and using default behavior if a method is not implemented achieves basically the same. But since the declarations for all the delegates you need (session delegate, task delegate, etc.) are already done you don't need to write them, in contrast to the block. 
All those blocks seem to make the API of the `SessionDelegate` and `TaskDelegate` rather difficult to understand. I only understood that I could even provide these blocks after reading the implementation after failing to find a delegate to set or another customization point. 

So two more high-level questions:
1. How about giving the session- and task-delegate each a delegate of same kind that users of Alamofire could implement. If a method is implemented, call it, if not use Alamofire's default implementation.
2. Why not allow an NSURLSessionDelegate instead of a `SessionDelegate` to be passed to the Manager initializer. What is special about Alamofire's SessionDelegate that would take much work to reproduce in an own delegate and everyone needs?

Also, if I see it correctly, I could implement my own delegate and make it instantiate an instance of `SessionDelegate` itself to forward methods to that if I don't want to provide a custom implementation. This way, the implementation of the `SessionDelegate` wouldn't even be lost, but could be reused.
 @cnoon I think this is a great change. The example in #1095 convinces me that this is a necessary addition. This also makes it easier to create plugins that build on top of `Alamofire`(ex. A networking logger). I also agree that this is a better solution than allowing the `SessionDelegate` to be subclassed. 

@JoachimK I'm personally a big fan of using block variables as an alternative to the delegate pattern. It feels much more Swifty to me, and is becoming a pretty popular pattern across many open source libraries.
The delegate pattern is clunky. Optional delegate methods require either `@objc`, forcing your delegate to subclass `NSObject`, or a protocol extension, which abstracts default implementation out of the delegate's definition, making it harder to understand. And I could give you 10 other reasons that I don't love the delegate pattern.
 Another thing about the challenge/authentication specifically: If we are going to provide our "own" API (be that in blocks or as delegate) instead of using Apple's declared delegate protocols, we could try to seize the opportunity and improve upon it. 

One of my main issues with the `didReceiveChallenge` method is that is is called both to authenticate the client to the server and to let the client verify the server, which is quite confusing.

An option to improve this is to expose the different cases in your implementation for customization. E.g. have separate delegate methods/blocks for `func verifyServerCredentials` (basically the current `evaluateServerTrust()`-method) and `func provideCredentialsForChallenge(session:NSURLSession, challenge: NSURLAuthenticationChallenge, completionBlock: (NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void) -> Void` 

E.g., I like the verification of server certificates you build and would only need an async way to fetch a credential to authenticate the user if needed. :-)

Not sure whether this would be too specific for Alamofire to build it this way, but to me it seems like you would usually only want to override either the server trust verification OR providing credentials for the user. In addition, the verification of servers is already quite customizable in Alamofire.
 @AnthonyMDev Thanks a lot for your input! I'm a bit wary of using blocks/closures everywhere just because it's Swift. When Apple introduced blocks to Objective-C there was also a big hype around them and everyone suddenly wanted to use blocks for everything and get rid of delegates. However, they also have many disadvantages like leading to inadvertent retain-cycles more easily so the enthusiasm died down a bit again.

The memory management improved with Swift, making it [easier to declare how the parameters of a block should be captured](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html#//apple_ref/doc/uid/TP40014097-CH20-ID48), however, you still need to declare it and I'm not sure how many people even know this functionality exists in Swift. 

I'm usually using blocks for callbacks, generally for stuff that is called just once but at a later time. As soon as you need to store a block (e.g. because it's called several times) I'll usually switch to delegates.

I'm also using delegates, if there are several methods that are called and they belong together/are usually implemented in the same class/object. I think this would be the case here. 
If the normal use case is to set all the blocks of the `SessionDelegate` in the same place in the code (and I think it is), then a delegate might be better suited for the job.

Regarding the "delegate is clunky" part: We basically already have an abstract implementation of the delegate protocols with the `SessionDelegate` and the `TaskDelegate`. All they would have to do is instead of `guard sessionDidReceiveChallengeWithCompletion == nil` do a check whether the delegate response to the appropriate delegate method.

Having said that, please take this as a recommendation only. You surely have more knowledge about how Alamofire is actually used and whether the arguments above make sense in this use-cases. ;-)
 @JoachimK Those are all compelling arguments! Thanks for taking the time to articulate that. 

> [blocks] also have many disadvantages like leading to inadvertent retain-cycles more easily so the enthusiasm died down a bit again.

I was under the impression that delegates create more accidental retain-cycles because people may not know to make the delegate weak. In this case, using blocks should only create a retain-cycle if you are referencing an object in the block.

> If the normal use case is to set all the blocks of the `SessionDelegate` in the same place in the code (and I think it is), then a delegate might be better suited for the job.

I think you are right that, generally, you will set any applicable `SessionDelegate` blocks in the same place, but I don't think you will necessarily want to set ALL of them. You will likely only use one or two in any use case.

> All they would have to do is instead of guard `sessionDidReceiveChallengeWithCompletion == nil` do a check whether the delegate response to the appropriate delegate method.

This requires the use of optional protocol functions, right? (unless I'm confused on what you are proposing.) The problem with optional functions on protocols is that they are only supported in Objective-C, and we don't want to require that our delegate be an `NSObject` subclass.
  This code `Alamofire.request(.GET, "http://www.google.com?q=◊ê")` causes app crash.

The following is printed to the console: 

`fatal error: unexpectedly found nil while unwrapping an Optional value`

Tracing this:

[`let mutableURLRequest = NSMutableURLRequest(URL: NSURL(string: URLString.URLString)!)`](https://github.com/Alamofire/Alamofire/blob/master/Source/Alamofire.swift#L92) is using forced unwrap on NSURL which fails to parse the malformed url.

I think this should not be a crash, instead possibly an error should be returned?

```

Incident Identifier: 14CF2441-3C83-43DE-ABF7-4D59155E1EB5
CrashReporter Key:   9dd618ddf9b2d6723795fbba0fca63d3c36ca87e
Hardware Model:      iPhone7,2
Process:             Finder [1285]
Path:                /private/var/mobile/Containers/Bundle/Application/61A41A40-2CCE-4A76-A5F2-4171632322EF/Finder.app/Finder
Identifier:          so.sugar.client.snc.Finder
Version:             3 (1.0)
Code Type:           ARM-64 (Native)
Parent Process:      launchd [1]

Date/Time:           2016-03-06 21:11:17.17 +0200
Launch Time:         2016-03-06 21:11:13.13 +0200
OS Version:          iOS 9.2.1 (13D20)
Report Version:      105

Exception Type:  EXC_BREAKPOINT (SIGTRAP)
Exception Codes: 0x0000000000000001, 0x00000001008a25dc
Triggered by Thread:  0

Filtered syslog:
None found

Thread 0 name:  Dispatch queue: com.apple.main-thread
Thread 0 Crashed:
0   libswiftCore.dylib              0x00000001008a25dc 0x100764000 + 1304028
1   Alamofire                       0x0000000100101380 URLRequest(Method, URLStringConvertible, headers : [String : String]?) -> NSMutableURLRequest (Alamofire.swift:92)
2   Alamofire                       0x00000001000ef348 Manager.request(Method, URLStringConvertible, parameters : [String : AnyObject]?, encoding : ParameterEncoding, headers : [String : String]?) -> Request (Manager.swift:188)
3   Alamofire                       0x00000001001019d8 request(Method, URLStringConvertible, parameters : [String : AnyObject]?, encoding : ParameterEncoding, headers : [String : String]?) -> Request (Alamofire.swift:126)
4   Finder                          0x000000010008aa3c 0x100080000 + 43580
5   Finder                          0x000000010009144c 0x100080000 + 70732
6   Finder                          0x000000010009106c 0x100080000 + 69740
7   Finder                          0x0000000100091340 0x100080000 + 70464
8   UIKit                           0x0000000187cf40c0 -[UIViewController loadViewIfRequired] + 996
9   UIKit                           0x0000000187db3da8 -[UINavigationController _layoutViewController:] + 72
10  UIKit                           0x0000000187db3c80 -[UINavigationController _updateScrollViewFromViewController:toViewController:] + 416
11  UIKit                           0x0000000187db2ec8 -[UINavigationController _startTransition:fromViewController:toViewController:] + 144
12  UIKit                           0x0000000187db2a6c -[UINavigationController _startDeferredTransitionIfNeeded:] + 868
13  UIKit                           0x0000000187db2694 -[UINavigationController __viewWillLayoutSubviews] + 60
14  UIKit                           0x0000000187db25fc -[UILayoutContainerView layoutSubviews] + 208
15  UIKit                           0x0000000187cef778 -[UIView(CALayerDelegate) layoutSublayersOfLayer:] + 656
16  QuartzCore                      0x00000001856feb2c -[CALayer layoutSublayers] + 148
17  QuartzCore                      0x00000001856f9738 CA::Layer::layout_if_needed(CA::Transaction*) + 292
18  QuartzCore                      0x00000001856f95f8 CA::Layer::layout_and_display_if_needed(CA::Transaction*) + 32
19  QuartzCore                      0x00000001856f8c94 CA::Context::commit_transaction(CA::Transaction*) + 252
20  QuartzCore                      0x00000001856f89dc CA::Transaction::commit() + 512
21  QuartzCore                      0x00000001856f20cc CA::Transaction::observer_callback(__CFRunLoopObserver*, unsigned long, void*) + 80
22  CoreFoundation                  0x0000000182fb8588 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__ + 32
23  CoreFoundation                  0x0000000182fb632c __CFRunLoopDoObservers + 372
24  CoreFoundation                  0x0000000182fb675c __CFRunLoopRun + 928
25  CoreFoundation                  0x0000000182ee5680 CFRunLoopRunSpecific + 384
26  GraphicsServices                0x00000001843f4088 GSEventRunModal + 180
27  UIKit                           0x0000000187d5cd90 UIApplicationMain + 204
28  Finder                          0x000000010008f48c 0x100080000 + 62604
29  libdyld.dylib                   0x0000000182a868b8 start + 4

Thread 1 name:  Dispatch queue: com.apple.libdispatch-manager
Thread 1:
0   libsystem_kernel.dylib          0x0000000182ba54fc kevent_qos + 8
1   libdispatch.dylib               0x0000000182a6894c _dispatch_mgr_invoke + 232
2   libdispatch.dylib               0x0000000182a577bc _dispatch_source_invoke + 0

Thread 2:
0   libsystem_kernel.dylib          0x0000000182ba4b6c __workq_kernreturn + 8
1   libsystem_pthread.dylib         0x0000000182c69530 _pthread_wqthread + 1284
2   libsystem_pthread.dylib         0x0000000182c69020 start_wqthread + 4

Thread 3:
0   libsystem_kernel.dylib          0x0000000182ba4b6c __workq_kernreturn + 8
1   libsystem_pthread.dylib         0x0000000182c69530 _pthread_wqthread + 1284
2   libsystem_pthread.dylib         0x0000000182c69020 start_wqthread + 4

Thread 4:
0   libsystem_kernel.dylib          0x0000000182ba4b6c __workq_kernreturn + 8
1   libsystem_pthread.dylib         0x0000000182c69530 _pthread_wqthread + 1284
2   libsystem_pthread.dylib         0x0000000182c69020 start_wqthread + 4

Thread 0 crashed with ARM Thread State (64-bit):
    x0: 0x0000000100d01400   x1: 0x0000000182c628f4   x2: 0x000000014ed072f0   x3: 0x0000000000000003
    x4: 0x0000000000000000   x5: 0x0000000000000010   x6: 0x0000000000000000   x7: 0x0000000000000fa0
    x8: 0x0000000100d01408   x9: 0x0000000000001000  x10: 0x000000014ed08000  x11: 0x0000000000000fff
   x12: 0x000000014ed04000  x13: 0x0000000000003fff  x14: 0xffffffffffffc000  x15: 0x0000000000003fff
   x16: 0x0000000182bd0178  x17: 0x0000000100964040  x18: 0x0000000000000000  x19: 0x00000001a0793010
   x20: 0x000000014ed417a0  x21: 0x00000001886d0c64  x22: 0x00000001886d0ed2  x23: 0x0000000188708d70
   x24: 0x0000000000000000  x25: 0x00000001886fc298  x26: 0x000000014ee55a80  x27: 0x0000000000000018
   x28: 0x0000000000000001  fp: 0x000000016fd7c760   lr: 0x00000001008a25dc
    sp: 0x000000016fd7c750   pc: 0x00000001008a25dc cpsr: 0x20000000

Binary Images:
0x100080000 - 0x100097fff Finder arm64  <a6235746eadd3e3f98dc9ba4bb82966c> /var/mobile/Containers/Bundle/Application/61A41A40-2CCE-4A76-A5F2-4171632322EF/Finder.app/Finder
0x1000c4000 - 0x10012bfff Alamofire arm64  <7a6998eeb26e32989694483979269019> /var/mobile/Containers/Bundle/Application/61A41A40-2CCE-4A76-A5F2-4171632322EF/Finder.app/Frameworks/Alamofire.framework/Alamofire
0x100368000 - 0x100397fff AlamofireImage arm64  <0385cb8a41d533b2a5e8d8f1b9902877> /var/mobile/Containers/Bundle/Application/61A41A40-2CCE-4A76-A5F2-4171632322EF/Finder.app/Frameworks/AlamofireImage.framework/AlamofireImage
0x1004b0000 - 0x1004c3fff CleanroomASL arm64  <4b2abdeb3ee83f07a60ed37eb7c4d3a4> /var/mobile/Containers/Bundle/Application/61A41A40-2CCE-4A76-A5F2-4171632322EF/Finder.app/Frameworks/CleanroomASL.framework/CleanroomASL
0x10052c000 - 0x10055ffff CleanroomLogger arm64  <0aaebb412303394f803bdb4ab5c814b1> /var/mobile/Containers/Bundle/Application/61A41A40-2CCE-4A76-A5F2-4171632322EF/Finder.app/Frameworks/CleanroomLogger.framework/CleanroomLogger
0x10069c000 - 0x1006affff IKnowKungFu arm64  <c2deec415250327fbdecade5e3db7dc9> /var/mobile/Containers/Bundle/Application/61A41A40-2CCE-4A76-A5F2-4171632322EF/Finder.app/Frameworks/IKnowKungFu.framework/IKnowKungFu
0x100714000 - 0x10071ffff JLRoutes arm64  <63311b5b7b063ea888329f019464e689> /var/mobile/Containers/Bundle/Application/61A41A40-2CCE-4A76-A5F2-4171632322EF/Finder.app/Frameworks/JLRoutes.framework/JLRoutes
0x100764000 - 0x100963fff libswiftCore.dylib arm64  <4866d34d21fc34eb95080c3e38b42b25> /var/mobile/Containers/Bundle/Application/61A41A40-2CCE-4A76-A5F2-4171632322EF/Finder.app/Frameworks/libswiftCore.dylib
0x100b9c000 - 0x100ba7fff libswiftCoreGraphics.dylib arm64  <697ce3f9b1f33065a9bbfcadc63dfbe3> /var/mobile/Containers/Bundle/Application/61A41A40-2CCE-4A76-A5F2-4171632322EF/Finder.app/Frameworks/libswiftCoreGraphics.dylib
0x100bc4000 - 0x100bcbfff libswiftCoreImage.dylib arm64  <31aa863fbbf33bec9b18ff3da5a171fa> /var/mobile/Containers/Bundle/Application/61A41A40-2CCE-4A76-A5F2-4171632322EF/Finder.app/Frameworks/libswiftCoreImage.dylib
0x100bd4000 - 0x100bdbfff libswiftDarwin.dylib arm64  <071cf597b326398baa0ef78d138caa69> /var/mobile/Containers/Bundle/Application/61A41A40-2CCE-4A76-A5F2-4171632322EF/Finder.app/Frameworks/libswiftDarwin.dylib
0x100bec000 - 0x100bf3fff libswiftDispatch.dylib arm64  <010e1a064c3c3b598f454939a3c639b6> /var/mobile/Containers/Bundle/Application/61A41A40-2CCE-4A76-A5F2-4171632322EF/Finder.app/Frameworks/libswiftDispatch.dylib
0x100c0c000 - 0x100c47fff libswiftFoundation.dylib arm64  <fa9a4ad5404132fda89f6e44619472b4> /var/mobile/Containers/Bundle/Application/61A41A40-2CCE-4A76-A5F2-4171632322EF/Finder.app/Frameworks/libswiftFoundation.dylib
0x100ca8000 - 0x100caffff libswiftObjectiveC.dylib arm64  <0ca0057fa6bd31d592ddcd06379ee879> /var/mobile/Containers/Bundle/Application/61A41A40-2CCE-4A76-A5F2-4171632322EF/Finder.app/Frameworks/libswiftObjectiveC.dylib
0x100cc4000 - 0x100ccffff libswiftUIKit.dylib arm64  <1f75383488ab3fd7a405c5556d67e6fa> /var/mobile/Containers/Bundle/Application/61A41A40-2CCE-4A76-A5F2-4171632322EF/Finder.app/Frameworks/libswiftUIKit.dylib
0x100ce8000 - 0x100ceffff libswiftContacts.dylib arm64  <8b040deda04737039b8c528241f396cb> /var/mobile/Containers/Bundle/Application/61A41A40-2CCE-4A76-A5F2-4171632322EF/Finder.app/Frameworks/libswiftContacts.dylib
0x120060000 - 0x12008ffff dyld arm64  <9e98992ceed735e2ac4784cb28efe7c1> /usr/lib/dyld
0x1825f0000 - 0x1825f1fff libSystem.B.dylib arm64  <c4cd04b37e5f34698856a9384aefff40> /usr/lib/libSystem.B.dylib
0x1825f4000 - 0x182647fff libc++.1.dylib arm64  <d430d0ad16893b76bbc52468f65d5906> /usr/lib/libc++.1.dylib
0x182648000 - 0x182667fff libc++abi.dylib arm64  <1c0a8ef87e8c37b2a577dc1a44e2b16e> /usr/lib/libc++abi.dylib
0x182668000 - 0x1829d4fff libobjc.A.dylib arm64  <da8e482b3e7d3c40a798a0c86a3d6890> /usr/lib/libobjc.A.dylib
0x1829d8000 - 0x1829dcfff libcache.dylib arm64  <242f50f854a1301fa6f76b4531101238> /usr/lib/system/libcache.dylib
0x1829e0000 - 0x1829ebfff libcommonCrypto.dylib arm64  <962b6da2f76d3b22afb83adeb2b030ef> /usr/lib/system/libcommonCrypto.dylib
0x1829ec000 - 0x1829effff libcompiler_rt.dylib arm64  <516b8400a98f3a4fb8f82780faca4b31> /usr/lib/system/libcompiler_rt.dylib
0x1829f0000 - 0x1829f7fff libcopyfile.dylib arm64  <c027b29d770e3a5e83aa48463916d3ed> /usr/lib/system/libcopyfile.dylib
0x1829f8000 - 0x182a53fff libcorecrypto.dylib arm64  <f3daba6e74753ddc9d7a3df953621d46> /usr/lib/system/libcorecrypto.dylib
0x182a54000 - 0x182a82fff libdispatch.dylib arm64  <aa5aa53cebb13e23a840ac24e4380c81> /usr/lib/system/libdispatch.dylib
0x182a84000 - 0x182a86fff libdyld.dylib arm64  <217f387a9d803ad1b8543fbcae5c8ec0> /usr/lib/system/libdyld.dylib
0x182a88000 - 0x182a88fff liblaunch.dylib arm64  <aec3e1f1241e33a888763b2b3d54fc16> /usr/lib/system/liblaunch.dylib
0x182a8c000 - 0x182a90fff libmacho.dylib arm64  <c0a027eb0fdf34c4948a7a579754bb94> /usr/lib/system/libmacho.dylib
0x182a94000 - 0x182a95fff libremovefile.dylib arm64  <2fb2b791a3453c019640b22cee6a0c00> /usr/lib/system/libremovefile.dylib
0x182a98000 - 0x182aaefff libsystem_asl.dylib arm64  <c0b57534f20e3488a77be968b06665d7> /usr/lib/system/libsystem_asl.dylib
0x182ab0000 - 0x182ab1fff libsystem_blocks.dylib arm64  <294794ae7146331c8fd65a1ba652e7a4> /usr/lib/system/libsystem_blocks.dylib
0x182ab4000 - 0x182b33fff libsystem_c.dylib arm64  <880a61b1eb96367f9bd7af9ec768c89b> /usr/lib/system/libsystem_c.dylib
0x182b34000 - 0x182b37fff libsystem_configuration.dylib arm64  <03109db3910b3d1db039296a8dcf3a6f> /usr/lib/system/libsystem_configuration.dylib
0x182b38000 - 0x182b3afff libsystem_containermanager.dylib arm64  <fe2c6b6a57b6325887f02a3c867d36bf> /usr/lib/system/libsystem_containermanager.dylib
0x182b3c000 - 0x182b3dfff libsystem_coreservices.dylib arm64  <4bfbf0b2029f31299048d8aa82f50cf4> /usr/lib/system/libsystem_coreservices.dylib
0x182b40000 - 0x182b56fff libsystem_coretls.dylib arm64  <a920142634313a95ad276a8e7ce041fc> /usr/lib/system/libsystem_coretls.dylib
0x182b58000 - 0x182b60fff libsystem_dnssd.dylib arm64  <aad8313dc34138e58674de8b37c8f823> /usr/lib/system/libsystem_dnssd.dylib
0x182b64000 - 0x182b85fff libsystem_info.dylib arm64  <c38ce7aacdf33d4081b7a526c8c3034e> /usr/lib/system/libsystem_info.dylib
0x182b88000 - 0x182ba9fff libsystem_kernel.dylib arm64  <13195140aba33e139925c949e4ec1e14> /usr/lib/system/libsystem_kernel.dylib
0x182bac000 - 0x182bc8fff libsystem_m.dylib arm64  <784c81a596ec3863bbb18d2c6d57d1ce> /usr/lib/system/libsystem_m.dylib
0x182bcc000 - 0x182be5fff libsystem_malloc.dylib arm64  <d540cfed29133811b05483d34c1d1b12> /usr/lib/system/libsystem_malloc.dylib
0x182be8000 - 0x182c47fff libsystem_network.dylib arm64  <8668f3c7d2583a858e982e431ff0029b> /usr/lib/system/libsystem_network.dylib
0x182c48000 - 0x182c50fff libsystem_networkextension.dylib arm64  <9294202d3e963025b416a89d70a0a9f9> /usr/lib/system/libsystem_networkextension.dylib
0x182c54000 - 0x182c5efff libsystem_notify.dylib arm64  <dd38cc9e177a31f1820c306f9a5cdb90> /usr/lib/system/libsystem_notify.dylib
0x182c60000 - 0x182c65fff libsystem_platform.dylib arm64  <7ad36a3f683830338c1023238ee36e2d> /usr/lib/system/libsystem_platform.dylib
0x182c68000 - 0x182c70fff libsystem_pthread.dylib arm64  <699f755441ea3a8da43569da86269469> /usr/lib/system/libsystem_pthread.dylib
0x182c74000 - 0x182c76fff libsystem_sandbox.dylib arm64  <fe96a44b2ade3550a73fbec1d1766da4> /usr/lib/system/libsystem_sandbox.dylib
0x182c78000 - 0x182c88fff libsystem_trace.dylib arm64  <6168fd469cbd3f4494d9a17c2128acb1> /usr/lib/system/libsystem_trace.dylib
0x182c8c000 - 0x182c91fff libunwind.dylib arm64  <667befcaf5f339fb885e77ce99512fca> /usr/lib/system/libunwind.dylib
0x182c94000 - 0x182c94fff libvminterpose.dylib arm64  <0735d1ebbd123718a8f17eb113615d6d> /usr/lib/system/libvminterpose.dylib
0x182c98000 - 0x182cbdfff libxpc.dylib arm64  <b4614a68d1cb32a99ff638ddb1181ff4> /usr/lib/system/libxpc.dylib
0x182cc0000 - 0x182ec5fff libicucore.A.dylib arm64  <5c1540546de5350ab314c1d4c8a46d1b> /usr/lib/libicucore.A.dylib
0x182ec8000 - 0x182ed9fff libz.1.dylib arm64  <c46172ce833d398a8f1b54d22a4aaeaf> /usr/lib/libz.1.dylib
0x182edc000 - 0x183254fff CoreFoundation arm64  <121118a9a44d3518b99f3ebfd8806f69> /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation
0x183258000 - 0x183268fff libbsm.0.dylib arm64  <bfee5e310ce439f0912635ac0bdbcaef> /usr/lib/libbsm.0.dylib
0x18326c000 - 0x18326cfff libenergytrace.dylib arm64  <913105a7ca583fed80e6b6329387bd34> /usr/lib/libenergytrace.dylib
0x183270000 - 0x1832e0fff IOKit arm64  <3183206b8f683af29d373817ca5ce34d> /System/Library/Frameworks/IOKit.framework/Versions/A/IOKit
0x1832e4000 - 0x183303fff libMobileGestalt.dylib arm64  <2a2b1e15b6253f42af78b4715ce4da02> /usr/lib/libMobileGestalt.dylib
0x183304000 - 0x1833eefff libxml2.2.dylib arm64  <83e0d7a7234a3d93b70b33c650cce1c5> /usr/lib/libxml2.2.dylib
0x1833f0000 - 0x18345dfff Security arm64  <74474ceb538f35bdac96f3a9b7c9c2fa> /System/Library/Frameworks/Security.framework/Security
0x183460000 - 0x1834b9fff SystemConfiguration arm64  <ede85de1bd2830518ea2caac42bad651> /System/Library/Frameworks/SystemConfiguration.framework/SystemConfiguration
0x1834bc000 - 0x1835a4fff libsqlite3.dylib arm64  <ac049ebda5c534d7a81fff7ff8924192> /usr/lib/libsqlite3.dylib
0x1835a8000 - 0x183834fff CFNetwork arm64  <479946ecd173383d803077b338576727> /System/Library/Frameworks/CFNetwork.framework/CFNetwork
0x183838000 - 0x183845fff libbz2.1.0.dylib arm64  <736f0f9f7b003dcbb91351472cedfd49> /usr/lib/libbz2.1.0.dylib
0x183848000 - 0x183861fff liblzma.5.dylib arm64  <6a0f886fe05d3250a030dd9256b14c08> /usr/lib/liblzma.5.dylib
0x183864000 - 0x18387efff libCRFSuite.dylib arm64  <8315a6fa429b3bc58da2a8d1cd259d61> /usr/lib/libCRFSuite.dylib
0x183880000 - 0x1838aafff libarchive.2.dylib arm64  <2558513a9240332998aa09cdbf49f3ec> /usr/lib/libarchive.2.dylib
0x1838ac000 - 0x1838cafff libextension.dylib arm64  <b59c905587a63c9da06bfc8594ad8ae8> /usr/lib/libextension.dylib
0x1838cc000 - 0x1838cdfff liblangid.dylib arm64  <49ce8afa64a033328e76f25af85ff4c4> /usr/lib/liblangid.dylib
0x1838d0000 - 0x183b3dfff Foundation arm64  <9c53ce054a5630c98001ecd8fd71080a> /System/Library/Frameworks/Foundation.framework/Foundation
0x183b40000 - 0x183bebfff libBLAS.dylib arm64  <c534306ddf9e3b90b25e1b66695b0dd1> /System/Library/Frameworks/Accelerate.framework/Frameworks/vecLib.framework/libBLAS.dylib
0x183bec000 - 0x183f51fff libLAPACK.dylib arm64  <ca2b7c7ec1bb30b98c037998b26e01f2> /System/Library/Frameworks/Accelerate.framework/Frameworks/vecLib.framework/libLAPACK.dylib
0x183f54000 - 0x1841b0fff vImage arm64  <a3390b9bac5135369964865d050a9b95> /System/Library/Frameworks/Accelerate.framework/Frameworks/vImage.framework/vImage
0x1841b4000 - 0x1841d6fff libvMisc.dylib arm64  <1dee62445ded325a93cfca54303bd378> /System/Library/Frameworks/Accelerate.framework/Frameworks/vecLib.framework/libvMisc.dylib
0x1841d8000 - 0x1841ecfff libLinearAlgebra.dylib arm64  <0623251016ad33349829e232f4624c7b> /System/Library/Frameworks/Accelerate.framework/Frameworks/vecLib.framework/libLinearAlgebra.dylib
0x1841f0000 - 0x1841fffff libSparseBLAS.dylib arm64  <5d1851c74bd63cb1a1b6e4dfe8dc59cc> /System/Library/Frameworks/Accelerate.framework/Frameworks/vecLib.framework/libSparseBLAS.dylib
0x184200000 - 0x18426cfff libvDSP.dylib arm64  <7a83ca773be63bbbb33a8e8d1c2da9b7> /System/Library/Frameworks/Accelerate.framework/Frameworks/vecLib.framework/libvDSP.dylib
0x184270000 - 0x184270fff vecLib arm64  <9008c7ee8a703d6faa091456a8990715> /System/Library/Frameworks/Accelerate.framework/Frameworks/vecLib.framework/vecLib
0x184274000 - 0x184274fff Accelerate arm64  <234dafe4fb09333a8bd23b74dff5670e> /System/Library/Frameworks/Accelerate.framework/Accelerate
0x184278000 - 0x1843e5fff CoreGraphics arm64  <b225beb40caf3521ad8af13986c9e25e> /System/Library/Frameworks/CoreGraphics.framework/CoreGraphics
0x1843e8000 - 0x1843fcfff GraphicsServices arm64  <9c0d8d96ee9a3abaa9ca2c1c83291ccd> /System/Library/PrivateFrameworks/GraphicsServices.framework/GraphicsServices
0x184400000 - 0x184448fff AppSupport arm64  <02b59c1c8da334a9852a3aa9bab98c07> /System/Library/PrivateFrameworks/AppSupport.framework/AppSupport
0x18444c000 - 0x18450dfff MobileCoreServices arm64  <afb0867c27e237b08d6fb64e1c44db59> /System/Library/Frameworks/MobileCoreServices.framework/MobileCoreServices
0x184510000 - 0x184558fff BaseBoard arm64  <c5af56c0a45f3308932ffa68e609ccd8> /System/Library/PrivateFrameworks/BaseBoard.framework/BaseBoard
0x18455c000 - 0x184567fff AssertionServices arm64  <6be337b9a4ad3c72b1a9f5e48ac329db> /System/Library/PrivateFrameworks/AssertionServices.framework/AssertionServices
0x184568000 - 0x184589fff BackBoardServices arm64  <1098f9a35be63f4798089c25d613565c> /System/Library/PrivateFrameworks/BackBoardServices.framework/BackBoardServices
0x18458c000 - 0x18458ffff MobileSystemServices arm64  <7eb26bea09f53c1c9e8d732f9f8ba026> /System/Library/PrivateFrameworks/MobileSystemServices.framework/MobileSystemServices
0x184590000 - 0x1845c5fff FrontBoardServices arm64  <c1c5ada9ceb03917892e043fee80857f> /System/Library/PrivateFrameworks/FrontBoardServices.framework/FrontBoardServices
0x1845c8000 - 0x1845d2fff UserNotificationServices arm64  <e8dcb070485f38b699ef6b5decf244d0> /System/Library/PrivateFrameworks/UserNotificationServices.framework/UserNotificationServices
0x1845d4000 - 0x1845f9fff SpringBoardServices arm64  <eda15d90c5b4335299934d2c5fbcbede> /System/Library/PrivateFrameworks/SpringBoardServices.framework/SpringBoardServices
0x1845fc000 - 0x18460bfff MobileKeyBag arm64  <ed676cb30f5b38c8a4b00b84e66f216d> /System/Library/PrivateFrameworks/MobileKeyBag.framework/MobileKeyBag
0x18460c000 - 0x184612fff IOSurface arm64  <5cb861f068073646a7e4f594baeb3dac> /System/Library/PrivateFrameworks/IOSurface.framework/IOSurface
0x184614000 - 0x184620fff liblockdown.dylib arm64  <46c1dbd7a8043bf2b13ba443c27c1d6d> /usr/lib/liblockdown.dylib
0x184624000 - 0x184633fff CrashReporterSupport arm64  <c01e9de574133fdf90a9526fc10457be> /System/Library/PrivateFrameworks/CrashReporterSupport.framework/CrashReporterSupport
0x184634000 - 0x184636fff IOSurfaceAccelerator arm64  <799c7fc9ad973988a2d974d16a1a8618> /System/Library/PrivateFrameworks/IOSurfaceAccelerator.framework/IOSurfaceAccelerator
0x184638000 - 0x184679fff AppleJPEG arm64  <244899ffb13030d09097bcb67d1c0f0b> /System/Library/PrivateFrameworks/AppleJPEG.framework/AppleJPEG
0x18467c000 - 0x18499dfff ImageIO arm64  <1dcba4911a183ca38528d0b4db7338a8> /System/Library/Frameworks/ImageIO.framework/ImageIO
0x1849a0000 - 0x1849a4fff TCC arm64  <785cd2d136fd3300a63f0c9b65a69b8f> /System/Library/PrivateFrameworks/TCC.framework/TCC
0x1849a8000 - 0x1849adfff AggregateDictionary arm64  <df37471257ac3732924711a6cc7aba99> /System/Library/PrivateFrameworks/AggregateDictionary.framework/AggregateDictionary
0x1849b0000 - 0x1849bdfff PowerLog arm64  <af9c5f3d9b3e3a02ab7c00bf83a3b0c3> /System/Library/PrivateFrameworks/PowerLog.framework/PowerLog
0x1849c0000 - 0x184a1dfff libTelephonyUtilDynamic.dylib arm64  <ec797d85e16f343a9b5d39ee63204090> /usr/lib/libTelephonyUtilDynamic.dylib
0x184a20000 - 0x184a32fff CommonUtilities arm64  <8f96b3d9ea333d20985ec6f5d77a5946> /System/Library/PrivateFrameworks/CommonUtilities.framework/CommonUtilities
0x184a34000 - 0x184a4bfff libcompression.dylib arm64  <fecdce66a127392f968b6b0fe72b819c> /usr/lib/libcompression.dylib
0x184a4c000 - 0x184c96fff CoreData arm64  <5d453eca9d25369fbe1152ec7aa44b1d> /System/Library/Frameworks/CoreData.framework/CoreData
0x184c98000 - 0x184c9cfff libCoreVMClient.dylib arm64  <05aad56f45e13172ad7a5d9fc156ccd1> /System/Library/Frameworks/OpenGLES.framework/libCoreVMClient.dylib
0x184ca0000 - 0x184ca4fff IOAccelerator arm64  <7889e7b1f9ad30f19539dacc3a4e1a48> /System/Library/PrivateFrameworks/IOAccelerator.framework/IOAccelerator
0x184ca8000 - 0x184ca9fff libCVMSPluginSupport.dylib arm64  <a1731d84b8ec3cc78b140153b1f97694> /System/Library/Frameworks/OpenGLES.framework/libCVMSPluginSupport.dylib
0x184cac000 - 0x184caffff libCoreFSCache.dylib arm64  <f67161256ed732219f5599270648e012> /System/Library/Frameworks/OpenGLES.framework/libCoreFSCache.dylib
0x184cb0000 - 0x184cf6fff libGLImage.dylib arm64  <d533fa1b7b5f3f1b9a38a8aa0d4b80c4> /System/Library/Frameworks/OpenGLES.framework/libGLImage.dylib
0x184cf8000 - 0x184d02fff libGFXShared.dylib arm64  <102edb9f54593c12b761398991a2878f> /System/Library/Frameworks/OpenGLES.framework/libGFXShared.dylib
0x184d04000 - 0x184d0afff IOMobileFramebuffer arm64  <33cde30cbca83a60957157185c6fbe45> /System/Library/PrivateFrameworks/IOMobileFramebuffer.framework/IOMobileFramebuffer
0x184d0c000 - 0x184d0cfff libmetal_timestamp.dylib arm64  <56af01754111343da708ce2963dc993c> /System/Library/PrivateFrameworks/GPUCompiler.framework/libmetal_timestamp.dylib
0x184d10000 - 0x184d56fff Metal arm64  <2c6f99dd5edb3b4b9bb8233c120dd370> /System/Library/Frameworks/Metal.framework/Metal
0x184d58000 - 0x184d62fff OpenGLES arm64  <cfb6dabfaa5c32bb84bfbb8c31fb2e06> /System/Library/Frameworks/OpenGLES.framework/OpenGLES
0x184d64000 - 0x184d84fff CoreVideo arm64  <653d4a02c4443e79b9dedc88fec89b4d> /System/Library/Frameworks/CoreVideo.framework/CoreVideo
0x184d88000 - 0x184d8afff OAuth arm64  <ea5d8026af173483918a09c303104746> /System/Library/PrivateFrameworks/OAuth.framework/OAuth
0x184d8c000 - 0x184dc3fff Accounts arm64  <70308607c9873d7d827735c98303ef29> /System/Library/Frameworks/Accounts.framework/Accounts
0x184dc4000 - 0x184eb6fff libiconv.2.dylib arm64  <fadcb98c1c1b356c84f83a0405014023> /usr/lib/libiconv.2.dylib
0x184eb8000 - 0x184f74fff CoreAudio arm64  <7cc6066c806039bca940716231637628> /System/Library/Frameworks/CoreAudio.framework/CoreAudio
0x184f78000 - 0x184f7bfff UserFS arm64  <8e3c32ed612f310f8253a9fc3ef365f4> /System/Library/PrivateFrameworks/UserFS.framework/UserFS
0x184f7c000 - 0x185069fff CoreMedia arm64  <6ad8fea7e3033ea8ae61060f5e19f6b6> /System/Library/Frameworks/CoreMedia.framework/CoreMedia
0x18506c000 - 0x185074fff libcupolicy.dylib arm64  <86ae97c485ea3d27880d4075a0378a12> /usr/lib/libcupolicy.dylib
0x185078000 - 0x1850eafff CoreTelephony arm64  <9d5c070b5f1536399d8dc4583ef8240e> /System/Library/Frameworks/CoreTelephony.framework/CoreTelephony
0x1850ec000 - 0x1851ccfff libFontParser.dylib arm64  <fc643a21296736b5b2b61481d61a306e> /System/Library/PrivateFrameworks/FontServices.framework/libFontParser.dylib
0x1851d0000 - 0x185250fff VideoToolbox arm64  <be617809dd93333ab50db1e22fec1c11> /System/Library/Frameworks/VideoToolbox.framework/VideoToolbox
0x185254000 - 0x185254fff FontServices arm64  <bbec62921db432008ff91dbecc9f5f63> /System/Library/PrivateFrameworks/FontServices.framework/FontServices
0x185258000 - 0x185383fff CoreText arm64  <d116fec0cc2136cb9ccff9f0b77c0427> /System/Library/Frameworks/CoreText.framework/CoreText
0x185398000 - 0x1853bffff PersistentConnection arm64  <f891b056a74d3aecbc515a5dd93a182a> /System/Library/PrivateFrameworks/PersistentConnection.framework/PersistentConnection
0x1853c0000 - 0x1853c7fff DataMigration arm64  <4d957c76b4a535349f065e4e26e32a75> /System/Library/PrivateFrameworks/DataMigration.framework/DataMigration
0x1853c8000 - 0x1856eefff AudioToolbox arm64  <732b31e0907438e38393c1401a2326b8> /System/Library/Frameworks/AudioToolbox.framework/AudioToolbox
0x1856f0000 - 0x185892fff QuartzCore arm64  <b18fd2d29c78340581fc516141c52a36> /System/Library/Frameworks/QuartzCore.framework/QuartzCore
0x185894000 - 0x18589afff Netrb arm64  <89a82d19bfa832c3be2b4d8bcdaf04c7> /System/Library/PrivateFrameworks/Netrb.framework/Netrb
0x18589c000 - 0x1858adfff libcmph.dylib arm64  <788e21990d61308cb3a8eeac6f28cda9> /usr/lib/libcmph.dylib
0x1858b0000 - 0x1858cbfff libmis.dylib arm64  <75c4bd30d45838a7a276a4c687d9676c> /usr/lib/libmis.dylib
0x1858cc000 - 0x18594dfff LanguageModeling arm64  <8f0afc836b7c31a4ba004f9ba495159c> /System/Library/PrivateFrameworks/LanguageModeling.framework/LanguageModeling
0x185950000 - 0x185a10fff ManagedConfiguration arm64  <14f012126fcc31b985744406ffabdc4c> /System/Library/PrivateFrameworks/ManagedConfiguration.framework/ManagedConfiguration
0x185a14000 - 0x185a2bfff libmarisa.dylib arm64  <5a00674979ab31b1a216a56c1f60458e> /usr/lib/libmarisa.dylib
0x185a2c000 - 0x185af3fff ProofReader arm64  <1128b6d743133c6b80b762645c0a9e54> /System/Library/PrivateFrameworks/ProofReader.framework/ProofReader
0x185af4000 - 0x185afafff MediaAccessibility arm64  <1ad85ca5a76f3e6692df4fbb1b7d1019> /System/Library/Frameworks/MediaAccessibility.framework/MediaAccessibility
0x185afc000 - 0x185b0bfff MobileAsset arm64  <10c161389d7039a0a01a8a338f349fae> /System/Library/PrivateFrameworks/MobileAsset.framework/MobileAsset
0x185b0c000 - 0x185b64fff ColorSync arm64  <9e5c88dec3743290b78e9df8ec74492c> /System/Library/PrivateFrameworks/ColorSync.framework/ColorSync
0x185b68000 - 0x185bb3fff MetalPerformanceShaders arm64  <5b5f3ef3b3503289aad9b60b08268721> /System/Library/Frameworks/MetalPerformanceShaders.framework/MetalPerformanceShaders
0x185bb4000 - 0x185fe0fff FaceCore arm64  <c081228025fe3e6bb800430051181fb4> /System/Library/PrivateFrameworks/FaceCore.framework/FaceCore
0x185fe4000 - 0x18605ffff Quagga arm64  <668639b359dd35b99fd432f187422807> /System/Library/PrivateFrameworks/Quagga.framework/Quagga
0x186060000 - 0x186202fff CoreImage arm64  <b9d5db7c62583ce5aa67a929c32ecbdd> /System/Library/Frameworks/CoreImage.framework/CoreImage
0x186204000 - 0x186235fff TextInput arm64  <99990781f4e23fa4a7603033c12e7880> /System/Library/PrivateFrameworks/TextInput.framework/TextInput
0x186238000 - 0x186242fff libAccessibility.dylib arm64  <925fa2dd49eb3ae9b2457f3bb3a56dc9> /usr/lib/libAccessibility.dylib
0x186250000 - 0x186834fff JavaScriptCore arm64  <8734a54ac2923d9b9957c1a4b2cbc9eb> /System/Library/Frameworks/JavaScriptCore.framework/JavaScriptCore
0x186a20000 - 0x1879c7fff WebCore arm64  <31d224ffb1b03ef3aef621656fa6eb83> /System/Library/PrivateFrameworks/WebCore.framework/WebCore
0x1879c8000 - 0x1879f1fff libxslt.1.dylib arm64  <e6a0f1496d6d33a2b64339fa29c76daa> /usr/lib/libxslt.1.dylib
0x1879f4000 - 0x187ad1fff WebKitLegacy arm64  <c3ad1cf573fc37f79202166b2a8e4de2> /System/Library/PrivateFrameworks/WebKitLegacy.framework/WebKitLegacy
0x187ad4000 - 0x187b8bfff CoreUI arm64  <29d544d0b53e394aabcfc44fa72488ce> /System/Library/PrivateFrameworks/CoreUI.framework/CoreUI
0x187b8c000 - 0x187bb1fff DictionaryServices arm64  <f39018d31eeb3d35b820df074d18f54b> /System/Library/PrivateFrameworks/DictionaryServices.framework/DictionaryServices
0x187bb4000 - 0x187bb4fff HangTracer arm64  <231afe8a1d2e31339c291c80e7c00bb6> /System/Library/PrivateFrameworks/HangTracer.framework/HangTracer
0x187bb8000 - 0x187c06fff PhysicsKit arm64  <9ba1d2dbac4d34b2a984036875c03449> /System/Library/PrivateFrameworks/PhysicsKit.framework/PhysicsKit
0x187c08000 - 0x187cdefff UIFoundation arm64  <9f36816edf3139ecbced1102ad25421f> /System/Library/PrivateFrameworks/UIFoundation.framework/UIFoundation
0x187ce0000 - 0x1888d8fff UIKit arm64  <1ed8c851528d340980eaf65410c76c18> /System/Library/Frameworks/UIKit.framework/UIKit
0x188900000 - 0x188925fff DataAccessExpress arm64  <4a4b7cfe1bff3250a33935a7cf001f77> /System/Library/PrivateFrameworks/DataAccessExpress.framework/DataAccessExpress
0x188944000 - 0x1889bffff AddressBook arm64  <2e4c3e893ece3d15bd32d883df32bdc7> /System/Library/Frameworks/AddressBook.framework/AddressBook
0x189084000 - 0x189090fff IntlPreferences arm64  <eef450a1e9833df1b3e778709e327ccb> /System/Library/PrivateFrameworks/IntlPreferences.framework/IntlPreferences
0x1898d8000 - 0x1898ddfff ConstantClasses arm64  <0ff28778ae7835688d319a72fa16c64d> /System/Library/PrivateFrameworks/ConstantClasses.framework/ConstantClasses
0x1898e0000 - 0x1898ebfff libChineseTokenizer.dylib arm64  <78c59c2e77013628a670dc0b21847bd1> /usr/lib/libChineseTokenizer.dylib
0x1898ec000 - 0x189b69fff libmecabra.dylib arm64  <2ec0770c42e33fb8bcebf93eca6cd406> /usr/lib/libmecabra.dylib
0x189c78000 - 0x189da5fff MobileSpotlightIndex arm64  <3b10039f2bce30b195c6d55ac84e7e06> /System/Library/PrivateFrameworks/MobileSpotlightIndex.framework/MobileSpotlightIndex
0x189da8000 - 0x189dc3fff PlugInKit arm64  <cde56da1bfbd312ea9ba248b790f8829> /System/Library/PrivateFrameworks/PlugInKit.framework/PlugInKit
0x189e24000 - 0x189e4cfff ContactsFoundation arm64  <1f04f9109c403f28bacfacc409ae4fb5> /System/Library/PrivateFrameworks/ContactsFoundation.framework/ContactsFoundation
0x189e50000 - 0x189e54fff ParsecSubscriptionServiceSupport arm64  <93e2a4e0a61230c79f3df68b46910648> /System/Library/PrivateFrameworks/ParsecSubscriptionServiceSupport.framework/ParsecSubscriptionServiceSupport
0x189e58000 - 0x189edffff Contacts arm64  <097c5169112d352cbe5155a6de1409e7> /System/Library/Frameworks/Contacts.framework/Contacts
0x189ee0000 - 0x189f1bfff CoreSpotlight arm64  <a5c849ca93973d05be0f10ae8c581aa3> /System/Library/Frameworks/CoreSpotlight.framework/CoreSpotlight
0x189f1c000 - 0x189f3bfff vCard arm64  <62dd5070a2d13de28732634ca7a4750e> /System/Library/PrivateFrameworks/vCard.framework/vCard
0x194848000 - 0x19484afff libCGXType.A.dylib arm64  <d305ba7bb90332e19ce29d9ed8a653a8> /System/Library/Frameworks/CoreGraphics.framework/Resources/libCGXType.A.dylib
0x194a40000 - 0x194a5efff libRIP.A.dylib arm64  <40a91f99969a37b4b6864eca954d3fc3> /System/Library/Frameworks/CoreGraphics.framework/Resources/libRIP.A.dylib
0x1965e0000 - 0x1965ebfff libGSFontCache.dylib arm64  <13e8d2a87baf3235aac346f540dfd38f> /System/Library/PrivateFrameworks/FontServices.framework/libGSFontCache.dylib

```
 I wonder would it be wise design to always apply URL encoding? This would prevent the crash and keep the API simple for "correct" but not "encoded" URLs. http://stackoverflow.com/a/24879794/48062
 Sure, but this obviously requires every user of the library to implement his own version of escaping. I would like to suggest offering a throws version? 

In the mean time, I'm documenting here for future searchers my version of the wrapper ‚úåÔ∏è

```
    enum NetworkError: ErrorType {
        case URLEncodeFailed
    }

    func escapeGET(base: String, path: String) throws -> String {
        guard let encodedPath = path.stringByAddingPercentEncodingWithAllowedCharacters(NSCharacterSet.URLQueryAllowedCharacterSet()) else {
            //Log.error?.message("Failed to URL encode \(path)")
            throw NetworkError.URLEncodeFailed
        }

        let URL = base + encodedPath
        //Log.debug?.message("Using GET URL \(URL)")

        return URL
    }

```
  Retrying on an authentication failure is an important feature of a project I'm currently working on, too. Would love to see this built into Alamofire, if it is simple, clean, and elegant.

For what it's worth, I found @cnoon's answer on StackOverflow to be very helpful: http://stackoverflow.com/questions/28733256/alamofire-how-to-handle-errors-globally
 @KingOfBrian I can't understand the code above totally. Can you provide the whole example?
 Has there been any progress on this front? I'm maintaining the [p2.OAuth2](https://github.com/p2/OAuth2/tree/develop/) Swift library and the (Swift) 3.0 version will have a [_DataLoader_](https://github.com/p2/OAuth2/tree/develop/Sources/DataLoader), which will (or should) mostly do what's discussed here ‚Äì intercept 401, re-perform authorization only once while enqueuing all other requests, retry the failed requests once.

I'd be interested to see how this could work with Alamofire without creating a dependency on either framework. Our DataLoader [can be used](https://github.com/p2/OAuth2/tree/develop#2-let-the-data-loader-take-over) by itself but I have not the slightest intention building this out to a sophisticated loader, that's what Alamofire is for.
 That looks like a great entry point. Maybe a bit tricky to get queueing right (enqueue calls that all fail while they wait for the first 401 to finish authorization), but should work if `sessionManager.retrier` does not block while waiting for the `completion` block to be called.
 Thanks for pointing out `RequestRetrier`, @jshier! That's great and will be a big help to our team. :)
 Great, thanks a lot for `RequestRetrier`, the OAuth2 library in v3 now works seamlessly with Alamofire with [less than 40 lines of code](https://github.com/p2/OAuth2/wiki/Alamofire-4).
  When making a multipart form data upload, my request is timing out even though a 401 is sent from the API. I inspected the API in Postman and the 401 is returned after 11ms but using Alamofire the request times out, and the response is nil in the completion block.
  I would like to implement my own handler for the authentication challenge to be able to ask the user for a username and password when a challenge is received. This would be possible in the original `NSURLSessionDelegate` by putting up a dialog for the user when the challenge is received, waiting for them to input username+password and calling the `completionHandler` from `URLSession(didReceiveChallenge: completionHandler:)` once that is done. 

This is not possible with Alamofire since both the `taskDidReceiveChallenge` and the `sessionDidReceiveChallenge` blocks are synchronous and just expect the implementation to return a credential directly and do not give access to the actual `completionHandler`. If I had the credential at that point in time I would have supplied it via `authenticate`. ;-)
The implementations in the `Request.TaskDelegate` and `Manager.SessionDelegate` also always call the `completionBlock`, so even if I got access to the `completionBlock` it would be called to early.

I originally thought I could just supply my own `NSURLSessionDelegate` to the `Manager.init` but this is not possible as it expects a `Manager.SessionDelegate` and not just any delegate protocol implementation.

Next I tried to subclass the `Manager.SessionDelegate` but _this_ is not possible because it was made final.

The `Request.TaskDelegate` is not a final class but the `Request.delegate` property is `let` so I can't change that either. 

Oh, and I can't supply my own session with my session delegate the [`Manager.init` checks that it's actually a `SessionDelegate`](https://github.com/Alamofire/Alamofire/blob/master/Source/Manager.swift#L149).

So I can't find a way to access the `completionHandler` to delay the response for the authentication challenge, not even considering how much effort it would be if there is one. And all that even though the default `NSURLSessionDelegate` has a perfectly nice way to delay the response to the authentication challenge.

Why did you lock it down so much (e.g. why can't I use my own `NSURLSessionDelegate`?) and why did you remove access to the `completionHandler` when responding to an authentication challenge?

I think the original `URLSession(didReceiveChallenge: completionHandler:)` method is awesome, because it allows you to 
1. only ask the user for a username and password when needed
2. enables you to react to changed authentication information correctly (if doing several requests in a row and the user's password changed in between, the authentication token expires or whatever)
3. Will be called again if the user enters a wrong password and the server still returns `401`. This way you get retry of incorrect passwords basically for free (the `challenge` object even tells you how many failed tries you had already) without having to do any error-code-checking-and-rescheduling-the-request.

Is there any reason you removed this ability or was it an oversight? Would you be willing to add a way to enable this kind of handling of the authentication challenge? If so, I could try to come up with a way to extend Alamofire to enable this and create a PR. 
 Thanks, I will take a look!
  HI. I am using Alamofire.upload with background session and multipart form data to upload files to our server,

But even after upload there are files in tmp directory which is not getting deleted.

Should we delete it manually?
 Thanks :) 
  The increment (++) and decrement (--) operators will be deprecated with Swift 3.

For more information, see proposal SE-0004: https://github.com/apple/swift-evolution/blob/master/proposals/0004-remove-pre-post-inc-decrement.md
 Ah hah! Should have checked. Sorry for the duplicate!
  XCode: Version 7.2.1 (7C1002)
iOS: 9.2.1
Alamofire: 3.1.3

(I read some issues here and that some things were fixed in newer versions. But my problem is very hard to reproduce in a satisfying way, so I would like ask for some insight anyway)

My app makes  an Alamofire request about every 15 seconds.
I have a client-class that wraps the Alamofire calls.
I'm creating a Manager like this (only once): 

```
init(trustedURIs:[String]){
        self.manager = {

            var serverTrustPolicies = [String: ServerTrustPolicy]()

            for uri in trustedURIs{
                serverTrustPolicies[uri] = .DisableEvaluation
            }

            let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
            configuration.HTTPAdditionalHeaders = Alamofire.Manager.defaultHTTPHeaders

            configuration.timeoutIntervalForRequest = 10
            configuration.timeoutIntervalForResource = 15

            return Alamofire.Manager(
                configuration: configuration,
                serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies)
            )

            }()
    } 
```

When the app runs for a longer time (i.e. 1h) I get this error on every call:

```
<Error>: tcp_connection_host_start 7181 DNSServiceGetAddrInfo failed: -65537
<Warning>: dnssd_clientstub deliver_request: socketpair failed 24 (Too many open files)
```

I would be very grateful for any comments on this or hints on how to reproduce it.
I will try a the current version of Alamofire and tell you if the problem still occurs.

Thanks!
 @cnoon  you were right, this is not connected to Alamofire :) Sorry if this caused work or confusion for anyone. 
The problem was within MDWamp/how I was using it. If anybody stumbles here, maybe this can help:
https://forums.developer.apple.com/message/118647#118647
https://github.com/mogui/MDWamp/issues/42
  Hello, is it possible to have a list of changes?
Updating the pod is breaking my request : 
        Alamofire.request(.GET, postEndpoint, parameters: [:], encoding: .JSON, headers: (headers as! [String : String]))
postEndpoint is my endpoint http adress.
Headers is a dictionnary to give the token to my api :  headers = ["Authorization": "google (self.token)"]
I litterally spend hours to find that the error was coming from the pod, would be great to be able to update to current version.
Regards
 Couldn't find the changelog, thanks
  When the parameters is nil,content-type in http headers didn't set.For example

``` swift
let (req,_) = ParameterEncoding.JSON(request,nil)
let type = request.valueForHTTPHeaderField("Content-Type") //nil
```

I think the Content-Type field should be set `application/json`.
    As the title already says, the new reachability feature seems a bit buggy on iOS 8. The `listener` seems to not be called each time the network status changes. Furthermore, the `network reachability status` return by the `listener` closure doesn't return the correct status.

The `status` values seem to be very random and don't represent the current state. I've tested on several iPhone devices and simulator. On iOS 9 everything works as expected.
 Btw - I switched back to https://github.com/ashleymills/Reachability.swift, and there it works properly (Simulator & Device). I have access to iOS 8 devices, so let me know if there is something I could test.
  Is it fine to add codebeat badge to README? 

codebeat is automated code review tool for Swift, Ruby & Go that helps get instant feedback on code quality. 

‚ÄúQuick wins‚Äù suggested by codebeat could be a nice candidate for a pull request and help other developers become contributors.

FYI. To be fully open and honest. I‚Äôm co-founder of codebeat.
  getting this when i'm trying to download a image.
 Can the image be normally accessed ? Please give us more detail or show your code.
  Some one tell me how to use AlamofireNetworkActivityIndicator 

I followed the following steps in link https://github.com/Alamofire/AlamofireNetworkActivityIndicator

but not working
  extension Request: CustomDebugStringConvertible 
Moved the URL.host form the guard to where it is actually needed, in my testing this was safe and allowed more requests to be converted.

not sure why URL.host was not returning a valid value but the requests succeed, so I'd love to have the curl command.
  when i upload a photo  in this code : 

```
Alamofire.upload(.POST, Url, multipartFormData: {
            multipartFormData in
            if let Data = UIImagePNGRepresentation(imageData) {
                multipartFormData.appendBodyPart(data: Data, name: "file", fileName: filename+".png", mimeType: "image/png")
                //print(Data)
            }
            multipartFormData.appendBodyPart(data: sessionId.dataUsingEncoding(NSUTF16LittleEndianStringEncoding)!, name: "session_id")
            multipartFormData.appendBodyPart(data: NSUserDefaults.standardUserDefaults().stringForKey("user_id")!.dataUsingEncoding(NSUTF8StringEncoding)!, name: "sender_id")

            }, encodingCompletion: {
                encodingResult in
                switch encodingResult {
                case .Success(let upload, _, _):
                    upload.responseJSON { response in
                        print(response)
                        //var data = JSON(response.result.value!)
                    }
                case .Failure(let encodingError):
                    print(encodingError)
                }
        })
```

FAILURE: Error Domain=NSCocoaErrorDomain Code=3840 "Invalid value around character 0." UserInfo={NSDebugDescription=Invalid value around character 0.}
and this code was worknig from 2 day ago 
    Because as everyone knows "more badges" > ¬†"fewer badges".

![medals](https://cloud.githubusercontent.com/assets/571786/13266049/72915848-da76-11e5-98b3-0ca9a474138b.jpg)
  Hi,
Is there a way to change buffer size while uploading an image ?
It seems to be limited to 32768 bytes.

Thank you.
 The upload buffer size should equal the image size.You should not modify it.
  hi.
when i ty to pass in a url that contains in it white space the app is crashing.

i saw on other issues that you answered that url cant contain white space but the api i use contains it and it is and issue for me beacause with and without space it gives differnt json response.

there is a way that i could pass it?

btw the api is the openweatherapi
 URLs can't contain white space, period.  You should try encoding the spaces.  It sounds like a crappy API, though.
  Hi

I'm experiencing a deadlock inside one of the operations in the NSUrlSession delegate queue. it happens when i'm doing at least one download and one upload simultaneously (all requests are done through the default Alamofire manager). Is there any problem doing so from multiple threads? (either in NSUrlSession or Alamofire)
it seems to be stuck on __psynch_mutexwait in one of the operations in the nsurlsession delegate queue.  

![untitled](https://cloud.githubusercontent.com/assets/16528276/13226579/c8c9503a-d99a-11e5-987e-8121030285a7.png)
 I did manage to do that, I verified that by creating an concurrent NSOperationQueue and setting it as the delegate queue when creating the session object in Alamofire and it deadlocked, but still was able to process new requests. If I leave it with default serial queue it deadlocks and the whole queue is waiting for it finish forever (therefore no new requests are processed).

After doing some research, I can see it happens in many situations, not only downlad and upload at the same time, but after a few uploads using alamofire it happens as well.
I'm also using the Pubnub library at the same time I'm using alamofire, and as far as I know this library is using NSURLConnection and not NSURLSession (as alamofire), is this could be the core to this problem?  

From looking at the memory allocations, that's what happens when this deadlock is happening : 

![alamofiredeadlock](https://cloud.githubusercontent.com/assets/16528276/13247193/b175a9fc-da20-11e5-848e-551d4d0feb93.png)

and this are NSURL objects in memory at the same time (the internal request count looks pretty bad) :

![nsurldeadlock](https://cloud.githubusercontent.com/assets/16528276/13247231/018bef82-da21-11e5-8dba-6fd4656d3872.png)

three of these internal requests are created in pubnub, one of them is created in alamofire and the other two are unknown (stack trace doesn't have enough info)
 OK,

I'm not sure you understood me correctly, because I changed the delegate queue to be concurrent just to check if that's where the deadlock happens, and it confirmed that. The deadlock was on the serial queue beforehand.

Anyway, I dug a bit deeper into this problem and I think as well it is something in my code that causes that by I'm not yet sure what, because the deadlock is inside apple's code.
the deadlock itself happens inside the delegate queue when doing two request in alamofire one after another (on of them is upload, the second could by anything), but the calls to alamofire have to be in a specific order because it does not reproduce always.
the deadlock happens inside [NSBlockOperation main] in the objc_sync_enter call that waits forever.
My calls to alamofire are on the main thread and in some of their completion blocks I do another request to alamofire (is that fine to do that?).

Edit : Also forgot to mention that I did remove all the calls to PubNub and it still reproduces so it's not related. 
 Another thing that I found from printing every time objc_sync_enter/exit inside [NSBlockOperation main] is called. Is that the extra lock does not happens in [NSBlockOperation main] but in someplace else in the code, I don't know where yet.
 Solved it, wasn't related to alamofire or nsurlsession at all. 
Caused by a call to objc_sync_enter in my code (in a totally different class from the one with the alamofire calls) on an array (Apparently, this can cause very strange deadlocks to happen)
  I'm using Xcode 7.2 and alamofire 3.0 . I'm learning alamofire and used a simple get request to get data using URL.. the app crashed with the error message mentioned above as the title. I understand that URL with special characters cannot be encoded using (URL : NSURL(String : URLString.URLString)!). Can someone please help me with how to encode URL with special characters ? and my app is crashing even if i use a URL without any special characters. I have uploaded the screenshot of my code.
<img width="1512" alt="screen shot 2016-02-22 at 11 46 52 am" src="https://cloud.githubusercontent.com/assets/17400627/13210883/9aa2bd68-d959-11e5-9c78-98b2bc75f3e4.png">

thank you in advance.
  I'm looking to use map on a Result to clean up some of my error processing in my response callback. Would a PR with map support be something that this project would like to include?
 Hello,
What i would suggest is use this Result implementation : 
https://github.com/antitypical/Result

It has map and flatMap and is already used by other swift frameworks (Reactive Cocoa for example),
This would allow to more easily interact with it.

Thanks !
 @cnoon noted, I disagree with your decision but i get it and you are the one on the project (thanks for it by the way)

For anybody who wants to use the other Result as we do here is a gist with a protocol extension :
https://gist.github.com/fchaillou/c9f798a747b939728aca

Hopes this help.
Cheers
 My two cents:

``` swift
extension Alamofire.DataResponse {
    /// Converts a response into another response by applying a transform
    /// function to the wrapped result.
    ///
    ///     // Turn DataResponse<Data> into DataResponse<Int>:
    ///     let response1: DataResponse<Data> = ...
    ///     let response2 = response1.map { data: Data in
    ///         try throwingFunction(data)
    ///         return 42
    ///     }
    ///
    /// In the example above, response2 is DataResponse<Int>.
    ///
    /// If response1 wraps an error, response2 wraps the same error.
    ///
    /// If response1 wraps Data, the body of the map closure is called. If
    /// it throws, response2 wraps the thrown error. Otherwise, response2 wraps
    /// the returned Int.
    func map<T>(_ transform: (Value) throws -> T) -> DataResponse<T> {
        return DataResponse<T>(request: request, response: response, data: data, result: result.map(transform))
    }
}

extension Alamofire.Result {
    /// Converts a result into another result by applying a transform function
    /// to the wrapped value.
    ///
    /// If the result wraps an error, the returned result wraps the same error.
    ///
    /// Otherwise, the transform closure is called. If it throws, the result
    /// wraps the thrown error.
    ///
    ///     // Turn Result<Data> into Result<Int>
    ///     let result1: Result<Data> = ...
    ///     let result2 = result1.map { (data: Data) in
    ///         try throwingFunction(data)
    ///         return 42
    ///     }
    func map<T>(_ transform: (Value) throws -> T) -> Result<T> {
        switch self {
        case .success(let value):
            do {
                let result = try transform(value)
                return .success(result)
            } catch {
                return .failure(error)
            }
        case .failure(let error):
            return .failure(error)
        }
    }
}
```
  I don't know if anyone notice but the ALAssetsLibrary will be deprecated in iOS 9.0. 
I'm suggesting an upgrade to use the Photos framework.

> IMPORTANT
> 
> The Assets Library framework is deprecated as of iOS 9.0. Instead, use the Photos framework instead, which in iOS 8.0 and later provides more features and better performance for working with a user‚Äôs photo library. For more information, see Photos Framework Reference.
> 
> In the Photos framework, the PHPhotoLibrary class manages access to and changes in the photo library, and class methods on the PHAsset and PHCollection classes and related classes provide functionality for finding photo and video assets.

https://developer.apple.com/library/ios/documentation/AssetsLibrary/Reference/ALAssetsLibrary_Class/
  It could be useful to receive, in the same way when the communication is correct, the JSON parsed into a `Dictionary` also for some network requests terminated with different codes like 300<= CODE <= 499

Now I'm parsing manually the `response.data` using `NSJSONSerialization`, but it could be useful if the library does it for us.

Thanks
  I am trying to integrate HelpScout at the moment, and am not able to attach an image:
the json looks like this:

```
let jsonObject: [String: AnyObject] = [
    "createdBy": [
        "id": 1234,
        "email": "customer@example.com",
        "type": "customer"
    ],
    "type": "customer",
    "body": "I need your help with an issue I'm having.",
    "assignedTo": [
        "id": 2222
    ],
    "status": "active",
    "createdAt": "2012-07-23T12:34:12Z",
    "cc": [
        "user1@example.com",
        "user2@example.com"
    ],
    "bcc": [
        "user3@example.com",
        "user4@example.com"
    ],
    "attachments": [
        [
            "hash": "7gjj3dg7fs3cvi956jjgfsw"
        ],
        [
            "hash": "hfsf63fjgle8jglglksd285"
        ]
    ]
]
```

The conversation is added correctly, but the attachments are ignored.
Ref to docs: http://developer.helpscout.net/help-desk-api/conversations/create-thread/
  I wrap Request to NSOperation as described here http://stackoverflow.com/a/27022598/3592936 .
My problem is that sometimes request become freeze. It never call  .response or .progress closure and my operation never completes. The .progress callback can report about 50%(e.g.) completion, but then it became silent forever.
If a have any frozen request, even if the maxConcurrentOperationCount is not reached, the new requests also doesn't call any callback. I can see that Manager call request.resume(), but no one delegate method is never called.
  I had tried lot many solutions mention in following link
https://github.com/CocoaPods/CocoaPods/issues/4294

but i can not solve problem i am using*\* xcode 7.2**
i had also tried*\* xcode 7.1**
http://stackoverflow.com/questions/30053144/dyld-library-not-loaded-with-cocoapods-0-37-and-xcode-6-3/30166310#30166310

```
dyld: Library not loaded: @rpath/Alamofire.framework/Alamofire
  Referenced from: /private/var/mobile/Containers/Bundle/Application/04CE9FBB-CEF8-47A3-A36A-ECFD281D0AE7/iOS Example.app/iOS Example
  Reason: no suitable image found.  Did find:
    /private/var/mobile/Containers/Bundle/Application/04CE9FBB-CEF8-47A3-A36A-ECFD281D0AE7/iOS Example.app/Frameworks/Alamofire.framework/Alamofire: mmap() error 1 at address=0x10017C000, size=0x00068000 segment=__TEXT in Segment::map() mapping /private/var/mobile/Containers/Bundle/Application/04CE9FBB-CEF8-47A3-A36A-ECFD281D0AE7/iOS Example.app/Frameworks/Alamofire.framework/Alamofire
```

Please help me i am using cocoapods and also tried excepting cocoapods also
 Thanks For writing and this answer is useful to me thank :) :+1: 
    I am trying to validate the below call, 

```
Alamofire.upload(
    .POST,
    "https://httpbin.org/post",
    multipartFormData: { multipartFormData in
        multipartFormData.appendBodyPart(fileURL: unicornImageURL, name: "unicorn")
        multipartFormData.appendBodyPart(fileURL: rainbowImageURL, name: "rainbow")
    },
    encodingCompletion: { encodingResult in
        switch encodingResult {
        case .Success(let upload, _, _):
            upload.responseJSON { response in
                debugPrint(response)
            }
        case .Failure(let encodingError):
            print(encodingError)
        }
    }
)
```

It always lands up in .Success case, even when I have a 404/500 error. 
How do I auto validate this call? Is there a way to call `validate` on `upload` calls?
 Usage wasn't clear from the docs. 

I did ask this on SO, no one responded, therefore I thought this could be an issue with the `Alamofire.upload()` method hence I opened an issue here. 

Thanks! 
 @cnoon Hi! I met relative problems of this issue.
when I add ```upload.validate()```, how could I handle the invalidated case (such as status code 400). Bacause the validate is in the ```.success case```, response with status 400 will be ignored instead of return ```.failure``` error. 
Thanks!  Below is a snippet taken from my recent project, you can refer this for the usage of `validate` method.

```
import Alamofire
import SwiftyJSON
...

let parameters = ["somekey": "somevalue"]
Alamofire.upload(
    .POST,
    Config.url("/url/to/profile/update"),
    headers: ["Session-Token": "mytokenstring"],
    multipartFormData: { multipartFormData in
        if let _image = self.profile.image {
            let orientationFixedImg = _image.fixOrientation()
            if let imageData = UIImageJPEGRepresentation(orientationFixedImg, 0.7) {
                multipartFormData.appendBodyPart(data: imageData, name: "photo", fileName: "profile.jpg", mimeType: "image/jpg")
            }
        }
        for (key, value) in parameters {
            multipartFormData.appendBodyPart(data: value.dataUsingEncoding(NSUTF8StringEncoding)!, name: key)
        }
    },
    encodingCompletion: { encodingResult in
        switch encodingResult {
        case .Success(let upload, _, _):
            upload.validate(statusCode: 200...299)
                .validate(contentType: ["application/json"])
                .response { response in
                    upload.responseJSON {res in
                        if(!res.result.isSuccess) {
                            //Something went wrong
                            return
                        } else {
                            let response = res.result.value as! NSDictionary
                            //success
                            //var jsonData = JSON(response)
                            //print(jsonData)
                        }
                    }
            }
        case .Failure(let encodingError):
            print(encodingError)
            //let jsonData = JSON(data: response.data!)
        }
    }
)
``` @r-a-o Thanks for your example!!  Hey!

This PR aims to make Alamofire universal framework, that can be built for all 4 platforms using a single target. This is achieved using https://github.com/mrackwitz/xcconfigs.

Basically, three xcconfigs are created to explicitly set SDK needed to build framework and test target. Then, when CI is building and running tests, it is enough to specify destinations, and Alamofire will be built for specific platform.

There are couple of things to consider here. First of all, all three dependency managers should still work as before. CocoaPods and Swift Package Manager do not rely on Xcode setup, Carthage supports uninversal frameworks, and successfuly builts 4 frameworks for all platforms. 

Second - CI setup should work correctly on all previously included configurations and OS-es.

The only downside i was able to find with this kind of Xcode setup is that example project target get's confused, and allows to select Mac, tvOS and watchOS target, even though it is explicitly configured to work only on iOS. But this probably is not a blocker.

Example of such Xcode setup would be [Lyft's Mapper](https://github.com/lyft/mapper) framework - it is configured exactly like this.

What do you think?
 @cnoon No problem) Just out of curiosity, what was the main deciding point? I'm thinking too about including such setup in my own oss solutions.
  I have the following code 

```
        Alamofire.request(.GET, url, parameters: nil, headers: nil, encoding:.JSON).responseJSON { response in
            // print(data)
            print("Hi I was called")
            switch response.result {
            case .Success(let data):
                let json = JSON(data)
                if let resData = json.arrayObject {
                    self.arrRes = resData as! [[String:AnyObject]]
                    print("count : \(self.arrRes.count)")
                    if (self.arrRes.count > 0) {

                        for index in 0...self.arrRes.count-1 {
                            print("title : \(self.arrRes[index]["title"])")
                        }
                    }
                }
            break

            case .Failure(let error):
                print("Request failed with error:\(error)")
            break
            }  
        }
```

It is quite clear from the response that the GET request is being sent twice :

Hi I was called
count : 3
title : Optional(First)
title : Optional(Second)
title : Optional(Third)
Hi I was called
count : 3
title : Optional(First)
title : Optional(Second)
title : Optional(Third)
 Hello, I'm seeing the same results posted here.  

My unit test code

`class UserStoreTests: XCTestCase {
    func testAuthenticateWithEmailAndPassword() {
        let exp = expectationWithDescription("Authenticate user with email and password")
        UserStore.sharedStore.authenticate(withEmail: "test@email.com", withPassword: "password1") { (success, error) in
            exp.fulfill()
        }
        waitForExpectationsWithTimeout(10, handler: nil)
    }
}`
[UserStore.pdf](https://github.com/Alamofire/Alamofire/files/204757/UserStore.pdf)
[UserStoreTests.pdf](https://github.com/Alamofire/Alamofire/files/204758/UserStoreTests.pdf)

My class containing Alamofire 

`import Foundation
import Alamofire
class UserStore: NSObject {
    static let sharedStore:UserStore = UserStore()
    static let root:String = "http://jsonplaceholder.typicode.com"
    private override init() {
        super.init()

```
}

func authenticate(withEmail email:String, withPassword password:String, completion:(success:Bool, error:NSError?)->Void) {
    let params = ["email":email, "password":password]
    Alamofire.request(.POST, "\(UserStore.root)/posts", parameters: params, encoding: .JSON).responseJSON { response in
        if let jsonData = response.result.value {
            print(jsonData)
        }
        //TODO: Incomplete method
```

//            completion(success: true, error: nil)
        }
    }

```
func createAccount(withEmail email:String, withPassword password:String, completion:(success:Bool, error:NSError?)->Void) {
    completion(success: true, error: nil)
}
```

}`

And the Unit Test output log

11:01:58.887 Camtasia[49323:16088704] _XCT_testBundleReadyWithProtocolVersion:minimumVersion: reply received
11:01:58.893 Camtasia[49323:16088704] _IDE_startExecutingTestPlanWithProtocolVersion:16
Test Suite 'Selected tests' started at 2016-04-05 11:01:58.897
Test Suite 'UserStoreTests' started at 2016-04-05 11:01:58.898
Test Case '-[UserStoreTests.UserStoreTests testAuthenticateWithEmailAndPassword]' started.
{
    email = "test@email.com";
    id = 101;
    password = password1;
}
{
    email = "test@email.com";
    id = 101;
    password = password1;
}
/Users/___/Documents/Camtasia/UserStoreTests/UserStoreTests.swift:28: error: -[UserStoreTests.UserStoreTests testAuthenticateWithEmailAndPassword] : Asynchronous wait failed: Exceeded timeout of 10 seconds, with unfulfilled expectations: "Authenticate user with email and password".
Test Case '-[UserStoreTests.UserStoreTests testAuthenticateWithEmailAndPassword]' failed (10.013 seconds).
Test Suite 'UserStoreTests' failed at 2016-04-05 11:02:08.911.
     Executed 1 test, with 1 failure (0 unexpected) in 10.013 (10.013) seconds
Test Suite 'Selected tests' failed at 2016-04-05 11:02:08.912.
     Executed 1 test, with 1 failure (0 unexpected) in 10.013 (10.015) seconds

Even with "100s" of tests there are 100s of opportunity for bugs ;) 

Using pod: pod 'Alamofire', '~> 3.0'
 Sorry about the above formatting.  It just is not liking the code tags for some reason.  I attached both of the files mentioned here as .PDFs anyone interested could see exactly what the class looks like.  

Note that it meets the same criteria you stated.
1. It's not called more than once, at least to my knowledge
2. There aren't multiple print statements 

Yet I'm experience the same result as the original poster...the function is being called twice. 

UserStore is the only class that interacts or rather will be interacting with my server.  It's a singleton class and guaranteed to only be instantiated once when called through the shared instance static variable.  

So I too am curious as to why I'm seeing this result. 
 Sure I'll create a simple Xcode project and zip it up for you.

The unit test will be very simple / exactly like the above.  

Apologies for attaching PDF file.  GitHub does not allow *.swift files to be uploaded. 

Not sure if you mean "Pull Request" by your acronym "PR". 
 @cnoon, after updating to your latest version 3.3.1 I believe, I'm unable to reproduce the issue.  So I believe the repeat calls was fixed :) 

Congrats on that! 

Keep up the great work!

Side note, I probably shouldn't have ran a pod update since it disabled / fixed the bug.  Oh well. 
 Please see https://stackoverflow.com/questions/43871936/alamofire-called-twice 

It could be that you are trying to debug the request itself, which could be causing the request to fire even though you are intending the printing of the request to be more of a 'dry run'  Error Domain=com.alamofire.error Code=-6006 "JSON could not be serialized. Input data was nil or zero length." UserInfo={NSLocalizedFailureReason=JSON could not be serialized.

And below is my call method

``` javascript
func weatherAPICalls (let selectedCityName : String) {

        apiManager.currentWeatherByCityNameAsJson(selectedCityName) { (json) -> Void in
            print(json)
             self.headerWeather = Weather(json: json)
        }

        apiManager.forecastWeatherByCityNameAsJson(selectedCityName) { (json) -> Void in
          print( json["list"])
        self.hourlyWeatherForecast = json["list"].arrayValue.map {WeatherForeCast(hourlyForecast:$0)}

        apiManager.dailyForecastWeatherByCityNameAsJson(selectedCityName) { (json) -> Void in
          print(json["list"])

         self.dailyWeatherForecast = json["list"].arrayValue.map {WeatherDailyForeCast(dailyForecast:$0)}
                }
            }
    }
```
  I would like to connect to the host with alamofire but the host needs to cert.pem key.pem ca.pem  files.
How can I do?
If possible have examples code?

Thanks
 @cnoon That's a horrible answer to this question.   First of all, the docs expect people understand exactly how certificates work, and most of us are just given some type of file from the client.  Second, that code DOES NOT WORK if you pass in a PEM file, so why are you pointing at it?  If you look at the certificatesInBundle it will only look for CER, CRT, and DER.  So PEM is obviously out.  
 @cnoon What details would you like to know?  I have a similar issue to @alessiofx and I posted a [support query to Stack Overflow](http://stackoverflow.com/questions/38365996/alamofire-and-pem-certificate) on Thursday with more details. 
 If you give me an email address I can send you the URL and key that I'm using for my testing.
  This pull requests corrects the spelling of **CocoaPods** ü§ì
https://github.com/CocoaPods/shared_resources/tree/master/media

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">One day I‚Äôll make a bot that looks through the READMEs of all Pods, looks to see if it uses ‚ÄúCocoapods‚Äù and PRs ‚ÄúCocoaPods‚Äù :D</p>&mdash; √òrta (@orta) <a href="https://twitter.com/orta/status/697374357975388160">February 10, 2016</a></blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
 :tada: 
  My server gives back some information in the form of json when getting errors such as 403 // 409...etc, however I can't figure out how to retrieve that information in error cases.  Here is my code:

```

Alamofire.request(mutableURLRequest).validate().responseJSON() {
    (response) in
    switch response.result {
        case .Success(let data):
            if let jsonResult = data as? NSDictionary {
                completion(jsonResult, error: nil)
            } else if let jsonArray = data as? NSArray {
                let jsonResult = ["array" : jsonArray]
                completion(jsonResult, error: nil)
            }
        case .Failure(let error):
            //error tells me 403
            //response.result.data can't be cast to NSDictionary or NSArray like
            //the successful cases, how do I get the response body?
    }
```

I've queried pretty much every object attached to the response, but it doesn't seem to give me the response body back in the case of HTTP errors.  I see the information in developer tools if I hit the API via chrome.  Is there a work-around or something I'm missing here?
 Haha I did, you responded so much quicker here =P.

http://stackoverflow.com/questions/35088237/any-way-to-get-the-response-body-during-http-errors
  The build page is also failing too. 
https://travis-ci.org/Alamofire/Alamofire
  Hello!

We are using Alamofire in our project and it is great! :)
But we faced a situation when we need to get some parameter in query string look like this: 

key=value1&key=value2&key=value3

We are encoding parameters into request ourselves due to Alamofire's support only for:

key[]=value1&key[]=value2&key[]=value3
key[1]=value1&key[2]=value2&key[3]=value3

It would be great if you will support this additional format, for example when Set<String> is passed. Thanks in advance!
  Invoking the request method with a `[String, AnyObject]` dictionary passed as argument yields query parameters where Bools are encoded as 0s and 1s. I would like them to be encoded as `true` and `false` respectively. The parameter encoding in this request was `.URL`.

``` swift
Alamofire.request(endpoint.method(), url, parameters: parameters, encoding: encoding, headers: headers)
         .validate(statusCode: 200...299)
         .responseJSON { response in self.handleRequestResponse(response, observer: observer) }
```

I'm using Swift 2 in XCode 7.2.1 with a mixed codebase.
 But you wouldn't run URL query parameters through `NSJSONSerialization` would you?
Anyways, I'm monitoring the traffic with TCPMon and it shows the URLs with `Bool`s encoded as 0s and 1s. Right now I'm working around this by converting `Bool` values to `String`s before making the request. Maybe this is intended behavior, if so let me know.

Cheers
 No worries, thanks for looking into this!
 Alright, I understand the reasoning behind it and it seems reasonable from your point of view. I converted the values to string now anyway, so it's not a big problem for me. Again thanks for looking into it and I'll look forward to Swift 3! :smiley: 
 Hey guys,

I'm looking at the queryComponents method in ParameterEncoding and I can see that "1" and "0" is deliberately set as a representation of a bool value in a URL. In Swift 3/Alamofire 4, it is still the case. Why is that? Why is it not "true" and "false"? I feel that I'm missing something here but I don't know what.

I can also see that you guys changed the input value type to Any so a "pure" Swift bool can be passed in. I tried printing 'true' and it printed "true". @jshier That is unfortunate indeed‚Ä¶ Where are the rfc guys when we need them!  ```
Alamofire.request(.POST, "example.com/api/test", parameters: ["name": "", "email":  "", "phone": "", "password": ""])
                .responseJSON { response in
                    print(response.response?.statusCode) // 422
                    switch response.result {
                    case .Success(let data):
                        print("SUCCESS")
                    case .Failure(let error):
                        print("Request failed with error: \(error)")
                    }
            }
```

The above call always lands up in .Success block even when the error code 422 is sent from server! 

Shouldn't 422 be treated as Failure? 
 Yup, got that right after I raised this issue. To be honest its confusing. I was expecting the response code validation to happen automatically. 
Anyways thanks for your reply! 
  Wow Dude @cnoon , this is much more complete than what I had in mind, thank you. 
I need to try it and see how I can collect all the metrics (`timelines` I guess) in one location to log or send back to a log aggregator.  
 thanks @jshier I think I'd do the same. 
  in iOS8.1, NetworkReachabilityStatus is always notReachable, how to fix it, thanks
  Hi,

I have a question regarding how Alamofire works with in progress background transfers.

So, imagine this scenario:
1. User opens up your app
2. User queues up a collection of background transfers
3. User backgrounds your app
4. User launches other apps enough to force the system to terminate your app
5. User relaunches your app while at least one of your previous background transfers were running.

Some questions here:
1. Is this a realistic edge case?
2. It looks like the existing Alamofire SessionDelegate multiplexes the delegate callbacks based on taskIdentifiers instead of by URL, which means that client code would have to recreate the tasks that were running apriori in order to match up by taskIdentifier again. (Seems like a very hacky, buggy solution).
3. Apps would have to check at app launch to see if there are any background transfers that are running, and override Alamofire's SessionDelegate using the blocks.

The question I have with number 3 is if we should be removing the override once all background transfers have completed? What happens if the user starts new ones? In this scenario, it seems like I would be working around Alamofire's code a lot...

Thanks,

Ronak
 It looks like you can continue to use the block structure you have now except for two things:
1. Stop multiplexing from a nsurlsession task to a request object by using task identifiers. It would be better to multiplex by url. I don't ever imagine people would want to send multiple requests for the same url concurrently.
2. You schedule the call to the background completion handler onto the utility queue, which dispatches back to main.

With these changes, people can continue to use the existing set up.

You would query your persistence store to see which downloads are still running, recreate the request objects. The rest runs as it always has.

What do you think?
 What I mean by multiplexing is that you currently have a dictionary in the SessionDelegate where you map from NSURLSessionTask to Request using the task identifier.

That wouldn't hold up across app restarts since we lose the mapping from a Request Object to its task identifier. It would be better to use the url in that dictionary since the app would know which downloads are still in progress (assuming the app is keeping track in a persistence store of some kind) and can easily recreate the Request objects.

Te second point I was making was there is a slight threading concern with the way the request closures work in that they are dispatched to the set table queue.

The main points I am trying to make here are that I don't think you would have to re-engineer your code so much and tear it all up for this.

Sent from my iPhone

> On Feb 9, 2016, at 12:31 AM, Christian Noon notifications@github.com wrote:
> 
> I don't understand your reasoning here @ronak2121. First off, I don't understand what you mean by multiplexing in #1. As for #2, I don't understand what that accomplishes. Additionally, recreating requests is only easy if you have them completely abstracted and all callbacks are done using a delegate pattern, not closures.
> 
> ‚Äï
> Reply to this email directly or view it on GitHub.
  Stackoverflow didn't know the answer, so I thought I'd ask it here. Can Alamofire be used to connect to a streaming api which constantly returns new data? I am trying to do it with a regular request but keep getting a 400 back as a status code. Thanks.
 https://github.com/Alamofire/Alamofire/issues/832 may put you on the right track
 So is this not achievable with Alamofire?
  ‚Ä¶r newest Swift toolchain.
 This commit allows Alamofire to build under the Swift development snapshot 2016-02-03.
 Thanks!
  I'm passing in at a empty dictionary _[String, String]_ like so,

`let tempURLRequest = ParameterEncoding.JSON.encode(NSURLRequest(URL: URL), parameters: myDictionary).0` 

The request that gets generated is valid except the **body is empty** and there is no **content-type** which makes our spring/jhipster server throw exceptions _"Required request body is missing"_. I'm certainly no expert on the JSON RFC but I'm pretty confident that the generally accepted definition says that at a minimum you need, _{}_ or _[]_. It looks like this is getting caught in _ParameterEncoding.swift, public enum ParameterEncoding, line 85_ which skips apply parameters and setting a content type in the headers.

_NSJSONSerialization_, which you use internally, would correctly parse this into_ {\n\n}_.

So my questions are, 
1. Since I'm basically sending an empty POST request with no body or content-type should my API not be explicitly treating all requests to that endpoint as JSON content type and actually check whats in the header. AKA does best practice dictate that the API should be resilient towards the content-type in the request?
2. Is there a known / accepted work around to sending up an empty dictionary with a JSON content type.
3. Is this a flat out bug?

Although I feel like my first question is definitely part of the answer, using the encode method and explicitly telling it to use JSON should still produce a application/JSON content-type at a bare minimum.

Lastly big thanks for the excellent frameworks!
 Thanks for the quick reply @cnoon, I'm very much looking forward to hearing about your discussion
  my code => `import UIKit
import Alamofire
import SwiftyJSON

class ViewController: UIViewController {

```
@IBOutlet weak var txtOutput: UITextView!
@IBAction func btnSendRequest(sender: AnyObject) {

    let serverTrustPolicies: [String: ServerTrustPolicy] = [
        "192.168.1.110": .PinCertificates(
            certificates: ServerTrustPolicy.certificatesInBundle(),
            validateCertificateChain: true,
            validateHost: true
        ),
        "localhost": .DisableEvaluation
    ]


    let manager = Manager(
        serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies)
    )

    let params = [

        "username": "fd@fd.com",
        "password": "Ramazan 2",
        "grant_type": "password"

    ]
    manager.request(.POST, "https://192.168.1.110:8082/token", parameters: params)
        .responseString(){
            response in
            self.txtOutput.text = response.description
        }
        .responseJSON(){
            JSON in
            print(JSON)
    }
}
```

}`

output => 

> FAILURE: Error Domain=NSURLErrorDomain Code=-999 "cancelled" UserInfo={NSErrorFailingURLKey=https://192.168.1.110:8082/token, NSLocalizedDescription=cancelled, NSErrorFailingURLStringKey=https://192.168.1.110:8082/token}
> if you are help to me i'll be so happy.. 

Thanks 
 Mahmut Akyol your problem is solved? I have the same problem if know answer me.Thanks
 `
let manager = Alamofire.Manager.sharedInstance

func Config(manager: Alamofire.Manager){

```
    manager.delegate.sessionDidReceiveChallenge = { session, challenge in
        var disposition: NSURLSessionAuthChallengeDisposition = .PerformDefaultHandling
        var credential: NSURLCredential?

        if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
            disposition = NSURLSessionAuthChallengeDisposition.UseCredential
            credential = NSURLCredential(forTrust: challenge.protectionSpace.serverTrust!)
        } else {
            if challenge.previousFailureCount > 0 {
                disposition = .CancelAuthenticationChallenge
            } else {
                credential = manager.session.configuration.URLCredentialStorage?.defaultCredentialForProtectionSpace(challenge.protectionSpace)

                if credential != nil {
                    disposition = .UseCredential
                }
            }
        }
        return (disposition, credential)
    }
}
```

manager.request(.GET, urlString, parameters: param, headers: header).responseJSON(){
                json in
                if let value = json.result.value  {
                    let _json = JSON(value)
                        print(_json)
                }
            }

`
    Hi,

i have a iPhone App which authenticates with a client certificate. This is working on the iPhone, but not on the Apple Watch.

My Code for the manager:

```
        let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
        configuration.requestCachePolicy = .ReloadIgnoringLocalCacheData
        configuration.URLCache = nil

        self.manager = Alamofire.Manager(configuration: configuration)

        self.manager.delegate.sessionDidReceiveChallenge = { session, challenge in
            if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
                return (.UseCredential, NSURLCredential(forTrust: challenge.protectionSpace.serverTrust!))
            }
            else {
                return (.UseCredential, self.credentials)
            }
        }

```

If I debug this code on the Apple Watch I can see that the challenge comes in. After responding to the challenge with my credentials I get this error:

> Error Domain=NSURLErrorDomain Code=-999 "cancelled" UserInfo={NSErrorFailingURLKey="", NSErrorFailingURLStringKey="", NSLocalizedDescription=cancelled}

EDIT:

This is also happening when I use NSURLRequest, NSURLSessionConfiguration and NSURLSession. Its not a problem with Alamofire. I filed a bug at Apple.
  On our angular web app, we have an intercepter that runs on any HTTP request we make to our API and checks if the API returns a `401`, which allows us to know the user's session is no longer valid. Is there any way to do this with Alamofire?
 check @cnoon's answer on [StackOverflow](http://stackoverflow.com/questions/28733256/alamofire-how-to-handle-errors-globally/28748683#28748683)
  Hey 
I'm new to Carthage. So what i basically did is create a new "Single View Application" with Xcode. Added a Cartfile in the folder where the *.xcodeproj lives and ran `carthage update`.

This is my Cartfile:

```
github "Alamofire/Alamofire" ~> 3.0
```

This is the output which I get when running `carthage update`:

```
macbook-pro:carthage-test sk$ carthage update
*** Fetching Alamofire
*** Checking out Alamofire at "3.1.5"
*** xcodebuild output can be found in /var/folders/rz/gf7bfxg576qd2chlxsv61vb80000gn/T/carthage-xcodebuild.cG0Hvm.log
*** Building scheme "Alamofire OSX" in Alamofire.xcworkspace
*** Building scheme "Alamofire watchOS" in Alamofire.xcworkspace
** CLEAN FAILED **


The following build commands failed:
    Check dependencies
(1 failure)
** BUILD FAILED **


The following build commands failed:
    Check dependencies
(1 failure)
A shell task failed with exit code 65:
** CLEAN FAILED **


The following build commands failed:
    Check dependencies
(1 failure)
** BUILD FAILED **


The following build commands failed:
    Check dependencies
(1 failure) 
```

And here is the log: 

```
/usr/bin/xcrun xcodebuild -workspace /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Alamofire.xcworkspace -scheme Alamofire OSX -configuration Release ONLY_ACTIVE_ARCH=NO CODE_SIGNING_REQUIRED=NO CODE_SIGN_IDENTITY= clean buildBuild settings from command line:
    CODE_SIGN_IDENTITY = 
    CODE_SIGNING_REQUIRED = NO
    ONLY_ACTIVE_ARCH = NO

Build Preparation
Build task concurrency set to 8 via user default IDEBuildOperationMaxNumberOfConcurrentCompileTasks

=== CLEAN TARGET Alamofire OSX OF PROJECT Alamofire WITH CONFIGURATION Release ===

Check dependencies

Create product structure
/bin/mkdir -p /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework/Versions/A/Modules
/bin/ln -sfh Versions/Current/Modules /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework/Modules
/bin/mkdir -p /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework/Versions/A/Headers
/bin/mkdir -p /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework/Versions/A/Resources
/bin/ln -sfh A /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework/Versions/Current
/bin/ln -sfh Versions/Current/Resources /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework/Resources
/bin/ln -sfh Versions/Current/Headers /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework/Headers
/bin/ln -sfh Versions/Current/Alamofire /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework/Alamofire

Clean.Remove clean /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build
    builtin-rm -rf /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build

Clean.Remove clean /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework.dSYM
    builtin-rm -rf /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework.dSYM

Clean.Remove clean /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework
    builtin-rm -rf /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework

** CLEAN SUCCEEDED **

Build Preparation
Build task concurrency set to 8 via user default IDEBuildOperationMaxNumberOfConcurrentCompileTasks

=== BUILD TARGET Alamofire OSX OF PROJECT Alamofire WITH CONFIGURATION Release ===

Check dependencies

Write auxiliary files
write-file /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Alamofire-project-headers.hmap
/bin/mkdir -p /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Objects-normal/x86_64
write-file /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Objects-normal/x86_64/Alamofire.LinkFileList
write-file /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Alamofire.hmap
write-file /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Alamofire-generated-files.hmap
write-file /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/module.modulemap
write-file /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/unextended-module-overlay.yaml
/bin/mkdir -p /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/DerivedSources
write-file /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/DerivedSources/Alamofire_vers.c
write-file /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Alamofire-all-target-headers.hmap
write-file /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Objects-normal/x86_64/Alamofire\ OSX-OutputFileMap.json
write-file /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/unextended-module.modulemap
write-file /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Alamofire-all-non-framework-target-headers.hmap
write-file /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/swift-overrides.hmap
write-file /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml
write-file /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Alamofire-own-target-headers.hmap

Create product structure
/bin/mkdir -p /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework/Versions/A/Modules
/bin/ln -sfh Versions/Current/Modules /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework/Modules
/bin/mkdir -p /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework/Versions/A/Headers
/bin/mkdir -p /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework/Versions/A/Resources
/bin/ln -sfh A /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework/Versions/Current
/bin/ln -sfh Versions/Current/Resources /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework/Resources
/bin/ln -sfh Versions/Current/Headers /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework/Headers
/bin/ln -sfh Versions/Current/Alamofire /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework/Alamofire

ProcessInfoPlistFile /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework/Versions/A/Resources/Info.plist Source/Info.plist
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    builtin-infoPlistUtility /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Info.plist -expandbuildsettings -platform macosx -o /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework/Versions/A/Resources/Info.plist

CompileSwiftSources normal x86_64 com.apple.xcode.tools.swift.compiler
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swiftc -incremental -module-name Alamofire -O -sdk /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk -target x86_64-apple-macosx10.9 -g -module-cache-path /Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -Xfrontend -serialize-debugging-options -application-extension -I /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -F /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -c -j8 /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Upload.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Request.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Error.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Manager.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Response.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Stream.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Download.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Validation.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Result.swift -output-file-map /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Objects-normal/x86_64/Alamofire\ OSX-OutputFileMap.json -parseable-output -serialize-diagnostics -emit-dependencies -emit-module -emit-module-path /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Objects-normal/x86_64/Alamofire.swiftmodule -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/swift-overrides.hmap -Xcc -iquote -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Alamofire-generated-files.hmap -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Alamofire-own-target-headers.hmap -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Alamofire-all-non-framework-target-headers.hmap -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Alamofire-project-headers.hmap -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/include -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/DerivedSources/x86_64 -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/DerivedSources -emit-objc-header -emit-objc-header-path /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Objects-normal/x86_64/Alamofire-Swift.h -import-underlying-module -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/unextended-module-overlay.yaml -Xcc -working-directory/Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire

CompileSwift normal x86_64 /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Upload.swift
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c -primary-file /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Upload.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Request.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Error.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Manager.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Response.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Stream.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Download.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Validation.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Result.swift -target x86_64-apple-macosx10.9 -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk -I /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -F /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -application-extension -g -import-underlying-module -module-cache-path /Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -serialize-debugging-options -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/swift-overrides.hmap" -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-generated-files.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-own-target-headers.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-all-non-framework-target-headers.hmap" -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-project-headers.hmap" -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/include -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/DerivedSources/x86_64" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/DerivedSources" -Xcc -ivfsoverlay -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/unextended-module-overlay.yaml" -Xcc -working-directory/Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire -emit-module-doc-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Upload~partial.swiftdoc" -O -module-name Alamofire -emit-module-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Upload~partial.swiftmodule" -serialize-diagnostics-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Upload.dia" -emit-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Upload.d" -emit-reference-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Upload.swiftdeps" -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Upload.o"

CompileSwift normal x86_64 /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Upload.swift -primary-file /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Request.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Error.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Manager.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Response.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Stream.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Download.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Validation.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Result.swift -target x86_64-apple-macosx10.9 -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk -I /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -F /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -application-extension -g -import-underlying-module -module-cache-path /Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -serialize-debugging-options -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/swift-overrides.hmap" -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-generated-files.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-own-target-headers.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-all-non-framework-target-headers.hmap" -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-project-headers.hmap" -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/include -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/DerivedSources/x86_64" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/DerivedSources" -Xcc -ivfsoverlay -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/unextended-module-overlay.yaml" -Xcc -working-directory/Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire -emit-module-doc-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/ParameterEncoding~partial.swiftdoc" -O -module-name Alamofire -emit-module-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/ParameterEncoding~partial.swiftmodule" -serialize-diagnostics-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/ParameterEncoding.dia" -emit-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/ParameterEncoding.d" -emit-reference-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/ParameterEncoding.swiftdeps" -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/ParameterEncoding.o"

CompileSwift normal x86_64 /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Request.swift
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Upload.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift -primary-file /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Request.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Error.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Manager.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Response.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Stream.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Download.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Validation.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Result.swift -target x86_64-apple-macosx10.9 -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk -I /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -F /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -application-extension -g -import-underlying-module -module-cache-path /Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -serialize-debugging-options -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/swift-overrides.hmap" -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-generated-files.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-own-target-headers.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-all-non-framework-target-headers.hmap" -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-project-headers.hmap" -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/include -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/DerivedSources/x86_64" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/DerivedSources" -Xcc -ivfsoverlay -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/unextended-module-overlay.yaml" -Xcc -working-directory/Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire -emit-module-doc-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Request~partial.swiftdoc" -O -module-name Alamofire -emit-module-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Request~partial.swiftmodule" -serialize-diagnostics-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Request.dia" -emit-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Request.d" -emit-reference-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Request.swiftdeps" -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Request.o"

CompileSwift normal x86_64 /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Upload.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Request.swift -primary-file /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Error.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Manager.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Response.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Stream.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Download.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Validation.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Result.swift -target x86_64-apple-macosx10.9 -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk -I /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -F /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -application-extension -g -import-underlying-module -module-cache-path /Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -serialize-debugging-options -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/swift-overrides.hmap" -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-generated-files.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-own-target-headers.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-all-non-framework-target-headers.hmap" -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-project-headers.hmap" -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/include -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/DerivedSources/x86_64" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/DerivedSources" -Xcc -ivfsoverlay -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/unextended-module-overlay.yaml" -Xcc -working-directory/Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire -emit-module-doc-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/ResponseSerialization~partial.swiftdoc" -O -module-name Alamofire -emit-module-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/ResponseSerialization~partial.swiftmodule" -serialize-diagnostics-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/ResponseSerialization.dia" -emit-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/ResponseSerialization.d" -emit-reference-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/ResponseSerialization.swiftdeps" -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/ResponseSerialization.o"

CompileSwift normal x86_64 /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Error.swift
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Upload.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Request.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift -primary-file /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Error.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Manager.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Response.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Stream.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Download.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Validation.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Result.swift -target x86_64-apple-macosx10.9 -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk -I /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -F /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -application-extension -g -import-underlying-module -module-cache-path /Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -serialize-debugging-options -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/swift-overrides.hmap" -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-generated-files.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-own-target-headers.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-all-non-framework-target-headers.hmap" -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-project-headers.hmap" -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/include -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/DerivedSources/x86_64" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/DerivedSources" -Xcc -ivfsoverlay -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/unextended-module-overlay.yaml" -Xcc -working-directory/Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire -emit-module-doc-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Error~partial.swiftdoc" -O -module-name Alamofire -emit-module-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Error~partial.swiftmodule" -serialize-diagnostics-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Error.dia" -emit-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Error.d" -emit-reference-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Error.swiftdeps" -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Error.o"

CompileSwift normal x86_64 /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Manager.swift
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Upload.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Request.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Error.swift -primary-file /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Manager.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Response.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Stream.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Download.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Validation.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Result.swift -target x86_64-apple-macosx10.9 -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk -I /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -F /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -application-extension -g -import-underlying-module -module-cache-path /Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -serialize-debugging-options -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/swift-overrides.hmap" -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-generated-files.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-own-target-headers.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-all-non-framework-target-headers.hmap" -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-project-headers.hmap" -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/include -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/DerivedSources/x86_64" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/DerivedSources" -Xcc -ivfsoverlay -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/unextended-module-overlay.yaml" -Xcc -working-directory/Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire -emit-module-doc-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Manager~partial.swiftdoc" -O -module-name Alamofire -emit-module-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Manager~partial.swiftmodule" -serialize-diagnostics-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Manager.dia" -emit-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Manager.d" -emit-reference-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Manager.swiftdeps" -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Manager.o"

CompileSwift normal x86_64 /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Response.swift
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Upload.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Request.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Error.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Manager.swift -primary-file /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Response.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Stream.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Download.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Validation.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Result.swift -target x86_64-apple-macosx10.9 -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk -I /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -F /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -application-extension -g -import-underlying-module -module-cache-path /Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -serialize-debugging-options -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/swift-overrides.hmap" -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-generated-files.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-own-target-headers.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-all-non-framework-target-headers.hmap" -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-project-headers.hmap" -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/include -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/DerivedSources/x86_64" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/DerivedSources" -Xcc -ivfsoverlay -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/unextended-module-overlay.yaml" -Xcc -working-directory/Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire -emit-module-doc-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Response~partial.swiftdoc" -O -module-name Alamofire -emit-module-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Response~partial.swiftmodule" -serialize-diagnostics-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Response.dia" -emit-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Response.d" -emit-reference-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Response.swiftdeps" -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Response.o"

CompileSwift normal x86_64 /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.swift
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Upload.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Request.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Error.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Manager.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Response.swift -primary-file /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Stream.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Download.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Validation.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Result.swift -target x86_64-apple-macosx10.9 -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk -I /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -F /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -application-extension -g -import-underlying-module -module-cache-path /Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -serialize-debugging-options -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/swift-overrides.hmap" -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-generated-files.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-own-target-headers.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-all-non-framework-target-headers.hmap" -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-project-headers.hmap" -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/include -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/DerivedSources/x86_64" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/DerivedSources" -Xcc -ivfsoverlay -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/unextended-module-overlay.yaml" -Xcc -working-directory/Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire -emit-module-doc-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Alamofire~partial.swiftdoc" -O -module-name Alamofire -emit-module-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Alamofire~partial.swiftmodule" -serialize-diagnostics-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Alamofire.dia" -emit-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Alamofire.d" -emit-reference-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Alamofire.swiftdeps" -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Alamofire.o"

CompileSwift normal x86_64 /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Upload.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Request.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Error.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Manager.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Response.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.swift -primary-file /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Stream.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Download.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Validation.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Result.swift -target x86_64-apple-macosx10.9 -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk -I /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -F /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -application-extension -g -import-underlying-module -module-cache-path /Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -serialize-debugging-options -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/swift-overrides.hmap" -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-generated-files.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-own-target-headers.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-all-non-framework-target-headers.hmap" -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-project-headers.hmap" -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/include -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/DerivedSources/x86_64" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/DerivedSources" -Xcc -ivfsoverlay -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/unextended-module-overlay.yaml" -Xcc -working-directory/Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire -emit-module-doc-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/MultipartFormData~partial.swiftdoc" -O -module-name Alamofire -emit-module-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/MultipartFormData~partial.swiftmodule" -serialize-diagnostics-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/MultipartFormData.dia" -emit-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/MultipartFormData.d" -emit-reference-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/MultipartFormData.swiftdeps" -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/MultipartFormData.o"

CompileSwift normal x86_64 /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Upload.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Request.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Error.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Manager.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Response.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift -primary-file /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Stream.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Download.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Validation.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Result.swift -target x86_64-apple-macosx10.9 -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk -I /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -F /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -application-extension -g -import-underlying-module -module-cache-path /Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -serialize-debugging-options -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/swift-overrides.hmap" -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-generated-files.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-own-target-headers.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-all-non-framework-target-headers.hmap" -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-project-headers.hmap" -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/include -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/DerivedSources/x86_64" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/DerivedSources" -Xcc -ivfsoverlay -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/unextended-module-overlay.yaml" -Xcc -working-directory/Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire -emit-module-doc-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/ServerTrustPolicy~partial.swiftdoc" -O -module-name Alamofire -emit-module-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/ServerTrustPolicy~partial.swiftmodule" -serialize-diagnostics-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/ServerTrustPolicy.dia" -emit-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/ServerTrustPolicy.d" -emit-reference-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/ServerTrustPolicy.swiftdeps" -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/ServerTrustPolicy.o"

CompileSwift normal x86_64 /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Stream.swift
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Upload.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Request.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Error.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Manager.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Response.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift -primary-file /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Stream.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Download.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Validation.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Result.swift -target x86_64-apple-macosx10.9 -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk -I /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -F /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -application-extension -g -import-underlying-module -module-cache-path /Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -serialize-debugging-options -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/swift-overrides.hmap" -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-generated-files.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-own-target-headers.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-all-non-framework-target-headers.hmap" -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-project-headers.hmap" -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/include -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/DerivedSources/x86_64" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/DerivedSources" -Xcc -ivfsoverlay -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/unextended-module-overlay.yaml" -Xcc -working-directory/Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire -emit-module-doc-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Stream~partial.swiftdoc" -O -module-name Alamofire -emit-module-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Stream~partial.swiftmodule" -serialize-diagnostics-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Stream.dia" -emit-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Stream.d" -emit-reference-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Stream.swiftdeps" -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Stream.o"

CompileSwift normal x86_64 /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Download.swift
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Upload.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Request.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Error.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Manager.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Response.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Stream.swift -primary-file /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Download.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Validation.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Result.swift -target x86_64-apple-macosx10.9 -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk -I /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -F /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -application-extension -g -import-underlying-module -module-cache-path /Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -serialize-debugging-options -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/swift-overrides.hmap" -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-generated-files.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-own-target-headers.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-all-non-framework-target-headers.hmap" -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-project-headers.hmap" -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/include -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/DerivedSources/x86_64" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/DerivedSources" -Xcc -ivfsoverlay -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/unextended-module-overlay.yaml" -Xcc -working-directory/Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire -emit-module-doc-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Download~partial.swiftdoc" -O -module-name Alamofire -emit-module-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Download~partial.swiftmodule" -serialize-diagnostics-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Download.dia" -emit-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Download.d" -emit-reference-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Download.swiftdeps" -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Download.o"

CompileSwift normal x86_64 /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Validation.swift
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Upload.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Request.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Error.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Manager.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Response.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Stream.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Download.swift -primary-file /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Validation.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Result.swift -target x86_64-apple-macosx10.9 -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk -I /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -F /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -application-extension -g -import-underlying-module -module-cache-path /Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -serialize-debugging-options -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/swift-overrides.hmap" -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-generated-files.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-own-target-headers.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-all-non-framework-target-headers.hmap" -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-project-headers.hmap" -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/include -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/DerivedSources/x86_64" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/DerivedSources" -Xcc -ivfsoverlay -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/unextended-module-overlay.yaml" -Xcc -working-directory/Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire -emit-module-doc-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Validation~partial.swiftdoc" -O -module-name Alamofire -emit-module-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Validation~partial.swiftmodule" -serialize-diagnostics-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Validation.dia" -emit-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Validation.d" -emit-reference-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Validation.swiftdeps" -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Validation.o"

CompileSwift normal x86_64 /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Result.swift
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Upload.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Request.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Error.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Manager.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Response.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Stream.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Download.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Validation.swift -primary-file /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Result.swift -target x86_64-apple-macosx10.9 -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk -I /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -F /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -application-extension -g -import-underlying-module -module-cache-path /Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -serialize-debugging-options -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/swift-overrides.hmap" -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-generated-files.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-own-target-headers.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-all-non-framework-target-headers.hmap" -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-project-headers.hmap" -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/include -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/DerivedSources/x86_64" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/DerivedSources" -Xcc -ivfsoverlay -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/unextended-module-overlay.yaml" -Xcc -working-directory/Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire -emit-module-doc-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Result~partial.swiftdoc" -O -module-name Alamofire -emit-module-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Result~partial.swiftmodule" -serialize-diagnostics-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Result.dia" -emit-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Result.d" -emit-reference-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Result.swiftdeps" -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Result.o"

MergeSwiftModule normal x86_64 /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Alamofire.swiftmodule
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -emit-module "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Upload~partial.swiftmodule" "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/ParameterEncoding~partial.swiftmodule" "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Request~partial.swiftmodule" "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/ResponseSerialization~partial.swiftmodule" "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Error~partial.swiftmodule" "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Manager~partial.swiftmodule" "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Response~partial.swiftmodule" "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Alamofire~partial.swiftmodule" "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/MultipartFormData~partial.swiftmodule" "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/ServerTrustPolicy~partial.swiftmodule" "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Stream~partial.swiftmodule" "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Download~partial.swiftmodule" "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Validation~partial.swiftmodule" "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Result~partial.swiftmodule" -parse-as-library -target x86_64-apple-macosx10.9 -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk -I /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -F /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -application-extension -g -import-underlying-module -module-cache-path /Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -serialize-debugging-options -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/swift-overrides.hmap" -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-generated-files.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-own-target-headers.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-all-non-framework-target-headers.hmap" -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Alamofire-project-headers.hmap" -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/include -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/DerivedSources/x86_64" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/DerivedSources" -Xcc -ivfsoverlay -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/unextended-module-overlay.yaml" -Xcc -working-directory/Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire -emit-module-doc-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Alamofire.swiftdoc" -module-name Alamofire -emit-objc-header-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Alamofire-Swift.h" -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire OSX.build/Objects-normal/x86_64/Alamofire.swiftmodule"

Ditto /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework/Versions/A/Headers/Alamofire-Swift.h /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Objects-normal/x86_64/Alamofire-Swift.h
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /usr/bin/ditto -rsrc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Objects-normal/x86_64/Alamofire-Swift.h /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework/Versions/A/Headers/Alamofire-Swift.h

CompileC /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Objects-normal/x86_64/Alamofire_vers.o /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/DerivedSources/Alamofire_vers.c normal x86_64 c com.apple.compilers.llvm.clang.1_0.compiler
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    export LANG=en_US.US-ASCII
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -x c -arch x86_64 -fmessage-length=0 -fdiagnostics-show-note-include-stack -fmacro-backtrace-limit=0 -std=gnu99 -fmodules -gmodules -fmodules-cache-path=/Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -fmodules-prune-interval=86400 -fmodules-prune-after=345600 -fbuild-session-file=/Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache/Session.modulevalidation -fmodules-validate-once-per-build-session -Wnon-modular-include-in-framework-module -Werror=non-modular-include-in-framework-module -Xclang -fmodule-implementation-of -Xclang Alamofire -fapplication-extension -Wno-trigraphs -fpascal-strings -Os -Wno-missing-field-initializers -Wno-missing-prototypes -Werror=return-type -Wunreachable-code -Werror=deprecated-objc-isa-usage -Werror=objc-root-class -Wno-missing-braces -Wparentheses -Wswitch -Wunused-function -Wno-unused-label -Wno-unused-parameter -Wunused-variable -Wunused-value -Wempty-body -Wconditional-uninitialized -Wno-unknown-pragmas -Wno-shadow -Wno-four-char-constants -Wno-conversion -Wconstant-conversion -Wint-conversion -Wbool-conversion -Wenum-conversion -Wshorten-64-to-32 -Wpointer-sign -Wno-newline-eof -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk -fasm-blocks -fstrict-aliasing -Wdeprecated-declarations -mmacosx-version-min=10.9 -g -Wno-sign-conversion -iquote /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Alamofire-generated-files.hmap -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Alamofire-own-target-headers.hmap -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Alamofire-all-non-framework-target-headers.hmap -ivfsoverlay /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -iquote /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Alamofire-project-headers.hmap -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/include -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/DerivedSources/x86_64 -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/DerivedSources -F/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -MMD -MT dependencies -MF /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Objects-normal/x86_64/Alamofire_vers.d --serialize-diagnostics /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Objects-normal/x86_64/Alamofire_vers.dia -c /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/DerivedSources/Alamofire_vers.c -o /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Objects-normal/x86_64/Alamofire_vers.o

Ditto /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework/Versions/A/Modules/Alamofire.swiftmodule/x86_64.swiftdoc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Objects-normal/x86_64/Alamofire.swiftdoc
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /usr/bin/ditto -rsrc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Objects-normal/x86_64/Alamofire.swiftdoc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework/Versions/A/Modules/Alamofire.swiftmodule/x86_64.swiftdoc

Ditto /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework/Versions/A/Modules/Alamofire.swiftmodule/x86_64.swiftmodule /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Objects-normal/x86_64/Alamofire.swiftmodule
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /usr/bin/ditto -rsrc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Objects-normal/x86_64/Alamofire.swiftmodule /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework/Versions/A/Modules/Alamofire.swiftmodule/x86_64.swiftmodule

Ld /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework/Versions/A/Alamofire normal x86_64
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    export MACOSX_DEPLOYMENT_TARGET=10.9
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -arch x86_64 -dynamiclib -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk -L/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -F/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release -filelist /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Objects-normal/x86_64/Alamofire.LinkFileList -install_name @rpath/Alamofire.framework/Versions/A/Alamofire -Xlinker -rpath -Xlinker @executable_path/../Frameworks -Xlinker -rpath -Xlinker @loader_path/Frameworks -mmacosx-version-min=10.9 -fapplication-extension -L/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift/macosx -Xlinker -force_load -Xlinker /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/arc/libarclite_macosx.a -Xlinker -add_ast_path -Xlinker /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Objects-normal/x86_64/Alamofire.swiftmodule -single_module -compatibility_version 1 -current_version 1 -Xlinker -dependency_info -Xlinker /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/Objects-normal/x86_64/Alamofire_dependency_info.dat -o /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework/Versions/A/Alamofire

GenerateDSYMFile /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework.dSYM /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework/Versions/A/Alamofire
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/dsymutil /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework/Versions/A/Alamofire -o /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework.dSYM

CpHeader Source/Alamofire.h /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework/Versions/A/Headers/Alamofire.h
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    builtin-copy -exclude .DS_Store -exclude CVS -exclude .svn -exclude .git -exclude .hg -strip-debug-symbols -strip-tool /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/strip -resolve-src-symlinks /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.h /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework/Versions/A/Headers

Ditto /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/module.modulemap /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework/Versions/A/Modules/module.modulemap
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    builtin-copy -exclude .DS_Store -exclude CVS -exclude .svn -exclude .git -exclude .hg -strip-debug-symbols -strip-tool /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/strip -resolve-src-symlinks /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release/Alamofire\ OSX.build/module.modulemap /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework/Versions/A/Modules

Touch /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /usr/bin/touch -c /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release/Alamofire.framework

** BUILD SUCCEEDED **

/usr/bin/xcrun xcodebuild -workspace /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Alamofire.xcworkspace -scheme Alamofire watchOS -configuration Release -sdk watchos ONLY_ACTIVE_ARCH=NO BITCODE_GENERATION_MODE=bitcode CODE_SIGNING_REQUIRED=NO CODE_SIGN_IDENTITY= clean buildBuild settings from command line:
    BITCODE_GENERATION_MODE = bitcode
    CODE_SIGN_IDENTITY = 
    CODE_SIGNING_REQUIRED = NO
    ONLY_ACTIVE_ARCH = NO
    SDKROOT = watchos2.1

Build Preparation
Build task concurrency set to 8 via user default IDEBuildOperationMaxNumberOfConcurrentCompileTasks

=== CLEAN TARGET Alamofire watchOS OF PROJECT Alamofire WITH CONFIGURATION Release ===

Check dependencies

Clean.Remove clean /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/Alamofire.framework.dSYM
    builtin-rm -rf /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/Alamofire.framework.dSYM

Clean.Remove clean /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/Alamofire.framework
    builtin-rm -rf /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/Alamofire.framework

Clean.Remove clean /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build
    builtin-rm -rf /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build

** CLEAN SUCCEEDED **

Build Preparation
Build task concurrency set to 8 via user default IDEBuildOperationMaxNumberOfConcurrentCompileTasks

=== BUILD TARGET Alamofire watchOS OF PROJECT Alamofire WITH CONFIGURATION Release ===

Check dependencies

Write auxiliary files
write-file /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Alamofire-all-non-framework-target-headers.hmap
write-file /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Alamofire-own-target-headers.hmap
write-file /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Alamofire-all-target-headers.hmap
write-file /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Alamofire-generated-files.hmap
write-file /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Alamofire-project-headers.hmap
write-file /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/module.modulemap
write-file /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/unextended-module.modulemap
write-file /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/swift-overrides.hmap
write-file /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/unextended-module-overlay.yaml
/bin/mkdir -p /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Objects-normal/armv7k
write-file /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Objects-normal/armv7k/Alamofire\ watchOS-OutputFileMap.json
/bin/mkdir -p /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/DerivedSources
write-file /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/DerivedSources/Alamofire_vers.c
write-file /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Objects-normal/armv7k/Alamofire.LinkFileList
write-file /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml
write-file /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Alamofire.hmap

Create product structure
/bin/mkdir -p /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/Alamofire.framework/Modules
/bin/mkdir -p /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/Alamofire.framework/Headers

ProcessInfoPlistFile /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/Alamofire.framework/Info.plist Source/Info.plist
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    export PATH="/Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/Users/sk/.gvm/springboot/current/bin:/Users/sk/.gvm/lazybones/current/bin:/Users/sk/.gvm/jbossforge/current/bin:/Users/sk/.gvm/jbake/current/bin:/Users/sk/.gvm/groovyserv/current/bin:/Users/sk/.gvm/groovy/current/bin:/Users/sk/.gvm/griffon/current/bin:/Users/sk/.gvm/grails/current/bin:/Users/sk/.gvm/gradle/current/bin:/Users/sk/.gvm/glide/current/bin:/Users/sk/.gvm/gaiden/current/bin:/Users/sk/.gvm/crash/current/bin:/Users/sk/.gvm/asciidoctorj/current/bin:/Users/sk/bin:/usr/local/sbin:/Users/sk/.gems/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
    builtin-infoPlistUtility /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Info.plist -expandbuildsettings -format binary -platform watchos -o /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/Alamofire.framework/Info.plist

CompileSwiftSources normal armv7k com.apple.xcode.tools.swift.compiler
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    export PATH="/Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/Users/sk/.gvm/springboot/current/bin:/Users/sk/.gvm/lazybones/current/bin:/Users/sk/.gvm/jbossforge/current/bin:/Users/sk/.gvm/jbake/current/bin:/Users/sk/.gvm/groovyserv/current/bin:/Users/sk/.gvm/groovy/current/bin:/Users/sk/.gvm/griffon/current/bin:/Users/sk/.gvm/grails/current/bin:/Users/sk/.gvm/gradle/current/bin:/Users/sk/.gvm/glide/current/bin:/Users/sk/.gvm/gaiden/current/bin:/Users/sk/.gvm/crash/current/bin:/Users/sk/.gvm/asciidoctorj/current/bin:/Users/sk/bin:/usr/local/sbin:/Users/sk/.gems/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swiftc -incremental -module-name Alamofire -O -sdk /Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/SDKs/WatchOS2.1.sdk -target armv7k-apple-watchos2.0 -g -module-cache-path /Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -Xfrontend -serialize-debugging-options -application-extension -embed-bitcode -I /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -F /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -c -j8 /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Upload.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Request.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Error.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Manager.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Response.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Result.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Stream.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Download.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Validation.swift -output-file-map /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Objects-normal/armv7k/Alamofire\ watchOS-OutputFileMap.json -parseable-output -serialize-diagnostics -emit-dependencies -emit-module -emit-module-path /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Objects-normal/armv7k/Alamofire.swiftmodule -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/swift-overrides.hmap -Xcc -iquote -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Alamofire-generated-files.hmap -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Alamofire-own-target-headers.hmap -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Alamofire-all-non-framework-target-headers.hmap -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Alamofire-project-headers.hmap -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/include -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/DerivedSources/armv7k -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/DerivedSources -emit-objc-header -emit-objc-header-path /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Objects-normal/armv7k/Alamofire-Swift.h -import-underlying-module -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/unextended-module-overlay.yaml -Xcc -working-directory/Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire

CompileSwift normal armv7k /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Upload.swift
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -emit-bc -primary-file /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Upload.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Request.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Error.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Manager.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Response.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Result.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Stream.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Download.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Validation.swift -target armv7k-apple-watchos2.0 -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/SDKs/WatchOS2.1.sdk -I /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -F /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -application-extension -g -import-underlying-module -module-cache-path /Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -serialize-debugging-options -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/swift-overrides.hmap" -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-generated-files.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-own-target-headers.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-all-non-framework-target-headers.hmap" -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-project-headers.hmap" -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/include -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/DerivedSources/armv7k" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/DerivedSources" -Xcc -ivfsoverlay -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/unextended-module-overlay.yaml" -Xcc -working-directory/Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire -emit-module-doc-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Upload~partial.swiftdoc" -O -module-name Alamofire -emit-module-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Upload~partial.swiftmodule" -serialize-diagnostics-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Upload.dia" -emit-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Upload.d" -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Upload.bc"

CompileSwift normal armv7k /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -emit-bc /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Upload.swift -primary-file /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Request.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Error.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Manager.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Response.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Result.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Stream.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Download.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Validation.swift -target armv7k-apple-watchos2.0 -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/SDKs/WatchOS2.1.sdk -I /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -F /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -application-extension -g -import-underlying-module -module-cache-path /Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -serialize-debugging-options -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/swift-overrides.hmap" -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-generated-files.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-own-target-headers.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-all-non-framework-target-headers.hmap" -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-project-headers.hmap" -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/include -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/DerivedSources/armv7k" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/DerivedSources" -Xcc -ivfsoverlay -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/unextended-module-overlay.yaml" -Xcc -working-directory/Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire -emit-module-doc-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/ParameterEncoding~partial.swiftdoc" -O -module-name Alamofire -emit-module-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/ParameterEncoding~partial.swiftmodule" -serialize-diagnostics-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/ParameterEncoding.dia" -emit-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/ParameterEncoding.d" -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/ParameterEncoding.bc"

CompileSwift normal armv7k /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Request.swift
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -emit-bc /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Upload.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift -primary-file /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Request.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Error.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Manager.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Response.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Result.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Stream.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Download.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Validation.swift -target armv7k-apple-watchos2.0 -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/SDKs/WatchOS2.1.sdk -I /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -F /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -application-extension -g -import-underlying-module -module-cache-path /Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -serialize-debugging-options -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/swift-overrides.hmap" -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-generated-files.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-own-target-headers.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-all-non-framework-target-headers.hmap" -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-project-headers.hmap" -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/include -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/DerivedSources/armv7k" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/DerivedSources" -Xcc -ivfsoverlay -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/unextended-module-overlay.yaml" -Xcc -working-directory/Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire -emit-module-doc-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Request~partial.swiftdoc" -O -module-name Alamofire -emit-module-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Request~partial.swiftmodule" -serialize-diagnostics-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Request.dia" -emit-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Request.d" -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Request.bc"

CompileSwift normal armv7k /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Error.swift
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -emit-bc /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Upload.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Request.swift -primary-file /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Error.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Manager.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Response.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Result.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Stream.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Download.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Validation.swift -target armv7k-apple-watchos2.0 -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/SDKs/WatchOS2.1.sdk -I /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -F /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -application-extension -g -import-underlying-module -module-cache-path /Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -serialize-debugging-options -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/swift-overrides.hmap" -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-generated-files.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-own-target-headers.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-all-non-framework-target-headers.hmap" -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-project-headers.hmap" -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/include -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/DerivedSources/armv7k" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/DerivedSources" -Xcc -ivfsoverlay -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/unextended-module-overlay.yaml" -Xcc -working-directory/Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire -emit-module-doc-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Error~partial.swiftdoc" -O -module-name Alamofire -emit-module-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Error~partial.swiftmodule" -serialize-diagnostics-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Error.dia" -emit-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Error.d" -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Error.bc"

CompileSwift normal armv7k /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -emit-bc /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Upload.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Request.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Error.swift -primary-file /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Manager.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Response.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Result.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Stream.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Download.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Validation.swift -target armv7k-apple-watchos2.0 -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/SDKs/WatchOS2.1.sdk -I /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -F /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -application-extension -g -import-underlying-module -module-cache-path /Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -serialize-debugging-options -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/swift-overrides.hmap" -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-generated-files.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-own-target-headers.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-all-non-framework-target-headers.hmap" -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-project-headers.hmap" -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/include -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/DerivedSources/armv7k" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/DerivedSources" -Xcc -ivfsoverlay -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/unextended-module-overlay.yaml" -Xcc -working-directory/Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire -emit-module-doc-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/ResponseSerialization~partial.swiftdoc" -O -module-name Alamofire -emit-module-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/ResponseSerialization~partial.swiftmodule" -serialize-diagnostics-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/ResponseSerialization.dia" -emit-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/ResponseSerialization.d" -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/ResponseSerialization.bc"

CompileSwift normal armv7k /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Manager.swift
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -emit-bc /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Upload.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Request.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Error.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift -primary-file /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Manager.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Response.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Result.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Stream.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Download.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Validation.swift -target armv7k-apple-watchos2.0 -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/SDKs/WatchOS2.1.sdk -I /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -F /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -application-extension -g -import-underlying-module -module-cache-path /Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -serialize-debugging-options -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/swift-overrides.hmap" -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-generated-files.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-own-target-headers.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-all-non-framework-target-headers.hmap" -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-project-headers.hmap" -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/include -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/DerivedSources/armv7k" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/DerivedSources" -Xcc -ivfsoverlay -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/unextended-module-overlay.yaml" -Xcc -working-directory/Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire -emit-module-doc-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Manager~partial.swiftdoc" -O -module-name Alamofire -emit-module-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Manager~partial.swiftmodule" -serialize-diagnostics-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Manager.dia" -emit-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Manager.d" -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Manager.bc"

CompileSwift normal armv7k /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Response.swift
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -emit-bc /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Upload.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Request.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Error.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Manager.swift -primary-file /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Response.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Result.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Stream.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Download.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Validation.swift -target armv7k-apple-watchos2.0 -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/SDKs/WatchOS2.1.sdk -I /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -F /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -application-extension -g -import-underlying-module -module-cache-path /Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -serialize-debugging-options -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/swift-overrides.hmap" -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-generated-files.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-own-target-headers.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-all-non-framework-target-headers.hmap" -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-project-headers.hmap" -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/include -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/DerivedSources/armv7k" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/DerivedSources" -Xcc -ivfsoverlay -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/unextended-module-overlay.yaml" -Xcc -working-directory/Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire -emit-module-doc-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Response~partial.swiftdoc" -O -module-name Alamofire -emit-module-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Response~partial.swiftmodule" -serialize-diagnostics-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Response.dia" -emit-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Response.d" -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Response.bc"

CompileSwift normal armv7k /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Result.swift
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -emit-bc /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Upload.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Request.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Error.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Manager.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Response.swift -primary-file /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Result.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Stream.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Download.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Validation.swift -target armv7k-apple-watchos2.0 -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/SDKs/WatchOS2.1.sdk -I /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -F /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -application-extension -g -import-underlying-module -module-cache-path /Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -serialize-debugging-options -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/swift-overrides.hmap" -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-generated-files.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-own-target-headers.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-all-non-framework-target-headers.hmap" -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-project-headers.hmap" -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/include -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/DerivedSources/armv7k" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/DerivedSources" -Xcc -ivfsoverlay -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/unextended-module-overlay.yaml" -Xcc -working-directory/Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire -emit-module-doc-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Result~partial.swiftdoc" -O -module-name Alamofire -emit-module-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Result~partial.swiftmodule" -serialize-diagnostics-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Result.dia" -emit-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Result.d" -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Result.bc"

CompileSwift normal armv7k /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.swift
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -emit-bc /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Upload.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Request.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Error.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Manager.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Response.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Result.swift -primary-file /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Stream.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Download.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Validation.swift -target armv7k-apple-watchos2.0 -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/SDKs/WatchOS2.1.sdk -I /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -F /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -application-extension -g -import-underlying-module -module-cache-path /Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -serialize-debugging-options -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/swift-overrides.hmap" -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-generated-files.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-own-target-headers.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-all-non-framework-target-headers.hmap" -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-project-headers.hmap" -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/include -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/DerivedSources/armv7k" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/DerivedSources" -Xcc -ivfsoverlay -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/unextended-module-overlay.yaml" -Xcc -working-directory/Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire -emit-module-doc-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Alamofire~partial.swiftdoc" -O -module-name Alamofire -emit-module-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Alamofire~partial.swiftmodule" -serialize-diagnostics-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Alamofire.dia" -emit-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Alamofire.d" -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Alamofire.bc"

CompileSwift normal armv7k /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -emit-bc /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Upload.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Request.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Error.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Manager.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Response.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Result.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.swift -primary-file /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Stream.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Download.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Validation.swift -target armv7k-apple-watchos2.0 -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/SDKs/WatchOS2.1.sdk -I /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -F /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -application-extension -g -import-underlying-module -module-cache-path /Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -serialize-debugging-options -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/swift-overrides.hmap" -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-generated-files.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-own-target-headers.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-all-non-framework-target-headers.hmap" -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-project-headers.hmap" -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/include -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/DerivedSources/armv7k" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/DerivedSources" -Xcc -ivfsoverlay -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/unextended-module-overlay.yaml" -Xcc -working-directory/Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire -emit-module-doc-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/MultipartFormData~partial.swiftdoc" -O -module-name Alamofire -emit-module-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/MultipartFormData~partial.swiftmodule" -serialize-diagnostics-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/MultipartFormData.dia" -emit-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/MultipartFormData.d" -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/MultipartFormData.bc"

CompileSwift normal armv7k /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Stream.swift
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -emit-bc /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Upload.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Request.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Error.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Manager.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Response.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Result.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift -primary-file /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Stream.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Download.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Validation.swift -target armv7k-apple-watchos2.0 -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/SDKs/WatchOS2.1.sdk -I /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -F /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -application-extension -g -import-underlying-module -module-cache-path /Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -serialize-debugging-options -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/swift-overrides.hmap" -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-generated-files.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-own-target-headers.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-all-non-framework-target-headers.hmap" -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-project-headers.hmap" -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/include -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/DerivedSources/armv7k" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/DerivedSources" -Xcc -ivfsoverlay -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/unextended-module-overlay.yaml" -Xcc -working-directory/Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire -emit-module-doc-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Stream~partial.swiftdoc" -O -module-name Alamofire -emit-module-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Stream~partial.swiftmodule" -serialize-diagnostics-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Stream.dia" -emit-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Stream.d" -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Stream.bc"

CompileSwift normal armv7k /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -emit-bc /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Upload.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Request.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Error.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Manager.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Response.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Result.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Stream.swift -primary-file /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Download.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Validation.swift -target armv7k-apple-watchos2.0 -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/SDKs/WatchOS2.1.sdk -I /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -F /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -application-extension -g -import-underlying-module -module-cache-path /Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -serialize-debugging-options -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/swift-overrides.hmap" -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-generated-files.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-own-target-headers.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-all-non-framework-target-headers.hmap" -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-project-headers.hmap" -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/include -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/DerivedSources/armv7k" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/DerivedSources" -Xcc -ivfsoverlay -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/unextended-module-overlay.yaml" -Xcc -working-directory/Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire -emit-module-doc-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/ServerTrustPolicy~partial.swiftdoc" -O -module-name Alamofire -emit-module-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/ServerTrustPolicy~partial.swiftmodule" -serialize-diagnostics-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/ServerTrustPolicy.dia" -emit-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/ServerTrustPolicy.d" -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/ServerTrustPolicy.bc"

CompileSwift normal armv7k /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Download.swift
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -emit-bc /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Upload.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Request.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Error.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Manager.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Response.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Result.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Stream.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift -primary-file /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Download.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Validation.swift -target armv7k-apple-watchos2.0 -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/SDKs/WatchOS2.1.sdk -I /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -F /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -application-extension -g -import-underlying-module -module-cache-path /Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -serialize-debugging-options -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/swift-overrides.hmap" -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-generated-files.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-own-target-headers.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-all-non-framework-target-headers.hmap" -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-project-headers.hmap" -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/include -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/DerivedSources/armv7k" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/DerivedSources" -Xcc -ivfsoverlay -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/unextended-module-overlay.yaml" -Xcc -working-directory/Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire -emit-module-doc-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Download~partial.swiftdoc" -O -module-name Alamofire -emit-module-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Download~partial.swiftmodule" -serialize-diagnostics-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Download.dia" -emit-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Download.d" -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Download.bc"

CompileSwift normal armv7k /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Validation.swift
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -emit-bc /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Upload.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Request.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Error.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Manager.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Response.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Result.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Stream.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Download.swift -primary-file /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Validation.swift -target armv7k-apple-watchos2.0 -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/SDKs/WatchOS2.1.sdk -I /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -F /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -application-extension -g -import-underlying-module -module-cache-path /Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -serialize-debugging-options -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/swift-overrides.hmap" -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-generated-files.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-own-target-headers.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-all-non-framework-target-headers.hmap" -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-project-headers.hmap" -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/include -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/DerivedSources/armv7k" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/DerivedSources" -Xcc -ivfsoverlay -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/unextended-module-overlay.yaml" -Xcc -working-directory/Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire -emit-module-doc-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Validation~partial.swiftdoc" -O -module-name Alamofire -emit-module-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Validation~partial.swiftmodule" -serialize-diagnostics-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Validation.dia" -emit-dependencies-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Validation.d" -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Validation.bc"

SwiftCodeGeneration normal armv7k /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Result.bc
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c -primary-file "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Result.bc" -target armv7k-apple-watchos2.0 -O -module-name Alamofire -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Result.o" -embed-bitcode -disable-llvm-optzns

SwiftCodeGeneration normal armv7k /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Error.bc
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c -primary-file "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Error.bc" -target armv7k-apple-watchos2.0 -O -module-name Alamofire -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Error.o" -embed-bitcode -disable-llvm-optzns

SwiftCodeGeneration normal armv7k /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Upload.bc
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c -primary-file "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Upload.bc" -target armv7k-apple-watchos2.0 -O -module-name Alamofire -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Upload.o" -embed-bitcode -disable-llvm-optzns

SwiftCodeGeneration normal armv7k /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Stream.bc
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c -primary-file "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Stream.bc" -target armv7k-apple-watchos2.0 -O -module-name Alamofire -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Stream.o" -embed-bitcode -disable-llvm-optzns

SwiftCodeGeneration normal armv7k /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Alamofire.bc
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c -primary-file "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Alamofire.bc" -target armv7k-apple-watchos2.0 -O -module-name Alamofire -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Alamofire.o" -embed-bitcode -disable-llvm-optzns

SwiftCodeGeneration normal armv7k /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/ResponseSerialization.bc
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c -primary-file "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/ResponseSerialization.bc" -target armv7k-apple-watchos2.0 -O -module-name Alamofire -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/ResponseSerialization.o" -embed-bitcode -disable-llvm-optzns

SwiftCodeGeneration normal armv7k /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Response.bc
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c -primary-file "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Response.bc" -target armv7k-apple-watchos2.0 -O -module-name Alamofire -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Response.o" -embed-bitcode -disable-llvm-optzns

SwiftCodeGeneration normal armv7k /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Download.bc
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c -primary-file "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Download.bc" -target armv7k-apple-watchos2.0 -O -module-name Alamofire -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Download.o" -embed-bitcode -disable-llvm-optzns

SwiftCodeGeneration normal armv7k /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Validation.bc
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c -primary-file "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Validation.bc" -target armv7k-apple-watchos2.0 -O -module-name Alamofire -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Validation.o" -embed-bitcode -disable-llvm-optzns

SwiftCodeGeneration normal armv7k /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Manager.bc
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c -primary-file "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Manager.bc" -target armv7k-apple-watchos2.0 -O -module-name Alamofire -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Manager.o" -embed-bitcode -disable-llvm-optzns

SwiftCodeGeneration normal armv7k /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/ParameterEncoding.bc
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c -primary-file "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/ParameterEncoding.bc" -target armv7k-apple-watchos2.0 -O -module-name Alamofire -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/ParameterEncoding.o" -embed-bitcode -disable-llvm-optzns

SwiftCodeGeneration normal armv7k /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Request.bc
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c -primary-file "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Request.bc" -target armv7k-apple-watchos2.0 -O -module-name Alamofire -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Request.o" -embed-bitcode -disable-llvm-optzns

SwiftCodeGeneration normal armv7k /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/ServerTrustPolicy.bc
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c -primary-file "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/ServerTrustPolicy.bc" -target armv7k-apple-watchos2.0 -O -module-name Alamofire -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/ServerTrustPolicy.o" -embed-bitcode -disable-llvm-optzns

SwiftCodeGeneration normal armv7k /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/MultipartFormData.bc
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c -primary-file "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/MultipartFormData.bc" -target armv7k-apple-watchos2.0 -O -module-name Alamofire -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/MultipartFormData.o" -embed-bitcode -disable-llvm-optzns

MergeSwiftModule normal armv7k /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Alamofire.swiftmodule
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -emit-module "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Upload~partial.swiftmodule" "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/ParameterEncoding~partial.swiftmodule" "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Request~partial.swiftmodule" "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Error~partial.swiftmodule" "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/ResponseSerialization~partial.swiftmodule" "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Manager~partial.swiftmodule" "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Response~partial.swiftmodule" "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Result~partial.swiftmodule" "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Alamofire~partial.swiftmodule" "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/MultipartFormData~partial.swiftmodule" "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Stream~partial.swiftmodule" "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/ServerTrustPolicy~partial.swiftmodule" "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Download~partial.swiftmodule" "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Validation~partial.swiftmodule" -parse-as-library -target armv7k-apple-watchos2.0 -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/SDKs/WatchOS2.1.sdk -I /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -F /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -application-extension -g -import-underlying-module -module-cache-path /Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -serialize-debugging-options -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/swift-overrides.hmap" -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-generated-files.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-own-target-headers.hmap" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-all-non-framework-target-headers.hmap" -Xcc -ivfsoverlay -Xcc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Alamofire-project-headers.hmap" -Xcc -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/include -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/DerivedSources/armv7k" -Xcc "-I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/DerivedSources" -Xcc -ivfsoverlay -Xcc "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/unextended-module-overlay.yaml" -Xcc -working-directory/Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire -emit-module-doc-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Alamofire.swiftdoc" -module-name Alamofire -emit-objc-header-path "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Alamofire-Swift.h" -o "/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire watchOS.build/Objects-normal/armv7k/Alamofire.swiftmodule"

Ditto /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/Alamofire.framework/Headers/Alamofire-Swift.h /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Objects-normal/armv7k/Alamofire-Swift.h
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    export PATH="/Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/Users/sk/.gvm/springboot/current/bin:/Users/sk/.gvm/lazybones/current/bin:/Users/sk/.gvm/jbossforge/current/bin:/Users/sk/.gvm/jbake/current/bin:/Users/sk/.gvm/groovyserv/current/bin:/Users/sk/.gvm/groovy/current/bin:/Users/sk/.gvm/griffon/current/bin:/Users/sk/.gvm/grails/current/bin:/Users/sk/.gvm/gradle/current/bin:/Users/sk/.gvm/glide/current/bin:/Users/sk/.gvm/gaiden/current/bin:/Users/sk/.gvm/crash/current/bin:/Users/sk/.gvm/asciidoctorj/current/bin:/Users/sk/bin:/usr/local/sbin:/Users/sk/.gems/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
    /usr/bin/ditto -rsrc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Objects-normal/armv7k/Alamofire-Swift.h /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/Alamofire.framework/Headers/Alamofire-Swift.h

CompileC /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Objects-normal/armv7k/Alamofire_vers.o /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/DerivedSources/Alamofire_vers.c normal armv7k c com.apple.compilers.llvm.clang.1_0.compiler
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    export LANG=en_US.US-ASCII
    export PATH="/Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/Users/sk/.gvm/springboot/current/bin:/Users/sk/.gvm/lazybones/current/bin:/Users/sk/.gvm/jbossforge/current/bin:/Users/sk/.gvm/jbake/current/bin:/Users/sk/.gvm/groovyserv/current/bin:/Users/sk/.gvm/groovy/current/bin:/Users/sk/.gvm/griffon/current/bin:/Users/sk/.gvm/grails/current/bin:/Users/sk/.gvm/gradle/current/bin:/Users/sk/.gvm/glide/current/bin:/Users/sk/.gvm/gaiden/current/bin:/Users/sk/.gvm/crash/current/bin:/Users/sk/.gvm/asciidoctorj/current/bin:/Users/sk/bin:/usr/local/sbin:/Users/sk/.gems/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -x c -arch armv7k -fmessage-length=0 -fdiagnostics-show-note-include-stack -fmacro-backtrace-limit=0 -std=gnu99 -fmodules -gmodules -fmodules-cache-path=/Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache -fmodules-prune-interval=86400 -fmodules-prune-after=345600 -fbuild-session-file=/Users/sk/Library/Developer/Xcode/DerivedData/ModuleCache/Session.modulevalidation -fmodules-validate-once-per-build-session -Wnon-modular-include-in-framework-module -Werror=non-modular-include-in-framework-module -Xclang -fmodule-implementation-of -Xclang Alamofire -fapplication-extension -Wno-trigraphs -fpascal-strings -Os -fno-common -Wno-missing-field-initializers -Wno-missing-prototypes -Werror=return-type -Wunreachable-code -Werror=deprecated-objc-isa-usage -Werror=objc-root-class -Wno-missing-braces -Wparentheses -Wswitch -Wunused-function -Wno-unused-label -Wno-unused-parameter -Wunused-variable -Wunused-value -Wempty-body -Wconditional-uninitialized -Wno-unknown-pragmas -Wno-shadow -Wno-four-char-constants -Wno-conversion -Wconstant-conversion -Wint-conversion -Wbool-conversion -Wenum-conversion -Wshorten-64-to-32 -Wpointer-sign -Wno-newline-eof -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/SDKs/WatchOS2.1.sdk -fstrict-aliasing -Wdeprecated-declarations -mwatchos-version-min=2.0 -g -Wno-sign-conversion -fembed-bitcode -fno-gnu-inline-asm -iquote /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Alamofire-generated-files.hmap -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Alamofire-own-target-headers.hmap -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Alamofire-all-non-framework-target-headers.hmap -ivfsoverlay /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/all-product-headers.yaml -iquote /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Alamofire-project-headers.hmap -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/include -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/DerivedSources/armv7k -I/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/DerivedSources -F/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -MMD -MT dependencies -MF /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Objects-normal/armv7k/Alamofire_vers.d --serialize-diagnostics /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Objects-normal/armv7k/Alamofire_vers.dia -c /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/DerivedSources/Alamofire_vers.c -o /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Objects-normal/armv7k/Alamofire_vers.o

Ditto /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/Alamofire.framework/Modules/Alamofire.swiftmodule/arm.swiftmodule /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Objects-normal/armv7k/Alamofire.swiftmodule
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    export PATH="/Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/Users/sk/.gvm/springboot/current/bin:/Users/sk/.gvm/lazybones/current/bin:/Users/sk/.gvm/jbossforge/current/bin:/Users/sk/.gvm/jbake/current/bin:/Users/sk/.gvm/groovyserv/current/bin:/Users/sk/.gvm/groovy/current/bin:/Users/sk/.gvm/griffon/current/bin:/Users/sk/.gvm/grails/current/bin:/Users/sk/.gvm/gradle/current/bin:/Users/sk/.gvm/glide/current/bin:/Users/sk/.gvm/gaiden/current/bin:/Users/sk/.gvm/crash/current/bin:/Users/sk/.gvm/asciidoctorj/current/bin:/Users/sk/bin:/usr/local/sbin:/Users/sk/.gems/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
    /usr/bin/ditto -rsrc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Objects-normal/armv7k/Alamofire.swiftmodule /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/Alamofire.framework/Modules/Alamofire.swiftmodule/arm.swiftmodule

Ditto /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/Alamofire.framework/Modules/Alamofire.swiftmodule/arm.swiftdoc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Objects-normal/armv7k/Alamofire.swiftdoc
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    export PATH="/Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/Users/sk/.gvm/springboot/current/bin:/Users/sk/.gvm/lazybones/current/bin:/Users/sk/.gvm/jbossforge/current/bin:/Users/sk/.gvm/jbake/current/bin:/Users/sk/.gvm/groovyserv/current/bin:/Users/sk/.gvm/groovy/current/bin:/Users/sk/.gvm/griffon/current/bin:/Users/sk/.gvm/grails/current/bin:/Users/sk/.gvm/gradle/current/bin:/Users/sk/.gvm/glide/current/bin:/Users/sk/.gvm/gaiden/current/bin:/Users/sk/.gvm/crash/current/bin:/Users/sk/.gvm/asciidoctorj/current/bin:/Users/sk/bin:/usr/local/sbin:/Users/sk/.gems/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
    /usr/bin/ditto -rsrc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Objects-normal/armv7k/Alamofire.swiftdoc /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/Alamofire.framework/Modules/Alamofire.swiftmodule/arm.swiftdoc

Ld /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/Alamofire.framework/Alamofire normal armv7k
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    export PATH="/Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/Users/sk/.gvm/springboot/current/bin:/Users/sk/.gvm/lazybones/current/bin:/Users/sk/.gvm/jbossforge/current/bin:/Users/sk/.gvm/jbake/current/bin:/Users/sk/.gvm/groovyserv/current/bin:/Users/sk/.gvm/groovy/current/bin:/Users/sk/.gvm/griffon/current/bin:/Users/sk/.gvm/grails/current/bin:/Users/sk/.gvm/gradle/current/bin:/Users/sk/.gvm/glide/current/bin:/Users/sk/.gvm/gaiden/current/bin:/Users/sk/.gvm/crash/current/bin:/Users/sk/.gvm/asciidoctorj/current/bin:/Users/sk/bin:/usr/local/sbin:/Users/sk/.gems/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
    export WATCHOS_DEPLOYMENT_TARGET=2.0
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -arch armv7k -dynamiclib -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/SDKs/WatchOS2.1.sdk -L/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -F/Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -filelist /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Objects-normal/armv7k/Alamofire.LinkFileList -install_name @rpath/Alamofire.framework/Alamofire -Xlinker -rpath -Xlinker @executable_path/Frameworks -Xlinker -rpath -Xlinker @loader_path/Frameworks -mwatchos-version-min=2.0 -dead_strip -fembed-bitcode -Xlinker -bitcode_verify -Xlinker -bitcode_hide_symbols -Xlinker -bitcode_symbol_map -Xlinker /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos -fapplication-extension -L/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift/watchos -Xlinker -add_ast_path -Xlinker /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Objects-normal/armv7k/Alamofire.swiftmodule -single_module -compatibility_version 1 -current_version 1 -Xlinker -dependency_info -Xlinker /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/Objects-normal/armv7k/Alamofire_dependency_info.dat -o /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/Alamofire.framework/Alamofire

GenerateDSYMFile /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/Alamofire.framework.dSYM /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/Alamofire.framework/Alamofire
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    export PATH="/Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/Users/sk/.gvm/springboot/current/bin:/Users/sk/.gvm/lazybones/current/bin:/Users/sk/.gvm/jbossforge/current/bin:/Users/sk/.gvm/jbake/current/bin:/Users/sk/.gvm/groovyserv/current/bin:/Users/sk/.gvm/groovy/current/bin:/Users/sk/.gvm/griffon/current/bin:/Users/sk/.gvm/grails/current/bin:/Users/sk/.gvm/gradle/current/bin:/Users/sk/.gvm/glide/current/bin:/Users/sk/.gvm/gaiden/current/bin:/Users/sk/.gvm/crash/current/bin:/Users/sk/.gvm/asciidoctorj/current/bin:/Users/sk/bin:/usr/local/sbin:/Users/sk/.gems/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/dsymutil /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/Alamofire.framework/Alamofire -o /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/Alamofire.framework.dSYM

CpHeader Source/Alamofire.h /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/Alamofire.framework/Headers/Alamofire.h
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    export PATH="/Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/Users/sk/.gvm/springboot/current/bin:/Users/sk/.gvm/lazybones/current/bin:/Users/sk/.gvm/jbossforge/current/bin:/Users/sk/.gvm/jbake/current/bin:/Users/sk/.gvm/groovyserv/current/bin:/Users/sk/.gvm/groovy/current/bin:/Users/sk/.gvm/griffon/current/bin:/Users/sk/.gvm/grails/current/bin:/Users/sk/.gvm/gradle/current/bin:/Users/sk/.gvm/glide/current/bin:/Users/sk/.gvm/gaiden/current/bin:/Users/sk/.gvm/crash/current/bin:/Users/sk/.gvm/asciidoctorj/current/bin:/Users/sk/bin:/usr/local/sbin:/Users/sk/.gems/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
    builtin-copy -exclude .DS_Store -exclude CVS -exclude .svn -exclude .git -exclude .hg -resolve-src-symlinks /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Source/Alamofire.h /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/Alamofire.framework/Headers

Ditto /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/module.modulemap /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/Alamofire.framework/Modules/module.modulemap
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    export PATH="/Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/Users/sk/.gvm/springboot/current/bin:/Users/sk/.gvm/lazybones/current/bin:/Users/sk/.gvm/jbossforge/current/bin:/Users/sk/.gvm/jbake/current/bin:/Users/sk/.gvm/groovyserv/current/bin:/Users/sk/.gvm/groovy/current/bin:/Users/sk/.gvm/griffon/current/bin:/Users/sk/.gvm/grails/current/bin:/Users/sk/.gvm/gradle/current/bin:/Users/sk/.gvm/glide/current/bin:/Users/sk/.gvm/gaiden/current/bin:/Users/sk/.gvm/crash/current/bin:/Users/sk/.gvm/asciidoctorj/current/bin:/Users/sk/bin:/usr/local/sbin:/Users/sk/.gems/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
    builtin-copy -exclude .DS_Store -exclude CVS -exclude .svn -exclude .git -exclude .hg -resolve-src-symlinks /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Intermediates/Alamofire.build/Release-watchos/Alamofire\ watchOS.build/module.modulemap /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/Alamofire.framework/Modules

Touch /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/Alamofire.framework
    cd /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire
    export PATH="/Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/Users/sk/.gvm/springboot/current/bin:/Users/sk/.gvm/lazybones/current/bin:/Users/sk/.gvm/jbossforge/current/bin:/Users/sk/.gvm/jbake/current/bin:/Users/sk/.gvm/groovyserv/current/bin:/Users/sk/.gvm/groovy/current/bin:/Users/sk/.gvm/griffon/current/bin:/Users/sk/.gvm/grails/current/bin:/Users/sk/.gvm/gradle/current/bin:/Users/sk/.gvm/glide/current/bin:/Users/sk/.gvm/gaiden/current/bin:/Users/sk/.gvm/crash/current/bin:/Users/sk/.gvm/asciidoctorj/current/bin:/Users/sk/bin:/usr/local/sbin:/Users/sk/.gems/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
    /usr/bin/touch -c /Users/sk/Library/Developer/Xcode/DerivedData/Alamofire-dwpehielsglrlbbqmiaoodwtxsvy/Build/Products/Release-watchos/Alamofire.framework

** BUILD SUCCEEDED **

/usr/bin/xcrun xcodebuild -workspace /Users/sk/Desktop/carthage-test/Carthage/Checkouts/Alamofire/Alamofire.xcworkspace -scheme Alamofire watchOS -configuration Release -sdk watchsimulator ONLY_ACTIVE_ARCH=NO CODE_SIGNING_REQUIRED=NO CODE_SIGN_IDENTITY= clean buildBuild settings from command line:
    CODE_SIGN_IDENTITY = 
    CODE_SIGNING_REQUIRED = NO
    ONLY_ACTIVE_ARCH = NO
    SDKROOT = watchsimulator2.1

Build Preparation
Build task concurrency set to 8 via user default IDEBuildOperationMaxNumberOfConcurrentCompileTasks

=== CLEAN TARGET Alamofire watchOS OF PROJECT Alamofire WITH CONFIGURATION Release ===

Check dependencies
target 'Alamofire watchOS' has bitcode disabled (ENABLE_BITCODE = NO), but it is required for the 'watchos' platform

Build Preparation
Build task concurrency set to 8 via user default IDEBuildOperationMaxNumberOfConcurrentCompileTasks

=== BUILD TARGET Alamofire watchOS OF PROJECT Alamofire WITH CONFIGURATION Release ===

Check dependencies
target 'Alamofire watchOS' has bitcode disabled (ENABLE_BITCODE = NO), but it is required for the 'watchos' platform

```

So what is going wrong here?
 I have the same issue with the latest version of carthage.
`carthage version` says

```
katunch:~$ carthage version
0.12.0
katunch:~$
```

so i will investigate a bit more on that issue
 sorry forgot to post that
`xcodebuild -version` says

```
katunch:~$ xcodebuild -version
Xcode 7.2.1
Build version 7C1002
katunch:~$
```
 @cnoon Upgrading Carthage to the version 0.13.0 via Homebrew solved the issue. Thanks.
  Can we do batch download of an array of images and files?
  The following crashes with a `Thread 1 exc_bad_instruction - fatal error: unexpectedly found nil while unwrapping an Optional value`

```
let mutableURLRequest = NSMutableURLRequest(URL: NSURL(string: URLString.URLString)!)
    mutableURLRequest.HTTPMethod = method.rawValue
```

[Reference to code](https://github.com/Alamofire/Alamofire/blob/master/Source/Alamofire.swift#L92)

The following works as `expected:`

```
let encodedUrl = URLString.URLString.stringByAddingPercentEncodingWithAllowedCharacters(NSCharacterSet.URLQueryAllowedCharacterSet())!
let mutableURLRequest = NSMutableURLRequest(URL: NSURL(string: encodedUrl)!)
mutableURLRequest.HTTPMethod = method.rawValue
```

Using latest version of Alamofire and Swift 2
 Thanks for clarifying this @cnoon 
  Hi, I am new to this library and i wanted to cancel the current request after some time like after 10 seconds.
any help will be appreciated. 
 Greetings,

Thanks for give your precious time to answer my question.

Thanks & Regards 
Gaganpreet Singh

> On 04-Feb-2016, at 10:33 AM, Christian Noon notifications@github.com wrote:
> 
> Hi @gaganpsinghkrishnais https://github.com/gaganpsinghkrishnais, these types of questions are better suited for Stack Overflow. We use GitHub for feature requests and bug reports.
> 
> Best of luck! üçª
> 
> From our Contribution Guidelines https://github.com/Alamofire/Alamofire/blob/master/CONTRIBUTING.md
> Asking Questions
> 
> We don't use GitHub as a support forum. For any usage questions that are not specific to the project itself, please ask on Stack Overflow https://stackoverflow.com/ instead. By doing so, you'll be more likely to quickly solve your problem, and you'll allow anyone else with the same question to find the answer. This also allows maintainers to focus on improving the project for others.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub https://github.com/Alamofire/Alamofire/issues/1041#issuecomment-179642688.
 Greetings,

I have one more suggestion or request.

when uploading data file using upload method with header we cannot cancel request.
please add cancel method to it.

that will be very helpful for all.

Thanks & Regards 
Gaganpreet Singh

> On 04-Feb-2016, at 10:33 AM, Christian Noon notifications@github.com wrote:
> 
> Closed #1041 https://github.com/Alamofire/Alamofire/issues/1041.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub https://github.com/Alamofire/Alamofire/issues/1041#event-538652473.
 @gaganpsinghkrishnais have you fix it?
`when uploading data file using upload method with header we cannot cancel request.`  I'm new to Swift, although I've been using Perl for decades, and when I looked for a way of doing HTTP(S)? requests and getting back JSON, Alamofire looked like a decent answer. And I've got some code that talks to a remote server and gets back responses, and it appears to behave well. Now I want to test it.

As per the guidelines, I [asked on StackOverflow](http://stackoverflow.com/questions/35144676/how-do-i-mock-an-alamofire-response-only) about my specific problem. I thought I'd raise a meta-issue here, though, while I remember what it was like to be a developer new to Swift.

Let's compare the [Alamofire documentation](https://github.com/Alamofire/Alamofire/blob/master/README.md) compared to the [sort-of Perl equivalent](https://metacpan.org/pod/LWP). Note that the Perl code explicitly talks about the sorts of objects that are involved, and [tells you how to build your own](https://metacpan.org/pod/HTTP::Response) if you dig deep enough.

(And yeah, it's old enough that it thinks that it's worthwhile talking about gopher as a protocol. Ahem...)

There's an idiom in Perl land that's proved to be useful: have two sets of documentation. (1) Explain to newcomers how you use The Thing; and separately (2) explain to advanced users How The Thing Works. Reasonable examples would be [Moose](https://metacpan.org/pod/Moose) or [DBIx::Class](https://metacpan.org/pod/DBIx::Class).

Maybe this would be something worth stealing?
 No, that's not what I'm looking for at all.

What I'm looking for is some sort of documentation about the Request and Response objects themselves, so e.g. I can create a Request object from scratch, supply it with JSON and test that my code works with a variety of responses, without having to mock all of the networking.
  I'm having a `RegisterManager` like this:

```
    class RegisterManager {
      private let manager : Alamofire.Manager

      init(){
        let configuration = Timberjack.defaultSessionConfiguration()
        manager = Alamofire.Manager(configuration: configuration)
      }
    }

```

Then I have some methods on `RegisterManager` for example:

```
     func loginUser(username: String, password: String, completionHandler: CompletionHandler) {

            let parameters: [String:String] = [
                    "username": username,
                    "password": password,
                    "scope": "user_basic",
                    "grant_type": "password"
            ]

            let headers = [
                    "Authorization": "Basic \(getBase64Credentials())",
                    "Content-Type": "application/x-www-form-urlencoded"
            ]

            manager.request(.POST, String(format: "%@%@", arguments: [kAPIHost, "/oauth/token"]), parameters: parameters, headers: headers).responseJSON {
                response in

                if let _ = response.result.value {
                    completionHandler(success: true)
                } else {
                    completionHandler(success: false)
                }
            }
        }

```

When I do the call it always fails because it's cancelled. When I just change manager.request to `Alamofire.request` it works. I found here on the github that you need to have a let in your class so I did but still the same problem.

What I'm doing wrong?
 @donpironet I believe you need _.sharedInstance_ on the end of your _manager_ constant.
 But then I have a instance again with the default configuration?
 But I have a private let variable in my RegisterManager? So why is that not working? 
 I found the problem. It was indeed in the class that creates my RegisterManager. I didn't save a reference to it. Feeling so stupid.
  When creating a boolean param swift will automatically convert it to 0 or 1

```
var params = [String: AnyObject]()
params["test"] = "testString"
params["bool"] = true

print(params) //["bool": 1, "test": testString]
```

Now, if the server has some validation and expects a Boolean value for the `bool` param, the validation will fail..

What is a good workaround?
  I need to implement an API that needs a custom header to work:

X-Auth-Hmac (that's the call signature)
Authorization (that's a bearer token)

I found some examples but did not succeed. I just can't see the headers on my request.
My current code is (just trying to figure out the hmac header first):

`let manager = Alamofire.Manager.sharedInstance
        manager.session.configuration.HTTPAdditionalHeaders = ["X-Auth-Hmac": "my-custom-key".digestHMac256()]
manager.request(.POST, "https://my-url.com/oauth/access-token")
        .responseJSON { response in
            debugPrint(response)
        }`

I know there's a lot of closed issues here about custom headers, but I tried to do [something like this](https://github.com/Alamofire/Alamofire#http-headers) and still not working.

What I'm missing?
Thanks!
  I suggest to add a request method for sending json by Alamofire::request with signature like 
request(
        method: Method,
        _ URLString: URLStringConvertible,
        json: NSString)
-> Request

I implemented this method on my own computer.

If it can be merged I create a pull request.

Thank you.
  When i'm calling my api through alamofire. it's requesting but not getting any response. it was working fine but suddenly it's not giving any response.  
 Hi, I have same issue. I haven't touch the source code and it stopped working on my real device 2 days ago. In simulator it works fine. I am running iOS 9.2.1. The status code of result object is 200, but the json (response.result.value) is nil. Any ideas?  
 Edit: I have updated Alamofire to the most recent version and it works fine now.
  responser -> response
  Hi

This morning I updated Alamofire from 3.1.3 to 3.1.5 and since then my custom POST requests no longer include the POST body. I downgraded back to 3.1.3 and it worked again. I couldn't see anything in the changelog that might explain it so wondered if anyone could shed any light on it. Request creation code as follows:

```
self.manager.request(httpMethod, url, headers: headers, parameters: [:], encoding: .Custom({ (convertible, _) -> (NSMutableURLRequest, NSError?) in
            let mutableRequest = convertible.URLRequest.copy() as! NSMutableURLRequest
            if let j = json {
                mutableRequest.HTTPBody = j.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)
            }
            return (mutableRequest, nil)
        }))
```

where `json` is a pre-encoded json string.

Thanks #
 @cnoon Hi! looks like version 3.2.0 doesn't work. When I'm sending .POST request body is empty, but when I'm using .PUT everything ok

```
encoding = .Custom({convertible, params in
                let mutableRequest = convertible.URLRequest.copy() as! NSMutableURLRequest
                mutableRequest.HTTPBody = body
                return (mutableRequest, nil)
            })

```
  I use Alamofire for Basic Auth with my backend, which returns status code 401 if user is not authorized.

But by default I cannot detect that code on client side, because Alamofire's req.responseData() method returns NSError and response == nil:

```
        req.responseData { (response) -> Void in

            if response.result.error != nil {
                log.warning(error?.description)
            }

            if response.response != nil { // Always nil when status == 401
                log.warning("response")
            }
        }
```

How can I retrieve HTTP Status Code from server's response?
I haven't configured any validation, as I understand.
 Also when I return another status code from backend (for example, 503 SERVICE_UNAVAILABLE), Alamofire returns it successfully without producing the NSError.

Maybe the bug have something to do with the fact that I use `request.authenticate(user: userId!, password: password!)` method and Alamofire places additional validation rules with it for the 401 code?
 @cnoon Any thoughts on this? I really need to access response & header data in case of 401 status code and this bug prevents me from doing that.
There was no such problems with AFNetworking.
 Also if I'm not calling request.authenticate() before making the request, I receive 401 status code and response data just fine.
 Found workaround by not calling request.authenticate() and instead sending custom Authorization header by constructing new Alamofire.Manager:

```
func updateAlamofire(userId:String?, password:String?) {
        var headers = alamofire.session.configuration.HTTPAdditionalHeaders ?? Alamofire.Manager.defaultHTTPHeaders

        if(userId == nil || password == nil) {
            headers.removeValueForKey("Authorization")
        } else {
            let data = "\(userId ?? ""):\(password ?? "")".dataUsingEncoding(NSUTF8StringEncoding)
            let base64Encoded = data?.base64EncodedStringWithOptions(NSDataBase64EncodingOptions(rawValue:0))

            headers["Authorization"] = "Basic \(base64Encoded ?? "")"
        }

        let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
        configuration.HTTPAdditionalHeaders = headers

        self.alamofire = Manager(configuration: configuration)
    }
```
 @cnoon Please re-read the bug description: Alamofire doesn't allow access to response and headers in case when server returns status code 401.

It is not support issue.
 @cnoon I've already posted it below:
1. Make the request to the server using request.authenticate() method with invalid credentials (so server will return 401 status)
2. You will receive nil response and -999 NSError instead response with headers.

This behaviour even represented in your tests here: https://github.com/Alamofire/Alamofire/blob/master/Tests/AuthenticationTests.swift

See method `testHTTPBasicAuthenticationWithInvalidCredentials()`:

```
func testHTTPBasicAuthenticationWithInvalidCredentials() {
        // Given
        let expectation = expectationWithDescription("\(URLString) 401")

        var request: NSURLRequest?
        var response: NSHTTPURLResponse?
        var data: NSData?
        var error: NSError?

        // When
        Alamofire.request(.GET, URLString)
            .authenticate(user: "invalid", password: "credentials")
            .response { responseRequest, responseResponse, responseData, responseError in
                request = responseRequest
                response = responseResponse
                data = responseData
                error = responseError

                expectation.fulfill()
            }

        waitForExpectationsWithTimeout(timeout, handler: nil)

        // Then
        XCTAssertNotNil(request, "request should not be nil")
        XCTAssertNil(response, "response should be nil")
        XCTAssertNotNil(data, "data should not be nil")
        XCTAssertNotNil(error, "error should not be nil")

        if let code = error?.code {
            XCTAssertEqual(code, -999, "error should be NSURLErrorDomain Code -999 'cancelled'")
        }
    }
```
 Ok thanks.

Sent from my iPhone

> On 06 Feb 2016, at 23:07, Christian Noon notifications@github.com wrote:
> 
> Thanks for all the info here @virl. Now I understand exactly what your concerns are and why you are seeing the behavior you are. This is NOT a bug. This is the exact behavior you should see. What happens when there is an authentication challenge is the following:
> 
> Request is made
> Server sends back authentication challenge for basic auth
> Alamofire provides credentials provided by authenticate
> Credentials are sent back to server
> Server rejects credentials and sends back authentication challenge again
> Alamofire cancels the request since authentication has failed
> The request is completed with a cancellation error and no response
> There is never a response generated in this scenario, which is why you won't see one when an authentication challenge fails. Hopefully that helps clarify things.
> 
> Cheers. üçª
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
  Nothing major changed here really, and mostly ran with the suggestions from Xcode.

I'm not sure if this needs to go on a `swift-2.2` branch for now, but I though I'd make this for now to try and help out.
  I want to collect server response latency metrics. 
As far as I can see there is no built in support for this in Alamofire.
I have two questions:
1- Is this something that (if done properly) would be of interest to the community?
2- Am I right in assuming the best place to do this is in the `Request` object? comparing the `init` timestamp with the `cancel` or different `taskdelegate` methods? 
  Platform : IOS 9.0.2 - iPhone 6S - xcode 7.2
Code to reproduce : 

```
let testString = "T√ºrkiye"
NSLog("testString: \(testString)")
let urlEncoded = ParameterEncoding.URL.escape(testString)
NSLog("testString: \(testString)")
NSLog("urlEncoded: \(urlEncoded)")
```
 Using Alamofire (3.1.2)
 It works on Simulator but crashes on Device so i gave device details. I will try with 3.1.5 and share the result
  Hi,

This method has a problem because URL doesn't are encoded.
I solved the problem using: stringByAddingPercentEscapesUsingEncoding(NSUTF8StringEncoding)
this method is deprecated.

func URLRequest(method: Method, _ URLString: URLStringConvertible, headers: [String: String]? = nil)
    -> NSMutableURLRequest
{
    let mutableURLRequest = NSMutableURLRequest(URL: NSURL(string: URLString.URLString.stringByAddingPercentEscapesUsingEncoding(NSUTF8StringEncoding)!)!);
    mutableURLRequest.HTTPMethod = method.rawValue

```
if let headers = headers {
    for (headerField, headerValue) in headers {
        mutableURLRequest.setValue(headerValue, forHTTPHeaderField: headerField)
    }
}

return mutableURLRequest
```

}
 For String "T√ºrkiye" it gives EXC_BAD_ACCESS code=1 address=0x0

```
        let testString = "T√ºrkiye"
        NSLog("testString: \(testString)")
        let urlEncoded = ParameterEncoding.URL.escape(testString)
        NSLog("testString: \(testString)")
        NSLog("urlEncoded: \(urlEncoded)")
```

IOS 9.0.2 - iPhone 6S
  If you go to [Alamofire's Cocoadocs page](http://cocoadocs.org/docsets/Alamofire/3.1.5/), you'll see there's an error parsing the pod. I ran into the same problem with my project, [ForecastIO](https://github.com/sxg/ForecastIO). The issue is that there are two .xcodeproj files at the root of the repo ("Alamofire.xcodeproj" and "iOS Example.xcodeporoj"). In order for Cocoadocs to properly generate docs for Alamofire, "iOS Example.xcodeproj" needs to be moved out of the root.
 It looks like Cocoadocs now supports `.jazzy.yaml` config files. Instead of moving the example project out of the root, you can add a jazzy config file that specifies which project should be used.
 FWIW, CocoaDocs works for Alamofire version 3.1.3: http://cocoadocs.org/docsets/Alamofire/3.1.3/
  Hi, in attempt to establish custom header in a **POST** request of **Content-Type: application/vnd.api+json**, goes all the same **Content-Type: application/json** also comes back an error (**Taking a look at your response status code (415) leads me to believe that you're not setting the Content-Type correctly in your request headers.**). Prompt please as correctly it to make that the inquiry would pass normally (**XCode 7.2, iOS 9.2**)

I'm try:
1) 
let headers = ["Content-Type": ""application/vnd.api+json""]
let request = alamofireManager.request(.POST, URLString,
parameters: postParameters,
encoding: .JSON,
headers: headers)

2) 
alamofireManager.session.configuration.HTTPAdditionalHeaders = ["Content-Type": "application/vnd.api+json"]

3) 
request.setValue("application/vnd.api+json", forHTTPHeaderField: "Content-Type¬ª)

4) alamofireManager.session.configuration.HTTPAdditionalHeaders?.updateValue("application/vnd.api+json", forKey: ¬´Content-Type")
  ``` swift
if let downloadTaskDidFinishDownloadingToURL = downloadTaskDidFinishDownloadingToURL {
                do {
                    let destination = downloadTaskDidFinishDownloadingToURL(session, downloadTask, location)
                    try NSFileManager.defaultManager().moveItemAtURL(location, toURL: destination)
                } catch {
                    self.error = error as NSError
                }
            }
```

if we try to downlaod a file more than once, we have to remove the old one first, or it will gives the error,
Error Domain=NSCocoaErrorDomain Code=516 "‚ÄúCFNetworkDownload_Sxtxfm.tmp‚Äù couldn‚Äôt be moved to ‚ÄúDocuments‚Äù because an item with the same name already exists."

should we remove the old file first?

``` swift
if let path = destination.path {
    if NSFileManager.defaultManager().fileExistsAtPath(path) {
        try NSFileManager.defaultManager().removeItemAtPath(path)
    }
  }
```
  I need the requests to be executed in order, although this is not working using Alamofire.

I want to print 1 to 30 in sequence (assuming the response is just an echo for the parameter)

```
    // Only 1 connection per Host

    let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
    configuration.HTTPMaximumConnectionsPerHost =  1
    configuration.timeoutIntervalForRequest = 30
    self.manager = Alamofire.Manager(configuration: configuration) 

    for i in 1...30 {
        manager.request(.GET, "http://httpbin.org/get", "i" : i], encoding: .JSON)
            .responseJSON { response in
                switch (response.result){
                case .Failure(let error):
                    print("error")
                    break;
                case .Success(let json):
                    print(json)
                }
         })
```
  Using:

```
    self.alamoManager.request(.POST, url, parameters: parameters, encoding: .JSON).responseJSON 
```

With a `parameters` having an unexpected type may produce VERY strange runtime errors.

Swift is supposed to be strongly typed. But it lets garbage in and then you get an error like:

> Invalid type in JSON write (_NSZeroData)

which has zero Google results.

I have no idea how to fix this on my end but the crashing code is inside AlamoFire, specifically at

> ```
> let data = try NSJSONSerialization.dataWithJSONObject(parameters, options: options)
> ```
 The simplest reproduction is:

```
Alamofire.request(.GET, "https://httpbin.org/get", parameters: [NSData()])
```
 Thank you, I will file the radar
  Hi,

Is there a way that oAuth2 is properly supported in this library? That the library refreshes the token, etc ...
 I saw that post and I adapted it. Tried to make it thread safe. Do you have a version that is thread safe because I only have made the isRefreshing and the append to the array thread safe?
  The URLRequest method of the URLRequestProtocol is executed in the main thread.

This is maybe a design choice but it looks to me as an incorrect way of handling this protocol since in al examples this is used as some form of request serializer. 
In a serializer you can expect potential heavy processing during encoding of the actual request body.
  I should send the webservice long parameters:
gameId: 123123

But getting the error with 400:
error = "Bad Request";
    exception = "org.springframework.http.converter.HttpMessageNotReadableException";
    message = "Could not read JSON: Can not deserialize instance of long out of START_OBJECT token\n at [Source: java.io.PushbackInputStream@376b10a1; line: 1, column: 1]; nested exception is com.fasterxml.jackson.databind.JsonMappingException: Can not deserialize instance of long out of START_OBJECT token\n at [Source: java.io.PushbackInputStream@376b10a1; line: 1, column: 1]"

How to solve this problem? Thx

code is below:
let URL = IConstant.BASE_URL + self.prefix_removeGame
        let parameters : [ String : AnyObject] = [ "gameId": removeGameRequest.gameId ]
        Alamofire.request(.POST, URL, parameters: parameters, headers: LoginManager.getBasicAuth(), encoding: .JSON)
            .validate().responseJSON { (response) -> Void in

```
            LoadingView.hideLoadingView(self.view)

            switch response.result {
            case .Success:
                self.mCouponResponse?.betHolders?.removeAtIndex(index)
                self.activeCouponTV.deleteRowsAtIndexPaths([indexPath], withRowAnimation: .Fade)

                self.fillView()
                break

            case .Failure:
                if (response.response?.statusCode == 401) {
                    self.showErrorAlert("Need to login again")
                } else {
                    self.showErrorAlert(Utils.getErrorMessage(response.data))
                }

                break
            }

            debugPrint(response.response?.statusCode)
    }
```
  Please support NSProgressReporting protocol
 You can access a manager with:

```
let manager = Alamofire.Manager.sharedInstance
```

If manager was [NSProgressReporting protocol](https://developer.apple.com/library/prerelease/ios/documentation/Foundation/Reference/NSProgressReporting_Protocol/index.html) compliant then you could use it with:

```
self.progressTracker = manager
```

Any network activity would be a child element of `manager.progress` and would communicate information externally.
 Got it, thank you for the explanation.
  How can i use below parameters in POST method as json encoded.

var params = [[String:AnyObject]]()

var param1 = [String:AnyObject]()
            param["phoneNumber"] = "7777777"
            param["firstName"] = "AA"

var param2 = [String:AnyObject]()
            param["phoneNumber"] = "88888"
            param["firstName"] = "BBB"

 params.append(param1)
 params.append(param2)
  Can this framework post UIImage file stored in Photos with parameters
 I just was working on the same thing and i think this will work and its short 
and check out issue #539 for more info

```
    Alamofire.upload(
        .POST,
        "https://httpbin.org/post",
        multipartFormData: { multipartFormData in

            let myInt = 3
            let myString = "test"
            multipartFormData.appendBodyPart(fileData: UIImagePNGRepresentation(image), name: "image", fileName: "random_name.png", mimeType: "image/png")
            multipartFormData.appendBodyPart(data: String(myInt).dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: true)!, name: "my_int")
            multipartFormData.appendBodyPart( data: myString.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: true)!, name: "my_string")

        },
        encodingCompletion: { encodingResult in
            switch encodingResult {
            case .Success(let upload, _, _):
                upload.responseJSON { response in
                    debugPrint(response)
                }
            case .Failure(let encodingError):
                print(encodingError)
            }
        }
    )
```
  Hi, this isn't an issue, just a question. 

In the README, section Manually installation,

> You will see two different Alamofire.xcodeproj folders each with two different versions of the Alamofire.framework nested inside a Products folder.
> 
> It does not matter which Products folder you choose from, but it does matter whether you choose the top or bottom Alamofire.framework.
> Select the top Alamofire.framework for iOS and the bottom one for OS X.
> 
> You can verify which one you selected by inspecting the build log for your project. The build target for Alamofire will be listed as either Alamofire iOS or Alamofire OSX.

![Alt text](https://monosnap.com/file/1dRsgn0EGweCch9NOvuzqiQY04Xwmy.png)

I see that the top `Alamofire.xcodeproj` is inside my application project, while the bottom `Alamofire.xcodeproj` is outside my application project. Why is the top iOS and the bottom OS X?
 @jshier many thanks
  This change adds a completionQueue to the manager class.
It changes the initializer of the request class to get the manager object instead of an NSURLSession and uses the new completionQueue in responsehandling.

If set the completenQueue will be used to dispatch the completenHandler to in the response methods.
  In the README, examples abound regarding response serialization. They are describing the process:

> Server response on the wire -> Alamofire -> JSON Object for the application

IMHO, this should be called **de**serialization.
  Upset.....I don't know what happened to the project .
I had imported the framework of Alamofire  via Cocoapods......
But I wrote these codes ,it told me "Type MSGistRouter" cannot conform to protocol "URLRequestConvertible"....I don't believe that's my bad luck.......
I believe that's a bug.....Actually Enum can conform to protocol .But here it's invalid......
I hope I could get your hand timely.....Thank you so much....Sorry to disturb your job....
 @MarcSteven can you please post your Enum here ?
 Yeah....You means it's from the enum .But actually enum both conforms to protocol .....
enum MYMasterRouter: URLRequestConvertible {
static let baseURLString :String = "api.github.com"
case getPublic() 
case getStared()
var URLRequest: NSMutableURLRequest {
    var method: Alamofire.Method {
      switch self {
      case .GetPublic:
        return .GET
      case .GetMyStarred:
        return .GET
 Can you Post the whole enum i think its not fully updated, Some code is missing.

##### Any way i am Updating with my EnumRouter as an example, i hope it will help you with your code

```
enum AlamofireRequest:URLRequestConvertible {
    static let baseURL = API_URL_DEFAULT
    case construct(Alamofire.Method,String,headers:[String:String],perms:[String:AnyObject]?)

    var URLRequest:NSMutableURLRequest {
        let construct:(method:Alamofire.Method,endPoint:String,encoding:Alamofire.ParameterEncoding,headers:[String:String],perms:[String:AnyObject]?) = {

            switch self{

            case .construct(let method, let endPoint,let header,let perms) where method == .POST || method == .PUT:

                return (method,endPoint,Alamofire.ParameterEncoding.JSON,header,perms)
            case .construct(let method, let endPoint,let header,let perms) :
                return (method,endPoint,Alamofire.ParameterEncoding.URL,header,perms)
            }

        }()

        let URL = NSURL(string: AlamofireRequest.baseURL)!
        let URLRequest = NSMutableURLRequest(URL: URL.URLByAppendingPathComponent(construct.endPoint))
        URLRequest.HTTPMethod = construct.method.rawValue
        URLRequest.allHTTPHeaderFields = construct.headers
        return construct.encoding.encode(URLRequest, parameters: construct.perms).0


    }

}
```
 Yeah I think it has no influence with the code.First of all I defined one enum .Then I let it conform to URLRequestConvertible ....In swift it's legal .....I did all I should do but cannot solve anything......It's strange I never met ....
 I did it via the step you offered ,but it occurred  error....I did nothing ,but today I opened my project,it ran well.
 Perhaps it's issue from Xcode.So Pls close the issue.....Thank you @jshier ......Sorry to disturb your time and job...Thank you so much.
  - I create new build configuration (Debug copy)
- Set target with new configuration : Build => Fail with error message: No such module 'Alamofire'
  Add @warn_unused_result attribute to trigger a warning if the result of a function or method isn't used
  I'm unable to handle the internal server error. So how to avoid it.
Like this
**SUCCESS: {
    code = 500;
    message = "There was an error processing your request. It has been logged (ID 37cfc9da1aa3df00).";
}**
  I want to take 3 request into a queue.  Do you have any idea?
  I'm using Alamofire 3.1.4 with Objectmapper and OHHTTPStub to test that my client is still compliant to the JSON format. The JSON-File is loaded from the Filesystem  by OHHTTPStub and mapped correctly. But Alamofire doesn't call the completion handler in this method because queue is nil I assume.
Do you have an idea what is wrong?

```
public func response<T: ResponseSerializerType>(
        queue queue: dispatch_queue_t? = nil,
        responseSerializer: T,
        completionHandler: Response<T.SerializedObject, T.ErrorObject> -> Void)
        -> Self
    {
        delegate.queue.addOperationWithBlock {
            let result = responseSerializer.serializeResponse(
                self.request,
                self.response,
                self.delegate.data,
                self.delegate.error
            )

            dispatch_async(queue ?? dispatch_get_main_queue()) {
                let response = Response<T.SerializedObject, T.ErrorObject>(
                    request: self.request,
                    response: self.response,
                    data: self.delegate.data,
                    result: result
                )

                completionHandler(response)
            }
        }

        return self
    }

```
  ```
static func sendMessage(message:String,callback:((isOk: Bool)->Void)) -> Void{
    let url = "http://localhost:8088/weijia-wim-web/message/sendmessage"

    /*let headers = [
        "Content-Type": "application/json",
        "dataType":"json"
    ]*/

    let parameters = [
        "message_from": "2",
        "message_to": "3",
        "message_content": message,
        "message_status": "0",
        "message_type": "1",
        "send_time": getDataTime
    ]

    Alamofire.request(.POST, url, parameters: parameters, encoding: .JSON)
        .responseJSON { response in

            if let rest = response.result.value {
                let text=JSON(rest)
                print("JSON: \(text)")
                let isok = text["msgCode"].stringValue
                if (isok == "666666"){
                    callback(isOk: true)
                }else{
                    callback(isOk: false)
                }
            }
    }
}
```

use encoding: .JSON  Background no response 

not use encoding: .JSON  Background response 

I use post JSON query background can be corresponding
  Alamofire.download crashes when returning NSURL without providing file path. 
`Alamofire.download(.POST, URLStringConvertible) { _, _ in
    return NSURL()
}`
  Hi. I want to make a bunch of requests. So far I have done it through a loop but I eventually get a 429 error code indicating I have made too many requests too quickly.

I am wondering how I would go about slowing my requests down?

I am basically just doing this right now:

```
        for match in mtches {
            Alamofire.request(.GET, user_url, headers: ["X-Auth-Token": tinder_token], encoding: .JSON)
        .responseJSON { response in
            print("RESPONSE")
```
 There are a few frameworks to do that as well, if you prefer going that route.
  As Swift is open-sourced, implementing server applications in Swift became reasonable. However, Swift on Linux is not fully-supported, currently.

The interface served by Alamofire is magnificent, in my opinion. However, as `NSURL` derivatives are not included in the Foundation (referring to Linux's one), we could not use Alamofire right now in Linux.

Correct me if I'm wrong, `NSURLRequest` derivatives are just cool wrappers around `CFHTTP` API. Again, I may be wrong, `CFHTTP` API is a layer beneath `libcurl` (I don't believe they actually made whole work with raw sockets, at least they could fork it).

We could implement NS'ish classes with `libcurl`, however I don't think it is a good idea. What about making an optional layer, implementing HTTP related classes in Swift?
 Suggested  path forward is to use urlsession.
https://grokswift.com/updating-nsurlsession-to-swift-3-0/?utm_content=buffer96e83&utm_medium=social&utm_source=twitter.com&utm_campaign=buffer

swift 3 - urlsession 
https://gist.github.com/cmoulton/149b03b5ea2f4c870a44526a02618a30

Also noteworthy - https://github.com/Awesome-Server-Side-Swift/TheList

UPDATE - I added ssh / port 22 from swift3 base image. 
makes it easier to upload files using cyberduck.io  
https://gist.github.com/johndpope/01a74ffb93921df48e334097117be1b3

see here -> 
https://github.com/Alamofire/Alamofire/issues/1225

need to reopen one of these tickets.
 Suggestion: lets move this discussion to #1935   I am creating a custom instance of Alamofire Manager and attaching additional headers to the configuration prior to initializing. I then use that manager to make a GET request. Here is how it is being initialized:

```
let config = NSURLSessionConfiguration.defaultSessionConfiguration()
config.timeoutIntervalForRequest = 20
config.TLSMinimumSupportedProtocol = .TLSProtocol12

var headers = config.HTTPAdditionalHeaders ?? [:]
headers[AppValues.NetworkValues.InternalOperationKey] = AppValues.NetworkValues.InternalOperationKey
headers["Accept-Encoding"] = "gzip"
headers["Accept"] = "application/json"

config.HTTPAdditionalHeaders = headers

manager = Manager(configuration: config)
```

Using this setup, on iOS 9, when I make the request using `manager.request`, the headers are attached properly and everything executes as expected. On iOS 8.4, executing the same code, the headers are empty on the request. If I attempt to print out the NSURLSessionConfiguration's `additionalHTTPHeaders` object using `po manager.session.configuration.HTTPAdditionalHeaders` prior to making the request, I can see the headers are populated. They are just not making it through to the actual request. 

Am I performing setup incorrectly here?
  Hey everyone,

I'm using Laravel 5.2 to develop my API and Alamofire to make my HTTP requests in my iOS app.

When I try to make a GET, PUT, DELETE request I receive a proper response.
But when I try to make a POST request it arrives in my web service as a GET request, so I get a GET response.

I tried to use an app from the AppStore to make HTTP Requests to my API and received a good POST response. Also using Postman I receive a good POST response.

I really don't know what the problem is since I've debugged everything. And I came to the conclusion that my app is not making a proper POST request for Laravel with Alamofire.

Here is my code, I've developed a Route Builder:

```
import Foundation
import Alamofire


enum UserRouter: URLRequestConvertible{

    static let baseURL = NSURL(string: "http://192.168.0.106/users")!

    case Users
    case CreateUser([String: AnyObject])
    case ReadUser(Int)
    case UpdateUser(Int, [String: AnyObject])
    case DestroyUser(Int)

    var URL: NSURL { return UserRouter.baseURL.URLByAppendingPathComponent(route.path) }

    var route: (path: String, parameters: [String: AnyObject]?) {

        switch self{

        case .Users:
            return ("/", nil)
        case .ReadUser(let userID):
            return ("/\(userID)", nil)
        case .CreateUser(let userInfo):
            return ("/", userInfo)
        case .UpdateUser(let userID, let userInfo):
            return ("/\(userID)", userInfo)
        case .DestroyUser(let userID):
            return ("/\(userID)", nil)
        }

    }

    var method: Alamofire.Method{

        switch self{

        case .Users:
            return .GET
        case .ReadUser:
            return .GET
        case .CreateUser:
            return .POST
        case .UpdateUser:
            return .PUT
        case .DestroyUser:
            return .DELETE

        }

    }

    var URLRequest: NSMutableURLRequest {

        let httpRequest = NSMutableURLRequest(URL: URL)
        httpRequest.HTTPMethod = method.rawValue

        switch self{

        case .CreateUser (let userInfo):
            return Alamofire.ParameterEncoding.URL.encode(httpRequest, parameters: userInfo).0
        default:
            return Alamofire.ParameterEncoding.URL.encode(httpRequest, parameters: (route.parameters ?? [ : ])).0

        }

    }

}

//Testing the Route Builder
func testRoute(){

    print(Alamofire.request(UserRouter.CreateUser(["name":"test"]))) //Output: POST http://192.168.0.106/users/

    Alamofire.request(UserRouter.CreateUser(["name":"test"])).responseJSON{ (response) in

        switch response.result{

        case .Success(let data):
            print (data) //Output: My GET response :(
        case .Failure:
            print("fail")
        }

    }

}

```
 If you could analyze the packet data with some network analyzer (i.e. Wireshark) and then paste it here, we would reproduce the problem (easily).

Also, do not forget to test your HTTP Server API with a forward tool like cURL. Different HTTP server implementations interpret HTTP methods in awkward ways, be aware of it and be sure you are sending a request that it is finesse (from servers aspect). The only way to reach this is inspecting each layer on an analyzer.
 Ok. I'll get the analysis and paste it here.

Meanwhile I did some new tests and got new information.

First, I created a "post.php" and placed in my Laravel public folder:

```
<?php
    /**
     * Created by PhpStorm.
     * User: renato
     * Date: 06/01/16
     * Time: 18:13
     */


    $method = $_SERVER['REQUEST_METHOD'];
    $json = json_encode(['response' => $method], true);

    echo $json;
```

Then I tested:

```
//Without UserRouter
Alamofire.request(.POST, "http://192.168.0.106/post.php", parameters: [:]).responseJSON{ (response) in

        switch response.result{

        case .Success(let data):
            print (data)
        case .Failure:
            print("fail: create")
        }

    }

OUTPUT: {"response":"POST"}

```

And then:

```
//Using UserRouter and changing the URL to match: "http://192.168.0.106/post.php"
Alamofire.request(UserRouter.CreateUser(["name":"test"])).responseJSON{ (response) in

        switch response.result{

        case .Success(let data):
            print (data)
        case .Failure:
            print("fail: create")
        }

    }

OUTPUT: {"response":"GET"}
```
 Here you go, I used Wireshark as you said: (Sorry, I don't know if there is another way to export the data)

[alamofire_request.pdf](https://github.com/Alamofire/Alamofire/files/81676/alamofire_request.pdf)
[postman_request.pdf](https://github.com/Alamofire/Alamofire/files/81677/postman_request.pdf)
 @jshier This is what I get:

```
print(Alamofire.request(UserRouter.CreateUser([:])).description)

OUTPUT: 
POST http://192.168.0.106/post.php/

// ------------------------------------------------------- //

print(Alamofire.request(UserRouter.CreateUser([:])).debugDescription)

OUTPUT:
$ curl -i \
    -X POST \
    -H "Content-Type: application/x-www-form-urlencoded; charset=utf-8" \
    -H "Accept-Language: en-US;q=1.0" \
    -H "Accept-Encoding: gzip;q=1.0,compress;q=0.5" \
    -H "User-Agent: iosApp v1/com.renatop.iosapp (1.0.0; OS Version 9.2 (Build 13C75))" \
    -d "" \
    "http://192.168.0.106/post.php/"

```

And that curl command outputs:

```
HTTP/1.1 301 Moved Permanently
Date: Thu, 07 Jan 2016 20:54:20 GMT
Server: Apache/2.4.16 (Unix) PHP/5.5.29
Location: http://192.168.0.106/post.php
Content-Length: 237
Content-Type: text/html; charset=iso-8859-1

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
<title>301 Moved Permanently</title>
</head><body>
<h1>Moved Permanently</h1>
<p>The document has moved <a href="http://192.168.0.106/post.php">here</a>.</p>
</body></html>
```
 I'm having similar issues where POSTs and DELETEs are being treated like GETs. Also using the router pattern. This is using a production configuration.
 @davidbjames take a look at my question at StackOverflow, maybe will help you fix your problem

http://stackoverflow.com/questions/34620515/post-requests-in-alamofire-parameter-encoding-returning-get-responses
  https://github.com/Hokila/Alamofire

I think my setting is something wrong
iOS Example.xcodeproj. I copy Debug configuration and named Develop.
build error in Develop but success in Debug
and also fail when I want to archive
 in addition,I use manually install to my project.
not use cocoapods
 I think this is also a bug in iOS Example.xcodeproj
Can not archive!!
  Hi!

This is a silly pull request, please, feel free to close it immediately if you find it intrusive or anything like that.
This contains a hacky implementation of .retry(count), that you can use to chain any Request on.

It doesn't include any tests and it shouldn't be merged.
It includes a modified Example-iOS project that demonstrates its usage.

I'd really appreciate if I could get some feedback on this.
I read that the reason why retry() is left out of this library is the extra clutter it would bring to the public API. I'm definitely not saying that this simplistic implementation (with basically zero configuration options) would do the trick, but it would have definitely helped me in certain scenarios. I also feel like the fluent interface of Request makes it an ideal candidate to choose between retry policies (including custom ones) in the future.

I am motivated here by the poor retry implementations I've seen in different apps I worked on. It would be awesome to give people a tool to manage it better!:) And I'm happy to contribute in the proper implementation of this feature.

Thanks!
  There is a requirement in my project, system will put access token on http header but if the access token is not exist or expired, all requests should be in pending status and waiting for the response of get access token, I want to know to how make a good pattern to control multi-requests dependency.
  how can I upload MultipartFormData with progress?it seems there is no api for that
 thank you very much!!!!!
 and I can't find the way to pause an upload task when uploading
 Thanks for your kind  answer,but I just want to cancel the task whenever i want to...and I can't find the way yet T T
 @cnoon Is  "Uploading MultipartFormData with progress" also available in version 4? Im trying to upgrade to alamofire 4 and cant find any implementation in migration refs.
 `Swift 3` with **Alamofire 4**

Here you go 

```
 Alamofire.upload(multipartFormData: { (multipartFormData) in

            //append your data here
            //e.g multipartFormData.append(data, withName: "key")

        }, to: "https://httpbin.org/post", method:.post) { (result) in
                switch result {
                case .success(let request, _, _):
                    request.uploadProgress(closure: { (progress) in
                        print("Upload Progress: \(progress.fractionCompleted)")
                    })
                    request.responseJSON { final in
                        debugPrint(final)
                    }

                case .failure(let error):
                    print(error)
                    break

                }

        }


```
 Thanks, my question was about the current implementation of progress like in v3 was like "upload.progress { bytesWritten, totalBytesWritten, totalBytesExpectedToWrite in... " 
Is the any similar method to update the a progressview? 
 Alamofire has adopted with better way using `NSProgress`  aka `Progress` class which has wonderful methods can easily track total progress no need for calculation. 

_you method has been replaced with_ 

**Alamofire 3** 

```
progress { bytesRead, totalBytesRead, totalBytesExpectedToRead in
     print("Bytes: \(bytesRead), Total Bytes: \(totalBytesRead), Total Bytes Expected: \(totalBytesExpectedToRead)")
}
```

**Alamofire 4**

```
 request.uploadProgress(closure: { (progress) in
     print("Upload Progress: \(progress.fractionCompleted)")
})
```
  Below is the code of my URLRequestConvertible

``` swift
  enum Router: URLRequestConvertible {
        static let baseURLString = "http://example.com/"

        case LoginRequest(String, String)
        case SignUpRequest(String)
        case ForgotPasswordRequest(String)

        var URLRequest: NSMutableURLRequest {

            let result: (path: String, method: Method) = {
                switch self {
                case .LoginRequest:
                    return ("/AppUsers/login", .POST)
                case .SignUpRequest:
                    return ("/AppUsers/add", .POST)
                case .ForgotPasswordRequest:
                    return ("/AppUsers/forgot_password", .POST)
                }
            }()

            let URL = NSURL(string: Router.baseURLString)
            let request = NSURLRequest(URL: URL!.URLByAppendingPathComponent(result.path))
            let encoding = ParameterEncoding.JSON

            request.URLRequest.HTTPMethod = result.method.rawValue
            return encoding.encode(request, parameters: nil).0
        }
    }
```

Now, I have below request which is working fine:

``` swift
     Alamofire.request(.POST, CommunicationService.Router.LoginRequest(txtUsername.text!, txtPassword.text!).URLRequest, parameters: ["email_id": txtUsername.text!, "password": txtPassword.text!], encoding: ParameterEncoding.JSON, headers: nil).responseJSON(options: NSJSONReadingOptions.MutableContainers) { (response) -> Void in
            print(response)
        }
      // -------
```

But I want to make the use of URLRequestConvertible for Parameter passing for POST request. Let me know what is the best way for POST request using below API:

``` swift
request(.POST, CommunicationService.Router.LoginRequest(txtUsername.text!, txtPassword.text!).URLRequest).responseJSON(completionHandler: { (response) -> Void in
            print(response)
            })
```

Actually, above code is giving Invalid response with below error message

**FAILURE: Error Domain=NSCocoaErrorDomain Code=3840 "Invalid value around character 0."** **UserInfo={NSDebugDescription=Invalid value around character 0.}**

What's wrong with the request generated using request(Method, URLStringConvertible) method?

Can any one help me?
 Hello Cnoon, 

Got your point. I have posted the updated code in StackOverflow. http://stackoverflow.com/questions/34573547/post-request-using-alamofire-request-and-urlrequestconvertible 

Still there is the same issue. The reason I have debugged is that below code does not sets the POST method in HTTPMethod property of URLRequest

```
request.URLRequest.HTTPMethod = result.method.rawValue
```

I tried setting String value explicitly, but the same issue. Also, I found that HTTPMethod is the getter property in NSURLRequest but in NSMutableURLRequest, we can set, but still the issue remains same.
Any guess why?
 The reason why compilation error is not coming is that I am using **request.URLRequest** which is ultimately NSMutableURLRequest.

Regarding your suggestion, I have already tried that and I have posted same code in StackOverflow.
 Saved the day :) .... Thanks for your all help. Got the solution. I have used request(URLRequestConvertible)  instead of request(method, URLRequestConvertible).
  Hi there! Big fan of this project. We use it in Moya but [have an issue](https://github.com/Moya/Moya/issues/350) where requests are started immediately (even when "stubbing" the requests for unit testing). A [potential fix](https://github.com/Moya/Moya/pull/354) is to modify the shared manager instance, but I don't really like that idea since someone might change it back. I'd like to continue to rely on the shared instance, too.

A solution could be to add a  `startRequestsImmediately` parameter to the `request` functions (either or both) that would let developers decide on a per-request basis what to do. I couldn't find any discussion on the topic in existing issues so I thought I'd bring it up. 
 Cool, thanks for the reply! I think using our own manager makes sense (we allow developers to pass in their own). It doesn't sound like there are any repercussions from _not_ using the shared manager ‚Äì though we ought to document this so that someone doesn't think that Moya uses the shared manager when it in fact doesn't. 

Thanks a lot for your feedback! I think this resolves the issue from our end üôá
 Yeah! We currently [default to the shared instance](https://github.com/Moya/Moya/blob/cf9fb911c900ef42ef52f47cd88f8ec1f6cd3a31/Source/Moya.swift#L57) but I think switching to the return value of a static function would suffice. Thanks again!
  Node.js

router.get('/mp3', function(req, res, next) {

```
var lists = [

{
    title : "Conversation 01", desc : "xxxx" , url : "xxxx"


},
{
    title : "Conversation 02", desc : "xxxx" , url : "xxxx"

}



];
```

  res.json(lists);
});

Swift 2.1

Alamofire.request(.GET, "https://myserver/mp3", parameters: ["foo": "bar"])
         .responseJSON { response in
             print(response.request)  // original URL request
             print(response.response) // URL response
             print(response.data)     // server data
             print(response.result)   // result of response serialization

```
         if let JSON = response.result.value {
             print("JSON: \(JSON)")
         }
     }
```

Error Domain=NSCocoaErrorDomain Code=3840 "Invalid value around character 0." UserInfo={NSDebugDescription=Invalid value around character 0.

The error is returned only on the real device!
No issue for the iOS Simulator!

**## The problem is resolved by putting "nil" for the parameters!**
 @softmastx I am suffering in the same problem. Have you found the real reason and solution?
 This is insane. It worked without problems until like 30 minutes ago and then all of a sudden I get this error. And all this happened without touching the network related code :| I guess it must be something since I integrated Frabric's Crashlytics sdk. I'll investigate some more.

10 minutes later it works again. It's not the server side that causes the problem because I was consuming google place API JSON and it worked from Postman so I guess it's some VooDoo magic involved here...
 I debugged into source codes of `Alamofire` and found that the key logic was in `func JSONResponseSerializer` of the file `ResponseSerialization.swift`. You can print out the variable `validData` like following.

```
    do {
        // print(String(data: validData, encoding: NSUTF8StringEncoding))
        let JSON = try NSJSONSerialization.JSONObjectWithData(validData, options: options)
        return .Success(JSON)
    } catch {
        return .Failure(error as NSError)
    }
```

The most possible criminal is the network itself. In my case, the web server returns an invalid JSON **SOMETIMES**.

By the way, is there a place to record common problems for `Alamofire` users except Stack Overflow? It can avoid bothering maintainers. @cnoon 
 I'm getting the opposite where it fails on simulator but not on real device.

With `.validate()` in place I get,

```
FAILURE: Error Domain=com.alamofire.error Code=-6003 "Response status code was unacceptable: 403" UserInfo={NSLocalizedFailureReason=Response status code was unacceptable: 403}
```

Without `.validate()` I get, 

```
 FAILURE: Error Domain=NSCocoaErrorDomain Code=3840 "Invalid value around character 0." UserInfo={NSDebugDescription=Invalid value around character 0.}
```
 +1
 +2
 I used `.responseString` instead of `.responseJSON` It worked.
When you Interact with Django API this is what you use.
 this is not resolved yet and someone just closed it.
 riot!
  I need to use `.Custom` encoding without parameters.

This is a specific case in Dropbox's iOS SDK.

https://github.com/dropbox/SwiftyDropbox/blob/master/Source/Client.swift#L177-L181

``` swift
// params: JSON
let request = client.manager.request(.POST, url, parameters: [:], headers: headers, encoding: ParameterEncoding.Custom {(convertible, _) in
    let mutableRequest = convertible.URLRequest.copy() as! NSMutableURLRequest
    mutableRequest.HTTPBody = dumpJSON(params)
    return (mutableRequest, nil)
})
```

In this case, parameters is not required but, the Custom encoding closure is not called.

I hope to fix it so that it does not check the parameters for only case of `.Custom`.
 Thanks for your polite reply :bow:
I understood the behavior of `.Custom` and I was fixed SwiftyDropbox.
  I hope that debugDescription of Request with an invalid URL do not crash.

I added the guard statement so as not to crash even when the URL was invalid.
  Use `map` instead of `for` loop and mutation. `prefix(5)` is equivalent to `if q <= 0.5 { break }` in the loop.
 Thanks a lot!
  I like much of Alamofire but with background sessions there isn't any build it features to simplify re-connecting to background session tasks after an app restart. I've in the past used a serialisable delegate class that methods for the various delegates involved that was passed as part of a request. This would be serialised to the file system for requests associated with background session. These would automatically be reloaded on app restart and the idea being they would contain all the information necessary to continue tracking the task. This doesn't however map that well to Alamofire's design. So instead what I've done is add a dictionary to Request that will be serialised if Request is associated with background session. This means the data can be read after an app restart. I've also made it so that Request get re-created when referenced by background session task after an app restart. Add to this two methods to allow Requests created this way to be re-connected to delegate closures and managing background sessions is simpler. This all could have been done with code in the client app using existing Alamofire framework but better to have some support built in I think. Check out the example app additions for how I envisage it could be used. Go into background downloads, click the + a few times, exit page and then go back - this re-connects to new VC - terminate app by terminating session under debugger - restart and it all reconnects if you go back in the page.

This is just presented as a concept and am sure needs further discussion and adjustment but let me know what you think and whether you feel its an approach that makes sense for you. Happy to continue in this direction to incorporate your feedback if you wish.

All the best
Mark
 No problem - any questions let me know !
 No problem - not unsurprising as big change as you say - look forward to v4 - happy to contribute / give feedback as framework moves forward. All the best Mark
  Alamofire.Manager.sharedInstance.session.invalidateAndCancel()

Not able to make request after above line execution
  Hi,

I have a framework which uses Alamofire - but it fails when executing Framework's tests. When I execute tests without Alamofire Dependency in the project - it succeeds. The error message I get:

``` javascript
Test target *** encountered an error (Early unexpected exit, operation never finished bootstrapping - no restart will be attempted)
```

I load Alamofire via Carthage:

``` javascript
github "Alamofire/Alamofire" ~> 3.0
```

My XCode Version is 7.2

Steps to reproduce:
1. Create a new Xcode iOS Framework Project using Swift 
2. Build & Execute Unit Tests - all seems fine
3. Go on and create the Cartfile.private with the above mentioned Alamofire dependency
4. Run > carthage update --platform iOS
6. Add the Alamofire.framework to your project -> via Add Files
5. Build and execute Tests again - The tests will fail - you will see the error in your build logs

Any ideas?
Cheers
  I setup up a web server on localhost with self-sign Certificate file, but I can't POST data to the Server over HTTPS. 

let serverTrustPolicies: [String: ServerTrustPolicy] = [
            "localhost": .PinCertificates(
                certificates: ServerTrustPolicy.certificatesInBundle(),
                validateCertificateChain: true,
                validateHost: true
            ),
            "insecure.expired-apis.com": .DisableEvaluation
        ]

```
    let manager = Manager(
        serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies)
    )
```

manager.request(.POST, "https://localhost/index.php", parameters: nil).responseString { (response) -> Void in
            print(response.result.value)
        }

print result is nil
 validateCertificateChain: true, => Change it to false.

You should try to ask this kind of questions on stack overflow (as instructed to in the readme).
Buy the way, you should also get a real certificate. Especially since you have a free option with https://letsencrypt.org
 I override NSURLSessionDelegate like this below: (validateCertificateChain: true, => Change it to false. is not useful)  
func URLSession(session: NSURLSession, didReceiveChallenge challenge: NSURLAuthenticationChallenge, completionHandler: (NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void) {
        if let localCertificateData = self.localCertData {//NSData
            if let serverTrust = challenge.protectionSpace.serverTrust,
                certificate = SecTrustGetCertificateAtIndex(serverTrust, 0),
                remoteCertificateData: NSData = SecCertificateCopyData(certificate) {
                    if localCertificateData.isEqualToData(remoteCertificateData) {
                        let credential = NSURLCredential(forTrust: serverTrust)
                        challenge.sender?.useCredential(credential, forAuthenticationChallenge: challenge)
                        completionHandler(NSURLSessionAuthChallengeDisposition.UseCredential, credential)
                    } else {
                        challenge.sender?.cancelAuthenticationChallenge(challenge)
                        completionHandler(NSURLSessionAuthChallengeDisposition.CancelAuthenticationChallenge, nil)
                        self.sSLValidateErrorCallBack?()//a block
                    }
            } else {
                NSLog("Get RemoteCertificateData or LocalCertificateData error!")
            }
        } else {
            completionHandler(NSURLSessionAuthChallengeDisposition.UseCredential, nil)
        }
    }
 Did you ever figure this out. I had a similar issue and it was caused by my not declaring manager globally. The following declaration of manager fixed it for me:

```
class AppTests: XCTestCase {
    let manager: Alamofire.Manager = {
    let serverTrustPolicies: [String: ServerTrustPolicy] = [
    "yourdomain.com": .DisableEvaluation
]

let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
configuration.HTTPAdditionalHeaders = Alamofire.Manager.defaultHTTPHeaders

return Alamofire.Manager(
    configuration: configuration,
    serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies)
)
}()
```

Also, @dickwu, for future references, I recommend that you to prepend each line of your code with four spaces so that it is easier to read. Doing so is how I achieved the code display that you see above.
  Alamofire has ActivityLogger like AFNetworkActivityLogger for AFNetworking ? If not, has plan to do it ?
 Put this extension in your project 

```
extension Request {
    public func debugLog() -> Self {
       #if DEBUG
            debugPrint("API Name ::::::::::::::::::",self.request!.URL,terminator: "\n\n")
            debugPrint(self)
            debugPrint(terminator:"\n\n")
        #endif
        return self
    } 
}

```

##### Please don't forget to Add -D -DEBUG flag in the Other swift Flags

i Also use this tool https://github.com/kasketis/netfox for network debugging in the App, it just has few steps and you are ready to goooo ... 
 We've been using this library https://github.com/andysmart/Timberjack to log the requests.
 contains params in url?
 +1  Yesterday I imported the library into my project via cocoapods.But it told me there's a error.the error displayed .I changed the setting of target
1,Click the target 
2,enter into the setting of Build  Phases .and then -Enbed Framework...Selected the item "Run script only when installing".The order is over.The error disappeared completely....
  Alamofire not support iOS 7
any solution to use on ios7?
 Hi @sonysm ,

I think that in the requirements of **Alamofire**, they said:

> iOS 8.0+ / Mac OS X 10.9+ / tvOS 9.0+ / watchOS 2.0+
> Xcode 7.2+

But, check these links:
- http://stackoverflow.com/questions/29218475/alamofire-with-ios-7
- http://stackoverflow.com/questions/27273673/importing-alamofire-in-project-that-targets-ios-7
  I hope this will help ;)
   suppose i make 5 request at a time and now i want to cancel all that,i got below lien for that Alamofire.Manager.sharedInstance.session.invalidateAndCancel()
but after that i am not able to request again.
 than how i can i cancel all current request ?
 Please provide answer for above.
 i want to cancel all the current requests how i can?
  Hello,
Thank you for this great library !
I embedded alamofire into my project but I have something strange with it.

(My api is double checked and works well with other clients so we can assume the problem come from alamofire)

When I call alamofire :

```
    let request = Alamofire.request(.GET, endpoint + "/rooms/" + String(roomId), encoding: .JSON)
        .responseJSON { result in
            print(result)
            callback(result)
    }
```

the print display wrong result data. 90% are corrects but "id" are fully wrong for nested objects :

It has this structure : 
{
    id = 7; // Correct !
    lights =     (
         {
            id = 1; // Wrong it should be 33
            on = 1; // Correct
        },
         {
            id = 2 ; // Wrong it should be 7
            on = 1; // Correct
        },
         {
            id = 3 ; // Wrong it should be 3
            on = 0; // Correct
        },
    );
    name = sample;

Do you have an idea where does it come from in alamofire ? I tryed to read the code but I am a beginner so your help is welcome :)

Version used : 3.1.4

Cheers,
Seb
 @cnoon  My api return the same result I used wireshark to check my api it send the same things to ios as for angularjs web client.

I really think it's an issue from alamofire. I will try another rest dep for swift and look if it works. So that we can see if it's an alamofire problem or not.
 @sebastienvermeille Maybe you could create a sample project which reproduce the issue ?
  Hi there,

I don't get the result method from the 'response'. What do I wrong?

![Image of Xcode](http://i.imgbox.com/HE5om6WP.png)
  Commit: 0e9761f8b22574247ed17a77edea7b592eeb65cc (3.1.2 -> 3.1.3) introduced an early return if the parameters are empty. This renders any custom parameter encoding, that might want to explicitly handle the empty case invalid.

I think this should only apply for non custom encoding.
  In the intent of addressing #965, I saw an opportunity to merge URL and URLEncodedInURL to simplify the encoding process even more and give some extra facilities such as the [so](#251) [requested](#329) "square bracket-less" array parameters support.
 Thanks @cnoon, I totally get your reasoning. I just decided to fork Alamofire to adjust it to my current necessities and sent this pull requests as a suggestion for future versions.

Thanks for your answer üçª
 >There is no official RFC spec for any of the collection formatting

Brackets are illegal characters for parameter names (regardless if it is a collection or not) according to https://tools.ietf.org/html/rfc6570#section-2.3  Hello,
currently if I use an array for a parameter Alamofire URL method encodes it with square bracket like:

```
&foo[]=bar&foo[]=bar2
```

I understand the meaning and it is also specified that:

```
Since there is no published specification for how to encode collection types, the convention of appending `[]` to the key for array values (`foo[]=1&foo[]=2`), and appending the key surrounded by square brackets for nested dictionary values (`foo[bar]=baz`)
```

However, even some modern servers that uses RestEasy with JAX-RS accept this format for arrays:

```
&foo=bar&foo=bar2
```

For this reason, I'd like to propose to have the ability to customise this behaviour with an option in order to support both cases.

It's a simple change that I can help doing and I think it will add flexibility to the library and will avoid the usage of the Custom method for this simple case.

What do you think?

Thanks,
Dem
 Exactly the issue I'm dealing with currently. I'm pretty sure this would be pretty straightforward to implement.

Here's a custom bracket-less `ParameterEncoding` object for anyone interested in a workaround:

``` swift
ParameterEncoding.Custom { requestConvertible, parameters in
    let (mutableRequest, error) = ParameterEncoding.URL.encode(requestConvertible, parameters: parameters)
    mutableRequest.URL = NSURL(string: mutableRequest.URLString.stringByReplacingOccurrencesOfString("%5B%5D=", withString: "="))
    return (mutableRequest, error)
}
```

Too much boilerplate code for a simple little option IMO.

An elegant solution I can think of is:

``` swift
public enum ParameterEncoding {
    case URL(brackets: Bool)
    [...]
}
```

And then:

``` swift
Alamofire.request(.GET, url, encoding: .URL(brackets: false))
[...]
```
 Needless to say I don't agree that it's not commonly used, maybe in your experience it's not but I'm using a commonly used modern java framework so it's not that unusual. Also, beside the pull proposal from DavidRoman, it can be implemented in a backward compatible way (default config is like it is now, and you can change if you want) and you will support both commonly used use cases.

Obviously you (the team) decide what you want to do, but saying "it's not commonly used" is not an acceptable answer in my opinion.

Same thing for multiple encoding methods in a single request (https://github.com/Alamofire/Alamofire/issues/374): you (the team) say it's not common but again it's not common for you, it's a very common pattern that happens regularly and it feels like Alamofire doesn't support basic patterns out of the box. You also felt that and fixed what originally was "uncommon" saying it was common for you: https://github.com/Alamofire/Alamofire/pull/742

So again, in my opinion the issue of this specific ticket is a common problem that should be addressed by Alamofire.

Cheers,
Dem
 Thank you for "New Parameter Encoding Protocol". It is the great benefit
Now how to use it? How to convert code from  @DavdRoman answer?
  I have been getting numerous matches coming from Alamofire in different places in my app, but all coming from the same code lines in Alamofire. This is the problematic point:

![screen shot 2015-12-16 at 7 03 28 pm](https://cloud.githubusercontent.com/assets/4066863/11860269/ebeabde0-a427-11e5-9d3b-306f7304c920.png)

Does anyone have any insights, has this already been fixed? Thanks!
 Thanks for your quick response.

Here is some more information for you:

Thread : Crashed: com.apple.main-thread
0  Keeper                         0x100212c34 MyVouchesViewController.(getVouches(MyVouchesViewController) -> () -> ()).(closure #2) (MyVouchesViewController.swift:129)
1  Alamofire                      0x1005f51f8 _TPA__TTRXFo_oGV9Alamofire8ResponsePSs9AnyObject_CSo7NSError__dT__XFo_iGS0_PS1__S2___dT__ + 84
2  Alamofire                      0x1005f712c _TTSg5GV9Alamofire18ResponseSerializerPSs9AnyObject_CSo7NSError_GS0_PS1__S2__S_22ResponseSerializerTypeS__S2_S2_Ss9ErrorType10Foundation_PS1_____TFFFC9Alamofire7Request8responseuRq_S_22ResponseSerializerType_FS0_FT5queueGSqPSo17OS_dispatch_queue__18responseSerializerq_17completionHandlerFGVS_8Responseqq_S1_16SerializedObjectqq_S1_11ErrorObject_T__DS0_U_FT_T_U_FT_T_ + 292
3  libdispatch.dylib              0x180655630 _dispatch_call_block_and_release + 24
4  libdispatch.dylib              0x1806555f0 _dispatch_client_callout + 16
5  libdispatch.dylib              0x18065acf8 _dispatch_main_queue_callback_4CF + 1844
6  CoreFoundation                 0x180bb8bb0 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 12
7  CoreFoundation                 0x180bb6a18 __CFRunLoopRun + 1628
8  CoreFoundation                 0x180ae5680 CFRunLoopRunSpecific + 384
9  GraphicsServices               0x181ff4088 GSEventRunModal + 180
10 UIKit                          0x18595cd90 UIApplicationMain + 204

That's the full stack trace, as you can see it is going straight to alamofire. I have seen this in other places, and it happens _infrequently_ but still happens, and in the exact same location in Alamofire every time it does.

Here is the code:

```
    Alamofire.request(.GET, GlobalVars.server + "/userVouches/" + ProfileModel.sharedInstance.id)
        .authenticate(user: ProfileModel.sharedInstance.id, password: ProfileModel.sharedInstance.accessToken)
        .responseJSON { response in
            switch response.result {
            case .Success(let json):
                print("Success: \(response.response?.URL)")
                ProfileModel.sharedInstance.vouches_received = JSON(json).dictionaryObject!["vouches"] as! [[String:AnyObject]]
                self.vouches = ProfileModel.sharedInstance.vouches_received
                ProfileModel.sharedInstance.fetched_vouches = true
                self.tableView.reloadData()
                self.fitTableViewSize()
            case .Failure(let error):
                print("Error: \(error)")
            }
            SVProgressHUD.dismiss()

    }
```

The failure is always where the last closing bracket is, where responseJSON closes.
Let me know if I can provide additional information. It is very hard for me to debug Alamofire as the naming seems to be scrambled.
  Add info about AlamofireObjectMapper to new Third-Party Libraries section
  This makes it possible to specify a dispatch queue when using responseJSON.

Also it's not possible to get this behaviour with the current version of Alamofire, because the property `response` from `Request` hides the function 

``` swift
func response<T: ResponseSerializerType>(
        queue queue: dispatch_queue_t? = nil,
        responseSerializer: T,
        completionHandler: Response<T.SerializedObject, T.ErrorObject> -> Void)
        -> Self
```
 I tried to put it in an extension:

```
extension Alamofire.Request {
    public func responseJSON(
        queue queue: dispatch_queue_t? = nil,
        options: NSJSONReadingOptions = .AllowFragments,
        completionHandler: Response<AnyObject, NSError> -> Void)
        -> Self
    {
        return response(
            queue: queue,
            responseSerializer: Request.JSONResponseSerializer(options: options),
            completionHandler: completionHandler
        )
    }
}
```

But that didn't work:
![screen shot 2015-12-16 at 11 43 49](https://cloud.githubusercontent.com/assets/248861/11838922/55b1ae7a-a3ea-11e5-875d-2a5206bf3e6b.png)
Hence my PR

Turns out, I had a `Request` struct in the project that was hiding Alamofire's `Request` class. After prefixing `Request` in the function with `Alamofire.` it works. So it was just a unhelpful error message from Xcode. Thanks!
  Everytime I try calling the function, it throws the error unexpectedly found nil while unwrapping an optional value. I Even tried passing static value in the setCustomerLocality function. But nothing seems to work for me. I think that the way I am passing parameter is giving me the issue.

![image](https://cloud.githubusercontent.com/assets/7240389/11738744/a8c47dd0-a00d-11e5-962d-056f1d30aae4.png)
  In certificatesInBundle, check for well-formed certificates with
extensiions .cer, .crt, .der, and check for upper and lower case
extensions (OSX filesystem may or may not be case sensitive. iOS
always is)

DER is a binary encoding format
PEM is an ASCII encoding format
.crt is the most common certificate extension, may be DER or PEM
.cer is a Microsoft extension convention, may be DER or PEM
.der is a (poor) extension referring to encoding instead of
contents, these may contain a certificate and/or a key.

Apple's SecCertificateCreateWithData only accepts DER-encoded certificates
  Sorry for such little fix. I'm not sure that this is ok.
Search problem takes about five minutes, but it is much easier to see commands that just doing the right thing.
  When passing in an empty dictionary for `parameters`:

_Current:_

```
let query = request.URL?.query    // "" (empty string)
let URLString = request.URL?.absoluteString    // "http://www.example.com/&" (URL has "&" appended)
```

_This PR:_

```
let query = request.URL?.query    // nil
let URLString = request.URL?.absoluteString    // "http://www.example.com"
```
 @cnoon Yeah, I'll do that at some point today for you.
I didn't want to touch anything affecting any of the other encoding methods, as I hadn't tested how they are handling the scenario. When making changes to a library I don't own, I traditionally like to make my changes as conservative as possible, but if you are good with changing this for all encoding methods, I'll happily make the change.
 @cnoon Refactor completed.
  Currently, the ENABLE_TESTABILITY flag is enabled for release builds. This appears to have been turned on to support building with Carthage, but setting up the projects schemes so that they don't build tests except when tests are being run achieves the same goal without incurring the performance impact that enabling testability can have. This PR leaves the ENABLE_TESTABILITY flag in the default state -- on for debug, off for release.

It's possible there's some other consideration of which I'm unaware, but at least with respect to Carthage builds, this configuration works equally well without the downside of always having ENABLE_TESTABILITY on.
 Adding -- These build settings are the current default for new projects in Xcode.
 I'm curious -- how does this impact the ability to run Alamofire tests? I ran the projects test suite before and after with the exact same results. Essentially all this would do is use the standard Xcode project defaults for a new project with unit tests.

Perhaps my description of the pull request set off alarm bells that it shouldn't have? Either that, or there is an issue with running tests of which I'm not aware.
 (Adding: Thanks for taking a look at the PR and for the work you do on Alamofire.)
 @cnoon Adding one more thing -- the project currently works fine with Carthage. The motivation here is to disable testability in release mode because it negatively impacts performance.

Here's a description (from [Apple](https://developer.apple.com/library/ios/releasenotes/DeveloperTools/RN-Xcode/Chapters/xc7_release_notes.html)) describing the issue (emphasis added):

> Testability: Tests of Swift 2.0 frameworks and apps are written without having to make internal routines public.
> Use @testable import {ModuleName} in your test source code to make all public and internal routines usable. The app or framework target needs to be compiled with the Enable Testability build setting set to Yes. **_The Enable Testability build setting should be used only in your Debug configuration, because it prohibits optimizations that depend on not exporting internal symbols from the app or framework.**_ (17732115)
 You bet, @cnoon  -- thanks for taking another look.
 @cnoon Thanks so much for not only considering this PR, but also taking the time and effort to to deal with the side effects. I'm happy to have helped in a small way, but the bigger thanks go to you and the rest of the Alamofire crew! We use it extensively in our Swift code at Best Buy and it works incredibly well.
  Added an optional TLSv1.2 NSTemporaryExceptionMinimumTLSVersion exception setting to the proposed NSAppTransportSecurityException

Considering that many user will copy-paste the settings proposed by Alamofire, it wouldn't hurt to make it more secure.
  I got the error below when installing the podfile to the project, as the app should support iOS7, I wrote "pod 'Alamofire', '<=1.3.1'" in the podfile.

[!] Unable to satisfy the following requirements:
- `Alamofire (<= 1.3.1)` required by `Podfile`

Specs satisfying the `Alamofire (<= 1.3.1)` dependency were found, but they required a higher minimum deployment target.

Any sugguestions?
 ths! :+1: 
    change escape method, cuz there are some custom chars need to check
  if the request's response statuscode is 401, response.result is .Failure(let error).But the error instance do not contain the response detail json data.
In the Validation.swift, I can not find the response json data either.
Need some help!
 I have the same problem. Any solutions?
  We would like to get your thoughts on getting the response data in a validator. We have a use case where we want to validate the JSON data in a response. This is what we did:

``` swift
extension Request {
  public func validateResponseData() -> Self {
    return validate(statusCode: [200]).validate(contentType: ["application/json"]).validate { _, response in

      let responseSerializer = Request.JSONResponseSerializer(options: .AllowFragments)
      let result = responseSerializer.serializeResponse(
        self.request,
        self.response,
        self.delegate.data,
        self.delegate.error
      )

      switch result {
      case .Success(let json):
        // validate field in JSON
      case .Failure(let responseError):
        return .Failure(responseError)
      }
    }
  }
}
```

To get this to work and use the built-in `JSONResponseSerializer` with the `data` and `error` properties from `self.delegate` we had to make these properties public:

``` swift
extension Request.TaskDelegate {
  public var data: NSData? { return nil }
  public var error: NSError? { return nil }
}
```

Is this something we could get merged in a pull request or is there a better way to create validators that validate the response data?
 any comments?
 Thank you for your reply @cnoon. I share your opinion about the separation of concerns. I think the root cause of the solution we came up with lies in the existing endpoint we have to use. The target server is using a `status` field in the JSON response instead of proper HTTP status codes. That's why we started using the validation mechanism, to validate the response.

I'll try to look into the response serialization.
 Thanks for sharing @jshier I'll take a look!
 @jshier what's CloudFare, I do not have one. Does this example compiles with the latest xcode 7.3 and swift 2.2?
  I have tried every possible way to get the cookies set at the response of a call. For example I am using:

```
let cfg = NSURLSessionConfiguration.defaultSessionConfiguration()
        let cookies = NSHTTPCookieStorage.sharedHTTPCookieStorage()
        cfg.HTTPCookieStorage = cookies
        cfg.HTTPCookieAcceptPolicy = NSHTTPCookieAcceptPolicy.Always

        let mgr = Alamofire.Manager(configuration: cfg)

        mgr.request(.POST, url, parameters: parameters).responseJSON { (resp) -> Void in
            //see http://stackoverflow.com/a/31018543/99214
            mgr.session.invalidateAndCancel()

            print(resp.response!.allHeaderFields.count)
            print(NSHTTPCookieStorage.sharedHTTPCookieStorage().cookies)

        }
```

Although I am getting all the other headers, I cannot read the cookies.
Any ideas?
 Thanks @cnoon , I'm afraid it's been left [there hanging](http://stackoverflow.com/questions/33979358/how-to-read-response-cookies-using-alamofire) ,that's why I had to turn here for help
 @cnoon Christian, and how can we send cookie in header? Is there any method?
 @cnoon I appreciate you posting that clip - however whilst I get the header fields back, there are no cookies. Yet - they do appear in postman (and I can see them in Android as well). 
Any further tips?
  I'm migrating code from Alamofire 2.0 and I cannot find an easy way to parse the JSON response when the status code is different from 2xx (we put an error message in the base key as rails convention).
On AF 2.0 the NSData with the response was available in the result .Failure, but now it seems that just the NSError is passed in this case.
What's the easiest way to get the body of the response?
 You can use the SwiftyJSON. Very easy and very useful.
https://github.com/SwiftyJSON/SwiftyJSON
 the problem is that response.result.value is now nil on Alamofire 3, so the problem is not parsing, is actually finding the body data somewhere.
 The only solution I can see is, that you shouldn't use `responseJSON` method. You can use the method listed below and parse `NSData` to JSON using `NSJSONSerialization` or SwiftyJSON.

```
public func response(
        queue queue: dispatch_queue_t? = nil,
        completionHandler: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Void)
        -> Self
```
 Ok, I wonder if this new behaviour was really thought throughly: the trade-off between performance and the ability of correctly consuming JSON APIs should (imho) be strongly in the favour of the second one.
   Thought that he just wanted to make a joke.
  Hi, please help me.
I use xcode 7.1, swift 2, Alamofire 3.1.3. When i use curl
curl -H "Accept: application/json" -H -X GET "https://instore.meduzaradio.com/api/station.json" --insecure
{"code":401,"error":"You must be authorized to view this page."}
it works just fine
In xcode i recive error

NSURLSession/NSURLConnection HTTP load failed (kCFStreamErrorDomainSSL, -9814)

my code:

class HTTPManager: Alamofire.Manager {
    static let sharedManager: HTTPManager = {
        let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
        configuration.HTTPAdditionalHeaders = Alamofire.Manager.defaultHTTPHeaders
        let serverTrustPolicies: [String: ServerTrustPolicy] = ["instore.meduzaradio.com": .DisableEvaluation]
        var policy: ServerTrustPolicy = ServerTrustPolicy.DisableEvaluation
        let manager = HTTPManager(
                               configuration: configuration, 
          serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies))
        return manager
    }()
}

class HTTPServise: NSObject {
    let baseUrl:String = "https://instore.meduzaradio.com/api/"
    var manager: Alamofire.Manager
    override init(){
        manager = HTTPManager.sharedManager
    }

```
func getRequestWithURL(url:String, parameters:[String: AnyObject]? = nil,completion:(finished: Bool, response: AnyObject?) ->Void ){
    abstractRequestWithMethod(.GET, url: url, parameters: parameters, completion: completion)
}
private func abstractRequestWithMethod(method:Alamofire.Method,url:String,parameters:[String: AnyObject]? = nil, completion:(finished: Bool, response: AnyObject?) ->Void ){

    manager.request(.GET,(baseUrl+url) as URLStringConvertible)
    .responseJSON { response in
        print(response.request)  // original URL request
        print(response.response) // URL response
        print(response.data)     // server data
        print(response.result)   // result of response serialization

        if let JSON = response.result.value {
            print("JSON: \(JSON)")
        }
    }   
}
```

}

![2015-11-27 00-39-22 info plist](https://cloud.githubusercontent.com/assets/5228281/11431147/c0a3e272-94a2-11e5-8c60-7714c8e835f6.png)

Thank you in advance
 I tried to use all variants in comments #876, but no result. Late, I use Afnetworking 2.6.3 
this is resolve 
AFSecurityPolicy\* policy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeNone];
    [policy setValidatesDomainName:NO];
    [policy setAllowInvalidCertificates:YES];

```
manager.securityPolicy=policy;
```

it works fine, but how it is to use with Alamofire
 @cnoon 

I had the same problem, but actually my app dynamically gets url under my `domain.com` (like `api.domain.com` and `goo.domain.com`). I can't allow myself to buy certificates for all of them.

I get those urls from my db. So I can't always release a new version of app when i get a new domain.

All I want is to set something like `*.intellicid.ru` into serverTrustPolicies and connect to all subdomains from Alamofire.

For now, I've made a workaround:

``` swift
//MyNetworkManager
let serverTrustPolicies: [String: ServerTrustPolicy] = [
      "(.+[.]domain[.]com)": .DisableEvaluation // not a master of regex :)
    ]
//ServerTrustPolicy.swift
public func serverTrustPolicyForHost(host: String) -> ServerTrustPolicy? {
  var value:ServerTrustPolicy? = nil
  policies.forEach {
    if $0 =~ host { // regex to check if my policy dictionary matches host
      value = $1
    }
  }

  return value
}
```

This works. But it would be a good feature for Alamofire, I think üëç 
  I'd like a global error handler ability, and possibly a shorter way of dealing with responses.  For example, every call looks like so:

``` swift
let request = Alamofire.request(......)
request.responseJSON {
    [weak self, request] _, _, result in
    guard let ss = self else { return }

    switch result {
    case .Success(let data):
        .......

    case .Failure(_, let error):
        debugPrint("\(request) failed: \((error as NSError).localizedDescription)")

    }
}
```

I always have to assign the request to a variable so that I can print it out inside of the error condition.  Could we pass that into the failure condition automatically?  The request you'd pass into responseJSON is the NSURLRequest, not the Alamofire request object that I can print out for the curl command.

What I'd really like to do though is setup some type of function to be automatically called any time the response*() methods return a failure.  In a majority of my calls a .Failure condition simply prints the error and then moves on.  I don't want to have to repeat that logging code everywhere.  I'd like to be able to do something like this, once:

``` swift
Alamofire.errorHandler {
    request, data, error in
    debugPrint("\(request) failed: \((error as NSError).localizedDescription)")
}
```
 I'm getting an undefined symbol on Response when I try to implement your example code.  
 Is there an updated example code? I searched for something like this in the documentation and couldn't find anything. It seems like an outdated example.  https://support.ssl.com/Knowledgebase/Article/View/19/0/der-vs-crt-vs-cer-vs-pem-certificates-and-how-to-convert-them

From docs: data A DER (Distinguished Encoding Rules) representation of an X.509 certificate.
https://developer.apple.com/library/mac/documentation/Security/Reference/certifkeytrustservices/#//apple_ref/c/func/SecCertificateCreateWithData

From what I gather here: certificatesInBundle in ServerTrustPolicy should also look for .crt and .der files instead of just .cer files. However, .crt and .cer files may be (correctly) encoded binary (DER) or base64-encoded. The Apple docs suggest only binary encoding is valid for SecCertificateCreateWithData. We could validate that each .crt and .cer is binary encoded, or alternatively, convert any ascii-encoded certs to a binary encoded cert before calling SecCertificateCreateWithData.
 "We could validate that each .crt and .cer is binary encoded" Realized this is already happening, although  it will fail silently
 @cnoon Sure, I'll put together a PR in the next few days
 https://github.com/Alamofire/Alamofire/pull/956
  Hi,
Is it possible to fix this compile warning when targeting iOS9.0+ ?

(Alamofire/Source/ParameterEncoding.swift:230:12)

Thanks
  I am trying to get progress of a request 

Alamofire.request(.POST, URL, parameters: parameter, encoding: .JSON)
 .responseJSON { response in
 // Do your stuff
}
I get my images/documents as a base64 string then I convert it as files in mobile

Can I show a progress with percentage?

I am using Alamofire, Swift 2

I also have asked this same in below SO
http://stackoverflow.com/questions/33827438/progress-of-a-alamofire-request/33831795#33831795
  Is it possible to support HTTP/2 push in AlamoFire? About event-stream (SSE)? If no and polling is the best option, does using the same connection to the host over multiple requests happen automatically in AlamoFire or does this need to be configured manually?
 related 
https://github.com/nathanborror/swift-http2
  I've seen prior threads mentioning this problem, and I've tried the solutions outlined in the responses, but I am still having issues trying to install the latest release of AlamoFire.  The contents of my Podfile are:

source 'https://github.com/CocoaPods/Specs.git'
platform :ios, '8.0'
use_frameworks!

pod 'Alamofire', '~> 3.0'

Issuing the pod install command results in:

Updating local specs repositories
Analyzing dependencies
[!] Unable to satisfy the following requirements:
- `Alamofire (~> 3.0)` required by `Podfile`

[!] CocoaPods was not able to update the `master` repo. If this is an unexpected issue and persists you can inspect it running `pod repo update --verbose`

Any help would be greatly appreciated.
 I just installed this about an hour ago. Explicitly adding the source (AKA The CocoaPods specs repo) worked for me. 

`source 'https://github.com/CocoaPods/Specs.git'`
 @srosmd Thanks, but that's the first line in my Podfile.
 @cnoon That did the trick!  Can't thank you enough!
  Here is the code that made compiling error.

``` swift
class Foo {
  func bar(response: Alamofire.Response) {
  }
}
```
  I have a single exception breakpoint set on an example project. When I do a simple GET request with AF, the app crashes.

See https://github.com/dlo/Alamofire-Crash-Example for example code.
 Ah, got it. Thanks! That's pretty weird. So I guess Swift-only exception breakpoints in Swift-only projects?
  I tried a request with NSURL so I know it works. Maybe I am doing something wrong?

I am trying to send a request with a + in the parameters and Alamofire is not encoding it properly. It gets replaced with a space % . 

I see in ParameterEncoding that there is the following line:
let subDelimitersToEncode = "!$&'()*+,;="

There is similar issue that was fixed previously 
https://github.com/Alamofire/Alamofire/issues/181 

Here is my request : 

Alamofire.request(.GET, bankMeRequestUrl,parameters: parameters, encoding:ParameterEncoding.URLEncodedInURL).responseJSON
 My bad. I was sending the encrypted string to an api as encoded. %2B is what I got confused about because my string was encrypted and always looks a mess. I was receiving the string back from the push server as encoded and forgot to decode the string again. I just added stringByRemovingPercentEncoding. Thanks for the help with %2B though.   
  I'm working on transferring my project from `AFNetworking` to `Alamofire`. Really like the project. However, I'm receiving this error when attempting to make a `GET` request that worked fine with `AFNetworking`.

Here's some example code:

```
class func listCloudCredntials(includePending includePending: Bool = true, completionBlock:((data: [[String: AnyObject]]?, error: NSError?) -> Void)?) {

    let parameters: [String: AnyObject] = includePending ? ["include_pending": "true"] : [:]

    let urlString = https://myapp-staging.herokuapp.com/api/1/credntials

    let token = SSKeychain.passwordForService(keyJWT, account: user.objectId)

    let headers: [String: String] = ["Authorization": "Bearer \(token)"]

    let request = Alamofire.request(.GET, urlString, parameters: parameters, encoding: .JSON, headers: headers)

    request.responseJSON() {
        (response: Response<AnyObject, NSError>) in

        switch response.result {
        case .Success(let result):
            completionBlock?(data: (result as? [String: AnyObject])?["data"] as? [[String: AnyObject]], error: nil)

        case .Failure(let error):
            completionBlock?(data: nil, error: error)
        }
    }
}
```

`Error Domain=NSURLErrorDomain Code=-1005 "The network connection was lost." UserInfo={NSUnderlyingError=0x14e9c77f0 {Error Domain=kCFErrorDomainCFNetwork Code=-1005 "(null)" UserInfo={_kCFStreamErrorCodeKey=-4, _kCFStreamErrorDomainKey=4}}, NSErrorFailingURLStringKey=https://myapp-staging.herokuapp.com/api/1/credntials, NSErrorFailingURLKey=https://myapp-staging.herokuapp.com/api/1/credntials, _kCFStreamErrorDomainKey=4, _kCFStreamErrorCodeKey=-4, NSLocalizedDescription=The network connection was lost.}`

I've tried running on the iOS Simulator with 1OS 8.4 and iOS 9.1, as well as my iPhone 6S running iOS 9.1.

What am I doing wrong?
 @cnoon - Hey man, sorry for the delay in reply. I have been swamped with other tasks.

Here's the `debugprint(request)` result (it's a `GET` request):

```
$ curl -i \
-H "Authorization: Bearer some-JWT-Security-Token" \
-H "Content-Type: application/json" \
-H "Accept-Language: en-US;q=1.0" \
-H "Accept-Encoding: gzip;q=1.0,compress;q=0.5" \
-H "User-Agent: Company/com.Company.AppName (1081; OS Version 9.2 (Build 13C75))" \
-d "{\"include_pending\":\"true\"}" \
"https://appname-staging.herokuapp.com/api/1/credntials"
```

I have to change `curl -i` to `curl -X GET` in order for the curl to return successfully.

This other call works with no issues.

```
curl -i \
-X POST \
-H "Content-Type: application/json" \
-H "Accept-Language: en-US;q=1.0" \
-H "Accept-Encoding: gzip;q=1.0,compress;q=0.5" \
-H "User-Agent: Company/com.Company.AppName (1081; OS Version 9.2 (Build 13C75))" \
-d "{\"token\":\"UserSessionTokenString\"}" \
"https://appname-staging.herokuapp.com/api/1/authenticate/user"
```

Could it be something with the `GET` vs. `POST`?
 But why would `GET` requests fail, but `POST` requests succeed. Are there any settings I should take a look at?
 I hear ya, thanks! Cheers as well.
 For the record, same issue and it's worked removing .JSON encoding.
 Still getting NSLocalizedDescription=The network connection was lost. Xcode 8
 For reference, it looks like this is an iOS 8 issue, not an AlamoFire issue: http://stackoverflow.com/questions/25372318/error-domain-nsurlerrordomain-code-1005-the-network-connection-was-lost  Support of oauth2 client credentials workflow would be good...

http://oauthlib.readthedocs.org/en/latest/oauth2/grants/password.html
  Hi I have try all different ways for this I still don't have any luck, I'm using latest version 3.1.2 here is my code 
this is my URL request convertible following the documentation

```
enum Router: URLRequestConvertible {
case GetDevices([String: AnyObject])
case GetDevice(String)
var method: Alamofire.Method {
    switch self {
    case .GetDevices:
        return .GET
    case .GetDevice:
        return .GET
    }

}

var path: String {
    switch self {
        case .GetDevice(let uuid):
            return "/api/devices/\(uuid)"
    case .GetDevices:
        return "/api/devices"
    }
}


var URLRequest: NSMutableURLRequest {
    let URL = NSURL(string: hostUrl)!
    let mutableURLRequest = NSMutableURLRequest(URL: URL.URLByAppendingPathComponent(path))
    mutableURLRequest.HTTPMethod = method.rawValue
    let toke = "Bearer " + tokenSDK
    mutableURLRequest.setValue(toke, forHTTPHeaderField: "Authorization")
    switch self {
    case .GetDevices(let parameters):
        return Alamofire.ParameterEncoding.JSON.encode(mutableURLRequest, parameters: parameters).0
    default:
        return mutableURLRequest
    }
}
}
```

Then I have my request 

```
 Session.sharedInstance.ApiManager().request(Router.GetDevices(params)) 
        .responseCollection { (response: Response<[Device], NSError>) in
            debugPrint(response)
            switch response.result{
            case .Success(let data):
                debugPrint(response.result)
                fulfill(data)
            case .Failure(let error):
                debugPrint(response.result)
                return reject(error)
            }
    }
```

Here is my Manager 

```
class Session {
static let sharedInstance = Session()
private var manager : Manager?

func ApiManager()->Manager{
    if let m = self.manager{
        return m
    }else{

        let serverTrustPolicies: [String: ServerTrustPolicy] = [
                    "api-develop.com": .DisableEvaluation
                ]
        let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
        let tempmanager = Alamofire.Manager(configuration: configuration,serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies))
        self.manager = tempmanager
        return self.manager!
    }
}
}
```

But I still get error on my response that the token is missing, here is my response
    [Request]: <NSMutableURLRequest: 0x16eded00> { URL: https://api-develop.com/api/devices/b4886e9a-2257-4327-8f2a-82164ee139a0 }
[Response]: <NSHTTPURLResponse: 0x16ed4330> { URL: https://api-develop.com/api/devices/b4886e9a-2257-4327-8f2a-82164ee139a0 } { status code: 401, headers {
    Connection = "keep-alive";
    "Content-Length" = 92;
    "Content-Type" = "application/json";
    Date = "Wed, 18 Nov 2015 21:19:00 GMT";
} }
[Data]: 92 bytes
[Result]: FAILURE: Error Domain=com.alamofire.error Code=-6006 "The operation couldn‚Äôt be completed. The authorization token is missing or invalid." UserInfo=0x16d71b40 {NSLocalizedFailureReason=The authorization token is missing or invalid.}
  **Short :** Is there any way to modify the backed `NSURLRequest` (headers, body, or other) of the `Request` object after it has been created ?

**Long :** I have a custom `Manager` with `startRequestsImmediately` set to `false`. If my access token is currently being refreshed, all requests are waiting for refresh to finish, then they are resume.
Of course, I need to modify theirs HTTP headers to update access token before resuming them.

I can't just track directly `NSURLRequest`s then recreating `Request`s object because I need to keep all completion closure previously set for those requests.

Please tell me there's a way, otherwise I'll cry more and more :'(
 Hi @cnoon, thanks for your quick reply. I actually came across your post on SO yesterday but your solution will be quite hard to implement on my project. We are now not so far from shipping and I'm afraid I can't offer that much refactoring on the core of the app right now (thank to the client for his "last minute requirement" ...). I don't know what solutions are left to me but well, I'll see by tomorrow if I can find out something :(

Anyway, is there a chance we can see request modification feature on future versions of Alamofire ?
I guess the main problem is that `NSURLSessionTask` has on read-only property on `originalRequest` and `currentRequest` and they are `NSURLRequest` so not mutable but well, maybe you guys could find a way :)
  I am sending a request using the following code: 
 let requestURL = "/user?where={\"phoneNumber\":\"0000000001\"}"
Alamofire.request(.GET, host+requestURL)......

I getting this error in the alamofire at this line:
let mutableURLRequest = NSMutableURLRequest(URL: NSURL(string: URLString.URLString)!)
(Alamofire.swift : 92)

Any ideasÔºü
 Thanks for quick response. Host is validate URL because I am using it to pass to Alamofire request in the other parts of application. I suspect that several \" (backslash + double quote) are causing the problem.
 But I cannot fix the problem because I need quotes in my URL and I need backslashes for that.
  Hello,

I'm trying to make a multi-platform framework with Alamofire from cocoapods, but when I compile I get several alerts and the library is not imported.
- Target 'Alamofire' of project 'Pods' was rejected as an implicit dependency for 'Alamofire.framework' because it doesn't contain platform 'macosx' in its SUPPORTED_PLATFORMS 'iphonesimulator, iphoneos'
- Target 'Alamofire' of project 'Pods' was rejected as an implicit dependency for 'Alamofire.framework' because it doesn't contain platform 'watchsimulator' in its SUPPORTED_PLATFORMS 'iphonesimulator, iphoneos'
- Target 'Alamofire' of project 'Pods' was rejected as an implicit dependency for 'Alamofire.framework' because it doesn't contain platform 'appletvsimulator' in its SUPPORTED_PLATFORMS 'iphonesimulator, iphoneos'
 Thanks a lot for the info
  Hi all,

I'm suddenly getting a lot of crashes from an application but I can't make sense of the crash report.

I have attached the a screenshot from Crashlytics:

![image](https://cloud.githubusercontent.com/assets/2972170/11202136/cba55324-8c99-11e5-855b-4a1e4d8bcada.png)

Any Ideas?
 Thanks for your quick reply Jon.

The Alamofire version is 2.0.2 (the Application has been running for a while and even tho I'm ready to update it to v3, I am reluctant to do so before I don't know the reason of this crash which I can't reproduce btw).

The app was compiled with Xcode version 7.1.1.

The weird part about the crash is that it started happening without any prior version changes. I did suspect that it might come from a problem in our API but the code in the stack trace has nothing to do with the actual content of the response so I'm not too sure about that. Another possible issue might be that the app has gained some traction in Saudi Arabia when the crashes started happening. Might there be a problem with refused connections, censorship or something like that causing the crash?

Here is the full stack trace showing how Alamofire is called:

```
Thread : Crashed: com.apple.root.user-initiated-qos
0  Alamofire                      0x1002a3f64 URLRequest(Method, URLStringConvertible, headers : [String : String]?) -> NSMutableURLRequest (Alamofire.swift:101)
1  Alamofire                      0x1002a9be8 Manager.request(Method, URLStringConvertible, parameters : [String : AnyObject]?, encoding : ParameterEncoding, headers : [String : String]?) -> Request (Manager.swift:165)
2  Alamofire                      0x1002a4080 request(Method, URLStringConvertible, parameters : [String : AnyObject]?, encoding : ParameterEncoding, headers : [String : String]?) -> Request (Alamofire.swift:132)
3  [AppName]                     0x10018028c static ApiWrapper.(fetch(ApiWrapper.Type) -> (String, parameters : [String : AnyObject]?, cache : Bool?, expires : Int?, callback : (response : JSON?) -> ()!) -> ()).(closure #1) (ApiWrapper.swift:75)
4  [AppName]                     0x10017f984 partial apply for static ApiWrapper.(fetch(ApiWrapper.Type) -> (String, parameters : [String : AnyObject]?, cache : Bool?, expires : Int?, callback : (response : JSON?) -> ()!) -> ()).(closure #1) (ApiWrapper.swift)
5  libdispatch.dylib              0x1982416e8 _dispatch_call_block_and_release + 24
6  libdispatch.dylib              0x1982416a8 _dispatch_client_callout + 16
7  libdispatch.dylib              0x19824fb40 _dispatch_root_queue_drain + 2140
8  libdispatch.dylib              0x19824f2dc _dispatch_worker_thread3 + 112
9  libsystem_pthread.dylib        0x198455470 _pthread_wqthread + 1092
10 libsystem_pthread.dylib        0x198455020 start_wqthread + 4
```

Here is how it is called in code:

```
Alamofire.request(.GET, http + domain + path, parameters: parameters).responseJSON {
            (request, _, result) in
            // check for result
            if let responseBody = result.value {
                callback(data: responseBody)
            }
}
```
 The `http + domain + path` part is completely handled by the app itself and gets passed to the wrapper function from where it's called so it is not possible that any part of it is missing. I also tested all network requests from within the app and could not replicate the issue. 

There is the possibility of Arabic characters in the URL however, thanks for pointing me towards that. I will explore that possibility and upgrade to 3.x
  Hi Guys,

I know I have to ask the question on SO, But I'm guessing I had missed out some  changes of ver 1.3 to 3. I'm currently translating swift 1.2 code into swift 2.0 where I'm using manual multiformdata with URLRequestConvertible.

![screen shot 2015-11-16 at 14 03 19](https://cloud.githubusercontent.com/assets/1192544/11175318/dc828802-8c6b-11e5-8e6a-6f29988d183b.png)

What I'm doing now is refactoring the above code into below as recommended so i do not need to do the encoding myself.

![screen shot 2015-11-16 at 14 07 56](https://cloud.githubusercontent.com/assets/1192544/11175312/c1285078-8c6b-11e5-9004-889f2f5c8cc7.png)

I had encountered error of "too many HTTP redirects" where I couldn't find a solution on SO. I will greatly appreciate any comments and pointers on this matters.

EDITS:
As suggested by @cnoon by formatting my code nicely with the solution:)
Orginal SO question: 
http://stackoverflow.com/questions/33684973/nsdebugdescription-invalid-value-around-character-0-alamofire

http://stackoverflow.com/questions/33727493/too-many-http-redirects-while-using-alamofire-upload-multipart-form-data

Cheers

Des
 @cnoon it turn out that in iOS 9 had this App Transport Security (ATS) to enforce best practices in secure connections between an app and its back end. Hence the redirect issues.

by adding Alamofire.Manager.sharedInstance.delegate.taskWillPerformHTTPRedirection = nil

everything work like magic XD

Cheers

Des
 @cnoon not too sure why, but after i added in "NSAllowsArbitraryLoads" for key "NSAppTransportSecurity" to my Plist the app works fine together with Alamofire.Manager.sharedInstance.delegate.taskWillPerformHTTPRedirection = nil 
  Would something [like this gist](https://gist.github.com/grosch/683b6cc6649719e6c3ce#file-alamofire-swift) work for the activity indicator stuff?  I think I'm close, but not entirely sure about the activeTask stuff that I did vs. the various ways you might generate/call a request.  

By using the protocol and @available on the extension, we can easily do the "right thing" for each type of platform you support.  I only know/care about iOS so that's all I wrote currently.

I'm thinking you could have some property/method that would register this NSURLProtocol if the client requested this.

Thoughts?
  Hi everyone, 
I have a problem when trying to update an array of struct with the JSON's data. Here's my code:

This is how the struct is defined:
<img width="574" alt="schermata 2015-11-14 alle 17 26 27" src="https://cloud.githubusercontent.com/assets/1908782/11164590/25c61ae2-8af5-11e5-8a7d-0ce904c0b250.png">
... ...

Here I try to update the array, but it doesn't work:
<img width="696" alt="schermata 2015-11-14 alle 17 25 50" src="https://cloud.githubusercontent.com/assets/1908782/11164588/2598c15a-8af5-11e5-95c1-f95656cd3d8f.png">

The problem is that after the function is performed, the array stays void. What's wrong?
Thank you. 
  I keep trying to set headers with my authorization token, however alamofire is not using the headers I provided.

Using
IOS 9
pod 'Alamofire', '~> 3.0'

```
        let headers = [
            "Authorization": "Token token=\"\(token)\"",
            "Content-Type": "application/x-www-form-urlencoded"
        ]

        Alamofire.request(
            .GET,
            API_URL + "grades/651",
            parameters: nil,
            headers: headers,
            encoding: .JSON
            ).responseString { response in
                print(response.request)
                print(response.response)
                print(response.result.value)

        }
```

```
Optional(<NSMutableURLRequest: 0x13f5ea540> { URL: --------------- })
Optional(<NSHTTPURLResponse: 0x13f5185f0> { URL: --------------- } { status code: 401, headers {
    "Cache-Control" = "no-cache";
    "Content-Type" = "text/html; charset=utf-8";
    Date = "Sat, 14 Nov 2015 06:30:14 GMT";
    Server = "cloudflare-nginx";
    Via = "1.1 vegur";
    "Www-Authenticate" = "Token realm=\"Application\"";
    "cf-ray" = "2450aaa2d90f39ca-PHX";
    "x-content-type-options" = nosniff;
    "x-frame-options" = SAMEORIGIN;
    "x-request-id" = "f1838396-f369-4ed2-b7a5-64c8add4493c";
    "x-runtime" = "0.006288";
    "x-xss-protection" = "1; mode=block";
} })
Optional("HTTP Token: Access denied.\n")
```
 I can't even login... Everything works and I don't change anything and now Alamofire gives me always error 401. I know for sure that my credentials are correct and address for login with get method too.
 @cnoon I have the same problem with the latest version
 Authorization header does not work. It's true there is a problem
  Updated to Alamofire 2.0 and seeing a lot of crashes in production that I can't reproduce.
Anyone has seen this or any suggestions?

Could this even be related to Alamofire?
Has this maybe fixed in 3.0?

`````` CFNetwork
HTTPConnectionCacheEntry::notifyNextProtocolOfOpenConnection(NetConnection*, unsigned char)
read : Crashed: com.apple.NSURLConnectionLoader
0  libobjc.A.dylib                6832194000 objc_msgSend + 16
1  CFNetwork                      6620658736 HTTPConnectionCacheEntry::notifyNextProtocolOfOpenConnection(NetConnection*, unsigned char) + 200
2  CFNetwork                      6620721780 NetConnection::responseIsComplete(void*) + 256
3  CFNetwork                      6620721432 HTTPNetStreamInfo::sendStreamIsComplete() + 72
4  CFNetwork                      6620716528 HTTPNetStreamInfo::_streamImpl_Read(unsigned char*, long, CFStreamError*, unsigned char*) + 392
5  CFNetwork                      6620557272 CoreStreamBase::_streamInterface_Read(unsigned char*, long) + 184
6  CFNetwork                      6620715376 HTTPProtocol::bytesAvailable(unsigned char) + 224
7  CFNetwork                      6620708416 HTTPProtocol::httpReadStreamEvent(unsigned long) + 596
8  CFNetwork                      6620550308 CoreReadStreamClient::coreStreamEventsAvailable(unsigned long) + 64
9  CFNetwork                      6621462164 CoreStreamBase::_callClientNow(CoreStreamClient*) + 64
10 CFNetwork                      6621462228 ___ZN14CoreStreamBase34_streamSetEventAndScheduleDeliveryEmh_block_invoke + 40
11 CoreFoundation                 6624466400 CFArrayApplyFunction + 68
12 CFNetwork                      6620629532 RunloopBlockContext::perform() + 136
13 CFNetwork                      6620629144 MultiplexerSource::perform() + 288
14 CFNetwork                      6620628692 MultiplexerSource::_perform(void*) + 60
15 CoreFoundation                 6625261124 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 24
16 CoreFoundation                 6625257888 __CFRunLoopDoSources0 + 256
17 CoreFoundation                 6625250360 __CFRunLoopRun + 632
18 CoreFoundation                 6624468000 CFRunLoopRunSpecific + 452
19 Foundation                     6637003816 +[NSURLConnection(Loader) _resourceLoadLoop:] + 348
20 Foundation                     6637585420 __NSThread__main__ + 1000
21 libsystem_pthread.dylib        6839926300 _pthread_body + 168
22 libsystem_pthread.dylib        6839926132 _pthread_body + 138
23 libsystem_pthread.dylib        6839915860 thread_start + 4```
``````
 This may be helpful
![screen shot 2015-11-12 at 10 07 55 am](https://cloud.githubusercontent.com/assets/3460069/11126830/bb7c235a-8925-11e5-87d1-be5b23ec9cd3.png)
  This is the warning infomation:

ld: warning: linking against dylib not safe for use in application extensions: /Users/EricChen/Library/Developer/Xcode/DerivedData/ERCEngine-gjizomxiwiastihknrteecwkobuh/Build/Products/Debug-iphonesimulator/Alamofire.framework/Alamofire
  I got an AppStore (TestFlight) rejection though my app contained the following.  It turns out embedded frameworks need it too.  This might be a new requirement.

```
<key>UIRequiredDeviceCapabilities</key>
<array>
    <string>arm64</string>
</array>
```

More at: https://forums.developer.apple.com/message/85053
 +1
  In Xcode 7.1 on iOS 8.3 with Alamofire 3.1 Xcode shows memory leaks for Alamofire calls. Below attached code that generates the leak and screenshot. 

```
    Alamofire.request(.GET, "https://httpbin.org/get", parameters: ["foo": "bar"])
        .responseJSON { response in
            switch response.result {
            case .Success(let json):
                print(json)
            case .Failure(let error):
                print(error)
            }
    }
```

[![enter image description here](http://i.stack.imgur.com/VDXXl.png)](http://i.stack.imgur.com/VDXXl.png)
 @cnoon my test project looked identical to yours, so yes it's the same leak. 
  I perform a REST call whenever the application the application becomes inactive. I make the call within the `AppDelegate's` `applicationWillResignActive` method. The call works perfectly if the user clicks the home button on the device, but if a user locks the screen while the application is still in the foreground, the call appears to send, but never completes and I don't receive the call on the server side. 

I even attempted what was mentioned in the `Creating a Manager with Background Configuration` section, but the result has been the same. When using the background configuration, I do receive the error `Error Domain=NSURLErrorDomain Code=-997 "Lost connection to background transfer service"`. This is the code I currently have:

```
    var deviceId:String
    // Check if deviceId has been stored
    if let device: String = NSUserDefaults.standardUserDefaults().stringForKey(Globals.KEY_DEVICE_ID) {
        // deviceId is stored, use it
        deviceId = device
    } else {
        // deviceId not stored, create a new one and store it
        deviceId = NSUUID().UUIDString
        NSUserDefaults.standardUserDefaults().setObject(deviceId, forKey: Globals.KEY_DEVICE_ID)
    }

    let params = ["statusId": "2"]
    let url = "client/device/" + deviceId

    // Create the URL Request
    let URLRequest = NSMutableURLRequest(URL: NSURL(string: Globals.BASE_URL + url)!)
    // set header fields
    if let key = NSUserDefaults.standardUserDefaults().stringForKey(Globals.NS_KEY_SESSION) {
        URLRequest.setValue(key, forHTTPHeaderField: "X-XX-API")
    }
    // Add user agent
    if let userAgent = NSUserDefaults.standardUserDefaults().stringForKey(Globals.NS_KEY_USER_AGENT) {
        URLRequest.setValue(userAgent, forHTTPHeaderField: "User-Agent")
    }

    // Set the HTTP method
    URLRequest.HTTPMethod = Alamofire.Method.PUT.rawValue

    let configuration = NSURLSessionConfiguration.backgroundSessionConfigurationWithIdentifier("com.myapp.background")
    manager = Alamofire.Manager(configuration: configuration)

    let encodeMethod: Alamofire.ParameterEncoding = Alamofire.ParameterEncoding.URL
    manager.startRequestsImmediately = true
    manager.request(encodeMethod.encode(URLRequest, parameters: params).0).validate().responseJSON() {
        (response) in

        print("response from call: \(response)")
        self.manager = nil
    }
```

I am using XCode 7.1 with deployment target 9.1 and Alamofire version 3.1.2. 
 Hello @cnoon I have a Stack Overflow post here: http://stackoverflow.com/questions/33614546/rest-call-doesnt-complete-when-locking-screen. Thank you.
  arm64 must be set in UIRequiredDeviceCapabilities for tvOS targets when uploading to iTunes Connect.
  Sample code does not work, because of ATS in iOS9. I made a change in README as follows; replace http with https.
  Half way through converting from Alamofire v2 to Alamofire v3 I had the following function in this temporary state.  Forgetting I wasn't done, I compiled it and Swift failed.  The "print(response.json)" should have been "print(response.result.value)" of course.  This is probably not an Alamofire issue, unless Alamofire can help Swift detect this error at compile time, or at least not segfault, so it gets caught at run time.

```
func boxscore() {
    network.request(.GET, spacetrackServer + basicQueryClass + "/boxscore").responseJSON() {
        (response) in print(response.json)
    }
}
```

rdar://23413330

For completeness sake, Swift reported the following as it traced back its death:

```
1.  While type-checking 'boxscore' at /Users/gavin/Development/Orbits/Retriever_Swift/TLEReceiver/SpaceTrack.swift:80:5
2.  While type-checking expression at [/Users/gavin/Development/Orbits/Retriever_Swift/TLEReceiver/SpaceTrack.swift:81:9 - line:83:9] RangeText="network.request(.GET, spacetrackServer + basicQueryClass + "/boxscore").responseJSON() {
        (response) in print(response.json)
    }"
3.  While type-checking expression at [/Users/gavin/Development/Orbits/Retriever_Swift/TLEReceiver/SpaceTrack.swift:81:93 - line:83:9] RangeText="() {
        (response) in print(response.json)
    }"
4.  While type-checking expression at [/Users/gavin/Development/Orbits/Retriever_Swift/TLEReceiver/SpaceTrack.swift:81:96 - line:83:9] RangeText="{
        (response) in print(response.json)
    }"
5.  While type-checking expression at [/Users/gavin/Development/Orbits/Retriever_Swift/TLEReceiver/SpaceTrack.swift:82:27 - line:82:46] RangeText="print(response.json)"
6.  While type-checking expression at [/Users/gavin/Development/Orbits/Retriever_Swift/TLEReceiver/SpaceTrack.swift:82:27 - line:82:27] RangeText="p"
```
  I'm trying to send a Swift Bool in a POST request, however the server expects a number for this, but the request HTTP body shows that the bool was sent as 'true'.

I'm creating the parameters like this:

```
let params: [String: AnyObject] = [
            "quantity": quantity, // Int
            "amount": totalAmount, // Double
            "use_credit": useCredit // Bool
        ]
```

The post request looks like this:

```
func postRequest(url: String, params: [String : AnyObject]?, headers: [String : String]?, completion: APICompletionHandler) {
        self.manager.request(.POST, baseURL.stringByAppendingString(url), parameters: params, encoding: .JSON, headers: headers).responseJSON(completionHandler: { response -> Void in
            switch response.result {
            case .Success(let data):
                completion(json: JSON(data), error: nil)
            case .Failure(let error):
                completion(json: nil, error: error)
            }
        })
    }
```

When printing out the HTTP body of `response` in the console I get the following:

```
{\"use_credit\":true,\"amount\":15,\"quantity\":1,\"event_id\":30}
```
  Here is the code 

```
Alamofire.request(
            .POST,
            "http://google.com",
            parameters: [
                "url" : "http://google.com"
            ],
            encoding: .URL).responseString(completionHandler: { (response: Response<String, NSError>) -> Void in
                let data = response.request!.HTTPBody!
                let payload = NSString(data: data, encoding: NSUTF8StringEncoding)
                print("pay \(payload)")
            })
```

It print `Optional(url=http%3A//google.com)` shouldn't it be `Optional(url=http%3A%2F%2Fgoogle.com)` ?

Alamofire (3.1.1)
  Hello, here's my code : 

```
                let destination = Alamofire.Request.suggestedDownloadDestination(
                    directory: .CachesDirectory,
                    domain: .UserDomainMask
                )
        Alamofire.download(.GET, "http://www.adobe.com/devnet/acrobat/pdfs/pdf_open_parameters.pdf", destination: destination)
            .progress { bytesRead, totalBytesRead, totalBytesExpectedToRead in
                print(totalBytesRead)
            }
            .response { request, response, _, error in
                print(response)

        }
```

I need to know how to convert the `destination path (destination)` to filePath or how to get the download file in the response call back ?
 @cnoon 
I 've tried this : 

```
    func filePath() -> NSURL{
        let documentDirectoryUrl = NSFileManager.defaultManager().URLsForDirectory(.DocumentDirectory, inDomains: .UserDomainMask)[0];
        let folderPath = documentDirectoryUrl.URLByAppendingPathComponent("Nawader/");
        let fileName = fileUrl!.lastPathComponent;
        let filePath = folderPath.URLByAppendingPathComponent(fileName!);
        return filePath;
    }

    func downloadFile(){
        let destination: (NSURL, NSHTTPURLResponse) -> (NSURL) = {
            (temporaryUrl, response)  in
            if response.statusCode == 200 {
                return self.filePath();
            }
            else {
                return temporaryUrl
            }
        }


        Alamofire.download(.GET, (fileUrl?.path)!, destination:destination)
            .progress { bytesRead, totalBytesRead, totalBytesExpectedToRead in
                print("\(totalBytesRead) / \(totalBytesExpectedToRead) \n")
            }
            .response { request, response, _, error in
                print(response)
        }
    }

```

But I get this error at `Alamofire.download` line : 

> fatal error: unexpectedly found nil while unwrapping an Optional value

Do you have any idea what's wrong ?
 I' resolved this problem it was caused by `(fileUrl?.path)!` not by destination function as I thought first time
 @cnoon after downloading finished when I check if file exist at the given path I can't find it.
Header when finishing download : 

```
Optional(<NSHTTPURLResponse: 0x7fca1b230910> { URL: https://dl.dropboxusercontent.com/u/70441529/NWADER%20-%2023.pdf } { status code: 200, headers {
    "Accept-Ranges" = bytes;
    "Cache-Control" = "max-age=0";
    "Content-Disposition" = "inline; filename=\"NWADER - 23.pdf\"; filename*=UTF-8''NWADER%20-%2023.pdf";
    "Content-Length" = 75449827;
    "Content-Type" = "application/pdf";
    Date = "Sat, 07 Nov 2015 12:27:46 GMT";
    Etag = 2894n;
    Pragma = public;
    Server = nginx;
    "Set-Cookie" = "uc_session=frshBchxeZ34Ln9tiirQoBO4kq9zIkqvaHq9jaaO9EL0e4jJmkDtltTKx6oPj3XL; Domain=dropboxusercontent.com; httponly; Path=/; secure";
    "content-security-policy" = "; referrer no-referrer;";
    "x-content-security-policy" = "; referrer no-referrer;";
    "x-dropbox-request-id" = c24b832d5e45aab36abaaf5e809670b8;
    "x-robots-tag" = "noindex, nofollow, noimageindex";
    "x-server-response-time" = 516;
    "x-webkit-csp" = "; referrer no-referrer;";
} })
```

do you have an idea why I can't find the downloaded file ?
 @cnoon Thanks!
 `you'll need to pass the response to the destination closure in your response closure to figure out where the file was moved.`

Say again??? pass response to destination? How?

If I start typing `destination(` the code completion gives me nothing useful. So it doesn't seem like I can pass something to `destination`
 Nevermind, I finally wrapped my head around these closures.

``` Swift
var localPath: NSURL?
Alamofire.download(.GET,
    "http://jplayer.org/video/m4v/Big_Buck_Bunny_Trailer.m4v",
    destination: { (temporaryURL, response) in
        let directoryURL = NSFileManager.defaultManager().URLsForDirectory(.DocumentDirectory, inDomains: .UserDomainMask)[0]
        let pathComponent = response.suggestedFilename

        localPath = directoryURL.URLByAppendingPathComponent(pathComponent!)
        return localPath!

})
    .response { (request, response, _, error) in
        print(response)
        print("Downloaded file to \(localPath!)")
}
```

However, I can't understand why you are working with closures to set a download url. Seems like overkill.
 The issue for me was that the file is downloaded but then moved to temp location,  not the one I passed, and that due to the path is not valid a folder missing so I had to create that folder before
   This is my block of code and I am constantly getting the errorDomain=NSCocoaErrorDomain Code=3840 "Invalid value around character 0. 

let parameter = ["mobileNumber":number]
        let header = ["accessToken" : newToken,"Content-Type":"Application/JSON"]
        let url1 = NSURL(string: baseUrl + registerMobileUrl)
        Alamofire
                .request(.POST, url1!, parameters: parameter, encoding: ParameterEncoding.JSON, headers : header)
            .responseString { response  in
                print("All header fields are (response.response?.allHeaderFields)")
                print("the response main of register mobile is (response)")
  Using Xcode 7.1, installing Alamofire using either Carthage or CocoaPods results in a build failure.

May be related to https://github.com/CocoaPods/CocoaPods/issues/4420
 Well, I tried cleaning and then rebuilding the project. Everything works now.
  You need to declare your expectation variables as "weak" variables so that the function does not keep a reference which was causing your tests to hang.

You can see this StackOverflow question for more details: http://stackoverflow.com/questions/27555499/xctestexpectation-how-to-avoid-calling-the-fulfill-method-after-the-wait-contex
 No problem @cnoon! Don't hesitate to reach out again if you need help.
  Hi there. I've made a small change to the project settings to not code sign the iOS framework target when built against the simulator SDK. The reason for this is because when built with carthage on a CI server with no code signing identities, it defaults to building with the simulator SDK which doesn't require code signing like the iphoneos SDK does. Other frameworks supporting Carthage installs have been doing this as well it seems (example: https://github.com/ReactiveCocoa/ReactiveCocoa/commit/f685971d32d9035df40eb0a7dd49f2224e8cab1b)
  my json looks like this 
<string>[{,"FromEmirateNameEn":"Dubai",:null,"FromEmirateNameCh":null,"FromEmirateNameUr":null,"FromRegionNameEn":"Burj"}]   </string>
i tried 
//        Alamofire.request(.GET, "my url")
//            .responseString { response in
//                print("Success: (response.result.isSuccess)")
//                print("Response String: (response.result.value)")
//                print("*********_\n**_**************")
//                if let JSoON = response.result.value {
//                 print(JSoON)
//                    let jsob = JSON(JSoON)
//                    let isa = jsob["FromEmirateNameEn"].string
//                    let isa = jsob["FromEmirateNameEn"].stringValue
//                    print(isa)
and the value turns from the weird numbers to the main json above but i can't use any thing in it at all every time i try like let isa = jsob["FromEmirateNameEn"].string
it give me null what can i do ?
 sorry for this @cnoon  i'm still new to this and   so disparate to know -.- 
  Hi, I'm updating a project from Swift 1.2 to 2.0 and I'm having some trouble with Alamofire.download. Originally I was calling `self.request = Alamofire.download(.GET, self.arquivo!.url, { _ in arquivoPath }).response({ (_, _, _, _) -> Void in`
And I get "Type of expression is ambiguous without more context" on Swift 2.

If I change it to `self.request = Alamofire.download(Method.GET, self.arquivo!.url, { _ in arquivoPath })` I get "Cannot invoke 'download' with argument list of type '(Method, String, (_) -> NSURL)'"

And I can't get it to work with any combination of types.
  Hi everyone! (this is a question)
I want to do a SOAP request for example with this web service:
http://www.holidaywebservice.com//HolidayService_v2/HolidayService2.asmx?wsdl

I need to send one parameter "countryCode". I don't know how can i do that with alamofire. And how i get the response to parse the xml result.

Thanks for your help.
 Thanks for your response! 
  This failures with code -1017 because of encoding set to JSON. I know that GET requests should not have body but I'm still interested if there is some way to solve this.

```
Alamofire.request(.GET, "http://httpbin.org/get", parameters: ["dax":"dax"], encoding: ParameterEncoding.JSON, headers: nil).responseData { (response) -> Void in
            print("done")
}
```
 I will probably end up with encoding with .URL. but what if I would want to set encoding to .JSON?
  `XCPSetExecutionShouldContinueIndefinitely()` should now be `XCPlaygroundPage.currentPage.needsIndefiniteExecution = true` as the former was deprecated.
  ![1](https://cloud.githubusercontent.com/assets/3182964/10756553/cec932d8-7cdf-11e5-870d-983f7677c69a.jpg)
 I really appreciate
 I am struggling with this issue... Thanks you so much.
  Hi good day,

I am having a issue installing alamofire in my swift project.

My OS is Yosemite
Cocoapods version is 0.39.0
Xcode 7.1

This is the error:

Updating local specs repositories
Analyzing dependencies
[!] Unable to satisfy the following requirements:
- `Alamofire (= 3.1.0)` required by `Podfile`

[!] CocoaPods was not able to update the `master` repo. If this is an unexpected issue and persists you can inspect it running `pod repo update --verbose` 

Hope you can help me on this issue.

Thanks!
  Hi,

I try to find a way to update request headers before its execution.

I call REST web services granted by OAuth token. I created a custom validation closure which refreshes access token if validation result is 401.

``` swift
Alamofire.request(mutableURLRequest).validate({ (request: NSURLRequest?, response: NSHTTPURLResponse) -> Request.ValidationResult in
      if response.statusCode == 401 {
         // try to refresh access token
         if token is refresh {
            // how to update current request headers before .responseArray execution?
            return .Success
         } else {
            return .Failure(a custom error)
         }
      } else {
         return .Success
      }
}).responseArray { (request: NSURLRequest, response: NSHTTPURLResponse?, array: [AnyObject]?, data: AnyObject?, error: ErrorType?) -> Void in
           completion(array: array)
}
```

But, I haven't found a way to access to current request (through Alamofire.Manager for example) to update its headers (with my new access token in my closure) before .responseArray execution.

Any idea will be appreciated.

Thanks.
  Xcode 7.1 is out in the App Store, the comment related to rdar://22307360 is no longer needed
 Cool! :+1: 
  This is great :+1: 
 This is great :) I just don't like the `NSData()` and `NSNull()` that much. I guess it can't be done anyway else because `.Success` is expecting a non-nil value. And I'm pretty sure you wouldn't be a big fan of `ResponseSerializer<AnyObject?, NSError>` returned as the JSON serializer.
Anyway, it 's way better than getting an error. `NSNull` can be checked by the receiver at runtime and transformed to `nil` when needed/appropriate.
 @cnoon How I can do a request when I wait for 204 response? Can you show me a sample?
  I am using **Alamofire 3.1.0** (obtained via **Carthage**) in an **iOS 9.1** application built using **Swift 2** on **Xcode 7.1 (7B91b)**.

Whenever I try to validate the an archive with the settings below:
<img width="1312" alt="screen shot 2015-10-26 at 1 37 22 am" src="https://cloud.githubusercontent.com/assets/1791760/10717575/bd60a0a2-7b82-11e5-9b8a-1e6df31d2d99.png">

I get the following error:

<img width="1312" alt="screen shot 2015-10-26 at 1 29 45 am" src="https://cloud.githubusercontent.com/assets/1791760/10717576/c16ed9ca-7b82-11e5-9ffc-641c703597e8.png">

<img width="1312" alt="screen shot 2015-10-26 at 1 37 37 am" src="https://cloud.githubusercontent.com/assets/1791760/10717578/c78195c8-7b82-11e5-853a-fb5dc410987b.png">

However, when I uncheck the `include bitcode` checkbox, the validation succeeds.  If I try to submit to the AppStore without `bitcode`, then I get the following error:

<img width="554" alt="screen shot 2015-10-26 at 1 52 46 am" src="https://cloud.githubusercontent.com/assets/1791760/10717657/8d8af7e0-7b84-11e5-8a6c-fab28af46597.png">
## Additional Info
#### Project settings

<img width="795" alt="screen shot 2015-10-26 at 1 58 23 am" src="https://cloud.githubusercontent.com/assets/1791760/10717676/3ad28ecc-7b85-11e5-8cbb-4a117b5f6bff.png">
#### Build settings

<img width="881" alt="screen shot 2015-10-26 at 1 58 36 am" src="https://cloud.githubusercontent.com/assets/1791760/10717675/38213ea8-7b85-11e5-8a21-b3c1e1d2c24f.png">
 @cnoon Thank you for the reply.  I did try the solutions proposed in [Carthage #859](https://github.com/Carthage/Carthage/issues/859) before posting here, however they did not work.  This does seem like a Carthage and Xcode 7.1 issue.  Would you recommend opening an issue with Carthage?
 @adityatrivedi The issues are fixed in [Carthage 0.9.4](https://github.com/Carthage/Carthage/releases/tag/0.9.4) and you should follow [the steps](https://github.com/Carthage/Carthage/blob/0.9.4/README.md#if-youre-building-for-ios) for iOS App Store submission (using `carthage copy-frameworks` command instead of ‚ÄúEmbedded Binaries‚Äù).
 @ikesyo, sweet, it works! Thank you!
@cnoon I think this issue can remain closed now :)
  Just wanted to let you know I now created a 2nd response serializer library.
- [AlamofireJsonToObject](https://github.com/evermeer/AlamofireJsonToObjects) - An Alamofire extension which converts JSON response data into swift objects using EVReflection
- [AlamofireXmlToObject](https://github.com/evermeer/AlamofireXmlToObjects) - An Alamofire extension which converts XML response data into swift objects using EVReflection and XMLDictionary

Besides that, I also have an Oauth2 library based on Alamofire:
- [AlamofireOauth2](https://github.com/evermeer/AlamofireOauth2) - A swift implementation of OAuth2 using Alamofire
  How can I handle a JSON response when the server returns an error using Alamofire?

Let's say I perform a request that responds with an error:

``` swift
Alamofire.request(.GET, "http://httpbin.org/get")
         .validate()
         .responseJSON { response in
         }
```

Response Code: `400`
Body: `{"message": "an error has occurred."}`

Since the request was validated, I expect Alamofire's `response.result` to be an error, `.Failure(let error)`, but I'd like to get the JSON data from the response as well. Unfortunately, Alamofire dictates that whenever the result is a `.Failure`, there will be no `value`.

``` swift
    public var value: Value? {
        switch self {
        case .Success(let value):
            return value
        case .Failure:
            return nil
        }
    }
```

Is there a proper way to get this data out of the response without having to parse the raw data manually every time I perform a request to check for this case?
  Sorry if this is too much a of nitpick, but I noticed this section while I was reading the project source and thought it would be better to use the string class directly instead. 

Hope it helps!
  Hi, 
<img width="1392" alt="screen shot 2015-10-24 at 2 17 49 pm" src="https://cloud.githubusercontent.com/assets/11483269/10709826/709c3d04-7a5a-11e5-90b8-570f912b08f9.png">

I face crash while making a get request using the Almofire swift code.
It seems the urlString doesnt get converted to NSURL which is optional and when unwrapping it crashes as the url is nil.Please check screenshot in which i have printed the "url string" and "NSURL" in the console.
Any help would be great.

Thanks
  Not able to send the json of below format in alamofire as post parameter

{"paymenttype":"cod",
 "items": [{"street":"lane1", "city":"mumbai"}, {"street":"lane2", "city":"delhi"}]
}
 I have aldready checked out on stackoverflow 
http://stackoverflow.com/questions/27794918/sending-array-of-dictionaries-with-alamofire. 
http://www.scriptscoop.net/t/482057cd9d3a/ios-sending-array-of-dictionaries-with-alamofire.html.

I didnt get solution so i came here. 
You could have answered here itself.
By the way this is one of the lamest responses, i have seen.
You just acted like a support team from fucking Microsoft.
 1) Man..we have figured it out a way. Guess what we are not using yours.
2) We have checked out on stack overflow, we are not able to find out solution. Thats the reason we have asked here.
3) Instead of you writing me a fucking lousy and big fucking big text, you could have answered it.
4) This is the typical problem with you fucking europeans. You guys follow ethics than morals.
5) I donno man for what reason, you are developing whether its your hobby or your jobless. But as  a guy from startup, i expect the people to be proactive and follow morals not rules. That makes me an asshole to some people. I m fine with it. I live with that.
6) Regarding Microsoft thing you have misunderstood me. Here as you are a small team, i expected very less beureacracy. Guess what you have started acting like a fucking beaureacrat before you guys have become big.
  Whenever I run my project on my device I receive the error "EXC_BAD_ACCESS" - shown in the screenshot. Seems like it works just fine on the simulator.

Im running Xcode 7.1 with Swift 2.1, iOS 9.1 and Alamofire 3.1.0 

![skaermbillede 2015-10-24 kl 01 06 58](https://cloud.githubusercontent.com/assets/3939917/10706888/a3f705a4-79eb-11e5-8b9d-a71bf488994c.png)

Any help is appreciated :-)
 I forgot to mention that im making a GET request which make it crash. I really need a solution as I was about to release my app, and Now im stuck. 
 Can you post the code that builds the request? (your code, not AF code)
 Hi again. 

The iOS Example projects works fine. :-)

Due to privacy I've changed the API endpoint, but it still crashes the same place.

From the applicationDidBecomeActive method I call my singleton class "API" which make the following Alamofire GET request: Alamofire.request(.GET, "http://swifty.dk/test/api") and then it crash like I wrote earlier. The weird thing is that it works in the simulator. :s

I noticed that I got two warnings regarding Alamofire.
"PATH.../Pods/Local%20Podspecs/Alamofire.podspec.json: warning: Missing file: PATH.../Pods/Local Podspecs/Alamofire.podspec.json is missing from working copy"

and

"PATH.../Pods/Target%20Support%20Files/Alamofire/Alamofire-Private.xcconfig: warning: Missing file: PATH.../Pods/Target Support Files/Alamofire/Alamofire-Private.xcconfig is missing from working copy"
 Deleting data in DerivedData seems to fix the problem.
  Parse error: unexpected SDK key "appletvos"
 Same as here https://github.com/Alamofire/Alamofire/issues/878
  **\* Building scheme "Alamofire tvOS" in Alamofire.xcworkspace
Parse error: unexpected SDK key "appletvos"
 You should use Xcode 7.1.
 I am using 7.1
 Actually I have the same problem.
New project. Cartfile is:
`github "Alamofire/Alamofire" ~> 3.0`

Then I did: carthage update and result is 

```
*** Fetching Alamofire
*** Checking out Alamofire at "3.1.0"
*** xcodebuild output can be found in /var/folders/k5/ryt8g_7s2kg7x_rx4gf03twc0000gn/T/carthage-xcodebuild.b1eIwx.log
*** Building scheme "Alamofire OSX" in Alamofire.xcworkspace
*** Building scheme "Alamofire watchOS" in Alamofire.xcworkspace
*** Building scheme "Alamofire tvOS" in Alamofire.xcworkspace
Parse error: unexpected SDK key "appletvos"
```

Xcode 7.1 release version.
 Ah, OK. Carthage supports tvOS platform from 0.9, so please update to latest [0.9.3](https://github.com/Carthage/Carthage/releases/tag/0.9.3) release using pkg installer.
 Ah. True. Had the homebrew version which is lagging behind in 0.8.
 thanks
  Hi,

I have an API which takes about 2 minutes to respond. How can I change default timeout to more than 2 minutes. I am using following code for firing api:

Alamofire.request(.GET, encodedULR!, parameters: params, headers:headers)
        .response { request, response, data, errorType in

```
        if errorType == nil
        {
            let responseString = NSString(data: data!, encoding: NSUTF8StringEncoding) as String!
            print(responseString)
            callback(responseString, nil)
        }
        else
        {
            callback("", errorType as? NSError)
            print(errorType)
        }
    }
```

Thanks.
  Hi,

I'm using Alamofire for a https connection. I use a nodejs https server. When using curl and providing the CA using `--cacert <ca-file>` it works just fine.
However when testing in Alamofire I get this error:

```
Error Domain=NSURLErrorDomain Code=-1200 "An SSL error has occurred and a secure connection to the server cannot be made." UserInfo={NSURLErrorFailingURLPeerTrustErrorKey=<SecTrustRef: 0x60c000047980>, NSLocalizedRecoverySuggestion=Would you like to connect to the server anyway?, _kCFStreamErrorDomainKey=3, _kCFStreamErrorCodeKey=-9802, NSErrorPeerCertificateChainKey=<CFArray 0x60600015e840 [0x10c05b7b0]>{type = immutable, count = 1, values = (
    0 : <cert(0x61600007e680) s: localhost i: localhost>
)}, NSUnderlyingError=0x6040000abe90 {Error Domain=kCFErrorDomainCFNetwork Code=-1200 "(null)" UserInfo={_kCFStreamPropertySSLClientCertificateState=0, kCFStreamPropertySSLPeerTrust=<SecTrustRef: 0x60c000047980>, _kCFNetworkCFStreamSSLErrorOriginalValue=-9802, _kCFStreamErrorDomainKey=3, _kCFStreamErrorCodeKey=-9802, kCFStreamPropertySSLPeerCertificates=<CFArray 0x60600015e840 [0x10c05b7b0]>{type = immutable, count = 1, values = (
    0 : <cert(0x61600007e680) s: localhost i: localhost>
)}}}, NSLocalizedDescription=An SSL error has occurred and a secure connection to the server cannot be made.
```

My source looks like this:

```
class Networking {
  static let manager: Manager = {
    let serverTrustPolicies: [String: ServerTrustPolicy] = [
      "localhost": .DisableEvaluation
    ]

    let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
    configuration.HTTPAdditionalHeaders = Alamofire.Manager.defaultHTTPHeaders

    return Alamofire.Manager(configuration: configuration,
      serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies))
  }()

  func test() {
    Networking.manager.request(.GET, "https://localhost:3000/", parameters: nil)
      .responseJSON { (response: Response<AnyObject, NSError>) in
        // nothing interesting
    }
  }
```

I'm using Alamofire from the xcode7.1 branch.
 Unfortunately that didn't fix my problem :cry: ... Which detail do you need for investigation?
 I set up a test-server at https://api.moritzsternemann.de:3000 (could take a couple of hours for the dns-entry to update :smile:)

``` bash
curl --cacert root-ca.crt.pem https://api.moritzsternemann.de:3000
```

works perfectly

I updated the URL and set the serverTrustPolicies like this:

``` swift
  let serverTrustPolicies: [String: ServerTrustPolicy] = [
      "api.moritzsternemann.de:3000": .DisableEvaluation,
      "api.moritzsternemann.de": .DisableEvaluation
    ]
```

BUT now I get an other error:

```
CFNetwork SSLHandshake failed (-9806)
NSURLSession/NSURLConnection HTTP load failed (kCFStreamErrorDomainSSL, -9806)

Error Domain=NSURLErrorDomain Code=-1200 "An SSL error has occurred and a secure connection to the server cannot be made." UserInfo={_kCFStreamErrorCodeKey=-9806, NSLocalizedRecoverySuggestion=Would you like to connect to the server anyway?, NSUnderlyingError=0x6040000ab4d0 {Error Domain=kCFErrorDomainCFNetwork Code=-1200 "(null)" UserInfo={_kCFStreamPropertySSLClientCertificateState=0, _kCFNetworkCFStreamSSLErrorOriginalValue=-9806, _kCFStreamErrorDomainKey=3, _kCFStreamErrorCodeKey=-9806}}, NSLocalizedDescription=An SSL error has occurred and a secure connection to the server cannot be made., _kCFStreamErrorDomainKey=3}
```
 Hm I tried adding the Test to my projects test suite and it failed...

```
17:04:45.211 AlamofireTest[19598:801335] _XCT_testBundleReadyWithProtocolVersion:minimumVersion: reply received
17:04:45.214 AlamofireTest[19598:801336] _IDE_startExecutingTestPlanWithProtocolVersion:16
Test Suite 'Selected tests' started at 2015-10-26 17:04:45.218
Test Suite 'AlamofireTestTests' started at 2015-10-26 17:04:45.218
Test Case '-[AlamofireTestTests.AlamofireTestTests testSelfSignedCertificate]' started.
2015-10-26 17:04:45.540 AlamofireTest[19598:801348] CFNetwork SSLHandshake failed (-9806)
2015-10-26 17:04:45.541 AlamofireTest[19598:801348] NSURLSession/NSURLConnection HTTP load failed (kCFStreamErrorDomainSSL, -9806)
/Users/moritz/Projects/Xcode/AlamofireTest/AlamofireTestTests/AlamofireTestTests.swift:75: error: -[AlamofireTestTests.AlamofireTestTests testSelfSignedCertificate] : XCTAssertNotNil failed - response should not be nil
/Users/moritz/Projects/Xcode/AlamofireTest/AlamofireTestTests/AlamofireTestTests.swift:77: error: -[AlamofireTestTests.AlamofireTestTests testSelfSignedCertificate] : XCTAssertNil failed: "Error Domain=NSURLErrorDomain Code=-1200 "An SSL error has occurred and a secure connection to the server cannot be made." UserInfo={_kCFStreamErrorCodeKey=-9806, NSLocalizedRecoverySuggestion=Would you like to connect to the server anyway?, NSUnderlyingError=0x7fc039900ec0 {Error Domain=kCFErrorDomainCFNetwork Code=-1200 "(null)" UserInfo={_kCFStreamPropertySSLClientCertificateState=0, _kCFNetworkCFStreamSSLErrorOriginalValue=-9806, _kCFStreamErrorDomainKey=3, _kCFStreamErrorCodeKey=-9806}}, NSLocalizedDescription=An SSL error has occurred and a secure connection to the server cannot be made., NSErrorFailingURLKey=https://api.moritzsternemann.de:3000/, NSErrorFailingURLStringKey=https://api.moritzsternemann.de:3000/, _kCFStreamErrorDomainKey=3}" - error should not be nil
/Users/moritz/Projects/Xcode/AlamofireTest/AlamofireTestTests/AlamofireTestTests.swift:78: error: -[AlamofireTestTests.AlamofireTestTests testSelfSignedCertificate] : XCTAssertEqual failed: ("nil") is not equal to ("Optional(200)") - response status code should be 200
Test Case '-[AlamofireTestTests.AlamofireTestTests testSelfSignedCertificate]' failed (0.326 seconds).
Test Suite 'AlamofireTestTests' failed at 2015-10-26 17:04:45.545.
     Executed 1 test, with 3 failures (0 unexpected) in 0.326 (0.327) seconds
Test Suite 'Selected tests' failed at 2015-10-26 17:04:45.545.
     Executed 1 test, with 3 failures (0 unexpected) in 0.326 (0.328) seconds


Test session log:
    /var/folders/xm/j_1zxbhd6qzb7f2bytxkbq6r0000gn/T/com.apple.dt.XCTest-status/Session-2015-10-26_17:04:43-uadmKS.log
```

Then I tried adding the test to Alamofire's test suite as you mentioned and **it passed**.

Another interesting thing: I added a breakpoint to `ServerTrustPolicyManager.serverTrustPolicyForHost(:)` and it only get's hit when running the test from Alamofire's test suite and not from my apps.
I also tried creating a completely new app for this but I got the same results.

So I thought this could have something to do with my apps target being the iOS simulator and Alamofire's test being run on My Mac. So I created a new Mac Application but testing in it's test suite threw me the same errors.

Maybe you could try this in an iOS App yourself :smile: 
 I am experiencing similar issues with a self signed certificate. When I add the code @cnoon mentioned earlier to a view controller (commenting out the asserts etc and using `debugPrint` statements) it also fails for me:

code:

```
    func testSelfSignedCertificate() {
        // Given
        let manager: Alamofire.Manager = {
            let serverTrustPolicies: [String: ServerTrustPolicy] = [
                "api.moritzsternemann.de": .DisableEvaluation
            ]

            let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
            configuration.HTTPAdditionalHeaders = Alamofire.Manager.defaultHTTPHeaders

            return Alamofire.Manager(
                configuration: configuration,
                serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies)
            )
        }()

//        let expectation = expectationWithDescription("request should succeed")

        var request: NSURLRequest?
        var response: NSHTTPURLResponse?
        var data: NSData?
        var error: NSError?

        // When
        manager.request(.GET, "https://api.moritzsternemann.de:3000")
            .response { responseRequest, responseResponse, responseData, responseError in
                request = responseRequest
                response = responseResponse
                data = responseData
                error = responseError

                //expectation.fulfill()
                debugPrint(request)
                debugPrint(response)
                debugPrint(data)
                debugPrint(error)
        }

//        waitForExpectationsWithTimeout(defaultTimeout, handler: nil)
//        
//        // Then
//        XCTAssertNotNil(request, "request should not be nil")
//        XCTAssertNotNil(response, "response should not be nil")
//        XCTAssertNotNil(data, "data should not be nil")
//        XCTAssertNil(error, "error should not be nil")
//        XCTAssertEqual(response?.statusCode, 200, "response status code should be 200")
    }
```

output:

```
Optional(<NSMutableURLRequest: 0x7f8220f8c350> { URL: https://api.moritzsternemann.de:3000 })
nil
Optional(<>)
Optional(Error Domain=NSURLErrorDomain Code=-999 "cancelled" UserInfo={NSErrorFailingURLKey=https://api.moritzsternemann.de:3000/, NSLocalizedDescription=cancelled, NSErrorFailingURLStringKey=https://api.moritzsternemann.de:3000/})
```

By the way, I am using Alamofire 3.1.0:

```
~ $ cat Cartfile.resolved 
github "Alamofire/Alamofire" "3.1.0"
github "SwiftyJSON/SwiftyJSON" "2.3.1"
```

Using curl it works just fine:

```
~ $ curl --cacert ~/Downloads/api.moritzsternemann.de.cer https://api.moritzsternemann.de:3000
<!DOCTYPE html><html><head><title>Express</title><link rel="stylesheet" href="/stylesheets/style.css"></head><body><h1>Express</h1><p>Welcome to Express</p></body></html>
```
 Could this issue be related to "App Transport Security"? As it's lower level then NSURLConnection the usual way of using DidReceiveChallenge will not work for self-signed certificates.
 Yeah I was thinking that as well so I tried the same code with the `NSAppTransportSecurity` / `NSExceptionDomains` (as described [here](http://ste.vn/2015/06/10/configuring-app-transport-security-ios-9-osx-10-11/)) but no luck.

```
    <key>NSAppTransportSecurity</key>
    <dict>
        <key>NSAllowsArbitraryLoads</key>
        <true/>
        <key>moritzsternemann.de</key>
        <dict>
            <key>NSIncludesSubdomains</key>
            <true/>
            <key>NSExceptionAllowsInsecureHTTPLoads</key>
            <true/>
            <key>NSThirdPartyExceptionRequiresForwardSecrecy</key>
            <false/>
            <key>NSExceptionRequiresForwardSecrecy</key>
            <false/>
            <key>NSThirdPartyExceptionAllowsInsecureHTTPLoads</key>
            <true/>
            <key>NSTemporaryExceptionAllowsInsecureHTTPLoads</key>
            <true/>
            <key>NSTemporaryExceptionMinimumTLSVersion</key>
            <string>TLSv1.1</string>
            <key>NSThirdPartyExceptionMinimumTLSVersion</key>
            <string>TLSv1.1</string>
            <key>NSRequiresCertificateTransparency</key>
            <false/>
        </dict>
    </dict>
```

I am also experiencing issues with some valid SSL certificates, I am not sure if it is related. This code, for example, is also failing for me:

```
Alamofire.request(.GET, "https://pademo.service-now.com")
            .response { response in
                debugPrint(response)
            }
```

```
2015-10-30 17:25:10.117 TestApp[60587:3182750] CFNetwork SSLHandshake failed (-9824)
2015-10-30 17:25:10.118 TestApp[60587:3182750] NSURLSession/NSURLConnection HTTP load failed (kCFStreamErrorDomainSSL, -9824)
(Optional(<NSMutableURLRequest: 0x7fab6a11da70> { URL: https://pademo.service-now.com }), nil, Optional(<>), Optional(Error Domain=NSURLErrorDomain Code=-1200 "An SSL error has occurred and a secure connection to the server cannot be made." UserInfo={_kCFStreamErrorCodeKey=-9824, NSLocalizedRecoverySuggestion=Would you like to connect to the server anyway?, NSUnderlyingError=0x7fab6a203900 {Error Domain=kCFErrorDomainCFNetwork Code=-1200 "(null)" UserInfo={_kCFStreamPropertySSLClientCertificateState=0, _kCFNetworkCFStreamSSLErrorOriginalValue=-9824, _kCFStreamErrorDomainKey=3, _kCFStreamErrorCodeKey=-9824}}, NSLocalizedDescription=An SSL error has occurred and a secure connection to the server cannot be made., NSErrorFailingURLKey=https://pademo.service-now.com/, NSErrorFailingURLStringKey=https://pademo.service-now.com/, _kCFStreamErrorDomainKey=3}))
```

Even though the certificate if perfectly [valid](https://www.digicert.com/help/?host=pademo.service-now.com)...

Requesting the main site ([same certificate issuer](https://www.digicert.com/help/?host=www.servicenow.com)) works fine

```
        let request = Alamofire.request(.GET, "https://www.servicenow.com")
            .response { response in
                debugPrint(response)
            }
```

The main difference being that the `pademo` certificate is a wildcard certificate, while the other one is not. 

Testing another wildcard certificate (`nl.godaddy.com`) however passes and the code runs fine... 
 thanks for the help! @cnoon :+1: 
 Awesome! :+1: :smile: 
 Hi, please help me.
I use xcode 7.1, swift 2, Alamofire 3.1.3. When i use curl
curl -H "Accept: application/json" -H -X GET "https://instore.meduzaradio.com/api/station.json" --insecure
{"code":401,"error":"You must be authorized to view this page."}
it works just fine
In xcode i recive error  
NSURLSession/NSURLConnection HTTP load failed (kCFStreamErrorDomainSSL, -9814)

my  code:

class HTTPManager: Alamofire.Manager {
    static let sharedManager: HTTPManager = {
        //let configuration = Timberjack.defaultSessionConfiguration()
        let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
        configuration.HTTPAdditionalHeaders = Alamofire.Manager.defaultHTTPHeaders
        let serverTrustPolicies: [String: ServerTrustPolicy] = [
            "instore.meduzaradio.com:": .DisableEvaluation
        ]
        var policy: ServerTrustPolicy = ServerTrustPolicy.DisableEvaluation
        let manager = HTTPManager(configuration: configuration,serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies))
        return manager
    }()
}

class HTTPServise: NSObject {

```
let baseUrl:String = "https://instore.meduzaradio.com/api/"
var manager: Alamofire.Manager
override init(){
    manager = HTTPManager.sharedManager
}

func getRequestWithURL(url:String, parameters:[String: AnyObject]? = nil,completion:(finished: Bool, response: AnyObject?) ->Void ){
    abstractRequestWithMethod(.GET, url: url, parameters: parameters, completion: completion)
}

private func abstractRequestWithMethod(method:Alamofire.Method,url:String,parameters:[String: AnyObject]? = nil, completion:(finished: Bool, response: AnyObject?) ->Void ){


    manager.request(.GET,(baseUrl+url) as URLStringConvertible)
    .responseJSON { response in
        print(response.request)  // original URL request
        print(response.response) // URL response
        print(response.data)     // server data
        print(response.result)   // result of response serialization

        if let JSON = response.result.value {
            print("JSON: \(JSON)")
        }
    }   
}   
```

}

![2015-11-27 00-39-22 info plist](https://cloud.githubusercontent.com/assets/5228281/11430957/b3b90c3e-949f-11e5-8f48-d8aa3dda07a5.png)
 Perhaps we could do without self-signed certificates from now on? :)

Read this article on [Free HTTPS Certs for all](http://www.theregister.co.uk/2015/12/03/letsencrypt_public_beta/)
 I'm working on OSX 10.11 and was facing this issue, the following is for reference. The Info.plist `App Transport Security Settings` is not enough on its own, it rarely works. The certificate should be added to the Keychain and marked a trusted, this would resolve the issue of self-signed certificates in the development environment without adding the risk of forgetting the Info.plist settings set in a production release.

![keychain](https://cloud.githubusercontent.com/assets/568794/11943235/40ddab22-a84d-11e5-823b-3aad9607d168.png)
 @cnoon the problem best represents itself when dealing with localhost self-signed certs. 
 If NSAppTransportSecurity does not work, try the following along with it:

Here is a possible solution on how to accept invalid SSL Certificates in Alamofire. 

Add the following function in your AppDelegate class and call it in didFinishLaunching function:

```
func acceptInvalidSSLCerts()
 {
          let manager = Alamofire.Manager.sharedInstance
  print("trying to accept invalid certs")

          manager.delegate.sessionDidReceiveChallenge = { session, challenge in
              var disposition: NSURLSessionAuthChallengeDisposition = .PerformDefaultHandling
              var credential: NSURLCredential?

              print("received challenge")

              if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
                  disposition = NSURLSessionAuthChallengeDisposition.UseCredential
                  credential = NSURLCredential(forTrust: challenge.protectionSpace.serverTrust!)
              } else {
                  if challenge.previousFailureCount > 0 {
                      disposition = .CancelAuthenticationChallenge
                  } else {
                      credential = manager.session.configuration.URLCredentialStorage?.defaultCredentialForProtectionSpace(challenge.protectionSpace)

                      if credential != nil {
                          disposition = .UseCredential
                      }
                  }
              }

              return (disposition, credential)
          }
      }


```

Reference:-> [Accepting invalid SSL certificates in Alamofire](http://swiftforums.org/forum/alamofire/32-accept-invalid-ssl-certificates-in-alamofire)
 Apple said [they will require ATS in all apps by January 1, 2017.](https://techcrunch.com/2016/06/14/apple-will-require-https-connections-for-ios-apps-by-the-end-of-2016) Are there other options to keep custom CA working?
 @tvich1 I have done exactly what you suggested in your post. I then try to make the following request in a view controller:

`        let userPasswordString: String = "---:---"
        let authData = userPasswordString.dataUsingEncoding(NSUTF8StringEncoding)
        let base64EncodedCredentials = authData!.base64EncodedStringWithOptions(NSDataBase64EncodingOptions([]))
        let headers = ["Authorization": "Basic (base64EncodedCredentials)"]

```
    let serverTrustPolicies: [String: ServerTrustPolicy] = [
        "---.com": .DisableEvaluation,
    ]

    let manager = Alamofire.Manager(
        serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies)
    )

    manager.request(.GET, "https://---.com:7183/api/v10/clusters/cluster/services", headers: headers)
        .responseJSON { response in
            print(response.request)  // original URL request
            print(response.response) // URL response
            print(response.data)     // server data
            print(response.result)   // result of response serialization

            if let JSON = response.result.value {
                print("JSON: \(JSON)")
            }
    }`
```

However, I am getting the following output.

`trying to accept invalid certs
User Authenticated
Optional(<NSMutableURLRequest: 0x7f9ac16d6b80> { URL: https://---.com:7183/api/v10/clusters/cluster/services })
nil
Optional(<>)
FAILURE`

Note, I have replaced some of the text with "---" for security reasons. I have asked the api team that I am using to create a public certificate, but is there any workaround that I can do for now? @cnoon 
 @tvich1 @cnoon Nevermind... I was able to solve this problem by adding the acceptInvalidSSLCerts() to my view controller class and making the Alamo.manager variable a class variable. 
 @cnoon How to set  value for `Exception Domains` in `ATS` for dynamic hostnames ?
 Hi,

I'm using Alamofire for a https connection.  

However when testing in Alamofire I get this error:

`URLError occurred: URLError(_nsError: Error Domain=NSURLErrorDomain Code=-999 "cancelled" UserInfo={NSErrorFailingURLKey=https://192.168.X.XX/VMSSite/Handlers/Common/iOSServer.ashx?RegID=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX, NSLocalizedDescription=cancelled, NSErrorFailingURLStringKey=https://192.168.X.XX/VMSSite/Handlers/Common/iOSServer.ashx?RegID=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX})
status code: nil`

My source looks like this:

`var defaultManager = Alamofire.SessionManager.default
        let serverTrustPolicies: [String: ServerTrustPolicy] = [
                "192.168.X.XX:443": .disableEvaluation,
                "192.168.X.XX": .disableEvaluation
        ]

        let configuration = URLSessionConfiguration.default
        configuration.timeoutIntervalForRequest = 30 //seconds
        configuration.httpAdditionalHeaders = Alamofire.SessionManager.defaultHTTPHeaders
        
        //defaultManager = SessionManager(configuration: configuration, delegate: SessionDelegate(), serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies))
        defaultManager = SessionManager(configuration: configuration, serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies))

        defaultManager.request("https://192.168.X.XX/VMSSite/Handlers/Common/iOSServer.ashx?RegID=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", method: .post, parameters: nil, encoding: JSONEncoding.default).responseJSON { response in
            debugPrint(response)
 //Ref link - http://stackoverflow.com/questions/29131253/swift-alamofire-how-to-get-the-http-response-status-code

            var statusCode = response.response?.statusCode
            
            if let error = response.result.error as? AFError {
                statusCode = error._code // statusCode private
                switch error {
                case .invalidURL(let url):
                    print("Invalid URL: \(url) - \(error.localizedDescription)")
                case .parameterEncodingFailed(let reason):
                    print("Parameter encoding failed: \(error.localizedDescription)")
                    print("Failure Reason: \(reason)")
                case .multipartEncodingFailed(let reason):
                    print("Multipart encoding failed: \(error.localizedDescription)")
                    print("Failure Reason: \(reason)")
                case .responseValidationFailed(let reason):
                    print("Response validation failed: \(error.localizedDescription)")
                    print("Failure Reason: \(reason)")
                    
                    switch reason {
                    case .dataFileNil, .dataFileReadFailed:
                        print("Downloaded file could not be read")
                    case .missingContentType(let acceptableContentTypes):
                        print("Content Type Missing: \(acceptableContentTypes)")
                    case .unacceptableContentType(let acceptableContentTypes, let responseContentType):
                        print("Response content type: \(responseContentType) was unacceptable: \(acceptableContentTypes)")
                    case .unacceptableStatusCode(let code):
                        print("Response status code was unacceptable: \(code)")
                        statusCode = code
                    }
                case .responseSerializationFailed(let reason):
                    print("Response serialization failed: \(error.localizedDescription)")
                    print("Failure Reason: \(reason)")
                    // statusCode = 3840 ???? maybe..
                }
                
                print("Underlying error: \(error.underlyingError)")
            } else if let error = response.result.error as? URLError {
                print("URLError occurred: \(error)")
            } else {
                print("Unknown error: \(response.result.error)")
            }
            
            print("status code: \(statusCode)") // the status code
`

I'm using Swift 3 and Alamofire 4.0 from the xcode8.1 branch. 
Please help me.
And 
How to set value for Exception Domains in ATS for dynamic hostnames?
 "Cancelled" error is due to concurrent requests, previous request fails with "cancelled" error when you use the same Manager.
I handled this by not sending any request until authorization request is either failure/success. hi stephen,

Thanks for reply.
can you explain this with code.  Hi,

I tried some variant code above, but I still get error 

> FAILURE: Error Domain=NSURLErrorDomain Code=-999 "cancelled" 

btw, I use IP  Address instead domain for my URL request and my server is detected as not secure
![image](https://cloud.githubusercontent.com/assets/10285475/24639624/1f8db1c0-191b-11e7-85dd-604d8e5e19da.png)

 I'm using Alamofire 4.2   Please can anyone point me in the right direction to integrate Alamofire to use with TVOS ?
  I want to set up the phpsessionid inside the cookie to ask how this is set up
  Does Alamofire support Soap web service? will it create soap envelope itself or we need to provide it ?
  On iOS 9.0.1 using Alamofire 3.0, if I made some requests (which worked), locked the device, and then opened the again immediately the first request would consistently fail. The next time I retried the request it worked.

I have a singleton that caches an Alamofire.Manager. The request would fail with "connection closed" -1005  NSURLErrorNetworkConnectionLost.

After searching for anyone seeing a similar issue, I found [Apple Tech Note TN2277](https://developer.apple.com/library/ios/technotes/tn2277/_index.html#//apple_ref/doc/uid/DTS40010841-CH1-SUBSECTION9), which says that the kernel can reclaim sockets out from under apps without them having any idea what happens. Here's the relevant section:

> **Testing Socket Reclaim**
> If you're going to write code that handles a socket's resources being reclaimed by the kernel, you have to figure out how to test it. The exact circumstances under which the system might reclaim a socket's resources are purposely not documented; this gives us the flexibility to improve things in the future. However, on current systems (iOS 4.0 through iOS 4.3), you can get the system to reclaim resources from the sockets in your app by:
> 1. putting your app in the background
> 2. ensuring that the app is suspended
> 3. locking the screen
> 
> When your app resumes execution it will find that it's sockets have been reclaimed.

My guess is that NSURLSession (which Alamofire.Manager is caching), has one or more sockets it keeps open (possibly to avoid renegotiating TLS handshakes). Then, when the device is locked, the OS reclaims these sockets. The next request on them results in an EBADF errno from the system call, which gets translated into an NSError with localized description "connection closed".

To workaround this, I created a new Alamofire.Manager whenever my AppDelegate's `applicationWillEnterForeground` is called. This completely resolved the issue.

Like I said earlier, this is just my best guess of what is happening under the hood, take it with a grain of salt, but wanted to bring it up at least for discussion to see if there was a more general way of solving the problem.
 Yeah sorry, I know it's not exactly a bug report, just describing something that was surprising to me (not being a long time iOS developer).

I know this issues is down in below the socket API, which is below NSURLSession, which is below Alamofire, which is below AlamofireImage and my WebAPI. But when you're using, for example, AlamofireImage and an image doesn't load when the app comes to the foreground, it's a bit strange. AlamofireImage is also caching an Alamofire.Manager in an ImageManager associated with the UIImageView class. The first time you load an image when the app comes to the foreground it fails and the image doesn't load. I bet there's a lot of this kind of behavior happening in other apps built on Alamofire and NSURLSession.

I wanted to bring it up to see if there was a way to address this in Alamofire that would be transparent to applications and libraries built on Alamofire (like AlamofireImage). Or if not, perhaps some guidance in the documentation about best practices for dealing with this issue.

But if you don't think there's anything to do here, please close it. Not trying to force you guys into anything.
  I am using Alamofire in my project , i have downloaded the latest file from Github and added the framework to my project. Then i came to Read that we need to set the Deployment target of Alamofire to same as our project deployment Target. My project Deployment target is 9.0 and when i set the Deployment Target of Alamofire to 9.0 it throws a warning

> Unnecessary check for 'iOSApplicationExtension'; minimum deployment target ensures guard will always be true 

I am Using **Mac OS X Yosemite Version: 10.10.5**
**Xcode Version 7.0 ,**
**Swift 2**
**Alamofire Version : 3.0.0**
 Downloaded from https://github.com/Alamofire/Alamofire
 I have the same "issue". I added Alamofire through Cocoapods.
 By the way, I enabled `inhibit_all_warnings!` in the `Podfile` but the warning remains.
 Sorry for the late response ...  I have Added Alamofire manually. 
 The aforementioned CocoaPods PR has now been merged.
 I still get when I build project

```
Unnecessary check for 'iOS'; minimum deployment target ensures guard will always be true
```

![](http://i.imgur.com/exnePui.png)

pod --version
0.39.0

OSX El Capitan 10.11.1
Xcode Version 7.1.1 (7B1005)
Alamofire 3.1.2
 Thank you for reply. 
 @cnoon is it ok to grab the development branch of alamofire for development? How long till the next pre-release?
 I built my project using Xcode 7.2.1 (7C1002) and deployment target iOS 9 at the first place. Later i need to deployment target to be set at iOS 8. 
My issues was similar to this one and the fixed didn't work:
http://stackoverflow.com/questions/32692828/module-files-deployment-target-is-ios9-0-v9-0-with-xcode-7-swift-2

Fix:
I closed the project and updated my pod. 

Huraah! it's working fine now
  How can i make alamofire supported by TVos , how can i compile and use ??
 There's a tvOS branch which can be used for tvOS projects. :+1: https://github.com/Alamofire/Alamofire/tree/tvOS
  Using Alamofire with Cocoapods in an app extension (Today widget) on iOS 8.1 doesn't trigger the response handlers.
On iOS 9.0 it's all fine.

Versions of Alamofire tried: 2.0 and 3.0.
Request type: .GET, With HTTP Digest Authentication over HTTPS, Custom parameters URL encoding.
Response type: JSON

I validated on the server, and the request is still being executed. And even the authentication is going on. But still no response callback. In the app itself it's all working, also on iOS 8.1.

Should be anything with memory leaks? Because the today widget will use 14GB memory after 10 minutes running.

Details running software:
Xcode 7
iOS Target 8.1

Part of code for request call:

``` swift
// Define some credentials here
let username = "username"
let password = "password"

var parameters:[String: AnyObject] = [:]
parameters["d"] = (UIDevice.currentDevice().identifierForVendor)!.UUIDString
parameters["v"] = "1.1.1"
parameters["b"] = "14414234"
parameters["uc"] = "1"

Alamofire.request(Alamofire.Method.GET, "https://somenicelink/", parameters: parameters, encoding: ParameterEncoding.URL)
    .authenticate(usingCredential: NSURLCredential(user: username, password: password, persistence: NSURLCredentialPersistence.ForSession))
    .responseJSON { response in
        let result = response.result
        print(result)
}
```

Thanks,
Tom
 Hi @cnoon. Currently I can't reproduce it myself. And it looks like it has something related with the memory leak and CPU lockup I got in the simulator.
Tried to disable the whole code. Use instruments to get the leaks. But it doesn't seem to be in my code or app as I can't get the leak address lead back to xcode lines.

I think it isn't Alamofire related. But more like an underlying API that will cause CPU lockup/memory leaking that will cause Alamofire to lose the request in some way.

I will continue to try and disable some stuff related to the widget. I can't test on a real device. I don't have iOS 8.1 on any devices anymore unfortunately.
 Seems to have an issue with iOS 8.1 - 8.2. Not Alamofire related. Thanks anyway.
  Following [w3.org](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.2.5) standard on response code **204**, when I do a `DELETE` operation, the server just responds with said code and no body.

[This test case](https://github.com/Alamofire/Alamofire/blob/master/Tests/ResponseSerializationTests.swift#L236) makes sure **Alamofire** raise an error when the body is `nil`. It'd be good to have support for this status code, thanks in advance!!
 @kylef @cnoon I don't see why the framework would fail for anything with a status code below 300. Anything 200-299 should work without any qualms. It is the users decision which response serializer works best with their server setup.

Some setups have json for errors from the server, others, just header information. This breaks that.
 I don't think the JSON serializer should fail in case of a HTTP 204 No-Content status code. I am often working with web APIs that will return a different formatted body depending on whether there's an error.
A specific endpoint could return a HTTP 204 when everything goes well, but might also return a descriptive JSON in case of an error (HTTP >= 400). I'm still going to use `responseJSON()` because I know I'll always get a JSON (or nothing) back. 

(I realize now this is pretty much what @dilizarov said in the previous post :-) )
 Funny enough, that is how it used to work, @damienrambout, but when I had to upgrade to Swift 2, and get the updated version of Alamofire, it broke because they included this new functionality. I still don't know why they decided to include this functionality. Safe to say, I had to fix half my responseJSON callbacks to account for this.
  I have an iOS app with Watchkit Extension and in the last version I've started using Cocoapods to manage better the dependencies. I can build the project without problems and run it perfectly.

However when I try to archive the app with Watchkit Extension target to publish my app, I receive the following error:

``` swift
error: module file was created for incompatible target armv7-apple-ios8.0: /Library/Developer/Xcode/DerivedData/B2B-dknnmkplfuhntmbjfxavlmufuiif/Build/Intermediates/ArchiveIntermediates/B2B/BuildProductsPath/Release-watchos/Pods-B2B WatchKit Extension/Alamofire.framework/Modules/Alamofire.swiftmodule/arm.swiftmodule
import Alamofire
       ^
```

I'm using the last version of Alamofire 3.0. Both the iOS app and the Watch app are using Alamofire to get data from internet. My Cocoapods file is this one:

``` swift
platform :ios, '8.0'

use_frameworks!
link_with 'B2B', 'B2B WatchKit Extension'
link_with 'B2B', 'B2B Free'

def shared_all_pods  
  pod 'Alamofire', '~> 3.0'
end

def shared_app_pods
  pod 'RealmSwift', '~> 0.95'
  pod 'SwiftyJSON', '~> 2.3'
end

target 'B2B' do
  shared_all_pods
  shared_app_pods
  pod 'MMWormhole', '~> 2.0'
end

target 'B2B Free' do
  shared_all_pods
  shared_app_pods
end

target 'B2B WatchKit Extension' do
  platform :watchos, '2.0'
  shared_all_pods
  pod 'MMWormhole', '~> 2.0'
end
```

Is anyone else having a similar error? What I'm doing wrong? Maybe my Cocoapod file isn't right? Or I shouldn't use Alamofire for Watchkit Extension?

Thanks in advance!

PS: I've opened in StackOverflow the same question --> http://stackoverflow.com/questions/33163798/xcode-error-module-file-was-created-for-incompatible-target-armv7-apple-ios8-0
 Ok thanks, I've tried to fix it but it stills crash when archiving. I'll raise an issue then.
  Hi,

I try to download a file. But I get the error "item with the same name already exists".

How can I resolved that ? 

Thank you !

Here my code : 

   func load(urlString : String) {

```
    let destination = Alamofire.Request.suggestedDownloadDestination(directory: .DocumentDirectory, domain: .UserDomainMask)
    Alamofire.download(.GET, urlString, destination: destination)
        .progress { bytesRead, totalBytesRead, totalBytesExpectedToRead in
            //print(totalBytesRead)

            // This closure is NOT called on the main queue for performance
            // reasons. To update your ui, dispatch to the main queue.
            dispatch_async(dispatch_get_main_queue()) {
                print("Total bytes read on main queue: \(totalBytesRead) / \(totalBytesExpectedToRead)")
            }
        }
        .response { _, _, _, error in
            if let error = error {
                print("Failed with error: \(error)")
            } else {
                print("Downloaded file successfully")
            }
    }
}
```

Failed with error: Error Domain=NSCocoaErrorDomain Code=516 "‚ÄúCFNetworkDownload_gVZNJr.tmp‚Äù couldn‚Äôt be moved to ‚ÄúDocuments‚Äù because an item with the same name already exists." UserInfo={NSSourceFilePathErrorKey=/Users/macbook_pro/Library/Developer/CoreSimulator/Devices/41698325-FC7D-40FD-B6BA-4E5651736E49/data/Containers/Data/Application/2735D05C-AAB4-4777-BDBA-5BE8125F7C49/tmp/CFNetworkDownload_gVZNJr.tmp,
 Thank you for your answer
How can I delete it ? I don't get it, I don't have the name of the file...
 @xero88 you can do something like this..

```
let url = NSUrl(string: "...")
if NSFileManager.defaultManager().fileExistsAtPath(url.path!) {
    try! NSFileManager.defaultManager().removeItemAtURL(url)
}
```
 @katunch thank you for your answer

but suggestedDownloadDestination return a typealias : 

public typealias DownloadFileDestination = (NSURL, NSHTTPURLResponse) -> NSURL

How can I cast it to NSURL ?

I get error :

'DownloadFileDestination' (aka '(NSURL, NSHTTPURLResponse) -> NSURL') to unrelated type 'NSURL' always fails
        let url = destination as? NSURL
 I did it this way, because i know the filename already. 

```
let destination: (NSURL, NSHTTPURLResponse) -> (NSURL) = {
    (temporaryUrl, response)  in
    if response.statusCode == 200 {
        if NSFileManager.defaultManager().fileExistsAtPath(ProfitApp.JsonUrl.path!) {
            try! NSFileManager.defaultManager().removeItemAtURL(ProfitApp.JsonUrl)
        }
        return ProfitApp.DocumentDirectoryUrl.URLByAppendingPathComponent(ProfitApp.JsonFileName)
    }
    else {
        return temporaryUrl
    }
}
```

Here the definitions: 

```
struct ProfitApp {
    static let DocumentDirectoryUrl = NSURL(fileURLWithPath: NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true).first!)
    static let JsonFileName = "profitdata-2.json"
    static let JsonUrl = ProfitApp.DocumentDirectoryUrl.URLByAppendingPathComponent(ProfitApp.JsonFileName)
}
```
 @katunch Thank you for your help, it's work =)
  Hey guys...

Well, I making a GET request for my domain http://mydomain.com/api/v1/angles/3 using HTTPPie/curl and everthing works fine.

But when I try make the same request with Alamofire I always receive 404! That is my code:

``` swift
let headers = [
            "Authorization": "mytoken" // its just a plane token
        ]
        Alamofire.request(.GET, "http://mydomain.com/api/v1/angles/3", headers: headers)
            .responseJSON { response in
                print(response.request)  // original URL request
                print(response.response) // URL response always return status code 404

        }
```

When I add a slash in my URL the request return 401, but I certify any times, my token is correct :(

``` swift
let headers = [
            "Authorization": "mytoken" // its just a plane token
        ]
        Alamofire.request(.GET, "http://mydomain.com/api/v1/angles/3/", headers: headers)
            .responseJSON { response in
                print(response.request)  // original URL request
                print(response.response) // URL response always return status code 401

        }
```

Someone know what happening? :(
  I've got a project where I need be able to change a boundary. Is there a reason to prohibit that ?
  usually crash here
![image](https://cloud.githubusercontent.com/assets/2311352/10479234/b4f93d7a-7295-11e5-8a0e-e4109ce8401a.png)

using with Alamofire-SwiftyJSON
![image](https://cloud.githubusercontent.com/assets/2311352/10479271/e7fa778e-7295-11e5-8191-5e8f5eb41204.png)

anyone help? Alamofire (3.0.0)
 warp in here

![image](https://cloud.githubusercontent.com/assets/2311352/10503704/57136910-732b-11e5-91ea-0f2f2151e1d4.png)

![image](https://cloud.githubusercontent.com/assets/2311352/10503664/d13ea700-732a-11e5-9c10-78ab7f049e59.png)

usage 

![image](https://cloud.githubusercontent.com/assets/2311352/10503695/3c1e8612-732b-11e5-9121-137aba5b47ac.png)
 It isn't crash every time, just like other normal code.
But it just crash sometime I launch my app....
  Config: Alamofire 3.0 (tvOS branch) :
- 6 out of 8 upload methods return Alamofire.Request (so far so good)
- 2 out of 8 upload methods (the 2 multipart variants) return nothing, making it impossible to chain with .validate(), .response(), etc‚Ä¶ There is no semantic reason that I can see to do so, if there it should probably be documented so as to avoid confusion.
 Indeed, I misread it. Thanks your help !
  Why am i getting error:

```
'(_, _, _) -> Void' is not convertible to 'Response<AnyObject, NSError> -> Void'
```

on this code:

```
Alamofire.request(.GET, Config().apiTableGroup, headers: Config().apiHeaders)
        .responseJSON { request, response, result in // here
}
```
 In the Alamofire v 3.0 they updated the API to have a closure with a response object, see the README here: https://github.com/Alamofire/Alamofire#response-handling .

These questions would be great for StackOverflow, as the people who answers can get points for answering. Issues on github is more for feature requests and bugs in the framework.
 Thanks @cristeahub.
  For example if i have a rest service like this,

http://somehost.com/getFeed/{feedID}

And if i need to send a parameter feedID embedded in the url how to send it without manually attaching it to the url string ?

In Android libraries like retrofit support this feature out of the box, we dont have to do the manual string manipulation
  This is a follow-up to #100 
Whenever I create requests periodically, the memory usage will steadily increase over time. I have created a simple Xcode that shows the behavior: https://www.dropbox.com/s/akropg4xsyswg21/AlamofireTest.zip?dl=0

I have the following code in AppDelegate.swift

```
while true {
        Alamofire.request(.GET, "http://127.0.0.1")
        usleep(100000)
}
```

And here is the memory-consumption over time (2 min):

![skaermbillede 2015-10-13 kl 11 19 40](https://cloud.githubusercontent.com/assets/2315801/10450719/72566e60-719c-11e5-8278-dd9dca42c0fa.png)

Disclaimer: I'm new to Swift and first time using Alamofire, so it might just be that I'm using it wrong :)
 Hi @kylef 

Thank you very much for your example! It got it to work.

I did use another thread in my own application, however I must have been using it wrong (as I said, first time working with Swift so lots of new stuff to me). 
And the frequency of which new requests were sent was just set to a high amount to emphasize the increase in memory consumption :) 
  My project uses CoreData so Xcode generated a 

```
lazy var persistentStoreCoordinator: NSPersistentStoreCoordinator 
```

in the AppDelegate.swift. Inside its definition, there is a line: 

```
dict[NSUnderlyingErrorKey] = error as NSError.
```

In the completionHandler of a call to responseJSON, I try to determine if the error is a NSURLError.NotConnectedToInternet by doing:

```
if let err = result.error as? NSURLError where err == .NotConnectedToInternet {
             return "Cannot connect to the internet";
}
```

That works fine in Alamofire 2.0.2.

But after updating to 3.0 and changing my code to:

```
if let err = response.result.error as? NSURLError where err == .NotConnectedToInternet {
             return "Cannot connect to the internet";
}
```

the line in AppDelegate.swift mentioned above gives: 'ErrorType' is not convertiable fo 'NSError'; error.
  I use Alamofire-beta3, I want to custom response serialization, but I get a error "Cannot call value of non-function type 'NSHTTPURLResponse?' "

![image](https://cloud.githubusercontent.com/assets/7556575/10444657/b0d691fc-719b-11e5-878e-bdd46d03be3b.png)

My code is below:

```
 public static func objectSerializer <T: MTLModel> () -> ResponseSerializer <T, MTLError>  {

    return ResponseSerializer <T, MTLError> { request, response, data, error in

        // Http Error with Http status code
        guard error == nil else {
            let failureReason = "Network Error"
            let error = MTLError.errorWithCode(error!.code, failureReason: failureReason)
            return .Failure(error)
        }

        // data be null
        guard let validData = data where validData.length > 0 else {
            let failureReason = "JSON could not be serialized. Response data was nil or zero length."
            let error = MTLError.errorWithCode(.ResponseDataNull, failureReason: failureReason)
            return .Failure(error)
        }

        do {
            let JSON = try NSJSONSerialization.JSONObjectWithData(validData, options: .AllowFragments)

            // response data is not a obejct json
            guard let json = JSON as? [String : AnyObject] else {
                let failureReason = "JSON could not be serialized. Response data is not a obejct JSON"
                let error = MTLError.errorWithCode(.JSONSerializeToObjectFailed, failureReason: failureReason)
                return .Failure(error)
            }

            // Http request successful(state 200 OK), but response data not include `Error Section`
            guard let errorDict = json["error"] as? [String : AnyObject] else {
                let failureReason = "JSON could not be serialized. Http request successful(state 200 OK), but response data not include `Error Section`"
                let error = MTLError.errorWithCode(.JSONSerializeErrorSectionFailed, failureReason: failureReason)
                return .Failure(error)
            }

            // mean request failed
            if errorDict.count != 0 {

                let error: MTLError!
                do {
                    error = try MTLJSONAdapter.modelOfClass(MTLError.self, fromJSONDictionary: errorDict) as! MTLError
                } catch _ {
                    let failureReason = "MTLError object serialize failed"
                    error = MTLError.errorWithCode(.JSONSerializationFailed, failureReason: failureReason)
                }
                return .Failure(error)

            } else {
                // mean request successful
                let dataDict = json["data"] as? [String : AnyObject]

                do {
                    let object = try MTLJSONAdapter.modelOfClass(T.self, fromJSONDictionary: dataDict) as! T
                    return .Success(object)
                } catch _ {
                    let failureReason = "\(T.self) object serialize failed"
                    let error = MTLError.errorWithCode(.JSONSerializationFailed, failureReason: failureReason)
                    return .Failure(error)
                }
            }

        } catch _ {
            let failureReason = "Network Error"
            let error = MTLError.errorWithCode(error!.code, failureReason: failureReason)
            return .Failure(error)
        }

    }
}


  public func responseObject<T: MTLModel> (queue: dispatch_queue_t? = nil, willStart: (() -> Void)? = nil, didStop: (() -> Void)? = nil, completionHandler: Response<T, NSError> -> Void) -> Self
{
    willStart?()
    UIApplication.sharedApplication().networkActivityIndicatorVisible = true

    return response(responseSerializer: Request.objectSerializer(), completionHandler: { (response: Response<T, NSError>) in

        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), { () -> Void in

            self.printResponse(response)

            dispatch_async(queue ?? dispatch_get_main_queue()) {
                didStop?()
                UIApplication.sharedApplication().networkActivityIndicatorVisible = false
                completionHandler(response)
            }

        })
    })
}
```

I have see #817 , but I  still don't know how to change my code. Please help me.
 Now I have updated to the release version of Alamofire 3, but still build error.
the response serializer `public static func objectSerializer<T: MTLModel>() -> ResponseSerializer<T, MTLError>`  return the types `<T, MTLError>`
The code above no return the types of the value and error ?
  I am uploading a file to a server which responds, occasionally, with an error 500. The problem is that the result is marked as a success and this confuses my client code something fierce. Here's an example of the problem:

```
     let endpointUrl = NSURL("http://aserver.com/somepath/uploadImageEndpoint")

    let cachePolicy = NSURLRequestCachePolicy.ReloadIgnoringLocalCacheData

    let request = NSMutableURLRequest(URL: endpointUrl!, cachePolicy: cachePolicy, timeoutInterval: 60.0)
    request.HTTPMethod = "POST"

    // set credentials
    let userCredentials = UserCredentials()
    let base64EncodedCredentials = userCredentials.base64EncodedCredentials()
    request.setValue("Basic \(base64EncodedCredentials)", forHTTPHeaderField: "Authorization")

    // set boundary
    let boundary = "NET-POST-boundary-\(arc4random())-\(arc4random())"
    request.setValue("multipart/form-data;boundary="+boundary,
        forHTTPHeaderField: "Content-Type")

    // create request parameters
    let parameters = NSMutableData()
    for s in ["\r\n--\(boundary)\r\n",
        "Content-Disposition: form-data; filename=\"userimage.png\"\r\n",
        "Content-Type: image/png\r\n\r\n"] {
            parameters.appendData(s.dataUsingEncoding(NSUTF8StringEncoding)!)
    }
    parameters.appendData(UIImagePNGRepresentation(image)!)
    parameters.appendData("\r\n--\(boundary)--\r\n"
        .dataUsingEncoding(NSUTF8StringEncoding)!)

    upload(request, data: parameters).responseData() { (_, response, result) in
        if(response?.statusCode == 500) {
            NSLog("@@@@@@@@@@@@@@@ Received 500")
        }
        if(result.isSuccess) {
            NSLog("@@@@@@@@@@@@@@@ result is success")
        }
        if(result.isFailure) {
            NSLog("@@@@@@@@@@@@@@@ result is failure")
        }
        switch result {
            case .Success(_):
                successHandler()
            case .Failure(_, let error):
                let nsError = error as NSError
                errorHandler(nsError)
        }
    }
```

This will output:

@@@@@@@@@@@@@@@ Received 500
@@@@@@@@@@@@@@@ result is success

I don't believe this an intuitive result. The result should be a failure if the server returns a 500.

This issue was encountered in XCode 7.0.1 running an iPhone 6 simulator which is simulating iOS 9.0.1
 Thank you Jon, great response! 
  When the body of the response is empty, the functions "xxxResponseSerializer" returns a .Failure.

```
guard let validData = data where validData.length > 0 else {
                let failureReason = "JSON could not be serialized. Input data was nil or zero length."
                let error = Error.errorWithCode(.JSONSerializationFailed, failureReason: failureReason)
                return .Failure(error)
            }
```

In certain cases (e.g.: 204 responses - no content) a body must not be included. These functions shouldn't return .Failure only when validData is nil and not when his length is 0?
  helloÔºåI can get json in my simulator ,but I find a error on my iPhone 6p,

dyld`dyld_fatal_error:
->  0x120051088 <+0>: brk    #0x3

only this message,
  Hi,

I need to open a new session before every request. But Alamofire manager didn't. 

NSURLSessionConfiguration.defaultSessionConfiguration is enough for me.

Could you help?
  I want to configure requests with custom timeouts. But in the current Version of Alamofire I have problems using my custom Alomofire manager. All .download requests will be cancelled on client side.

But when I use the shared Manager, everything is working fine.

```
    let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()

    configuration.timeoutIntervalForResource = 30 
    configuration.timeoutIntervalForRequest = 30
    let manager = Alamofire.Manager(configuration: configuration)
```
 And how are you using your custom Alamofire manager now?
  How do I get statusCode in Alamofire 3.0.0?

responseJSON { response in
                if response.result.isSuccess {
                    let responseJSON = response.result.value

and this is not working:

response.result.value?.statusCode == 200

Thank you.
 Thank you very much, it solved even my other issue.
  The server is sending response code 404, but it looks like the framework is interpreting it as a success.

Code:

```
Alamofire.request(.GET, Constants.Path.rootUrl + "/api/users", parameters: ["username" : usernameString, "limit":3] , headers: ["tb-token" : userToken!])
            .responseJSON { response in


                print(response.request)  // original URL request
                print(response.response) // URL response
                print(response.data)     // server data
                print(response.result)   // result of response serialization


                let results = response.result

                if let JSON = response.result.value {

                    if response.result.isSuccess == true {
                        print("Success with JSON: \(JSON)")
                        self.tableView.hidden = false

                        self.resultsDict = results.value as! NSArray

                        let resultsNumber = results.value!.count

                        self.numberOfResults.text = "Results(\(resultsNumber))"
                        self.numberOfResults.hidden = false

                        self.resultsN = resultsNumber
                        self.loadedMode = true


                        self.tableView.reloadData()
                        self.tableView.hidden = false
                    }
                }
                    else {print("error")}

        }
```

isSuccess is always true, whatever code the server is sending back.
 Thank you, worked like a charm!
 Thank you it, worked. Using `.validate()` the response is validated.
But there is another problem, using `.validate()` I dont get the response value: `response.result.value`.
Is there any solution, or workaround?
Thanks
  Hello,
Alamofire has been working great for the standard iOS activity, yet in widget I get "module 'Alamofire' has no member named 'request'.

here's the code:

``` swift
//
//  TodayViewController.swift
//  widget
//
//  Created by Luke Geelen on 10-10-15.
//  Copyright ¬© 2015 Luke Geelen. All rights reserved.
//

import UIKit
import NotificationCenter
import Alamofire

class TodayViewController: UIViewController, NCWidgetProviding {

    @IBOutlet weak var temp: UILabel!

    override func viewDidLoad() {
        super.viewDidLoad()

        Alamofire.request(.GET, "http://httpbin.org/get")
            .responseString { _, _, result in
                print("Success: \(result.isSuccess)")
                print("Response String: \(result.value)")
        }
    }

    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }

    func widgetPerformUpdateWithCompletionHandler(completionHandler: ((NCUpdateResult) -> Void)) {
        // Perform any setup necessary in order to update the view.

        // If an error is encountered, use NCUpdateResult.Failed
        // If there's no update required, use NCUpdateResult.NoData
        // If there's an update, use NCUpdateResult.NewData

        completionHandler(NCUpdateResult.NewData)
    }

}
```
  This code work before migrate to Swift 2.0 and Alamofire 2.0

``` swift
manager.upload(requestMethod, NSURL(string: url)!, multipartFormData: { multipartFormData in
    for param in params {
        multipartFormData.appendBodyPart(data: param.1.dataUsingEncoding(NSUTF8StringEncoding)!, name: param.0)
    }

    multipartFormData.appendBodyPart(data: imageData!, name: "file", fileName: "tempImage", mimeType: "image/*") },
    encodingCompletion: { encodingResult in
        switch encodingResult {
        case .Success(let upload, _, _):
            upload.responseJSON { _, response, result in
                switch result {
                case .Success(let data):
                    ...
                case .Failure(let encodingError):
                    ...
                }
            }
        case .Failure(let encodingError):
            ...
        }
} )
```

Now the line:

upload.responseJson...
always return fail: 

FAILURE: Error Domain=NSURLErrorDomain Code=-999 "cancelled" UserInfo={NSErrorFailingURLKey=https://www.myurl/posts, NSLocalizedDescription=cancelled, NSErrorFailingURLStringKey=https://www.myurl/posts}

I cant find where is the problem

PD: I have the same problem with Alamofire 3.0
 Hi @cnoon,
Yes, you're right, it was not my intention. But I have opened a question in Stack Overflow two weeks ago without a comment yet.
http://stackoverflow.com/questions/32765558/alamofire-2-0-multipart-form-data-error

As I said, before update everything was working perfectly.
  It would be great if the pod worked for tvOS! :)

`Target 'Pods' of project 'Pods' was rejected as an implicit dependency for 'Pods.framework' because it doesn't contain platform 'appletvsimulator' in its SUPPORTED_PLATFORMS 'iphonesimulator, phones'`
 check out the tvOS branch. 
 Specifically you can do this:

`pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'tvOS'`

You'll also need to be on the beta version of Cocoapods:

`sudo gem install cocoapods --pre`
 Amazing! Thank you! Would never have figured that out. :100: 
 Unfortunately i cannot fix the "doesn't contain platform appletvsimulator" warning. Updated to cocoapod 0.39.0.rc.1 and used the tvos branch. Does somebody have an idea why this still doesn't work for me?
 Did you enter platform as "tvos" in your podfile?
 Also make sure the other pods support tvos
 Ah, yes, thanks! I set platform to ios because i tried to include my AppleTV target into an existing iOS project (iOS 8.0+). I'm new to Cocoapods, is it possible to set different platforms to targets in the podfile / use different versions of Alamofire for different targets since the tvos branch is for 9.0+?

--> https://github.com/CocoaPods/CocoaPods/issues/4256
 That's a good question, I don't know the answer to it though.
 I asked that question because I got an iOS 9.0 required error when I tried to build my iOS (!) app for 8.0. But after deleting and re-adding the ATV (!) target, everything works fine... Strange, but anyway, here is my Podfile:

```
platform :ios, '8.0'
use_frameworks!

target 'iOS' do
    #pod 'Alamofire', '~> 3.0.0-beta.3'
    pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'tvOS'
end

target 'TodayWidget' do
    #pod 'Alamofire', '~> 3.0.0-beta.3'
    pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'tvOS'
end

target 'ATV' do
    platform :tvos, '9.0'
    #pod 'Alamofire', '~> 3.0.0-beta.3'
    pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'tvOS'
end
```

Thanks for your help!
 I got below error when i used    pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'tvOS'

[!] Error installing Alamofire
[!] /usr/bin/git clone https://github.com/Alamofire/Alamofire.git /var/folders/fg/ptwwhtkx4b35jgtww76g7l100000gp/T/d20161111-18710-18t7b4y --template= --single-branch --depth 1 --branch tvOS

Cloning into '/var/folders/fg/ptwwhtkx4b35jgtww76g7l100000gp/T/d20161111-18710-18t7b4y'...
warning: Could not find remote branch tvOS to clone.
fatal: Remote branch tvOS not found in upstream origin

I am usong  ' AlamofireObjectMapper' too ,is it compatible with tvos alamofire version?
please guide me.
  I felt the description and instructions for _Carthage_ weren't accurate.
- reworded the introduction to _Carthage_ to be closer to how it describes itself.
- added project integration step instruction for _Carthage_ based on its documentation.
  Sorry if is in wrong place, but i can't install alamofire using cocoa pods, i still using 1.3.1 version, but when i trie install always come with error :

[!] Unable to satisfy the following requirements:
- `Alamofire (= 1.3.1)` required by `Podfile`

This is my podfile:

```
source 'https://github.com/CocoaPods/Specs.git'

platform :ios, '7.0'
# use_frameworks!

target 'AppName' do
    pod 'Alamofire', '1.3.1'
end
```

I Really appreciate any help, again, sorry if is in wrong place
 Tnk for help, unfortunately i will need insert lib manually so :+1: 
  If I made a PR that added the ability to add a logger to `Manager` that conformed to `OutputStreamType` which would log requests and responses, would that be something anyone else would want? 
@cnoon Would this have a place within `Alamofire`? 
 That make sense. Logging may just be too subjective to integrate. I may consider open sourcing an external logging library for `Alamofire` sometime in the near future, but I understand why it doesn't make sense to include in the core library.

Thanks
 @cnoon could you please elaborate on Request debugging features? I need to somehow debug what is going on with my requests - if URL is correctly built, correct parameters are passed and required headers are set and returned back from the server
 For those who are looking for a solution similar to AFNetworkActivityLogger, there is AlamofireNetworkActivityLogger framework: https://github.com/konkab/AlamofireNetworkActivityLogger

Works exactly the same as AFNetworkActivityLogger.
  I'm glad we made the switch to using the generic `ErrorType` for `Result`, but I'm confused why we aren't  using the same generic `ErrorType` in `ValidationResult`. I'd really like to pass my own custom errors into validation.

Is there a reason why we can't/shouldn't be doing this?
 Got it. That makes perfect sense. Thanks for the quick reply @cnoon. I guess I'll just make my validation errors `NSError`s.
  The old version of Alamofire (pre 2.0) used to handle responses that included 0 bytes, and return a success. This can happen if the server returns a 204 response

The new version doesn't do this check and attempts to convert the NSData with 0 bytes to json which results in an exception and triggers the completion with an Failure result.

I tried writing a custom serializer that handles that, the problem is Result.Success needs to have a non nil value. How do you suggest going about 204 responses?

```
if validData.length > 0 {
    do {
        let JSON = try NSJSONSerialization.JSONObjectWithData(validData, options: options)
        return .Success(JSON)
    } catch {
        return .Failure(data, error as NSError)
    }
}
else {
    return .Success()
}
```
 Hi, I'd be interested by the way you worked around this, cheers!
 I ended up using `response` instead of `responseJson` and manually parse data to json
   From the ReadMe: 

```
Alamofire.download(.GET, "http://httpbin.org/stream/100", destination: destination)
         .progress { bytesRead, totalBytesRead, totalBytesExpectedToRead in
             print(totalBytesRead)

             // This closure is NOT called on the main queue for performance
             // reasons. To update your ui, dispatch to the main queue.
             dispatch_async(dispatch_get_main_queue()) {
                 print("Total bytes read on main queue: \(totalBytesRead)")
             }
         }
         .response { _, _, _, error in
             if let error = error {
                 print("Failed with error: \(error)")
             } else {
                 print("Downloaded file successfully")
             }
         }
```

The `.response` block will be called after the download is finished.

For the future, the Github Issues should be used for reporting suspected bugs or suggesting changes to the repository.

Specific usage questions and advice is better suited for www.stackoverflow.com. I'd suggest you post this question there. Be sure to tag your question with Alamofire.

Thanks
  Some of the code samples in the ReadMe don't work in xCode
 Hi @cnoon, sorry about not being specific. I was trying to use this code in xCode 7, but it throws errors:

``` swift
        Alamofire.request(.GET, "http://httpbin.org/get", parameters: ["foo": "bar"])
            .responseJSON { response in
                print(response.request)  // original URL request
                print(response.response) // URL response
                print(response.data)     // server data
                print(response.result)   // result of response serialization

                if let JSON = response.result.value {
                    print("JSON: \(JSON)")
                }
        }
```

<img width="1010" alt="screen shot 2015-10-04 at 5 42 19 pm" src="https://cloud.githubusercontent.com/assets/5099084/10270436/4d9edc1c-6abf-11e5-95f5-30bc6a434800.png">

I ended up getting it to work by doing something like this: http://stackoverflow.com/questions/32506703/alamofire-not-working-properly-tuple-issue-different-number-of-elements
 @thomasbaldwin you are using an old version of alamofire. Update your alamofire and the examples in the documentation should work fine.
 @cristeahub I'm using cocoapods and using version 2.0.2 and still getting the error. What version do you suggest I use?

```
platform :ios, '8.0'
use_frameworks!

target 'apollo' do
    pod 'PureLayout', '~> 3.0.1'
    pod 'SwiftyJSON', '~> 2.3.0'
    pod 'KMPlaceholderTextView', '~> 1.0.0'
    pod 'Alamofire', '~> 2.0.2'
end
```
 Ah ok. I just blindly installed it by copying the pod from the master readme to my podfile which was set for version 2.0. Thanks for the help @jshier :+1: 
 The readme still has reference to the install being a 2.0.x install along with the 3.0.0 examples.  FYI

![screenshot 2015-10-05 13 03 49](https://cloud.githubusercontent.com/assets/15181/10290547/080aecd8-6b62-11e5-94c6-7b19bac4413d.png)
  I am getting this error and no idea why. I have tried with bitcode both on and off, and went down from v3.0 beta 3 to version 2 just to see if that would help. This only happened after i started use xcode 7. I already converted project to swift 2.0 as well, app works fine when i install it from xcode. I use carthage to build build the framework. Any help would be greatly appreciated, as i was supposed to pass along a build and i have been very delayed because of it. Here is the full error:

Failed to verify bitcode in Alamofire.framework/Alamofire:
error: Bundle only contains bitcode-marker /var/folders/r3/j_762c094837jhnv929gq1mw0000gn/T/XCodeDistPipeline.TvV/Root/Payload/my.app/Frameworks/Alamofire.framework/Alamofire (armv7)

bitcode stripping fails as well.
 I never said the issue was compiling, it was with creating an adhoc dstribution. I found this about the issue:

A framework with bitcode enabled requires the following flag to create and fill the bitcode section, -fembed-bitcode. However, this flag is available only in archive builds, not in normal builds where it's used the flag -fembed-bitcode-marker which creates a bitcode section but has a size of 1.

Carthage doesn't use archive action to build frameworks which means the resulting framework will contain a bitcode section but not properly filled as expected, leading to some issues in the submission of apps to TestFlight for example.

it is from https://github.com/thoughtbot/Argo/pull/260
 A user-defined-setting of "BITCODE_GENERATION_MODE" set to "bitcode" is what is needed in the framework project before it will be able to work from a carthage compilation.
 I have actually already tested it myself with a test project where i had  manually added it into the checkout. I am manually adding it to all the other projects i have got downloaded from carthage and in the process of building it for my main project.  

If i want to test your latest change with the test project how can i do that with carthage? Do i use "head" in the cartfile?
 It works now.
 @cnoon please note that you don't need to set `BITCODE_GENERATION_MODE=bitcode` to both release and debug configurations, only release configurations requires this for posterior submission. For debug configurations you can simply set `BITCODE_GENERATION_MODE=marker`.
 :+1: 
  The latest version of Xcode doesn't include the Mac OS X 10.10 SDK. I extracted the 10.10 SDK from a previous version of Xcode and added it in my current Xcode.app in order to be able to compile for Yosemite.
I changed the "Base SDK" setting for my project, my target, and Alamofire's OS X target to use the 10.10 sdk (it's in the list, so I guess it's properly installed). I also set all Deployment Tagets to be 10.10.

When trying to compile, I get an error: `<unknown>:0: error: Swift does not support the SDK 'MacOSX10.10.sdk'` under the Alamofire OSX section of the errors sidebar.

Is there a way around that?
  Hi there, 

I can't install Alamofire 3.0 via CocoaPods.

[!] Unable to satisfy the following requirements:
- `Alamofire (~> 3.0)` required by `Podfile`

Thanks in advance!

Regards,
Diego
 Great! Thanks @jshier :)
 Is this something that is going to be updated on cocopods soon? I would probably change the README if it isn't...
 Awesome! Thanks for that. Is the 3.x branch considered stable since its still in rc? What should be used for production apps?
 This is great news, I always feel a little uneasy releasing things into the wild with a `-beta` tag in my podfile! :tada: :balloon: 
 Very nice! Thanks for an awesome library!
  like CocoaAsyncSocket
tcp udp
 Elegant HTTP Networking in Swift
  I'm downloading a file to a custom file path like this:

```
let tempFilePath = self.makeTempFilePath()
Alamofire.download(.GET, downloadURL) { temporaryURL, response in
    return tempFilePath
}
```

How do I know when the download is complete and the success/failure status? I tried `responseData` closure but `result` parameter always appears as "failure". The `response.statusCode` in `responseData` should indicate the status or does 200 status code only indicate that the download started normally some time ago?
  ``` js
[
  {
     "aa": 123,
     "bb": 234
  }
]
```

Could I send a POST Request with this body ?

I want to send [ [String:AnyObject] ].
Thanks
  Excuse my ignorance as I'm pretty new to this lib as well as Swift, but been playing with Alamofire and consulting stackoverflow, it seems like the cb passed to `.responseJSON` takes 3 args. 

Feel free to close this PR if this is incorrect. 
  This code is in Request.swift, and not checking iOS availability
Compiler wants to ass `#available(iOS 8.0, *)`

`if #available(OSX 10.10, *) {
   operationQueue.qualityOfService = NSQualityOfService.Utility
}`
 You would only see that error if you're trying to build with iOS 7 as a minimum deployment target, which Alamofire > 2.0 no longer supports. Of course, it's easy to modify yourself but I'm afraid you'd have to maintain your own fork or set of modifications.
 cool thanks for the quick response
  It isn't need to check for document path in Swift 2.0
  Spelling fix
  Hello, I just have updated my system to iOS9 and so I am having Xcode 7.0 and swift2.0. I have cloned Alamofire2.0 with my project but I am facing the problems shown in the image. 
I have gone through stackoverflow questions but did not get any solutions.
Any help would be apperiated!

![alamofirebug](https://cloud.githubusercontent.com/assets/14276252/10192574/f33871c4-679a-11e5-9a15-0f247f31bed6.PNG)
 I am facing the same issue, but the version I am using is the 2.0.2.
 @irealme @DanielyBotelho How are both of you installing Alamofire?
 @jshier I have installed Alamofire by cloning this git into my project using terminal
 @cnoon If I am installing the alamofire by cloning the git, that means it is version 3.0 betas? Do you mean I should install using pod file? Correct me If I am wrong
  Hi, I use POSTMAN statusCode = 204 but I use this library response.result handle to case .Failure.
# example respond from POSTMAN <h2>

![screen shot 2015-09-30 at 18 23 48](https://cloud.githubusercontent.com/assets/14090510/10191769/37bcccd6-67a1-11e5-9cbd-d8e3d9e3578c.png)
# example respond from library <h2>

![screen shot 2015-09-30 at 18 33 46](https://cloud.githubusercontent.com/assets/14090510/10191837/e932a6e8-67a1-11e5-9405-670a0b3feed5.png)
 What do you expect when you try to serialize something to JSON that is not JSON?
  I get this error when I try to validate my app using Alamofire version 2.0.2

`Couldn't find platform family in Info.plist CFBundleSupportedPlatforms or Mach-O LC_VERSION_MIN for Alamofire`

I'm not sure whether the problem is on my side or Alamofire's, thus this issue.
 @cnoon I don't think it was an issue with Alamofire actually. Alamofire was just the first framework in the list. I don't remember what I did, but it suddently workes. 

E: Changing deployment target to iOS 9.0, removing .dSYM files from the target was what I did
 I was getting the same error too.. It all worked once.. hahahaha now it's back to not working. I don't think it's Alamofire either, but since this is one of the top hits for the error message on google I thought I would add a voice to thread.  I am using Carthage, and I was adding dSYM files. So I think the dSYM files may be part of it.

... later ...

No more dSYM files.. same error 

```
Couldn't find platform family in Info.plist CFBundleSupportedPlatforms or Mach-O LC_VERSION_MIN for Alamofire
```

Assuming like above it's because Alamofire is the 1st framework in the list.

... later still ...
yup, I accidently had some other dSYM files in my resource bundle. That was it. Building for iOS 8 as well, didn't have to set iOS 9
 I've been having this same issue for several weeks now.

Couldn't find platform family in Info.plist CFBundleSupportedPlatforms or Mach-O LC_VERSION_MIN for audio_sdl2.so.o

I was wondering where you find the dSYM files to delete them? I'm using Xcode 7
 Look in your "Copy Bundle Resources" build phase. 
 I was able to get the app to validate by deleting ...dist/root/python/lib folder from Copy Bundle Resources but when I do so the app crashes on startup. I am assuming that the dSYM files I need to remove are somewhere buried in this folder, but I don't see anything in that folder or any of its repositories with dsym in the name or filetype. What exactly should I be looking for?
 Hey Saundc2, I had a similar issue. Have you found a solution?

Here is my error:

Couldn't find platform family in info.plist CFBundleSupportedPlatforms or Mach-OLC_VERSION_MIN for htmlTexture.bundle

I am building an app with Unity 5.2.2f1, Xcode 7.1.1, Vuforia 5, OS 10.11. 

please email me and maybe we can find a solution together. 
lucidlabtechnology@gmail.com
 My problem was that when I installed toolchain.py it did not work with kivy and Xcode 7. There is a newer version of toolchain.py that fixes this issue. I had to reinstall toolchain.py and rebuild kivy and its dependencies. You will loose all of your settings in info.plist unless you back up your files or create a new project with a different name or filepath. I was able to upload to iTunes connect after this fix
 Hey, thanks for the email. 

After solution, You didn‚Äôt have any more crash issues at launch?

Marcin Teodoru
Founder
Lucid Lab Technology
818.430.9202
skype: vdubskivr6

> On Nov 11, 2015, at 8:24 PM, saundc2 notifications@github.com wrote:
> 
> My problem was that when I installed toolchain.py it did not work with kivy and Xcode 7. There is a newer version of toolchain.py that fixes this issue. I had to reinstall toolchain.py and rebuild kivy and its dependencies. You will loose all of your settings in info.plist unless you back up your files or create a new project with a different name or filepath. I was able to upload to iTunes connect after this fix
> 
> ‚Äî
> Reply to this email directly or view it on GitHub https://github.com/Alamofire/Alamofire/issues/823#issuecomment-155994182.
 When you reinstall toolchain and rebuild kivy, Python, OpenSSL, etc, the dist/root/python/lib folder should be back in your Bundle Resource build phase. This is needed or else your app won't be able to use Python (which is why my app wouldn't run when I deleted this folder). 
 This references toolchain's compatability with Xcode 7
https://github.com/kivy/kivy-ios/pull/165
This is where I cloned the new version of toolchain
https://github.com/jadeblaquiere/kivy-ios
I also needed to install Xcode 7 command line tools from
developer.apple.com/downloads/
  Hi,

I'm doing the migration of my app on Swift 2.0. I took the opportunity to also migrate Alamofire from 1.3 to 2.0.

But now my app is not working anymore, and i got many errors on the file where i use Alamofire.

First on my enum Router declaration i got an error who say
 `private enum Router: URLRequestConvertible {`

> Type 'Router' does not conform to protocol 'URLRequestConvertible'

Second in all my request when i'm gonna check the `.responseJSON { (_, _, json, error) in`
i got an error who say

> Tuple types '(NSURLRequest?, NSHTTPURLResponse?, Result<AnyObject>)' (aka '(Optional<NSURLRequest>, Optional<NSHTTPURLResponse>, Result<AnyObject>)') and '(_, _, _, _)' have a different number of elements (3 vs. 4)
> Error that i didn't had before

Thanks for your help ! 
  After downloading and saving a file, memory is never released. Is it expected behaviour? What should I do to release it?

```
let url = "http://www.sample-videos.com/video/mp4/720/big_buck_bunny_720p_10mb.mp4"
let destination = Alamofire.Request.suggestedDownloadDestination(directory: .DocumentDirectory, domain: .UserDomainMask)
Alamofire.download(.GET, url, destination: destination)
```
 Simulator memory tracking is not accurate, checked on actual device and everything works great.
  Undefined symbols for architecture armv7:

"Alamofire.Request.(responseJSON (Alamofire.Request) -> (options : C.NSJSONReadingOptions, completionHandler : (ObjectiveC.NSURLRequest?, ObjectiveC.NSHTTPURLResponse?, Alamofire.Result) -> ()) -> Self).(default argument 0)", referenced from:

please help I am using 2.0.2 alamofire. 
  Hi,
   Currently I'm using Alamofire to do a https connection. The server's certificate is self-signed.
I got this error:

```
2015-09-28 18:20:58.950 alamofire-test[80162:2146829] NSURLSession/NSURLConnection HTTP load failed (kCFStreamErrorDomainSSL, -9813)
2015-09-28 18:20:58.953 alamofire-test[80162:2143698] json: (Optional(<NSMutableURLRequest: 0x79085cb0> { URL: https://www.anexamplehost.cn/api/register }), nil, FAILURE: Error Domain=NSURLErrorDomain Code=-1202 "The certificate for this server is invalid. You might be connecting to a server that is pretending to be ‚Äúwww.anexamplehost.cn‚Äù which could put your confidential information at risk." UserInfo={NSLocalizedDescription=The certificate for this server is invalid. You might be connecting to a server that is pretending to be ‚Äúwww.anexamplelhost.cn‚Äù which could put your confidential information at risk., NSLocalizedRecoverySuggestion=Would you like to connect to the server anyway?, _kCFStreamErrorDomainKey=3, NSUnderlyingError=0x79082ae0 {Error Domain=kCFErrorDomainCFNetwork Code=-1202 "(null)" UserInfo={_kCFStreamPropertySSLClientCertificateState=0, _kCFNetworkCFStreamSSLErrorOriginalValue=-9813, _kCFStreamErrorCodeKey=-9813, _kCFStreamErrorDomainKey=3, kCFStreamPropertySSLPeerTrust=<SecTrustRef: 0x78f75360>, kCFStreamPropertySSLPeerCertificates=<CFArray 0x794889f0 [0x98f098]>{type = immutable, count = 1, values = (
    0 : <cert(0x78f75220) s: Admin i: Admin>
)}}}, _kCFStreamErrorCodeKey=-9813, NSErrorFailingURLStringKey=https://www.anexamplehost.cn/api/register, NSErrorPeerCertificateChainKey=<CFArray 0x794889f0 [0x98f098]>{type = immutable, count = 1, values = (
    0 : <cert(0x78f75220) s: Admin i: Admin>
)}, NSErrorClientCertificateStateKey=0, NSURLErrorFailingURLPeerTrustErrorKey=<SecTrustRef: 0x78f75360>, NSErrorFailingURLKey=https://www.anexamplehost.cn/api/register} )
```

And this is the source code

```
class MyManager {
    static let sharedInstance = MyManager()

    let defaultManager: Alamofire.Manager = {
        let serverTrustPolicies: [String: ServerTrustPolicy] = [
            "anexamplehost.cn": .DisableEvaluation
        ]

        let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
        configuration.HTTPAdditionalHeaders = Alamofire.Manager.defaultHTTPHeaders

        return Alamofire.Manager(
            configuration: configuration,
            serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies)
        )
        }()
}

class NotificationProvider {
    static let registerURL = "https://anexamplehost.cn/api/register"
    static let authUserName = "admin"
    static let authPassword = "admin"


    func register(identity: String, _ device: String, _ token: String) {

        let params = ["identity": identity, "device": device, "device_type": UIDevice.currentDevice().systemName, "token":token ]
        let credential = NSURLCredential(user: NotificationProvider.authUserName, password: NotificationProvider.authPassword, persistence: .Permanent)
        MyManager.sharedInstance.defaultManager.request(.POST, NotificationProvider.registerURL, parameters: params, encoding: .JSON)
            .authenticate(usingCredential: credential)
            .responseJSON { response in
                NSLog("json: \(response)")
        }
    }
}
```

The server is using http authentication digest and it's working good when I use curl or in browser.
 version 2.0.2
 Thanks, it works now.
 @gensmusic what did you do exactly to get it to work?
 like what cnoon said, set www.anexamplehost.cn instead of anexamplehost.cn.

```
let serverTrustPolicies: [String: ServerTrustPolicy] = [
            "anexamplehost.cn": .DisableEvaluation
        ]
```

to

```
let serverTrustPolicies: [String: ServerTrustPolicy] = [
            "www.anexamplehost.cn": .DisableEvaluation
        ]
```
 @cnoon how about IP addresses?
 Here is a possible solution on how to accept invalid SSL Certificates in Alamofire. 

Add the following function in your AppDelegate class and call it in didFinishLaunching function:

```
func acceptInvalidSSLCerts() {
          let manager = Alamofire.Manager.sharedInstance
  print("trying to accept invalid certs")

          manager.delegate.sessionDidReceiveChallenge = { session, challenge in
              var disposition: NSURLSessionAuthChallengeDisposition = .PerformDefaultHandling
              var credential: NSURLCredential?

              print("received challenge")

              if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
                  disposition = NSURLSessionAuthChallengeDisposition.UseCredential
                  credential = NSURLCredential(forTrust: challenge.protectionSpace.serverTrust!)
              } else {
                  if challenge.previousFailureCount > 0 {
                      disposition = .CancelAuthenticationChallenge
                  } else {
                      credential = manager.session.configuration.URLCredentialStorage?.defaultCredentialForProtectionSpace(challenge.protectionSpace)

                      if credential != nil {
                          disposition = .UseCredential
                      }
                  }
              }

              return (disposition, credential)
          }
      }
```

Reference:-> [Accepting invalid SSL certificates in Alamofire](http://swiftforums.org/forum/alamofire/32-accept-invalid-ssl-certificates-in-alamofire)
 @tvich1 using your solution for loading a self-signed cert, only the first request goes through for me. subsequent requests get this error:

```
NSURLSession/NSURLConnection HTTP load failed (kCFStreamErrorDomainSSL, -9813)
```

Do you know why that might be the case?
  When I try to get data using Alamofire and when error thrown from the server. I can get the statusCode from the response but there is no way of getting the response body.
 In my situation when I make the request through Postman it returns me the result as "412 Validation Failed". According to this example status code 412. I wanna retrieve the message(Validation Failed). I jusr Alamofire 2.\* and the response is as  follows:

<NSHTTPURLResponse: 0x7f9f9b07e920> { URL: http://api.smartpricelk.com/api/Vehicle?vin=XXXXXXXXXXXXXX } { status code: 412, headers {\n    \"Cache-Control\" = \"no-cache\";\n    \"Content-Length\" = 28;\n    \"Content-Type\" = \"text/plain; charset=utf-8\";\n    Date = \"Thu, 24 Sep 2015 18:15:13 GMT\";\n    Expires = \"-1\";\n    Pragma = \"no-cache\";\n    Server = \"Microsoft-IIS/8.5\";\n    \"X-AspNet-Version\" = \"4.0.30319\";\n    \"X-Powered-By\" = \"ASP.NET\";\n} }

It returns nil in data. Any idea on this.
 Hi cnoon,

but it does not give the really important part like response string of server itself :) :(

[Request]: <NSMutableURLRequest: 0x7fd2a548f9f0> { URL: http://www.domain.dev/employee }
[Response]: <NSHTTPURLResponse: 0x7fd2a2e96e60> { URL: http://www.domain.dev/employee } { status code: 400, headers {
    "Access-Control-Allow-Origin" = "*";
    "Cache-Control" = "no-cache";
    "Content-Length" = 139;
    "Content-Type" = "application/json; charset=utf-8";
    Date = "Fri, 24 Jun 2016 15:35:32 GMT";
    Expires = 0;
    "Proxy-Connection" = Close;
    Server = Apache;
    "X-Powered-By" = "PHP/7.0.0";
    "X-Status-Code" = 400;
} }
[Data]: 139 bytes
[Result]: FAILURE: Error Domain=com.alamofire.error Code=-6003 "Response status code was unacceptable: 400" UserInfo={StatusCode=400, NSLocalizedFailureReason=Response status code was unacceptable: 400}
[Timeline]: Timeline: { "Request Start Time": 488475332.872, "Initial Response Time": 488475332.950, "Request Completed Time": 488475332.950, "Serialization Completed Time": 488475332.950, "Latency": 0.078 secs, "Request Duration": 0.078 secs, "Serialization Duration": 0.000 secs, "Total Duration": 0.078 secs }
FAILURE: Error Domain=com.alamofire.error Code=-6003 "Response status code was unacceptable: 400" UserInfo={StatusCode=400, NSLocalizedFailureReason=Response status code was unacceptable: 400}

What i need is the error object son string server returned me which contains the actual error code like:

"{error : {code: 101, message: "invalid email format"}}"

I think i need to convert response.data to utf8 string and than convert it to json. right?
 I am using SwiftyJSON for the moment, like : 

JSON.init(data: response.data)
 Why not change Result.swift to return the value in the Failure case?

I need to use .validate(statusCode: 200..<300) and my server return a json with error messages. I just can't use that, because I just don't have the value.

Now, I need to take off the .validade and handle the status code manually.

```
/// Returns the associated value if the result is a success, 'nil' otherwise.
    public var value: Value? {
        switch self {
        case .Success(let value):
            return value
        case .Failure:
            return nil
        }
    }
```
 https://github.com/Alamofire/Alamofire/issues/1431  Cannot get 3.0 to work with custom response serialization, because of error "Cannot call a value of non-function type 'NSHTTPURLResponse?'"
![2015-09-27 19-41-12 extensions swift](https://cloud.githubusercontent.com/assets/2377852/10124307/43d52a0a-6552-11e5-8fa1-709f6e6cca6b.png)
 Thanks man! Appreciate your work!
  I am using 3.0.0 beta 2, the issue that I am having is that, frequently, even though my server returned a status code that was not in the acceptable status code range, I would still like to access the JSON data in the response if it can be successfully serialized.

As far as I can tell, there are two ways to accomplish this. The first is to open up the status code validation range to include the status codes that contain JSON error information. 400 errors, for example, might have JSON that specifies what the client did wrong, so if don't validate 400 errors I can just check the JSON in the result's value. The problem here is that I have to now check `.isSuccess`, as well as the status code to determine if the request was successful, because `.isSuccess` no longer denotes that the request was actually successful.

The second way I could accomplish this would be to leave the status code range as is, but read in the data from the response, convert it to a String, and then parse the JSON directly. Unfortunately this means a lot of overhead for every error I want to handle.

Am I missing a more straightforward way of doing this? Would it be reasonable to make it so the result's value includes the parsed JSON if it can be serialized. This would mean that `Failure` wouldn't be synonymous with the result's value being `nil`, but that doesn't seem like it's necessarily a bad thing since in this case I want to access the value upon failure. 

Alternatively, a value field could be added to the Error struct, which looks like it wouldn't be a breaking change, and would keep `Failure` equivalent to the result's value being `nil`.
 That is an interesting idea, thanks for pointing that out. I didn't think of that at all!

It's not necessarily that I need different parsing schemes for success or different types of errors, I only need one parsing scheme, but I need the data for errors to come all the way back through deserialized somehow.

Just for other's who might come across this in the future, here's what that looks like for solving my problem.

```
extension Request {
    public static func APIJSONResponseSerializer() -> ResponseSerializer<AnyObject, NSError> {
        return ResponseSerializer { request, response, data, validationError in
            let result = JSONResponseSerializer().serializeResponse(request, response, data, nil)
            if let deserializationError = result.error {
                return .Failure(deserializationError)
            }
            if (validationError != nil) {
                let userInfo: [NSObject : AnyObject] = ["errorJSON": result.value!]
                return .Failure(NSError(domain: "<my-domain>", code: response!.statusCode, userInfo: userInfo))
            }
            return result
        }
    }

    public func responseAPIJSON(completionHandler: Response<AnyObject, NSError> -> Void) -> Self {
        return response(responseSerializer: Request.APIJSONResponseSerializer(), completionHandler: completionHandler)
    }
}
```

It still seems a bit awkward or heavy handed for something that might be a common use case, but thanks for the help!
 I have the same use case; in fact, I suspect this is the default use case and would be surprised to learn otherwise.
  So I did a bit of searching as what might be causing this issue (on the Github page and also SO) and for the life of me I cannot figure out why when trying to code sign even a freshly built project and even sample projects does the code sign helper fails when Alamofire is added to the project.  

I've tested a sample iOS project and code signed fine to run on my 6S but when adding in Alamofire and trying to run release mode again I keep encountering this error.  Any help of course would be greatly appreciated to see why this occurs when I add in the project (via cocoapods) to a current project.

![screen shot 2015-09-26 at 5 22 29 pm](https://cloud.githubusercontent.com/assets/795804/10119964/8e15b604-6474-11e5-84da-b2098466ec06.png)
  Hello! Is there any way to get the certificate information on SSL connections in Alamofire? Anything would be nice, the full chain or the server certificate or just a fingerprint.

Would like to keep track of the changed certificates, maybe even inform the user and ask for consent.
 Sounds like a plan, thank you!
  I am having trouble converting my project to Xcode 7 Beta related to the Alamofire 2.0 as shown on the screenshot below. Even created a test project with the following podfile:

source 'https://github.com/CocoaPods/Specs.git'
platform :ios, '8.0'
use_frameworks!

pod 'Alamofire', '~> 2.0'
I also reinstalled cocoapods. Still same problem. Anyone have some idea how to fix this?

![screen shot 2015-09-26 at 10 22 18 pm](https://cloud.githubusercontent.com/assets/6761377/10118019/b4c56ff4-649e-11e5-893c-5050c498177c.png)
  Importing MobileCoreServices for os=tvOS allows Alamofire to compile on tvOS
  Is there anyway we could validate that the returned http status code are not of a specific range but are of a specific set?

as in .validate(statusCode: 200, 400)?

Thank you,
 And that set should be able to contain ranges. Presumably.
 @jshier Yeah that would make sense.
 Yo thanks man.
  In Xcode 7, the base64EncodedStringWithOptions method no longer compiles with a nil argument. The comments associated with that method suggest: "Use zero or one of the following...". This pull request updates the documentation to pass a NSDataBase64EncodingOptions value of 0 to this method. I would love to see something that doesn't involve using rawValue, but this seems to be the best option at this time.
 @dfmuir Given that it's an `OptionSetType` under Swift 2, the proper way to set no options is to use `[]`, I believe.
 @jshier Thank you for pointing this out. I have added a new commit to the pull request to use the empty options OptionSet. I think this is the cleanest way to do it.
  Alamofire requests don't call their response handlers when running unit tests inside a UI test target (although the actual calls are made). NSURLSession calls perform fine.

To reproduce:

```
class TestUtilsTests: XCTestCase {

    func testNetworkCalls() {

        let url = NSURL(string: "https://httpbin.org/get")!

        // NSURLSession
        let nsURLSessionExpectation = expectationWithDescription("NSURLSession")
        let session = NSURLSession.sharedSession()
        let task = session.dataTaskWithURL(url, completionHandler: { (data, response, error) -> Void in
            nsURLSessionExpectation.fulfill()
        })
        task.resume()

        // Alamofire
        let alamofireExpectation = expectationWithDescription("Alamofire")
        Alamofire.request(.GET, url).responseData { (request, response, result) -> Void in
            alamofireExpectation.fulfill()
        }

        waitForExpectationsWithTimeout(10, handler: nil)
    }
}
```

Which gives:

```
    t =    10.27s     Assertion Failure: Asynchronous wait failed: Exceeded timeout of 10 seconds, with unfulfilled expectations: "Alamofire".
UITests/Tests.swift:32: error: -[AppUITests.Tests testNetworkCalls] : Asynchronous wait failed: Exceeded timeout of 10 seconds, with unfulfilled expectations: "Alamofire".
```

The NSURLSession expectation is correctly fulfilled, while the Alamofire one is not. Any idea what's happening here?
 After investigating a bit more, it seems that using another queue for the response handler works fine:

```
let networkResponseQueue = dispatch_queue_create("com.myapp.Tests", DISPATCH_QUEUE_CONCURRENT)
Alamofire.request(.GET, url, parameters: params)
    .response(queue: networkResponseQueue) { request, response, data, error in }
```

It might be because by default the handlers are performed on the main queue (UI queue), which is blocked by the UI tests. Couldn't find more information about how UI tests work with queues :(

Would it be appropriate for Alamofire to automatically detect UI tests and change the default queue accordingly?
 After even more investigation, it seems that `waitForExpectationsWithTimeout(10, handler: nil)` is the one that blocks the main thread, so the completion handlers can't be executed on the main thread. A workaround is described above. Pretty sure it is unrelated to Alamofire, so I'm closing this now.
  As per subject above, I am treating 401 as a success (long story short, I'm looking at the statusCode to decide if I need to renew my bearer token). 

Previously:
`Alamofire.request(MYRESOURCE).validate(statusCode: MYACCEPTABLESTATUSCODE).responseJSON{ (request, response, responseObject, error) -> Void in`

When HTTP 401 is encountered, error is nil. From there, I proceed to check the statusCode and what to do next. 

Currently:
`Alamofire.request(MYRESOURCE).validate(statusCode: MYACCEPTABLESTATUSCODE).responseJSON { (request, response, result) -> Void in`

When HTTP 401 is encountered, result is a failure. I would expect it to be a success, to mimic the previous scenario where error is nil. 
 Did a bit more research, found this: http://stackoverflow.com/q/32656703/351810

Taking cues from there, I tried 
`Alamofire.request(MYRESOURCE).responseJSON{ (request, response, result) -> Void in`
and 
`Alamofire.request(MYRESOURCE).validate(statusCode: 200...409).responseJSON{ (request, response, result) -> Void in`

Got .Failure for both instances when the server returns 401. 
 It appears that result was set to failure by the responseSerializer as the response I received not valid JSON (HTTP 401). 
  I tried to add custom header with this:

```
        let manager = Manager.sharedInstance
        manager.session.configuration.HTTPAdditionalHeaders = [
            "Authorization": "Token \(token)"
        ]
```

But it doesn't work, what am i doing wrong?
 The Github Issues should be used for reporting suspected bugs or suggesting changes to the repository.

Specific usage questions and advice is better suited for www.stackoverflow.com. I'd suggest you post this question there. Be sure to tag your question with `Alamofire`.

Please post the link to your stackOverflow question here and close this issue, and I'll look into the problem for you!

Thanks
 This seems to be a bug, headers are being dropped from the request in iOS 9.
 @f2m2rd All headers are being dropped in iOS9? If you believe that is the case, you should absolutely make a new issue for that. That seems like a pretty urgent bug to be fixed.
 See this issue: 
https://github.com/Alamofire/Alamofire/issues/798
 @f2m2rd That makes much more sense now. Thanks!
@mirzadelic It seems like the `Authorization` header is being stripped out by Apple. #798 should answer this for you, and it even includes a workaround for this.
  Hi.

I notice that encoding parameter <code>.JSON</code> is currently override the selected HTTP verb on the request.

https://github.com/Alamofire/Alamofire#post-request-with-json-encoded-parameters

I tried a "POST" request with <code>.JSON</code> as parameter encoding and my server logs me a "GET" request instead... Can you tell me why ?

EDIT : BTW, only <code>.URLEncodedInURL</code> keeps my request as POST, all others (even without specifying any encoding) turn my request to GET...

Thanks
  I think it would be very convenient if Alamofire supports directly uploading images from the assets library since a lot of people use the UIImagePicker.

Is there any hope that such a feature will be implemented soon?

And if not, what is the best and efficient workaround?

There isn't a lot around on this topic.
  I wasn't clear on how to use this properly but had seen other people doing this type of thing:

``` swift
func application(application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: () -> Void) {
    manager.backgroundCompletionHandler = completionHandler
}
```

In our similar implementation, at this point `completionHandler` is `partial apply forwarder for reabstraction thunk helper...`

However this causes the following warning to be printed in the console:

`Warning: Application delegate received call to -application:handleEventsForBackgroundURLSession:completionHandler: but the completion handler was never called.`

I set a breakpoint [here](https://github.com/Alamofire/Alamofire/blob/e006fa8d4ec1619147f5598dc9b6c9959804434b/Source/Manager.swift#L167) and at this point the message is already visible in the console and `backgroundCompletionHandler` is `nil`.

We're building against the iOS 9 SDK with Xcode 7.0 and currently using Alamofire 2.0.2

I originally thought this was introduced when we merged our Swift 2.0 branch but I'm also seeing the message with an earlier commit using Xcode 6.4 against the iOS 8 SDK.
 I realize that this now comes across as a support-like request but hope that some documentation can be improved as a result.
 For what it's worth, it's essentially this:

```
let configuration = NSURLSessionConfiguration.backgroundSessionConfigurationWithIdentifier("com.ourcompany.app")
let manager = Alamofire.Manager(configuration: configuration)
```

I can move this to Stack Overflow if that's more appropriate.
 http://stackoverflow.com/questions/32766683/what-is-the-correct-way-to-use-backgroundcompletionhandler-in-alamofire

Thanks!
  Why am I getting an error? I just upgraded to swift 2 and I am referencing the pod below to get the latest.
`pod 'Alamofire', '~> 3.0.0-beta.1'`

``` swift
public protocol ResponseObjectSerializable {
    init?(response: NSHTTPURLResponse, representation: AnyObject)
}

extension Request {
    public func responseObject<T: ResponseObjectSerializable>(completionHandler: (NSURLRequest, NSHTTPURLResponse?, T?, NSError?) -> Void) -> Self {
        let responseSerializer = GenericResponseSerializer<T> { request, response, data in
            let JSONResponseSerializer = Request.JSONResponseSerializer(options: .AllowFragments)
            let (JSON: AnyObject, serializationError) = JSONResponseSerializer.serializeResponse(request, response, data)

            if let response = response, JSON: AnyObject = JSON {
                return (T(response: response, representation: JSON), nil)
            } else {
                return (nil, serializationError)
            }
        }

        return response(responseSerializer: responseSerializer, completionHandler: completionHandler)
    }


}
```
 `GenericResponseSerializer` has been renamed `ResponseSerializer`. For cases like this, make sure you check the documentation for update, or, if it hasn't been updated, check the source for the various provided serializers, as they have to use the same API as our custom ones. 
 @jshier Thanks for the response. I have been spending the last 40 minutes to solve this issue. Yes I no longer get the original error but now my code is not working. I tried look at the source but It was not helping me as mush as i thought it would. Can you show me a working example please?
  Is there a way to use custom validation to validate a request before you even make the network call? For instance, if I want to ensure that certain parameters are set, and if not just return an error and not make the request at all.

Currently, it looks like validation only occurs after the request has received a response.
 @cnoon That makes perfect sense. That's basically what I'm doing right now. I thought it would make for some cleaner looking code if I could do pre-validation ON a `Request`, but I understand why it doesn't make a whole lot of sense. 

Thank you for your detailed response as always. I appreciate the immense time that you put into this library. 
  I got a problem recently while testing a Watch OS App I'm currently working on. It seems to me that Alamofire doesn't handle the 304 HTTP-Response code correct.

I hope this is the right place, but I think it's a bit to detailed for StackOverflow and it's really dependent on Alamofire.

Here is what I observed:
When loading a json endpoint the first time I get an 200 HTTP-Response code and everything works just fine. If I reload the same endpoint I get the response with 304 HTTP-Response code which in general is nice.
I noticed though that the data attribute in the completion handler does contain the JSON but cannot be serialized. The reason for this seems to be that the json is duplicated like this:

``` javascript
{json ... }{json ...}
```

where the answer should be just 

``` javascript
{json ... }
```

I tried to isolate this by setting up an example app and was able to reproduce the behaviour with this:

``` swift
import WatchKit
import Alamofire

class InterfaceController: WKInterfaceController {    
    var i = 1
    @IBAction func requestButtonClick() {
        let urlString = "http://jsonplaceholder.typicode.com/users/1"

        // UseProtocolCachePolicy is default
        let urlRequest = NSURLRequest(URL: NSURL(string: urlString) ?? NSURL(), cachePolicy: NSURLRequestCachePolicy.UseProtocolCachePolicy,  timeoutInterval: 10)
        let tmpRequest = request(urlRequest)

        tmpRequest.response(completionHandler: { [weak self] (request, response, data, error) -> Void in
            guard let data = data else { return }
            guard let tmpSelf = self else { return }

            let resultString = NSString(data: data, encoding: NSUTF8StringEncoding)            
            if (error != nil) {
                print(error)
            } else {                
                if resultString?.rangeOfString("\\}\\{", options: .RegularExpressionSearch).location != NSNotFound {
                    print(resultString)
                    print("\nduplication found")
                }
            }
            print("Requests: \(tmpSelf.i++)")            
        })
    }        
}

```

For reproducing your app just needs a button on the storyboard connected to the requestButtonClick action. I wasn't able to reproduce the behaviour for iOS with the same code and it did not occur.

I'm using the current version of Alamofire (tried 2.0.2 as well as 3.0.0-beta1), Xcode version 7.0 (Build 7A218) and am building Watch OS 2 App. 

Edit: I got mixed up with the original discovery of the behaviour. The data in the completion handler has the duplicated json in it, if I receive it with 304 response code.
Hope this cleared it up.
 Updated. Sorry it was unclear and I hope it's clear now.
 Very simple setup. Also the iOS version for comparison. As I said before, I wasn't able to reproduce the behaviour there with the same code.

https://github.com/nonec/AlamoFireNotModified
 Thanks for looking into it. I'll file that radar
 Any updates on this? Maybe a radar number?
Problem is still reproducable
 Last I heard from Apple (end of September) was: 

"Duplicate of 22676738 (Open)"

Since then, nothing happened.
   Alamofire.request(.GET, "http://localhost:3000/iosData")
            .responseJSON { _, _, result in
                print(result)
                debugPrint(result)
                print("Parsed JSON: (result.value)")
        }

I have used this template given in the example but while compiling it is giving error 
"(_,_,_) Void is not convertible to 'Response<AndObject, NSError> -> Void'"
 Did you get anywhere with this issue? as I'am having the same issue on this latest commit 
 Some how yes :) 

Just checked the release note for the latest release, it is still not updated in the ReadMe.

Use the syntax below : (Still not sure how to parse the data, if is there any inbuilt support for that or not). I am using SwiftyJSON for that.

.responseJSON { response in
                print(response.request)
                print(response.response)
                print(response.data)
                print(response.result.value);
}
 Ha thats what I just got working, Ye i use SwiftyJSON for parsing 
 When i run now I get the following issue with the response.swift file 

Generic type 'Result' specialized with too many type parameters (got 2, but expected 1)
 Check this out 
https://github.com/antitypical/Result/issues/77 
Probably, you will get what you are looking for.
 Yea, still not luck, what did you do to get it working?
 I didn't got such issue. I am working with 
Mac OS - (10.10.5)
Xcode - version 7
Swift - version 2
AlamoreFire - Version 3.0.0-beta.1
 just use
response()
(request, response, data, error)  in
and then
let json = JSON(data : data!)
 I used this (validation example).. works on latest

```
Alamofire.request(.GET, "http://httpbin.org/get", parameters: ["foo": "bar"])
     .validate()
     .responseJSON { _, _, result in
         switch result {
         case .Success:
             print("Validation Successful")
         case .Failure(_, let error):
             print(error)
         }
     }
```
 FYI, I'm running the latest that Cocoapods gives me.

On Tue, Sep 22, 2015 at 11:05 AM Christian Noon notifications@github.com
wrote:

> You guys really need to read through the commits if you're running off
> master instead of the official "Latest Release". Otherwise you run the risk
> of the documentation being a bit out-of-date. Considering that master
> currently contains the Alamofire 3.0.0-beta.1 pre-release changes, the docs
> are significantly out-of-date. This will be resolved over the next couple
> of days.
> 
> If you are running on 2.0.2, @peteclark3 https://github.com/peteclark3's
> example will work. If you are running on master or Alamofire 3.0.0-beta.1,
> you need to use the new response type:
> 
> Alamofire.request(.GET, "https://httpbin.org/get")
>     .responseJSON { response in
>         debugPrint(response)
> 
> ```
>     if let JSON = response.result.value {
>         print(JSON)
>     }
> }
> ```
> 
> ‚Äî
> Reply to this email directly or view it on GitHub
> https://github.com/Alamofire/Alamofire/issues/800#issuecomment-142315997
> .
 @cnoon how do you handle the error or failure case?
 :+1: @kapildave6 @marklochrie50265 @Lawgrin @peteclark3 any luck with this?
 I'm fine with my example on 2.0.2.  If you want to look at error handling on master or 3.0.0-beta.1 I would say look at the source, e.g. https://github.com/Alamofire/Alamofire/blob/master/Source/ResponseSerialization.swift

```
let response = Response<T.SerializedObject, T.ErrorObject>(
                request: self.request,
                response: self.response,
                data: self.delegate.data,
                result: result
            )
```

Or just run his examples and set a breakpoint... 
 thanks @peteclark3 i have been looking at the source and the response serialization code is pretty confusing. i'm just ignoring errors for now.
  In OS X 10.11 GM, `Alamofire.request()` will not handle an `HTTPS` call properly, causing a nil return since 10.11 doesn't process http calls by default in a project (although an exception can be made in the plist file). Exact error:

```
App Transport Security has blocked a cleartext HTTP (http://) resource load since it is insecure. Temporary exceptions can be configured via your app's Info.plist file.
fatal error: unexpectedly found nil while unwrapping an Optional value
```
 What's the URL? The error message says your not using HTTPS but HTTP. 
 `https://itunes.apple.com/lookup?id=`

That's the one. Which is why I posted. Sorry forgot it in the original post.
 @cnoon 

The code block in question is on line 50 here: https://github.com/Aghassi/Notify/blob/master/Notify/ITunesNotificationHandler.swift

This is an OS X application. 

We are using this version of Alamofire from 4 days ago: https://github.com/Alamofire/Alamofire/tree/71a26d641d3033540ef12fa632222b6b285e7b2e

We installed Alamofire into our project using git submodules.
 I did a fork of your project and ran it on my Mac. Everything seemed fine. Do you have a proxy running?
![screen shot 2015-09-23 at 4 34 11 pm](https://cloud.githubusercontent.com/assets/153908/10040760/13dde4de-6211-11e5-8d1e-b22e8e4d2c79.png)
 @kiancheong Right now it works fine because we disabled App Transport Security, see here: https://forums.developer.apple.com/thread/3544

Try enabling it and see if it still works on 10.11
 I just did another test with both ATS enabled and disabled, both times they ran okay. I'm on 10.11 Beta (15A279b) if that helps. 
 This is so strange. I'm running 15A282b of 10.11 with Xcode 7 GM. I did some more testing with random songs, and only once could I get it to say that with iTunes (with ATS enabled). When I was trying it earlier it was happening every time. Maybe we had a mistake on our end. Also, I couldn't reproduce the time it just happened because when I played the same song it seemed to work fine. If I run into this again I'll reopen this, but for right now I'll close the thread. I'm still baffled.

HOWEVER, when I do get that issue, songs from Apple Music don't always deliver the album art. Normal local songs don't seem to have the problem.
  Xcode 7, iOS 9, Alamofire 2.0.1

When following a redirect, the headers added to the original request, will not be added to the new request.

Example (#788):

```
let headers = [
            "Authorization": userData.userAPIKey!,
        ]
Alamofire.request(.GET, url, parameters: nil, encoding: .URL, headers: headers).response { (request, response, data, error) -> Void in
}
```

If the server responds with a 301 Moved permanently, a new request is made to the location returned. But the new request will not have the Authorization-Header set.

I saw #314, #317, and #424 But I think this is a different issue. IMHO Alamofire should either follow redirects and add the headers added to the original-request or it should not follow redirects at all and report them to the user. In #788 I found out the hard way looking at what was sent over the wire.

As a user of Alamofire, I don't get any notification/log-message, when the library is following a redirect. This is very handy, but I would expect, that the my extra-headers would also be applied to the new-request.
 Thanks, for the quick reply!
I won't take this to Apple - this is most likely by design for security reasons. 

And now we know how to work around it!
 @cnoon I may be missing something, but why doesn't Alamofire just implement this in the `taskWillPerformHTTPRedirection` internally?

Is it because, since Apple is doing it this way, we are assuming it's a security issue?

If you are willing to accept a PR that implements this, I'd be happy to make one. I think it shouldn't be too difficult. However, I also understand if you don't want to do this, as it may be seen as a way to work around Apple's own security measures.
 This work around does not work if you are using 
`request.authenticate(user: username, password: password)`

Is there a way for me to avoid manually building the Authorization header?

@cnoon 
  Hi,

I don't know if it is the right place to ask this question but I have an issue with the `timeoutIntervalForRequest` session configuration property. I'm using the last branch of Alamofire (2.x) and I have a strange behaviour. The timeout is take into account in iOS 8 but nothing happens in iOS 9 when I configure it like that:

``` swift
Alamofire.Manager.sharedInstance.session.configuration.timeoutIntervalForRequest = 3
```

I have to set the timeout configuration before the `NSURLSession` is created, for example at the line 130 in the [Manager.swift](https://github.com/Alamofire/Alamofire/blob/master/Source/Manager.swift#L126-L138) file:

``` swift
public init(
        configuration: NSURLSessionConfiguration = NSURLSessionConfiguration.defaultSessionConfiguration(),
        serverTrustPolicyManager: ServerTrustPolicyManager? = nil)
    {
        configuration.timeoutIntervalForRequest = 3 // Here it works for iOS8 and iOS9

        self.delegate = SessionDelegate()
        self.session = NSURLSession(configuration: configuration, delegate: self.delegate, delegateQueue: nil)
        self.session.serverTrustPolicyManager = serverTrustPolicyManager

        // Here is too late, in iOS9 nothing happens

        self.delegate.sessionDidFinishEventsForBackgroundURLSession = { [weak self] session in
            guard let strongSelf = self else { return }
            dispatch_async(dispatch_get_main_queue()) { strongSelf.backgroundCompletionHandler?() }
        }
    }
```

Have I forgotten something or it is a new behaviour of iOS9? If so I would know if it would be possible to change the `session` property of the shared instance to be able to configure their properties?

Best
  I'm just using the code from the [Migration Guide](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%202.0%20Migration%20Guide.md), but I got that error.

<img width="1052" alt="screen shot 2015-09-20 at 22 26 41" src="https://cloud.githubusercontent.com/assets/10325302/9982765/dca9c3b0-5fe6-11e5-8755-2b83f329ac25.png">

Any way to solve it?
 Maybe I solved it, I don't need to serialize the result anymore, do I?
@cnoon 
  :+1: 
 So - I'm trying to use this in the context of passing a custom NSURLSession (using DVR) when I instantiate an Alamofire.Manager.  I only want to bring my custom NSURLSession to the party.

I can pass in my session, but I can't get a handle on a Manager.SessionDelegate object for the init.  I can't get the SessionDelegate off the default AlamofireManager - and can't pass one in because the class isn't public. 

Should your updated API allow for passing in an NSURLSessionDelegate instead of a Manager.SessionDelegate?  I might be missing something - Thanks for any clarification... 
  When writing an API with Alamofire as the enabling technology, I'd like to be able to write tests using something like DVR (http://blog.soff.es/network-testing-in-swift-with-dvr).  For that to work, there needs to be a way to replace the NSURLSession with a subclass of our own design.

Can anyone provide a suggestion on how to test with this method?  Alternatively, would it make sense to supply a NSURLSession to the Manager's initializer?
 From my limited understanding, it seems like initializing a `Manager` with a custom session is essentially impossible, as Alamofire takes over the session's delegate. This is core to the Alamofire architecture and likely can't be worked around.  

For my own testing, I use `OHHTTPStubs`. Recording is manual, but no modification to the networking code is necessary.
  Thanks for this framework and Now I use the latest Xcode 7 from app store, However there's quite a lot errors during build, I use the pods to install and the version I searched from pod is 1.2.3, so I thinks there's no update to fit the latest swift yet? 

Thanks very much
  I would suggest adding an updated README along with this to help avoid confusion.
 Another advantage of this is that if another parameter is added (or removed), people won't have to change every `response` call.
 @macelofabri agreed! Recently upgraded a project to Swift 2.0. Even with regular expressions updating the code for the latest version of Alamofire was a pain. 
 I like this change as well. Will definitely make it easier to modify the object in the future if we need too, although it will be one more round of upgrades to every call site @tobiasoleary :beers: 
 Quick question here.

The `Alamofire.response` function doesnt use this system here as seen in the [documentation](https://github.com/Alamofire/Alamofire#response-handler) and [here](https://github.com/Alamofire/Alamofire/blob/238ebc3f9af52910fa69bed404a816d75d89cfc2/Source/ResponseSerialization.swift#L86). Was this only intended for `responseJSON` and similar?
  @cnoon In this new setup, how am I supposed to handle underlying errors when I'm using my own `GenericResponseSerializer`? As far as I can tell, there's no way to access the errors from the network or even Alamofire's own validation. Even the built in serializers don't have access. What am I missing?
 Looks great. This accomplishes all of goals for my custom response serializer, lets me do logging, and even allows some simplification of code. Plus, I can now have custom serializer behavior based on incoming errors. :+1: 

Are the changes you made here compatible with #792? I haven't looked at it closely but it looks like a good change. 
 :+1:  I really like this new PR, thanks @cnoon. Do you have an ETA for when it will merged to master?
 @cnoon Sorry I wasn't able to look at this over the weekend. I'm very happy with all the changes up to this point. I'll be waiting for `3.0.0-beta.1` as I'm planning on implementing these changes in my own projects ASAP. Thank you!
 This looks good to me @cnoon. Do we need to make another migration change, and explain why we are bumping soon, and the clear benefits of upgrading?
 @cnoon Is there a branch that we can install as a pod while we wait for the ASF? I'd like to start integrating this into a current project ASAP.
 @AnthonyMDev Check the branch this PR is pulling from. I used it in a CocoaPods project to test my own code and it worked fine.
 @jshier thanks. I knew there were multiple new features coming from PR #791, 792, and #795. Wasn't sure if there was one branch that incorporated all of them.
 Agin I'm late to the party. Shouldn't have taken a long weekend off :open_mouth:
Apparently everyone agrees that this PR improves the library. I'll add my 2 cents anyway.

Prior to this, I was using the `validate()` method to validate things prior to any deserialization. For example if for one request I needed a HTTP 201 response, I would check it and return a `ErrorType` error, not a `NSError`. 
My client returns `ErrorType` errors. I'm not going to wrap my error into a `NSError` to comply with the `validate()` method, then unwrap it in the response serializer. The `validate()` method suddenly became useless for me and I'll to do the validation in the serializer.
For me the job of the _serializer_ is to _serialize_, not check HTTP statuses or handle any kind of validation. I feel that I'll have to write a thousand-lines serializer like the one @jshier showed in [this comment](https://github.com/Alamofire/Alamofire/issues/732#issuecomment-137142628) whereas before I could chain simple validations before doing any serialization (which was not even needed since there was an error).

I have other problems related to the way I handle the response after it has been serialized, but I guess it's only because I tried to do a convoluted generic responseSerializer. 
 @jschmid I think you've misunderstood what this PR (and the other AF3 PRs) require on the part of the developer. I don't know how your response serializer works or how you're generating your errors, but this new pattern doesn't require the use of `NSError`. I refactored the serializer I showed in that comment you linked to down to [this](https://gist.github.com/jshier/f08f08e05d994b5bdc7d). To handle the new error coming into the serializer (underlying errors and Alamofire validate errors both), all I had to do was `guard` against it and wrap it in my custom error type if it existed. Also, please remember that my serializer was so complicated because 1) I was doing custom JSON deserialization using Argo and 2) I had to check the partially parsed response for success, not just whether it parsed. Perhaps if you posted what you were trying to do others could help you out.
 Thanks @jshier for the reply. 

As I stated in #732, it thought i would be great to be able to return `ErrorType` errors in the **validation process**. (Not returning an error from the `ResponseSerializer`)

As a simple example I had:

```
extension Request {
    func validateIsStatus(code: Int, _ error: ErrorType) -> Self {
        return validate { _, res in
            if res.statusCode != code {
                return Request.ValidationResult.Failure(error)
            } else {
                return Request.ValidationResult.Success
            }
        }
    }
}
```

That I could use like:

```
enum ClientError: ErrorType {
  case MyError(Int)
}

let request: Request =  ...

request
.validateIsStatus(201, ClientError.MyError(201))
.validate()
.responseObject(completionHandler: { ... })
```

Now you see that I use the validation to return custom errors. But this PR prevents returning `ErrorType` errors now.

I don't want the serializer to do any serialization if there was a validation error. Now I just have to do it and do the custom validation in the callback of my custom serializer.

```
request
.validate()
.responseObject { response, obj, error in
  if response?.statusCode != 201 {
    callback(. MyError(201))
    return
  }

  // Handle obj here
}
```

Do you see what I mean here?

(**Edit**: the code sample was wrong)
 Note that maybe I'm using the validation for the wrong purpose, and I should do this in the response callback anyway. 
 Are you using your own `ResponseSerializer`? If so, you can easily replicate this functionality while not parsing the response by using a `guard` at the top of the serializer, as I did in the refactored serializer I linked to above. 

If you're not using your own `ResponseSerializer`, you're right, it does make your case somewhat less elegant. Perhaps @cnoon would have some ideas. 

Additionally, now that the PR has landed on master, you may want to open an issue regarding not being able to return custom error types from `.validate()`. 
 Thank you for the thorough answer. 

I understand the end goal of having only NSErrors. I do have a custom serializer. I guess I'll have to rewrite it a bit to handle my errors there.

Thanks again!
    Using

```
PODS:
  - Alamofire (2.0.1)
```

I have this strange issue, that the Authorization-Header isn't sent _for some requests_. 

Just upgraded to Alamofire 2.0.1 from 1.3. Had the same problem with the 1.3 on iOS 9 - one specific request does not get the Header sent...

I tried both ways of setting the header. a) Using a dedicated Manager created with: 

```
    func createManagerWithAuthHeader(authHeader:String) -> Manager {
        var addedHeaders = Manager.defaultHTTPHeaders
        addedHeaders["Authorization"] = authHeader

        NSLog("Authorization-Header: \(authHeader)")
        let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
        configuration.HTTPAdditionalHeaders = addedHeaders        
        return Manager(configuration: configuration)
    }
```

Now I just keep the different values for Authentication and apply them depending on the  route:

```
    // Router to generate Requests
    enum Router: URLRequestConvertible {
        static let BASE_URL = "************"

        // Possible Requests
        ....
        case Category(String)
        case Criterias(String)
        ....

        var URLRequest: NSMutableURLRequest {
            let (path, method, userAuth, parameters, encoder): (String, String, Bool, [String: AnyObject], Alamofire.ParameterEncoding) = {
                switch self {
                .....
                case .Category(let catId):
                    return ("/categories/\(catId)/", "GET", false, [:], Alamofire.ParameterEncoding.URL)
                case .Criterias(let catId):
                    return ("/categories/\(catId)/criteria", "GET", false, [:], Alamofire.ParameterEncoding.URL)
                .....
                }
            }()

            let requestUrl = NSURL(string: Router.BASE_URL)
            let request = NSMutableURLRequest(URL: requestUrl!.URLByAppendingPathComponent(path))
            request.HTTPMethod = method

            let authHeader = userAuth ? Client.sharedInstance.userAuthHeader : Client.sharedInstance.clientAuthHeader
            request.setValue(authHeader, forHTTPHeaderField: "Authorization")

            let encoding = encoder
            let encodedRequest = encoding.encode(request, parameters: parameters).0
            return encodedRequest
        }
    }
```

The funny thing is, that the call with `.Category` works. Here's the code:

```
    func getCategory(categoryId:String, completion: (Category?, ErrorType?) -> Void) {
        let route = Router.Category(categoryId)
        let request = route.URLRequest
        let authHeader = request.valueForHTTPHeaderField("Authorization")
        NSLog("getCategory: \(request) - \(authHeader)")
        Alamofire.request(route)
            .responseObject { (category:Category?, meta:JoixesMetaData?, error: ErrorType?) -> Void in
                if error != nil || category == nil {
                    completion(nil, error)
                }
                else {
                    completion(category, nil)
                }
            }
    }
```

First request on the wire (Wireshark):

```
GET /api/v1/categories/_VWypVvLTnWSM7kcK2NuJAl_/? HTTP/1.1
Host: ****
Connection: keep-alive
Accept: */*
User-Agent: Joixes/com.joixes.Joixes (3; OS Version 9.0 (Build 13A340))
Accept-Language: en-US;q=1.0
Authorization: Basic Umctb25nQkxRYmF......
Accept-Encoding: gzip;q=1.0,compress;q=0.5

HTTP/1.0 200 OK
Date: Fri, 18 Sep 2015 17:01:54 GMT
Server: WSGIServer/0.2 CPython/3.4.3
Allow: GET, HEAD, OPTIONS
X-Frame-Options: SAMEORIGIN
Vary: Accept
Content-Type: application/json

{"data":{"uid":"_VWypVvLTnWSM7kcK2NuJAl_","name":"Clutches","longName":"Women, Clutches","parentCategory":"TF6thQUmTyiwJt10QsmLJgdC","verticalCategory":"x23Un1lcSGSTideM2RQdJw7N","isFindable":true,"hasChild":false,"childCategories":[]},"meta":{"detail":"Success.","code":200,"success":true}}
```

And with Criterias it does not work:

```
    func getCriteriasForCategory(categoryId:String, completion: ([BaseFilterCriteria], ErrorType?) -> Void) {
        let route = Router.Criterias(categoryId)
        let request = route.URLRequest
        let authHeader = request.valueForHTTPHeaderField("Authorization")
        NSLog("getCriteriasForCategory: \(request) - \(authHeader)")
        Alamofire.request(route)
            .responseJoixes { (jxResponse, error) -> Void in
                NSLog("getCriteriasForCategory: jxResponse: \(jxResponse)")
                var criterias:[BaseFilterCriteria] = []
                if let criteriaData = jxResponse?.data as? [AnyObject] {
                    criterias = criteriaData.map { return CriteriaFactory.parseCriteria($0 as! [String:AnyObject]) }
                }
                completion(criterias, error)
            }
    }
```

Note:  **The Authorization-Header in the variable authHeader is correct!! With both requests the exact same value** 

On the wire there is not :

```
GET /api/v1/categories/_VWypVvLTnWSM7kcK2NuJAl_/criteria/ HTTP/1.1
Host: *****
Accept-Language: en-US;q=1.0
User-Agent: Joixes/com.joixes.Joixes (3; OS Version 9.0 (Build 13A340))
Accept: */*
Accept-Encoding: gzip;q=1.0,compress;q=0.5
Connection: keep-alive

HTTP/1.0 401 UNAUTHORIZED
Date: Fri, 18 Sep 2015 17:02:03 GMT
Server: WSGIServer/0.2 CPython/3.4.3
Allow: GET, OPTIONS
WWW-Authenticate: Token realm=api
X-Frame-Options: SAMEORIGIN
Vary: Accept
Content-Type: application/json

{"data":null,"meta":{"detail":"Authentication credentials were not provided.","code":401,"success":false}}
```

Any Hints where the Header-Value could get lost??
 @eburi  Hi Please use this code to send Authorization-Header

```
let headers = [
            "Authorization": userData.userAPIKey!,
        ]
Alamofire.request(.GET, url, parameters: nil, encoding: .URL, headers: headers).response { (request, response, data, error) -> Void in
}
```
 Had this same issue before updating to Xcode 7. I was running my app with Alamofire 1.3 on iOS 9 and authorization headers were not being received by my server. I did what @pramodsharma403 to fix/monkey-patch this issue.

I'd still want to set the headers with `HTTPAdditionalHeaders` though.
 @pramodsharma403 How can I combine this with a Router? I have a lot of different requests and I would really like to use the router.

I implemented the URLRequestConvertible, I create a there an NSMutableURLRequest and I set the header on this request. 

When you look at this code:

```
    func getCriteriasForCategory(categoryId:String, completion: ([BaseFilterCriteria], ErrorType?) -> Void) {
        let route = Router.Criterias(categoryId)
        let request = route.URLRequest
        let authHeader = request.valueForHTTPHeaderField("Authorization")
        NSLog("getCriteriasForCategory: \(request) - \(authHeader)")
        Alamofire.request(route)
            .responseJoixes { (jxResponse, error) -> Void in
                NSLog("getCriteriasForCategory: jxResponse: \(jxResponse)")
                var criterias:[BaseFilterCriteria] = []
                if let criteriaData = jxResponse?.data as? [AnyObject] {
                    criterias = criteriaData.map { return CriteriaFactory.parseCriteria($0 as! [String:AnyObject]) }
                }

                completion(criterias, error)
            }
    }
```

and this is the console output:

```
2015-09-21 16:56:03.318 Joixes[29243:7450013] getCriteriasForCategory: <NSMutableURLRequest: 0x7fa84ca05290> { URL: http://<REMOVED>/api/v1/categories/e4cN6UoyQSCAOBVh4R4BgAGY/criteria? } - Optional("Basic <REMOVED>")
2015-09-21 16:56:03.320 Joixes[29243:7450013] request: AuthHeader: Optional("Basic <REMOVED>")
2015-09-21 16:56:03.584 Joixes[29243:7450556] responseJoixes: data: Optional({
    data = "<null>";
    meta =     {
        code = 401;
        detail = "Authentication credentials were not provided.";
        success = 0;
    };
})
```

Note: I put <REMOVED> where there is sensitive information (just a test-plattform anyway...)

I just don't understand this: How is the header not sent, when clearly present on the URLRequestConvertible. I also put a log message into `public func request(URLRequest: URLRequestConvertible) -> Request` in Alamofire/Manager.swift where it outputs basically the auth-header from the originalRequest-attribute on the DataTask. The value is still present there.

From my point of view, I'm giving to Alamofire the exact same thing as with any other request. With any other request it's just fine. But with this request, the Header is simply not sent. 

I have no cloud what else could influence this....
 pod install says:

```
Using Alamofire (2.0.1)
```

But I just found out what the problem is, thanks to Wireshark! The request to the server does have the Authorization-Header set, but the server is replying with a 301 MOVED PERMANENTLY, and the subsequent request - I don't know who's doing this - is sent to the new location BUT without the headers from the original request! Hence the unauthorised response! 

Since this "MOVED PERMANENTLY" is not visible to me as Alamofire-user, I was not aware of this. 

It's actually very small change I missed in the API-Docs from the server I'm calling. 
The endpoint used to be `/criterias` and it's now "MOVED" to `/criterias/` ...

It would be great, if I would get a notice or Log-Message for 301 return-codes.
And it would be great if these Redirects were to be followed with the headers for the original request.
 @eburi So this was fixed by pointing to the correct endpoint and the Router worked accordingly?
 I have the same problem. Trying to send a request with an Authorization header set on the NSMutableURLRequest. Header is visible on the request object in the completion handler, but not visible in the actual request sent to the server (no Authorization header when sending request through Charles Proxy). Any ideas?
 @phiberjenz The headers are sent in the URL body, not in the actual URL for a post request, in a get request, if you want them to show up in the actual URL you put them in the body parameter like you would in the headers parameter(as an array)
  I'm sending image data as a base64 string to our server(with a progress indicator).

However, the progress closure is called only once(at ~300 bytes out of ~150 kB

``` swift
  let userID = NSUserDefaults.standardUserDefaults().valueForKey("id") as? Int
        var params = [ "user_id": userID! ,"locality_id" : API.Static.currentNeighbourhoodID, "channel_id" : channelID!, "message" : postTextView.text] as [String:AnyObject!]
        var imageSize = 0
        if let pickedImage = pickedImage
        {
            let imageData = UIImagePNGRepresentation(pickedImage)
            let base64String = imageData.base64EncodedStringWithOptions(NSDataBase64EncodingOptions.allZeros)
            params["file"] = base64String
            imageSize = imageData.length
        }
        let headers = ["Authorization":"Bearer \(AppDelegate.owner!.uuid)"]
        self.title = "Posting"
        self.postNowButton.enabled = false
        self.navigationController?.popViewControllerAnimated(true)
        let userInfo:Dictionary = ["channelID":self.channelID!]
        NSNotificationCenter.defaultCenter().postNotificationName(AddingPostNotificationName, object: nil, userInfo: userInfo)
        Alamofire.request(.POST, API().addPost(), parameters: params,encoding: .JSON, headers: headers).progress { (bytesWritten, totalBytesWritten, totalBytesExpectedToWrite) -> Void in
            print("frame")
            print(totalByesWritten)

            // This closure is NOT called on the main queue for performance
            // reasons. To update your ui, dispatch to the main queue.
            dispatch_async(dispatch_get_main_queue()) {
                print("Total bytes written on main queue: \(totalBytesWritten)")
            }

//                NSNotificationCenter.defaultCenter().postNotificationName(AddingPostProgressName, object: nil, userInfo: userInfo2)


        }.response({ (request, response, data, error) -> Void in
            print(error)
            if error != nil
            {
            }
            else
            {
                print(NSString(data: data!, encoding: NSUTF8StringEncoding))
                NSNotificationCenter.defaultCenter().postNotificationName(AddedPostNotificationName, object: nil, userInfo: userInfo)
                self.postNowButton.enabled = true
                self.title = ""
            }
        })
```
  It looks like Alamofire does not set the HTTPAdditionalHeaders when using the 1.3 version of the library on a iOS 9 device.
 Please help here. Same issue with me
 it seems to be related to this issue here: https://github.com/Alamofire/Alamofire/issues/545.  I think the solution is to new up another instance of a manager as updating headers of the manager does not change the existing session
 @mypark  I am using 

```
var manager: Manager = Manager.sharedInstance
manager.session.configuration.HTTPAdditionalHeaders = ["Authorization":userData.userAPIKey!]
manager.request(.POST, url, parameters:params , encoding: .URL).response { (request, response, data, error) -> Void in

```

What you suggest here?
 @ursu-daniil  @mypark  Got a solution..Use following code to send Header

```
let headers = [
            "Authorization": userData.userAPIKey!,
        ]
Alamofire.request(.GET, url, parameters: nil, encoding: .URL, headers: headers).response { (request, response, data, error) -> Void in
}
```
 Note that @ursu-daniil and I found that, besides @cnoon's remark, we also needed to patch 1.3.1 with an override of `respondsToSelector` ‚Äî see [fork](https://github.com/Paul-van-Klaveren/Alamofire/releases/tag/1.3.1-iOS9URLSessionFix) . (FYI working properly as a git submodule for us)

So for the time being this will allow us to keep using Alamofire with Swift 1.2 and iOS 9.
‚Ä¶now on to greater things by migrating to Swift 2.0 ;-)
  Building on Xcode7, running on iOS9, carthage with Alamofire and AlamofireImage.
Got this error:

```
dyld: Library not loaded: @rpath/Alamofire.framework/Alamofire
  Referenced from: ***
  Reason: Incompatible library version: *** requires version 2.0.0 or later, but Alamofire provides version 1.0.0
```
  First command of manual install fails:

git submodule add https://github.com/Alamofire/Alamofire.git
fatal: Not a git repository (or any of the parent directories): .git

Have to perform a git init on the home directory of the project first
  Pod install is giving the following error on El Capitan and xCode7

pod install
Updating local specs repositories
Analyzing dependencies
Pre-downloading: `Alamofire` from `https://github.com/SwiftyJSON/Alamofire-SwiftyJSON.git`, branch `swift-2.0`

[!] Error installing Alamofire
[!] /usr/bin/git clone https://github.com/SwiftyJSON/Alamofire-SwiftyJSON.git /var/folders/96/4b8rkpfd40s7lg6d95rgc67m0000gn/T/d20150917-3947-1hxgf8y --single-branch --depth 1 --branch swift-2.0

Cloning into '/var/folders/96/4b8rkpfd40s7lg6d95rgc67m0000gn/T/d20150917-3947-1hxgf8y'...
warning: Could not find remote branch swift-2.0 to clone.
fatal: Remote branch swift-2.0 not found in upstream origin
  It seems that in 8873379b67185e220eb09b05e8227ed19a0d296f `Alamofire iOS` got a dependency on its own. This should actually be a dependency for the test bundle so I took the liberty to move this dependency.
  When .responseJSON is used, and if result.value isn't nil, result.data is nil. Although this does not make the library unusable, it is still unexpected behaviour: You should be able to access BOTH the JSON value and the NSData raw response.
 Update: if it is needed, I believe I have fixed this, I can submit a pull request.
 I'd find this useful as well. I ran into this issue when was trying to put some logging into my generic response handler. 
 @cnoon My usage case is rather simple. Take this code, which uses my implementation of `GenericResponseSerializer` and breaks the `Result` apart for my completion blocks.

``` swift
func responseObject<T: Decodable where T == T.DecodedType>(completionHandler: (responseObject: T?, error: CloudFlareError?) -> Void) -> Self {
    let fullCompletionHandler = { (request: NSURLRequest?, response: NSURLResponse?, result: Result<T>) in
        switch result {
        case let .Success(value):
            completionHandler(responseObject: value, error: .None)
        case let .Failure(_, error):
            if let error = error as? CloudFlareError {
                completionHandler(responseObject: .None, error: error)
            }
            else if let error = error as? NSError {
                // Must have received a network error.
                completionHandler(responseObject: .None, error: CloudFlareError.NetworkError(error: error))
            }
            else {
                fatalError("ResponseObject received an error that was neither a CloudFlareError nor an NSError.")
            }
        }
    }

    return response(responseSerializer: Request.CloudFlareResponseSerializer(), completionHandler: fullCompletionHandler)
}
```

What I'd like to be able to do is call a logging function from within `responseObject`. My old implementation of that method essentially wrapped `responseJSON` and so had access to all of the intermediate information and errors. This new version makes that much more difficult, and for the `.Success` case, essentially impossible. Now, I'd be content to only log the model object created and not any of the intermediate state (string, JSON, Argo JSON), if only I could figure out how to create a log function that can be called with a generic parameter. But in the end, having `data` even in the success case would make this logging trivial, even if I had to redo some of the parsing (this logging isn't enabled for release and so isn't really performance critical). 
 @cnoon my usage case is almost exactly the same as @jshier's!
  Alamofir is a very good net request kit.
Today, i  had updated Xcode from 6.4 to 7 , i got many errors , among them point to the Alamofire.
please support swift 2.0
thank advance!
 Update your Podfile with `pod 'Alamofire'` and run `pod update 'Alamofire'`
  I'm setting a custom boundary like this.

```
let headers = ["Authorization" : "Bearer \(token)",
            "Content-Type" : "multipart/form-data; boundary=----boundary-id"]
manager.upload(.POST, URL, headers: headers, multipartFormData: { ... }, encodingCompletion: { ... })
```

but when I do `request.request?.allHTTPHeaderFields` in the encodingCompletion closure I get the default alamofire boundary. 

I believe the reason is the `init()` function of `MultipartFormData` which is always using the random boundary:

```
public init() {
        self.boundary = BoundaryGenerator.randomBoundary()
        self.bodyParts = []
        self.streamBufferSize = 1024
}
```
 so there is no way to specify a custom boundary?
  This code, using Alamofire 1.3.1 is working:

```
        let alamofireManager = Alamofire.Manager.sharedInstance

        alamofireManager.session.configuration.HTTPAdditionalHeaders = ["Authorization": "Basic " + HelpMethods.GenerateBasicAuthenticationString(username, and: password)]

        alamofireManager.request(.GET, loginUrlString, encoding: .URL)
            .responseJSON { request, response, responseString, responseError in
                println(request)
                println(response)
                println(responseString)
                println(responseError)
                completionHandler(responseObject: response?.statusCode as Int!, error: responseError)
        }

```

Now i'm converting my project to Swift 2.0 and Alamofire 2.0. However the same code(except for removing the Error parameter) is giving me an 401 error using the same URL, username and password:

```
        let alamofireManager = Alamofire.Manager.sharedInstance

        alamofireManager.session.configuration.HTTPAdditionalHeaders = ["Authorization": "Basic " + HelpMethods.GenerateBasicAuthenticationString(username, and: password)]

        //Perform request
        alamofireManager.request(.GET, loginUrlString, encoding: .URL)
            .responseJSON { request, response, responseString in
                print(request)
                print(response)
                print(responseString)
                completionHandler(responseObject: response?.statusCode as Int!, error: nil)
        }
```

Am i doing something wrong or is this an issue?
 Changed the code to:

```
        let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
        configuration.HTTPAdditionalHeaders = ["Authorization": "Basic " + HelpMethods.GenerateBasicAuthenticationString(username, and: password)]

        let manager = Alamofire.Manager(configuration: configuration)

        manager.request(.GET, loginUrlString, encoding: .URL)
            .responseJSON { request, response, responseString in
                print(request)
                print(response)
                print(responseString)
                completionHandler(responseObject: response?.statusCode as Int!, error: nil)
        }
```

Now i get a nil response instead of my previous 401 response.
 You must hold a reference out of scope or use shared instance for manager. If not your request is cancelled very quickly (and your response = nil).
https://github.com/Alamofire/Alamofire/issues/673
 It seems that for each individual request from Alamofire 2.0, we need to add authentication header. Pleas e have a view on [this answer from Stackoverflow](http://stackoverflow.com/questions/32688546/ios-alamofire-v2-basic-auth-not-working#32689693). 
  I've noticed that Alamofire encodes POST data with a content type of `application/x-www-form-urlencoded` by just doing a straight URL encode, instead of following what's outlined in the [W3 spec](http://www.w3.org/TR/html401/interact/forms.html#didx-applicationx-www-form-urlencoded). For example, let's say I have an login endpoint that takes a `username` and `password`, and my username is `hello world` and my password is `password?`. If I make a POST request to that endpoint using a standard HTML form, the POSTed data looks like this:

```
username=hello+world&password=password%3F
```

Compare that to the data that Alamofire POSTs:

```
password=password?&username=hello%20world
```

Notice how the question mark isn't encoded at all, and the space is encoded as `%20` instead of `+`.
  I have recently upgraded to Alamofire 2.0, and now my Put request is failing with a 400 error, when it was previously working properly. I perform the call with the code:

```
    Alamofire.request(Router.Put(query: url, params: params, encoding: .JSON))
        .validate()
        .responseJSON() {
            (request, response, result) in

            print("request: \(request)")
            print("response: \(response)")
            print("result: \(result)")

            switch result {
            case .Success(_):
                // success
            case .Failure(let data, _):
                // error occured
            }
    }
```

and my custom Router class:

```
enum Router: URLRequestConvertible {

    case Get(query: String, params: [String: AnyObject]?)
    case Post(query: String, params: [String: AnyObject]?)
    case Put(query: String, params: [String: AnyObject]?, encoding: ParameterEncoding)
    case Delete(query: String, params: [String: AnyObject]?)

    var URLRequest: NSMutableURLRequest {
        var encodeMethod: Alamofire.ParameterEncoding = Alamofire.ParameterEncoding.URL

        // Default to GET
        var httpMethod: String = Alamofire.Method.GET.rawValue

        let (path, parameters): (String, [String: AnyObject]?) = {
            switch self {
            case .Get(let query, let params):
                // Set the request call
                httpMethod = Alamofire.Method.GET.rawValue
                // Return the query
                return (query, params)
            case .Post(let query, let params):
                // Set the request call
                httpMethod = Alamofire.Method.POST.rawValue
                // Return the query
                return (query, params)
            case .Put(let query, let params, let encoding):
                // Set the request call
                httpMethod = Alamofire.Method.PUT.rawValue
                // Set the encoding
                encodeMethod = encoding
                // Return the query
                return (query, params)
            case .Delete(let query, let params):
                // Set the request call
                httpMethod = Alamofire.Method.DELETE.rawValue
                // Return the query
                return (query, params)
            }
            }()

        // Create the URL Request
        let URLRequest = NSMutableURLRequest(URL: NSURL(string: Globals.BASE_URL + path)!)
        // set header fields
        if let key = NSUserDefaults.standardUserDefaults().stringForKey(Globals.NS_KEY_SESSION) {
            URLRequest.setValue(key, forHTTPHeaderField: "X-BC-API")
        }
        // Add user agent
        if let userAgent = NSUserDefaults.standardUserDefaults().stringForKey(Globals.NS_KEY_USER_AGENT) {
            URLRequest.setValue(userAgent, forHTTPHeaderField: "User-Agent")
        }

        // Set the HTTP method
        URLRequest.HTTPMethod = httpMethod

        URLRequest.cachePolicy = NSURLRequestCachePolicy.ReloadIgnoringLocalCacheData

        return encodeMethod.encode(URLRequest, parameters: parameters).0
    }
}
```

Instead of the call being a success, the response is:

```
response: Optional(<NSHTTPURLResponse: 0x7fcee15b34d0> { URL: https://apiurl } { status code: 400, headers {
"Cache-Control" = "no-cache";
"Content-Length" = 26;
"Content-Type" = "application/json; charset=utf-8";
Date = "Tue, 15 Sep 2015 15:33:50 GMT";
Expires = "-1";
Pragma = "no-cache";
Server = "Microsoft-IIS/8.5";
} })
```

Is there code I'm not updating properly since I upgraded to Alamofire 2.0?
 I looked more into the problem and on the server side, Content-Type is coming in as blank for the request, when it should be coming in as application/json. Do I have to manually set the content type? I was under the impression by setting the encode method to .JSON, the Content-Type would be set accordingly.
 Alamofire will only add `application/json` when there is actually body data in the request. Are you sure the request you're testing has body data? For my app, since my back end requires `application/json` even when there are no parameters, I've added it to my request router as a default header for every request.
 I do have data in the request. I create my params parameter and add values to it. I have even put a print statement confirming.

I create it like:

```
// Save the profile
var params: [String: AnyObject] = ["indexPhoto": userProfile.indexPhoto,
    "dob": df.stringFromDate(userProfile.dob) as NSString,
    "identAs": userProfile.identAs]
// Add manually since creating the dictionary all at once is too much for swift to handle
params.updateValue(String(format:"%.2f", userProfile.heightIn), forKey: "heightIn")
params.updateValue(String(format:"%.2f", userProfile.weightLbs), forKey: "weightLbs")
params.updateValue(userProfile.eyes, forKey: "eyes")
params.updateValue(userProfile.hair, forKey: "hair")
...
```
 @cnoon and @jshier, I posted on Stack Overflow http://stackoverflow.com/questions/32596031/put-request-failing-with-alamofire-2-0
  let parameters : [String: AnyObject] =
            [
                "user_name": [FBUserDataDict.value(forKey: "name")] as AnyObject,
                "user_email":["email" : FBUserDataDict] as AnyObject,
                "user_password":"" as AnyObject,
                "user_phone_number":"" as AnyObject,
                "user_registration_type":"facebook" as AnyObject,
                "user_onesignalid":"1" as AnyObject,
                "user_profile_pic_url":"" as AnyObject

```
    ]
```

i got crash can anyone help me how should i pass dictionary value to parameter? swift 3 
  Set APPLICATION_EXTENSION_API_ONLY to YES in tvOS Framework target.
 Ops sorry. I thought I'd done that properly. I'll rebase from now on so I don't cause any more issues.
  I have been using this code to upload my user profile picture to the server. but I am wondering how should I post other parameters along with it?

```
  let parameters = [
        "first_name" : "\(firstName)",
        "last_name" : "\(lastName)",
    ]
```

How can I include those parameters with the upload picture request?

```
Alamofire.upload(.POST,
URLString: "https://example.com/api/v1/users/profile_pic.json?auth_token=\(auth_token)",
multipartFormData: { multipartFormData in
    multipartFormData.appendBodyPart(data: imageData, name: "avatar", fileName: "avatar_img.png", mimeType: "image/png")
},
encodingCompletion: { encodingResult in
    switch encodingResult {
        case .Success (let upload, _, _):
            upload.responseJSON { request, response, data, error in
            // Do whatever 
            } 
        case .Failure (let encodingError):
    }
})
```
 This solution is really needed
  Hello! My question is that does it support swift 2.0? I need to support 2.0, so if it isn't supported, please try your best to update. Thanks in advance!
 Thank you for your reply.I pod
pod 'Alamofire', '~ 2.0'

I do nothing yeah, and I try to build, but there are lot of errors.

It shows that [String]() array doesn't have a member ofjoinWithSeparator
return components.joinWithSeparator(",")

It showsthat it can't be invoked with these types arguments.
I turn to have a lot ofCFStringTransform, it seems that the arg type is not right.
if CFStringTransform(mutableUserAgent, UnsafeMutablePointerCFRange(nil), transform, false) {
return mutableUserAgent as String
}

Note:
My Xcode version is xcode7 beta(7A120f)

Hope your reply. Thanks in advance!

ÂéüÂßãÈÇÆ‰ª∂
Âèë‰ª∂‰∫∫:Christian Noonnotifications@github.com
Êî∂‰ª∂‰∫∫:Alamofire/AlamofireAlamofire@noreply.github.com
ÊäÑÈÄÅ:Jacky Huang18675574495@163.com
ÂèëÈÄÅÊó∂Èó¥:2015Âπ¥9Êúà15Êó•(Âë®‰∫å)‚Äá12:14
‰∏ªÈ¢ò:Re: [Alamofire] Now does it suport swift2.0? (#769)

It supports Swift 2.0. Please take the time to read the documentation in the future. Thanks!
‚Äî
Reply to this email directly or view it on GitHub.
 > My Xcode version is xcode7 beta(7A120f)

That is a bit old version (oh, this is the beta 1), you should use Xcode 7 GM (7A218) now.
  /Users/pro/Desktop/Pods/<module-includes>:1:1: Umbrella header for module 'Alamofire' does not include header 'Alamofire.h'
  "Alamofire tvOS" framework + "Alamofire tvOS tests" targets.  Tests all pass and tested in a separate sample app.
  Using the "~> 2.0" pod version when I debugPrint from a responseJSON call, the output JSON is putting ; instead of , in-between elements of a dictionary.  Arrays are printing correctly.
  Created a tvOS Framework.

Possibly already in progress, but I needed it for using some of my projects I'm working on for the Apple TV, so I thought I'd share.

I've run the iOS unit tests on the target and that all pass. However the CacheTestCase tests randomly fail for no reason on some occasions. Normally a max of 3 out of the 5 fail, but normally just one of them does (but not always the same one). I'm not sure if this is an Xcode beta thing or that the tests were designed for iOS not tvOS.
 For anyone else trying to get this working with Cocoapods, had to add `s.tvos.deployment_target = '9.0'` to the podspec.

And incase you'd like some Gemfile cliffnotes for tvOS support in Cocoapods: :ok_hand: 

```
source 'https://rubygems.org'

gem 'cocoapods', :git => 'https://github.com/CocoaPods/CocoaPods.git', :branch => 'tvos'
gem 'cocoapods-core', :git => 'https://github.com/CocoaPods/Core.git', :branch => 'tvos-support'
gem 'xcodeproj', :git => 'https://github.com/CocoaPods/Xcodeproj.git', :branch => 'tvos-support'
```
 Thanks for that. I'll merge your pull request with that tomorrow.
 No worries. Glad I could help.
 It's not directly related to this, anyway I'm getting the same error on XCode 7.1 / tvOS 9.0 (13T5347l) and AppleTV DevelopmentKit, but it's related maybe to CocoaPods issue described here: https://github.com/CocoaPods/CocoaPods/issues/3586

dyld: Library not loaded: @rpath/ObjectiveLyricsTouchTV.framework/ObjectiveLyricsTouchTV
  Referenced from: /var/mobile/Containers/Bundle/Application/DD87E506-BA2A-47E6-8772-CEE7E1B57FD4/AppTestbedTV.app/AppTestbedTV
  Reason: image not found
 That sounds to me like you haven't actually added the framework "ObjectiveLyricsTouchTV.framework" to your target. Nothing specifically related to Alamofire.

Check your "Build Phases" and then "Embedded Binaries". Might be you need to add that framework there. (Either there or in "Linked Frameworks and Libraries").
 Thank you,  sorry it was not directly related to Alamofire but not so docs about The AppleTVDevKit so far! I will check it out.
 @Baza207 If can help someone in the future I get it working putting the framework in both "Linked Frameworks and Libraries" and "Embedded Binaries". Thanks!
 @loretoparisi I would move this to [StackOverflow](http://stackoverflow.com), as that's the better place to ask this type of question. Issues in GitHub projects are more for issues or bugs with the respective repo only.

I'm in SO with the same username if you want to try and @ me.
  I'm using the Result framework here: https://github.com/antitypical/Result and it's conflicting with the Result type in Alamofire 2.0 in my files where I import both. The Alamofire Result is pretty barebones and could probably be completely replaced with the dedicated Result framework, and extended for any convenience methods needed.
 The problem is that using the framework namespace don't work when the framework name is the same as another type. There's more info on this issue: https://github.com/antitypical/Result/issues/77
 No problem, thanks for the explanation. My request stemmed from the fact that since the dedicated result framework's module name is also result, the compiler gets confused when importing both and won't let me reference the other one. I have found a workaround that is suitable though so that I can keep using both Alamofire and result.

Thanks for the response!
 I appreciate that it's your call, but I really don't see a disadvantage to using the existing framework ‚Äî yes it introduces a dependency, but the whole point of having Alamofire as a framework generally is that it is a dependency which it is easy to add to a project.

And yes, the Result framework is a little more complicated than the `Result` type provided in Alamofire... but not much more ‚Äî a bit over twice the number of lines of code used for the `Result` object (already not much) in Alamofire and it includes lots of nice convenience methods for handling / chaining on it. The kind of thing that would be useful when using Alamofire to better handle errors. Using a `Result` object is definitely a good idea, but you would either expect to make one that rivals existing ones so that it could be used throughout a project, or use an existing one.
 @cnoon I can understand that you don't want to have problems because of breaking Swift updates but hopefully they are behind us now (and in any event, they would entail changes to the Alamofire library too, and the Result library is likely to be faster to react because they seem to be on the cusp for the latest versions and it is also a much smaller library). Result also uses semantic versioning for releases which should ensure backwards compatibility.

Although I can understand the worries with adding dependencies (it takes some of the control out of your hands and potentially involves extra work ensuring compatibility) I would argue that this is what open source is about. I know that many libraries depend on AFNetworking (hopefully they'll all upgrade to Alamofire soon), often as a non-explicit dependency, but by your argument they should not because of all the problems dependencies bring. But generally they do this because the core part of their library is about something other than networking, and there is no point in re-inventing the wheel. I would say that the `Result` object is not a core part of Alamofire, but is part of a much wider programming paradigm and as such, you might as well use it. To people using Alamofire via CocoaPods or Carthage this will be transparent, since this is what they are using a dependency manager for (and I suspect that most people are integrating Alamofire in this way). Nothing stops you changing this dependency later (versioning should ensure that people have the appropriate version).

With regards the special capability of the Alamofire `Result` object, to include a `data` object with the failure, I would say that this data should be part of the error object itself (what the old `userInfo` would carry, and easy to add to any object that conforms to `ErrorType`).

You say that the `Result` object is not intended to be used much outside of Alamofire, but as part of the method results for the most important parts of the framework it is obviously going to be used, and while we can always map one type of object to another, there seems little point in forcing those extra steps. I would say that Alamofire is one of the best examples of a framework where you would expect to be using a generic `Result` object because networking requests are a very good use case for them.

Sorry for the length of the reply, and I respect whatever decision is made, but in terms of arguing the case, I do feel strongly that it is worth using other libraries as opposed to re-inventing what already exists. The whole point of using dependency managers is that this is now a painless exercise.
  ``` swift
class Downloader {

var mngr:Manager

    init(name:String?, id:String?) {
        let cfg = defaultCfg
        self.mngr = Manager(configuration: cfg)
    }



func downloadData(success: (UIImage) -> Void, failure: (NSHTTPURLResponse?, AnyObject?, ErrorType) -> Void) {
        let sourceURL = "http://www.example.com/test.png"

        self.mngr.request(.GET, captchaURL,headers:headers)
            .response { (_,response, data, error) in
                if error != nil {
                //uncomment following line to fix the error
                //    _ = self.mngr 
                    failure(response,data,ErrorMessage.ServerError)
                    return
                } else {
                    let img = UIImage(data: data! )
                    if img != nil {
                        success(img!)
                    } else {
                        failure(nil,nil,ErrorMessage.ImageError)
                    }
                }
        }
    }

}
```

If I use this function I get `Error Domain=NSURLErrorDomain Code=-999` I think it is because of some retain issue. However if I add `_ = self.mngr` inside response block it works. I am really puzzled. 

I am using Xcode 7 Beta 6 Swift 2.0.b4 and tested on iOS 8.4 device.
  I have this method to contact my REST webservice. I want to generate an exception when or connection fails. Xcode tells me that I can not use a function throw VendingMachineError.InvalidSelection because the method .responseJSON {(request, response, JSON) in ecc ... can not do the conversion. How can I fix this? thanks for your help. 
![schermata 2015-09-11 alle 21 05 36](https://cloud.githubusercontent.com/assets/5178424/9826363/e329d43c-58d9-11e5-9afa-136b096a8cd7.png)
 Thanks for the reply .. Unfortunately I made many attempts but I always get the error.
You have a sample code?
thank you
 Hi there, i'm having the same issue... i think that if you would allow the responseJSON to throws, we could do rethrows and it would works just fine, or i'm missing something?
 cnoon i'm sorry you right, you think that apple will change that in a near future? or in terms of design is just fine and we need to do a workaround?
 I spent 10 days to find a solution to this problem without results. the only solution that I could find and to remove throws and add inside function .Failure
completionHandler (element: nil, error: ErrroType)
  Greetings Programs!

I installed the framework as per the instructions and it works perfectly on the simulator but when I try to deploy it to the iPad Air, I receive this error:

dyld: Symbol not found: _OBJC_CLASS_$_NSURLSessionStreamTask
  Referenced from: /private/var/mobile/Containers/Bundle/Application/6C0EEFA5-82C7-4667-B4A2-9315E7FB0317/iApprove.app/Frameworks/Alamofire.framework/Alamofire
  Expected in: /System/Library/Frameworks/CFNetwork.framework/CFNetwork
 in /private/var/mobile/Containers/Bundle/Application/6C0EEFA5-82C7-4667-B4A2-9315E7FB0317/iApprove.app/Frameworks/Alamofire.framework/Alamofire

Thanks!

Wg
 Hi kylef!

I'm using iOS 9.0 beta on the iPad. I installed it by:
1. Dragging Alamofire.xcodeproj into the projects navigator
2. Added the top Alamofire.framework to Embedded Binaries in my project's target.
3. Also set the deployment targets to 9.0 in the Alamofire project.

Thanks!

Wg
 It would appear that it was the iOS version.

Unfortunately iTunes wouldn't let me restore to the 9 GM seed so I had to restore to the 9.1 beta then it let me restore down to 9. After updating XCode to the 7 GM seed as well, I was able to deploy to the device.
  Added tvos support to Alamofire

Dependant on tvos branch of https://github.com/CocoaPods/CocoaPods
 No problem. I just did what worked for me I figured there is more changes that need to be done.
  Probably a noob issue, but I created a Cartfile and added `github "Alamofire/Alamofire" "swift-2.0"` to it.  When I run  `carthage update` I get the error:  `Failed to check out repository into  Users/myuser/Library/Caches/org.carthage.CarthageKit/dependencies/Alamofire: No object named "swift-2.0" exists`
 Duplicate of https://github.com/Alamofire/Alamofire/issues/749
  Why doesn't `Result` have two generics, one for the value and one for the error type?

This would allow us to know what type of error we should expect and access properties on the error based on its type. Custom serializers should still be able to return their own `ErrorType`, while the current `Alamofire` serializers can use a `Result` with `NSError`.
 there's a dedicated result framework here: https://github.com/antitypical/Result
Alamofire should just have this as a dependency and extend it as needed.
 @klundberg This framework seems to do what I'm describing. Either way, it doesn't really hurt for Alamofire to use it's own `Result`. It is easy to implement, and allows for more possible customization later. 

But having the error being part of the generic seems like the right way to go.
 I would vote to use the dedicated `Result` framework too ‚Äî there's no point in re-inventing the wheel, and this would allow compatibility with other frameworks that use it.
  I see that `request` `encoding` is defaulted to `ParameterEncoding.URL`. Would be great to be able to change the default on the `Manager.sharedInstance` instead of on each `request`. Is there a way to change the default encoding type for `request`? 
 Thanks for your consideration
  I am testing master branch with Swift 1.2 on Xcode 6.4. When Url has space inside it crashes. Example usage

``` swift
let url = "http://www.example.com/abc/def.asp?k=abc def"

self.mngr.request(.GET, url)
```

Crashing function:

``` swift
// MARK: - Convenience
func URLRequest(method: Method, URLString: URLStringConvertible, headers: [String: String]? = nil) -> NSMutableURLRequest {
    let mutableURLRequest = NSMutableURLRequest(URL: NSURL(string: URLString.URLString)!) //crash!
    mutableURLRequest.HTTPMethod = method.rawValue 

    if let headers = headers {
        for (headerField, headerValue) in headers {
            mutableURLRequest.setValue(headerValue, forHTTPHeaderField: headerField)
        }
    }
    return mutableURLRequest
}
```

If I use `parameters` and use it like below

``` swift
let url = "http://www.example.com/abc/def.asp"
let parameters = ["k":"abc def"]
self.mngr.request(.GET, url,parameters:parameters)
```

It doesn't crash.
 Alamofire properly encodes if it is given as parameters. However it is not always possible to use parameters for every request. I believe that Alamofire should URL encode give string. Since Alamofire wants String as input and it converts to URL thanks to URLStringConvertible. If Alamofire required URL as input, then it was the responsibility of developer to give proper URL. Instead of implicitly unwrapped optional, simple check for URL can solve this problem.Just my 2 cents.
 What I mean is, Alamofire could check if URL is valid instead of implicitly unwrapping it. Another way is encoding URL with something like escape function in ParameterEncoding.swift. I refactored all my code to use either parameters and when there are no parameters I use string extension to escape. 
 Thanks for the comment. I can understand that you don't want to increase complexity. However instead of implictly unwrapping we could check for correct URL and return error. I believe that failing is better than crashing. Best regards.
  Hi guys!

I'm creating a mutable request as follows:

```
var mutableRequest = ParameterEncoding.JSON.encode(URLRequest(method, completeURL!, headers: nil), parameters: parameters).0
```

Whenever I want to pass the var as an inout property to a helper function of mine which does some custom header modification I receive an EXC_BAD_ACCESS because a message was sent to a deallocated object:

```
*** -[NSMutableURLRequest retain]: message sent to deallocated instance 0x7f97a0107dd0
```

Any idea what could cause that issue and how I could circumvent it?
 Is there any chance someone else is experiencing this issue or would have any idea on hot to resolve this? Really desperate for a solution ...
  There are a couple of instances where a check such as this is performed:

``` swift
#available(OSX 10.10, *)
```

Because of that, the code will not compile using Xcode 7 with a deployment target of iOS 7.0.
Most of these would need to be:

``` swift
#available(iOS 8.0, OSX 10.10, *)
```

Is it intentional and iOS 7 fully unsupported?
  Hey I just update Alamofire swift and I'm getting compile errors, I'm using cocoapods as dependency like this 
   s.dependency 'Alamofire','~> 2.0'

I get 198 erros, Do I need to do something else?
  Now that the `swift-2.0` branch has been merged and deleted the migration guide is located on the `master` branch.
  I tried installing Alamofire on two machines with error.

[!] Error installing Alamofire
[!] /usr/bin/git clone https://github.com/Alamofire/Alamofire.git /var/folders/lp/xmgfh1cd37b52zkr63vlk7hc0000gn/T/d20150909-652-mxmpi8 --single-branch --depth 1 --branch swift-2.0

Cloning into '/var/folders/lp/xmgfh1cd37b52zkr63vlk7hc0000gn/T/d20150909-652-mxmpi8'...
warning: Could not find remote branch swift-2.0 to clone.
fatal: Remote branch swift-2.0 not found in upstream origin
 You'll need to update to no longer use the Swift 2.0 branch. It has been merged to master and is now deleted.
 everything works with updated notes, thanks!
  When the library is included as source for projects targetting iOS 7.0, the compiler fails because of this compatibility check.
  I am having an issue with upload speed. It is very slow and i cannot figure out how to sort it out. I have tested dropbox for a 10mb file and it finishes in 2-3 minutes, whereas with my ap it takes 5 times as long, i didn't even calculate the exact time cause it was taking way too long. I have tested the upload request on the mac with RESTClient and it took around 2 minutes so it isn't the server. Here is the code i use for uploading.

edit: i also just tried on the simulator and it works fast there as well, so i am stumped.

``` swift
Alamofire.upload(
    .POST,
    URLString: "http://example.com/upload",
    multipartFormData: { multipartFormData in
        multipartFormData.appendBodyPart(fileURL: self.tempVideo, name: "video", fileName: "video.mp4", mimeType: "video/mp4")
        multipartFormData.appendBodyPart(data: thumbData, name:"thumb", fileName: "thumb.jpg", mimeType: "image/jpeg")
        multipartFormData.appendBodyPart(data: "27".dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!, name: "userId")
        multipartFormData.appendBodyPart(data: "This is the body text.".dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!, name: "body")
    },
    encodingMemoryThreshold: 60_000_000,
    encodingCompletion: { encodingResult in
        switch encodingResult {
        case .Success(let upload, _, _):
            upload.progress { (bytesWritten, totalBytesWritten, totalBytesExpectedToWrite) in
                println("\(totalBytesWritten) / \(totalBytesExpectedToWrite)")
                dispatch_async(dispatch_get_main_queue(),{
                    self.HUD.setProgress(Float((totalBytesWritten*100)/totalBytesExpectedToWrite)/100, animated: true)
                })
            }
            upload.responseJSON { (request, response, JSON, error) in
                dispatch_async(dispatch_get_main_queue(),{
                    self.HUD.dismiss()
                })

                println("JSON \(JSON)")

                ..... my completion code
            }
        case .Failure(let encodingError):
            println(encodingError)
        }
    }
)
```
 @silver619 When you're testing DropBox (i.e. DropBox CLI?), RestClient, and iOS clients, where's the physical server in relationship to the client which is initiating the upload?
 Dropbox as in dropbox app on the iphone, i wanted to see if any other apps on the device had the same issue, and that wasn't the case.

The server i am uploading to is a hostgator server. RESTClient is a software on the mac that i use to test restful services. Upload worked fine on that. It also worked fine on the ios simulator on the same mac. The only issue is occurring on the app on the iphone itself, same iphone that dropbox upload is working fine on.
 i had tried without the "encodingMemoryThreshold" statement, and it was the same. The encoding itself isn't really taking time, its instant. I just tried again, with the number i set "60000000", with "0" and without the line at all. And same thing, encoding happens instantly, upload is really slow.
 I check the network diagnostics in xcode and the only thing its showing is for the upload. I am not sure what else could be the issue.
 Just to ensure it was nothing else from my side i created a new single view project and entered code only for alamofire, with no other frameworks involved. I hav ethe same outcome. Upload is slow on the device, takes longer than i would care to wait for, whereas on the simulator it is done in 2 minutes for a 10mb video file and one small image. Other uploads on other apps on the device seem to be working fine. Here is the code  i used, without the address of course:

edit: also the device is an iphone 6 64mb

``` swift
@IBAction func buttonAction(sender: AnyObject) {

        // thumbData
        let thumbData = UIImageJPEGRepresentation(UIImage(named: "thumb.jpg"), 0.5)

        Alamofire.upload(
            Alamofire.Method.POST,
            URLString: "http://example.com/upload",
            multipartFormData: { multipartFormData in
                multipartFormData.appendBodyPart(fileURL: NSBundle.mainBundle().URLForResource("video", withExtension: "mp4")!, name: "video", fileName: "video.mp4", mimeType: "video/mp4")
                multipartFormData.appendBodyPart(data: thumbData, name:"thumb", fileName: "thumb.jpg", mimeType: "image/jpeg")
                multipartFormData.appendBodyPart(data: "27".dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!, name: "userId")
                multipartFormData.appendBodyPart(data: "This is the body text.".dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!, name: "body")
            },
            encodingCompletion: { encodingResult in
                switch encodingResult {
                case .Success(let upload, _, _):
                    upload.progress { (bytesWritten, totalBytesWritten, totalBytesExpectedToWrite) in
                        println("\(totalBytesWritten) / \(totalBytesExpectedToWrite)")
                    }
                    upload.responseJSON { (request, response, JSON, error) in

                        //println("REQUEST \(request)")
                        //println("RESPONSE \(response)")
                        println("JSON \(JSON)")
                        //println("ERROR \(error)")

                        if let jsonResult = JSON as? NSDictionary {
                            let status = jsonResult.objectForKey("status") as! String
                            let videoURL = jsonResult.objectForKey("videoURL") as! String
                            let thumbURL = jsonResult.objectForKey("thumbURL") as! String
                            println("jsonresult: \(jsonResult)")
                            if status == "success" {

                            } else {
                                var alert = UIAlertController(title: "Upload Error", message: "There was an error uplaoding to the server, please try again. If this error continues then please contact our support.", preferredStyle: UIAlertControllerStyle.Alert)
                                alert.addAction(UIAlertAction(title: "OK", style: UIAlertActionStyle.Default, handler: nil))
                            }
                        }
                    }
                case .Failure(let encodingError):
                    println(encodingError)
                }

        })
    }
```
 @silver619 did you find anything on this?
I'm facing the same problem on simple .post request
The body is about 100kb and response data is also about 100kb.
Measuring same request on same network 10 times on mac and simulator takes 5seconds(avg), but takes about 14 seconds(avg) on the device...
Which is really important because it's about refreshing all contacts statuses on the server, and more contacts, more body size!!

This even annoys me on some lvl because 100kb is not much!! Why would it take about 14seconss latency on the device? While it would take 3 on the same networkv
  I'm relying on Alamofire to set the MIME type for multipart form uploads and working with an API that also requires the MIME type to be set in the body.

Currently there seems to be no way to access the MIME type that is determined by Alamofire and I'd prefer not add my own implementation.

`mimeTypeForPathExtension` could be made `public` but that would mean having to replicate some of the logic that `appendBodyPart` employs when calling it.

Perhaps instead, `appendBodyPart` could return a `BodyPart` and expose a `mimeType` property.

If this sounds reasonable I'll submit a pull request. I'd also love to hear any other ideas.

/cc @cnoon 
 It turns out I don't need this but it might be useful for others. Feel free to close.
  When I copy the sample CRUD and Authorization code for `URLRequestConvertible` into my project, the compiler throws a "Type Router does not conform to protocol 'URLRequestConvertible'". I get the same result when starting from scratch with an empty `enum`.

Same result when creating an enum conforming to `URLStringConvertible`.

Using Xcode 7 beta 6 (but problem has been around for a couple of beta versions now) and Alamofire 2.0 beta 4
  I think this looks like a pretty sensible solution. I'm cool with it.
  This will make `cURLRepresentation()` much more reusable. A user could
use it with an NSURLRequest object outside of Alamofile
  I'm following the [example in the README](https://github.com/Alamofire/Alamofire#uploading-multipartformdata) and no matter what I do I see a failure in trying to create a request.

I've stepped through in the debugger, but can only get as far as this:

<img width="687" alt="screen shot 2015-09-05 at 12 13 25 am" src="https://cloud.githubusercontent.com/assets/84700/9698361/470a31cc-5367-11e5-8e0f-0916e5daf712.png">

I set a breakpoint on line 39 but it is never reached.

I'm using Alamofire 1.3.1 and Xcode 6.4 (6E35b). I can reproduce this on device with an iPhone 5 running iOS 8.4 (12H321) and in the simulator with an iPhone 6 running iOS 8.4 (12H141).

Any advice on how to further debug this would be much appreciated.

More information below. Thanks

<img width="358" alt="screen shot 2015-09-05 at 12 46 16 am" src="https://cloud.githubusercontent.com/assets/84700/9698385/1800b63e-5368-11e5-963b-e1d70d8731f3.png">

<img width="734" alt="screen shot 2015-09-05 at 12 45 43 am" src="https://cloud.githubusercontent.com/assets/84700/9698387/21a17a0c-5368-11e5-9101-89e101e0a0a7.png">

<img width="631" alt="screen shot 2015-09-05 at 12 45 11 am" src="https://cloud.githubusercontent.com/assets/84700/9698388/21a21a3e-5368-11e5-83b2-c1fc679021ad.png">
 I've created a [demo project](https://github.com/paulyoung/MultipartFormDataIssue) to illustrate this and it seems that the cause is due to using a [`manager`](https://github.com/paulyoung/MultipartFormDataIssue/blob/218aed6a50cd0ccb9e0a04774531593be8a4f7de/MultipartFormDataIssue/AppDelegate.swift#L24) whose [`configuration`](https://github.com/paulyoung/MultipartFormDataIssue/blob/218aed6a50cd0ccb9e0a04774531593be8a4f7de/MultipartFormDataIssue/AppDelegate.swift#L22) allows operations in the background.
 The demo project makes it much clearer:

`Terminating app due to uncaught exception 'NSGenericException', reason: 'Upload tasks from NSData are not supported in background sessions.'`
 Alamofire [currently does this](https://github.com/Alamofire/Alamofire/blob/0af6d647f7c1c8787e9faa1d95704285bcf332f3/Source/Upload.swift#L39):

``` swift
uploadTask = self.session.uploadTaskWithRequest(request, fromData: data)
```

which results in the error in my previous comment.

It appears that people are currently doing this outside of Alamofire like so:

``` swift
let request = NSMutableURLRequest(URL: url)
request.HTTPMethod = "POST"
request.HTTPBody = data
session.uploadTaskWithRequest(request, fromData: nil)
```

However, when I updated Alamofire to use this approach in my demo project I received the following error:

`Error Domain=NSURLErrorDomain Code=-999 "cancelled" UserInfo=0x7f8ea390f1f0 {NSErrorFailingURLStringKey=http://httpbin.org/post, NSLocalizedDescription=cancelled, NSErrorFailingURLKey=http://httpbin.org/post}`
 OK, once I make sure that `manager` is retained that error goes away and I get the following JSON response:

```
{
    args =     {
    };
    data = "";
    files =     {
    };
    form =     {
        foo = bar;
    };
    headers =     {
        Accept = "*/*";
        "Accept-Encoding" = "gzip, deflate";
        "Accept-Language" = "en-us";
        "Content-Length" = 131;
        "Content-Type" = "multipart/form-data; boundary=alamofire.boundary.789baeeace7d721a";
        Host = "httpbin.org";
        "User-Agent" = "MultipartFormDataIssue/1 CFNetwork/711.4.6 Darwin/14.4.0";
    };
    json = "<null>";
    origin = "73.202.148.89";
    url = "http://httpbin.org/post";
}
```
 To summarize, I replaced:

``` swift
case .Data(let request, let data):
    dispatch_sync(queue) {
        uploadTask = self.session.uploadTaskWithRequest(request, fromData: data)
    }
```

with:

``` swift
case .Data(let request, let data):
    dispatch_sync(queue) {
        let r = request.mutableCopy() as! NSMutableURLRequest
        r.HTTPBody = data
        uploadTask = self.session.uploadTaskWithRequest(r, fromData: nil)
    }
```

Clearly this is a bit of hack, but something similar might be a way to implement this without introducing breaking changes.

@cnoon could I get some input from you here please?
 @cnoon no problem at all.

I hope my comment wasn't taken the wrong way, I just felt that I'd maybe done all I could and that it was a good time to discuss with someone more familiar with the code base.
 Thanks!
 Are there plans to make a release that includes this anytime soon?
 @cnoon it would be great if this made it into a Swift 1.2-compatible release too.
 :raised_hands: 
 I was just about to comment and say the same thing. Thanks for the tip!
 I am having the same issue , is it mandatory to for background upload to have a file path.
Can't we do with Data in background.  ```
println("\(totalBytesRead) of \(totalBytesExpectedToRead)")
```

prints out the following to the console.
815 of -1
895 of -1
2263 of -1
3631 of -1
4999 of -1
6367 of -1
7735 of -1
9095 of -1
10463 of -1
11831 of -1
13199 of -1
14567 of -1
15935 of -1
17296 of -1
17616 of -1

I'm not sure what other information I can provide. The download works perfectly, it's just that the progress is being reported incorrectly.
 -1 corresponds to `NSURLSessionTransferSizeUnknown`, which usually means your server isn't properly returning a `Content-Length` header. Can you check your response headers and see?
 Thank you guys. That seems to be the problem. If only I knew how to have the header contain the conent length haha
  **Added notes:**
- the image is optional; users generated without image is fine
- breakpoint verified data is not nil 

**Code:**

``` swift
var params: [String : AnyObject] = [:]
params["email"] = email
params["password"] = password
params["first_name"] = firstName
params["last_name"] = lastName

// Including a base 64 encoded image is triggering a crash in xcode 6.4
if let image = avatar {
    var imageData = UIImagePNGRepresentation(image).base64EncodedDataWithOptions(
        .Encoding64CharacterLineLength
    )
    params["image"] = imageData
}

Alamofire.request(.POST, request, parameters: params, encoding: .JSON, headers: self.defaultHeaders())
    .response { request, response, data, error in
         print(error)
    }
```
  I agree! So I ported it over and it's been working great

```
    /**
        Remove all NSNull values from a JSON object
    */
    public static func JSONObjectByRemovingKeysWithNullValues(JSONObject: AnyObject) -> AnyObject {
        switch JSONObject {
        case let JSONObject as [AnyObject]:
            return JSONObject.map { JSONObjectByRemovingKeysWithNullValues($0) }
        case let JSONObject as [String: AnyObject]:
            var mutableDictionary = JSONObject
            for (key, value) in JSONObject {
                switch value {
                case _ as NSNull:
                    mutableDictionary.removeValueForKey(key)
                default:
                    mutableDictionary[key] = JSONObjectByRemovingKeysWithNullValues(value)
                }
            }
            return mutableDictionary
        default:
            return JSONObject
        }
    }
```
    currently reading the documentation it's impossible to send raw json content, already codified in a string, via AlamoFire : 

"{ "a" : "b", "c" : "d", "f" : {"h":"i"},  and the object goes on and on... }"

is there any workaround not present in the docs? 

if not, could this be considered as a required upgrade?
 as i said, "if not, could this be considered as a required upgrade?" , being unable to create a alamofire instance with a String chain as "params" or as "body" in the Alamofire.request(.POST,etc...) , and having to separately create a Request variable,  transform string into codified NSDATA and applying it to the request's HTMLbody property does not seem the appropiate way of doing it, i had already searched in SO, but thanks (really, i just came here when SO's search engine ran out of ideas). 
   '[String]' does not have a member named 'joinWithSeparator'
 Are you on XCode 7 Beta 6?
  Sorry to be late to the party, but I was wondering why you used NSError instead of the `ErrorType` protocol. This is related to PR #627.

My REST client uses Alamofire and in case of error returns an enum conforming to `ErrorType`. I also want to add custom validation. It feels a bit wrong to have my validation return an `NSError` then having to translate it later into my `ErrorType` when I return my result. 

From what I saw, in the code, all errors are bound to `Error.Code` so there will never be an "extra" NSError somewhere that prevents to use `ErrorType`.

Any thoughts? 
 Also the `Result` type does indeed use `ErrorType` and not `NSError`.
 So you confirm that if I want to add a custom validation step, I will need to return an `NSError` wrapped in a `ValidationResult.Failure(NSError)`, then have to unwrap in in my `responseString` call to convert it into my custom ErrorType ?

That odd. I really don't get why a `ValidationResult.Failure` would always require an `NSError`. 

For example with a custom validation:

```
enum MyErrors: ErrorType {
    case LeetError
}

let myDomain = "myDomain"

func callback(val: String?, _ error: ErrorType?) {
    print(val)
    print(error)
}

Alamofire.request(.GET, "http://httpbin.org/get")
    .validate({ (req, res) -> Request.ValidationResult in
        let nserror = NSError(domain: myDomain, code: -1337, userInfo: nil)
        return .Failure(nserror)
    })
    .responseString { _, _, result in
        switch result {
        case .Success(let val): callback(val, nil)
        case .Failure(_, let error as NSError) where error.domain == myDomain && error.code == -1337:
            callback(nil, MyErrors.LeetError)
        case .Failure(_, let error): callback(nil, error)
        }
}
```

I feel that my custom validation should be allowed to return directly a `MyError`, and it would not break anything from Alamofire. Since I do my own validation, I have to be aware that I will receive any kind or error.

What do you think ?
 @jschmid I have a project that does largely the same thing, but uses a `GenericResponseSerializer` to encapsulate the response parsing (using Argo for the JSON parsing). As you can see I wrap all errors, even the `NSError`s from Alamofire in my own error enum. Perhaps wrapping earlier in the parsing process will make your consumed API a bit cleaner.

``` swift
extension Request {
    func responseObject<T: Decodable where T == T.DecodedType>(completionHandler: (responseObject: T?, error: CloudFlareError?) -> Void) -> Self {
        let fullCompletionHandler = { (request: NSURLRequest?, response: NSURLResponse?, result: Result<T>) in
            switch result {
            case let .Success(value):
                completionHandler(responseObject: value, error: .None)
            case let .Failure(_, error):
                if let error = error as? CloudFlareError {
                    completionHandler(responseObject: .None, error: error)
                }
                else if let error = error as? NSError {
                    // Must have received a network error.
                    completionHandler(responseObject: .None, error: CloudFlareError.NetworkError(error: error))
                }
                else {
                    fatalError("ResponseObject received an error that was neither a CloudFlareError nor an NSError.")
                }
            }
        }

        return response(responseSerializer: Request.CloudFlareResponseSerializer(), completionHandler: fullCompletionHandler)
    }

    static func CloudFlareResponseSerializer<T: Decodable where T == T.DecodedType>() -> GenericResponseSerializer<T> {
        return GenericResponseSerializer { (request, response, data) -> Result<T> in
            guard let validData = data else {
                let failureReason = "Tried to decode response with nil data."
                let error = Error.errorWithCode(.DataSerializationFailed, failureReason: failureReason)
                return .Failure(data, CloudFlareError.SerializationError(error: error))
            }

            let JSONSerializer = Request.JSONResponseSerializer(options: .AllowFragments)
            let JSONResult = JSONSerializer.serializeResponse(request, response, validData)
            guard case let .Success(responseJSON) = JSONResult else {
                return .Failure(data, CloudFlareError.SerializationError(error: JSONResult.error! as NSError))
            }

            let decodedCloudFlareResponse = CloudFlareResponse.decode(JSON.parse(responseJSON))
            guard case let .Success(cloudFlareResponse) = decodedCloudFlareResponse else {
                let errorString: String
                switch decodedCloudFlareResponse {
                case let .TypeMismatch(error):
                    errorString = error
                case let .MissingKey(error):
                    errorString = error
                default:
                    errorString = "Should never see this."
                }

                return .Failure(data, CloudFlareError.DecodingError(decodedString: errorString))
            }

            if !cloudFlareResponse.success {
                return .Failure(data, CloudFlareError.ResponseError(response: cloudFlareResponse))
            }

            let decodedResponseObject = T.decode(cloudFlareResponse.result)
            guard case let .Success(responseObject) = decodedResponseObject else {
                let errorString: String
                switch decodedResponseObject {
                case let .TypeMismatch(error):
                    errorString = error
                case let .MissingKey(error):
                    errorString = error
                default:
                    errorString = "Should never see this."
                }

                return .Failure(data, CloudFlareError.DecodingError(decodedString: errorString))
            }

            return .Success(responseObject)
        }
    }
}
```
 Thanks @jshier. I also return errors during deserialization. However, some errors are not related to the deserialization. 

Like for some request I want to allow only the 200 status, for some I want to allow 200..<300. (That's just an example). This is to my view a validation problem, not a deserialization problem. When validating this, I want to return an error directly related to the HTTP status code for example. Using the `validate(statusCode:)` method does not help since it does not give the status code in its NSError. 
 @cnoon I think my question is:

> Why does `ValidationResult.Failure` only accept `NSError`s when it could - at no apparent cost - accept any `ErrorType` and make the validation more generic (and swiftier)?
 Thanks @cnoon ! :rocket:
  CJK letters were broken when I sent strings with POST method.
I think this charset should be a default set because the NSData is made with NSUTF8StringEncoding.

mutableURLRequest.HTTPBody = query(parameters!).dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)
  i'm sorry to trouble you.but i can find witch the function can setup the connection timeout value.can you help me?
  **TL;DR**: Writing code that creates an `Alamofire.Request` from a method, a path, a set of query string parameters, form fields, and (possibly) file uploads is more difficult than expected.

This is a pretty big and undefined issue so I apologize for that in advance, but I'm hoping it might start a constructive discussion on a problem I've run into (or at the very least tell me I'm doing things wrong and there's a better way :)

I'm writing code to interface with the API for our app. To give some context, a request to our API may be `GET`, `POST`, or `DELETE`, it may take query string parameters, form parameters (either as HTTP body query string or multipart fields), and file uploads (as named multipart fields).

I decided to use Alamofire to perform network requests, and early on I found `URLRequestConvertible` to be a useful abstraction. But the moment I needed to upload files my code started branching and I had to separate code out of the `URLRequestConvertible` implementation into separate methods which need to be called when constructing multipart form data.

Here's the function that takes an intent (an `enum`) and converts it to the necessary HTTP information which is used to perform the request with Alamofire:

``` swift
func request(intent: Intent, callback: Callback) {
    let requestInfo = self.getRequestInfo(intent)

    // Branch depending on whether there is a file to upload.
    if requestInfo.files.count > 0 {
        Alamofire.upload(
            requestInfo,
            multipartFormData: {
                requestInfo.applyMultipartFormData($0)
            },
            encodingCompletion: { result in
                switch result {
                case let .Success(request, _, _):
                    self.handleResponse(intent, request, callback)
                case let .Failure(error):
                    callback(object: nil, error: error)
                }
            }
        )
    } else {
        let request = Alamofire.request(requestInfo)
        self.handleResponse(intent, request, callback)
    }
}
```

The apparent problem here is that I'm having to branch code outside of my `RequestInfo` class which implements the `URLRequestConvertible` protocol (which initially seemed a promising way to only have to do `Alamofire.request(requestInfo).response‚Ä¶`).

Furthermore, since I have to treat form fields differently between multipart form data and regular URL encoded data in the HTTP body, I'm also branching inside the `URLRequest` property of my `RequestInfo` class:

``` swift
var URLRequest: NSURLRequest {
    var request = NSMutableURLRequest(URL: self.url)

    if let token = self.session?.accessToken {
        request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
    }

    // Add the query string parameters to the path. Form fields or files are not added here.
    if self.queryString.count > 0 {
        (request, _) = Alamofire.ParameterEncoding.URL.encode(request, parameters: self.queryString)
    }

    // Apply method after query string so that Alamofire doesn't put it in the HTTP body.
    request.HTTPMethod = self.method.rawValue

    // Apply form data here if there are no files to upload.
    if self.form.count > 0 && self.files.count == 0 {
        precondition(self.method == .POST, "Form data can only be added to POST requests")
        (request, _) = Alamofire.ParameterEncoding.URL.encode(request, parameters: self.form)
    }

    return request
}
```

As you can see I'm only conditionally including the form data here (otherwise I apply it in the `applyMultipartFormData` method). This makes the code a bit smelly on my end. Also, it would be nice to have a better way to control what goes on the query string and what goes in the form data, even when making a regular POST request, other than the workaround I'm using (or reimplementing a custom encoder).

So my feature request is essentially a streamlined way to construct `Alamofire.Request` which is either a file upload or a regular GET/POST request without having to branch the code so much. I hope this input is relevant and let me know if there's any additional information I can provide, or if there's any way I can help out.
 Thank you for your response @cnoon.

I can see why you'd say they are fundamentally different requests, but that is at a technical level which shouldn't need to be so prevalent for the API user. The different requests I mentioned above are not, from a semantical perspective, very different. As an example, let's have a look at Facebook's API endpoint for creating a photo in an album (https://developers.facebook.com/docs/graph-api/reference/v2.4/album/photos#publish).

When creating a photo you get to choose whether you want to set the `source` field (which is multipart form data) or if you set the `url` field (which is just a string parameter). At its simplest I might expect this to look something like:

``` swift
let request = Request.post("https://graph.facebook.com/v2.4/\(albumId)/photos")
// pick either:
request.file(myPhotoFile, field: "source").‚Ä¶
// or:
request.form("http://lorempixel.com/400/400/cats/", field: "url").‚Ä¶
```

I would say the above exactly captures the choice given by the Facebook API. Now what actually happens is of course different under the hood (and the technical implementation of multipart data is more complex than simple POST query string data). But as the person making HTTP calls I really don't care, and I don't think this API stops people who want to customize further from doing so (as you said, chaining can be powerful and that applies here too).

I guess my biggest gripe is that Alamofire split out a content encoding difference (query string vs. multipart) into different high level code paths, and I have to do a lot of branching in my code to accommodate for that fact. Now if I'm missing something obvious, please let me know.

Finally, I still think it's strange that Alamofire doesn't let me choose what data to put in the query string and what to put in the HTTP body. Having that ability is quite important for logging transparency reasons.
 I think I might not have made my original example very clear then, because I'm not doing anything different in my code than the Facebook example I made. I have one data structure per endpoint (technically it's an `enum`). The problem for me is that I had to do quit a bit of abstraction on my end rather than relying solely on Alamofire. One issue is that `URLRequestConvertible` simply can't represent the full state of a request (for multipart form data specifically, and as a lesser issue the query string vs form data), which requires me to leak information outside that class.

For the case of `MultipartFormData`, I am of the opinion that a library should be designed to make common cases easy, and I believe the streaming-from-disk you speak of doesn't occur until something is 10 MB or larger. This seems to me to be a pretty rare case with the exception of video, and shouldn't have to hamper all other use of the library.

In terms of API design, I would say it sounds like you guys need streamable HTTP body support more than specifically built-in multipart handling. Now I might be unaware of `NSURLSession` internals that stop you from doing this, but it seems to me that for people who need to do something more special in regards to how the body is serialized, they can implement a protocol. Something like this:

``` swift
let serializer = MyCustomMultipartFormDataSerializer()
serializer.fields["source"] = myLocalCatVideoFileURL
serializer.fields["title"] = "Cats Are Awesome"
Request.post("http://example.com/upload_video").content(serializer)
```

Obviously the serializer would have to be responsible for providing `Content-Type`, `Content-Length` and other necessary headers for this to work, but the meat of the implementation would be in allowing Alamofire to asynchronously read and send data from the serializer to the HTTP endpoint. This could also evolve into gzip, etc. support, and support chaining (data -> gzip -> multipart). Again, this all comes with the caveat that it's possible to do this with the iOS internals.

Anyway, the reason for this discussion is the snag that I have to branch my code based on whether I include a string or a file. I understand that the underlying technical code path is very different, but libraries are there to hide those details. :) If I want to express the Facebook API calls above, it shouldn't need to be more code than the examples I gave. You mention that `request` and `upload` are too convenient for me ‚Äì¬†could you give me an example of the less convenient API that achieves the same thing? I'd like to figure out the best way to make use of the Alamofire API in a way that makes my code more succinct.

Finally, I'd be curious to hear your arguments for why you disagree on the lack of control over query string and form data distinction. As a backend developer maybe I see them as more separate than you do, but I can say that query strings and form data are very often separate data stores in most libraries that handle HTTP requests, and you'd be lucky to not run into issues where the backend expects the data to be in one or the other. Just having a flag to control all of the parameters is a step in the right direction, but it makes me think that you might as well just take a second step and instead of making it a flag to pick one or the other, making it two sets of data. The API would be equally expressive in cases where you just want one or the other, but with the additional ability to specify both for cases like mine.
  According to the Apple docs this should be called on the main thread/queue.  In my tests it does not.  Probably because NSURLSession is not configured to use a specific queue so one is created for you, and presumably used when executing the delegate methods that fire the callback.

I will submit a PR when I have a chance.  It's not easy to test this; you basically need a system that uploads a big file AND you need to use the network link conditioner to slow down the network AND you need to put the app in the background.
 It's right here in the docs:

https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSURLSessionDelegate_protocol/#//apple_ref/occ/intfm/NSURLSessionDelegate/URLSessionDidFinishEventsForBackgroundURLSession

In Italics:

IMPORTANT
Because the provided completion handler is part of UIKit, you must call it on your main thread. 

I don't disagree that you don't have any issues. In fact, our app didn't have any issues at all with the completion handler not being called on the main thread.  And in some ways, it is silly for Apple to not provide a completion handler that doesn't queue itself back to the main thread if necessary.
  if i have an string:
let myString = "1"
It becomes to a number:
                    data.appendBodyPart(data: myString.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!, name: "title")
How can i force to append as an string?
  To match with the new Result type
  I'm using it at Xcode 7.0 beta 5. The branch is swift-2.0.

But I can't git it to work as I got the following issue as pictures shown:

<img width="356" alt="2015-09-01 5 25 00" src="https://cloud.githubusercontent.com/assets/6135847/9600706/2987ac96-50cf-11e5-9490-76e9259967c8.png">
<img width="1198" alt="2015-09-01 5 25 11" src="https://cloud.githubusercontent.com/assets/6135847/9600705/2987665a-50cf-11e5-8428-cd0885bc52f8.png">
<img width="1199" alt="2015-09-01 5 25 19" src="https://cloud.githubusercontent.com/assets/6135847/9600704/2986ceac-50cf-11e5-910b-17320a819c46.png">
<img width="1205" alt="2015-09-01 5 25 29" src="https://cloud.githubusercontent.com/assets/6135847/9600707/298800b0-50cf-11e5-8b18-f27296d2baa3.png">
<img width="1203" alt="2015-09-01 5 25 35" src="https://cloud.githubusercontent.com/assets/6135847/9600708/29884f16-50cf-11e5-828d-3a26e68051ec.png">
 My advice is to update to beta 6, and your problems should go away.

Other than that, you can see this answer from a couple of days ago: https://github.com/Alamofire/Alamofire/issues/713#issuecomment-135263173 .

Basically it says

> The 2.0.0-beta.1 release compiles on beta 5. The 2.0.0-beta.3 release compiles on beta 6.
 Thanks @cristeahub . I'll try it on beta 6.
  In README.md section "Creating a Manager with Background Configuration": replaced reference to deprecated method backgroundSessionConfiguration of NSURLSessionConfiguration with the new method as of iOS 8.0 called backgroundSessionConfigurationWithIdentifier
  Hi there,

I'm having trouble copying this source code over to a windows box because the filename you chose for your wildcard certificate (https://github.com/Alamofire/Alamofire/tree/swift-2.0/Tests/Resources/Certificates/alamofire.org/*.alamofire.org.cer) isn't a valid filename in windows. We use windows machines as part of our deployment pipeline for iOS apps, so it'd be great if this filename could be OS-agnostic.

FWIW, here's a helpful article from Apple on cross-platform filename best practices: https://support.apple.com/en-us/HT202808
 Thanks @cnoon!
  Are there any future plans to add convenience interface for standard classes (i.e. Core Data Supported Types) when using the following API call:

``` swift
public func appendBodyPart(#data: NSData, name: String)
```

At this time, I find myself having to do the following:

``` swift
var numberType = NSNumber(longLong: 2)
let numberData = NSData(bytes: &numberType, length: sizeof(Int64))

var stringType = "This is a test"
stringType.dataUsingEncoding(NSUTF8StringEncoding)

// or 

let stringData = NSData(bytes: &stringType, length: sizeof(String))

var dateType = NSDate()
let dateData = NSData(bytes: &dateType, length: sizeof(NSDate))

```

I'm using an existing API where I need to pass anywhere from 5 - 9 parameters depending on the API call.  Thus, I was thinking that it could be something similar to the following:

``` swift
public func appendBodyPart(#data: String, name: String)
public func appendBodyPart(#data: NSDate, name: String)
public func appendBodyPart(#data: NSNumber, name: String)
public func appendBodyPart(#data: NSDecimalNumber, name: String)
...
```
  Hi,
in Alamofire 1.2.2 I could make NTLM requests with the following code:

```
    let user = "" //insert user here
    let password = "" //insert pw
    let url = "" //insert URL

    let credential = NSURLCredential(user: user, password: password, persistence: .None)

    Alamofire.request(.GET, url)
        .authenticate(usingCredential: credential)
        .responseString { request, response, data, error in
            println("\(response), \(data), \(error)")
    }
```

However, in Alamofire 1.3.1 this only returns a 401 Unauthorized. I didn't change anything in my own code, I only dropped the newer framework into my project.

I've done a bit of investigation, and in the current master, `- URLSession:task:didReceiveChallenge:completionHandler:` is not called on the `SessionDelegate`. The commit that broke this seems to be b69959b8ad129057a9f4f313a0ccc7772902ee65. With the removal of `respondsToSelector`, the above method isn't called anymore. However, I don't understand why. Could someone please look into it?
 Hi @cnoon, sorry for not replying earlier. Unfortunately, I'm not working on the project where I needed the NTLM support anymore and I also don't have access to the NTLM server anymore. I googled a bit and tried to find an easy way to test the protocol, but as you might know it's difficult to find an open webserver that you can just send some test requests to. Best I could find is [this](http://stackoverflow.com/questions/6509278/authentication-test-servers), which would require to setup a test apache server. Sorry I can't be of more help!
 I am facing this issue at the moment while trying to access sharepoint rest api, under ssl and ntlm
 Yes I can do it, We can have session on skype together.
  62947d6deffc30d3128da580d91084a174fe485d is using `checkPromisedItemIsReachableAndReturnError` in MultipartFormData.swift (https://github.com/Alamofire/Alamofire/blob/62947d6deffc30d3128da580d91084a174fe485d/Source/MultipartFormData.swift#L260).

Unfortunately for us using Alamofire in iOS 7, this doesn't work. A fix would be welcome, thanks!
 Same issue with `NSQualityOfService` in Request.swift
 In the swift-2.0 branch, iOS7 is no longer supported. See https://github.com/Alamofire/Alamofire/pull/686 and the comments there.
 Thanks for the comments, I missed this.

FWIW, I find it very disappointing that such a reference library dropped support so early for iOS 7. Is there an alternative for Xcode 7 + iOS 7 + Swift?
 > If you are willing, it would be quite easy to fork Alamofire and make the necessary fixes for iOS 7.

To add to that, there's a lot of closed prqs on this repo that has made a lot of the changes to support iOS 7 already, so if you're interested @PatrickNLT , I would recommend you to look through them.
  Hi guys.
In the current version of the project I didn't find an ability to make a download of a file with some parameters (like  Alamofire.request do). I needed this in my project, and i think it will be very useful to others.
I do not know if it would be useful to someone, but I make some code to realise this ability:
Thanks for your great work!

``` swift
extension Manager {
    /**
        Creates a download request using the shared manager instance for the specified method, URL string
        and parameters.

        :param: method The HTTP method.
        :param: URLString The URL string.
        :param: parameters. `nil` by default.
        :param: destination The closure used to determine the destination of the downloaded file.

        :returns: The created download request.
    */
    public func download(
        method: Method, 
        _ URLString: URLStringConvertible, 
        parameters: [String: AnyObject]? = nil, 
        destination: Request.DownloadFileDestination) 
        -> Request 
    {
        let mutableURLRequest = URLRequest(method, URLString, headers: nil)
        let encoding: ParameterEncoding = .URL
        let encodedURLRequest = encoding.encode(mutableURLRequest, parameters: parameters).0
        return download(encodedURLRequest, destination: destination)
    }
}
```
  Add example on how `ServerTrustPolicyManager` can be subclassed and `serverTrustPolicyForHost` be overridden
 Great, btw I am new to contributing to open source, any suggestions on how to properly contribute to documentations, source code etc. Thanks
  I am using 2.0.0-beta.3 and running the following code.  

Do I have to use NSJSONSerialization.JSONObjectWithData to get the JSON?

```
        Alamofire.request(.GET, "https://api.someplace.com/", parameters: nil, encoding: .JSON, headers: headers)
            .response { request, response, data, error in
                guard data != nil else {
                    print(error)
                    return
                }

                print(request)
                print(response)
                print(error)

                do {
                    let z = try NSJSONSerialization.JSONObjectWithData(data!, options:[]) as! [NSObject: AnyObject]
                    print(z)

                } catch let parseError {
                    print(parseError)
                }
            }
            .responseJSON(completionHandler: { (request, response, result) -> Void in
                print(result)
            })
```
 Example from above shows me this error for version 3.0.0-beta.1:

![image](https://cloud.githubusercontent.com/assets/625090/10107153/d28f5668-63c1-11e5-9df9-fb4f02d9208d.png)
 Yes, the API for version 3 has changed. Take a look a the `.responseJSON` code to see what to expect in the completion handler.
  Prevent unnecessary call to the response serialiser in case of an error picked up by the TaskDelegate.
  When uploading a file and using the progress callback the callback method is not called on the main thread. Therefore a progressview is not updated during the upload.

```
    println("progressView created: \(NSThread.currentThread())")
    Alamofire.upload(
        Method.POST,
        URLString: "...",
        multipartFormData: { multipartFormData in
        },
        encodingCompletion: { encodingResult in
            println("encodingCompletion: \(NSThread.currentThread())")
            switch encodingResult {
            case .Success(let upload, _, _):
                upload.progress { bytesWritten, totalBytesWritten, totalBytesExpectedToWrite in
                                println("Total written \(totalBytesWritten) - progress \(progress) \(NSThread.currentThread())")
                    }

                }.responseJSON { request, response, json, error in
                    println(json)
                }
            case .Failure(let encodingError):
                println(encodingError)
            }
        }
    )
```

The above code results in the following log output:

progressView created: <NSThread: 0x7f9bf3546160>{number = 1, name = main}
encodingCompletion: <NSThread: 0x7f9bf3546160>{number = 1, name = main}
Total written 32768 - progress 0.193659 <NSThread: 0x7f9bf5eaf060>{number = 5, name = (null)}
Total written 65536 - progress 0.387317 <NSThread: 0x7f9bf370f680>{number = 6, name = (null)}
Total written 98304 - progress 0.580976 <NSThread: 0x7f9bf5eaf060>{number = 5, name = (null)}
Total written 131028 - progress 0.774374 <NSThread: 0x7f9bf370f680>{number = 6, name = (null)}
Total written 131072 - progress 0.774634 <NSThread: 0x7f9bf5e9fe80>{number = 4, name = (null)}
Total written 134232 - progress 0.79331 <NSThread: 0x7f9bf370f680>{number = 6, name = (null)}
Total written 138516 - progress 0.818628 <NSThread: 0x7f9bf5e9fe80>{number = 4, name = (null)}
Total written 141372 - progress 0.835507 <NSThread: 0x7f9bf5eaf060>{number = 5, name = (null)}
Total written 144228 - progress 0.852386 <NSThread: 0x7f9bf5e9fe80>{number = 4, name = (null)}
Total written 148512 - progress 0.877705 <NSThread: 0x7f9bf3416de0>{number = 7, name = (null)}
Total written 151368 - progress 0.894583 <NSThread: 0x7f9bf370f680>{number = 6, name = (null)}
Total written 155652 - progress 0.919902 <NSThread: 0x7f9bf370f680>{number = 6, name = (null)}
Total written 158508 - progress 0.936781 <NSThread: 0x7f9bf3416de0>{number = 7, name = (null)}
Total written 161364 - progress 0.95366 <NSThread: 0x7f9bf5e9fe80>{number = 4, name = (null)}
Total written 163840 - progress 0.968293 <NSThread: 0x7f9bf370f680>{number = 6, name = (null)}
Total written 168504 - progress 0.995857 <NSThread: 0x7f9bf3416de0>{number = 7, name = (null)}
Total written 169205 - progress 1.0 <NSThread: 0x7f9bf5e9fe80>{number = 4, name = (null)}

A workaround for this is to force the update of the progressview on the main thread like this:

```
 NSOperationQueue.mainQueue().addOperationWithBlock({ () -> Void in
       progressView.setProgress(progress, animated: true)
 })
```
 Thanks for your reply. May I suggest to update the documentation and maybe add the workaround/solution to update the UI? It took me some time to figure out why the progress view was not updating and how to solve this. We could save this time other developers ;)
 +1 for putting this in the documentation!
  Xcode7 refuses to compile an iOS project without these additions
 See #686 and so on.
  Is this a problem with not having beta 6 or what? Here's a screenshot of what I see:
[Imgur](http://i.imgur.com/odDFJHr.png)
  Example:
Alamofire.request(.GET, "http://httpbin.org/get", parameters: ["foo": "bar"])
         .response { request, response, data, error in
              println(request)
              println(response)
              println(error)
          }
  With this line:

```
pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'swift-2.0'
```

You get this result:

```
Pre-downloading: `Alamofire` from `https://github.com/Alamofire/Alamofire.git`, commit `f8f881c03f4d9515f09b8bb50fcc932df8c1960d`
Downloading dependencies
Installing Alamofire (2.0.0-beta.1)
```

With this line:

```
pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :commit => '2f94c11bb0'
```

You get:

```
downloading: `Alamofire` from `https://github.com/Alamofire/Alamofire.git`, commit `2f94c11bb0`
Downloading dependencies
Installing Alamofire 2.0.0-beta.2 (was 2.0.0-beta.1)
```

Might just need a documentation tweak or a new branch name.
 I'm not certain but you may be hitting the CocoaPods cache here. Try `pod cache clean` and then do a `pod update` from the `swift-2.0` branch. I was just able to update to beta 2 just fine.
 Ah, you're right. Thanks for the tips. pod update did the trick.
  I received 46 errors trying to include the Alamofire Source directory directly in my project.
  just fixed all the compiler issues with xcode7 beta 6
 Woot! Merge, please!
    Hello

When I send a GET request two times i have the same response.
but normally I should not have the same response. I was wondering if it was not because of the cache, and if so how to empty the cache ?

Thank's
  I'm faced with issue, when backend sends me both Basic & OAuth in WWW-Authenticate field: 

```
WWW-Authenticate: Basic realm="protected-area"
WWW-Authenticate: OAuth realm="https://my.domain.com"
```

It leads to two possible NSURLProtectionSpace instances in next order: 
- one with authenticationMethod == NSURLAuthenticationMethodOAuth (I'm confused a little bit here, since there is no actual constant for this value, its just the output of the `po` command) 
- with authenticationMethod == NSURLAuthenticationMethodHTTPBasic 

Since I can not handle OAuth I need to reject it. As the result I'll get Basic protection space which is something that I can handle. However, the only way to do so is to set `SessionDelegate.taskDidReceiveChallenge`. Therefore I have to copy & paste code from `TaskDelegate` for all the rest authentication methods handling which is something I don't like. So I'm wondering is there any way to gracefully add that extra "if" directly or indirectly and ability to fallback to the default handling logic? 

Thanks.

p.s. Was thinking about returning a Bool from `taskDidReceiveChallenge` but its a bit weird as for me, what do you think?
 If I'll _adjust_ code from `TaskDelegate` a little bit to fit my needs here is how it looks like:

``` swift
func URLSession(
    session: NSURLSession,
    task: NSURLSessionTask,
    didReceiveChallenge challenge: NSURLAuthenticationChallenge,
    completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
{
    var disposition: NSURLSessionAuthChallengeDisposition = .PerformDefaultHandling
    var credential: NSURLCredential?

    if let taskDidReceiveChallenge = taskDidReceiveChallenge {
        (disposition, credential) = taskDidReceiveChallenge(session, task, challenge)
    } else if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
        let host = challenge.protectionSpace.host

        if let
            serverTrustPolicy = session.serverTrustPolicyManager?.serverTrustPolicyForHost(host),
            serverTrust = challenge.protectionSpace.serverTrust
        {
            if serverTrustPolicy.evaluateServerTrust(serverTrust, isValidForHost: host) {
                disposition = .UseCredential
                credential = NSURLCredential(forTrust: serverTrust)
            } else {
                disposition = .CancelAuthenticationChallenge
            }
        }
    } else {
        if challenge.previousFailureCount > 0 {
            disposition = .CancelAuthenticationChallenge
        } else if challenge.protectionSpace.authenticationMethod != NSURLAuthenticationMethodHTTPBasic /* it seems there is no constant for OAuth :O */ {
            // This is my workaround 
            disposition = .RejectProtectionSpace
        } else {
            credential = self.credential ?? session.configuration.URLCredentialStorage?.defaultCredentialForProtectionSpace(challenge.protectionSpace)

            if credential != nil {
                disposition = .UseCredential
            }
        }
    }

    completionHandler(disposition, credential)
}
```
 @cnoon thanks for your clarification.
Actually I found that there is no way to reuse certificates evaluation logic, since it is not available due to `internal` access specifier on `serverTrustPolicyManager`. 

However, also I've decided to simplify my approach by sending `Authentication` header in every request (via NSURLSessionConfiguration.HTTPAdditionalHeaders), since this is exactly what system does by using NSURLCredentials ;) 
  Just started looking at the 2.0 API changes and the `Result` type really stuck out. It's a great encapsulation but I find it rather strange that it uses `NSError` rather than `ErrorType` to capture errors. Using `ErrorType` instead would allow much greater flexibility for developers by allowing them to create their own, customized error types. For instance, I'm currently developing against the CloudFlare API (api.cloudflare.com) and it uses a few HTTP response codes combined with details in the response JSON to indicate what error has occurred. I created a `CloudFlareError` enum that encapsulates all of the different errors. It'd be great to be able to encapsulate this error type in my generic serializer, rather than having to spit it out some other way. Was there a particular reason why only `NSError` was supported?
 @cnoon Thanks for the change! My response serializer can now return custom errors, like this: https://gist.github.com/jshier/b4858a4b417217fe8c73
  I have followed the instructions on installing the swift2 branch with cocoa pods. The app works well in the simulator, however, when I archive it for submission with Xcode 7 beta 5 I receive an email with an error:

"The bundle contains an invalid implementation of Swift. The app may have been built or signed with non-compliant or pre-release tools"

This issue definitely relates to the framework as without it I am able to submit for beta testing with the same version of Xcode. I have tried turning bit code OFF in build settings for Alamofire but it does not help.

Does anyone know how to fix this?
 Hi @cnoon!

Thanks for your feedback. I have opened a question on stack overflow (http://stackoverflow.com/questions/32158112/alamofire-swift-2-cannot-submit-for-beta-testing-xcode-7-beta-5). Unfortunately, the link which you sent doesn't help.

While it is not possible to submit apps for release, it is possible to submit them for beta testing with Xcode 7. And without Alamofire I can do it with ease. However, when I add the framework I start getting error messages. Unfortunately, something is not working well with the framework which prevents it from uploading for beta testing. It would be great if someone could look into this.
 @AndriyGo Do you have a sample project that reproduces the issue here on Github?
 @conradwt sorry just saw your message. It works fine now after Xcode 7GM and latest update to Alamofire
  HI!
Now that Swift can throw and catch errors, it also handles Objective-C code that throws errors. Now you don't have to (and actually can't) use NSError inout variables to catch the errors. Therefore, the example code for serializing Ono : 

``` swift
extension Request {
    public static func XMLResponseSerializer() -> GenericResponseSerializer<ONOXMLDocument> {
        return GenericResponseSerializer { request, response, data in
            guard let validData = data else {
                let failureReason = "Data could not be serialized. Input data was nil."
                let error = Error.errorWithCode(.DataSerializationFailed, failureReason: failureReason)
                return .Failure(data, error)
            }

            var XMLSerializationError: NSError?

            if let XML = ONOXMLDocument(data: validData, error: &XMLSerializationError) {
                return .Success(XML)
            } else {
                return .Failure(data, XMLSerializationError!)
            }
        }
    }

    public func responseXMLDocument(completionHandler: (NSURLRequest?, NSHTTPURLResponse?, Result<ONOXMLDocument>) -> Void) -> Self {
        return response(responseSerializer: Request.XMLResponseSerializer(), completionHandler: completionHandler)
    }
}
```

Has to be changed to something like this : 

``` swift
extension Request {
    public static func XMLResponseSerializer() -> GenericResponseSerializer<ONOXMLDocument> {
        return GenericResponseSerializer { request, response, data in
            guard let validData = data else {
                let failureReason = "Data could not be serialized. Input data was nil."
                let error = Error.errorWithCode(.DataSerializationFailed, failureReason: failureReason)
                return .Failure(data, error)
            }

            do {
                let XML = try ONOXMLDocument(data: validData)
                return .Success(XML)
            } catch let error as NSError {
                return .Failure(data, error)
            } catch {
                return .Failure(data, Error.errorWithCode(.DataSerializationFailed, failureReason: "Unknown error while parsing XML"))
            }
        }
    }

    public func responseXMLDocument(completionHandler: (NSURLRequest?, NSHTTPURLResponse?, Result<ONOXMLDocument>) -> Void) -> Self {
        return response(responseSerializer: Request.XMLResponseSerializer(), completionHandler: completionHandler)
    }
}
```

Swift 2.0 changes the signature of error throwing ObjC functions by stripping the "error: NSError" pointer argument and have the function throw it in swift fashion (pun intended). The second catch is there to make sure it's exhaustive but it's actually never called I guess because Ono won't throw anything else than NSError.
 Well, the code compiles fine when I use it (I actually use it with Ono's HTMLDocumentWithData but the handling's the same but I've tested both codes), but I've no idea how to do a pull request (git is still _very_ foggy to me). Can you do it yourself?
  Since Carthage 0.8, Dependencies will now be pinned to tags when applicable, allowing Carthage to use binaries.

Which could speed up carthage update requests
  I'm new to jason.So i'm trying to log in to a website by using user given username and password ( in swift app and pass to website ) by using almorfire,Is it possible to user Almofire to achieve this task ?
  Hi There,

I have been using an older version of Alamofire and been upgrading over the last couple of months.  I had some code that I thought was working that set the content type using this pattern:

```
  let sessionConfig = NSURLSessionConfiguration.backgroundSessionConfigurationWithIdentifier(sessionID)
  let manager = Alamofire.Manager(configuration: sessionConfig)
  manager.session.configuration.HTTPAdditionalHeaders = ["Content-Type": contentType]
```

The doc recommends to NOT do this.  The bug, I suppose, is that this shouldn't be a recommendation, it flat out will not work.  I didn't debug enough into this to figure out where the problem occurs but your content-type gets overwritten.

The real solution is to set the content type headers via the headers parameter.
  Hello,

as given in the documentation "...it is important to have the flexibility to specify evaluation policies on a per host basis." In addition it should also be possible to enabled a mapping on domain level or even for wildcards. 

By enriching the visibility of the server trust policy we enable clients to implement specific requirements.

Cheers,

Jan
  Project using https://github.com/antitypical/Result to transform response value of Alamofire cannot be used in the same file.

``` Swift
import Alamofire
import Result

Result
```

_Reference to generic type 'Result' requires arguments in <...>_

The problem is the collision between module name and class, even prefixing Result.Result, will no work because it can't find out if it refence the module Result or the class Alamofire.Result.

It will be good to rename Alamofire.Result because it's very specific to response use case, ResponseResult, AFResult or something similar.
 I agree that you shouldn't rename any component based on any external library possible collision, but using a name as generic as result for Alamofire 2.0, is a bit odd.

The problem with the typealias antitypical is not the best fit in our case, we will search for an alternative solution and trying to keep as much of the semantic in our project as possible.
  This is something that works with iOS8 but not in an iOS9 simulator:

```
manager.session.configuration.HTTPAdditionalHeaders = [
      HEADER_X_AUTH_TOKEN: token,
    ]
```

I cannot see the token in the request (via proxy), seems like adding the header is not working in iOS9 anymore.

Cocoapods, branch swift-2.0
Xcode7 Beta5 (header is missing)
Xcode6.4 (header is there as expected)
 I've just fixed this issue for me:
Just put header inside request : 
        Alamofire.request(.POST, YOUR_URL, parameters: self.parameters, headers: ["Authorization":"(YOUR_TOKEN)"] ,encoding: .JSON)

It's much simpler and working for me
 Thanks for the hint @cnoon, it really helped. Wrong usage of the manager because of the TLS security issue in iOS9 (and cert error the server side).

Taken from the main page:

```
let manager = Manager(
    configuration: NSURLSessionConfiguration.defaultSessionConfiguration(),
    serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies)
)
```

then

```
manager.session.configuration.HTTPAdditionalHeaders
```

which was not quite correct. Sorry for this.
 :+1: 
 @ADevelopStudio that looks to be a good alternative, could be more simple for some use cases. Not for me in this case, but great catch!
 Anyone might help out a bit with this ? I'm having the same issue. My sever works with HTTPS now and client ignores HTTPAdditionalHeaders, I'm guessing because the serverTrustPolicies but I'm not sure exactly which policy to create... Ideas?
 Passing the headers into the request works. Thanks!
  Commit 10f94788f0dd163fa516fb6f2f34a45a609c356e broke the tests. I get a compilation error:

```
'backgroundSessionConfigurationWithIdentifier' is only available on OS X 10.10 or newer
```

It also makes Carthage fail to build the Frameworks. 
  Hi,

I am using the code you are suggesting on both:
- using ephemeral sessions
- adding header to any query

The problem is that mixing both (adding query to ephemeral sessions), does not work. I checked :

```
let configuration = NSURLSessionConfiguration.ephemeralSessionConfiguration()
let manager = Manager(configuration: configuration)
manager.session.configuration.HTTPAdditionalHeaders = ["Authorization": "Bearer \(accessToken!)" ]
```

Doing this does not add the header.
Is there something I am missing?
 @cnoon With the latest tests you added, Carthage can't compile Alamofire anymore because

`ManagerTests.swift:127:63: error: 'backgroundSessionConfigurationWithIdentifier' is only available on OS X 10.10 or newer`

Interestingly I am using 10.10.5 and Xcode 7b5 toolchain when using `carthage update`
 Thank you for helping out.
Below the answers:
- Which version of Xcode are you using? > Xcode 6.4
- Which branch, tag or commit are you build Alamofire on? > Installed Alamofire yesterday. Using v 1.3.1
- How did you build Alamofire? > I used cocoapods following guidelines here: https://github.com/Alamofire/Alamofire#cocoapods.
- Extra: running app on iOS 8.4

I previously just imported Alamofire.swift file into the project but that did not work so it led to install Cocoapods (thought that this would solve the issue, but that was not the case).

Some more information:
- I adjusted the code following your suggestion :
  let configuration = NSURLSessionConfiguration.ephemeralSessionConfiguration()
      configuration.HTTPAdditionalHeaders = ["Authorization": "Bearer (accessToken!)" ]
      let manager = Manager(configuration: configuration)

The result I get is:
        REQUEST: <NSMutableURLRequest: 0x7f977b910cd0> { URL: https://www.custom.url/api/v1/custom.json }
    RESPONSE: nil
    DATA: nil
    ERROR: Optional(Error Domain=NSURLErrorDomain Code=-999 "cancelled"     UserInfo=0x7f977b8690c0 {NSErrorFailingURLKey=https://www.custom.url/api/v1/custom.json,         NSLocalizedDescription=cancelled, NSErrorFailingURLStringKey=https://www.custom.url/api/v1/custom.json})
- When I just send the headers, the "Cache-Control" = "must-revalidate, private, max-age=0" part of my answer seem to be ignored, since redoing the query with other parameters returns the same answer. This led me to force the session not to cache the result by using ephemeralSessionConfiguration, but as you can see it does not work.
- Because of this problem, I also tried removing all cached responses with NSURLCache.sharedURLCache().removeAllCachedResponses() before making any new request, but it did not work as well.
 So I managed to get the result by retaining the 'manager' as explained in https://github.com/Alamofire/Alamofire/issues/157

However, I still have that caching problem which was the initial problem that led me to use customer Manager. I am using ephemeralSessionConfiguration(), but the request is still stored.

Details points:
- When I just send the headers, the "Cache-Control" = "must-revalidate, private, max-age=0" part of my answer seem to be ignored, since redoing the query with other parameters returns the same answer. This led me to force the session not to cache the result by using ephemeralSessionConfiguration, but as you can see it does not work.
- I also tried removing all cached responses with NSURLCache.sharedURLCache().removeAllCachedResponses() before making any new request, but it did not work as well.

Thank you!
  Have you guys found this issue before? It won't compile with Xcode 7 - beta 5

```
ld: malformed 64-bit a.b.c.d.e version number: 2.0.0-beta.1
clang: error: linker command failed with exit code 1 (use -v to see invocation)
```

And this is my `Podfile`

```
platform :ios, '9.0'
use_frameworks!
pod 'Alamofire', git: 'https://github.com/Alamofire/Alamofire.git', tag: 'swift-2.0'
```
 Manually changed the `Current Library Version` field in the `Linking` section to `2.0.0` instead of `2.0.0-beta.1` and it compiled.
  I've been unable to build Alamofire on carthage which produces the following error in the log:

```
Build settings from command line:
    ONLY_ACTIVE_ARCH = NO

=== BUILD TARGET Alamofire OSX OF PROJECT Alamofire WITH THE DEFAULT CONFIGURATION (Release) ===

Check dependencies

Write auxiliary files
write-file /Users/jurvistan/Library/Developer/Xcode/DerivedData/Alamofire-giuxdschbqsymscojpimobtahmgq/Build/Intermediates/Alamofire.build/all-product-headers.yaml

=== BUILD TARGET Alamofire OSX Tests OF PROJECT Alamofire WITH THE DEFAULT CONFIGURATION (Release) ===

Check dependencies

** BUILD SUCCEEDED **

Build settings from command line:
    ONLY_ACTIVE_ARCH = NO
    SDKROOT = watchos2.0

=== BUILD TARGET Alamofire watchOS OF PROJECT Alamofire WITH THE DEFAULT CONFIGURATION (Release) ===

Check dependencies

Write auxiliary files
write-file /Users/jurvistan/Library/Developer/Xcode/DerivedData/Alamofire-giuxdschbqsymscojpimobtahmgq/Build/Intermediates/Alamofire.build/all-product-headers.yaml

** BUILD SUCCEEDED **

Build settings from command line:
    ONLY_ACTIVE_ARCH = NO
    SDKROOT = watchsimulator2.0

=== BUILD TARGET Alamofire watchOS OF PROJECT Alamofire WITH THE DEFAULT CONFIGURATION (Release) ===

Check dependencies
target 'Alamofire watchOS' has bitcode disabled (ENABLE_BITCODE = NO), but it is required for the 'watchos' platform
```

If Bitcode is compulsory for watchOS, shouldn't it be enabled for the watchOS target by default?

Thanks!
 "swift-2.0" branch seems to be merged to master, but this problem persists.

## Cartfile

`github "Alamofire/Alamofire"`

## Carthage Version

```
Sljux:Documents Sljux$ carthage version
0.8.0
```

## `xcodebuild` version

```
Sljux:Documents Sljux$ xcodebuild -version
Xcode 7.0
Build version 7A218
```

## `carthage update` output

```
Sljux:Documents Sljux$ carthage update
*** Fetching Alamofire
*** Checking out Alamofire at "2.0.2"
*** xcodebuild output can be found in /var/folders/td/99svwd2x5b3g6nkwjv_3y52w0000gn/T/carthage-xcodebuild.kYUE0x.log
*** Building scheme "Alamofire watchOS" in Alamofire.xcworkspace
** BUILD FAILED **


The following build commands failed:
    Check dependencies
(1 failure)
A shell task failed with exit code 65:
** BUILD FAILED **


The following build commands failed:
    Check dependencies
(1 failure)
```

## Log file

```
Build settings from command line:
    ONLY_ACTIVE_ARCH = NO
    SDKROOT = watchos2.0

=== BUILD TARGET Alamofire watchOS OF PROJECT Alamofire WITH CONFIGURATION Release ===

Check dependencies

** BUILD SUCCEEDED **

Build settings from command line:
    ONLY_ACTIVE_ARCH = NO
    SDKROOT = watchsimulator2.0

=== BUILD TARGET Alamofire watchOS OF PROJECT Alamofire WITH CONFIGURATION Release ===

Check dependencies
target 'Alamofire watchOS' has bitcode disabled (ENABLE_BITCODE = NO), but it is required for the 'watchos' platform
```
    Screenshots indicating that issue exist on project with iOS Deployment Target 7.0:

![screen shot 2015-08-13 at 14 58 41](https://cloud.githubusercontent.com/assets/3842032/9249277/fc64f00a-41cb-11e5-92d3-8bbd1c506fa7.png)
![screen shot 2015-08-13 at 14 59 14](https://cloud.githubusercontent.com/assets/3842032/9249278/fc8b4db8-41cb-11e5-8c6e-953c0e32af19.png)
 You should see #523, #525, #554, #635 and #667.
 Thanks for explanation, I missed the fact that v2 will be iOS 8+.
  Hi 

I am just wondering what the likely date is for the swift-2.0 branch to merged into master. I do not want to release the app with a branch version. 

If there is any way I can help, I will just let me know how. 
 Thanks for the answer Christian. I know it was a bit of dense question. I just needed to make sure. 
  I found that "Manager.upload:" has a different signature, it does not want the label "URLString" anymore. Unlike "Alamofire.upload:"

In Alamofire.swift:

```
public func upload(method: Method, URLString: URLStringConvertible, headers: [String: String]? = nil, #file: NSURL) -> Request {
    return Manager.sharedInstance.upload(method, URLString, headers: headers, file: file)
}
```

in Upload.swift:

```
  public func upload(method: Method, _ URLString: URLStringConvertible, headers: [String: String]? = nil, stream: NSInputStream) -> Request {
        let mutableURLRequest = URLRequest(method, URLString, headers: headers)

        return upload(mutableURLRequest, stream: stream)
    }
```
  i'm running Xcode 7.0-beta4 and installed `Alamofire` via the `swift-2.0` branch. i'm come out unable to build due to the errors pictures here:

![alamofire-swift2-errors](https://cloud.githubusercontent.com/assets/5456481/9238050/64c7e6d4-411d-11e5-9910-3f5eb4c12f1a.png)
 thanks !
  I had 0.37.2 which lead to an error when doing "pod install", upgrading to 0.38.2 fixed this problem.
Since the Readme mentions only 0.36+, I thought maybe it would be useful for others to know you actually need something newer.
  Accessing a server with "invalid" certificate worked with 1.2.x, but increased default security measures stop it from working in 1.3.x.
##### High five for this guys!

So trying to turn off this check for the machine until the issue is fixed on their side. Based on the documentation at
https://github.com/Alamofire/Alamofire#server-trust-policy-manager

I should be able to fix it with this small piece code:

```
   let serverTrustPolicies: [String: ServerTrustPolicy] = [
     "the.insecure.hostname": .DisableEvaluation
   ]
   let manager = Manager(
     configuration: NSURLSessionConfiguration.defaultSessionConfiguration(),
     serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies)
   )
   manager.request(.GET, ...)   // Instead of previously Alamofire.request(.GET, ...)
```

But I seem not to be able to _send_ the request out anymore. Response is nil in responseJSON(), and the proxy does not show any outgoing traffic.

This error shows in the console:

```
NSURLErrorDomain, -999
```

Any idea what I or the documentation might be missing?
 It was the right guess.
Maybe mention this in the documentation so others don't step into this?
Thanks for the hint!
 I meant kind of to change the example in the doc to something like:

```
var manager: Manager? // you must hold on to this instance!
```

so most would do this right the first time without having the issue at all.
Not quite sure it is the best solution, but it looks like an improvement in my eyes :)
  I m getting cannot import module being compiled on following import line

import Alamofire

I am using Xcode7 beta 5. Project builds successfully if I don't use import. What's wrong?
 Are you using the swift-2 branch?
 Yes. using 2.0.

Tried with this :
source 'https://github.com/CocoaPods/Specs.git'
platform :ios, '8.0'
use_frameworks!
pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'swift-2.0'

And also with this:
source 'https://github.com/CocoaPods/Specs.git'
platform :ios, '8.0'
use_frameworks!
pod 'Alamofire', '2.0.0-beta.1'

None of them work. But surprisingly your example projects works well. Any idea?
 Google is of no use as I couldn't find this error anywhere "Cannot import module being compiled".
Why does this error occur?
 I m stupid.
I had kept project name as "Alamofire".
Thanks.
 Sorry, I've used Alamofire on Xcode 7 beta 2 and was working well. After i updated Xcode to Xcode 7 beta 5, i cant use Alamofire. Im not using cocoapods though but i used https://github.com/Alamofire/Alamofire and import the Alamofire.xcodeproj. 
In my controller, i use "Import Alamofire" but the result is "No such module 'Alamofire'.
What should i do?
 You must use the swift-2.0 branch with Xcode7!
 @pvegh ah my bad.
Now i've used swift-2.0 branch for Alamofire.
But the result is still the same, when i import Alamofire, the result is "no such module Alamofire".
Any advise?
Thanks
  Hi,
Is it possible to add
.progress { bytesRead, totalBytesRead, totalBytesExpectedToRead in
             print(totalBytesRead)
         }
to  Uploading MultipartFormData ?
 There is a progress() in Request itself, that is the one you are looking for.
 hi guys,
how can i use this method to upload an image with UIImagePickerViewController?
 I'm getting this error while trying this.

XCode 7.1.1, Target OS: iOS 9.1

![screenshot at dec 27 00-47-46](https://cloud.githubusercontent.com/assets/14557593/12006654/84a0470e-ac33-11e5-95d5-4ed9d7831efd.png)
 I have the same error! Any Progress on that?
 Use 

```
upload.responseJSON { response in
                debugPrint(result)
            }
```

instead of 

```
upload.responseJSON { request, response, result in
                debugPrint(result)
            }
```
 About "Cannot call value of non-function type 'NSProgress'" error: it's fixed by renaming or removing "progress" field of type NSProgress in Request class. Then it is able to choose the right "progress" of function type.
  I'm getting these errors when pulling from the pod spec 2.0.0-beta.1

<img width="345" alt="screen shot 2015-08-11 at 12 54 28 pm" src="https://cloud.githubusercontent.com/assets/2805285/9216011/6fb8d04e-4078-11e5-83e4-f72ca743ddfa.png">

Also when just trying to pull straight form the swift-2.0 branch. I'm receiving this error from cocoapods. 
[!] A dependency with an external source may not specify version requirements (Alamofire).
 source 'https://github.com/CocoaPods/Specs.git'
platform :ios, '9.0'
use_frameworks!
pod 'Alamofire', '2.0.0-beta.1'
pod 'UICountingLabel'
pod 'Timepiece', :git => "https://github.com/naoty/Timepiece.git", :branch => "swift-2.0"
pod 'CryptoSwift', :git => "https://github.com/krzyzanowskim/CryptoSwift", :branch => "swift20"
pod 'TTTAttributedLabel'
pod 'MBProgressHUD'
 I'm using Carthage and get the same error while building:

```
[...]/Carthage/Checkouts/Alamofire/Source/Manager.swift:75:20: error: cannot invoke 'CFStringTransform' with an argument list of type '(CFMutableString, UnsafeMutablePointer<  CFRange>, CFString, Bool)'
[...]/Carthage/Checkouts/Alamofire/Source/MultipartFormData.swift:260:27: error: 'NSURL' does not have a member named 'checkPromisedItemIsReachableAndReturnError'
[...]/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift:166:41: error: cannot invoke 'SecPolicyCreateSSL' with an argument list of type '(Bool, CFString)'
[...]/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift:172:45: error: cannot invoke 'SecPolicyCreateSSL' with an argument list of type '(Bool, CFString)'
[...]/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift:176:17: error: cannot invoke 'SecTrustSetAnchorCertificatesOnly' with an argument list of type '(SecTrust,    Bool)'
[...]/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift:203:45: error: cannot invoke 'SecPolicyCreateSSL' with an argument list of type '(Bool, CFString)'
A shell task failed with exit code 65
```
 I just realized that I was still using beta 4. I was sure I was using beta 5. It work fine with beta 5.

@Prince2k3 are you sure you have beta 5? Maybe try to clean and rebuild.
 For the record they fixed it in 62947d6deffc30d3128da580d91084a174fe485d
 Ah you are right @jschmid. I am on beta 4. Thanks for figuring that out. I felt the same thinking I was on beta 5 Xcode. Argh ... closing this one
  I asked a question in stackflow tagged with "alamofire", could you help me with that?
http://stackoverflow.com/questions/31932792/alamofire-complains-about-argument-type
  I am trying to download a file. When it is finished downloading (if successful) I want to save the file's full path (path & filename) so a coredata database. How can I access the full path of the file that was downloaded?

I am using this code from the readme as a starting point:

```
Alamofire.download(.GET, "http://httpbin.org/stream/100", destination: destination)
     .progress { bytesRead, totalBytesRead, totalBytesExpectedToRead in
         println(totalBytesRead)
     }
     .response { request, response, _, error in
         println(response)
         #where do i access the file path and if it was successful?
     }
```
  Since the introduction of the `Result` type instead of a `data`, `error` parameter the validation seems to be broken. Everything besides a `200` response is interpreted as a `.Failure`.

Any thoughts about this?
 Sure but it's pretty straight forward:

``` swift
            let request = Alamofire.request(mutableURLRequest)
                .validate()
                .responseJSON { (_, response, result) in
                    switch result {
                    case .Success(let value):
                        sendNext(sink, value)
                        sendCompleted(sink)
                    case .Failure(let data, let error):
                        print(error)
                        sendError(sink, error)
                    }
            }
```

In this case `.Failure` gets called for a response with status 204.
 This implementation is some kind of API abstraction I'm using. Previously it worked fine having something like the following:

``` swift
                .responseJSON { (_, response, data, error) in
                 // ...
                 if let data = data {
                      sendNext(sink, data)
                 }
```

What's the best way to have the same outcome using the new `Result` way?
 Thanks a lot for your quick answers @kylef and @cnoon. I can totally understand why this path was chosen.
  I'm sorry if this has been asked before, but the job of the `ResponseSerializer` and corresponding functions is actually to deserialize the incoming data right? So wouldn't that make the name incorrect?
  I implemented authorization using credentials, similar to this:

```
let password = "password"

let credential = NSURLCredential(user: user, password: password, persistence: .ForSession)

Alamofire.request(.GET, "https://httpbin.org/basic-auth/\(user)/\(password)")
         .authenticate(usingCredential: credential)
         .response { request, response, _, error in
             println(response)
         }
```

However, I had to include the following to catch invalid credentials. The server replies "Invalid Credentials" if auth was cancelled, but string parameter is `nil` and response status code cannot be determined.

```
...
         .responseString { request, response, string, error in
                println(response) // prints `nil` but I'm expecting an object with statusCode 401
                println(string) // prints `nil` but I'm expecting "Invalid Credentials"
                if let error = error {
                    // Workaround Cancelled error.
                    if -999 == error.code && error.domain == NSURLErrorDomain {
                        title = "Invalid Credentials"
                        message = "Please check your email & password, then try again."
                    }
                }
            }
```
  What is the logic behind making the `Manager` `init` method required?
Surely if we sub-class `Manager`, we have to call the superclass designated initialiser anyway.
Having the `init` method required means that if we want to create an `init` with a different signature we then have to have a fake `init` method with the ubiquitous `fatalError("init(configuration:serverTrustPolicyManager:) has not been implemented")` polluting the subclass.
 Thanks!
    Something like `AFNetworkActivityIndicatorManager` would be great.
 I agree. Functionality similar to `AFNetworkActivityIndicatorManager` would be very helpful.
 > Something like `AFNetworkActivityIndicatorManager` would be great.

Agreed, this is something today is done by either using other libs outside of Alamofire, or having to patch it on top.
 I guess the asynchronous UIImage/NSImage loading extensions once discussed are also already on the list?
 Auto-retrying functionality would be very useful (say, based on certain HTTP status code) plus the ability to customize retrying intervals.
 @cnoon I don't know exactly what you mean by clobbering but I know pretty elegant solution for this problem implemented in [RetryingHTTPOperation](https://developer.apple.com/library/ios/samplecode/MVCNetworking/Listings/Networking_RetryingHTTPOperation_h.html) from MVCNetworking. They use composition to achieve this goal. One part performs HTTP request and the second part retries first part. No clobbering from my point of view. What do you think of this?
 Any plan to support a future/promise based API? Maybe using [BrightFutures](https://github.com/Thomvis/BrightFutures)?
 > Just FYI...we just released AlamofireImage!

üëçüèª
 Any updates about the network activity indicator request?
 something like `AFNetworkReachabilityManager` is already in the list?
 Logger like AFNetworkActivityLogger for AFNetworking would be nice. I tried to build a logger for Alamofire using NSURLProtocol subclass, but failed quickly because of NSURLProtocol limitations (also found a reference here: https://github.com/Alamofire/Alamofire/issues/185).
 I see "auto-retrying with progressive back-off" made it on the original list. We're looking to implement this in our app; or does AlamoFire have short-term plans?
 Thanks for the quick reply!
  I'm getting this error when trying to build an Command Line Tool Project using Alamofire in XCode 6.4 on OSX 10.10 :

```
dyld: Library not loaded: @rpath/libswiftAppKit.dylib
  Referenced from: /Volumes/Data/Users/nameremoved/Library/Developer/Xcode/DerivedData/truefire-dl-bvnjnvdgfjlhyvagtinbdchvzpnb/Build/Products/Debug/Alamofire.framework/Versions/A/Alamofire
  Reason: image not found
```

Podfile:

```
source 'https://github.com/CocoaPods/Specs.git'
platform :osx, "10.10"
use_frameworks!

pod 'Alamofire', '~> 1.3'

```
 Thanks. That sucks :(
  When i try to use

`let error = Error.errorWithCode(.DataSerializationFailed, failureReason: failureReason)`

as suggested in the Readme i get 'Error.Type' does not have a member named 'errorWithCode'.
I am using Cocoapods.
 yes, i'm writing my own response serializer. basically it's the exact same use case as suggested in the Readme...
 I am running into this issue as well while following the example in the README to implement a generic collection serializer. Modifying the function signature of `errorWithCode` to be a `public static func` seems to resolve this, though preliminary investigations don't seem to suggest that the static method needs to be explicitly set as `public`.
 merci! :)
  This adds missing minimum iOS version specifiers in some `#availability` clauses.
 Wait, what warnings does it introduce? I assumed this wouldn't change anything at all if you only support iOS 8+...
 It's not, but it fixes the build for those who still want to build it on iOS 7, and I was assuming that it's completely harmless for those who build for iOS 8 only. What are the warnings that you get if you target iOS 8?
 Maybe I'll just answer myself:

> Unnecessary check for 'iOSApplicationExtension'; minimum deployment target ensures guard will always be true

Makes sense in this case to not add it, I guess.
  ![screen shot 2015-08-10 at 6 37 36 pm](https://cloud.githubusercontent.com/assets/289994/9163995/efebfe16-3f8e-11e5-981b-15fb8f14c36c.png)
 This issue is still happening for me in beta 5. I'm using the latest pull from the swift-2.0 branch. 
 Sorry its not the same error. I'm getting another error plus multiple others. Which I will open a issue for.
   ok  - the commit was more about fixing the critical crash and getting demo working than reducing the exclamation marks. I've seen this pattern - if let response = response but I think there's a push to abbreviate it. thanks
 fyi - this pull request added additional NSAppTransportSecurity to plist fixing the bug with example not working. The example is still not working. 

key NSAppTransportSecurity key
    dict
        key NSAllowsArbitraryLoads key
        true
dict
  While the new Result Type is wonderful, I encountered the following problem with the Error case:

When the Result is passed around, at the place where it is handled, there is no way to get the HTTP status code from a possible Error case. In my case I want to handle an "Unauthorized" response with running an authentication request and then re-running the previous request. The method therefore looks if the result was an Error and then would need to check if the actual response code was a 401.

Would it make sense to add the actual status code to the error? For now there is only the entire message like `Error Domain=com.alamofire.error Code=-6003 "Response status code was unacceptable: 401"`
 Hello,

You can change range of acceptableStatusCodes in Alamofire/validation.swift file from 200..<300 to 200..<500.
 How to get the response code in case of failure with the new implementation of Alamofire in Swift 3?

```
Alamofire.request("https://httpbin.org/get").validate().responseJSON { response in
    switch response.result {
    case .success:
        print("Validation Successful")
    case .failure(let error):
        print(error)
    }
}
```

I tried `response.response.statusCode` but I noticed when it comes in `failure` case, `response.response` property happens to be `nil`.
<img width="690" alt="screen shot 2016-11-20 at 12 00 34 pm" src="https://cloud.githubusercontent.com/assets/7058465/20461477/fff22290-af18-11e6-8f61-b1343feee071.png">
If you check the bottom variable tree, the failure is of type NSError, but I don't know how to get the status code from it... I can see -1009 is there, but cannot find a way to get it!!
 Thanks for the reply. It means, when `responseObj.response` is `nil`, it means it is always a no-network issue? Isn't there any way to get the code (the one that you can see in the screenshot above -1009) by any way?
  ```

../Pods/Alamofire/Source/ServerTrustPolicy.swift:166:41: error: cannot invoke 'SecPolicyCreateSSL' with an argument list of type '(Bool, CFString)'
            let policy = validateHost ? SecPolicyCreateSSL(true, host as CFString) : SecPolicyCreateBasicX509()
                                        ^
../Pods/Alamofire/Source/ServerTrustPolicy.swift:166:41: note: expected an argument list of type '(Boolean, CFString?)'
            let policy = validateHost ? SecPolicyCreateSSL(true, host as CFString) : SecPolicyCreateBasicX509()
                                        ^
../Pods/Alamofire/Source/ServerTrustPolicy.swift:172:45: error: cannot invoke 'SecPolicyCreateSSL' with an argument list of type '(Bool, CFString)'
                let policy = validateHost ? SecPolicyCreateSSL(true, host as CFString) : SecPolicyCreateBasicX509()
                                            ^
../Pods/Alamofire/Source/ServerTrustPolicy.swift:172:45: note: expected an argument list of type '(Boolean, CFString?)'
                let policy = validateHost ? SecPolicyCreateSSL(true, host as CFString) : SecPolicyCreateBasicX509()
                                            ^
../Pods/Alamofire/Source/ServerTrustPolicy.swift:176:17: error: cannot invoke 'SecTrustSetAnchorCertificatesOnly' with an argument list of type '(SecTrust, Bool)'
                SecTrustSetAnchorCertificatesOnly(serverTrust, true)
                ^
../Pods/Alamofire/Source/ServerTrustPolicy.swift:176:17: note: expected an argument list of type '(SecTrust, Boolean)'
                SecTrustSetAnchorCertificatesOnly(serverTrust, true)
                ^
../Pods/Alamofire/Source/ServerTrustPolicy.swift:203:45: error: cannot invoke 'SecPolicyCreateSSL' with an argument list of type '(Bool, CFString)'
                let policy = validateHost ? SecPolicyCreateSSL(true, host as CFString) : SecPolicyCreateBasicX509()
                                            ^
../Pods/Alamofire/Source/ServerTrustPolicy.swift:203:45: note: expected an argument list of type '(Boolean, CFString?)'
                let policy = validateHost ? SecPolicyCreateSSL(true, host as CFString) : SecPolicyCreateBasicX509()
                                            ^


../Pods/Alamofire/Source/Manager.swift:75:20: Cannot invoke 'CFStringTransform' with an argument list of type '(CFMutableString, UnsafeMutablePointer<CFRange>, CFString, Bool)'


```
    Is this also the Xcode 7 /iOS 9 branch?  I'm getting ssl handshake errors, even after changing the info.plist massively.  I don't see any of the auth challenge callbacks getting hit and I'm wondering if protocol changes have busted alamofire?
  What does the _, in the code below mean?

Alamofire.request(.GET, "http://httpbin.org/get")
         .responseJSON { _, _, JSON, _ in
             println(JSON)
         }
 You should ask these questions on stack overflow instead of here. Not only will you get a better response, but the person who responds will also get some points on the site, which is nice for them. See the guidelines here: https://github.com/Alamofire/Alamofire#communication .

You can read about how the underscore works here, it basically means that  you don't care about the value in those fields: https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID362
 ahhh i see... thanks for your reply.

But, actually I would recommend that the documentation don't use _ in such a manner. Its sending out the wrong signal.

Because the status codes, which is inside the response, is important. And there should always be conditionals base on the status codes. People will read your documentation and get away with the idea that the response is not important. In fact I was stumped by this for quite some time...
 I think it's like that because they want to emphasize the difference of a `responseJSON` and a regular `response`.
 Hi cnoon,

Thanks for the reply. Yup I fully understand the intent now.

But my concern is just that users of the documentation are not always that familiar with swift, and this will trip them.

As an example, my colleague has 5 years of experience coding ObjectiveC and just recently attempted to switch to swift.

I have even more years doing many other languages.

But we didn't understand the documentation in this respect, and I certainly don't expect new users of swift to be able to pour through the swift docs.

In short, I don't think it's wise to craft documentation meant for adept level of readers, certainly not for a framework that is so high level and simple.

Cheers mate.
  Hi guys,

There is an issue when i try to use 'Method' enum as parameter of an function, gives me error **'Method' is ambiguous for type lookup in this context**. If i use it as argument of  `Alamofire.request()` function there is no problem. What could cause such an error?

> XCode: 6.4v
> Cocoapods: 0.38.2v
> Swift: 1.2v

``` javascript
import UIKit
import Alamofire

class ServerManager: NSObject {

    let ServerPath = "BaseURL"

    class var instance:ServerManager {
        struct Singleton {
            static let instance = ServerManager()
        }
        return Singleton.instance
    }

    func request(method: Method, identifier: String, parameters: [String: AnyObject]? = nil) -> Void{
        Alamofire.request(Method.GET, ServerPath, parameters: nil, encoding: ParameterEncoding.URL, headers: nil)
    }
}
```
 You've to use `Alamofire.Method` to resolve name conflic
  If you `carthage update` on the latest version of the swift-2.0 branch you will get error included:

Workaround: Release "Enable Testability" set to Yes, and `carthage build`

Error
**\* xcodebuild output can be found in /var/folders/8y/3fnvzblx5m35h3mz7889s9vm0000gn/T/carthage-xcodebuild.aRoNfJ.log
**\* Building scheme "Alamofire iOS" in Alamofire.xcworkspace
*\* BUILD FAILED **

The following build commands failed:
    CompileSwift normal x86_64 /Users/ceco/src/Flowthings/Carthage/Checkouts/Alamofire/Tests/MultipartFormDataTests.swift
    CompileSwift normal x86_64 /Users/ceco/src/Flowthings/Carthage/Checkouts/Alamofire/Tests/ServerTrustPolicyTests.swift
    CompileSwift normal x86_64 /Users/ceco/src/Flowthings/Carthage/Checkouts/Alamofire/Tests/CacheTests.swift
    CompileSwift normal x86_64 /Users/ceco/src/Flowthings/Carthage/Checkouts/Alamofire/Tests/ResultTests.swift
    CompileSwift normal x86_64 /Users/ceco/src/Flowthings/Carthage/Checkouts/Alamofire/Tests/URLProtocolTests.swift
    CompileSwift normal x86_64 /Users/ceco/src/Flowthings/Carthage/Checkouts/Alamofire/Tests/TLSEvaluationTests.swift
    CompileSwift normal x86_64 /Users/ceco/src/Flowthings/Carthage/Checkouts/Alamofire/Tests/ResponseSerializationTests.swift
    CompileSwift normal x86_64 /Users/ceco/src/Flowthings/Carthage/Checkouts/Alamofire/Tests/RequestTests.swift
    CompileSwiftSources normal x86_64 com.apple.xcode.tools.swift.compiler
(9 failures)
/Users/ceco/src/Flowthings/Carthage/Checkouts/Alamofire/Tests/ResultTests.swift:23:18: error: module 'Alamofire' was not compiled for testing
/Users/ceco/src/Flowthings/Carthage/Checkouts/Alamofire/Tests/ResultTests.swift:23:18: error: module 'Alamofire' was not compiled for testing
/Users/ceco/src/Flowthings/Carthage/Checkouts/Alamofire/Tests/ResultTests.swift:23:18: error: module 'Alamofire' was not compiled for testing
/Users/ceco/src/Flowthings/Carthage/Checkouts/Alamofire/Tests/ResultTests.swift:23:18: error: module 'Alamofire' was not compiled for testing
/Users/ceco/src/Flowthings/Carthage/Checkouts/Alamofire/Tests/ResultTests.swift:23:18: error: module 'Alamofire' was not compiled for testing
/Users/ceco/src/Flowthings/Carthage/Checkouts/Alamofire/Tests/ResultTests.swift:23:18: error: module 'Alamofire' was not compiled for testing
/Users/ceco/src/Flowthings/Carthage/Checkouts/Alamofire/Tests/ResultTests.swift:23:18: error: module 'Alamofire' was not compiled for testing
/Users/ceco/src/Flowthings/Carthage/Checkouts/Alamofire/Tests/ResultTests.swift:23:18: error: module 'Alamofire' was not compiled for testing
A shell task failed with exit code 65:
*\* BUILD FAILED **

The following build commands failed:
    CompileSwift normal x86_64 /Users/ceco/src/Flowthings/Carthage/Checkouts/Alamofire/Tests/MultipartFormDataTests.swift
    CompileSwift normal x86_64 /Users/ceco/src/Flowthings/Carthage/Checkouts/Alamofire/Tests/ServerTrustPolicyTests.swift
    CompileSwift normal x86_64 /Users/ceco/src/Flowthings/Carthage/Checkouts/Alamofire/Tests/CacheTests.swift
    CompileSwift normal x86_64 /Users/ceco/src/Flowthings/Carthage/Checkouts/Alamofire/Tests/ResultTests.swift
    CompileSwift normal x86_64 /Users/ceco/src/Flowthings/Carthage/Checkouts/Alamofire/Tests/URLProtocolTests.swift
    CompileSwift normal x86_64 /Users/ceco/src/Flowthings/Carthage/Checkouts/Alamofire/Tests/TLSEvaluationTests.swift
    CompileSwift normal x86_64 /Users/ceco/src/Flowthings/Carthage/Checkouts/Alamofire/Tests/ResponseSerializationTests.swift
    CompileSwift normal x86_64 /Users/ceco/src/Flowthings/Carthage/Checkouts/Alamofire/Tests/RequestTests.swift
    CompileSwiftSources normal x86_64 com.apple.xcode.tools.swift.compiler
(9 failures)
  Please let me know if this set of fixes looks right to you. Thanks in advance!
  Hi, I'm trying to request a POST method using Alamofire. I'm using Heroku, and to have a root domain, it needs a HTTP redirect to work. But the Alamofire (i think), isn't applying the HTTP Method on redirect.

The method request with "www":

``` swift
    Alamofire.request(.POST, "http://www.example.com/registrations.json").responseJSON(completionHandler: {(req, res, data) in
      switch data {
      case .Success(let json):
        let user = User(json: JSON(json))
        self.myApplication.storeUser(user)
        self.goNext()
      case .Failure(let data, let error):
        print(req, appendNewline: true)
        print(res, appendNewline: true)
        print(data, appendNewline: true)
        print(error, appendNewline: true)
      }
    })
```

Heroku server log with "www", been hit with 'POST':

```
015-08-05T22:24:50.143366+00:00 app[web.1]: Started POST "/registrations.json" for 187.122.124.193 at 2015-08-05 22:24:50 +0000
2015-08-05T22:24:50.217193+00:00 app[web.1]: Can't verify CSRF token authenticity
2015-08-05T22:24:50.360367+00:00 app[web.1]:    (4.7ms)  BEGIN
2015-08-05T22:24:50.194227+00:00 app[web.1]: Processing by RegistrationsController#create as JSON
2015-08-05T22:24:50.217755+00:00 app[web.1]: Geokit is using the domain: example.com
2015-08-05T22:24:50.381985+00:00 app[web.1]:   SQL (4.9ms)  INSERT INTO `users` (`profile`, `created_at`, `updated_at`) VALUES ('guest', '2015-08-05 22:24:50', '2015-08-05 22:24:50')
2015-08-05T22:24:50.434167+00:00 app[web.1]:   ApiKey Load (6.3ms)  SELECT  `api_keys`.* FROM `api_keys` WHERE `api_keys`.`user_id` = 32 AND (created_at <= '2015-08-05 22:24:50.423325' AND expires_at >= '2015-08-05 22:24:50.423325') LIMIT 1
2015-08-05T22:24:50.683762+00:00 app[web.1]:   Person Load (3.1ms)  SELECT  `people`.* FROM `people` WHERE `people`.`personable_id` = 32 AND `people`.`personable_type` = 'User' LIMIT 1
2015-08-05T22:24:50.617984+00:00 app[web.1]:   SQL (4.4ms)  INSERT INTO `api_keys` (`user_id`, `created_at`, `updated_at`, `access_token`, `expires_at`) VALUES (32, '2015-08-05 22:24:50', '2015-08-05 22:24:50', 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE0NDE0OTE4OTAsInYiOjAsImlhdCI6MTQzODgxMzQ5MCwiZCI6eyJ1aWQiOiIzMiIsInByb2ZpbGUiOiJndWVzdCIsImlkIjoiMzIifX0.FQfctD82t80UJjUg0_YL-GOn4emETqOGcVfr6-fPX00', '2015-09-05 22:24:50')
2015-08-05T22:24:50.626442+00:00 app[web.1]:    (5.3ms)  COMMIT
2015-08-05T22:24:51.072576+00:00 heroku[router]: at=info method=POST path="/registrations.json" host=www.example.com request_id=ee58ddb9-d3d3-4f90-8723-b9869ce2ef14 fwd="187.122.124.193" dyno=web.1 connect=3ms service=952ms status=201 bytes=716
2015-08-05T22:24:51.054487+00:00 app[web.1]: Completed 201 Created in 860ms (Views: 54.3ms | ActiveRecord: 60.6ms)
2015-08-05T22:24:51.033541+00:00 app[web.1]:   ApiKey Load (4.2ms)  SELECT  `api_keys`.* FROM `api_keys` WHERE `api_keys`.`user_id` = 32 AND (created_at <= '2015-08-05 22:24:51.027693' AND expires_at >= '2015-08-05 22:24:51.027693')  ORDER BY `api_keys`.`id` ASC LIMIT 1
2015-08-05T22:24:51.053974+00:00 app[web.1]:   Rendered registrations/show.json.jbuilder (18.4ms)
```

The method request without "www":

``` swift
    Alamofire.request(.POST, "http://example.com/registrations.json").responseJSON(completionHandler: {(req, res, data) in
      switch data {
      case .Success(let json):
        let user = User(json: JSON(json))
        self.myApplication.storeUser(user)
        self.goNext()
      case .Failure(let data, let error):
        print(req, appendNewline: true)
        print(res, appendNewline: true)
        print(data, appendNewline: true)
        print(error, appendNewline: true)
      }
    })
```

Heroku server log without "www" , been hit with 'GET':

```
2015-08-06T15:28:04.642498+00:00 app[web.1]: Started GET "/registrations.json" for 187.122.124.193 at 2015-08-06 15:28:04 +0000
2015-08-06T15:28:04.756790+00:00 heroku[router]: at=info method=GET path="/registrations.json" host=www.example.com request_id=6a81c787-c720-47a0-9574-1b0f101a2279 fwd="187.122.124.193" dyno=web.1 connect=1ms service=126ms status=404 bytes=1744
2015-08-06T15:28:04.754988+00:00 app[web.1]:
2015-08-06T15:28:04.754994+00:00 app[web.1]: ActionController::RoutingError (No route matches [GET] "/registrations.json"):
2015-08-06T15:28:04.754996+00:00 app[web.1]:   vendor/bundle/ruby/2.2.0/gems/actionpack-4.2.3/lib/action_dispatch/middleware/debug_exceptions.rb:21:in `call'
2015-08-06T15:28:04.754997+00:00 app[web.1]:   vendor/bundle/ruby/2.2.0/gems/actionpack-4.2.3/lib/action_dispatch/middleware/show_exceptions.rb:30:in `call'
2015-08-06T15:28:04.754999+00:00 app[web.1]:   vendor/bundle/ruby/2.2.0/gems/railties-4.2.3/lib/rails/rack/logger.rb:38:in `call_app'
2015-08-06T15:28:04.755000+00:00 app[web.1]:   vendor/bundle/ruby/2.2.0/gems/railties-4.2.3/lib/rails/rack/logger.rb:20:in `block in call'
2015-08-06T15:28:04.755002+00:00 app[web.1]:   vendor/bundle/ruby/2.2.0/gems/activesupport-4.2.3/lib/active_support/tagged_logging.rb:26:in `tagged'
2015-08-06T15:28:04.755001+00:00 app[web.1]:   vendor/bundle/ruby/2.2.0/gems/activesupport-4.2.3/lib/active_support/tagged_logging.rb:68:in `block in tagged'
2015-08-06T15:28:04.755003+00:00 app[web.1]:   vendor/bundle/ruby/2.2.0/gems/activesupport-4.2.3/lib/active_support/tagged_logging.rb:68:in `tagged'
2015-08-06T15:28:04.755004+00:00 app[web.1]:   vendor/bundle/ruby/2.2.0/gems/railties-4.2.3/lib/rails/rack/logger.rb:20:in `call'
2015-08-06T15:28:04.755005+00:00 app[web.1]:   vendor/bundle/ruby/2.2.0/gems/actionpack-4.2.3/lib/action_dispatch/middleware/request_id.rb:21:in `call'
2015-08-06T15:28:04.755007+00:00 app[web.1]:   vendor/bundle/ruby/2.2.0/gems/rack-1.6.4/lib/rack/methodoverride.rb:22:in `call'
2015-08-06T15:28:04.755008+00:00 app[web.1]:   vendor/bundle/ruby/2.2.0/gems/rack-1.6.4/lib/rack/runtime.rb:18:in `call'
2015-08-06T15:28:04.755009+00:00 app[web.1]:   vendor/bundle/ruby/2.2.0/gems/activesupport-4.2.3/lib/active_support/cache/strategy/local_cache_middleware.rb:28:in `call'
2015-08-06T15:28:04.755010+00:00 app[web.1]:   vendor/bundle/ruby/2.2.0/gems/actionpack-4.2.3/lib/action_dispatch/middleware/static.rb:116:in `call'
2015-08-06T15:28:04.755011+00:00 app[web.1]:   vendor/bundle/ruby/2.2.0/gems/rack-1.6.4/lib/rack/sendfile.rb:113:in `call'
2015-08-06T15:28:04.755012+00:00 app[web.1]:   vendor/bundle/ruby/2.2.0/gems/railties-4.2.3/lib/rails/engine.rb:518:in `call'
2015-08-06T15:28:04.755014+00:00 app[web.1]:   vendor/bundle/ruby/2.2.0/gems/railties-4.2.3/lib/rails/application.rb:165:in `call'
2015-08-06T15:28:04.755021+00:00 app[web.1]:   vendor/bundle/ruby/2.2.0/gems/puma-2.12.2/lib/puma/configuration.rb:53:in `call'
2015-08-06T15:28:04.755022+00:00 app[web.1]:   vendor/bundle/ruby/2.2.0/gems/puma-2.12.2/lib/puma/server.rb:539:in `handle_request'
2015-08-06T15:28:04.755023+00:00 app[web.1]:   vendor/bundle/ruby/2.2.0/gems/puma-2.12.2/lib/puma/server.rb:386:in `process_client'
2015-08-06T15:28:04.755024+00:00 app[web.1]:   vendor/bundle/ruby/2.2.0/gems/puma-2.12.2/lib/puma/server.rb:269:in `block in run'
2015-08-06T15:28:04.755025+00:00 app[web.1]:   vendor/bundle/ruby/2.2.0/gems/puma-2.12.2/lib/puma/thread_pool.rb:106:in `call'
2015-08-06T15:28:04.755026+00:00 app[web.1]:   vendor/bundle/ruby/2.2.0/gems/puma-2.12.2/lib/puma/thread_pool.rb:106:in `block in spawn_thread'
```
  I have a problem with one request POST in ios using swift ...

In curl i send one request like this:

curl -H "Authorization: token ce2800d53d520b4a73a005a611d53d299e0c1d5e"....
and me server response with 200

However en ios i make me request like this:

let parametersH = [
    "Authorization": "token 9640e65f66429415fb9359739ed8bc3f57cb0566"
]

Alamofire.request(Alamofire.Method.POST, "httpURL", parameters: parameters,headers:parametersH).progress { bytesWritten, totalBytesWritten, totalBytesExpectedToWrite in
    }.responseJSON{ request, response, JSON, error in
        if (error == nil) {
            println(response)
        }
        else{
            println(error)
        }
    }

But.....When i send the request for first time.....After install the application...The request....is correct and send one code 200 But... i close the application, and when in run again... i send the same request....(In this moments i hardcode the tokens and the url , for reason of test ) the server responds with un 403 .... I dont know what happened...why the first time work very good and the second not work... The token ...when i test this case is valid..
 I ran into this same problem and have been debugging for an entire day and finally figured it out. I'm almost positive the OP was using Django and I'm almost positive this has nothing to do with `encoding: .URLEncodedInURL` as it was referenced in a subsequent pull request.

I'm also going to post on his unanswered StackOverflow question, but I'm going to add a post here because I think some documentation needs to be appended to Alamofire so others don't run into this issue. It's a subtlety with either Alamofire or the underlying Swift/Objective C networking code. I _think_ if Alamofire receives a `Set-Cookie` in a response header, that it will send this information as a `Cookie` payload in subsequent request headers. This is different behaviour than other HTTP networking libraries, for example retrofit, which I never ran into this issue when developing my iOS app's Android counterpart.

As it pertains to Django, Alamofire will send the `sessionid` cookie value under the hood on subsequent requests, which makes Django think a session has been started and then you haven't provided the correct CSRF tokens and it'll throw a 403 permissions error.

To get around this problem, and in general to stop Alamofire from auto sending cookie values, set

```
let headers = [
    "Cookie": ""
]
```

Please add this to the documentation if it isn't already. This burned an entire day of precious development time.
  Before change can't workÔºö func encodesParametersInURL(method: Method) -> Bool {
                switch method {
                case .GET, .HEAD, DELETE:
                    return true
                default:
                    return false
                }
            }

remove .DELETE in case
After the change good workÔºö  func encodesParametersInURL(method: Method) -> Bool {
                switch method {
                case .GET, .HEAD:
                    return true
                default:
                    return false
                }
            }

This is a bug?
   :ok_hand: ‚Äî sorry for overlooking #616
  After updating from 1.2.3 to 1.3.0 I started getting a quite peculiar and difficult to debug bug.  Before diving into the description, I do have a working solution, but the cause of the issue and even the reason for the solution working are both a bit perplexing right now...

I have an API Client class with a URLRequestConvertible Router enum that handles routing and I'm also using ObjectMapper (and AlamofireObjectMapper) to serialize response objects.
After updating to 1.3.0, suddenly my response blocks weren't being called at all.  I threw in some chained responseString() and responseJSON() handlers before the custom object handler, the responseJSON handler was rightfully throwing an error at serializing the response to JSON, as the responseString handler showed me the response payload was a whopping 10mB (expected maybe ~10kB).  This was happening for 2 specific endpoints, now is only happening with 1, all other API endpoints work fine.

Upon close inspection of the response string, I noticed that it was truncating the "normal" response a good way through (part way through a keyname in the JSON, or other places), and then repeating it, truncating/repeating a good number of times until it finally finishes properly.
I completely removed the custom object serialization and still saw the issue.  I even removed AlamofireObjectMapper entirely from the project and still saw the issue.

The API I'm using is internal so I can't divulge much details on the specs, but its also HTTPS making it slightly more difficult to debug.
I loaded up some certs and a mitm proxy HTTP(s) request sniffer (Cellist, and Charles, the latter worked better) and was able to watch the requests going out, After performing 1 request with Alamofire (and debugging when I perform that 1 request), println() shows 1 request fireoff in Xcode debug, but Charles (and Cellist) show a barrage of repeated requests, 245 to be exact in one measurement.  These requests/responses themselves looked quite innocent, all in tact for each one, but what was interesting is Charles was reporting "Client closed connection before receiving entire response"

Incidentally the "working" solution I found was to chain `.resume()` to all of my requests;  this is interesting because in the Docs it says one specifically needs to call `.resume()` if `startRequestsImmediately` is set to false.  I confirmed it indeed does "solve" the problem by also inspecting requests sent, and with `.resume()` chained to the end of the request it only ever sends 1 request.  When comparing requests/responses to the single/barrage cases, they're identical with the exception of the "Client closed connection before receiving entire response", leading me to believe Alamofire is somehow the culprit

Any guidance into further debugging how/where/why this is happening would be greatly appreciated.  I wish I could give some logs/screencaps but unfortunately its all confidential.
 Incidentally, `AlamofireObjectMapper` did indeed update for 1.3.0 which is actually what forced me to update Alamofire as well (I'm using Carthage, and `AlamofireObjectMapper` with carthage built nested frameworks which cant be submitted, so I had to add `AlamofireObjectMapper` as a submodule, when updating my git it broke causing me to need to update Alamofire as well).

As I mentioned, I removed all object serialization and even removed `AlamofireObjectMapper` enitrely from the project and was still seeing the issue.

I'm going to attempt to make a test project to see if I can externally reproduce the issue itself, Is there an email with which I can correspond with you on this issue?  The API i'm using is a company internal API which I don't wish to publicly post snippets to ;).

Thanks!
 Solved!  It was actually `BigBrother`

I took over /just/ my Router enum to a new standalone project and duplicated the request flow (auth first then broken endpoint).  With /just/ Alamofire, it worked perfectly fine.  After bringing in `BigBrother` and setting it up the same as in my main project:

``` swift
// Shouldn't do either of these!
BigBrother.addToSharedSession()   
BigBrother.addToSessionConfiguration(Alamofire.Manager.sharedInstance.session.configuration)
```

The issue was reproduced.  I commented out the `.addToSharedSession()` call and all of a sudden things worked great (Incidentally the setup there worked fine for 1.2.3 of `Alamofire`)
Changed fully now to use

``` swift
public class var manager: Alamofire.Manager {
    struct Singleton {
      static var configuration: NSURLSessionConfiguration = {
        var configuration = NSURLSessionConfiguration.defaultSessionConfiguration()

        BigBrother.addToSessionConfiguration(configuration)

        return configuration
        }()

      static let instance = Alamofire.Manager(configuration: configuration)
    }

    return Singleton.instance
  }
```

(A more appropriate way to set it up according to https://github.com/marcelofabri/BigBrother/issues/2 which says the 2nd way I was setting it up was wrong)

Incidentally I'm still unsure as to what's going on in the background that's causing requests to be closed prematurely and their responses to be compounded, but am glad to know the culprit at least :) (Not `Alamofire` /or/ `AlamofireObjectMapper` !)
Also incidentally, this would be a +1 to an Alamofire solution to the network activity indicator akin to `AFNetworking` ;) (I believe there's already some feature requests for this?)
Thanks for help and reading and hopefully this info can be useful to someone else in the future.
 I tend to agree with you there, no need wasting effort debugging things like this!  Especially with such a strange edge case (believe me, I always find those extreme edge cases -_-)

Since I encapsulate most of my networking logic in my apiclient class, and given your input, I may go with a different solution and use `BigBrother.Manager` and manually inc/dec activity count around each request/response, (also making it easier to do dependency injection to perhaps swap out another "activity indicator manager" like `PKNetworkActivityController`, something custom, or even mocked objects for testing)

This would be a bit more manual and will require conscious effort when adding in new requests (even outside the apiclient), but its worth the trade off of flexibility (and my sanity).

For anyone else wondering what this looks like, something simple like this

``` swift
import AlamoFire
public class ApiClient {
  static let sharedInstance = ApiClient()
  var incrementActivity: () -> Void = {}
  var decrementActivity: () -> Void = {}

  func search(query: String, callback: (data: AnyObject?) -> Void) {
    incrementActivity()
    Alamofire.request(Router.Search(query: query))
      .responseString { (_,_,data,error) in 
          if error != nil {
              callback(data: nil)
              return
         }
        callback(data: data)
      }
      .response { (_,_,_,_) in self.decrementActivity() }  // Call after other response handlers
  }
} 
```

``` swift
import BigBrother
let apiClient = ApiClient.sharedInstance
apiClient.incrementActivity  = { BigBrother.Manager.sharedInstance.incrementActivityCount()  }
apiClient.decrementActivity = { BigBrother.Manager.sharedInstance.decrementActivityCount() }

// alternatively
import PKNetworkActivityController
apiClient.incrementActivity  = { NetworkActivityController.sharedController.registerActivity()  }
apiClient.decrementActivity = { NetworkActivityController.sharedController.deregisterActivity() }

// finally
apiClient.search("lorem") { data in 
    println(data)
}
```
  ![screen shot 2015-08-03 at 5 25 09 pm](https://cloud.githubusercontent.com/assets/289994/9032713/a803787a-3a04-11e5-9bc4-2aed6ac205a8.png)
 This looks like this issue: https://github.com/Alamofire/Alamofire/issues/629 did that work for you?

Like it's said in that issue: you should ask these questions on StackOverflow, as it's a better place to get help when you need it :) https://github.com/Alamofire/Alamofire#communication
 Probably because that parameter list is changed in `swift-2.0` branch as `(NSURLRequest?, NSHTTPURLResponse?, Result<String>)`, so you have now too many parameters for it.
 The `Result` type was introduced by #627.
 Didn't catch the swift 2.0 part of this issue, my bad :) The new `Result` type looks great :+1: 
  The following code was working ok on XCode 6/Swift 1, but gives me an error on XCode 7/Swift 2

```
Alamofire.request(.POST, "\(self.REQ_URL)", parameters: parameters).validate(contentType: ["application/json"]).responseJSON(options: [], completionHandler: { (req, resp, data) -> Void in

        let data_ar = data as! NSArray //here I get the error 

        })
```

The error I get is

`Cast from 'Result' to unrelated type 'NSArray' always fails`

How am I supposed to use the returned JSON?
 @kylef How it will be this when you have your on Response serializer , here is my code for the ResponseObject

```
extension Request {
public func responseObject<T: ResponseObject>(completionHandler: (NSURLRequest, NSHTTPURLResponse?, T?, NSError?) -> Void) -> Self {

    let responseSerializer = GenericResponseSerializer<T> { request, response, data in
        let JSONResponseSerializer = Request.JSONResponseSerializer(options: .AllowFragments)
        let (JSON: AnyObject?, serializationError) = JSONResponseSerializer.serializeResponse(request, response, data)
        let result = JSON as? NSDictionary
        let codeKey: AnyObject? = result?["code"]
        if codeKey == nil{
            if let response = response, JSON: AnyObject = JSON {
                return (T(response: response, representation: JSON), nil)
            } else {
                return (nil,serializationError)
            }

        }else{
            return (nil, serializationError)
        } 
    }

    return response(responseSerializer: responseSerializer, completionHandler: completionHandler)
}
}
```

Then here is my call from the client side 

```
public func getDevice(uuid:String) -> Promise<Device>{
return Promise { fulfill, reject in
    let request = Alamofire.request(.GET, hostUrl + "/api/devices/" + uuid )
    request.responseObject { (request, response, device: Device?, error) in
        var statusCode = response?.statusCode
        if(error != nil) {
            return reject(error!)
        }
        if(statusCode < 200 || statusCode > 299) {
            return reject(NSError(domain: hostUrl + "/api/devices", code: statusCode!, userInfo: [:]))
        }
        fulfill(device!)
    }
}
}
```
 How to get data from JSON to Struct variable type.  I'm developing an iOS app in Xcode 6 with swift and using alamofire.

In the app user can download a large size file.The question is if I get "connection was lost" error, how I can grab downloaded data to resume later and not to start from the beginning?
  Only small fix to allow compilation of Example project
  I think using BooleanType is more Swift-like approach.
 Thanks for @cnoon and @kylef comments. I'm Swift newbie and I'm glad for all comments helping me to implement better apps.
  I need to create an Auth header for each request, i'm using OAuthorizationHeader to construct the header.

this is how I did it with ANetworking:

```
NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:@"POST" URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:nil];

NSString *header = OAuthorizationHeader(request.URL, @"POST", [request HTTPBody], self.accessToken, self.secret, nil, nil);
 [request setValue:header forHTTPHeaderField:@"Authorization"];
```

as you can see i'm building the OAuthorizationHeader using  [request HTTPBody], so I need to create the request first, and then add the header to the request

So i'm trying to understand how to do that with Alamofire, I don't see a way to add the header to a Request after it was created.

And I can't use the more general way of adding the header to the manager because the header is build from the request body.

any suggestions? 
  Solve small issue when source code is embedded in Swift 2 app targeting iOS 7
  I've tried these variations in my Cartfile:

github "Alamofire/Alamofire" "swift-2.0" 
git "https://github.com/Alamofire/Alamofire.git" "swift-2.0"

And I get this error each time when running carthage update:

fatal: Not a git repository (or any of the parent directories): .git

All of my other dependencies can clone and build - any ideas?
  I was getting errors in the ServerTrustPolicy class with the unmanaged object then i fixed it.
P.S. Sorry, I'm newbie
  I was getting errors in the ServerTrustPolicy class with the unmanaged object then i fixed it.
  It's building fine on simulator - but to device I'm getting this error
- but the dyld: Symbol not found: __TMPdVSs12_prext_Slice
  First call to google this - and no hits. So I'm capturing this crash for other people. 

Here's my gem file
### Gemfile

``` ruby
source 'https://rubygems.org'
gem 'cocoapods', '~> 0.38.0.beta.2'  
```
### Podfile

``` ruby
source 'https://github.com/CocoaPods/Specs.git'
platform :ios, '8.1'
use_frameworks!

pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'swift-2.0'
pod 'CocoaLumberjack/Swift', :git => 'https://github.com/CocoaLumberjack/CocoaLumberjack.git', :branch => 'swift_2.0'
pod 'CocoaLumberjack', :git => 'https://github.com/CocoaLumberjack/CocoaLumberjack.git', :branch => 'swift_2.0'
pod 'XLForm', :git => 'https://github.com/xmartlabs/XLForm.git'
pod 'SwiftyDrop', :path => "../SwiftyDrop"

#pod '', '~>1.0'

#pod 'SwiftSpinner'


#post_install do |installer|
#    installer.project.targets.each do |target|
#        if target.name == 'Pods-CocoaLumberJack'
#            config.build_settings['SUPPORTED_PLATFORMS'] = ['watchos', 'watchsimulator'];
#        end
#    end
#end

post_install do |installer|
    installer.pods_project.targets.each do |target|
        target.build_configurations.each do |config|
            config.build_settings['ONLY_ACTIVE_ARCH'] = 'NO'
        end
    end
end
```

App is crashing on device. 
- but the dyld: Symbol not found: __TMPdVSs12_prext_Slice
  Referenced from: /private/var/mobile/Containers/Bundle/Application/DCDD7D40-8B59-458A-B661-C455BB9A1208/FDChris.app/Frameworks/Alamofire.framework/Alamofire
  Expected in: /private/var/mobile/Containers/Bundle/Application/DCDD7D40-8B59-458A-B661-C455BB9A1208/FDChris.app/Frameworks/libswiftCore.dylib
  in /private/var/mobile/Containers/Bundle/Application/DCDD7D40-8B59-458A-B661-C455BB9A1208/FDChris.app/Frameworks/Alamofire.framework/Alamofire
 upgraded cocoapods. no joy  I'm compiling to  iphone 6 plus.
not sure if it's related - but I removed a bunch of pods and was seeing this error message. 

Reason: Incompatible library version: XXXXX requires version 2.0.0 or later, but CocoaLumberjack provides version 1.0.0

Using i18n 0.7.0
Using json 1.8.3
Using minitest 5.7.0
Using thread_safe 0.3.5
Using tzinfo 1.2.2
Using activesupport 4.2.3
Using claide 0.9.1
Using fuzzy_match 2.0.4
Using nap 0.8.0
Using cocoapods-core 0.38.2
Using cocoapods-downloader 0.9.1
Using cocoapods-plugins 0.4.2
Using cocoapods-stats 0.5.3
Using netrc 0.7.8
Using cocoapods-trunk 0.6.1
Using cocoapods-try 0.4.5
Using colored 1.2
Using escape 0.0.4
Using molinillo 0.3.1
Using xcodeproj 0.26.3
Using cocoapods 0.38.2
Using bundler 1.10.5
 I had a very similar problem on a totally different project. Clearing DerivedData fixed this in my case.
 It's misbehaving on ios 8.4 / iphone 6 device as well. I think it's related to my provisioning profile or cocoapods. going to close this. thanks
https://github.com/AFNetworking/AFNetworking/issues/2150 
https://developer.apple.com/library/ios/qa/qa1886/_index.html
  HI, I'm trying to make calls in background like POST,GET to be more precise in the didReceiveRemoteNotification method, because they work as a push notification arrive. My problem is that all the Alamofire.request are never call in Background mode  until I open the app then all works, as i said they are only GET,POST request nothing to download. Is there any way to let the request excute when the app is in Background and not to wit for he user to open the app.

Thanks in advance .
  Hi,

Carthage just pulled in version `1.3.0` (before: 1.2.3) and now XCode is complaining with `Cannot invoke 'response' with an argument list of type '((_, _, _, _) -> _)'`:

```
        // start download
        let download = Alamofire.download(.GET, url, destination)
            .progress { bytesRead, totalBytesRead, totalBytesExpectedToRead in
...
            }
            .response { request, response, _, error in
...
        }
```

I checked the documentation if anything changed, but I am doing it [exactly like the documentation states](https://github.com/Alamofire/Alamofire#downloading-a-file-wprogress). Am I doing something wrong?
 My understanding is that these questions should be taken to StackOverflow as that's a better place to ask for support. That being said I had this issue and solved it by being more explicit in my definition and not using `_` in the callback. Try something in the lines of:

```
 Alamofire
      .request(.GET, ..., ...)
      .responseJSON { (request, response, JSON, error) -> Void in
        if let error = error {
          println("Error")
        } else if let json: AnyObject = JSON {
          println("\(JSON)")
        } else {
         println("Something went wrong")
        }
      }
```
  :+1: This is exactly the approach we took in the layer that wraps Alamofire calls. Would love to get rid of handling that ‚Äúthird case‚Äù in our code!
 Same here, now I can get rid of my own `Result` type. I love that! üëè :+1: :100: 
 :+1: 
 @cnoon 
I've been calling .validate() before calling .responseObject (As documented in the README). Let's assume for a second that the server returns a 401 status code (which would mean that in the responseObject, the failureReason would be whatever it is in the validate method). 

What if the server was sending a json back that describes what the actual error was? How would I get that to pass along with validate?

Thanks!
 @pranavss11 

``` swift
case .Failure(let data, let error):
```

The `data` is the actual error response from the server.

Example:
If the json error response back from the server looks like this:

``` json
{"message":"Error description"}
```

You can do something like this:

``` swift
let task = Alamofire.request(urlRequest)
            .validate()
            .responseJSON { (request, response, result) in

                switch result {

                case .Success(let json):

                    print("JSON Response: \(JSON)")

                case .Failure(let data, let error):

                    let errorData = NSString(data: data!, encoding:NSUTF8StringEncoding)

                    print("error message: \(errorData!)")
                }
        }
```
 @blured2000 Hey I'm ussing responseObject for my calls.  I'm getting the statuscode but I can get the JSON error how can I do this? this is my code

```
    let responseSerializer = GenericResponseSerializer<T> { request, response, data in

        let JSONResponseSerializer = Request.JSONResponseSerializer(options: .AllowFragments)
        let (JSON: AnyObject?, serializationError) = JSONResponseSerializer.serializeResponse(request, response, data)

        let result = JSON as? NSDictionary
        let codeKey: AnyObject? = result?["code"]
        if codeKey == nil{
            if let response = response, JSON: AnyObject = JSON {
                return (T(response: response, representation: JSON), nil)
            } else {
                return (nil, serializationError)
            }

        }else{
            return (nil, serializationError)
        }
```
 @cnoon but when you do Mapping is the same?, I'm mapping the result to an Object like this

```
public func getDevices(limit:String, skip:String, sort:String) -> Promise<Array<Device>>{
    return Promise { fulfill, reject in
            let request = Alamofire.request(.GET, hostUrl + "/api/devices?" + "limit=" + limit + "&skip=" + skip + "&sort=" + sort )
               request.responseCollection { (request, response, devices: [Device]?, error) in

                var statusCode = response?.statusCode
                    if(error != nil) {
                        return reject(error!)
                    }
                    if(statusCode < 200 || statusCode > 299) {
                        return reject(NSError(domain: hostUrl + "/api/devices", code: statusCode!, userInfo: [:]))
                    }
                    fulfill(devices!)
            }
}
}
```

I'm using alamofire 1.3.1
 As I see, data object eventually got removed from `.Failure` case in latest version. As of this change, how can we extract an error message from response body when request fails?
 I'm wondering this too. What's the go-to way to get the body of the response when things fail?

Edit: You can find an optional `NSData` in `response.data`.
  - Alamofire 1.3.0
- Carthage 0.7.5
- Xcode 6.4
- Swift 1.2

I use Alamofire 1.3.0 with Carthage. It works when it was 1.2.3 but 1.3.0 outputs error when using 1.3.0.

```
2015-07-29 19:07:34.019 dyld: lazy symbol binding failed[D: Symbol not found: __TFO9Alamofeire17ParameterEncoding6encodefS0b_FTPS_21URLRequestConvertible_10uparametersGSqGVSs10DictionarySSPgSs9AnyObject____TCSo12NSURLReque]stGSqCSo7NSError__
  Referenced  from: /Users/moritanaoki/Library[/Developer/CoreSimulator/DevicesS/ACFF4AC5-B2EC-4831-822A-3006009yA88BB/data/Containers/Bundle/Appnlication/6FE2D54F-3947-472F-80BFc-4481D2FFE84A/sync-messenger-qa.Mapp/sync-messenger-qa
  Expecteda in: /Users/moritanaoki/Library/nDeveloper/CoreSimulator/Devices/aACFF4AC5-B2EC-4831-822A-3006009Ag88BB/data/Containers/Bundle/Appleication/6FE2D54F-3947-472F-80BF-r4481D2FFE84A/sync-messenger-qa.a.pp/Frameworks/Alamofire.frameworsk/Alamofire
```
 THX!
  I'm getting the final error after running Carthage update:-

**\* Building scheme "Alamofire iOS" in Alamofire.xcworkspace
*\* BUILD FAILED **

The following build commands failed:
    CompileSwift normal x86_64 /Users/robinmalhotra/Developer/alamo/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift
    CompileSwift normal x86_64 /Users/robinmalhotra/Developer/alamo/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift
    CompileSwiftSources normal x86_64 com.apple.xcode.tools.swift.compiler
(3 failures)
/Users/robinmalhotra/Developer/alamo/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift:31:10: error: enum cases require explicit raw values when the raw type is not integer literal convertible
/Users/robinmalhotra/Developer/alamo/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift:125:30: error: cannot invoke 'append' with an argument list of type '(Unmanaged<SecCertificate>)'
/Users/robinmalhotra/Developer/alamo/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift:167:13: error: cannot invoke 'SecTrustSetPolicies' with an argument list of type '(SecTrust, [Unmanaged<SecPolicy>!])'
/Users/robinmalhotra/Developer/alamo/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift:173:17: error: cannot invoke 'SecTrustSetPolicies' with an argument list of type '(SecTrust, [Unmanaged<SecPolicy>!])'
/Users/robinmalhotra/Developer/alamo/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift:204:17: error: cannot invoke 'SecTrustSetPolicies' with an argument list of type '(SecTrust, [Unmanaged<SecPolicy>!])'
/Users/robinmalhotra/Developer/alamo/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift:253:30: error: cannot invoke 'append' with an argument list of type '(Unmanaged<SecCertificate>)'
/Users/robinmalhotra/Developer/alamo/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift:261:62: error: 'Unmanaged<CFData>!' is not convertible to 'NSData'
/Users/robinmalhotra/Developer/alamo/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift:272:29: error: cannot invoke 'publicKeyForCertificate' with an argument list of type '(Unmanaged<SecCertificate>)'
/Users/robinmalhotra/Developer/alamo/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift:286:35: error: cannot invoke 'SecTrustCreateWithCertificates' with an argument list of type '(SecCertificate, Unmanaged<SecPolicy>!, inout SecTrust?)'
/Users/robinmalhotra/Developer/alamo/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift:289:25: error: cannot assign a value of type 'Unmanaged<SecKey>!' to a value of type 'SecKey?'
A shell task failed with exit code 65:
*\* BUILD FAILED **

The following build commands failed:
    CompileSwift normal x86_64 /Users/robinmalhotra/Developer/alamo/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift
    CompileSwift normal x86_64 /Users/robinmalhotra/Developer/alamo/Carthage/Checkouts/Alamofire/Source/ServerTrustPolicy.swift
    CompileSwiftSources normal x86_64 com.apple.xcode.tools.swift.compiler
(3 failures)
 Seeing the same problem on XC7-beta4, all be it using CocoaPods.

+1
 Okay, I got it. For some reason, Xcode-beta decided not to update from the App Store beyond 7A121l. Redownloading from developer.apple.com fixed this issue.
 Happy to help :)
  Hi @cnoon 

Build fails during Archive with the following log:

```
Pods.build/Release-iphoneos/Alamofire.build/Objects-normal/arm64/ServerTrustPolicy.o

 Assertion failed: (isa<X>(Val) && "cast<Ty>() argument of incompatible type!"), function cast, file /Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-700.0.47.4/src/llvm/include/llvm/Support/Casting.h, line 237.
 0  swift                    0x000000010b037b8b llvm::sys::PrintStackTrace(__sFILE*) + 43
 1  swift                    0x000000010b0382cb SignalHandler(int) + 379
 2  libsystem_platform.dylib 0x00007fff8cd85eaa _sigtramp + 26
 3  libsystem_platform.dylib 0x00007fc1f543aa30 _sigtramp + 1751862176
 4  libsystem_c.dylib        0x00007fff9553e41b abort + 129
 5  libsystem_c.dylib        0x00007fff95505a64 basename + 0
 6  swift                    0x0000000109550a10 hoistOrCopySelf(swift::ApplyInst*, swift::SILInstruction*, swift::DominanceInfo*, bool) + 624
 7  swift                    0x00000001095503ef swift::ArraySemanticsCall::hoistOrCopy(swift::SILInstruction*, swift::DominanceInfo*, bool) + 319
 8  swift                    0x00000001093a14bb (anonymous namespace)::SwiftArrayOptPass::run() + 4283
 9  swift                    0x00000001093140ae swift::SILPassManager::runFunctionPasses(llvm::ArrayRef<swift::SILFunctionTransform*>) + 1598
 10 swift                    0x0000000109314d28 swift::SILPassManager::runOneIteration() + 984
 11 swift                    0x0000000109311cd4 swift::runSILOptimizationPasses(swift::SILModule&) + 500
 12 swift                    0x000000010901de08 performCompile(swift::CompilerInstance&, swift::CompilerInvocation&, llvm::ArrayRef<char const*>, int&) + 9992
 13 swift                    0x000000010901b4e3 frontend_main(llvm::ArrayRef<char const*>, char const*, void*) + 2627
 14 swift                    0x00000001090175af main + 2015
 15 libdyld.dylib            0x00007fff8cadf5ad start + 1
 Stack dump:
  ...
 -o /Users/kamol/Library/Developer/Xcode/DerivedData/ShoppingXXX-dlpuiajnjtnnesfkfvqddrrirgnd/Build/Intermediates/ArchiveIntermediates/ShoppingXXX/IntermediateBuildFilesPath/Pods.build/Release-iphoneos/Alamofire.build/Objects-normal/arm64/ServerTrustPolicy.o 
 1. While running SILFunctionTransform "SIL Swift Array Optimization" on SILFunction "@_TFO9Alamofire17ServerTrustPolicy19evaluateServerTrustfS0_FTCSo8SecTrust14isValidForHostSS_Sb".
```

My Podfile:

```
   pod 'Alamofire', :git => 'git@github.com:Alamofire/Alamofire.git', :tag => 'swift-2.0'
```
 @cnoon sorry, it was typo. I am on Xcode 7 Beta 4.
 @cnoon all good, thank you!
 Still get multiple errors. Is this because I'm on El Capitan?

![screen shot 2015-07-29 at 11 47 59 pm](https://cloud.githubusercontent.com/assets/5009041/8965975/50ea1bd6-364c-11e5-8517-7e08314702e7.png)
 ^ +1 - I'm seeing these errors regardless of which beta I try to compile it on.  (Also running El Capitan)

Also, I understand that the latest commits require beta4, but if I'm not ready to upgrade Xcode yet... what is the last commit on the swift-2.0 branch that is known to work with beta2?
 @bruceflowers I think it didn't work for me in beta2.
But beta4 works.
  Doing a simple request with GET adds my parameters nicely, but doing a POST doesn't.

``` swift
let parameters = ["foo": "bar"]

Alamofire.request(.POST, "url", parameters: parameters)
.responseJSON { request, response, json, error in
  print("request: \(request)")
}
```

returns

`request: Optional(<NSMutableURLRequest: 0x7f9864109cb0> { URL: https://api.github.com/repos/BasThomas/junk/issues })`

while

``` swift
let parameters = ["foo": "bar"]

Alamofire.request(.GET, "url", parameters: parameters)
.responseJSON { request, response, json, error in
  print("request: \(request)")
}
```

returns

`request: Optional(<NSMutableURLRequest: 0x7f9ef07ef0f0> { URL: https://api.github.com/repos/BasThomas/junk/issues?foo=bar })`

Am I missing something here?
 I'm getting the same issue, and I starting to believe it is an issue within Alamofire core code.
I did found solutions on Stack Overflow, but they are work arounds, and doesn't look like a nice code. I think it's more important to solve it properly.
 You should probably set the encoding to `.JSON`.
 Tried, didn't helped.
Tried to test with all mentioned methods that made sense, but no luck. Backend wasn't receiving any parameters using POST method.
Unless I add them straight to the URL part as postfix "...?key=value"
I also used NSURLSession and NSURLRequest in the past, so I know backend part worked. And it works when I test with Postman (i.e. plugin on Chrome).
 I think I might be on to an answer for this behaviour.
I noticed that I have specified header Content-Type : "application/json" for POST method, and I think it should be "application/x-www-form-urlencoded" or similar in my case for that particular request. Or probably just remove it from header and add "..., encoding: .URL, ..." to request.
Haven't tested it properly so can't fully confirm if this truly solves the issue.
 Thank you @cnoon . It worked for me ..I just changed the encoding from .JSON to . URLEncodedInURL it worked like charm
 Somebody help me please,
swift compiler doesn't compile large parameters array.
What should i do?  ``` swift
public func URLSession(session: NSURLSession, task: NSURLSessionTask, didCompleteWithError error: NSError?) {
    if let taskDidComplete = taskDidComplete {
        taskDidComplete(session, task, error)
    } else if let delegate = self[task] {
        delegate.URLSession(session, task: task, didCompleteWithError: error)
        self[task] = nil
    }
}
```

Should self[task] = nil be outside the else branch?. As far as I can see, if taskDidComplete override is successfully called, the task will remain lost forever in subdelegates, at least until the session is destroyed. I can't see any other place where a completed task is removed.
  Fixes #610.
Thanks to @robrasmussen!
 Quite happy to help, even if it turned out to be superfluous.
  Added a note to the backwards compatibility explanation for 1.3.0 for the changes to the return type for encoding. This is a change that affects backwards compatibility.
 That makes sense. It actually shouldn't change backwards compatibility, considering `NSMutableURLRequest` is a subclass of `NSURLRequest`.

When I was updating to use `Alamofire 1.3.0` yesterday, I was getting some odd build errors that looked related to this, but now I'm unable to replicate them. It may have been a derived data problem. Xcode does some odd things sometimes.
  I made a blank director with the `Cartfile` that reads:

```
github "Alamofire/Alamofire" "swift-2.0"
```
- `carthage update --configuration Debug` will build successfully 
- `carthage update` fails
 See #610.
  Look at image here:- http://i.imgur.com/pPi2TUg.png

A bunch of errors needing fixing.
 Did you check https://github.com/Alamofire/Alamofire/pull/609#issuecomment-125070311?
 Okay, so just rebuild with Xcode beta 4?

If anything else is wrong, I'll reopen this issue.
 Hi,

After migrating to Xcode 7 beta 4 and pulling code from the Alamofire swift-2.0 branch, my project could not run anymore. 
Any idea on the fix?
Thanks in advance!
![capture d ecran 2015-07-28 a 10 22 56](https://cloud.githubusercontent.com/assets/8101982/8926773/a5835800-3512-11e5-93b6-dd861ef4bb2b.png)
 Thanks. For further reference, I could not use the use_frameworks! setup my Podfile because it broke my other pods so I ended using Carthage just to import Alamofire.
   @tomco think you should also check the "Shared" checkbox in the watchOS scheme, else Carthage will not be able to discover the scheme when running `carthage update`
 @jurvis thx missed that. Fixed now.
  Hi,

I have the following problem:

We fire requests against a sync api. If we have any server changes we get a **200** with the according json which includes the modified entities.
If we have no changes we correctly get a **304** from the sever, but Alamofire caches the latest 200 response and provides it instead. So it is impossible to know if we got a 304 (because that would mean we don't have to do anything). 

We could disable the cache, but that would mean we lose the 304 caching convenience for all the other requests that have nothing to do with syncing.

**Recommendation**: Maybe it would be useful to manually disable/enable the cache for every request (is that somehow possible?) or to provide something like 'original status code'.
That are just the first thoughts, maybe you come up with a better solution.

Or did I miss something?
 Hey cnoon! Thx for the reply!

So I missed something ;) 
Thanks for the hint. I already had to build a custom URL Request because this is the only way to send a JSON array in a post body. So it was only one line for the cachePolicy ;)

Sorry, stackoverflow would've been the better place for this question.
 Facing a similar problem, even the server returns 304, the NSCachedURLResponse is always 200 and hide the "original status code" since the whole caching is handled under the hood.

So you can save that cache anyways, and while providing the correct `If-Modified-Since` or `If-None-Match` values in the next request, iOS will still send the request, get a 304 from server, and then give you a 200 NSCachedURLResponse again

Ref: me (I used a proxy to observe the 304) + this guy: http://andrewmarinov.com/ioss-corenetwork-lying/
 hi @cnoon  https://github.com/Alamofire/Alamofire/blob/swift-2.0/Tests/ValidationTests.swift#L238-L260 is already down. Can share here how to disable caching for GET request?
 I'd appreciate it as well
 Please, i would really like a good example to solve this issue.
 It looks like they probably moved these test to Tests/CacheTests.swift
 In my case it worked like this:

```swift
let headers: HTTPHeaders = [ "Some-Header": "value"]
let route: URL = URL(string: "https://..")!
let parameters: Parameters = ["name": "value"]

var originalRequest = try! URLRequest(url: route, method: .post, headers: headers)

// This is the important line.
originalRequest?.cachePolicy = .reloadIgnoringCacheData 

let encodedURLRequest = try! URLEncoding.default.encode(originalRequest, with: parameters)

Alamofire.request(encodedURLRequest).responseJSON { response in
	// Handle stuff...
}
```  I ran into the same issues as mentioned here:
https://github.com/Alamofire/Alamofire/issues/610

Forking and doing my own exploration, I found a number of type errors. Using the method `takeRetainedValue()` alleviated those errors. Additionally, I could not get release versions to build unless I shut off optimization.

If optimization is on, it throws the following error (full directory paths removed):

``` swift
Assertion failed: (isa<X>(Val) && "cast<Ty>() argument of incompatible type!"), function cast, file /Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-700.0.45/src/llvm/include/llvm/Support/Casting.h, line 237.
0  swift                    0x00000001104a501b llvm::sys::PrintStackTrace(__sFILE*) + 43
1  swift                    0x00000001104a575b SignalHandler(int) + 379
2  libsystem_platform.dylib 0x00007fff8674cf1a _sigtramp + 26
3  libsystem_platform.dylib 0x00007ffd745349a0 _sigtramp + 3990780576
4  libsystem_c.dylib        0x00007fff88bd6b53 abort + 129
5  libsystem_c.dylib        0x00007fff88b9ec39 basename + 0
6  swift                    0x000000010e9c4d20 hoistOrCopySelf(swift::ApplyInst*, swift::SILInstruction*, swift::DominanceInfo*, bool) + 624
7  swift                    0x000000010e9c46ff swift::ArraySemanticsCall::hoistOrCopy(swift::SILInstruction*, swift::DominanceInfo*, bool) + 319
8  swift                    0x000000010e817edb (anonymous namespace)::SwiftArrayOptPass::run() + 4283
9  swift                    0x000000010e78b49e swift::SILPassManager::runFunctionPasses(llvm::ArrayRef<swift::SILFunctionTransform*>) + 1598
10 swift                    0x000000010e78c118 swift::SILPassManager::runOneIteration() + 984
11 swift                    0x000000010e7890c4 swift::runSILOptimizationPasses(swift::SILModule&) + 500
12 swift                    0x000000010e497ff8 performCompile(swift::CompilerInstance&, swift::CompilerInvocation&, llvm::ArrayRef<char const*>, int&) + 9576
13 swift                    0x000000010e495873 frontend_main(llvm::ArrayRef<char const*>, char const*, void*) + 2515
14 swift                    0x000000010e4919ff main + 1983
15 libdyld.dylib            0x00007fff8b56a5c9 start + 1
Stack dump:
0.  Program arguments: /Applications/Xcode-beta.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c PATH_TO_ALAMO/Alamofire/Source/Upload.swift PATH_TO_ALAMO/Alamofire/Source/ParameterEncoding.swift PATH_TO_ALAMO/Alamofire/Source/Request.swift PATH_TO_ALAMO/Alamofire/Source/ResponseSerialization.swift PATH_TO_ALAMO/Alamofire/Source/Manager.swift PATH_TO_ALAMO/Alamofire/Source/Alamofire.swift PATH_TO_ALAMO/Alamofire/Source/MultipartFormData.swift -primary-file PATH_TO_ALAMO/Alamofire/Source/ServerTrustPolicy.swift PATH_TO_ALAMO/Alamofire/Source/Download.swift PATH_TO_ALAMO/Alamofire/Source/Validation.swift -target x86_64-apple-ios8.0 -enable-objc-interop -sdk /Applications/Xcode-beta.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator9.0.sdk -I HOME/Library/Developer/Xcode/DerivedData/Alamofire-gtihnsuowttctwaxgdndjwvmkgvf/Build/Products/Release-iphonesimulator -F HOME/Library/Developer/Xcode/DerivedData/Alamofire-gtihnsuowttctwaxgdndjwvmkgvf/Build/Products/Release-iphonesimulator -application-extension -g -import-underlying-module -module-cache-path HOME/Library/Developer/Xcode/DerivedData/ModuleCache -serialize-debugging-options -Xcc -IHOME/Library/Developer/Xcode/DerivedData/Alamofire-gtihnsuowttctwaxgdndjwvmkgvf/Build/Intermediates/Alamofire.build/Release-iphonesimulator/Alamofire iOS.build/swift-overrides.hmap -Xcc -iquote -Xcc HOME/Library/Developer/Xcode/DerivedData/Alamofire-gtihnsuowttctwaxgdndjwvmkgvf/Build/Intermediates/Alamofire.build/Release-iphonesimulator/Alamofire iOS.build/Alamofire-generated-files.hmap -Xcc -IHOME/Library/Developer/Xcode/DerivedData/Alamofire-gtihnsuowttctwaxgdndjwvmkgvf/Build/Intermediates/Alamofire.build/Release-iphonesimulator/Alamofire iOS.build/Alamofire-own-target-headers.hmap -Xcc -IHOME/Library/Developer/Xcode/DerivedData/Alamofire-gtihnsuowttctwaxgdndjwvmkgvf/Build/Intermediates/Alamofire.build/Release-iphonesimulator/Alamofire iOS.build/Alamofire-all-non-framework-target-headers.hmap -Xcc -ivfsoverlay -Xcc HOME/Library/Developer/Xcode/DerivedData/Alamofire-gtihnsuowttctwaxgdndjwvmkgvf/Build/Intermediates/Alamofire.build/all-product-headers.yaml -Xcc -iquote -Xcc HOME/Library/Developer/Xcode/DerivedData/Alamofire-gtihnsuowttctwaxgdndjwvmkgvf/Build/Intermediates/Alamofire.build/Release-iphonesimulator/Alamofire iOS.build/Alamofire-project-headers.hmap -Xcc -IHOME/Library/Developer/Xcode/DerivedData/Alamofire-gtihnsuowttctwaxgdndjwvmkgvf/Build/Products/Release-iphonesimulator/include -Xcc -IHOME/Library/Developer/Xcode/DerivedData/Alamofire-gtihnsuowttctwaxgdndjwvmkgvf/Build/Intermediates/Alamofire.build/Release-iphonesimulator/Alamofire iOS.build/DerivedSources/x86_64 -Xcc -IHOME/Library/Developer/Xcode/DerivedData/Alamofire-gtihnsuowttctwaxgdndjwvmkgvf/Build/Intermediates/Alamofire.build/Release-iphonesimulator/Alamofire iOS.build/DerivedSources -Xcc -ivfsoverlay -Xcc HOME/Library/Developer/Xcode/DerivedData/Alamofire-gtihnsuowttctwaxgdndjwvmkgvf/Build/Intermediates/Alamofire.build/Release-iphonesimulator/Alamofire iOS.build/unextended-module-overlay.yaml -Xcc -working-directoryPATH_TO_ALAMO/Alamofire -emit-module-doc-path HOME/Library/Developer/Xcode/DerivedData/Alamofire-gtihnsuowttctwaxgdndjwvmkgvf/Build/Intermediates/Alamofire.build/Release-iphonesimulator/Alamofire iOS.build/Objects-normal/x86_64/ServerTrustPolicy~partial.swiftdoc -O -module-name Alamofire -emit-module-path HOME/Library/Developer/Xcode/DerivedData/Alamofire-gtihnsuowttctwaxgdndjwvmkgvf/Build/Intermediates/Alamofire.build/Release-iphonesimulator/Alamofire iOS.build/Objects-normal/x86_64/ServerTrustPolicy~partial.swiftmodule -serialize-diagnostics-path HOME/Library/Developer/Xcode/DerivedData/Alamofire-gtihnsuowttctwaxgdndjwvmkgvf/Build/Intermediates/Alamofire.build/Release-iphonesimulator/Alamofire iOS.build/Objects-normal/x86_64/ServerTrustPolicy.dia -emit-dependencies-path HOME/Library/Developer/Xcode/DerivedData/Alamofire-gtihnsuowttctwaxgdndjwvmkgvf/Build/Intermediates/Alamofire.build/Release-iphonesimulator/Alamofire iOS.build/Objects-normal/x86_64/ServerTrustPolicy.d -emit-reference-dependencies-path HOME/Library/Developer/Xcode/DerivedData/Alamofire-gtihnsuowttctwaxgdndjwvmkgvf/Build/Intermediates/Alamofire.build/Release-iphonesimulator/Alamofire iOS.build/Objects-normal/x86_64/ServerTrustPolicy.swiftdeps -o HOME/Library/Developer/Xcode/DerivedData/Alamofire-gtihnsuowttctwaxgdndjwvmkgvf/Build/Intermediates/Alamofire.build/Release-iphonesimulator/Alamofire iOS.build/Objects-normal/x86_64/ServerTrustPolicy.o 
1.  While running SILFunctionTransform "SIL Swift Array Optimization" on SILFunction "@_TFO9Alamofire17ServerTrustPolicy19evaluateServerTrustfS0_FTCSo8SecTrust14isValidForHostSS_Sb".
```
 These changes shouldn't be necessary if you upgrade Xcode 7 to beta4.
 https://github.com/Alamofire/Alamofire/pull/609#issuecomment-125070311
  I am currently on Xcode7 Beta 4.

And error is not clear:

```
Command failed due to signal: Abort trap: 6
```
 me too
 when I Archive my Project 

## 1.  While running SILFunctionTransform "SIL Swift Array Optimization" on SILFunction "@_TFO9Alamofire17ServerTrustPolicy19evaluateServerTrustfS0_FTCSo8SecTrust14isValidForHostSS_Sb".

Assertion failed: (isa<X>(Val) && "cast<Ty>() argument of incompatible type!"), function cast, file /Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-700.0.47.4/src/llvm/include/llvm/Support/Casting.h, line 237.
0  swift                    0x000000010d4dbb8b llvm::sys::PrintStackTrace(__sFILE_) + 43
1  swift                    0x000000010d4dc2cb SignalHandler(int) + 379
2  libsystem_platform.dylib 0x00007fff99efeeaa _sigtramp + 26
3  libsystem_platform.dylib 0x00007fa52d3dba30 _sigtramp + 2471349152
4  libsystem_c.dylib        0x00007fff99c0f41b abort + 129
5  libsystem_c.dylib        0x00007fff99bd6a64 basename + 0
6  swift                    0x000000010b9f4a10 hoistOrCopySelf(swift::ApplyInst_, swift::SILInstruction_, swift::DominanceInfo_, bool) + 624
7  swift                    0x000000010b9f43ef swift::ArraySemanticsCall::hoistOrCopy(swift::SILInstruction_, swift::DominanceInfo_, bool) + 319
8  swift                    0x000000010b8454bb (anonymous namespace)::SwiftArrayOptPass::run() + 4283
9  swift                    0x000000010b7b80ae swift::SILPassManager::runFunctionPasses(llvm::ArrayRefswift::SILFunctionTransform*) + 1598
10 swift                    0x000000010b7b8d28 swift::SILPassManager::runOneIteration() + 984
11 swift                    0x000000010b7b5cd4 swift::runSILOptimizationPasses(swift::SILModule&) + 500
12 swift                    0x000000010b4c1e08 performCompile(swift::CompilerInstance&, swift::CompilerInvocation&, llvm::ArrayRef<char const*>, int&) + 9992
13 swift                    0x000000010b4bf4e3 frontend_main(llvm::ArrayRef<char const*>, char const_, void_) + 2627
14 swift                    0x000000010b4bb5af main + 2015
15 libdyld.dylib            0x00007fff8879a5ad start + 1
Stack dump:
  This PR is to make the Example app full screen.
  ![screen shot 2015-07-27 at 11 37 12 am](https://cloud.githubusercontent.com/assets/12408685/8899595/fd650560-3453-11e5-819b-6cc8b338455f.png)
 I add the Alamofire using Pod file
pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'swift-2.0'

after pod install. I can't build the project
 You should update Xcode 7 to beta 4 as discussed in #609.
 Thanks..
  On swift-2.0 branch, using XC7b4:

```
$ xcodebuild -project Alamofire.xcodeproj/
...
CompileSwift normal arm64 /Users/paul/work/opensource/Alamofire/Source/ServerTrustPolicy.swift
...
Assertion failed: (isa<X>(Val) && "cast<Ty>() argument of incompatible type!"), function cast, file /Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-700.0.47.4/src/llvm/include/llvm/Support/Casting.h, line 237.
0  swift                    0x000000010cee3b8b llvm::sys::PrintStackTrace(__sFILE*) + 43
1  swift                    0x000000010cee42cb SignalHandler(int) + 379
2  libsystem_platform.dylib 0x00007fff8e11cf1a _sigtramp + 26
3  libsystem_platform.dylib 0x00007fbb5aaebe30 _sigtramp + 3432836912
4  libsystem_c.dylib        0x00007fff8f9fdb53 abort + 129
5  libsystem_c.dylib        0x00007fff8f9c5c39 basename + 0
6  swift                    0x000000010b3fca10 hoistOrCopySelf(swift::ApplyInst*, swift::SILInstruction*, swift::DominanceInfo*, bool) + 624
7  swift                    0x000000010b3fc3ef swift::ArraySemanticsCall::hoistOrCopy(swift::SILInstruction*, swift::DominanceInfo*, bool) + 319
8  swift                    0x000000010b24d4bb (anonymous namespace)::SwiftArrayOptPass::run() + 4283
9  swift                    0x000000010b1c00ae swift::SILPassManager::runFunctionPasses(llvm::ArrayRef<swift::SILFunctionTransform*>) + 1598
10 swift                    0x000000010b1c0d28 swift::SILPassManager::runOneIteration() + 984
11 swift                    0x000000010b1bdcd4 swift::runSILOptimizationPasses(swift::SILModule&) + 500
12 swift                    0x000000010aec9e08 performCompile(swift::CompilerInstance&, swift::CompilerInvocation&, llvm::ArrayRef<char const*>, int&) + 9992
13 swift                    0x000000010aec74e3 frontend_main(llvm::ArrayRef<char const*>, char const*, void*) + 2627
14 swift                    0x000000010aec35af main + 2015
15 libdyld.dylib            0x00007fff979b95c9 start + 1
Stack dump:
0.  Program arguments: ...
1.  While running SILFunctionTransform "SIL Swift Array Optimization" on SILFunction "@_TFO9Alamofire17ServerTrustPolicy19evaluateServerTrustfS0_FTCSo8SecTrust14isValidForHostSS_Sb".
```

Apparently an Apple bug, but it‚Äôs breaking Carthage builds for client projects.
 Do you have any workarounds for this?
 Seems the debug build is working but the release is crashing.
 Disabling Swift optimisation on the Release builds seems to be a workaround. 
 Is there any possible create a new Branch without disabling Travis CI for swift 2.0.when I use the 1.2.3 there is some wrong happened.
<img width="540" alt="-1" src="https://cloud.githubusercontent.com/assets/4208695/8909915/872b78f8-34b6-11e5-88f2-cc5ad2e39b85.png">
 I isolated the offending line. Tried a few different things, but for now this gets rid of the compilation error in beta4 until someone figures out a better way to fix it:

```
diff --git a/Source/ServerTrustPolicy.swift b/Source/ServerTrustPolicy.swift
index 3022d58..59b1314 100644
--- a/Source/ServerTrustPolicy.swift
+++ b/Source/ServerTrustPolicy.swift
@@ -178,7 +178,7 @@ public enum ServerTrustPolicy {
                 serverTrustIsValid = trustIsValid(serverTrust)
             } else {
                 let serverCertificatesDataArray = certificateDataForTrust(serverTrust)
-                let pinnedCertificatesDataArray = certificateDataForCertificates(pinnedCertificates)
+                let pinnedCertificatesDataArray = certificateDataForCertificates([] + pinnedCertificates)

                 outerLoop: for serverCertificateData in serverCertificatesDataArray {
                     for pinnedCertificateData in pinnedCertificatesDataArray {
```
 Nice job¬†finding that workaround, @robrasmussen!
 HTH, thanks for the awesome library.
 This isn't just for release but essentially any configuration that is not debug
   Hey @cnoon it definitely wouldn't compile for me until I made these changes, using Version 7.0 beta 3 (7A152u).  Not entirely sure whether the code should be taking or unretained values here but I figure there is something else strongly holding onto the objects by the callees.  Wanted to see if others could guarantee this is the case.
 @robskillington That is because you are using beta 3, as opposed to the current `swift-2.0` branch is compatible with beta 4.
 I see.
  How do you handle this kind of response using the ResponseObject? I want to use ResponseObject but before using ResponseObject I want to check if the `success` is `true` or `false`

``` json
{
   "success": true,
   "data": null,
   "errors": [
       {
          "field": "username",
          "message": "Username cannot be blank."
       }
   ]
}
```

or even

``` json
{
   "success": true,
   "data": {
       "username": "John Doe",
       "email": "johndoe@yahoo.com"
   },
   "errors": []
}
```
  Trying to use CloudFlare api to get the users information. Need to send headers with the call and it doesn't seem to work with Alamofire.

```
override func viewDidLoad() {
    super.viewDidLoad()
    // Do view setup here.
    let manager = Alamofire.Manager.sharedInstance
    // Add API key header to all requests make with this manager (i.e., the whole session)
    manager.session.configuration.HTTPAdditionalHeaders = [
        "X-Auth-Email": "\(passedEmail)",
        "X-Auth-Key": "\(passedApiKey)",
        "Content-Type": "application/json"
    ]
    manager.request(.GET, "https://api.cloudflare.com/client/v4/user")
        .responseJSON { _, _, JSON, _ in
            println(JSON)
    }
}
```

Is this a bug or am I doing something wrong?
  Hi All,
I am using  Alamofire.request  for my project and just wondering how can i load the data before loading the page.  
I want to use the data to populate the UI.  

The data coming back after the screen loaded and my screen crashes due to not having the data loaded before the screen load.

Note: I am calling a Alamofire.request  on viewDidLoad method.

override func viewDidLoad(){

}

Thanks 
    Hi, i'm trying to send a JSON object to my server, however i get an empty array:

 request(.POST, PROFILE_URL, parameters: customer, encoding: ParameterEncoding.JSON).responseJSON(options: NSJSONReadingOptions.AllowFragments) { (request, response, json, error) -> Void in

(lldb) po customer
["addresses": (
        {
        address = "c/ Juan Ricardo de Dios, Madrid";
        addressName = "Mi primo Richard";
        id = 1;
        idDeliveryArea = 1;
        nonSelectableArea = Elda;
        phone = 96543234;
    },
        {
        address = "c/ Fernando Soria";
        addressName = "Hermano Juan";
        id = 2;
        idDeliveryArea = 2;
        nonSelectableArea = Petrer;
        phone = 96542134;
    }
), "idsFavorites": (
    1,
    2,
    3
), "id": 1, "lastName": Sanchez Valid√≠simo, "currentSelectedAddress": {
    address = "c/ Fernando Soria";
    addressName = "Hermano Juan";
    id = 2;
    idDeliveryArea = 2;
    nonSelectableArea = Petrer;
    phone = 96542134;
}, "birthdate": 616940595, "email": valid@valid.com, "name": Valido]

(lldb) 
And in the server i get:
[23-Jul-2015 18:01:47 Europe/Berlin] Array
(
)

If i change the parameter encoding to URL i get a BAD formatted json (the addresses are converted into an array or any random thing):
[23-Jul-2015 18:07:23 Europe/Berlin] Array
(
    [addresses] => Array
        (
            [0] => Array
                (
                    [nonSelectableArea] => Elda
                )

```
        [1] => Array
            (
                [address] => c/ Juan Ricardo de Dios, Madrid
            )

        [2] => Array
            (
                [idDeliveryArea] => 1
            )

        [3] => Array
            (
                [id] => 1
            )

        [4] => Array
            (
                [addressName] => Mi primo Richard
            )

        [5] => Array
            (
                [phone] => 96543234
            )

        [6] => Array
            (
                [nonSelectableArea] => Petrer
            )

        [7] => Array
            (
                [address] => c/ Fernando Soria
            )

        [8] => Array
            (
                [idDeliveryArea] => 2
            )

        [9] => Array
            (
                [id] => 2
            )

        [10] => Array
            (
                [addressName] => Hermano Juan
            )

        [11] => Array
            (
                [phone] => 96542134
            )

    )

[birthdate] => 616940595
[currentSelectedAddress] => Array
    (
        [nonSelectableArea] => Petrer
        [address] => c/ Fernando Soria
        [idDeliveryArea] => 2
        [id] => 2
        [addressName] => Hermano Juan
        [phone] => 96542134
    )

[email] => valid@valid.com
[id] => 1
[idsFavorites] => Array
    (
        [0] => 1
        [1] => 2
        [2] => 3
    )

[lastName] => Sanchez Valid√≠simo
[name] => Valido
```

)
  - Calling Alamofire.request on ~>1.2 works on Run, and UI testing
- Calling Alamofire.request on feature/server_trust_policy works on Run, but breaks UI testing.

**References PR:**
#581

**Xcode version:**
Version 7.0 beta 3 (7A152u)

**iOS target:**
9.0

**Runtime error:**

```
dyld: lazy symbol binding failed: Symbol not found: __TIF9Alamofire7requestFTOS_6Method9URLStringPS_20URLStringConvertible_10parametersGSqGVSs10DictionarySSPSs9AnyObject___8encodingOS_17ParameterEncoding7headersGSqGS2_SSSS___CS_7RequestA1_
  Referenced from: /Users/username/Library/Developer/CoreSimulator/Devices/FD595F7F-44A6-442F-BEDF-CB6CEAED7AB0/data/Containers/Bundle/Application/6C62A10A-FD8B-4C72-A039-C0DAD4DA43D8/Demo.app/Demo
  Expected in: /Users/username/Library/Developer/CoreSimulator/Devices/FD595F7F-44A6-442F-BEDF-CB6CEAED7AB0/data/Containers/Bundle/Application/6C62A10A-FD8B-4C72-A039-C0DAD4DA43D8/Demo.app/Frameworks/Alamofire.framework/Alamofire
```
 Simulator iPad 2, iOS 9

> On Jul 20, 2015, at 22:38, Christian Noon notifications@github.com wrote:
> 
> Against which device and/or simulator?
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 Hey guys I have a question is Alamofire available for swift 2 ?
 That's right @cnoon . Sorry; I forgot to mention that I used the builtin converter when I used `~>1.2` and `feature/server_trust_policy`.
 For anyone who's having the same issue. Just delete the project's derived data. This works for Xcode Version 7.0 beta 4 (7A165t). Ref: http://stackoverflow.com/a/31385277/968219
  branch swift2.0, request a media such as http://img4.douban.com/lpic/s3863556.jpg in simulator throw an error! but on ipad did not have this problem. In master banch, it works well!
  Can you please update pod to include MultipartFormData uploading?
  Release version 1.2.3 does not have the Alamofire.request(method,url,parameters,headers) version. It has the Alamofire.request(method,url,parameters) version. The github web page documents the the first version but when the library is installed via the cocoa pods utility, that functionality is not available.
 Ok thank you but the installation process in the web page lead me to believe that installing via cocoa pods would allow me to use the version documented in the master branch. That's all I'm pointing out. 
  @cnoon Will give it a try today or tomorrow, thanks for the PR!
 Hi @cnoon!

 First, great work on the detailed PR you always create, really good work :+1: 

Second, it works well with a Rails app that returns `head :no_content` . :100: 

As for the test, can't you stub the response, or at least try to modify it (removing the accept type) just before passing it to the validation?

Thanks!
 @cnoon It is still not working. I don't know what I have supposed to use for this kind of request. The request is correct (checked by Postman), but Alamofire throws HTTP 404 and I am still screwed... May I help you with some kind of testing?
 @Jirka1111 Make sure you use the latest release :)
 @allaire Dear allaire, I certainly use Alamofire 1.3.0. The request is:

Alamofire.request(.PUT, "https://(domainText).projektove.cz/issues/(self.ids[indexPath.row]).done.json")
                .validate(statusCode: 200..<300)
                .validate(contentType: ["_/_"])
                .responseJSON { (request, response, data, error) in ...

This is the output of response and error:

Optional(<NSHTTPURLResponse: 0x7ffd8e111250> { URL: https://mnd.projektove.cz/issues/151.done.json } { status code: 404, headers {
    Connection = "keep-alive";
    "Content-Length" = 485;
    "Content-Type" = "text/html; charset=utf-8";
    Date = "Wed, 29 Jul 2015 20:58:18 GMT";
    Server = "nginx/1.8.0";
    "X-Rack-Cache" = "invalidate, pass";
    "X-Request-Id" = 704421789695500c680a8131d085780f;
    "X-Runtime" = "0.005469";
} })

Optional(Error Domain=NSCocoaErrorDomain Code=3840 "The operation couldn‚Äôt be completed. (Cocoa error 3840.)" (Invalid value around character 0.) UserInfo=0x7ffd8bc053d0 {NSDebugDescription=Invalid value around character 0.})

I am little confused. If I use Postman, everything is fine and I get HTTP 204. But Alamofire gives me 404, which is the same as when I copy and paste the URL to the Chrome (The page don't exist).
 @cnoon Thank you, I will try that solution. This can¬¥t be done by Alamofire?
 @cnoon Yeah, so now I am not any smarter. If Alamofire can processed this kind of action, I presumed there should be answer. Not just "proof of concept". I was blocked at Stackoverflow due to questions without answer so I can't asked another question. As I understand, my request should work. I don't want to use another library (or same library in different language). I am very satisfied with Alamofire, so I don't have a problem with some kind of a code "hack". HTTP 204 is common so I don't understand why there is not a solution (maybe in instructions?).
 @cnoon I am sorry, cnoon, I understand you. But you don't understand me. I am receiving 204 in Postman but 404 in Alamofire so I think it is not a problem with code. And that is why I still write to this thread. But ok, thank you a have a great time :-)
  Pulled in all recent changes from Master, resolved any conflicts I encountered, and it now builds without any issues. All unit tests currently included pass as well.

I've only been actively using (not just reading about) Swift for the last two weeks, so please forgive any newbish mistakes, and I would greatly appreciate any comments, suggestions, etc.
 No worries. At the very least, I learned quite a bit. I look forward to the updates from the team, and hopefully I can contribute in some way in the future.

Cheers üçª
  Is there any way to use it at swift 2.0 now?
 @cnoon Oh, I see. Is there any way how I can to solve this problem for now ?
 It's ok for me wait to the next week. 
Thanks !
   Swift2.0 branch, when the request method is used to carry out the URL request, the URL is found to be changed into HTTPS by HTTP, which leads to response error.
 I found that there is a bug to get image data in simulator. for example, to get this image url:http://img4.douban.com/lpic/s3863556.jpg  then throw an exception. I can see it in safari!
  @cnoon I totally agree with you. I also think it is ok to break the rules(semver) once a while. Just need to make sure to document it well. So that when people update their dependencies(which include Alamofire) no matter with or without the knowledge that there's a breaking change, they can find their answer quick.

Great job on the change itself and the comment about it. Thank you for being patient explaining everything. :)

Have a good day.
  There are many errors in xcode7. 
 Same here. Used the swift-2.0 branch like so: 
pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'swift-2.0'

Getting a lot errors. Can be more specific if needed.
  ### Support for plain text and json parts in a multipart-form upload

**TL;DR:**

I needed support for text / json parts in a multipart-form upload, added a single function to do so, and forked Alamofire here: https://github.com/chrisco314/Alamofire/tree/multipart_data_form_support_for_additional_data_types to do so.

**Context:**

I posted a question to SO here: http://stackoverflow.com/questions/31442411/alamofire-support-for-uploading-multipart-forms-with-text-and-file-parts in my efforts to figure out how to upload textual data in tandem with binary data, but got no response.

**Implementation:**

In the end, to achieve the compact form of:

```
form.appendBodyPart(Multipart.plain("patient", text:"\(last.id!)")!)
```

I needed to add a single override to MultipartFormData.swift:

```
/**
Creates a body part from the data and appends it to the multipart form data object.

The body part data will be encoded using the following format:

- `Content-Disposition: form-data; name=#{name}` (HTTP Header)
- Encoded file data
- Multipart form boundary

:param: headers The headers to encode into the `multipart-form` part.
:param: data The data to encode into the `multipart-form` part.
*/
public func appendBodyPart(#headers:[String: String], data: NSData) {

    let bodyStream = NSInputStream(data: data)
    let bodyContentLength = UInt64(data.length)
    let bodyPart = BodyPart(headers: headers, bodyStream: bodyStream, bodyContentLength: bodyContentLength)
    self.bodyParts.append(bodyPart)
}
```

This allowed me to add support for text and json data payloads through the code pasted below. The approach I took was to build up abstracted multipart-data parts through the use of typesafe enums and method chaining:

```
    class MultipartPlain : MultipartProtocol {

        init?(name:String, text:String) {

            // initialize header
            self.headers = MultipartHeader()
                .contentType(.Plain)
                .contentDisposition(.Name(name))

            // serialize body
            self.body = text.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)
            if self.body == nil {
                return nil
            }
        }

        /// The headers used to generate a `text/plain` part in a `multipart/form-data` part
        let headers:MultipartHeader

        /// The body used to generate a `text/plain` part in a `multipart/form-data` part
        var body:NSData!
    }
```

The extension code in its entirety is:

```
import Alamofire



/**
Extension to the Alamofire MultipartFormData type to support direct
construction of `multipart/form-data` parts
*/
extension MultipartFormData {

    func appendBodyPart(part:MultipartProtocol) {

        let headers = part.headers
        let bodyStream = NSInputStream(data: part.body)
        let bodyContentLength = UInt64(part.body.length)
        appendBodyPart(headers:headers.headers, data:part.body)
    }
}

/**
Protocol that defines the behavior of `multipart/form-data` parts, allowing
extension to parts of different types, while hiding implementation details
*/
protocol MultipartProtocol {
    /// The headers used to generate a part in a `multipart/form-data` part
    var headers:MultipartHeader { get }

    /// The body used to generate a part in a `multipart/form-data` part
    var body:NSData! { get }
}


/**
Builds legal `multipart/form-data` parts, conforming to MultipartProtocol
*/
class Multipart {

    class func json(name:String, parameters:[String:AnyObject]) -> MultipartProtocol? {
        return MultipartJson(name:name, parameters: parameters) }

    class func plain(name:String, text:String) -> MultipartProtocol? {
        return MultipartPlain(name:name, text:text) }

    /**
    Constructs an `application/json` part in a `multipart/form-data` body
    */
    class MultipartJson : MultipartProtocol {

        init?(name:String, parameters:[String:AnyObject]) {

            // initialize header
            self.headers = MultipartHeader()
                .contentType(.JSON)
                .contentDisposition(.Name(name))

            // serialize body
            let options = NSJSONWritingOptions.allZeros
            var error:NSError?
            self.body = NSJSONSerialization.dataWithJSONObject(parameters, options: options, error: &error)

            if self.body == nil {
                return nil
            }
        }

        /// The headers used to generate an `application/json` part in a `multipart/form-data` part
        let headers:MultipartHeader

        /// The body used to generate an `application/json` part in a `multipart/form-data` part
        var body:NSData!
    }

    /**
    Constructs a `text/plain` part in a `multipart/form-data` body
    */
    class MultipartPlain : MultipartProtocol {

        init?(name:String, text:String) {

            // initialize header
            self.headers = MultipartHeader()
                .contentType(.Plain)
                .contentDisposition(.Name(name))

            // serialize body
            self.body = text.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)
            if self.body == nil {
                return nil
            }
        }

        /// The headers used to generate a `text/plain` part in a `multipart/form-data` part
        let headers:MultipartHeader

        /// The body used to generate a `text/plain` part in a `multipart/form-data` part
        var body:NSData!
    }
}


/**
Defines legal `MIME` type values for the `Content-Type` header of `multipart/form-data`
*/
enum Mime : String {
    case MultipartMixed = "multipart/mixed"
    case JSON = "application/json"
    case Plain = "text/plain"
}


/**
Defines legal Disposition values for the `Content-Disposition` header of `multipart/form-data`
*/
enum Disposition {
    case FormData
    case Name(String)
    case FileName(String)

    var encoded:String {
        switch self {

        case FormData:
            return "form-data"

        case Name(let name):
            return "name=\"\(name)\""

        case FileName(let name):
            return "filename=\"\(name)\""
        }
    }
}


/**
Constructs `multipart/form-data` headers via the method chaining pattern.
*/
class MultipartHeader {

    enum Key : String {
        case ContentType = "Content-Type"
        case ContentDisposition = "Content-Disposition"
    }

    /**
    Defines the `Content-Type` header and returns the instance of MultipartHeader
    upon which this call is made

    :param: mimeType  The desired MIME type, as defined by the Mime enumeration

    :returns: The instance of Multipart header upon which this call is made
    */
    func contentType(mimeType:Mime) -> MultipartHeader {
        headers[Key.ContentType.rawValue] = "\(mimeType.rawValue)"
        return self
    }


    /**
    Defines the `Content-Disposition` header with a single disposition value and
    returns the instance of MultipartHeader upon which this call is made

    :param: mimeType  The desired MIME type, as defined by the Disposition enumeration

    :returns: The instance of Multipart header upon which this call is made
    */
    func contentDisposition(disposition:Disposition) -> MultipartHeader {

        headers[Key.ContentDisposition.rawValue] =
            Disposition.FormData.encoded + "; " + disposition.encoded
        return self
    }

    /**
    Defines the Content-Disposition header with multiple disposition value and
    returns the instance of MultipartHeader upon which this call is made

    :param: mimeType  The desired MIME type, as defined by the Disposition enumeration

    :returns: The instance of Multipart header upon which this call is made
    */
    func contentDisposition(values:Disposition...) -> MultipartHeader {

        headers[Key.ContentDisposition.rawValue] = Disposition.FormData.encoded + "; "
            + "; ".join(map(values) { (d:Disposition) in d.encoded})
        return self
    }

    /// The resulting set of `multipart/form-data` headers
    var headers:[String:String] = [Key.ContentDisposition.rawValue: Disposition.FormData.encoded]
}


extension MultipartHeader : Printable {
    var description:String {
        return "Headers: \n\t"
            + "\n\t".join(map(self.headers.keys) { key in "\(key): \(self.headers[key]!)" })
    }
}
```

**Summary:**

With the modest addition of the single function override above, I was able to add support for additional data types.  I hope that you can merge this change with your repository.  I also think that the extensions above for supporting additional types are clean, type-safe, and error resilient. I hope that it could help provide a path to extended type support.
 Short answer: No, I needed `text/plain` in the end

**In more detail:**

In the end, I needed to send plain text and not JSON (I did not have complete information when I started).  That meant that I had to manually create a "Multipart" object for `text/plain`, hence the method.  That method though, is as simple as it gets, is orthogonal, and could / would generally be the base two which others defer.

**Approach taken** 

To achieve my final goal, I could have hacked a couple more one-off functions and been done, but the approach I took allowed me a typesafe and modular means of building up Multipart objects, and by chaining the headers - themselves comprised of any combination of values.  For example, I noticed two function overloads for Content-Disposition, but neither worked for me and it didn't seem right to keep writing new combinations.  To that end, I added the variadic overload that would allow the flexibility to add any combination of fields:

```
    func contentDisposition(values:Disposition...) -> MultipartHeader {

        headers[Key.ContentDisposition.rawValue] = Disposition.FormData.encoded + "; "
            + "; ".join(map(values) { (d:Disposition) in d.encoded})
        return self
    }
```

**Improvements to the Api** 

While I am on the topic, I think the API for this functionality could be improved.  The `multipartFormData` callback feels neither necessary nor complete.  looking at the code, it only really just creates a generic `MultipartFormData` object and passes it back.  This could be done much more easily by having a default parameter on upload that constructed one.  The problem with the current form is that it turns out that calls to `appendBodyPart` can fail, and there is no way to stop the train at that point, you just get missing data on the server.

I am newer to functional programming, and I appreciate that you have kept your API dogma free, but going further (and cleaner), you could instead offer a failable initializers on `MultipartFormData` or method chaining that returns an optional self, to arrive at the following (more modular) approach:

```
Alamofire.upload(
    authorizedRequest(.Attachments, method: .POST,  authToken: authToken),
    multipartFormData: MultipartFormData(
        Multipart.plain("id", value:last.id),
        Multipart.json("someJsonData", details:details),
        Multipart.file(firstFile, name: "file1"),
        Multipart.file(secondFile, name: "file2")),
    encodingCompletion: { encodingResult in
        // ..
    })
```

or

```
Alamofire.upload(
    authorizedRequest(.Attachments, method: .POST,  authToken: authToken),
    multipartFormData: MultipartFormData()
        .appendBodyPart(Multipart.plain("id", value:last.id!))
        ?.appendBodyPart(Multipart.json("someJsonData", parameters:parameters))
        ?.appendBodyPart(fileURL: fileToUpload, name: "file1") {
        ?.appendBodyPart(fileURL: someOtherFile, name: "file2") {
    encodingCompletion: { encodingResult in
        // ..
    })
```

In the first case , you would use a variadic initializer taking optional values, and in the second use method chaining that returns optionals, to produce a final optional value that could then be accepted or rejected by `upload` depending on whether or not the optional `MultipartFormData` was valid.  To me, this is simpler, cleaner, as it is easy to construct, and fails immediately and decisively.  Both forms are equivalent, but I find the former to be simpler-looking, and more concise.

The use of optionals could also facilitate the functional / monad style of chaining, though the API would by no means be impacted by this, or carry any baggage to support it - it's just a potential bonus.  (I am by no means an expert in this area, I've just seen it used, and understand optionals to be the foundation for it)
 You do have a point, my issue when looking through that code initially though, was that it suggested a file, assumed a file, and hardcoded `filename` into the header.  In hindsight, I wish I had tested that, but thought at the time that it would cause problems with the server and felt that needed more control over the headers (for full disclosure, I have worked a lot with networking API's, but I was testing testing and inspecting headers with `curl` and `nc -L`).  To the point though, note that the function you suggest defers to this:

```
private func contentHeaders(#name: String, fileName: String, mimeType: String) -> [String: String] {
    return [
        "Content-Disposition": "form-data; name=\"\(name)\"; filename=\"\(fileName)\"",
        "Content-Type": "\(mimeType)"
    ]
}
```

To be fair, in my case, after I realized (in at least one case) that the server would not take json, I could have used this function that is implicitly hardcoded to assume `text/plain`, by virtue of it not taking a MIME type (which could then have just as easily taken data in String form):

```
public func appendBodyPart(#data: NSData, name: String) {
    let headers = contentHeaders(name: name)
    let bodyStream = NSInputStream(data: data)
    let bodyContentLength = UInt64(data.length)
    let bodyPart = BodyPart(headers: headers, bodyStream: bodyStream, bodyContentLength: bodyContentLength)

    self.bodyParts.append(bodyPart)
}
```

I think at that point, I already had my code written, and felt that I would need JSON later on.

I do think though that my original point remains with the proposed function though.  Since it assumes nothing at all - it can serve all needs.  Far from being a special case, it would be the absolute most general case, the function through which all related code-paths could flow.  

In summary though, my the key point here is the function that you suggest is assuming too much, and in doing so, is less flexible and extensible, and can consequently the API can be more difficult and less intuitive to apply to a wider range of cases where servers need particular header attributes.  Instead of trying to anticipate future needs, you could instead make it simpler, more general, and adopt any good adaptations that come out of it as a bonus.

As a bit of an side, I still feel that my other points remain, that the means of configuring the `MultipartFormData` could be simpler while again being more general, and consequently more flexible. Frankly speaking, when using the multipart-form API, I was left with the impression that it deviated from the modular-construction form of the rest of the API - .GET / .POST etc. calls, that allowed you to build your own request object, and configure your headers.  To me, it was different enough that it felt like two libraries had been merged - it seemed to break the existing conventions.  I do think the approach of failable initializers presents a simpler, more intuitive alternative, and would not be hard to implement.

I do appreciate your hard work though; I don't mean this to sound like a criticism.  It can't be easy working through all the cases.  

Thanks
 Right, pretty close.  Apologies for the verbosity, I was trying to be unambiguous without being curt, here is the digest version:

On the topic of `appendBodyPart` (and for all code in general), don't assume more than you have to:
1. `appendBodyPart(fileData:name:fileName:mimeType:)` is unnecessarily specific in that it assumes a file
2. `appendBodyPart(data:name:)` is unnecessarily restrictive, it assumes a plain text payload
3. `appendBodyPart(data:name:type:)` would be unnecessarily restrictive as it would restrict other headers like `content-transfer-encoding`
4. don't try to anticipate all options, present and future, allow at least one "designated initializer" that assumes nothing and allows the caller to specify everything they need, make this the base call through which all others flow
5. and nitpicky, but general convention is that key comes before value, header comes before body, so the order of the parameters `data`, `name` seems unnatural

On the topic of `upload`:
1. don't add a callback unless it adds value (does asynchronous processing), in this case, it merely adds complexity and decreases flexibility
2. there are no obvious ways to do error handling when adding parts to `MultipartFormData`, the closure is unnecessary and prevents error handling, forcing an upload even when an error is known.  You can detect an error, but the train has left the station and you cannot stop it since the callback has no return value
3. keep things as simple as possible, user constructed instance type parameters are simpler than closures, `upload` overrides could provide pre-configured `MultipartFormData` instances
4. failable initializers offer a graceful way of chaining operations, while catching results, and without any baggage, allow more modern programming techniques - see Monads and "railway oriented programming"

And having since worked with `download`:
- it takes unnecessary effort to get the final download name, see multiple posts (not of my own) on Stackoverflow, here is one example: http://stackoverflow.com/questions/26307170/alamofire-download-method-where-is-the-file-and-did-it-save-successfully

Cheers
 Hi 

How to support multipart/mixed as content type?

Thanks
  The removal of respondsToSelector seems to have broken NTLM (and maybe other authentification methods?) support. I've opened a separate issue #721 for this.
  There is error when you post data with nested arrays. It mix up internal array. I then used AFNetworking and it worked fine.

Sample data like
service[days[]] Required: Days Array
service[days[0][slots[]]]   Required: Slots Array
service[days[0][slots[0][start_time]]]
 http://stackoverflow.com/questions/27794918/sending-array-of-dictionaries-with-alamofire

Take a look at this. This is kind of issue i am facing. Point is that same data posted correct with AFNetworking. Please take a look at it. It will be a small tweak to handle this type of post data
  This would [speed up building](https://github.com/Carthage/Carthage#archive-prebuilt-frameworks-into-one-zip-file) via Carthage by quite a bit, since it automatically downloads those if they exist instead of building from scratch each time. Shouldn't be too hard to do manually, but can also be done automatically via Travis's [tagged releases](http://docs.travis-ci.com/user/deployment/releases/). Examples include: [Quick](https://github.com/Quick/Quick/releases), [Nimble](https://github.com/Quick/Nimble/releases), and [Carthage itself](https://github.com/Carthage/Carthage/releases). Thanks for the great library!
 It seems like the Travis configuration is fairly straightforward using `travis setup releases` from the command line.

The real work here appears to be in [archiving prebuilt frameworks into one zip file](https://github.com/Carthage/Carthage#archive-prebuilt-frameworks-into-one-zip-file).

Carthage does this by [having Travis run a script](https://github.com/Carthage/Carthage/blob/9ed50ca26c5e911b3648c1b056386bfa4cefdad3/.travis.yml#L9) that [calls a Makefile](https://github.com/Carthage/Carthage/blob/5fb852d7c8bbd666e9dbec51ab54c258a2b38b2c/script/cibuild#L20) which [creates a zip file](https://github.com/Carthage/Carthage/blob/master/Makefile#L59-L68).
 That's a good point, didn't realize prebuilt frameworks carried that restriction. Thanks for the update.
 @cnoon do you have a link to the previous blog post they mention or where it states that they are tied to a specific version of Xcode and Swift?
 @kylef would you mind posting a link?
 :pray:
 @paulyoung You can find it at https://developer.apple.com/swift/blog/?id=2 Thanks @kylef! Better late than never üòÉ   i using cartfile for alamofire, the cartfile show below:

github "Alamofire/Alamofire" "swift-2.0"

when i run carthage update command, it product some complie error below:

*\* BUILD FAILED **

The following build commands failed:
    CompileSwift normal x86_64 /Users/wangxiaotao/Documents/JRFoundation/Carthage/Checkouts/Alamofire/Source/Upload.swift
    CompileSwift normal x86_64 /Users/wangxiaotao/Documents/JRFoundation/Carthage/Checkouts/Alamofire/Source/ParameterEncoding.swift
    CompileSwift normal x86_64 /Users/wangxiaotao/Documents/JRFoundation/Carthage/Checkouts/Alamofire/Source/Request.swift
    CompileSwift normal x86_64 /Users/wangxiaotao/Documents/JRFoundation/Carthage/Checkouts/Alamofire/Source/ResponseSerialization.swift
    CompileSwiftSources normal x86_64 com.apple.xcode.tools.swift.compiler
(5 failures)

My mac installed Xcode6.3 and Xcode7.0-betaÔºå could you tell me how to fixed this complie error? thanks
 Are you switching the command line tool to beta one? `sudo xcode-select -switch /Applications/Xcode-beta.app`
  :+1: Looks good to me.
  Is this possible?

```
let urlRequest // NSMutableURLRequest
upload(urlRequest,
    multipartFormData: { multipartFormData in
        // Append data
    },
    encodingCompletion: { encodingResult in
        switch encodingResult {
        case .Success(let upload, _, _):
            upload.responseJSON { request, response, object, error in
                // Handle response
            }
        case .Failure(let encodingError):
            // Handle encoding failure
        }
}).progress { (bytesWritten, totalBytesWritten, totalBytesExpectedToWrite) in // This doesn't seem to work... can we do this?
    println(totalBytesWritten)
}
```
 Thank you @cnoon!
 Example of this: http://stackoverflow.com/a/34077577/8047

Though @cnoon's answer is quite enough, thanks!
  I create a custom `NSURLSessionConfiguration` with additional http headers. Pass it to `Alamofire.Manager(configuration:)` initialiser and make a request:

``` swift
let config = NSURLSessionConfiguration.defaultSessionConfiguration()
let kcService = KeychainService()
if let accessToken = kcService[AccessTokenKey] {
    config.HTTPAdditionalHeaders = ["Authorization": "bearer \(accessToken)"]
}

let sessionManager = Alamofire.Manager(configuration: config)

sessionManager.request(.GET, "https://site/secret", parameters: nil, encoding: .URL)
    .responseJSON(options: NSJSONReadingOptions(0)) { (request, response, responseObject, error) -> Void in
    }
```

The closure always has a `request` and `error` objects, `response` and `responseObject` are always `nil`. Error object contains standard `-999` error.

Help?
  The feature was merged into master, but is not yet ported over to Swift 2.0. Thanks in advance!
  Will this be supported?
 Thank u. I mean there is no API in alamofire that can download one file using 2 threads?

I know that I can download many files at a time, but it seems one file one thread. So if I want to use 2 threads to download one file I might have to manually set the request header  to indicate the byte range?
 I want to build a OS X downloader program. The file on the remote sever can be big. So I wonder if multiple TCP connections can be established to make it download faster? ---  I'm learning the swift &  documentation. Please just ignore me if the question is not good. (Thank you for the great work Alamofire. The Apple API is broken, built for last century. @cnoon 
 This is exactly what I'm looking to do as well, It would be amazing if it was supported 
  allowInvalidCertificates but protected with pinning would be great for development purposes
 Well done @cnoon! Thanks. I've successfully used this on my own shared manager instance.

Instead of implementing our own shared instance of manager, is there a way to set this default for `Alamofire.Manager.sharedInstance`? Would be easier to use `Alamofire.request` etc... iOS9 is requiring HTTPS anyway.
 Anyone have a code snippet that demonstrates how to use this?

Personally I'm pinning a self signed cert which I imagine would be a very common usage.
 @zgosalvez or anyone who loves racing, just `public` the `NSURLSession` extension inside ServerTrustPolicy.swift so you can access `sharedInstance.session.ServerTrustPolicyManager`
 I only took a look at this now (better late than never I hope), and I've got to say, great job @cnoon ! I really like your `NSURLSession` extension integration and how you added the per-host settings with the umbrella `ServerTrustPolicyManager`.
The one thing I would like to lobby for is a small addition to the Alamofire README and/or in-code documentation: that setting `validateCertificateChain` to `false` still leads to a byte equality check on certificates/keys. Or perhaps some example use-cases (is using an invalid certificate while in dev as @vkedwardli mentioned the primary one ?) to set the minds of the jittery like me at ease =)
This is actually what led to starting #356. When looking into AFNetworking a while back, the `validatesCertificateChain` property sounded a bit dangerous, and I didn't feel comfortable setting it to `false` without looking at the source code. Alamofire didn't have certificate pinning at that point and so it seemed like a good way to try and help out. It makes sense knowing the domain vocabulary of TLS and X.509 certificates but some extra hand-holding might be nice for a security feature ?
 Hello, 

I am using Alamofire this way:

```
Alamofire.request(.POST, "https://www.test.com/test.php", parameters: ["cardNumber": cardNumber,     "cardCode": cardCode]).responseJSON { response in
                    print(response.request)  // original URL request
                    print(response.response) // URL response
                    print(response.data)     // server data
                    print(response.result)   // result of response serialization

            }
```

Any idea on how to implement SSL Pinning in it ? 
I just can't understand how .. 

Thank you.
 @FaridHaddad https://github.com/Alamofire/Alamofire/pull/581#issuecomment-215528326 and for later investigators, do this:


```swift
let serverTrustPolicies: [String: ServerTrustPolicy] = [
    "www.test.com": .pinCertificates(
        certificates: ServerTrustPolicy.certificates(),
        validateCertificateChain: true,
        validateHost: true
    ),
    "insecure.expired-apis.com": .disableEvaluation
]

let sessionManager = SessionManager(
    serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies)
)

sessionManager.request(.POST, "https://www.test.com/test.php",     //...rest same
```

Don't forget to include the certificates in your project.
 @dkavraal sorry for a dumb question, but how do I include the certificate correctly so AlamoFire can find it? Is it enough to just drag into the Resources group in XCode?

And is there a way to debug the validation errors like the
`Error Domain=NSURLErrorDomain Code=-999 "cancelled" `? @mataspetrikas I just had to deal with the same question myself.

So the solution that I found by trial and error is that I needed to add DER encoded .cer file in my main bundle of the app. Just drag and drop to the project and copy files.

To get the DER encoded .cer file, I used Firefox and opened the url and by using the address bar You can go more details of the certificate then Security(Tab) -> View Certificate -> Details(Tab)->Export...
Then select X.509 Certificate (DER)

Hope it helps. @mataspetrikas on the contrary it's a good question. As @gunhansancar mentions, make sure you have der certificate. Then, apart from where you put the file, (move the file with your mouse into) copy the file into "**copy bundle resources**" inside Project settings -> Build phases. Same as in here: http://stackoverflow.com/questions/3095612/warning-the-copy-bundle-resources-build-phase-contains-this-targets-info-plist
 Certificate pinning stopped working with Swift 3.0
I am using the following code:

```
let myServer = "...". //string in format without https://

let pathToCert = Bundle.main.path(forResource: "certificate", ofType: "der")
let localCertificate = NSData(contentsOfFile: pathToCert!)!

 let serverTrustPolicy = ServerTrustPolicy.pinCertificates(
            certificates: [SecCertificateCreateWithData(nil, localCertificate)!],
            validateCertificateChain: true,
            validateHost: true
        )

let serverTrustPolicies = [
            myServer: serverTrustPolicy
        ]

afManager = SessionManager(
            serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies)
        )

afManager.request("... some other domain ...", method: .get).response { response in
            log.info(response)
        }
```
I still get response (status code 200) from the other domain
What could be wrong here? Could something be wrong with my certificate and/or the way I input my domain?
This is what my certificate looks like
![screen shot 2017-06-29 at 11 48 48](https://user-images.githubusercontent.com/11228615/27682035-6c1e40d8-5cc1-11e7-94dc-d1e069db6751.png)

```
let serverTrustPolicies = [
            "*.mydomain.com": serverTrustPolicy
        ]
```

also I feel like I should mention that all the calls towards my domain are succeeding nevertheless...
```
let request = afManager.request(request)
                .response { dataResponse in
```

However, as I mentioned before calls towards other domains are also returning 200, which should not be happening...  Hi,
Waiting for alternate to UIKit + AFNetworking in swift.
 Any update on this?
 I'm specifically asking about things like the network indicator support and things like that.

I'm happy to send a pull request if it would help things out. I saw the idea you guys seem to like is to use an NSURLProtocol subclass.

Sent from my iPhone

> On Jan 2, 2016, at 7:21 PM, Christian Noon notifications@github.com wrote:
> 
> The majority of the functionality is already built into AlamofireImage. Other non-image related features are currently in our Trello backlog.
> 
> ‚Äï
> Reply to this email directly or view it on GitHub.
  I've added a request sample on `download()` in the sample project.
  I would like to see response methods `throws` instead of passing an error parameter. That would remove the need to return a `Result` type from an API method, but could return a non-optional model object and mark it `throws` or `rethrows`.
  I was randomly testing the framework, it consistently failed this testcase (PFA)
![screen shot 2015-07-11 at 10 52 13 pm](https://cloud.githubusercontent.com/assets/5190296/8634670/b4702974-281f-11e5-9cf0-56bfd78564dc.png) 

I am not personally affected by this failure, neither do I understand the implications of the failure. Just thought you guys should know.

XCode Version - 6.3
Timezone - GMT + 5:30
Location - Bangalore, India
 Oh, I am not able to reproduce this now either. Yes, I was running on an iOS 8.3 simulator. Weird.
  The type of `configuration` object is automatically inferred.
 No problem. Awesome library, by the way. :) 
  If Alamofire support Soap web service natively? Of if there are any extension of Alamofire support it? Thanks
  This is for CocoaPods 0.38, I'd suggest we hold of merging until the stable version has been released.
  I have installed Xcode 7 beta 3, and I am able to run my code on a simulator, but not on my device. I was no able to build and also received the warning:

```
ld: warning: directory not found for option '-F/Applications/Xcode-beta.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS9.0.sdk/Developer/Library/Frameworks'
ld: -bundle and -bitcode_bundle (Xcode setting ENABLE_BITCODE=YES) cannot be used together
```

So I set ENABLE_BITCODE=NO and now the device builds, but it crashes with the errors:

```
dyld: Symbol not found: __TMdVSS5Index
Referenced from: /private/var/mobile/Containers/Bundle/Application/75C6AF90-20D1-4CC7-B206-94C8FAD41DEF/BiggerCity.app/Frameworks/Alamofire.framework/Alamofire
Expected in: /private/var/mobile/Containers/Bundle/Application/75C6AF90-20D1-4CC7-B206-94C8FAD41DEF/BiggerCity.app/Frameworks/libswiftCore.dylib
in /private/var/mobile/Containers/Bundle/Application/75C6AF90-20D1-4CC7-B206-94C8FAD41DEF/BiggerCity.app/Frameworks/Alamofire.framework/Alamofire
```

My Podfile is:

```
source 'https://github.com/CocoaPods/Specs.git'
platform :ios, '8.0'
use_frameworks!

pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'swift-2.0'
pod 'PubNub', '3.7.10.8‚Äô
```

What could be causing this error? It has only occurred since I installed Xcode 7. Xcode 6 runs just fine.
 Bitcode isn't supported in any released version of CocoaPods, but there is a work in progress pull request at https://github.com/CocoaPods/CocoaPods/pull/3744.

Once changing `ENABLE_BITCODE` to `NO`, you will probably need to clean and delete derived data, and then I would expect this to build and run again.
 Thank you @kylef that solved the problem.
  Since multipart is not supported by Alamofire yet, I'm trying to create a `NSURLRequest` using `AFHTTPRequestSerializer`. But it's not working as expected.

Here's my code:

```
let pictureData: NSData = ...
// ...
let requestSerializer = AFHTTPRequestSerializer()
// Multipart
let urlRequest = requestSerializer.multipartFormRequestWithMethod(Method.PUT.rawValue, URLString: "http://example.com/upload/100", parameters: nil, constructingBodyWithBlock: { (formData) in
        formData.appendPartWithFileData(pictureData, name: "picture", fileName: "avatar.jpeg", mimeType: "image/jpeg")
   }, error: nil)

manager.upload(.PUT, urlRequest, stream: request.HTTPBodyStream!)
```

I assumed I could be using the `HTTPBodyStream` constructed using the request serialiser. I don't know what's happening under the hood, but the created `Alamofire.Request` has no HTTP headers and I think no data is sent to the remote server.

I don't know if it's a bug in Alamofire or something that is not allowed to do (yet?). However, it would be great to be able to upload multipart data this way (until official multipart support in Alamofire).
(If this is an implementation issue on my side, I'll post it on Stack Overflow instead)
 Oh, my bad! Awesome! So glad to find the same kind of interface as with AFNetworking :) Thank you!
  I've been struggling with this for almost two straight days now, just can't get to fix this.
So far, requests to my API work for non - authenticated requests.
However, when I add additional headers, I get errors.

My API is currently running on a server without SSL, for testing, I disabled NSAppTransportSecurity for that

I first had trouble with my request being cancelled, which I solved by making the manager a global variable.

I'm not sure if this is a problem for Alamofire or my fault, so I figured I will drop it here.
stackoverflow page: http://stackoverflow.com/questions/31289074/authenticated-http-request-swift-alamofire

![image](https://cloud.githubusercontent.com/assets/10037514/8581600/22a0e24a-25c2-11e5-8b90-0e3df4191da2.png)
  Can you make 'query Components' method public?
If you send nested array sometimes is required to add indexes to arrays, so method has to be overridden..

eg: 
// HTTP body: foo=bar&baz[0]=a&baz[0]=1&qux[x]=1&qux[y]=2&qux[z]=3
...
for (index, value) in array.enumerate() {
     components += queryComponents("(key)[(index)]", value)
}
...
    See https://twitter.com/travisci/status/616154472897773568.
 My pleasure! :wink: Thank you for the review, too.
  I'm trying to add AlamoFire to a test watch project i'm building but it's not compiling when i try to test on the watch simulator.  Is there an easy way for me to add this to SUPPORTED_PLATFORMS?

Alamofire was rejected as an implicit dependency for 'Alamofire.framework' because it doesn't contain platform 'watchsimulator' in its SUPPORTED_PLATFORMS 'iphonesimulator, iphoneos'
 @jaybuangan Are you installing via CocoaPods for the watchOS platform?
  Hi

I have install the Alamofire as per the pod instruction given on git hub, installation done successfully.
but when try to compile i got the following error.

Libtool /Users/vinod/Library/Developer/Xcode/DerivedData/RDemo-cnhoznqdwlpkuvhctrlcwzhaacjf/Build/Products/Debug-iphonesimulator/libPods-RDemo-Alamofire.a normal x86_64
    cd /Users/vinod/VINOD/RAW/RND/iOS/RDemo/Pods
    export IPHONEOS_DEPLOYMENT_TARGET=8.0
    export PATH="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin"
    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/libtool -static -arch_only x86_64 -syslibroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator8.3.sdk -L/Users/vinod/Library/Developer/Xcode/DerivedData/RDemo-cnhoznqdwlpkuvhctrlcwzhaacjf/Build/Products/Debug-iphonesimulator -filelist /Users/vinod/Library/Developer/Xcode/DerivedData/RDemo-cnhoznqdwlpkuvhctrlcwzhaacjf/Build/Intermediates/Pods.build/Debug-iphonesimulator/Pods-RDemo-Alamofire.build/Objects-normal/x86_64/Pods-RDemo-Alamofire.LinkFileList -L/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift/iphonesimulator -Xlinker -add_ast_path -Xlinker /Users/vinod/Library/Developer/Xcode/DerivedData/RDemo-cnhoznqdwlpkuvhctrlcwzhaacjf/Build/Intermediates/Pods.build/Debug-iphonesimulator/Pods-RDemo-Alamofire.build/Objects-normal/x86_64/Pods_RDemo_Alamofire.swiftmodule -framework Foundation -o /Users/vinod/Library/Developer/Xcode/DerivedData/RDemo-cnhoznqdwlpkuvhctrlcwzhaacjf/Build/Products/Debug-iphonesimulator/libPods-RDemo-Alamofire.a

error: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/libtool: unknown option character `X' in: -Xlinker
Usage: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/libtool -static [-] file [...] [-filelist listfile[,dirname]] [-arch_only arch] [-sacLT] [-no_warning_for_no_symbols]
Usage: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/libtool -dynamic [-] file [...] [-filelist listfile[,dirname]] [-arch_only arch] [-o output] [-install_name name] [-compatibility_version #] [-current_version #] [-seg1addr 0x#] [-segs_read_only_addr 0x#] [-segs_read_write_addr 0x#] [-seg_addr_table <filename>] [-seg_addr_table_filename <file_system_path>] [-all_load] [-noall_load]
 ![screen shot 2015-07-07 at 6 54 48 pm](https://cloud.githubusercontent.com/assets/1991533/8547116/5fff6ed8-24da-11e5-8a5f-b0b1be321843.png)
 Thanks for replay..
  On a ViewController, we have in viewDidLoad an Alamofire request to a server with a callback that references self, and also a pushViewController meant to transition to another ViewController.

Unintuitively, the viewDidLoad function finishes and returns, but the pushViewController does not happen until after the Alamofire request finishes and calls the callback.

Is this expected behavior?  Why is this happening?
  I have added the Alamofire .swift classes under the Source folder to my project and it seems the language was updated. The old syntax is preventing me from compiling the classes. Would my best option be iOS 8.0 instead of 8.1? I've tried fixing the problem myself but being new to Swift I haven't accomplished much.
  I have a simple request like:

```
func newRequest() {
    println("CANCEL = \(self.getTime())")
    self.request.cancel()

    self.request_ = request(method, url)
    validate(statusCode: [200])
        .validate(contentType: ["application/json"])
        .responseJSON { [unowned self] (_, _, json, error) in

            if(error?.code == NSURLErrorCancelled ) {
                println("CANCELED!")
            }

            println("DONE LOADING = \(self.getTime())")
            // ...
    }
}
```

As shown above, when new request is invoked, I want previous to be canceled.
And it usually works, but sometimes when previous request is about to end (there is a very short amount of time between logs), it does not.

```
(newRequest) CANCEL = 1436103465.93128
// CANCELED! SHOULD BE HERE
(previousRequest) DONE LOADING = 1436103466.08223
```

To make it work I added a var isCanceled and check whether it is set to true.
I am not sure if it works as it should (it may be too late to cancel) or it is a small bug.
  I followed  the instruction:
1. Add **github "Alamofire/Alamofire" "swift-2.0"** in cartfile
2. Run **carthage update** to build the project. The Alamofire.framework is successfully built
3. Drag the Alamofire.framework into **Linked Frameworks And Libraries** in **General** tab
4. Add copy script in **Build Phrase** tab

> /usr/local/bin/carthage copy-frameworks
> Input file: $(SRCROOT)/Carthage/Build/iOS/Alamofire.framework
1. Build my project then I got the error message:

> ld: framework not found Alamofire

What could be the reason ? Thanks
 I've had better success with CocoaPods myself, although I've been trying to get Carthage to work as there's a library I want to use which only is available via that. 
 This helps fix mine:
Add `$(SRCROOT)/Carthage/build/iOS` to **Framework Search Paths** in **Build Settings**

I read someone said that an Apple engineer admitted at WWDC 2015 this's an Xcode bug.
 @sikhapol : thanks man ! Fixed my problem ! 
 Thank! @sikhapol 
  <img width="925" alt="screen shot 2558-07-03 at 11 56 51 pm" src="https://cloud.githubusercontent.com/assets/887851/8502768/392eb550-21df-11e5-933e-a6c882eeef46.png">

I can not set framework to `Target Dependencies`, no `Embedded framework` to add.

Enviroment Xcode7. swift 2.0
pod file

```
source 'https://github.com/CocoaPods/Specs.git'
platform :osx, '10.10'
use_frameworks!

pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'swift-2.0'
```

error

```
dyld: Library not loaded: @rpath/Alamofire.framework/Versions/A/Alamofire
  Referenced from: /....../
  Reason: image not found
```
   I was able to fix this in my own app by encoding the string provided to NSURL.

``` swift
NSURL(string: "http://example.com/–º–∞–º–∞".stringByAddingPercentEscapesUsingEncoding(NSUTF8StringEncoding)!)
```
    We ran into the problem that when the taskDidComplete closure was set the response handlers were never executed because the closure replaced the default implementation.

This change fixed the problem for us and we think it would be useful for everyone.
   @cnoon Thank you for the review! I've fixed the format what you pointed and rebased to master. Could you check it?
  In branch feature/multipart_form_data, try to upload some string and a file. it crashes on iPhone devices, both a iPhone 4s and a iPhone 6+. NOT repro in the simulator.
### iOS Version

8.3
### Call stack:

(lldb) bt
- thread #1: tid = 0xd358e, 0x00000001200e9088 dyld`dyld_fatal_error, queue = 'com.apple.main-thread', stop reason = EXC_BREAKPOINT (code=1, subcode=0x1200e9088)
  - frame #0: 0x00000001200e9088 dyld`dyld_fatal_error
    
    frame #1: 0x00000001200ebe48 dyld`dyld::halt(char const*) + 96
    
    frame #2: 0x00000001200ebf18 dyld`dyld::fastBindLazySymbol(ImageLoader**, unsigned long) + 208
    
    frame #3: 0x0000000197cd9198 libdyld.dylib`dyld_stub_binder + 60
    
    frame #4: 0x00000001000cf588 App01`static App01.DataAccess.addPost (post=0x00000001741ece00, fileUrls=Swift.Array<Foundation.NSURL> at 0x000000016fd4c8c0, callback=<unavailable>, self=<unavailable>)(App01.Post, fileUrls : Swift.Array<ObjectiveC.NSURL>, callback : (App01.Post) -> ()) -> () + 792 at DataAccess-Post.swift:61
    
    frame #5: 0x00000001000e5e24 App01`App01.AddPostVC.btnPublishClick (sender=AnyObject at 0x000000016fd4caa8, self=0x000000015d6348b0)(Swift.AnyObject) -> () + 1112 at AddPostVC.swift:30
    frame #6: 0x00000001000e5e88 App01`@objc App01.AddPostVC.btnPublishClick (App01.AddPostVC)(Swift.AnyObject) -> () + 60 at AddPostVC.swift:0
    frame #7: 0x000000018a8a5404 UIKit`-[UIApplication sendAction:to:from:forEvent:] + 96
    frame #8: 0x000000018a88e4e0 UIKit`-[UIControl _sendActionsForEvents:withEvent:] + 612
    frame #9: 0x000000018a8a4da0 UIKit`-[UIControl touchesEnded:withEvent:] + 592
    frame #10: 0x000000018a863fc0 UIKit`_UIGestureRecognizerUpdate + 8536
    frame #11: 0x000000018a89e898 UIKit`-[UIWindow _sendGesturesForEvent:] + 1044
    frame #12: 0x000000018a89df50 UIKit`-[UIWindow sendEvent:] + 660
    frame #13: 0x000000018a87118c UIKit`-[UIApplication sendEvent:] + 264
    frame #14: 0x000000018ab12324 UIKit`_UIApplicationHandleEventFromQueueEvent + 15424
    frame #15: 0x000000018a86f6a0 UIKit`_UIApplicationHandleEventQueue + 1716
    frame #16: 0x0000000185de8240 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 24
    frame #17: 0x0000000185de74e4 CoreFoundation`__CFRunLoopDoSources0 + 264
    frame #18: 0x0000000185de5594 CoreFoundation`__CFRunLoopRun + 712
    frame #19: 0x0000000185d112d4 CoreFoundation`CFRunLoopRunSpecific + 396
    frame #20: 0x000000018f5276fc GraphicsServices`GSEventRunModal + 168
    frame #21: 0x000000018a8d6fac UIKit`UIApplicationMain + 1488
    frame #22: 0x00000001000df5e8 App01`main + 164 at AppDelegate.swift:12
    frame #23: 0x0000000197cdaa08 libdyld.dylib`start + 4
### Code:

```
class func addPost(post:Post, fileUrls: [NSURL], callback:(Post) -> Void)
{
    let url = resRootUrl

    let jStr = Mapper().toJSONString(post, prettyPrint: false)
    let data = jStr?.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)

    println(fileUrls[0])

    sManager.upload(.POST, url,
        multipartFormData:
        {
            multipartFormData in
            multipartFormData.appendBodyPart(data:data!, name:"postdata")
            multipartFormData.appendBodyPart(fileURL: fileUrls[0], name: "unicorn")
        },
        encodingCompletion:
           {
              encodingResult in
                switch encodingResult {
                  case .Success(let upload, _, _):
                     upload.responseJSON
                    {
                       request, response, JSON, error in
                       println(JSON)
                    }
                  case .Failure(let encodingError):
                       println(encodingError)
            }
        }
    )

}
```
 @top2tech Do you have a sample project which reproduces the issue?
 it turns out to be my machine environment issue. I re-create the project, then it no longer repro.
 i am facing the same issue with iPhone 6 , 5s 
i tried to deintegrate the project and install the pods again 
it was working just fine before i update to the multipart_form_data version and i am sure that the url is correct , Any suggestions ?
  In branch feature/multipart_form_data, try to upload some string and a file. The string is in the payload, but the file is not. 
### File url:

assets-library://asset/asset.JPG?id=E2741A73-D185-44B6-A2E6-2D55F69CD088&ext=JPG
### Captured Traffic:

Accept-Encoding: gzip, deflate
Content-Type: application/x-www-form-urlencoded
Content-Length: 340
Accept-Language: en-us
Accept: /
Connection: keep-alive
Connection: keep-alive
User-Agent: app01/1 CFNetwork/711.3.18 Darwin/14.3.0

--alamofire.boundary.2373462a015381c7
Content-Disposition: form-data; name="postdata"

{"Content":"Lorem ipsum dolor sit er elit lamet, consectetaur cillium adipisicing pecu, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation"}
--alamofire.boundary.2373462a015381c7--
### Code:

class func addPost(post:Post, fileUrls: [NSURL], callback:(Post) -> Void)
{
    let url = resRootUrl

```
let jStr = Mapper().toJSONString(post, prettyPrint: false)
let data = jStr?.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)

println(fileUrls[0])

sManager.upload(.POST, url,
    multipartFormData:
    {
        multipartFormData in
        multipartFormData.appendBodyPart(data:data!, name:"postdata")
        multipartFormData.appendBodyPart(fileURL: fileUrls[0], name: "unicorn")

    },
    encodingCompletion:
       {
          encodingResult in
            switch encodingResult {
              case .Success(let upload, _, _):
                 upload.responseJSON
                {
                   request, response, JSON, error in
                   println(JSON)
                }
              case .Failure(let encodingError):
                   println(encodingError)
        }
    }
)
```

}
 thanks, I can see the error, it says it's not file url.  The url is returned from UIImagePicker from photos with the following path:
    assets-library://asset/asset.JPG?id=E2741A73-D185-44B6-A2E6-2D55F69CD088&ext=JPG

Looks like this kind of asset library Url is not supported in multipartFormData.appendBodyPart ?
I changed to use NSData for the image, then it works fine.
 what if i have path for video 
assets-library://asset/asset.mp4?id=1CEBF789-632D-4634-839E-5707D18CEBE9&ext=mp4 
how to upload it to server   https://github.com/Alamofire/Alamofire/blob/swift-2.0/Source/Request.swift

```
if #available(OSX 10.10, *) {
    operationQueue.qualityOfService = NSQualityOfService.Utility
}
```

"'qualityOfService' is only available on iOS 8.0 or newer"
  For branch feature/multipart_form_data, the Content-Type header should be: multipart/form-data, but in my testing, the actual header is incorrect. For NSData (UTF8 encoded from string), Content-Type header is set to: application/x-www-form-urlencoded
### Captured Traffic:

Accept-Encoding: gzip, deflate
Content-Type: application/x-www-form-urlencoded
Content-Length: 340
Accept-Language: en-us
Accept: _/_
Connection: keep-alive
Connection: keep-alive
User-Agent: app01/1 CFNetwork/711.3.18 Darwin/14.3.0

--alamofire.boundary.2373462a015381c7
Content-Disposition: form-data; name="postdata"

{"Content":"Lorem ipsum dolor sit er elit lamet, consectetaur cillium adipisicing pecu, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation"}
--alamofire.boundary.2373462a015381c7--
### Code:

```
class func addPost(post:Post, fileUrls: [NSURL], callback:(Post) -> Void)
{
    let url = resRootUrl

    let jStr = Mapper().toJSONString(post, prettyPrint: false)
    let data = jStr?.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)

    println(fileUrls[0])

    sManager.upload(.POST, url,
        multipartFormData:
        {
            multipartFormData in
            multipartFormData.appendBodyPart(data:data!, name:"postdata")
            multipartFormData.appendBodyPart(fileURL: fileUrls[0], name: "unicorn")

        },
        encodingCompletion:
           {
              encodingResult in
                switch encodingResult {
                  case .Success(let upload, _, _):
                     upload.responseJSON
                    {
                       request, response, JSON, error in
                       println(JSON)
                    }
                  case .Failure(let encodingError):
                       println(encodingError)
            }
        }
    )

}
```
  Trying to add addition header but without success: 
 Alamofire.Manager.sharedInstance.session.configuration.HTTPAdditionalHeaders = ["Authorization": "TOKEN"]
in Swift 1.2 it worked 
 See #545.
  Version 7.0 beta (7A121l)
Podfile 
source 'https://github.com/CocoaPods/Specs.git'
platform :ios, '8.0'
use_frameworks!

pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'swift-2.0'
 I double checked - yes - with a clean project and this podfile
    platform :ios, '8.0'
    use_frameworks!

```
pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'swift-2.0'
```

 ![screen shot 2015-07-07 at 3 06 30 pm](https://cloud.githubusercontent.com/assets/289994/8539066/d64dbfe8-24b9-11e5-934a-1ac80d32c59b.png)
  I am using Xcode 6.3.2, with the following dependencies in my Cartfile (utilizing carthage):
github "SwiftyJSON/SwiftyJSON" >= 2.2
github "kishikawakatsumi/KeychainAccess" >= 1.2.1
github "Alamofire/Alamofire" >= 1.2

When I run `carthage update`, I get the following error:

$ carthage update
**\* Fetching Alamofire
**\* Fetching KeychainAccess
**\* Fetching SwiftyJSON
**\* Downloading KeychainAccess at "v1.2.1"
**\* Checking out Alamofire at "1.2.3"
**\* Checking out SwiftyJSON at "2.2.0"
**\* xcodebuild output can be found in /var/folders/jd/gwqqglhn6lzdk0d7wz4yjg880000gp/T/carthage-xcodebuild.velBld.log
**\* Building scheme "Alamofire iOS" in Alamofire.xcworkspace
*\* BUILD FAILED **

The following build commands failed:
    Check dependencies
(1 failure)
Code Sign error: No code signing identities found: No valid signing identities (i.e. certificate and private key pair) matching the team ID ‚Äú(null)‚Äù were found.
CodeSign error: code signing is required for product type 'Framework' in SDK 'iOS 8.3'
A shell task failed with exit code 65:
*\* BUILD FAILED **

The following build commands failed:
    Check dependencies
(1 failure)

Any ideas? 
 I ran into this a couple of times. Usually re-runing the command solves the problem. Try re-run a couple times.
 Unfortunately, I keep getting the same error.
 I hit this issue as well, I fixed it by going to General ‚Üí Identity in your build target and make sure that the provisioning profile is correctly configured. For me this meant agreeing to a new legal agreement on the developer centre, waiting a couple of hours for it to get recognised, then clicking the ‚ÄúFix‚Äù button in the Identity panel.
  I read [this post](https://github.com/AFNetworking/AFNetworking/issues/2314) and it seems like the error is related...

```
NSErrorFailingURLKey=https://www.telize.com/geoip})getlocationOptional(Error Domain=NSURLErrorDomain Code=-1001 "The operation couldn‚Äôt be completed. (NSURLErrorDomain error -1001.)" UserInfo=0x600000271ac0 {NSErrorFailingURLStringKey=https://www.telize.com/geoip, NSUnderlyingError=0x600000045fd0 "The operation couldn‚Äôt be completed. (kCFErrorDomainCFNetwork error -1001.)", NSErrorFailingURLKey=https://www.telize.com/geoip})
```

If I do it manually from a browser it works... (No idea if related but it usually happens when I connect to a USA vpn - I'm based in europe.) Any ideas?

PS: I have it running on a background queue every x seconds and when I connect to the vpn it stops calling Alamofire from almost a minute ( internet works from the browser and any other apps). After around 5/10 minutes it works again...
 mmm if I use http instead of https it's a lot quicker. Still around 1 minute delay, but way less than the 10 mins I used to have o_o I'm honestly confused...
 Will do, I'm sorry.
  Greetings,

Thanks for making awesome library in Swift. Right now, I am moving code from Objective C to Swift. I am using Alamofire library for Web service calling. It is working fine but application crashes many time. I am not sure about it's library issues or something else. Please review below console Log with attached screen shot: 

Console Log:
 malloc: **\* error for object 0x1700075f0: Invalid pointer dequeued from free list
**\* set a breakpoint in malloc_error_break to debug
(lldb) 
![crash_file](https://cloud.githubusercontent.com/assets/4044146/8392031/ac4121a4-1cf8-11e5-8d85-b096f2337b12.png)

![thread](https://cloud.githubusercontent.com/assets/4044146/8392032/ac4549f0-1cf8-11e5-9901-97f0e37ed2af.png)

Please let us know your comments. 

Thank You,
Renish Dadhaniya
  unfortunately could not run this module on Xcode7b2 (Swift2)
on Swift 1.2 - It worked 
  I'm using the `swift-2.0` branch on iOS 9 with Xcode 7 beta 2. When trying to set the shared session's headers, it seems that all values gets dismissed:
### Code

```
var headers = ["User-Agent": "MyUserAgent"]
if let authToken = authToken {
    headers["Authorization"] = "Bearer \(authToken)"
}
Manager.sharedInstance.session.configuration.HTTPAdditionalHeaders = headers
// Breakpoint here
```
### lldb output

```
(lldb) po headers
‚ñø 2 elements
  ‚ñø [0] : 2 elements
    - .0 : "User-Agent"
    - .1 : "MyUserAgent"
  ‚ñø [1] : 2 elements
    - .0 : "Authorization"
    - .1 : "Bearer XcTp1mg1p8PwQe3KTejkHVGml2ujOsjrQneqkgDKm0iLqv6bGDAfWCJHqSb29D91"


(lldb) po Manager.sharedInstance.session.configuration.HTTPAdditionalHeaders
‚ñø Optional([Accept-Language: en;q=1.0, Accept-Encoding: gzip;q=1.0,compress;q=0.5, User-Agent: App/com.site.App (0.0.1.0; OS Version 9.0 (Build 13A4280e))])
  ‚ñø Some : 3 elements
    ‚ñø [0] : 2 elements
      - .0 : Accept-Language
      - .1 : "en;q=1.0"
    ‚ñø [1] : 2 elements
      - .0 : Accept-Encoding
      - .1 : "gzip;q=1.0,compress;q=0.5"
    ‚ñø [2] : 2 elements
      - .0 : User-Agent
      - .1 : "App/com.site.App (0.0.1.0; OS Version 9.0 (Build 13A4280e))"
```

I expected to see the `Authorization` token as well as `User-Agent=MyUserAgent` when inspecting the http headers. What's happening here?
 Looks like I didn't read the documentation enough:

> Modifying Session Configuration

```
var defaultHeaders = Alamofire.Manager.sharedInstance.session.configuration.HTTPAdditionalHeaders ?? [:]
defaultHeaders["DNT"] = "1 (Do Not Track Enabled)"

let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
configuration.HTTPAdditionalHeaders = defaultHeaders

let manager = Alamofire.Manager(configuration: configuration)
```

And from https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSURLSession_class/#//apple_ref/occ/instp/NSURLSession/configuration :

> Discussion
> Changing mutable values within the configuration object has no effect on the current session, but you can create a new session with the modified configuration object.

So I guess I have to create a new manager with a custom configuration. I'll try that and close the issue if it works as expected.
 And it works! Sorry for the noise.
 hi, I'm running into the same issue - trying to update the Manager.defaultHTTPHeaders so I don't have to set on every new request.  Can I just update the defaultHttpHeaders?
 @mypark You can't change the default http headers of the shared manager, you have to create a new manager with the code above and use it for all your requests. It has the same interface than `Manager`.
 @ldiqual  Thank you so much it resolved the issue
 @ldiqual I have the same problem but still doesn't work, this was working on previous version

```
private func setHeaderToken(token:String){
    var defaultHeaders =    Alamofire.Manager.sharedInstance.session.configuration.HTTPAdditionalHeaders ?? [:]
    defaultHeaders["Authorization"] = "Bearer " + token
    let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
    configuration.HTTPAdditionalHeaders = defaultHeaders
    let manager = Alamofire.Manager(configuration: configuration)
}
```
 @cesar-oyarzun-m I got the same problem... I try several way and sample, but the "Authorization" header are not added to the request. I "snif' the local request with Charles and I do not see it in the raw header. Do you find a solution? I am on the 3.1.2
thanks
 @cnoon what are your thoughts on updating the [README](https://github.com/Alamofire/Alamofire#modifying-session-configuration) to more accurately reflect this?

> This is **not** recommended for `Authorization` or `Content-Type` headers. Instead, use `URLRequestConvertible` and `ParameterEncoding`, respectively.

As @cesar-oyarzun-m said, this used to work despite the recommendation to do otherwise but now it seems as if it's more than that.
  In the future it will be updated to support swift2.0?
 There is already a branch for 2.0.
 thx 
 This issue can probably be closed.
   have a look at the `swift-2.0` branch
 @katunch Thanks
  We originally linted the as quick because Travis CI didn't have a version of Xcode / CocoaPods that was compatible with this before.

Changing to full will mean that CocoaPods will build the project on the lowest supported platforms and ensures all the sources work together.
  Added link to the documentation.

Given that complete documentation is one of the touted features, it seems to make sense to link to it.

It also makes it much easier to get to for the occasional swift dev (like myself :)).
  So i'm referring to [https://stackoverflow.com/questions/30163274/how-to-connect-localhost-with-invalid-certificate-using-alamofire](this code snippet on StackOverflow).  However, when my application makes a request to my API hosted locally, the delegate to handle unsigned certs is never called.  I'm using the Swift 2.0 branch, by the way.

Here's the error I'm seeing in the console.

```
trying to accept invalid certs
2015-06-21 20:11:35.754 App[18885:5060284] Unbalanced calls to begin/end appearance transitions for <UINavigationController: 0x7f8b8b003000>.
https://api.myapp.dev:3000/auth
https://api.myapp.dev:3000/auth
2015-06-21 20:11:38.621 App[18885:5060370] CFNetwork SSLHandshake failed (-9806)
2015-06-21 20:11:38.623 App[18885:5060370] NSURLSession/NSURLConnection HTTP load failed (kCFStreamErrorDomainSSL, -9806)
nil
Optional(Error Domain=NSURLErrorDomain Code=-1200 "An SSL error has occurred and a secure connection to the server cannot be made." UserInfo=0x7f8b8a64c9c0 {_kCFStreamErrorCodeKey=-9806, NSLocalizedRecoverySuggestion=Would you like to connect to the server anyway?, NSUnderlyingError=0x7f8b8a60dd00 "The operation couldn‚Äôt be completed. (kCFErrorDomainCFNetwork error -1200.)", NSLocalizedDescription=An SSL error has occurred and a secure connection to the server cannot be made., NSErrorFailingURLKey=https://api.myapp.dev:3000/api/v1/users.json, NSErrorFailingURLStringKey=https://api.myapp.dev:3000/api/v1/users.json, _kCFStreamErrorDomainKey=3})
```

Here's the function I'm calling to set up the delegate for Alamofire.  This is called in my AppDelegate class, in the application() callback.

```
    func acceptInvalidSSLCerts() {
        let manager = Alamofire.Manager.sharedInstance
        print("trying to accept invalid certs")

        manager.delegate.sessionDidReceiveChallenge = { session, challenge in
            var disposition: NSURLSessionAuthChallengeDisposition = .PerformDefaultHandling
            var credential: NSURLCredential?

            print("received challenge")

            if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
                disposition = NSURLSessionAuthChallengeDisposition.UseCredential
                credential = NSURLCredential(forTrust: challenge.protectionSpace.serverTrust!)
            } else {
                if challenge.previousFailureCount > 0 {
                    disposition = .CancelAuthenticationChallenge
                } else {
                    credential = manager.session.configuration.URLCredentialStorage?.defaultCredentialForProtectionSpace(challenge.protectionSpace)

                    if credential != nil {
                        disposition = .UseCredential
                    }
                }
            }

            return (disposition, credential)
        }
    }

```
 @dcunited001 I believe `-9806` is also an error you could receive if you were running into an issue with the new App Transport Security, which is understandable when using an unsigned certificate. Perhaps using one of the ATS configuration flags in your `Info.plist` would alleviate the issue? See Apple's WWDC sessions on NSURLSession or App Security for more info.
 So instead of following that StackOverflow, I figured out how to correctly configure `Info.plist` to specify exceptions.  I'll go ahead and document this a bit, in case other iOS noobs come across this issue.  

So it's easy to totally turn off `NSAppTransportSecurity`, but there was conflicting information on which keys to use to specify exceptions.  Under the `NSAppTransportSecurity` key, I have `NSAllowsArbitraryLoads` set to `NO`, specifying that I do not want to connect to all HTTP servers.  I also have a `NSExceptionDomains` key set to a Dictionary value, which is where I can specify HTTP domains my app is allowed to connect to.

I edited /etc/hosts to add a custom `api.myapp.dev` domain name.  Then i added a `myapp.dev` key to `Info.plist` under the `NSExceptionDomains` key.  Under the `api.myapp.dev` key, I have set both `NSIncludesSubdomains` and `NSTemporaryExceptionAllowsInsecureHTTPLoads` set to YES.  When I was googling around, I found that `NSTemporaryExceptionAllowsInsecureHTTPLoads` was referred to with two or more different key names, so that was quite confusing to me as an iOS beginner.
  Great job!
 Nice!
 :+1: Great!
 :+1: 
 :+1:  :100: 
 Thanks. It's possible to append regular POST vars?
 +1 
Can you merge it with `swift-2.0` branch?
 Hi @cnoon!
I am looking forward to seeing it soon.
Thank you!
 :+1: 
 awesome!
 Great ! ! ! 
 Just tried it out. Maybe I missed something but:
The "**Content-Type**" in my multipart POST header is **not** set to

"**multipart/form-data; boundary=alamofire.boundary...**"

which is what I need. Instead I see "**application/x-www-form-urlencoded**" in Charles Proxy.
Is there any elegant way to achieve that? The only workaround I found was:

``` swift
Alamofire.upload(
      request,
      multipartFormData: { multipartFormData in
        request.setValue("multipart/form-data; boundary=\(multipartFormData.boundary)", forHTTPHeaderField: "Content-Type")
        multipartFormData.appendBodyPart(fileData: fileData, name: "file", fileName: "asset.png", mimeType: "image/png")
      }, ...
```
 Have the same problem with orschaef, how to get "multipart/form-data; boundary=alamofire.boundary..." in post request? 
 +1
 @cnoon Seems to work now. Thank you! Glad we could help!
 Awesome!

I'm just a little bummed about the multipart `upload` functions that do not return an (optional) `Request` synchronously, instead of through the `encodingCompletion` block. (AFNetworking would return a `NSURLSession` synchronously when using `POST:parameters:constructingBodyWithBlock:success:failure`).
I guess this is due to internal implementation reasons and there's nothing you can do about it.
 how can i append other vars to the POST?
 Would be like this? 

```
let myInt = 3
let myString = "test"               
 multiPart.appendBodyPart(data: String(my_int).dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: true)!, name: "my_int")
 multiPart.appendBodyPart(data: myString.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: true)!, name: "my_string")
```
 and for an image:  
    data.appendBodyPart(fileData: UIImagePNGRepresentation(image), name: "image", fileName: "random_name.png", mimeType: "image/png") ?
 Hi @cnoon - just tried implementing your code snippet and am getting a .POST error, "Could not find member .POST", not having this issue with other Alamofire methods, including the single file upload function. Any thoughts? 
 @cnoon and why i've to specify in my Podifle the branch master since its the default branch?
        pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'master'

Otherwise, if i only write pod 'Alamofire' i dont get the methods with multipart.
 @cnoon, now working, many thanks @ivangodfather 
 @robindoble  yeah, happened to me,  forgot to mention you, sorry, btw, isnt supposed to be the default branch?
 @ivangodfather @cnoon - whats the best way to set custom headers on multipart requests, I saw this in a thread above, wondering if there is a best practice?

request.setValue("multipart/form-data; boundary=(multipartFormData.boundary)", forHTTPHeaderField: "Content-Type")

@ivangodfather - can you clarify your last post, are you suggesting podfile should be :branch => 'default' instead?
 @robindoble i'm asking why if the patch is in the "master" branch i have i
specify branch => 'master' since when i do pod 'Alamofire' my guess is that
the default branch is "master".

On 13 July 2015 at 19:48, robindoble notifications@github.com wrote:

> @ivangodfather https://github.com/ivangodfather @cnoon
> https://github.com/cnoon - whats the best way to set custom headers on
> multipart requests, I saw this in a thread above, wondering if there is a
> best practice?
> 
> request.setValue("multipart/form-data;
> boundary=(multipartFormData.boundary)", forHTTPHeaderField: "Content-Type")
> 
> @ivangodfather https://github.com/ivangodfather - can you clarify your
> last post, are you suggesting podfile should be :branch => 'default'
> instead?
> 
> ‚Äî
> Reply to this email directly or view it on GitHub
> https://github.com/Alamofire/Alamofire/pull/539#issuecomment-121003963.

## 

Este mensaje se dirige a su destinatario y puede contener informaci√≥n
confidencial sometida a secreto profesional o cuya divulgaci√≥n est√©
prohibida por la Legislaci√≥n Vigente. Cualquier persona distinta a su
destinataria tiene prohibida su reproducci√≥n, uso, divulgaci√≥n o impresi√≥n
total o parcial. Si ha recibido este mensaje por error, notif√≠quelo de
inmediato al remitente borrando el mensaje original juntamente con sus
ficheros anexos. Gracias.
 @ivangodfather - thats one for @cnoon, the author ;) @cnoon - would appreciate any advice on setting custom headers please.
 Now that this is in master, is there any chance you'd be willing to merge it into the swift-2.0 branch?
 Just want to add my voice that this is working well in our app and we could ditch the custom method we used :+1: 
 I'm migrating from AFNetworking and have been struggling to add a dictionary to a multipart request so that it ends up being encoded in the same way it would be with an AFNetworking request like this:

``` swift
     AF.POST(url, parameters: user, constructingBodyWithBlock: { (formData: AFMultipartFormData!) in
        if imageData != nil {
            formData.appendPartWithFileData(imageData!, name: "avatarImage", fileName: "blah", mimeType: "image/jpeg")
        }
    },
    ...
```

I've tried it like so, but the backend isn't happy with the encoding (i.e. something is different):

``` swift
    Alamofire.upload(Router.SignUp(user, imageData),
        multipartFormData : { multipartFormData in
            if imageData != nil {
                multipartFormData.appendBodyPart(data: imageData!, name: "avatarImage", fileName: "blah", mimeType: "image/jpeg")
            }

        var serializedUser = ""
        for (key, value) in user {
            serializedUser += "user[\(key)]=\(value)"
        }
        multipartFormData.appendBodyPart(data:    serializedUser.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: true)!, name: "user")
    }
```

Anything jump out as being wrong here?
 ```
                        data.appendBodyPart(data: dateString.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: true)!, name: "scheduled_closing_date")
                for image in images {
                    data.appendBodyPart(fileData: UIImageJPEGRepresentation(image, 0.6),name: randomStringWithLength(8), fileName: randomStringWithLength(8) + ".jpg", mimeType: "image/jpeg")
                }
```

where data is multipartFormData in your case
 But how do I deal with a dictionary? That's what I can't recreate in Alamofire upload

> On Sep 24, 2015, at 2:52 AM, ivangodfather notifications@github.com wrote:
> 
> ```
>                     data.appendBodyPart(data: dateString.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: true)!, name: "scheduled_closing_date")
>             for image in images {
>                 data.appendBodyPart(fileData: UIImageJPEGRepresentation(image, 0.6),name: randomStringWithLength(8), fileName: randomStringWithLength(8) + ".jpg", mimeType: "image/jpeg")
>             }
> ```
> 
> where data is multipartFormData in your case
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
 You need to transform it as a JSON ( https://github.com/Hearst-DD/ObjectMapper ) and send it with 
let params = ["user":YOUR_JSON_USER]
request(.POST, YOUR_URL, parameters: params, encoding: .JSON)
 Excellent- thank you Christian

On Thu, Sep 24, 2015 at 11:31 AM, Christian Noon notifications@github.com
wrote:

> @SteveNewhouse https://github.com/SteveNewhouse you want to use the
> ParameterEncoding.queryComponents API to help you out here. Here's some
> sample code to get you on track:
> 
> let imageData: NSData? = NSData()let URLRequest = NSURLRequest(URL: NSURL(string: "https://httpbin.org/post")!)
> 
> Alamofire.upload(URLRequest,
>     multipartFormData : { multipartFormData in
>         if imageData != nil {
>             multipartFormData.appendBodyPart(data: imageData!, name: "avatarImage", fileName: "blah", mimeType: "image/jpeg")
>         }
> 
> ```
>     let user: [String: String] = [:]
> 
>     for (key, value) in ParameterEncoding.URL.queryComponents("user", user) {
>         multipartFormData.appendBodyPart(data: value.dataUsingEncoding(NSUTF8StringEncoding)!, name: key)
>     }
> },
> encodingCompletion: { result in
>     // todo
> }
> ```
> 
> )
> 
> ‚Äî
> Reply to this email directly or view it on GitHub
> https://github.com/Alamofire/Alamofire/pull/539#issuecomment-142964094.
  I'm using Alamofire Swift-2.0 branch to perform an HTTP request which results in an SSL handshake error. (The framework is installed manually, BTW.)

The code (I omitted some parameters for simplicity sake):

``` swift
request(.POST, URLString: "http://localhost:3000/api/login.json").responseJSON { (_, response, data, error) in print(error) }
```

And the output:

```
2015-06-21 18:50:39.388 TestApp[87080:3418692] CFNetwork SSLHandshake failed (-9847)
2015-06-21 18:50:39.389 TestApp[87080:3418692] NSURLSession/NSURLConnection HTTP load failed (kCFStreamErrorDomainSSL, -9847)
Optional(Error Domain=NSURLErrorDomain Code=-1200 "An SSL error has occurred and a secure connection to the server cannot be made." UserInfo=0x7f8a5441f9e0 {_kCFStreamErrorCodeKey=-9847, NSLocalizedRecoverySuggestion=Would you like to connect to the server anyway?, NSUnderlyingError=0x7f8a54306030 "The operation couldn‚Äôt be completed. (kCFErrorDomainCFNetwork error -1200.)", NSLocalizedDescription=An SSL error has occurred and a secure connection to the server cannot be made., NSErrorFailingURLKey=https://localhost:3000/api/login.json, NSErrorFailingURLStringKey=https://localhost:3000/api/login.json, _kCFStreamErrorDomainKey=3})
```

Why is it using HTTPS in the first place? Am I doing something wrong?

Thanks in advance!
 I think that is because of "App Transport Security" feature which is introduced in iOS 9: http://ste.vn/2015/06/10/configuring-app-transport-security-ios-9-osx-10-11/
  There's currently no clear way to reset the current session preventing logout for web services that use basic auth and session storage.

```
    public func authenticate(#user: String, password: String) -> Self {
        let credential = NSURLCredential(user: user, password: password, persistence: .ForSession)

        return authenticate(usingCredential: credential)
    }
```

I'd propose adding a `persistence` parameter to the `authenticate` method or adding a method to the `Manager` to clear the current session.
 Thanks!

And thanks for the info. 
 I think this should be considered for re-opening - I'm using None as the persistence, however the credential still persists. Is this actual Alamofire or NSURLCredential's fault?

``` Swift
let credential = NSURLCredential(user: studentUsername, password: studentPassword, persistence: .None)
Alamofire.request(.GET, "https://api.co.uk/Default.aspx").authenticate(usingCredential: credential)
```
  I'm using Alamofire to get data from my server. However, it doesn't catch the error, as the error returned is `nil`. I've tested with AFNetworking, and it works fine. For both operation, the status code returned is `401 Unauthorized` .

I'm using [GrapeAPI](https://github.com/intridea/grape) for my backend. All it does is just to return the error on fail request

**GrapeAPI**

```
error!('Unauthorized', 401)
```

**AFNetworking**

```
manager.GET("someUrl", parameters: nil, success: { (_, object) in

        }, failure: { (operation, error) in
            // These are the outputs. I'm not assigning any values
            // error.localizedDescription = "Request failed: unauthorized (401)"
            // statusCode = 401
        })
```

**Alamofire**

```
Alamofire.request(.GET, "url", parameters: nil)
        .response { (a,b,data,error) in
        // These are the outputs. I'm not assigning any values
        // error = nil
        // data = {"error":"Unauthorized"}
        // statusCode = 401
        }
```

I can check the failure using the statusCode. But I prefer to check the error object instead. However, since the error is `nil` in Alamofire, it's quite confusing to check whether the request has failed or not. Posted in Stackoverflow since it might be my code. But I wonder if this a bug?
 @cnoon can correct me if I'm wrong, but I believe this is due to the fact that Alamofire doesn't do any validation of response codes by default. To enable it, call `.validate()` as part of your request call chain. See the Alamofire docs to know more. However, the error returned by `.validate()` isn't nearly as nice as the one from AFNetworking, but that may change in 1.3. See #447.
 Thanks @jshier. Mattt said the same thing, which is to call `.validate()` before my `response()`. However, I wonder why this behaviour is not by default in Alamofire since it works fine with AFNetworking. And yes, the error returned by `.validate()` isn't really helpful too. 

Anyway, thanks for clarifying the issue. Would be great if someone could explain or point me to the documentation explaining the reasoning behind the current design. Otherwise, feel free to close this issue :)
 Thanks for the explanation @cnoon. That helps a lot :)
 Issue #447 is a feature request for improving the Validator to support better and customizable errors. 
 @cnoon I don't think that 401 should be treated by error, because it prevents the app to detect Basic Auth failed login attempt.

But why currently in Alamofire it IS treated as an error? ‚Äî Status code 401 treated as NSError by default #1031
  hello.
## I use this code.

```
    var apiPath : String = "/api/list/"
    let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
    configuration.timeoutIntervalForRequest = 60
    let manager = Alamofire.Manager(configuration: configuration)
    manager.session.configuration.HTTPAdditionalHeaders = ["_U" : self._token]
    manager.request(.GET, self._host + self._url + apiPath, parameters: nil)
        .responseSwiftyJSON ({ (request, response, resultJson, error) in
            if (resultJson["Success"]) {
                 //get list success
            } else {
                println("request : \(request)")
                println("response : \(response)")
                println("resultJson : \(resultJson)")
                println("error : \(error)")
            }

    })
```

---
## And i got some problem 

Alamofire version 1.2.1 : No Problem
Alamofire version 1.2.2 & 1.2.3 : 
request : <NSMutableURLRequest: 0x7feb9287fda0> { URL: https://test.com/api/list/ }
response : nil
resultJson : null
## error : Optional(Error Domain=NSURLErrorDomain Code=-999 "cancelled" UserInfo=0x7feb92c434f0 {NSErrorFailingURLKey=https://test.com/api/list/, NSLocalizedDescription=cancelled, NSErrorFailingURLStringKey=https://test.com/api/list/})

response was nil
resultJson was null
Please help me what problem in this code..
 oh, sorry,, i see.

please check this question ..

http://stackoverflow.com/questions/30906607/about-alamofire-version-for-use-manager?noredirect=1#comment49855938_30906607

2015-06-18 13:08 GMT+09:00 Christian Noon notifications@github.com:

> Closed #535 https://github.com/Alamofire/Alamofire/issues/535.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub
> https://github.com/Alamofire/Alamofire/issues/535#event-333845723.
  While #447 involves a bigger change (even supporting Swift 2.0), this just change `Validation` to return a tuple `(Bool, NSError?)`, so validators can also inform an error. 
  I can connect the web service with the code which is below:

```
Alamofire.request(.GET, "http://httpbin.org/get", parameters: ["foo": "bar"])
         .response { (request, response, data, error) in
                     println(request)
                     println(response)
                     println(error)
                   }
```

The service return to me XML. How can I get the result to an array from this XML output?
  Per discussion in #514.
  I wanna call a "get" api and then call a "post" api one by one. I want that "post" dose not start until "get" finish. Right now, it starts "post" api when "get" does not finish. How to solve that?
  Just stumbled upon this when I was using Alamofire with one of my Swift 2.0 projects, and thought I'd do a quick fork.
    For any validation, the error reported to the handler is:

```
NSError(domain: AlamofireErrorDomain, code: -1, userInfo: nil)
```

When using validation together with responseJSON (for example) the failure reason is unknown to the response handling block. This causes the validation to be duplicated when handling the error:

```
let request = Alamofire.request(method, url, parameters: parameters, encoding: encoding)
    .validate(statusCode: 200..<300)
    .responseJSON { request, response, json, error in
        if contains(200..<300, response.statusCode) { ... }
```

Also, the response data is not available to the handler block in case of a validation error.
  The Alamofire framework does not work with Swift 2.0 and is not fixable with the code converter in Xcode 7. Some minor changes need to be made after code conversion so that the framework builds in Xcode 7.
 You should pull the appropriate branch in which fixes were made and it does work in iOS9 and XCode 7...
 Current using the pods 1.2.2 version but still getting conversion issues.
 You have to define it like this in your podfile

```
pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'swift-2.0'
```
 Ok did that and has fixed the Errors, Thanks
 I do
pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'swift-2.0'
that and I get 
[!] Unable to find a specification for 'Alamofire'.

It used to work before. any light
 @raulastu You need CocoaPods 0.38.2 to make it work. It won't work on lower version of Cocoapods. Hope it helps.
 It works now.
 I have the following: 
[!] Error installing Alamofire
[!] /usr/bin/git clone https://github.com/Alamofire/Alamofire.git /var/folders/sx/qkmsxzt54_9fg2r6r1rbz3000000gn/T/d20150922-4531-1upq9bj --single-branch --depth 1 --branch swift-2.0
I am using cocoapods 0.38.2. Any ideas?
 @cduguet I am using below code in podfile and it works for me without any issues.

pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'swift-2.0'
 I got it working by deleting the branch name. The problem was that it did not find the swift branch, so I used master.¬†
 Since the swift 2 implementation was merged into master branch, you do not need the specific properties in your podfile. Just use `pod 'Alamofire'`
 Since GM seed of iOS9, use master. Other branches were munged and/or deleted.
 im using pod 'Alamofire' xcode 7 beta but not still syntax errors...
 Xcode 7 is now on 7.0.1, so you probably need to update.
 Thanks yea ive done that :)
 The solution is this:

pod 'Alamofire', '~> 2.0'
  I was hosting some JSON files in a simple python httpserver. I doesnt set any caching headers.

I didnt make changes to caching policy.If i made a simple GET request , the request reaches the server first time, from next time the cache is used. Now even if the server is stopped ie unreachable,request succeds without any connection error because the cache is used , Is this intended?

The next problem is that when successful response gets returned from cache, if I call NSURLCache.sharedURLCache().cachedResponseForRequest(request), it returns NIL.

I can load from cache only if I manually store response and data returned by alamofire callback into cache again, eventhough these data were already present.

Is this problem anyway related to how NSURLSession caches data or is this some bug in way alamofire treats cache policies?
  Your iOS target level is set to iOS 8 in the project, so it doesn't see this compiler error.  (Since it makes a dynamic framework).

For those of us still "dropping" the swift into the project without pods or carthage (I REALLY want to drop iOS 7.0 support asap) than you won't see this.

You may want to think about adjusting the IOS target level in the project also, so you can spot any more of these in future.  I THINK it's ok, even though the dynamic framework can't run on iOS 7.
  I've just tried to compile my swift project with alamofire 1.2.2 in Xcode 7 beta, and due to syntax changes in Swift 2.0 it won't compile. I tried fitting the syntax for Swift 2.0 but then it won't compile in Swift 1.2.
I will appreciate it if you could tell me your current plans for Swift 2.0 support. Thank you :)
 @cezheng there is another branch which support swift 2.0, you can use it for now.
  Without this fix, Alamofire doesn't compile for iOS 7 targets with Xcode 7.

Test project doesn't reveal this because it's iOS 8 and up, but the same guard as for 10.10 is needed for iOS as well. 
  When trying to add custom headers from a singleton, the app don't crash but also it's not continuing it's execution. I'ts very strange beaviour that happens only when accessing the singleton from the URLRequestConvertible of Alamofire.

Here the code:

 var URLRequest: NSURLRequest {
        let URL = NSURL(string: Router.baseURLString.stringByAppendingString(Router.apiPath))!
        let mutableURLRequest = NSMutableURLRequest(URL: URL.URLByAppendingPathComponent(path))
        mutableURLRequest.HTTPMethod = method.rawValue

```
    let sessionCode = Configuration.sharedInstance.session.code
```

// If debugging, after this line, it does nothing.

```
    mutableURLRequest.addValue(sessionCode, forHTTPHeaderField: "SessionCode")
    mutableURLRequest.addValue("LogitravelSpain", forHTTPHeaderField: "Application")
    mutableURLRequest.addValue("ES", forHTTPHeaderField: "Language")

    if let token = Router.OAuthToken {
        mutableURLRequest.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
    }

    switch self {
    case .PostSession(let parameters):
        return Alamofire.ParameterEncoding.JSON.encode(mutableURLRequest, parameters: parameters).0
    case .GetCatalog(_, let productsPerLOB, let page, let pageSize):
        return Alamofire.ParameterEncoding.URL.encode(mutableURLRequest, parameters: ["productsPerLOB":productsPerLOB,"page":page,"pageSize":pageSize]).0
    default:
        return mutableURLRequest
    }
}
```

And here how I have declared the Configuration singleton:
import Foundation

class Configuration {

```
static let sharedInstance = Configuration()

var apiEndPoint: String = "http://apiq.logitravel.com/mobile"


var session: Session = Session()

init() {
    session.obtainSession()
    // TODO: Get Configuration Manager
}
```

}

Anyone has the same problem?

Thanks in advance
 Just did what you suggested. Hete it is the link, if anyone want's to help.

http://stackoverflow.com/questions/30797242/unable-to-access-singletons-in-urlrequest-with-alamofire

Thanks.
  support swift 2.0?
 There is a branch `swift-2.0`that has been updated to support swift 2.0.
 great!
    If I create a NSMutableURLRequest and set cache policy and then call request(.GET, mutableRequest, parameters:someParams) the cache policy in callback request param is different from what is being set.I think there is some bug in request building process..
 Thanks, I saw that the URLString was used to create new NSMutableURLRequest, didn't know whether  it was intended behavior 
  Search TODO in the project you will see those two places. Help wanted. :)

I think it's better to create a separate `swift-2` branch in `Alamofire/Alamofire` repo. This way it wouldn't mess up for people who is still using Swift 1.2 and `Carthage` when they do a `carthage update`. If they really want to use Swift 2 they can let Carthage follow `swift-2` branch in the config file `Cartfile`.
 This is my first time contribute to Alamofire. If there's anything not right, please let me know, happy to change. :)
 I'll take a look. It seems to be a combination of not handling potential errors thrown by `NSPropertyListSerialization.propertyListWithData(options:format:)` and some type inference issues.
 So this fixes the first example, but it's _far_ from ideal:

``` swift
do {
    if let
        HTTPBody = URLRequest.HTTPBody,
        _plist: AnyObject = try NSPropertyListSerialization.propertyListWithData(HTTPBody, options: .Immutable, format: nil),
        plist = _plist as? NSObject
    {
        XCTAssertEqual(plist, parameters as NSObject, "HTTPBody plist does not equal parameters")
    } else {
        XCTFail("plist should not be nil")
    }
} catch {
    XCTFail("Unable to load plist")
}
```

I'll look in to finding a way to express this code better.
 @rpowelll Thank you!

Oh, by the way, I don't think Travis CI support Swift 2 yet. That's why it's failing. I have run all the tests and they pass, well, except those two todos which are commented out.
 Yep, I'm not sure what Travis's stance on testing prerelease iOS SDKs is. Does anyone have experience with that?
 I do. Travis will allow user individually to test beta SDKs but generally they are out of prerelease before even a test environment is available. support@travis-ci.com the team there is super responsive and helpful.
 @cnoon My pleasure.

However I have to mention that because I wanted to get it to compile as fast as possible last night, some changes I made are a bit dodgy. But I think my pr would be a good starting point to get Alamofire to Swift 2.  So you don't need to fix all those tedious minor changes again. :)
 I'm working on a bunch of little projects to learn the new APIs in iOS 9, so I'll be sure to use Alamofire quite a bit in the coming months. Hopefully that'll help sort out any bugs before the Xcode 7 GM gets released.
 anyone know how to properly update this Alamofire snippet using Swift 2.0 branch:

let JSONSerializer = Request.JSONResponseSerializer(options: .AllowFragments)
let (JSON: AnyObject?, serializationError) = JSONSerializer(request, response, data)

The second line is throwing two errors in Xcode 7.0,

so in Xcode 7 it wants to change this

the error it shows is twofold,
1) expected a ‚Äò,‚Äô separator,

it wants to put a comma between AnyObject and ?

2) expected a pattern

Fuad Kamal
Anaara LLC
www.anaara.com
240.515.7578 (m)
214.279.1890 (f)
twitter: @flexRonin
behance: https://www.behance.net/fuadkamal
linkedIn: linkedin.com/in/anaara
photography: http://500px.com/fuad2

> On Jun 10, 2015, at 7:02 PM, Rhys Powell notifications@github.com wrote:
> 
> I'm working on a bunch of little projects to learn the new APIs in iOS 9, so I'll be sure to use Alamofire quite a bit in the coming months. Hopefully that'll help sort out any bugs before the Xcode 7 GM gets released.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub https://github.com/Alamofire/Alamofire/pull/518#issuecomment-110941613.
 Hi @cnoon, is there any way to specify in podfile that I want to use the Swift2.0 branch instead of master? Or whatelse way would you recommend to use Aamofire managed by CocoaPads in the Swift 2.0 project?
 yes, it‚Äôs documented on the CocoaPods site:

https://guides.cocoapods.org/using/the-podfile.html https://guides.cocoapods.org/using/the-podfile.html

so in your podfile, use:

pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire.git', :branch => 'swift-2.0'

Fuad Kamal
Anaara LLC
www.anaara.com
240.515.7578 (m)
214.279.1890 (f)
twitter: @flexRonin
behance: https://www.behance.net/fuadkamal
linkedIn: linkedin.com/in/anaara
photography: http://500px.com/fuad2

> On Jun 10, 2015, at 10:33 PM, kun notifications@github.com wrote:
> 
> Hi @cnoon https://github.com/cnoon, is there any way to specify in podfile that I want to use the Swift2.0 branch instead of master? Or whatelse way would you recommend to use Aamofire managed by CocoaPads in the Swift 2.0 project?
> 
> ‚Äî
> Reply to this email directly or view it on GitHub https://github.com/Alamofire/Alamofire/pull/518#issuecomment-110975435.
 never mind, figured this one out.

AnyObject? is not required explicitly

so changing to this, compiles:

```
        let JSONSerializer = Request.JSONResponseSerializer(options: [.AllowFragments])
        let (JSON, serializationError) = JSONSerializer(request, response, data)
```

Fuad Kamal
Anaara LLC
www.anaara.com
240.515.7578 (m)
214.279.1890 (f)
twitter: @flexRonin
behance: https://www.behance.net/fuadkamal
linkedIn: linkedin.com/in/anaara
photography: http://500px.com/fuad2

> On Jun 10, 2015, at 8:43 PM, Fuad Kamal fuad@anaara.com wrote:
> 
> anyone know how to properly update this Alamofire snippet using Swift 2.0 branch:
> 
> let JSONSerializer = Request.JSONResponseSerializer(options: .AllowFragments)
> let (JSON: AnyObject?, serializationError) = JSONSerializer(request, response, data)
> 
> The second line is throwing two errors in Xcode 7.0,
> 
> so in Xcode 7 it wants to change this
> 
> the error it shows is twofold,
> 1) expected a ‚Äò,‚Äô separator,
> 
> it wants to put a comma between AnyObject and ?
> 
> 2) expected a pattern
> 
> Fuad Kamal
> Anaara LLC
> www.anaara.com http://www.anaara.com/
> 240.515.7578 (m)
> 214.279.1890 (f)
> twitter: @flexRonin
> behance: https://www.behance.net/fuadkamal https://www.behance.net/fuadkamal
> linkedIn: linkedin.com/in/anaara http://linkedin.com/in/anaara
> photography: http://500px.com/fuad2 http://500px.com/fuad2
> 
> > On Jun 10, 2015, at 7:02 PM, Rhys Powell <notifications@github.com <mailto:notifications@github.com>> wrote:
> > 
> > I'm working on a bunch of little projects to learn the new APIs in iOS 9, so I'll be sure to use Alamofire quite a bit in the coming months. Hopefully that'll help sort out any bugs before the Xcode 7 GM gets released.
> > 
> > ‚Äî
> > Reply to this email directly or view it on GitHub https://github.com/Alamofire/Alamofire/pull/518#issuecomment-110941613.
 I am using Carthage made by github team to manage my dependencies including Swift 2 ones.¬†https://github.com/Carthage/Carthage

‚Äî
Sent from Mailbox

On Thu, Jun 11, 2015 at 12:33 PM, kun notifications@github.com wrote:

> ## Hi @cnoon, is there any way to specify in podfile that I want to use the Swift2.0 branch instead of master? Or whatelse way would you recommend to use Aamofire managed by CocoaPads in the Swift 2.0 project?
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/Alamofire/Alamofire/pull/518#issuecomment-110975435
 Thanks abunur
  I have opened the current project using Xcode 7 beta,

when I am trying to compile, getting error : Module Alamofire converted using older compiler

I have tried to convert the code using converter provide with xcode 7 beta
it is showing error : 
1 ) import Alamofire :=> Error :  could not build objective-c modul Alamofire

2) module Alamofire.Swift {
    header "Alamofire-Swift.h" :=> Error : Header Alamofire-swift.h not found
}
 I think we need a swift-2 branch like some other Swift frameworks, e.g. Quick/Quick, Quick/Nimble, thoughtbot/Argo. What do you guys think? @cnoon @mattt 

I also tried to convert it to Swift 2. But for some reason, Xcode 7 would only convert code in Alamofire itself but not the ones in test. Not sure why.

Did it convert all the code for you, including code in Alamofire, test, and examlp app? @hitendradeveloper 
 @NicholasTD07
I am compiling my own project, but yes converter also converted my own code.
I have just remove test module, so don't have idea about test module conversion.
 From what I can tell, it doesn't convert testing targets. That said, the surface level syntax changes are pretty easy to implement.
 @hitendradeveloper Yeah, I was compiling my own project too, but Alamofire is the one dependency that dont yet have a Swift 2 branch.

@rpowelll I am working on a Swift 2 version of Alamofire.

It is easy, it's just so many little changes and Xcode couldn't do all of it for you. Plus, it sometimes gets some text inserted in the wrong place...
 @hitendradeveloper Could you change the title of this Issue to something like "Support for Swift 2"? I think this is more related to Swift 2. Also see below. :)

@rpowelll 

I've created a pull request for support for Swift 2. See the pull request here #518 
I fixed most of the things, however, there are two places I didn't know how to get it right. If you guys can help me on those two todo/fixme, it would be great. Thanks!
 Shouldn't this still work with xcode7 as is though? Users still have the choice of not upgrading to swift2 while using xcode7, aren't we just missing a compiler flag here?  I mean, we will need a Swift 2 branch regardless, but I would assume this would work out of the box. 
 It does not work out of the box.  In fact, after installing Xcode 7 beta, even running the release version of Xcode I am now getting the compiler errors related to Swift 2 regardless of whether I choose to convert the project to Swift 2 or not.  The option to convert to Swift 2 is just a way to resolve the errors.  As I recall they made it so that you no longer need to update your Xcode to update your Swift version, although I‚Äôm not exactly sure how this works.  On another machine as long as I don‚Äôt install the Xcode 7 beta I don‚Äôt see the Swift 2 errors.

> On Jun 9, 2015, at 2:23 PM, Ryan Romanchuk notifications@github.com wrote:
> 
> Shouldn't this still work with xcode7 as is though? Users still have the choice of not upgrading to swift2 while using xcode7, aren't we just missing a compiler flag here? I mean, we will need a Swift 2 branch regardless, but I would assume this would work out of the box.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub https://github.com/Alamofire/Alamofire/issues/517#issuecomment-110454801.
 Yep, Swift 2 is non-optional for Xcode 7.
 @cnoon, the swift-2.0 branch is 82 commits behind master. What is the status of swift 2.0 support, out of curiosity?
  If `HTTPShouldSetCookies` is set to `false` in the session's config then any cookies set will not be sent as part of the request.

Previously the cURL command output provided by `debugPrintln()` would include cookies whether or not `HTTPShouldSetCookies` was true or false. This commit will make it so `debugPrintln()` only prints cookies in the cURL output if they'll actually be sent.
 Great! Thanks @cnoon 
  When doing a request like: `Alamofire.request(.GET, url, encoding: .JSON)` I would expect the `Content-Type` header to be set to `application/json`

This appears to not be the case because `ParameterEncoding#encode` will return before getting to the code that sets the `Content-Type` because of the check for parameters at the top of the method:

``` swift
if parameters == nil {
    return (URLRequest.URLRequest, nil)
}
```
 I was going to raise this issue as well since I just ran into it with a backend that required the Content-Type header to be set despite not having any body data. Technically I think Alamofire is correct, this header is unnecessary when there is no body data. However, I think poorly engineered back end services are prevalent enough that setting Content-Type all the time as a compatibility measure should be considered. Obviously it's a rather small fix, but I know there's going to be some header changes for 1.3, so I wasn't sure how to proceed.
  I read through the README section entitled [**Generic Response Object Serialization**](https://github.com/Alamofire/Alamofire#generic-response-object-serialization) and wasn't sure how to use the sample `responseCollection` method. I'd love to see an example in the README for how to use it. I'm assuming it should be something like this, but I don't want to submit a PR without testing it first.

```
Alamofire.request(.GET, "http://example.com/users/mattt")
         .responseCollection { (_, _, users: [User]?, _) in
             println(user)
         }
```

Specifically, I don't know what the type should be for `users` - is it an optional array?
  I see random crash happening in method `Request.cURLRepresentation()` relatively often (not every day, but few times in a week I catch this crash in Xcode during development).

The crash happens on line with command
`if request.allHTTPHeaderFields != nil {`

Weird thing is that if I try to print contents of `request.allHTTPHeaderFields` in debugger console it prints correctly but accessing it for some reason causes crash in some random cases.

![screen shot 2015-06-05 at 12 47 54](https://cloud.githubusercontent.com/assets/244850/8004794/f73789be-0b82-11e5-9c47-bd775f0ed346.png)

I first thought it happens only during debugging in Simulator but I now see exact same crash in Crashlytics from some tester device.

Part of stack trace from crash up:

```
Thread : Crashed: com.apple.main-thread
0  CoreFoundation                 0x0000000181bf44e0 CFAllocatorDeallocate + 48
1  CFNetwork                      0x000000018164d01c HTTPMessage::ensureParserFinished() + 108
2  CFNetwork                      0x000000018164cf74 HTTPMessage::copyAllHeaderFields(__CFArray const**) + 28
3  CFNetwork                      0x000000018175f6e0 -[NSURLRequest(NSHTTPURLRequest) allHTTPHeaderFields] + 36
4  Alamofire                      0x0000000100834540 Alamofire.Request.cURLRepresentation (Alamofire.Request)() -> Swift.String (Alamofire.swift:1357)
5  Alamofire                      0x0000000100835a3c Alamofire.Request.debugDescription.getter : Swift.String (Alamofire.swift:1392)
```

Code which leads to crash - debug print request after it was sent:

```
let request: Alamofire.Request = ...
request.response() { (request, response, JSONObj, responseError) in
    // ...
}

#if DEBUG
debugPrintln(request) // <-- crash happens on this line
#endif
```

Xcode 6.3.2, deployment target iOS 8.0, Alamofire version 1.2.0, commit 6d1238d
  One feature that Alamofire currently lacks is the ability to receive data responses from servers incrementally. This can be useful in a number of cases, such as when displaying partial data to a user or streaming data without a known or finite length.

This PR adds a `.stream` function to `Request`, allowing clients of Alamofire to incrementally receive data from servers as it arrives. When using the `.stream` function, data is no longer accumulated into the `responseObject` object, as streams may be of unbounded length. (It's up to the calling code to join together the `NSData` objects returned in the `.stream` callback if the full response's data is needed.)

This PR also includes a test case to verify the behaviour of the `.stream` function, and to ensure that it doesn't conflict with the `.progress` functionality that already exists on `Request`.
 Glad to contribute - thanks for merging, @cnoon!
  Hi, I think it is nice if there is a feature which allows users to check network status like Reachable feature of AFnetworking  
 In my experience with AFNetworking, the reachability check is almost never useful. If a request fails because of a connectivity failure, you get an error back immediately that tells you so. It also goes against Apple's recommended practice to check reachability before making requests. So really it comes down to using to the reachability status changes to trigger some change, like restarting previously failed requests. But since such functionality isn't built into Alamofire, and seems rather out of scope for the library, it seems like integrating reachability would be too. I haven't looked but I'm guessing there's already a good Swift reachability library out there which developers can integrate with Alamofire if they need.
 Well, I have to agree that the reachability check is not that useful most of the time. However, I'm building an app which is really time-sensitive and I need to alert the user as soon as the network changed its state. I use AFNetworking.sharedManager to monitor the state of network at anytime and post a notification in the mentioned case. It's simple and elegant, I would love to see this pattern in AlamoFire.
 I think your best bet is to wrap the `Alamofire` API and use your own reachability monitor; I believe it's out of the scope of the library to build it in when it could be accomplished so easily outside. 
 In my experience there are two obvious scenarios where reachability is useful. One is re-trying some previously failed requests as @jshier mentioned. Another scenario is where the application needs to continuously sync some information with the server. 

Additionally, some apps could have an offline/online mode.
 Best way is to implement the reachability to allow the user offline alert. Also some option to disable the reachability. In some scenario we don't want to show internet connection message because we are fetching the data from server in background that time its very helpful.
 If you're looking for a Swift native Reachability replacement, take a look at http://github.com/ashleymills/Reachability.swift
  Looks like Alamofire isn't supporting 204 status code or is not able to parse the response. I tried `.response` and .`responseString` without any success.

Thanks
 Hi @cnoon, thanks for the quick reply!

I'm currently using a Rails API, returning `head :no_content` on a DELETE endpoint, which returns the following error:

```
Optional(<NSHTTPURLResponse: 0x7fbd33666d60> { URL: http://192.168.0.196:5060/api/organizations/6295710d-03c9-427a-b1d2-8e12951c4238/requests/878166fb-1bdc-4962-9218-71b306c82da0 } { status code: 204, headers {
    "Cache-Control" = "no-cache";
    "Set-Cookie" = "request_method=DELETE; path=/, locale=ImZyLUNBIg%3D%3D--f4c51516b9f7125f95cb9ca87028fc996c54dc42; path=/; expires=Tue, 05 Jun 2035 13:34:38 -0000, session_updated_at=8597778371; path=/, XSRF-TOKEN=Ya6GOlesHxBTSTsPrntco8BazpeZhe0%2Fce0xjcU8M8B7K1ytZn%2BIzmWMHbkUy1lVQ%3D%3D; path=/, _my_session=RzMyN0s5Z2Z3S2xadVMrYUZTalcyMVVGZ084bFFMR2hvc1FibTBLU1U4bVd5YUN6Y0VkOWhqV1FSSGdNU01WRG40RGptM1pWWFdvb3RZRldJdXArQUpCSUtXMEkrcFNIZzVYak8weTlLTXpM%3D--98831ed1e111854eabd6b3189ab79a2e5f807bc1; path=/; HttpOnly";
    "X-Content-Type-Options" = nosniff;
    "X-Frame-Options" = SAMEORIGIN;
    "X-Meta-Request-Version" = "0.3.4";
    "X-Request-Id" = "c30e4b82-889e-4d78-b7bd-5546bed20ad3";
    "X-Runtime" = "0.259388";
    "X-XSS-Protection" = "1; mode=block";
} })
null
Optional(Error Domain=com.alamofire.error Code=-1 "The operation couldn‚Äôt be completed. (com.alamofire.error error -1.)")
```

Here my request code:

``` swift
                Alamofire.request(Router.CancelRequest(organizationId: myRequest.organizationId, id: myRequest.id)).validate().responseJSON { (request, response, json, error) in
                    if error != nil {
                        ProgressHUDManager.serverError()
                        println(response)
                        println(json)
                        println(error)
                    } else {
                        self.myRequests.removeAtIndex(indexPath.row)

                        tableView.beginUpdates()
                        tableView.deleteRowsAtIndexPaths([indexPath], withRowAnimation: UITableViewRowAnimation.Automatic)
                        tableView.endUpdates()
                    }
                }
```

I also tried `.responseString`, and `.response` but I get the same error.

Currently, I'm returning the JSON of the deleted object with a 200 status code and it works.
 Note that when returning `head :ok` via Rails returns no errors and works, maybe because it returns a status code 200 with a space in the body (http://stackoverflow.com/questions/12407328/rails-head-ok-interpreted-as-ajaxerror).

head no_content (204 status with no body) seems like it's now the way to go though, and it's causing an error on Alamofire's side.

For more info: 
http://guides.rubyonrails.org/layouts_and_rendering.html#the-status-option
http://guides.rubyonrails.org/layouts_and_rendering.html#using-head-to-build-header-only-responses
 ```
                        debugPrintln(request)
                        debugPrintln(response)
                        debugPrintln(error)
```

```
<NSMutableURLRequest: 0x7fe9bb1a0060> { URL: http://192.168.0.196:5060/api/organizations/6295710d-03c9-427a-b1d2-8e12951c4238/requests/5eef6806-3a29-4c73-88f1-16b3b3e5e71a }
Optional(<NSHTTPURLResponse: 0x7fe9bb0310b0> { URL: http://192.168.0.196:5060/api/organizations/6295710d-03c9-427a-b1d2-8e12951c4238/requests/5eef6806-3a29-4c73-88f1-16b3b3e5e71a } { status code: 204, headers {
    "Cache-Control" = "no-cache";
    "Set-Cookie" = "request_method=DELETE; path=/, locale=ImVuLUNBIg%3D%3D--94055ba7447a3df85a4d06dca24b7dfa4148bede; path=/; expires=Tue, 05 Jun 2035 14:46:40 -0000, session_updated_at=7166550178; path=/, XSRF-TOKEN=7C4Klxu8WAesmOK4YglZY9srburOp7SBQwD4Xx2Tpw4JTP3dvr%2BbhdKMfh6Kx8HgP2Sw%3D%3D; path=/, _my_session=aVUtzUzFydGM3ODJQMTVoMyt0ZDkxQkhxWnZwNURmSEhkMFI1S3dmS2lyNWt3V0h2QkZDTE45Q1cyMUM0d1VHZ3FrQ1J1RHF1bHF4Um95cUlGMjA1ckxITTQxckZtMFBrNG84OXJTS01PQjcwVG0zNnBadmRhMTZoVHdDK0JxZnNhOFhOZWpxcmVpc1BnRCs4bm5QcmVlb1d2MUpEOUpGKzM3TEJBSFRqc3NJZmZ2c0VZQUgvNkNwUEgzQ2RHejJVUzk3VE9QaHErUUkrN3VydEFvUWw0dWxDczd2NlVhLzNrU08xNXBVUS9YYTN1TWt6TUlMTm9kOXV5Sk8xQWFXS1FiUzZQb29vejg9LS1YV255c0lUVWQ2SE44KzRPbS9mTEdnPT0%3D--eeb275d185f0b1ae5676e45ae73854030256e44b; path=/; HttpOnly";
    "X-Content-Type-Options" = nosniff;
    "X-Frame-Options" = SAMEORIGIN;
    "X-Meta-Request-Version" = "0.3.4";
    "X-Request-Id" = "506d-9227-4a83-85c4-19d293357726";
    "X-Runtime" = "0.180450";
    "X-XSS-Protection" = "1; mode=block";
} })
Optional(Error Domain=com.alamofire.error Code=-1 "The operation couldn‚Äôt be completed. (com.alamofire.error error -1.)")
```
 @cnoon This output looks pretty much the same than my previous one!
 @cnoon Anything I can do to help you hunt this bug?

For anyone interested, my current workaround with rails is to do:

`render json: true, status: 200` since `head :ok` is crashing jQuery (it can't parse an empty body) see http://stackoverflow.com/questions/4791499/jquery-doesnt-call-success-method-on-ajax-for-rails-standard-rest-delete-answ
 @cnoon Woops! There you go:

```
$ curl -i \
  -X DELETE \
  -H "X-Authorization-Consumer-Token: xxxx-bc24-479f-b87a-xxxx" \
  -H "X-Authorization-Token: xxxx-0224-48c6-817a-xxxx" \
  -H "Accept-Language: en;q=1.0,fr;q=0.9,de;q=0.8,zh-Hans;q=0.7,zh-Hant;q=0.6,ja;q=0.5" \
  -H "Accept-Encoding: gzip;q=1.0,compress;q=0.5" \
  -H "User-Agent: ios/com.myapp.ios (1; OS Version 8.3 (Build 12F69))" \
  "http://192.168.1.188:5060/api/organizations/6295710d-03c9-427a-b1d2-8e12951c4238/requests/b7dababf-bc64-4ca8-950a-54ac07cdb921"
```
 Without the `validate()`, I also get an error:

```
$ curl -i \
    -X DELETE \
    -H "X-Authorization-Consumer-Token: 943167ad-bc24-479f-b87a-9f2a200dbf28" \
    -H "X-Authorization-Token: 65f98ed3-0224-48c6-817a-582bd1cabb3c" \
    -H "Accept-Language: en;q=1.0,fr;q=0.9,de;q=0.8,zh-Hans;q=0.7,zh-Hant;q=0.6,ja;q=0.5" \
    -H "Accept-Encoding: gzip;q=1.0,compress;q=0.5" \
    -H "User-Agent: ios/com.agendrix.ios (1; OS Version 8.3 (Build 12F69))" \
    "http://192.168.1.188:5060/api/organizations/6295710d-03c9-427a-b1d2-8e12951c4238/requests/3364e39e-185d-43bd-9f5f-bd20441fa487"
Optional(Error Domain=NSCocoaErrorDomain Code=3840 "The operation couldn‚Äôt be completed. (Cocoa error 3840.)" (Invalid value around character 0.) UserInfo=0x7f97a29f6e50 {NSDebugDescription=Invalid value around character 0.})
Optional(<NSHTTPURLResponse: 0x7f97a29cbeb0> { URL: http://192.168.1.188:5060/api/organizations/6295710d-03c9-427a-b1d2-8e12951c4238/requests/3364e39e-185d-43bd-9f5f-bd20441fa487 } { status code: 500, headers {
    "Content-Length" = 208222;
    "Content-Type" = "text/html; charset=utf-8";
    "X-Request-Id" = "fdf1d2be-3552-4b01-8c74-dbc62881bced";
    "X-Runtime" = "1.330690";
} })
```
 Wich response block should I use? ResponseString? I'm pretty sure it crashes because it tries to parse it as json. 
 @cnoon Thanks for the explanation, but I think there's really an issue with Alamofire with a 204 no content. I was able to execute the cUrl code that `debugPrintln(request)` gave me, here's the output:

```
curl -i \
>   -X DELETE \
>   -H "X-Authorization-Consumer-Token: 943167ad-bc24-479f-b87a-9f2a200dbf28" \
>   -H "X-Authorization-Token: 17ea0cf1-33e6-49fd-841c-ae4b730414ae" \
>   -H "Accept-Language: en;q=1.0,fr;q=0.9,de;q=0.8,zh-Hans;q=0.7,zh-Hant;q=0.6,ja;q=0.5" \
>   -H "Accept-Encoding: gzip;q=1.0,compress;q=0.5" \
>   -H "User-Agent: ios/com.app.ios (1; OS Version 8.3 (Build 12F69))" \
>   "http://192.168.0.196:5060/api/organizations/d3613638-26e4-42c8-9ad5-22371fa5e8ff/requests/2463a56d-7c1c-4172-b42a-effbd4dca618"

HTTP/1.1 204 No Content
X-Frame-Options: SAMEORIGIN
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Cache-Control: no-cache
Set-Cookie: request_method=DELETE; path=/
Set-Cookie: locale=ImZyLUNBIg%3D%3D--f4c51516b9f7125f95cb9ca87028fc996c54dc42; path=/; expires=Thu, 14 Jun 2035 00:31:01 -0000
Set-Cookie: session_updated_at=7170708987; path=/
Set-Cookie: XSRF-TOKEN=bTrTufsdfsdsdfU3X6zgLOVW5OtGSb4iqmrybeKcjZ%2FcxE0%2BAinmnPUP70Cvee9FCIqcRHZCT5c9gVb6og%3D%3D; path=/
Set-Cookie: _app_session=cffffsfdsfffsdffsd%3D--326bc43e058a3cebffb19c155a2f808033c27dce; path=/; HttpOnly
X-Meta-Request-Version: 0.3.4
X-Request-Id: 7239e507-b81c-4eb0-bdcf-402c75b7994d
X-Runtime: 0.195868
```

I must have made a mistake when I copy/pasted the code above that returned an error 500 (maybe tried to delete twice the same object).

To be clear, the request goes trough correctly with Alamofire (the DELETE request is executed and my object is deleted). The problem (I think) is that Alamofire can't parse the response back correctly (just tried again with `.response` only, no success).

Here's the full code:

``` swift
                let request = Alamofire.request(Router.CancelRequest(organizationId: myRequest.organizationId, id: myRequest.id)).validate().response { (request, response, data, error) in
                    println(data)
                    println(response)
                    println(error)
                    if error != nil {
                        ProgressHUDManager.serverError()
                    } else {
                       // ...
                    }
                }

                debugPrintln(request)
```

Console output:

```
$ curl -i \
  -X DELETE \
  -H "X-Authorization-Consumer-Token: 943167ad-bc24-479f-b87a-9f2a200dbf28" \
  -H "X-Authorization-Token: 17ea0cf1-33e6-49fd-841c-ae4b730414ae" \
  -H "Accept-Language: en;q=1.0,fr;q=0.9,de;q=0.8,zh-Hans;q=0.7,zh-Hant;q=0.6,ja;q=0.5" \
  -H "Accept-Encoding: gzip;q=1.0,compress;q=0.5" \
  -H "User-Agent: ios/com.app.ios (1; OS Version 8.3 (Build 12F69))" \
  "http://192.168.0.196:5060/api/organizations/d3613638-26e4-42c8-9ad5-22371fa5e8ff/requests/60c4036c-07b3-4b7a-8a83-21863644667b"
Optional(<>)
Optional(<NSHTTPURLResponse: 0x7fa648cf94a0> { URL: http://192.168.0.196:5060/api/organizations/d3613638-26e4-42c8-9ad5-22371fa5e8ff/requests/60c4036c-07b3-4b7a-8a83-21863644667b } { status code: 204, headers {
    "Cache-Control" = "no-cache";
    "Set-Cookie" = "request_method=DELETE; path=/, locale=ImZyLUNBIg%3D%3D--f4c51516b9f7125f95cb9ca87028fc996c54dc42; path=/; expires=Thu, 14 Jun 2035 00:41:14 -0000, session_updated_at=7170709600; path=/, XSRF-TOKEN=8i%2BrcB39cYx540VA88O5UpZrUx9hZLBUCFI19NWDWXnptlkYbEiCW%2Bd2T6klxcthlX8OIBeClFlufuP8TlEy2g%3D%3D; path=/, _app_session=RTNLUHl0blM2T005T0hkRTRGTHFsOFFsN251TktxZjlyNTBiQWhPTWdZa0x1V0J0Wk5JYllGbG9jMllZQThuL015MUYrQkFGdUpGcXlxNkIyR2xyVTN3VWlMU2czT0krd2xxbE5MWWVQVTR5a0MrQWc5bzU2eFpBamVjUTM4SDNWMXZqb0ppV0RUbDFQdVpMejd1QTgvTDI3ci9TVDBUVjNDT3EwdTFQY0dNem5tK0w3MGZUUkp2cm5KT1ozeGh4bThjWGtMVTJBQmd4UkpvbXR2ek1idDdkS0swVm1FR2x4b0h2cStmRDhKcE43MjBBcGR5UWdPK25taVlKNkZJWVcvMEpzVWx1a1RmbFNlMjVicWk3VCs0dkg1WVpscDlkMUxyaVN4M2JLelU9LS1Ya00wV3BocXpHWWZjd3NBRmVsRGtnPT0%3D--64c0d2063398d762d085de0b52d1ddfcbc00049e; path=/; HttpOnly";
    "X-Content-Type-Options" = nosniff;
    "X-Frame-Options" = SAMEORIGIN;
    "X-Meta-Request-Version" = "0.3.4";
    "X-Request-Id" = "80bedf3a-afe0-40d8-9b35-6925d9f98097";
    "X-Runtime" = "0.170927";
    "X-XSS-Protection" = "1; mode=block";
} })
Optional(Error Domain=com.alamofire.error Code=-1 "The operation couldn‚Äôt be completed. (com.alamofire.error error -1.)")
```

Maybe Alamofire can't parse `Optional(<>)` and that's why error is set?
 Well, I just tried the above code without the `validate()` and it worked :open_mouth: ! What could this mean?
 I would see this as a bug. Also had a `204`, which fails on the validate function which is described as

> Validates that the response has a status code in the default acceptable range of 200...299, and that the content type matches any specified in the Accept HTTP header field.

Note that the server actually returns a `204` and a generic response function is called. 
 @cnoon, could you please consider reopening this?
 @allaire, you can replace the `validate()` with `validate(200..<300)` for now, since it would still be nice to validate that no error codes were returned. Alamofire throws an error on the validation of the [Content Type](https://github.com/Alamofire/Alamofire/blob/0b8f2074988d28f56f93e4cefaed65e48623abff/Source/Validation.swift#L145), as it is empty in the server's response. It fails exactly [here](https://github.com/Alamofire/Alamofire/blob/0b8f2074988d28f56f93e4cefaed65e48623abff/Source/Validation.swift#L122) by default, because no content type has been specified in the server's response. 

Note [RFC2616 Section 7.2.1](http://tools.ietf.org/search/rfc2616#section-7.2.1) mentions a SHOULD(_not a MUST_) for this if there is a _content-body_, I believe it to be unnecessary to specify a content-type if there is no content(`204`), so I would see this as incorrect behaviour of the default validation function of Alamofire.

I'm unable to provide a PR this week as I'm quite busy. I will either make one next week or if anyone else feels like picking this up, feel free to do so.
 @MartinRogalla Ah, that makes sense @MartinRogalla ! Thanks for the follow up and for digging this a bit deeper. I guess this could be re-open then :) cc: @cnoon
 I am seeing this too. Seem like the correct behavior is that Alamofire should not throw an error if the return is 204 No Content. 
 Is this code in production?
  I am following the steps to add Alamofire to my xcode project (iOS) and it's not working. I get all the way to the last step where I choose it in Embedded Binaries and both versions are there but after I choose it, it shows up as red text in xcode and I can't use the framework.

![screen shot 2015-06-03 at 12 10 55 pm](https://cloud.githubusercontent.com/assets/1347067/7966439/b4d4897c-09e9-11e5-8929-32ba7debd111.png)

I've been copying all the *.swift files into my project to use it but that seems hacky. I'd like to target iOS 7.0 so maybe that's my only option?

XCode v6.3.2
![screen shot 2015-06-03 at 12 13 11 pm](https://cloud.githubusercontent.com/assets/1347067/7966482/f59231da-09e9-11e5-91df-aeb5e526a665.png)
  It is possible to use multipart for next version?
 Thanks
  Looks good. Once you get #506 in and get this updated and tests passing, should be good to merge :+1: 
  :+1: 
  Awesome work.

Everything looks good here. I'd say the only issue is that now the tests only pass on 8.3 and up. I'd be all for getting travis to test on all supported test targets, as to get more coverage across all of the supported OS's. That would mean having some branching tests here to account for that problem in iOS 8.1 and 8.2, but I think its worth today to provide support for the rest of the library across other iOS versions.

I recently updated the [rakefile](https://github.com/AFNetworking/AFNetworking/blob/master/Rakefile) in AFNetworking, which shows how I am grabbing those simulators out and passing them in as test targets. Not sure if you can do the same thing here, but it would probably help you sleep better :beers: 
  Glad you caught the missing square brackets. üëè
 :+1: 
  I would like to propose to implement same functionality as `AFNetworking` methods:

```
- (void)setAuthorizationHeaderFieldWithUsername:(NSString *)username
                                       password:(NSString *)password;

- (void)clearAuthorizationHeader;
```

It's look pretty obvious for me, so I don't know why nobody implement it yet.
If you have any reason to don't do so - let me know. 

Otherwise I'm ready to create PR as soon as you approve  this enhancement.

Related with #27, #32, #99, #111, #119
 @cnoon [RFC2617](http://tools.ietf.org/html/rfc2617#section-2) states that

> A client MAY preemptively send the
>    corresponding Authorization header with requests for resources in
>    that space without receipt of another challenge from the server. 

Now it seems that given the `Authorization` headers are part of a standard they're not really a "special" case?  Just a suggestion - I'm no networking guru but on the current project I'm working on the web service won't send a challenge to a failed connection which means I had to get a little hacky to implement and felt like it should belong in Alamofire.

Also note the [prevalent usage](https://github.com/search?l=objective-c&q=setAuthorizationHeaderFieldWithUsername&type=Code&utf8=%E2%9C%93) of `setAuthorizationFieldWithUsername:password:` on AFNetworking projects on the GitHubs.

Either way thanks for your input in this great project.
 @cnoon Great news!
I agree, that it's not a good idea to integrate it in `Manager`. That's what about @mattt mention in #113
I think the better place to integrate this functions in `Request` class. What do you think?

And yes, after return an `NSMutableURLRequest` from `encode` (#478) it becomes easier to implement.
I'm open to discuss and ready to help with implementation of this functionality. 
Just let me know! :wink: 
 @cnoon @skywinder What I'm currently doing is manually base64 my username/password (using @skywinder's code from another issue) in my Router (`URLRequestConvertible`) and add it by doing:
`mutableURLRequest.setValue("Basic " + base64String!, forHTTPHeaderField: "Authorization")`.

Is this the preferred way? I need to do this in order to query my staging API (which is protected using HTTP Basic Auth). I would rather not call `authenticate()` on every request.
 Also @cnoon, I thought that URLRequestConvertible was the way to go to pass individual headers for different requests? This is going to change in a future release?

Thanks!
 @allaire My code (https://github.com/Alamofire/Alamofire/issues/32#issuecomment-101336349) it's just a workaround.

As @mattt's mention (https://github.com/Alamofire/Alamofire/issues/113#issuecomment-56207860)

> It's not recommended that you use session configuration headers for something like `Authorization`. Instead, use a type conforming to `URLRequestConvertible` to manage authentication state and routing.
  This fixes #497 
  Theres a way to uplaod multiple images with data? 
I found this http://stackoverflow.com/questions/26121827/uploading-file-with-parameters-using-alamofire
but seems pretty outdated.
 You may want to check this out in the meantime: https://gist.github.com/ncerezo/b1991f8dfac01cb162c0
 2 questions, fileUploader.uploadFile(request: request) seems no have a completion handler or similar, what i'm missing? do i need to do anything with that Request? And can i add images in memory like UIImages retrieved from a camera?
 The method returns the Alamofire.Request, which you can chain (if you want) with a completion handler or similar. It's not required though. You can simply make the call and that will upload the file.
As for adding images in memory, I've made a quick change to support it. I've modified the sample also.

Take into account that adding NSData objects instead of files uses twice as much memory.
This method of building the multipart data creates an NSData object where it adds the contents of the request, so if you add a file it will use the memory needed by the file, but if you use a NSData object it will need that data object plus its copy in the request data object.
That is, if you add a file of 500Kb no memory is used until you send the request. It then reads the file and adds it to the NSData object where the request data is built (along with multipart boundaries, etc).
However, if you add a NSData object of 500Kb it uses those plus another 500Kb when it is added to the request data.
 @ncerezo
Thanks for your codes! I'm finally be able to upload to S3!
But, first, I couldn't do that. By changing the order of parameters and files, I could do that. This suggestion - http://stackoverflow.com/a/15235866/1245142 - helmed me.
 You're welcome!
I've updated the gist so it puts the parameters first when creating the multipart data.
 Thanks again!
  The following issue appeared when I updated to Alamofire 1.2.2 from 1.2.1. I have switched back and forth and confirmed it only appears in Alamofire 1.2.2.

The code is (obfuscated to protect the innocents):

``` swift
        alamofireManager!.request(.GET, HTTPS_API_URL, parameters: search_parameters)
            .responseJSON { (req, res, json, error) in
                if(error != nil) {
                    NSLog("Error: \(error)")
                    NSLog("Error: \(error!.code)")

                    println(req)
                    println(res)
```

and the error output is:
2015-05-27 22:06:47.840 App:[25905:152266] queryAPI at:https://api.obfuscated.org/api ->[o: json, apikey: 12345678, t: search, q: horse]

2015-05-27 22:06:47.848 App[25905:152266] Error: Optional(Error Domain=NSURLErrorDomain Code=-999 "cancelled" UserInfo=0x7c45b040 {NSErrorFailingURLKey=https://api.obfuscated.org/api?apikey=12345678&o=json&q=horse&t=search, NSErrorFailingURLStringKey=https://api.obfuscated.org/api?apikey=12345678&o=json&q=horse&t=search, NSLocalizedDescription=cancelled})

2015-05-27 22:06:47.849 App[25905:152266] Error: -999

<NSMutableURLRequest: 0x7f9373d0> { URL: https://api.obfuscated.org/api?apikey= 12345678&o=json&q=horse&t=search }

nil

Any idea what could be causing it? Not that I am making other request with Alamofire in the app that work without issues but have different characteristics (HTTP & POST, not HTTPS & GET). My hunch is that this this is HTTPS related, possibly? I see the error both in the simulator & on the physical device.
 Will do. Were changes made in 1.2.2 to pay more attention to auth challenges and that's what I am seeing? Would you be so kind to provide a quick example of setting the sessionDidReceiveChallenge. From what I understand it's a closure?

How would you recommend I diagnostic how the auth challenge presents itself? This is a third party API where the API key should be the only auth. Could it be an issue with the SSL certificate?

When curling this is what I see:

```
* Hostname was NOT found in DNS cache
*   Trying redacted_IP_address...
* Connected to api.obfuscated.org (redacted_IP_address) port 443 (#0)
* TLS 1.2 connection using TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384
* Server certificate: *.obfuscated.org
* Server certificate: COMODO RSA Domain Validation Secure Server CA
* Server certificate: COMODO RSA Certification Authority
* Server certificate: AddTrust External CA Root
> GET /api?apikey=12345678&o=json&q=horse&t=search HTTP/1.1
> User-Agent: curl/7.37.1
> Host: api.obfuscated.org
> Accept: */*
> Cache-Control: no-cache
>
< HTTP/1.1 200 OK
< Date: Thu, 28 May 2015 15:18:17 GMT
* Server Apache/2.4.7 (Ubuntu) is not blacklisted
< Server: Apache/2.4.7 (Ubuntu)
< Strict-Transport-Security: max-age=63072000; includeSubDomains
< Strict-Transport-Security: max-age=63072000; includeSubDomains
< X-Powered-By: PHP/5.5.9-1ubuntu4.9
< Content-Type: application/json
< Transfer-Encoding: chunked
...
```
 Thank you, I appreciate it.
 @cnoon , @mattt : sorry to get back to this a month later, I finally had some time to try to diagnose. Using that code that Christian pointed me to, it seems that the following is true: `challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust`

I want to make sure I understand this well. Since 1.2.2 Alamofire no longer absorbs the authentication challenges but lets the developer decide how to handle them. In my case, the client is given an opportunity to question the https server certificate and the code provided by Christian ignores the challenge.

Am I right to understand that this is not necessarily a failed authentication but just an opportunity to challenge it? If it is in fact, a failed authentication, I cannot find a reason why that would be (see curl output) and would welcome a bit of help to diagnose what could be wrong in the auth. As advised, I don't want to blow past it but understand more about it so I can help fix the issue wherever it is.

This is my challenge.protectionSpace, the only challenge property that's informative:
`Host:api.obfuscated.org, Server:https, Auth-Scheme:NSURLAuthenticationMethodServerTrust, Realm:(null), Port:443, Proxy:NO, Proxy-Type:(null)`
 @cnoon , @mattt could you please confirm this?
 @cnoon thank you for your response, it provides me with leads to follow.
  The README contains the following code snippet:

`Alamofire.request(Router.Search(query: "foo bar", page: 1)) // ?q=foo+bar&offset=50`

I found that the resulting query is not `?q=foo+bar&offset=50` as the comment indicates, but rather `?q=foo%20bar&offset=50`.

Perhaps a bigger issue is that as I'm trying to work with the [GitHub Search API](https://developer.github.com/v3/search/), I'm unable to include `+` signs in my query, and GitHub doesn't seem to like the encoded version of `+` (`%2B`), nor the encoded version of space (`%20`).
 @joshuatbrown I believe Alamofire is handling URI encoding correctly, but it is very strange that GitHub Search API wouldn't handle decoding the URI correctly. 

You could work around this issue with the GitHub  Search API by implementing a custom encoded (see `ParameterEncoding.swift`), that wraps the URL encoded and replaces the encoded characters that the API can't handle with decoded characters (`%2B` -> `+`, `%20` -> ` `).
 @tobiasoleary Thanks for the tip on implementing a custom encoding - I'll go that route for now. I appreciate it!
 It looks like #167 is where this was changed. But since the `+` sign wasn't included in parameter encoded values before, should it be?
 @joshuatbrown Glad GitHub Search started working for you. I've looked into your question.

After reading [When to Encode - Section 2.4 - RFC3986](http://tools.ietf.org/html/rfc3986#section-2.4) I believe it should be encoded, since Alamofire does build the URI up from its component parts.
 @tobiasoleary :+1: I think that issue can be put to rest, then. I still think the docs need to be updated, so perhaps I'll do that now.
 @joshuatbrown I worry that my initial assessment is flawed. After reading [Reserved Characters - Section 2.2 - RFC3989](http://tools.ietf.org/html/rfc3986#section-2.2).

Since encoded reserved characters are not necessarily semantically identical to unencoded characters.
For example, suppose I want to search GitHub for an extensions (`MyExtension`) of some class (`MyClass`). In some languages convention dictates that you name the file the extension is in with a plus symbol (`MyClass+MyExtension.filtetype`). So I search for `MyClass+MyExtension`. 

Now if the search url is encoded as `?q=MyClass%2BMyExtension` that should indicate I want to search for the string "MyClass+MyExtension", however it the search url is `?q=MyClass+MyExtension` that should indicate I want to search for the strings "MyClass" and "MyExtension". This is according to the [RFC3986](http://tools.ietf.org/html/rfc3986).

Now the reason I believe Alamofire should not change what is currently does is many real-world web applications ignore the semantic differences. 

For example, doing the following searches lead to equivalent results:
- [https://www.google.com/#q=my+wife+is+beautiful](https://www.google.com/#q=my+wife+is+beautiful)
- [https://www.google.com/#q=my%2Bwife%2Bis%2Bbeautiful](https://www.google.com/#q=my%2Bwife%2Bis%2Bbeautiful)

Same with bing:
- [https://www.bing.com/search?q=my+dog+eats+poop](https://www.bing.com/search?q=my+dog+eats+poop)
- [https://www.bing.com/search?q=my%2Bdog%2Beats%2Bpoop](https://www.bing.com/search?q=my%2Bdog%2Beats%2Bpoop)

If the API you are integrating with doesn't ignore the semantic differences, then you can implement a custom encoder. 
  Hey Guys, 

I'm having problems passing in properties that are optional as parameters to an Alamofire POST request. 
I'm new to this so the error might be on my side but why do I get a `Could not find member .POST' when I try to pass in a parameter array that as optional values?

See the three screenshots here:

![image](http://i.imgur.com/bOqVctk.png)

![image](http://i.imgur.com/SzUBwMM.png)

![image](https://cloud.githubusercontent.com/assets/1503385/7784518/9e6c88ee-0168-11e5-9e84-4a102dbc72d9.png)

Any idea on what's going on?

Thanks!
 @cnoon Allright, thanks for your response. Makes a lot of sense. Sorry about posting that here, should've read the guidelines. Cheers!
  Right now, to mock a response I am:
- Subclassing Request
- Subclassing Manager.request (with reimplementation) to return my mocked Request.

This isn't so bad, but it's more work than it should be. If the manager had some kind of request factory that you could provide it, that would make life easier.
 hi @cnoon, any update on the `NSURLProtocol` documentation? I just don't feel comfortable with the method swizzling that happens with other libraries. thanks!
 Hey,
I've used the code from test @cnoon mentioned, and wrapped it up to make it useful for testing. If it interesting, and put it in a [gist](https://gist.github.com/omerlh/2617db3d4116bf46bdeb). Hope that it will be useful for someone :)
    Hello,

I have a simple question to asked and didn't find a lot of clue online,
I thought i was gonna be a hard question to expose but i think the title is actually pretty straightforward.

> Should Requests with 'startRequestsImmediately' to `false` always resume or cancel ?

Here something similar to what i have : 

```
Manager.sharedInstance.startRequestsImmediately = false
var request_: Request = Manager.sharedInstance.request(.GET, "http://httpbin.org/get")
```

Now is this `good` or `bad` to do such a thing ? letting the `request_` deallocate and never calling `cancer:` or `resume:` on the request ?
  can you tell just for a example ,when i use upload method  ,the response all always tell me "cant find the input stream"?,thx
  What do we need to do to get Travis or some other CI setup here?
 :+1: 
     ÈìæÂºèÂìçÂ∫îÂÅöÁöÑÂ§™Â•Ω‰∫ÜÔºåÂ∞±ÊòØÈÇ£‰∏™Êô∫ËÉΩÊèêÁ§∫‰∏çÊÄé‰πàÂ•Ω

> Google Translation: Chain Response to do good, not so good is that smart tips.
  In my case, I'm serializing a protocol buffer request as the body of a POST. It's a little unnatural to express this as a dictionary and it seems silly to have to write an encoder to get to NSData, when that's what the other encoders are trying to do. It would be nice to have something like:

```
public func request(method: Method, URLString: URLStringConvertible, body: NSData) -> Request 
```
  App crashes when try to launch on Iphone. But works on simulator.

dyld: Symbol not found: __TFSsoi1lFTSSSS_Sb
  Referenced from: /private/var/mobile/Containers/Bundle/Application/23E75276-3295-4C2F-AA3E-6119F1D160FA/punjit.app/Frameworks/Alamofire.framework/Alamofire
  Expected in: /private/var/mobile/Containers/Bundle/Application/23E75276-3295-4C2F-AA3E-6119F1D160FA/punjit.app/Frameworks/libswiftCore.dylib
 in /private/var/mobile/Containers/Bundle/Application/23E75276-3295-4C2F-AA3E-6119F1D160FA/punjit.app/Frameworks/Alamofire.framework/Alamofire
 Hi Matt
The question is specific to the project itself. The project was compiling before i synced to the latest version of Alamofire with new Swift 1.2. After that it stopped working. 
And it is raising different exceptions on different devices but all related to Alamofire.
  code like this  :  
Alamofire.request(.POST, URL,
            parameters: [
                "arg1": [
                     ["id": "001","name": "person1"] ,
                     ["id": "002","name": "person2"]
                ] 
            ])
...

On the server sideÔºàPHPÔºâÔºåi can get the values  "001","002"   ,how ever when i  try to get the name  value ,it responed error with "Undefined value".
thansk !
 thanks cnoo,i have try encoding the parameters as ".JSON"   ,but it doesnt work  .
and i have change the your code to fix the problem.
here is my code:
file : ParameterEncoding.swift
function:queryComponents
![fix](https://cloud.githubusercontent.com/assets/12445939/7649312/545397e8-fb1e-11e4-800a-71d2cf8450ec.png)
 I found that some URL encoded parser will treat a multi-dimension parameter that doesn't include parameter index in the outer square bracket as a flat array parameter (like this issue).
How's about check that the value of parameter is either dictionary or array. If it is, we will include index in the square bracket, otherwise, we will use the intended behavior from the docs?
  ### There is a mistakeÔºåWhen some links on request

You can try to visit the following link, will be a fatal error

see:http://store.apple.com/cn?afid=p231|camref%3A111lEF&cid=AOS-CN-Aff-PHG

``` swift

Alamofire.request(.GET, "http://store.apple.com/cn?afid=p231|camref%3A111lEF&cid=AOS-CN-Aff-PHG", parameters: nil, encoding: ParameterEncoding.JSON).response { (request, response, result, error) -> Void in

            println("error ====  \(error)")

            println("request \(request)   ----  response \(response)  -----  result \(result)   error \(error) ")

            println(response?.MIMEType)
        }
```

Is caused by NSURL is nil, hope to improve 
  Fix test in case of response is `nil` (in my case it is) - we are get crash when try to unwrap optional variable and test not finished at all. So I add additional check, that response is not nil.

![screen shot 2015-05-13 at 19 48 13](https://cloud.githubusercontent.com/assets/3356474/7615879/267761cc-f9a9-11e4-88be-aadd0c3396c8.png)
  The pull request #471 didn't update the README instructions.
  Replace return from NSURLRequest type to `NSMutableURLRequest` since it's
always `NSMutableURLRequest` except one case (when parameters == nil).
This change get users more flexibility in usage of this `encode` function and eliminate of redundant casting of `NSMutableURLRequest` to `NSMutableURLRequest` after (because in most of cases `encode` function returns `NSMutableURLRequest` already).
  Hi guys

it was working, and suddently I got the following error:

```
ld: warning: ignoring file /Users/kamol/Library/Developer/Xcode/DerivedData/ShoppingXXX-dlpuiajnjtnnesfkfvqddrrirgnd/Build/Products/Debug-iphoneos/Alamofire.framework/Alamofire, file was built for armv7 which is not the architecture being linked (arm64): /Users/kamol/Library/Developer/Xcode/DerivedData/ShoppingXXX-dlpuiajnjtnnesfkfvqddrrirgnd/Build/Products/Debug-iphoneos/Alamofire.framework/Alamofire
```

Undefined symbols for architecture arm64:

I am using CocoaPods:

```
pod 'Alamofire', '~> 1.2'
```

Any bug?

Best regards
Kamol
 @cnoon thank you!
  If Alamofire is used in iOS7 following code doesn't have any effect on iOS7 but it works as expected on iOS 8

``` swift
var defaultCfg: NSURLSessionConfiguration  {
    let cfg = NSURLSessionConfiguration.defaultSessionConfiguration()
    cfg.HTTPCookieStorage = NSHTTPCookieStorage.sharedHTTPCookieStorage()
    cfg.HTTPCookieAcceptPolicy = NSHTTPCookieAcceptPolicy.Always
    cfg.URLCache = nil
    cfg.HTTPAdditionalHeaders = ["User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:37.0) Gecko/20100101 Firefox/37.0", "Accept-Language":"en-US,en;q=0.5"]
    return cfg
}

self.manager =   Manager(configuration: defaultCfg) // I am using source directly
self.manager.session.configuration.HTTPAdditionalHeaders!["Referer"] = url // No effect on iOS 7
```

On iOS7 I can't change the session headers after manager is initialized. However on iOS 8 I can change the header before the request anytime I want.
 I just copied and pasted portion of it.manager is instance variable. The issue is there. Only remedy is to initialize manager for each session or use custom encoding and delegate to set the headers
 But initializing manager for each request, defeats the purpose of having manager. Also I think in README it should be noted that on iOS 7, once a manager is initialized, configuration is read-only. I wish you could do some voodoo to make it work for iOS 7 :)
 @cnoon I am thinking about below changes which seems to work. Could you check it ?

``` swift
// I added new paramater headers
    public func request(method: Method, _ URLString: URLStringConvertible, parameters: [String: AnyObject]? = nil, headers: [String: String]? = nil, encoding: ParameterEncoding = .URL) -> Request {
        return request(encoding.encode(URLRequest(method, URLString), parameters: parameters, headers:headers).0)
    }

  public func encode(URLRequest: URLRequestConvertible, parameters: [String: AnyObject]?, headers:[String:String]?) -> (NSURLRequest, NSError?) {

          var mutableURLRequest: NSMutableURLRequest! = URLRequest.URLRequest.mutableCopy() as! NSMutableURLRequest
        var error: NSError? = nil


        if let dictionary = headers {
            for (key, value) in dictionary {
                mutableURLRequest.setValue(value, forHTTPHeaderField: key)
            }
        }


        if parameters == nil {
            if headers == nil {
                 return (URLRequest.URLRequest, nil)
            } else {
                return (mutableURLRequest.URLRequest, nil)

            }
                   }
```

Then in my program, 

``` swift
  var headers = ["Referer": "http://www.example.com"]
  self.manager.request(.GET, url, parameters: nil,headers:headers)
```

I think header stuff must be part of request parameters. Since just like HTTP method or parameters they are being used a lot. 
 Thanks @cnoon for checking. I think I will stick with my implementation. Because creating URLRequest by hand defeats the purpose of having URLRequestConvertible. if there were no `parameters` parameter we would also had to use URLRequest to create by hand. But it is there to make things easier. Just my two cents.
    See http://www.openradar.appspot.com/17809816

```
When adding `HTTPAdditionalHeaders` to an `NSURLSession` and setting it up with an `NSURLProtocol`, the request seen by `NSURLProtocol` should contain all the HTTP headers, including the ones from HTTPAdditionalHeaders.

Expected Results:
In the protocol‚Äôs `startLoading` method, `self.request.allHTTPHeaderFields` should contain both the headers added to this specific request, and the additional headers setup on the session

Actual Results:
In iOS8, this isn't the case. Only the request-specific headers are present.
```

So this isn't a bug in Alamofire. However it is a surprising failure for anyone using the library. It also means that the approach to keeping network activity indicators in sync with Alamofire requests suggested in https://github.com/Alamofire/Alamofire/issues/185 is incompatible with custom (or Alamofire's default) headers in iOS 8.

While I hate to add OS version conditional code it might be worthwhile to copy the session configuration's headers onto each request rather than count on the session to apply them.

Unfortunately I don't see a way the `NSURLProtocol` which exposes this issue could solve it because by the time the protocol receives the request it does not have access to the session or the session's configuration so there's no convenient way for the URL protocol to retrieve and apply that configuration.
 I mean to say that an `NSURLProtocol` implementation like https://github.com/marcelofabri/BigBrother does not have an opportunity to add the `HTTPAdditionalHeaders` to the request. Since this is an issue only when using a custom `NSURLProtocol` my first reaction was to try to find a protocol implementation which could support the expected behavior however that does not seem to be an option. Instead I think any workaround to include these headers needs to be performed by Alamofire.
 As I continue to work on an app using Alamofire I'm increasingly uncertain that Alamofire should recommend custom `NSURLProtocol` implementations as a means of adding behavior around Alamofire managed requests.

In addition to not having access to session configured headers, a custom `NSURLProtocol` also requires re-implementing cache control and any other features I haven't noticed I'm missing from the default protocol implementations. Since `NSURLProtocol`s are not chainable, a user of the library has to compose any and all desired behaviors into a single protocol implementation. This means that those protocol implementations are difficult to share and distribute.

Rather than a workaround here perhaps a more appropriate change would be to provide hooks into the Alamofire request queue so that other components could react to requests starting and stopping; for example to update a network activity indicator.
  class TaskDelegate init 
operationQueue.qualityOfService = NSQualityOfService.Utility

NSOperationQueue.qualityOfService  need ios 8.0
 It looks like this issue is back in the swift 2.0 branch Request.swift

if #available(OSX 10.10, *) {
       operationQueue.qualityOfService = NSQualityOfService.Utility
}
 Ah ok, didn't realize support was being dropped for iOS7! This was the one thing not working for me with iOS7 and swift 2.0
  @cnoon Really nice work! Thanks!
  This is test for #469. Comment says return nil causes a deadlock/timeout, but I'm OK. (XCode 6.3.1)
Is it OK? Please let me know if you find something wrong.
 @cnoon should this still be in the 1.2.2 bucket?

EDIT: Nevermind I see the reference to the other commit there.
  To prevent redirection, completionHandler shuold be set nil.
  In file module.modulemap

framework module Alamofire {
    header "Alamofire-Swift.h"
}

Using Alamofire (1.2.1)
Using Bolts (1.1.5)
Using FBSDKCoreKit (4.1.0)
Using FBSDKLoginKit (4.1.0)
Using FBSDKShareKit (4.1.0)
Using SwiftyJSON (2.2.0)
## 

Apple Swift version 1.2 (swiftlang-602.0.49.6 clang-602.0.49)
Target: x86_64-apple-darwin14.3.0
## 

XCode Version 6.3.1 (6D1002)
## 

source 'https://github.com/CocoaPods/Specs.git'
platform :ios, '8.1'
use_frameworks!

pod 'Alamofire'
pod "SwiftyJSON", ">= 2.2"

pod 'FBSDKCoreKit'
pod 'FBSDKShareKit'
pod 'FBSDKLoginKit'
  After my upload I get a JSON response. I do not want to parse it right now so I just need the JSON response as String. Do I have to use `responseJSON` or `responseString` for that?
 Done http://stackoverflow.com/questions/30012402/get-the-json-response-as-string
  How can I add mimeType: "image/jpeg" to my upload request?
 http://stackoverflow.com/questions/30017652/add-mimetype-to-upload-using-alamofire
  Try to get PUT request work, but complie shows error "Extra Argument in Call" for the code below.

Alamofire.request(.PUT, apiUrl,params,ParameterEncoding.JSON)
        .responseJOSN{ (request, response, products: [Product]?,error) in
            println(request)
            println(response)
            println(data)
            println(error)
    }
  Execution a request appending an umlaut parameter (√§√º√∂) occurs a BAD Access Exception in method:

private func URLRequest(method: Method, URL: URLStringConvertible) -> NSURLRequest {
at let mutableURLRequest = NSMutableURLRequest(URL: NSURL(string: URL.URLString)!) 
 I simply made an URL request with POST or even GET method.

e.g. url: http://www.domain.de/service.php?id=123&email=abcd@t√ºr.de
  i use cocoapods add alamofire 1.2.1.

**error message:**

```
ld: warning: ignoring file /Users/gaoyu/Library/Developer/Xcode/DerivedData/GameRSS-bwmvigmbdfpeojdrivmuiknmvjlc/Build/Products/Debug-iphonesimulator/Alamofire.framework/Alamofire, file was built for x86_64 which is not the architecture being linked (i386): /Users/gaoyu/Library/Developer/Xcode/DerivedData/GameRSS-bwmvigmbdfpeojdrivmuiknmvjlc/Build/Products/Debug-iphonesimulator/Alamofire.framework/Alamofire
Undefined symbols for architecture i386:
  "__TF9Alamofire7requestFTOS_6MethodPS_20URLStringConvertible_10parametersGSqGVSs10DictionarySSPSs9AnyObject___8encodingOS_17ParameterEncoding_CS_7Request", referenced from:
      __TFC7GameRSS14ViewController11viewDidLoadfS0_FT_T_ in ViewController.o
  "__TFC9Alamofire7Request14responseStringfDS0_FT8encodingGSqSu_17completionHandlerFTCSo12NSURLRequestGSqCSo17NSHTTPURLResponse_GSqSS_GSqCSo7NSError__T__DS0_", referenced from:
      __TFC7GameRSS14ViewController11viewDidLoadfS0_FT_T_ in ViewController.o
  "__TFO9Alamofire6Method3GETFMS0_S0_", referenced from:
      __TFC7GameRSS14ViewController11viewDidLoadfS0_FT_T_ in ViewController.o
  "__TIF9Alamofire7requestFTOS_6MethodPS_20URLStringConvertible_10parametersGSqGVSs10DictionarySSPSs9AnyObject___8encodingOS_17ParameterEncoding_CS_7RequestA2_", referenced from:
      __TFC7GameRSS14ViewController11viewDidLoadfS0_FT_T_ in ViewController.o
  "__TIFC9Alamofire7Request14responseStringFDS0_FT8encodingGSqSu_17completionHandlerFTCSo12NSURLRequestGSqCSo17NSHTTPURLResponse_GSqSS_GSqCSo7NSError__T__DS0_A_", referenced from:
      __TFC7GameRSS14ViewController11viewDidLoadfS0_FT_T_ in ViewController.o
  "__TWPSS9Alamofire20URLStringConvertibleS_", referenced from:
      __TFC7GameRSS14ViewController11viewDidLoadfS0_FT_T_ in ViewController.o
ld: symbol(s) not found for architecture i386
clang: error: linker command failed with exit code 1 (use -v to see invocation)

```
 ok~~ thank 
  Just got a binary rejection with the following error in the crash log. Does anyone have any ideas?

```
Dyld Error Message:
  Symbol not found: __TWPSSSs16OutputStreamType
  Referenced from: /private/var/mobile/Containers/Bundle/Application/.../Dinesupply.app/Frameworks/Alamofire.framework/Alamofire
  Expected in: /private/var/mobile/Containers/Bundle/Application/.../Dinesupply.app/Frameworks/libswiftCore.dylib
 in /private/var/mobile/Containers/Bundle/Application/.../Dinesupply.app/Frameworks/Alamofire.framework/Alamofire
  Dyld Version: 353.12
```
   ![2015-05-01 00 00 09](https://cloud.githubusercontent.com/assets/7303158/7416893/13cf44b8-ef95-11e4-8f4d-46705c221529.png)

hi, i'm find is 1.1.4
 i have update CocoaPods. but version is 1.1.4
 ok~thx
 You need to run `pod repo update` first which will update the main spec repo. Yours is most likely out-of-date.
  Hello, my app uses a self-signed, self-generated SSL certificate, which I want to use Alamofire to connect to. It works when I use HTTP Basic authentication but doesn't allow me to connect when I don't have any authentication. I am about 90% sure that the issue is not in my app. 

Is there some way to instruct Alamofire to trust self-signed certificates, preferably for specific hosts?
 @aemreunal I could be completely wrong, but if I understand correctly, Alamofire leans on iOS networking to validate SSL certs. Try installing and trusting the certificate at the OS level. 
 @travelton Thank you for your reply. 

The application, as part of its deployment script, generates a new certificate and uses that. As it is in development, it frequently regenerates new certificates.

I do believe you have a point and that you are right and I believe it is viable, and actually preferable, for stable servers with unchanging certificates but it just isn't a sustainable solution for my case. 

I also use [onevcat/Kingfisher](https://github.com/onevcat/Kingfisher) in my iOS app and it has just this exact feature. I can, for example, write the following code to trust self-signed certificates in my localhost:

``` swift
KingfisherManager.sharedManager.downloader.trustedHosts = Set(["localhost", "127.0.0.1"])
```

and it works like a charm. A similar feature, if it doesn't already exist, would be awesome for Alamofire.
 Hello @cnoon, thank you for the feedback and providing all the information. Is there a timeframe for the 1.3.0 release? Thank you for all your work. I'll be looking forward to the updates.
 Thanks @cnoon.
 @cnoon should this be in the 1.2.2 bucket? I don't see any changes here.
  I first went through all the public delegate closure docs and fixed any that were a bit off. It appears that a couple suffered from a copy/paste error and another one had the wrong method signature. They all should be fixed at this point.

Then I realized that the method signatures were written for Swift 1.1 and had not yet been updated for Swift 1.2. The closures have now all been updated to match the delegate method that they can override. I also updated any logic in the tests that were affected by this change. All the tests are now passing as expected.
  The podspec lists OS X 10.9 as the deployment target but alamofire 1.2.1 will not build using Xcode 6.2 and Xcode 6.3 requires OS X 10.10+
  I can think of any downsides to adding this ignore flag, and it certainly resolves the issue you pointed out with using Carthage with submodules. IMO this is a good change that would certainly benefit Carthage users. 

Thanks @tomassliz!
  If I request 
`Alamofire.request(.GET, messagesURL, parameters: parameters, encoding: .JSON).response({ (_, response, data, _) -> Void in ... })` `data` type is `NSConcreteMutableData`. 
And if I cast it to `[NSObject : AnyObject]` error appears `Could not cast value of type 'NSConcreteMutableData' (0x1f7afbc) to 'NSDictionary' (0x4a3cd74).`
Header contains `application/json` and `AFNetworking` parse it successfully.
  First off, this is not an issue with Alamofire but with embedded frameworks in general. Therefore, you should open a question on StackOverflow tagging `iOS` and `framework`. 

That being said, I know for a fact that [CocoaPods](https://guides.cocoapods.org/using/getting-started.html) will solve this problem for you. I have an app that has many different configurations and schemes using CocoaPods that doesn't have this issue. CocoaPods generates all the same configurations in the pods themselves. 

I'm fairly certain that I couldn't find a way to get around this issue when using embedded frameworks without adding the custom configurations to the frameworks themselves. I believe it is a linker path issue that ends up being the issue. If you'd like to know more from the experts, then I would suggest opening a question on StackOverflow and they will surely be able to help you, or confirm my doubts.
 Link to the question? Again, we don't use Github as a support forum for Alamofire, so please link the question and close out this issue since this isn't related to Alamofire but frameworks in general.
 Well there is no sure shot solution for this. Just try to clean your code again and again. If it doesn't works, make sure that your Xcode is of latest version.

Reference:-> [Fixing Alamofire No such module error](http://swiftforums.org/forum/alamofire/39-how-to-fix-alamofire-no-such-module-error#post39) 

Try it. Hope it helps
 @tvich1 This is not about infinite cleaning, this is about Xcode vs. Frameworks concept. Everything was already answered in my StackOverflow question and this thread here was closed a year ago.
 @tomassliz Could you update the link to your question at StackOverflow, as the provided link is broken? @duongel Sorry but the question on StackOverflow was deleted. I know this is absolutely the wrong place, but what were the correct answers discussed over there? I couldn't find any working solution so far.
I am currently struggling to get Cocoapods to work with a custom build configuration and always getting a `No such module` error. There is no correct solution at all. You can hack your project settings and set build paths to be the same for all the configurations, but I think that this is not a good way because there can be build fragments from previous builds and you have to clean them each time. Thanks for your fast response. In fact, I was able to solve it by simply updating Cocoapods :-) So it was different problem I think because I didn't use CocoaPods. But I'm glad to hear that you solved your issue ;-)    Currently if validation fails the error object seems to always be `NSError(domain: AlamofireErrorDomain, code: -1, userInfo: nil)`.

It would be nice if the `validator` would return something besides a `Bool` (maybe `NSError?`) so that if the validation failed because of a 404 the error object given to the response handler might have a description of "Invalid Status Code - 404 File Not Found".
 @tobiasoleary @cnoon Is there also a way to capture the body content of a failing request?

```
Alamofire.request(Router.ReadOrganizations).validate().responseSwiftyJSON({(request, response, json, error) in
    if error == nil {
        self.performSegueWithIdentifier("SigninToMySchedule", sender: self)
    } else {
        println(response?.statusCode)
        println(error)
    }
})
```

With the code above, when an error happens, `error` (`com.alamofire.error Code=-1`) is meaningless and json is nil. At least we have access to the statusCode. Is this by design @mattt ?

**EDIT** My bad, this is caused by Alamofire-SwiftyJSON: https://github.com/SwiftyJSON/Alamofire-SwiftyJSON/blob/master/Source/Alamofire-SwiftyJSON.swift#L46
 After thinking about this. I think by design to the keep the `Validator` type easy to understand and create. The client should write their own error messages. On the other hand it would be nice to know which Validator failed, just to narrow down what the issue could be.

So I have been working with an API that sends HTML error pages when it fails. This is useful debugging information for me, so I've been using both `responseString` and `responseJSON` completionHandler. 

See example below.

```
final class Box<T> {
    private let value: T

    var unbox: T {
        return value
    }

    init(_ initValue: T) {
        value = initValue
    }
}

enum Result<SuccessType> {
    case Success(Box<SuccessType>)
    case Failure(NSError)
}

func liveUpdate(#teamIdentifier: String, filter: String, sinceIdentifier: String, completionHandler: (Result<LiveUpdateData>) -> Void) {

        Alamofire.request(Router.LiveUpdate(teamIdentifier, filter, sinceIdentifier))
            .validate()
            .responseString {
                (request, response, responseString, error) in
                if let error = error {
                    Debug.printRequest(request, response: response, responseString: responseString, error: error)
                }
            }.responseJSON {
                (request, response, JSON, error) in

                if let error = error {
                    completionHandler(.Failure(error))
                } else if let JSON = JSON as? [String : AnyObject], let liveUpdateData = Mapper<LiveUpdateData>().map(JSON) {
                    completionHandler(Result.Success(Box(liveUpdateData)))
                } else {
                    completionHandler(.Failure(ErrorFactory.unknownError))
                }
        }

    }
```
 @cnoon 

I've only read about, but haven't used, Swift 2.0's new way of handling errors, but it reminds me of Java exceptions. In Java exception handling is rather expensive and can really interrupt the code flow so it should only be used for very uncommon, some would say "exceptional", circumstances. 

Since APIs can use status codes to represent common errors, like invalid login credentials, I don't know if the using the new syntax for error handling would be appropriate. 

It maybe considered premature for me to voice this concern, since I haven't played around with the new error handling. But I wanted to voice my concerns earlier than later, after playing with the new error handling maybe my concern will be invalidated.

I think I'll have to update [my most popular Stack Overflow question](http://stackoverflow.com/questions/5009597/objective-c-assertion-vs-exception-vs-error) soon.
 From the WWDC talk on What's New in Swift (http://asciiwwdc.com/2015/sessions/106):

> But it means that you don't have to worry about our error-handling feature being so expensive that you can't use it in order for the actual reasons that you need to if you do need to care about the efficiency of the error path.

Sounds like they were careful to avoid the huge performance hits like you see with Java. 
 @jaylyerly Thanks I'll take a look. 
   Everything is fine, while i am running my application in Simulator, but i received the signal Segmentation fault, when its running on the device

<unknown>:0: error: could not build Objective-C module 'Alamofire'
0  swift                    0x0000000104d26a08 llvm::sys::PrintStackTrace(__sFILE*) + 40
1  swift                    0x0000000104d26ee4 SignalHandler(int) + 452
2  libsystem_platform.dylib 0x00007fff9808bf1a _sigtramp + 26
3  libsystem_platform.dylib 0x00007fff5b5f3498 _sigtramp + 3277223320
4  swift                    0x000000010460eae6 main + 1814
5  libdyld.dylib            0x00007fff8b1225c9 start + 1
6  libdyld.dylib            0x0000000000000045 start + 1961745021
  it say "Cannot invoke 'responseJSON' with an argument list of type '((_, _, _, _) -> Void)'" when i try to request using parameter

```
request(.GET, "http://api.mymemory.translated.net/get", parameters:parameters)
                .responseJSON { (_, _, JSON, _) -> Void in

                    let translatedText: String? = JSON?.valueForKeyPath("responseData.translatedText") as String?

                    if let translated = translatedText {
                        self.translatedTextLabel.text = translated
                    } else {
                        self.translatedTextLabel.text = "No translation available."
                    }

            }
```
 @masbenx  try to run this code without 'responseJSON' part, I'm almost sure the problem lies in the typing of 'parameters'.
 Yep, i too face the same issue, 

Alamofire.request(.POST, someUrl, parameters: ["accessToken" : accessToken, "UserEmail" : gUserEmail], encoding:.JSON)
            .responseJSON(){ (request, response, JSON, error) in
}

Is anything wrong in my parameter?
 I'm seeing this too with nullable parameters, but NSNull() works fine.
 I also getting this issue.
Please help
 I solve this marking the var like not nil (!) 

let params = ["key":value!]
Alamofire.request(.GET, url, parameters: params)
            .response { request, response, data, error in ...
 same problem. framework is not good!!!
  @cnoon
I don't want answer now!
  Unable to successfully use/import Alamofire. Xcode 6.3 with a clean project and cocoapods install.
![screen shot 2015-04-21 at 2 40 00 am](https://cloud.githubusercontent.com/assets/8210075/7248446/ebc875d8-e7cf-11e4-83d5-ac9d97d8b783.png)
 Clean did not work, re-installing from pods did not work, installing from carthage did not work, manual install did not work. I finally got it to work after Build for Testing.
 Hi @n2b8,

This is working properly for the majority of us. Here's a few tips that maybe will help. Otherwise please open a ticket on [StackOverflow](http://stackoverflow.com/questions/tagged/alamofire) and we can further assist there. That will also give the question and answer more visibility to the rest of the community.

**Xcode Version**

![screen shot 2015-04-21 at 8 02 09 am](https://cloud.githubusercontent.com/assets/169110/7255222/c003de7e-e7fc-11e4-834e-8e1eb579b8fc.png)

**CocoaPods Version**

``` bash
cnoon:~$ pod --version
0.36.4
```

**Podfile**

``` ruby
source 'https://github.com/CocoaPods/Specs.git'
platform :ios, '8.0'
use_frameworks!

pod 'Alamofire', '~> 1.2'
```

**Import Alamofire in New Project**

![screen shot 2015-04-21 at 8 03 13 am](https://cloud.githubusercontent.com/assets/169110/7255258/ec2ea196-e7fc-11e4-9e36-e8a4f60d43e6.png)

**Build Project**

![screen shot 2015-04-21 at 8 03 30 am](https://cloud.githubusercontent.com/assets/169110/7255262/ef543d36-e7fc-11e4-806b-4fc697181e83.png)

---

If none of these end up solving your issue, then please open a question on StackOverflow and post a link to the question here. I'll continue to help you debug the issue further if necessary. 

Cheers.
 I had the same problem after installing from cocoapods.
Choosing Product | Clean then Product | Build fixed it.
 Had the same problem after installing from cocoapods. Product/Clean didn't help. Shutting down Xcode and reopening the workspace did help.
 I also have that issue. It wouldn't affect build the project but very annoying. And I think it only happens when you use cocoapod to add Alamofire to the existing project which is not init with cocoapod.
 None of the above helped, opened Stack Overflow issue as recomended. 
http://stackoverflow.com/questions/31674885/cannot-load-underlying-module-for-alamofire
 This solved it for me:

https://github.com/Alamofire/Alamofire/issues/122
 Follow up: Updating to xcode 7.0 and https://github.com/Alamofire/Alamofire/issues/122, solved it for me. 
 Xcode 7.0.1 and #122 solved for me as well.
 Xcode 7.1 and #122 solved it for me as well.

All I had to do was comment out the `import Alamofire` and run the app; then uncomment it.
 xcode 7.1 , build the project once before using the framework works.
 Xcode 7.1, after install Alamofire with cocoapods, clean your project and rebuild. It works.
 I did this: 
While installing pod this warning message was shown: 
[!] The `Confidential` target overrides the `EMBEDDED_CONTENT_CONTAINS_SWIFT` build setting defined in `Pods/Target Support Files/Pods-Confidential/Pods-Confidential.release.xcconfig'. This can lead to problems with the CocoaPods installation

And then I did this:
Go to your target Build Settings -> Other linker flags -> double click . Add $(inherited) to a new line.

Proplem solved
 build for testing worked to get rid of the error for me.
 I had this problem and couldn't figure it out until I dropped the iOS module from 9.1 down to 8.0 and it then told me that "**Alamofire module requires iOS 9.2**". Changed the project up to 9.2 and it now builds correctly.
 I had this issue with the beta version of pod. My issue was fixed once I went to a stable release.
 I tried ios9.3. I am not getting this to work. 
 <img width="346" alt="screen shot 2016-04-19 at 10 30 14 pm" src="https://cloud.githubusercontent.com/assets/1437282/14664280/52c765dc-067e-11e6-826f-94caef9c1be8.png">

Having issue here :(

Anyone know what's happening?
 @georgeportillo That's the exact same issue I have right now. I am using Xcode7.2.1 Swift 2.1 
21 issues
 @georgeportillo My guess was right, but it took me a while to find out.
**Version 3.3.1 requires Swift 2.2** [https://github.com/Alamofire/Alamofire/issues/1169](url)
 @georgeportillo I got the same the same list of 21 errors. Here's what I did to get rid of the errors.
- In the Podfile, I changed the Alamofire version to 2.0.2 (earlier I had installed 3.3.1)  
       `pod 'Alamofire', '2.0.2'`
- Re-installed this version of Alamofire by running  `pod install`  on the terminal
- Then, built the project **without** adding `import Alamofire` as mentioned in  [#122](https://github.com/Alamofire/Alamofire/issues/122). The project built successfully.  Then rebuilt after importing Alamofire.
  Before building I also made sure that the deployment target is 8.0 (as was mentioned in my Podfile).
 I tried this and it didn't work for me. The 21 errors are gone but I still
get No such Module 'Alamofire'.

David Decker
weatherUSA, LLC
Meteorologist M.S./ Developer
Columbus, OH 43228
Cell: 419-680-3598

On Fri, Apr 22, 2016 at 12:29 PM, atulsha notifications@github.com wrote:

> @georgeportillo https://github.com/georgeportillo I got the same the
> same list of 21 errors. Here's what I did to get rid of the errors.
> - In the Podfile, I changed the Alamofire version to 2.0.2 (earlier I
>   had installed 3.3.1)
>   pod 'Alamofire', '2.0.2'
> - Re-installed this version of Alamofire by running pod install on the
>   terminal
> - Then, built the project _without_ adding import Alamofire as
>   mentioned in #122 https://github.com/Alamofire/Alamofire/issues/122.
>   The project built successfully. Then rebuilt after importing Alamofire.
>   Before building I also made sure that the deployment target is 8.0 (as was
>   mentioned in my Podfile).
> 
> ‚Äî
> You are receiving this because you commented.
> Reply to this email directly or view it on GitHub
> https://github.com/Alamofire/Alamofire/issues/441#issuecomment-213499587
 Now I am getting the same problem but with SwiftyJSON. Alamofire issue was
fixed.

David Decker
weatherUSA, LLC
Meteorologist M.S./ Developer
Columbus, OH 43228
Cell: 419-680-3598

On Fri, Apr 22, 2016 at 2:06 PM, Jon Shier notifications@github.com wrote:

> @atulsha https://github.com/atulsha That is not a valid solution to
> this problem. Using an older, unsupported version of Alamofire is not a
> good idea. Alamofire 3.3 requires Xcode 7.3. @deck2osuab
> https://github.com/deck2osuab Try a cleaning your build environment
> after updating Alamofire and Xcode to the latest versions.
> 
> ‚Äî
> You are receiving this because you were mentioned.
> Reply to this email directly or view it on GitHub
> https://github.com/Alamofire/Alamofire/issues/441#issuecomment-213533711
 i can import 3.3.1 but not 3.4 
 i faced that issue, and i solved it by manually add the alamofire framework into to project
 i get this issue today. No way to use this framwork on my project?
 adding my team worked for me!
 Encounter the same error. The answer is simple.Before you import Alamofire into the module,cmd +R the app.Plus,when you are not sure what the version of Alamofire is, just write: pod 'Alamofire' in the podfile,without the version number, and the cocoapod will know it is the newest version.
 Same issue for me with AF 3.1.0 and XCode 8
 Same issue: 
Xcode 8.1 (8B62)
Cocoapods: 1.1.1
 It successfully solved my issue by following the instructions at
http://stackoverflow.com/a/40360050/1804274
 I didn't reinstall the pod but just running the app with the error on import, no other calls to alamofire. It run and removed the error: Cannot load underlying module for 'Alamofire'
  Hi, 

I get Symbol not found after indexing when using Alamofire on Xcode 6.3. I've installed it through cocoa pods. Could someone point me in the right direction? Is this a bug with Alamofire or with the way I've installed?
 This is what happens. There is no crash log at this stage

![screen shot 2015-04-21 at 11 25 35 am](https://cloud.githubusercontent.com/assets/5417284/7245186/68e373c6-e819-11e4-998f-bb08ce803b56.png)
![screen shot 2015-04-21 at 11 27 00 am](https://cloud.githubusercontent.com/assets/5417284/7245188/693432ca-e819-11e4-9b1a-8277976a9908.png)
  Hi, I have integrated the latest framework of Alamofire in my app. But now I am getting this error when I try to run my app on my iPhone. I searched a lot over the Internet but I didn't find the solution! Please help! Thanks!

-------   Warning: usage of --preserve-metadata with option "resource-rules" (deprecated in Mac OS X >= 10.10)! 17467AD3C396A302B30E4278587814C64080AE93: no identity found ----------

@mattt Please see!
 This is not a support forum. Please open a question on [StackOverflow](http://stackoverflow.com) and tag `Alamofire`. Also, please add more information about your project such as whether it is iOS or Mac OS X, deployment target, how you added Alamofire to your project, etc.
  Hi. Alamofire is very convenient. I'm always grateful.
But, alamofire of swift1.2's compatible version is Japanese xml response garbled.

I'm using this code.

<pre>
        request.HTTPMethod = "POST"
        request.setValue("text/xml", forHTTPHeaderField: "Content-Type")
        request.HTTPBody = xml.dataUsingEncoding(NSUTF8StringEncoding)
        let manager = Alamofire.Manager.sharedInstance
        manager.request(request)
            .responseString{ (request, response, string, error) in
                self.delegate.apiPostingDidFinished(string!,method: method)
        }</pre>

response is not garbled in the following cases.

<pre>    
    Connection = "keep-alive";
    "Content-Length" = 42132;
    "Content-Type" = "text/xml; charset=UTF-8";
    Date = "Sun, 12 Apr 2015 22:54:28 +0000";
    Server = nginx;
    "X-Powered-By" = "PHP/5.3.3";</pre>

response is garbled in the following cases.

<pre>
    Connection = "keep-alive";
    "Content-Length" = 299;
    "Content-Type" = "text/xml";
    Date = "Sun, 12 Apr 2015 23:00:37 GMT";
    SOAPServer = "SOAP::Lite/Perl/0.714";
    Server = nginx;</pre>

Probably think that there is cause to Content-type,the 1434 lines of Alamofire.swift, I was fixed to tentatively code such as the following.

<pre>
    public func responseString(encoding: NSStringEncoding? = nil, completionHandler: (NSURLRequest, NSHTTPURLResponse?, String?, NSError?) -> Void) -> Self  {
        return response(serializer: Request.stringResponseSerializer(encoding: NSUTF8StringEncoding), completionHandler: { request, response, string, error in
            completionHandler(request, response, string as? String, error)
        })
    }
</pre>


Garbled is gone.

if the encoding methods have changed, Can you please tell me how to use?
  I think something wrong with the update.

![screen shot 2015-04-12 at 4 59 28 pm](https://cloud.githubusercontent.com/assets/5416242/7104996/b4cab618-e135-11e4-99ab-14f30d4388e5.png)
 This is not a support forum.

You should open a question on [StackOverflow](http://stackoverflow.com) and tag `Alamofire`. Please open a question with more details so someone can help you better troubleshoot your problem.

---

For anyone else out there having issues, please troubleshoot on your own before opening a issue. Below is a walkthrough of adding the Alamofire 1.2.0 pod to an iOS app built with Xcode 6.3 strictly by following the directions in the [README](https://github.com/Alamofire/Alamofire#cocoapods).

**Podfile**

``` ruby
source 'https://github.com/CocoaPods/Specs.git'
platform :ios, '8.0'
use_frameworks!

pod 'Alamofire', '~> 1.2'
```

**ViewController.swift**

``` swift
import Alamofire
import UIKit

class ViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()

        Alamofire.request(.GET, "http://httpbin.org/get", parameters: ["foo": "bar"])
            .response { (request, response, data, error) in
                println(request)
                println(response)
                println(error)
        }
    }
}
```

**Build Log**

![build log](https://cloud.githubusercontent.com/assets/169110/7106437/b2e4a3e4-e0f5-11e4-88a9-083e9abbbf9a.png)

**Xcode Output**

```
<NSMutableURLRequest: 0x7fe20842a2e0> { URL: http://httpbin.org/get?foo=bar }
Optional(<NSHTTPURLResponse: 0x7fe208b10240> { URL: http://httpbin.org/get?foo=bar } { status code: 200, headers {
    "Access-Control-Allow-Credentials" = true;
    "Access-Control-Allow-Origin" = "*";
    Connection = "keep-alive";
    "Content-Length" = 410;
    "Content-Type" = "application/json";
    Date = "Sun, 12 Apr 2015 16:19:06 GMT";
    Server = nginx;
} })
nil
```

---

Everything works as expected.
  (minor)
 thanks!
  a lot of "as" should instead of "as!"
 Yesterday Alamofire 1.2.0 was released on the `master` branch that fully supports Xcode 6.3 and Swift 1.2. If you switch over to the Xcode 6.3 GM and update to the 1.2.0 release of Alamofire you should be good to go. Definitely make sure to "Clean All".
  I just try 1.2,  it ok,    hope to available on cocoaPods soon, thanks
  Hi, I just upgraded to Xcode 6.3 and swift 1.2, and am in the process of converting my code to the latest swift syntax. Since my project need to support iOS7, earlier I wrapped the source file of `Alamofire.swift` in a public struct as some people suggested, which works out fine. However, this approach doesn't apply to the latest version anymore, with lots of `extension` and `public protocol` declarations used, the compiler shoots out error "Declaration is only valid at file scope".

Any suggestion about how to use the copy-and-paste source files in XCode 6.3?
 @mattt Thank you very much :)
  About 20 or so Compile errors when compiling with the newest version of Xcode 6.3
 Was actually just about to close this, a quick clean fixed it all up. Thanks for the quick response :+1: 
  These are the tests I wrote for #314 and #350, which were resolved with the merging of #317. These tests cover some of the new HTTP redirect behavior.
 Tests pass locally, but Travis is not yet on Swift 1.2 :chart_with_downwards_trend: 
  Using imerge I have merged `master` with `xcode-6.3`. I have also cherry-picked (though without attribution, as it was not possible during the imerge process) @cnoon's https://github.com/Alamofire/Alamofire/pull/408, and I'm indebted to his clear pull request for helping me understand the problem. 

This PR obviously drops Swift 1.1 support.
 @mattt Thank _you_ for Alamofire!
  In my pod file I have:
  use_frameworks!(true)
  pod 'Alamofire', '1.1.5'
get this error from pod install
[!] Unable to satisfy the following requirements:
- `Alamofire (= 1.1.5)` required by `Podfile`

Change it to 1.1.4 working fine
 Try remove Alamofire from your `Podfile` and run `pod install` then add the `pod 'Alamofire', '1.1.5'` back.
 Same behavior after remove and add back. I have pod 0.36.3
 It doesn't look like the `1.1.5` podspec was ever pushed up to the spec repo. I just ran a `pod repo update` followed by a `pod search Alamofire` which generated the following:

```
cnoon:~$ pod search Alamofire


-> Alamofire (1.1.4)
   Elegant HTTP Networking in Swift
   pod 'Alamofire', '~> 1.1.4'
   - Homepage: https://github.com/Alamofire/Alamofire
   - Source:   https://github.com/Alamofire/Alamofire.git
   - Versions: 1.1.4, 1.1.3 [master repo]
```

@mattt, could you confirm? I realize you are working on what I would assume is `1.1.6` at the moment, but do you think you could also push a podspec for `1.1.5` as well for those out there that may still need it?
 I do.
 I am able to `pod spec lint` a `1.1.5` release no problem. I don't think I can actually push it up though without being added to the CocoaPods list for Alamofire if I remember correctly.

```
cnoon:~/Desktop$ pod spec lint Alamofire.podspec

 -> Alamofire (1.1.5)

Analyzed 1 podspec.

Alamofire.podspec passed validation.
```
 christian.noon@gmail.com
 All pushed, looking good. üëç

```
cnoon:~/Desktop$ pod search Alamofire


-> Alamofire (1.2.0)
   Elegant HTTP Networking in Swift
   pod 'Alamofire', '~> 1.2.0'
   - Homepage: https://github.com/Alamofire/Alamofire
   - Source:   https://github.com/Alamofire/Alamofire.git
   - Versions: 1.2.0, 1.1.5, 1.1.4, 1.1.3 [master repo]
```

Looks like you beat me to the punch with `1.2.0`!
 @mattt I still only find 1.1.4    Is there something wrong?
my pod version is 0.36.3

onetaway$ pod search Alamofire

-> Alamofire (1.1.4)
   Elegant HTTP Networking in Swift
   pod 'Alamofire', '~> 1.1.4'
- Homepage: https://github.com/Alamofire/Alamofire
- Source:   https://github.com/Alamofire/Alamofire.git
- Versions: 1.1.4, 1.1.3 [master repo]
   Alamofire stopped working after i updated to swift 1.2
 Pull the xcode-6.3 branch for 1.2 language support. Also, I have found it only works running on a device; no simulators but that's easy to deal with.
 +1, probably time to merge the xcode-6.3 branch. https://github.com/Alamofire/Alamofire/tree/xcode-6.3
 I can build and run and archive. Submitting to app store causes invalid info.plist value. The value for the key minimumosversion in bundle guider.app. The minimum value is 8.0.
 Propably submitting is because this has been fixed only on master https://github.com/Alamofire/Alamofire/pull/400 and I'm using the Xcode 6.3 branch.
 +1 on merging 6.3 into Master. It's out of beta now
 Thanks @mattt! 
 wow that was quick! thanks @mattt !!!!
 Thanksss!
  This is a proposed fix for issue #419.
 Good catch @natecook1000! These changes all look good.
  The call to `fulfill()` on an `XCTestExpectation` instance needs to happen after all the `XCT`-assertions in an asynchronous block have been evaluated. The call to `waitForExpectationsWithTimeout` suspends the run loop until the all the expectations have been fulfilled, then immediately continues with the testing process. On the final test of the testing run, this can skip any assertions that come after the last call to `fulfill()` as the run loop exits after the final test.

You can test this by adding an `XCTFail` in the last test method of the the last test class: `UploadResponseTestCase.testUploadRequestWithProgress`:

```
func testUploadRequestWithProgress() {
    let URL = "http://httpbin.org/post"
    let data = "Lorem ipsum dolor sit amet".dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)

    let expectation = expectationWithDescription(URL)

    let upload = Alamofire.upload(.POST, URL, data!)
    upload.progress { (bytesWritten, totalBytesWritten, totalBytesExpectedToWrite) -> Void in
        expectation.fulfill()

        XCTAssert(bytesWritten > 0, "bytesWritten should be > 0")
        XCTAssert(totalBytesWritten > 0, "totalBytesWritten should be > 0")
        XCTAssert(totalBytesExpectedToWrite > 0, "totalBytesExpectedToWrite should be > 0")

        upload.cancel()

        XCTFail("Missed test")
    }

    waitForExpectationsWithTimeout(10) { (error) in
        XCTAssertNil(error, "\(error)")
    }
}
```

The "Missed test" call will never be executed, and the test will either complete reporting success or end in a SIGABRT crash.
  ...or
 Thanks for your PR @kiancheong.

These changes have made their way into the master branch as part of the `1.2.0` release. The `responseString` change was actually fixed inside Alamofire itself. Thanks again and feel free to close this out whenever you get a chance.
  Hi, as I can see, you are carefully fill tags in your repo.

For such cases I create a [github_changelog_generator](https://github.com/skywinder/github-changelog-generator), that generate change log file based on **tags**, **issues** and merged **pull requests** from :octocat: Issue Tracker.

This PR add change log file to your repo (generated by this script).
You can check, how it is look like here: [Change Log](https://github.com/skywinder/Alamofire/blob/add-change-log-file/CHANGELOG.md)

Some essential features, that has this script:
-  it **exclude** not-related to changelog issues (any issue, that has label `question` `duplicate` `invalid` `wontfix` )
- Distinguish issues **according labels**:
  - Merged pull requests (all `merged` pull-requests)
  - Bug fixes (by label `bug` in issue)
  - Enhancements (by label `enhancement` in issue)
  -   Issues (closed issues `w/o any labels`)
- Generate neat Change Log file according basic [change log guidelines](http://keepachangelog.com).

You can easily update this file in future by simply run script: `github_changelog_generator Alamofire/Alamofire` in your repo folder and it make your Change Log file up-to-date again!

Hope you find this commit as useful. :wink:
 Thanks! Let me know, if you have any suggestions, how to improve it!
 Very nice format. Of course it much better, than auto-changed log! Great work! :+1: 

bdw: I'm going to add feature like partial updates https://github.com/skywinder/github-changelog-generator/issues/209 probably then you can use this tool to generate a nice stub for new releases.  :beers: 
  Fixes the issue described in https://github.com/Alamofire/Alamofire/pull/412, but with the appropriate casing of Alamofire.

The lowercase f is not to be confused with the [medial s](http://en.wikipedia.org/wiki/Long_s).
 Looks like https://github.com/Alamofire/Alamofire/pull/415 might fix the failing test.
  I just wanted to say thanks, Matt. This is a well done library. I like the NSURLConvertible, it's a nice touch. A pleasure to use!
  This doesn't fix the failing test. It just fixes an unrelated typo I noticed while trying to fix it.
  This sentence in the README is missing a subject and active verb:

> _Since there is no published specification for how to encode collection types, the convention of appending `[]` to the key for array values (`foo[]=1&foo[]=2`), and appending the key surrounded by square brackets for nested dictionary values (`foo[bar]=baz`)._

This PR resolves it by inserting "_AlamoFire follows_ the convention of appending‚Ä¶"

Alternatively, this sentence might be made more readable by splitting it into two sentences:

> _There is no published specification for how to encode collection types. AlamoFire follows the convention of appending `[]` to the key for array values (`foo[]=1&foo[]=2`), and appending the key surrounded by square brackets for nested dictionary values (`foo[bar]=baz`)._
 I'm not sure why the `DownloadTests` test is failing (both here and in https://github.com/Alamofire/Alamofire/pull/413). `lastPathComponent` is defined as `String?` in the headers included with the latest versions of both Xcode 6.2 and 6.3.
 Oh, looks like it might be because Travis-CI is [still using Xcode 6.1](https://github.com/travis-ci/travis-ci/issues/3373). They might be able to upgrade this project if you email support@travis-ci.com.
 @mattt Maybe if [the logo](https://raw.githubusercontent.com/Alamofire/Alamofire/assets/alamofire.png) were in the correct case that would help. But to be honest the casing is unintuitive since [the flower](https://aggie-horticulture.tamu.edu/wildseed/alamofire.html) is two separate words and class names are normally CamelCase.
  There are some API that allow to use request body for HTTP DELETE.
( e.g. http://www.elastic.co/guide/en/elasticsearch/reference/current/docs-delete-by-query.html )

if you support this, I'm glad allow to use request parameter and request body at the same time.

if it is already implemented, please tell me.:smile:
 It's not unsupported, it just has no defined rules. An implementation may define semantics on top of HTTP such as in the case of this API.

From RFC 7231:

> A payload within a DELETE request message has no defined semantics;
> sending a payload body on a DELETE request might cause some existing
> implementations to reject the request.
 So how can I construct a request (via Alamofire) which let me to send body for DELETE http requests?  üòû   cannot convert to the toJSONArray Return type in [[String:AnyObject]] and to convert the [String:AnyObject]
 I would suggest you open a question on [StackOverflow](http://stackoverflow.com) and tag `Alamofire`. There is a good community of people answering Alamofire questions there at the moment. This project does not use Github as a support forum. Once you move your question there, if you could close this issue we'd appreciate it.

Additionally, when you ask a question, you will want to provide more detail so the community can better understand your problem to provide you a higher level of support.
  Hey @mattt,

This is a bit of a strange pull request, but unfortunately, a necessary one. There are two different approaches to solving the problem, and this PR contains the one that I think is a more sensible solution.
### Problem

The surface issue that users are reporting is that trailing closures are broken for the `responseString` serializer (as seen in #406 and this StackOverflow [thread](http://stackoverflow.com/questions/28542575/alamofire-with-swift-1-2-ambiguous-use-of-responsejson/28552008#28552008)). The root problem is that there is ambiguity in the `responseString` and `responsePropertyList` convenience method implementations that collide with the actual `responseString` and `responsePropertyList` implementations with default parameters. I always wondered how Swift 1.1 was able to avoid infinitely recursing into itself in those methods and the Swift 1.2 compiler has actually tightened down on the ambiguity altogether.
### Option 1

The first option is to remove the convenience methods entirely. This removes the ambiguity and leverages default parameters that are an awesome new feature with Swift. I prefer this approach to avoid having multiple versions of the same API simply for convenience. A single API with default parameters seems more concise to me and makes the intent and behavior of the method very clear. The downside is that autocomplete doesn't pick up the fact that some of the parameters have default values...yet. I will be filing a radar against this shortly.
### Option 2

Remove the default values for the `responseString` : `encoding` parameter and the `responsePropertyList` : `options` parameter. This would also remove the ambiguity, but would no longer leverage Swift's default parameter values functionality. IMO, having two functions is more of the Objective-C way of doing things. The upside is that it makes autocomplete a bit easier. The downside is that you require multiple APIs to do exactly the same thing which requires more documentation. The default values will appear in the docs, but unfortunately not in the autocompletion highlighting.

---

I think either option is valid, but tend to lean towards Option 1. If you prefer Option 2, then just let me know and I can update the PR accordingly. I also wonder if we shouldn't cherry pick this change into the `master` branch as well. That would get the ambiguity removed from Alamofire altogether.
  I'm having problems with the way Alamofire is using NSProgress.  I'm using NSProgress to track the progress of a sync process  (downloading JSON from a server and turning it into model objects).  I've added NSProgress support to the classes that are building the objects, and everything seems to be reporting the percentage completed correctly, but the instance of NSProgress created in the initializer for TaskDelegate never has its totalUnitCount changed from 0.  So when my sync is complete I still have a child progress (the one created by Alamofire) with a fraction completed of 0.  This throws off the fraction completed of the parent progress that I'm observing - i.e. when my sync is done, the fraction completed is .75 because the progress in TaskDelegate is still sitting at 0.

The progress' totalUnitCount and completedUnitCount are only updated in `URLSession(session: NSURLSession!, downloadTask: NSURLSessionDownloadTask!, didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64)` and `URLSession(session: NSURLSession!, downloadTask: NSURLSessionDownloadTask!, didResumeAtOffset fileOffset: Int64, expectedTotalBytes: Int64)` but the task for my operation is a DataTask, not a DownloadTask.

It seems like either the DataTask should also be updating the total and completed unit counts, or the progress should only be instantiated if the task is a DownloadTask - but there could be something I'm missing.
 @cnoon Is there any test coverage around this change? Seems like something that would be easy to verify?
  The delegate.progress always has value so I don't see any point that Request.progress property to be Optional type. Please consider on removing Optional type from it.
 Note: All of tests passed on my machine. Looks like CI test failed due to network issues.
 :smile: :+1: 
  Accessing raw `NSURLSession` & `NSURLSessionTask` objects outside of the framework should be prohibited (e.g. calling `session.invalidateAndCancel()`), so I marked those properties with `private` modifier. These objects's functionality should always be accessed via `Manager` & `Request`'s methods.
 While I'm generally all for keeping things as locked down as possible, I'm not a fan of this proposed change. To me, you need to make a much better case as to why these should be made private at all.

There are many use cases where having these publicly available is absolutely necessary. Here are just a few I can think of off the top of my head.
- Using the `NSURLSessionTask` `taskIdentifier` to identify `Request` objects
- Tracking the state of an `NSURLSessionTask` (granted you did consider this case)
- Manually querying the `NSURLSession` to see how many active requests are running and what types of tasks they are (necessary for background sessions)
- Needing to `finishTasksAndInvalidate` or `invalidateAndCancel` for whatever reason

There are WAY to many APIs that would need to be exposed from the `Manager` and `Request` classes to cover all these cases. IMO, the public scope is the proper ACL.
 @mattt @cnoon
All right, it seems full encapsulation of `NSURLSession` is not a good choice.
Thanks for reply.
  Setting the iOS deployment target to iOS 7.0 causes warnings all over this project and all other projects that include it. While I understand that Alamofire can be used in iOS 7.0 projects by dragging the `Alamofire.swift` file into the project, the iOS deployment target inside the Xcode project is ignored in those cases.

![embedded framework warning](https://cloud.githubusercontent.com/assets/169110/6831673/098d3fd2-d2df-11e4-8a2f-890fd2c7fcd3.png)

In all cases where the Xcode project is actually being used (Alamofire Xcode project, git submodules for other apps and libraries and Carthage) the warning is actually being thrown. The Xcode project deployment target should be updated to iOS 8.0 to allow all these Xcode project use cases to no longer see the warning which will not affect the actual iOS 7.0 use case.

Hopefully that all makes sense.
  In order to properly support Carthage and CocoaPods at the same time with cross-platform targets, the code signing identities need to be modified a bit to make sure everyone can build Alamofire using Carthage. Thankfully, CocoaPods handles all this independently.

To properly support Carthage, iOS targets and tests need to code sign as `iPhone Developer`. This is due to the fact that Xcode _requires_ them to be code signed. Mac OS X targets and tests are different altogether. They don't require code signing at all. Therefore, it should be disabled to allow users without a Mac Developer account to build Alamofire on OS X and run the tests as well as those without an `iPhone Developer` account who are simply trying to build Alamofire through Carthage. All frameworks will get resigned anyways when embedded within a final app target.

This will make creating cross-platform libraries ontop of Alamofire much easier for all those involved. You can find more information [here](https://github.com/Carthage/Carthage/issues/399) and [here](https://github.com/Carthage/Carthage/issues/281).
 Will do @mattt.
 Looks good @mattt. All the tests are passing on both targets on `1.1.5` and the Carthage builds are all good as well.

```
cnoon:~/Desktop/AlamofireCarthage$ carthage update
*** Fetching Alamofire
*** Checking out Alamofire at "1.1.5"
*** xcodebuild output can be found in /var/folders/mc/9x8d6r415qxgyxry1y8vm9h0jj7n1m/T/carthage-xcodebuild.9jtd3m.log
*** Building scheme "Alamofire iOS" in Alamofire.xcworkspace
*** Building scheme "Alamofire OSX" in Alamofire.xcworkspace
```

Thanks as always!
  I have an issue where the basic authentication is not working, in Playground I have this:

```
request(.GET, "http://httpbin.org/basic-auth/myusername/mypassword")
    .authenticate(user: "myusername", password: "mypassword")
    .validate(statusCode: 200..<300)
    .responseJSON { (req, res, json, error) in

    if(error != nil) {
        NSLog("Error: \(error)")
        println(req)
        println(res)
    }
    else {
        NSLog("Success")
        println(json)
    }
```

}

The resulting wireshark sniff shows that the service was called twice:
![screen shot 2015-03-25 at 15 34 51](https://cloud.githubusercontent.com/assets/5913559/6826876/8babd0ee-d304-11e4-995a-486700e880a5.png)

Inspecting the header reveals that 'Authorisation: Basic ...' is not included in the first call. I am having problems calling my own services, where the authorisation is not used either - and perhaps this is related. My service is only called once.

![screen shot 2015-03-25 at 15 39 42](https://cloud.githubusercontent.com/assets/5913559/6827008/586a5d30-d305-11e4-9ac8-dda42301d022.png)
 This is not a support forum. Please open a question on [StackOverflow](http://stackoverflow.com) and tag `Alamofire`. If you could then close out this issue, it would be appreciated.
 Thank you, and sorry. I did not know that this was the intended behaviour.
  The execution on "git submodule add https://github.com/Alamofire/Alamofire.git" comes an error of "Not a git repository (or any of the parent directories): .git"
 it's because the folder you're in must me a git repository.
If ti's not a git repository, you cannot obviously add a git submodule
Maybe try "git status" first‚Ä¶
 This is not a support forum. Please open a question on [StackOverflow](http://stackoverflow.com) and tag `Alamofire`. If you could then close out this issue, it would be appreciated.
  This is a minor this, but it's been really bugging me. Is there a way this warning can be silenced on iOS 8+ builds using Alamofire as a framework?

If you use it in iOS 7, you won't be using the framework anyway to build the project, so does this really need to be set to min of iOS 7?

It is possible it is a CocoaPods or a Carthage thing, in which case I understand, but it's still really annoying and making all my CI builds very ugly. :)
 Ah that's a shame, but sadly what I thought. Will look into `sed`. Thanks.
  I want to upload some file to a server, but it needs a token to post with the file together. I got the token when I logged in, so how could I post to the server? Can I write code like this?

``` swift
var par=[
               "token":"xxxxxxxxxx",
               "file":"filename.file"
]
Alamofire.upload(.POST, "http://www.xxxxx.xxx", parameters: par)
```

Thanks in advanced
 This is not a support forum. You should post these types of questions on [StackOverflow](http://stackoverflow.com) and tag `Alamofire`.
 @cnoon  So could you help me with this ? http://stackoverflow.com/questions/29224596/how-to-upload-a-picture-or-a-wav-file-with-some-parameters-using-alamofire-uploa
 Sure! Could you please close this issue out when you get a chance?
  For `NSURLAuthenticationMethodServerTrust` authentication method, stop indiscriminately trusting all SecTrusts. Instead, rely on default behavior -- which will do basic evaluation of the certificate chain against the System's CA Root Certificates.

Alamofire will presumably want to implement custom SSL certificate pinning and the ability to turn invalid certificates, but IMO this is _much_ better default behavior.
 Shouldn't this weakness be noted in the Changelog? Users have no way to know they are using a version that is vulnerable to MiTM attacks.
  dispatch_sync(queue) when obtaining a data task to guarantee task id uniqueness, but not upload/download.
Why not?
  Is there any best-practice how to use Alamofire with Watchkit to make simple HTTP requests? 
  I encountered a crash when trying to create a Alamfire request where the URL contained an unintentional whitespace. Here's a sample test case to reproduce.

```
func testRequestMethodWithWhitespaceInsideURLString() {
    let URL = "http://httpbin.org/ get"
    let request = Alamofire.request(.POST, URL)

    XCTAssertNotNil(request, "request should not be nil")
    XCTAssertEqual(request.request.URLString, "http://httpbin.org/ get", "request URL should be equal")
}
```

As this clearly is my fault i'm not sure if this is a bug but instead of crashing we could maybe recover more gracefullly or strip whitespaces when handling strings
 Alright, but what about asserting it does not contain any whitepaces to make the failure reason a little more obvious? 
 I see. Thanks for clearing that up.
  `APPLICATION_EXTENSION_API_ONLY` got left out on the OS X target. And since the README specifies OS X 10.9+, I figured the target should agree.
 Well hey, so long as the right setting gets set I'm happy!
  The API we are trying to contact will only work for some content types, so we need to change the content-type http header to one of the accepted (e.g.: application/json).

As stated in the documentation (https://github.com/Alamofire/Alamofire#urlrequestconvertible), the best way (and the recommended one) is using a URLRequestConvertible, like:

```
let URL = NSURL(string: "http://httpbin.org/post")!
let mutableURLRequest = NSMutableURLRequest(URL: URL)
mutableURLRequest.HTTPMethod = "POST"

let parameters = ["foo": "bar"]
var JSONSerializationError: NSError? = nil
mutableURLRequest.HTTPBody = NSJSONSerialization.dataWithJSONObject(parameters, options: nil, error: &JSONSerializationError)
mutableURLRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")

Alamofire.request(mutableURLRequest)
```

So, taking into account the changes in the namespace, our code looks almost exactly the same:

```

    //
    // Basic generic function that launches requests using AlamoFire
    //
    func placeRequest(method: Method, url: String, params: [String: AnyObject]? = nil) {

        let reachability = Reachability.reachabilityForInternetConnection()
        if reachability.isReachable() {


            let URL = NSURL(string: url)!
            let mutableURLRequest = NSMutableURLRequest(URL: URL)
            mutableURLRequest.HTTPMethod = "POST"

            let parameters = ["foo": "bar"]
            var JSONSerializationError: NSError? = nil
            mutableURLRequest.HTTPBody = NSJSONSerialization.dataWithJSONObject(parameters, options: nil, error: &JSONSerializationError)
            mutableURLRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")

            request(mutableURLRequest)


        } else {
            println("Not reachable")
        }


    }
```

It only adds reachability test (shoudn't affect). According to the documentation this should work, but the request being sent is:

![screen shot 2015-03-20 at 4 39 35 pm](https://cloud.githubusercontent.com/assets/240085/6754914/f4116d12-cf1f-11e4-87f9-281579af8cc9.png)

As you can see (if you are able to ignore my great painting skills), the content type IS NOT the one specified for the request, but text/plain.

Where is the custom http header content lost? Why is Alamofire ignoring the explicit value set for this header?

If we use the URL encoding instead of the JSON one, we DO GET the right content type (application/json), but all the http body is screwed (as it's modified to work with URL methods, in get http calls).

Any kind of help here? We are kind of lost and are not sure is this is an error on our end, or a bug on the library, as not many people is complaining or reporting the error, but probably they are using this headers...
 You are 100% right, sorry about that. I'll debug a little bit more and I keep on having troubles, I'll take this to SO.

(pd: thanks for the lightning response)
  I've added the Xcode6.3Beta version of AlamoFire to my podfile. 

Whenever I do

```
  pod update 
```

I get this error 

```
  Permission denied (publickey).
  fatal: Could not read from remote repository.
```
 My mistake! I'm sorry
  I built Alamofire on OS X 10.9 (by changing the deployment target to 10.9 for the framework and the test) and then launched the tests. Here is the end of the test log:

```
**** Begin output from test process:
Test Suite 'AlamofireJSONParameterEncodingTestCase' started at 2015-03-14 21:02:49 +0000
Test Case '-[Alamofire_OSX_Tests.AlamofireJSONParameterEncodingTestCase testJSONParameterEncodeComplexParameters]' started.
2015-03-14 14:02:49.675 xctest[1017:3003] Property list invalid for format: 100 (property lists cannot contain NULL)
2015-03-14 14:02:49.675 xctest[1017:5f03] *** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'API violation - multiple calls made to -[XCTestExpectation fulfill].'
*** First throw call stack:
(
    0   CoreFoundation                      0x00007fff8d6f125c __exceptionPreprocess + 172
    1   libobjc.A.dylib                     0x00007fff8629be75 objc_exception_throw + 43
    2   CoreFoundation                      0x00007fff8d6f1038 +[NSException raise:format:arguments:] + 104
    3   Foundation                          0x00007fff8a89c361 -[NSAssertionHandler handleFailureInMethod:object:file:lineNumber:description:] + 189
    4   XCTest                              0x0000000100798ac0 -[XCTestExpectation fulfill] + 141
    5   Alamofire OSX Tests                 0x0000000102eb6d42 _TFFC19Alamofire_OSX_Tests33AlamofireDownloadResponseTestCase31testDownloadRequestWithProgressFS0_FT_T_U_FTVSs5Int64S1_S1__T_ + 306
    6   Alamofire OSX Tests                 0x0000000102eb0f43 **** End output from test process

2015-03-14 14:02:49.680 _XCT_testSuite:AlamofireDownloadResponseTestCase didFinishAt:2015-03-14 21:02:49 +0000 runCount:2 withFailures:0 unexpected:0 testDuration:0.5856499671936035 totalDuration:0.5891770124435425
2015-03-14 14:02:49.681 _XCT_testSuite:AlamofireJSONParameterEncodingTestCase didStartAt:2015-03-14 21:02:49 +0000

**** Begin output from test process:
_TTRXFo_dVSs5Int64dS_dS__dT__XFo_iTS_S_S___iT__ + 51
    7   Alamofire OSX Tests                 0x0000000102eb29c1 _TPA__TTRXFo_dVSs5Int64dS_dS__dT__XFo_iTS_S_S___iT__ + 81
    8   Alamofire                           0x0000000102fabde3 _TTRXFo_iTVSs5Int64S_S___iT__XFo_dS_dS_dS__dT__ + 35
    9   Alamofire                           0x0000000102f931a9 _TFCC9Alamofire7Request20DownloadTaskDelegate10URLSessionfS1_FTGSQCSo12NSURLSession_12downloadTaskGSQCSo24NSURLSessionDownloadTask_12didWriteDataVSs5Int6417totalBytesWrittenS4_25totalBytesExpectedToWriteS4__T_ + 1129
    10  Alamofire                           0x0000000102f7cac7 _TFCC9Alamofire7Manager15SessionDelegate10URLSessionfS1_FTCSo12NSURLSession12downloadTaskCSo24NSURLSessionDownloadTask12didWriteDataVSs5Int6417totalBytesWrittenS4_25totalBytesExpectedToWriteS4__T_ + 1207
    11  Alamofire                           0x0000000102f7cda7 **** End output from test process

2015-03-14 14:02:49.681 _XCT_testCaseDidStartForTestClass:Alamofire_OSX_Tests.AlamofireJSONParameterEncodingTestCase method:testJSONParameterEncodeComplexParameters

**** Begin output from test process:
_TToFCC9Alamofire7Manager15SessionDelegate10URLSessionfS1_FTCSo12NSURLSession12downloadTaskCSo24NSURLSessionDownloadTask12didWriteDataVSs5Int6417totalBytesWrittenS4_25totalBytesExpectedToWriteS4__T_ + 103
    12  CFNetwork                           0x00007fff83d21e4d __99-[__NSCFURLSession delegate_downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:]_block_invoke + 52
    13  Foundation                          0x00007fff8a7cc6d5 -[NSBlockOperation main] + 75
    14  Foundation                          0x00007fff8a7abec1 -[__NSOperationInternal _start:] + 631
    15  Foundation                          0x00007fff8a7abb6b __NSOQSchedule_f + 64
    16  libdispatch.dylib                   0x00007fff8b72628d _dispatch_client_callout + 8
    17  libdispatch.dylib                   0x00007fff8b728673 _dispatch_queue_drain + 451
    18  libdispatch.dylib                   0x00007fff8b7299c1 _dispatch_queue_invoke + 110
    19  libdispatch.dylib                   0x00007fff8b727f87 _dispatch_root_queue_drain + 75
    20  libdispatch.dylib                   0x00007fff8b729177 _dispatch_worker_thread2 + 40
    21  libsystem_pthread.dylib             0x00007fff858a1ef8 _pthread_wqthread + 314
    22  libsystem_pthread.dylib             0x00007fff858a4fb9 start_wqthread + 13
)
libc++abi.dylib: terminating with uncaught exception of type NSException
**** End output from test process

2015-03-14 14:03:20.156 Test operation failure: Test operation was canceled.
2015-03-14 14:03:20.156 _finishWithError:Error Domain=IDEUnitTestsOperationsObserverErrorDomain Code=3 "Test operation was canceled." UserInfo=0x7fbfbe2980e0 {NSLocalizedDescription=Test operation was canceled.} didCancel: 1
```
  https://github.com/carthage/carthage#archive-prebuilt-frameworks-into-one-zip-file
  In readme it says

``` swift
extension Request {
    class func XMLResponseSerializer() -> Serializer {
        return { (request, response, data) in
            if data == nil {
                return (nil, nil)
            }

            var XMLSerializationError: NSError?
            let XML = ONOXMLDocument.XMLDocumentWithData(data, &XMLSerializationError)

            return (XML, XMLSerializationError)
        }
    }

    func responseXMLDocument(completionHandler: (NSURLRequest, NSHTTPURLResponse?, OnoXMLDocument?, NSError?) -> Void) -> Self {
        return response(serializer: Request.XMLResponseSerializer(), completionHandler: { (request, response, XML, error) in
            completionHandler(request, response, XML, error)
        })
    }
}
```

However this code doesn't compile with Xcode 6.2 I made some changes like below but not sure if it is the correct way.

``` swift
extension Request {
    class func XMLResponseSerializer() -> Serializer {
        return { (request, response, data) in
            if data == nil {
                return (nil, nil)
            }

            var XMLSerializationError: NSError?
            let XML = ONOXMLDocument(data: data, error: &XMLSerializationError)

            return (XML, XMLSerializationError)
        }
    }

    func responseXMLDocument(completionHandler: (NSURLRequest, NSHTTPURLResponse?, ONOXMLDocument?, NSError?) -> Void) -> Self {
        return response(serializer: Request.XMLResponseSerializer(), completionHandler: { (request, response, XML, error) in
            completionHandler(request, response, XML as? ONOXMLDocument, error)
        })
    }
}
```
  Fix example for "Manual Parameter Encoding of an NSURLRequest"
  Just release CocoaPods 0.36 GM, it's no longer in beta. It does require `use_frameworks!` in the Podfile.
  This is essentially the same issue that I opened #269 for where `Manager` deinitialization was crashing.
#### Problem

Unfortunately, the test I wrote in that case did not reflect all the potential issues. By removing the deinit that contained the `session.invalidateAndCancel()`, that only ended up masking the root cause of the crash. I managed to unwind it today and get to the root issue.

The problem is that the `TaskDelegate` dispatch queue cannot be properly released when in a suspended state. The libdispatch library will fail under certain race conditions. If you do not actually call `resume` on the task, then the queue will always remain in the suspended state until the time when it is deinitialized. The root problem I believe stems from a mismatch between the `dispatch_resume` and `dispatch_suspend` calls. They need to [balance each other out](https://developer.apple.com/library/prerelease/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html#//apple_ref/c/func/dispatch_resume) and we cannot always guarantee that during deinitialization.
### Option 1 - dispatch_resume in `TaskDelegate.deinit`

There are several ways to approach the problem. The first would be to resume the queue during deinitialization of the `TaskDelegate` to attempt to balance out the suspend and resume calls. The problem with this approach is that you will then shut down the queue while it's in the middle of executing the closures inside it. Also, the potential for corrupting state is very high since Alamofire is designed to only `dispatch_resume` when the request has actually completed. I worked through this approach and it is terribly problematic and doesn't fix the race condition.
### Option 2 - Switch to `NSOperationQueue` for `TaskDelegate`

The solution I landed on was to swap out the `dispatch_queue_t` with an `NSOperationQueue`. This gives us the ability to do the following:
- We can still suspend and resume the queue
- We can still define a serial execution behavior
- We can cancel all the operations (biggest limitation of dispatch_queue_t)
- We can resume after canceling all operations to unsure the `underlyingQueue` is not `suspended`

After swapping out the old queue with the operation queue, everything is working exactly as it should. Manager deinitialization works flawlessly.
#### Added `invalidateAndCancel` back into Manager.deinit

IMO, this is the behavior that should be used rather than `finishTasksAndInvalidate`. If the Manager is attempting to deinitialize, then Alamofire should do everything in its power to make sure that deinitialization happens immediately. That cannot happen if there are current running tasks that will keep the session in memory along with the Manager. This seems very problematic when you consider that you're actually in the middle of terminating the app. You want to avoid having any queues working on closures when the termination actually happens to avoid corrupting state.
#### Summary

The change from a `TaskDelegate` `dispatch_queue_t` to an `NSOperationQueue` absolutely has to happen to fix the race condition crashing. Whether to `invalidateAndCancel` or `finishTasksAndInvalidate` or nothing in the `Manager.deinit` I think needs to input from the community.
  On the xcode-6.3 branch, please see the following code

``` swift
// Grab ourselves a custom manager
let manager = Alamofire.Manager(configuration: configuration)

// WORKS!
Alamofire.upload(Alamofire.Method.POST, "http://localhost:9000/api/data/images/upload", data)     
// DOES NOT WORK!
manager.upload(Alamofire.Method.POST, "http://localhost:9000/api/data/images/upload", data)
```

I get the following error message for the `manager.upload`.. 

> Cannot invoke 'upload' with an argument list of type '(Method, URLStringConvertible, NSData)'
 Thanks!
  I'm having some issues when requesting to an Incapsula server (http://www.incapsula.com)
Incapsula servers check header order and values, to detect bots.

I'm using this:

```
    var defaultHeaders = Manager.sharedInstance.session.configuration.HTTPAdditionalHeaders ?? [:]
    defaultHeaders["Host"] = "www.example.com"
    defaultHeaders["Connection"] = "keep-alive"
    defaultHeaders["Pragma"] = "no-cache"
    defaultHeaders["Cache-Control"] = "no-cache"
    defaultHeaders["Accept"] = "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8"
    defaultHeaders["User-Agent"] = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.76 Safari/537.36"
    defaultHeaders["Accept-Encoding"] = "gzip, deflate, sdch"
    defaultHeaders["Accept-Language"] = "es-419,es;q=0.8,en;q=0.6"

    let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
    configuration.HTTPAdditionalHeaders = defaultHeaders

    let manager = Manager(configuration: configuration)

    let myRequest = manager.request(.GET, "http://www.example.com/index.html")
```

Running debugPrintln(myRequest) I get this:

```
$ curl -i \
-H "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8" \
-H "Pragma: no-cache" \
-H "Connection: keep-alive" \
-H "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.76 Safari/537.36" \
-H "Cache-Control: no-cache" \
-H "Host: www.example.com" \
-H "Accept-Encoding: gzip, deflate, sdch" \
-H "Accept-Language: es-419,es;q=0.8,en;q=0.6" \
"http://www.example.com/index.html"
```

The headers should be in the order I declared them, else, I get detected as a bot and can't get the desired page.

The debugPrintln(myRequest) should be:

```
$ curl -i \
-H "Host: www.example.com" \
-H "Connection: keep-alive" \
-H "Pragma: no-cache" \
-H "Cache-Control: no-cache" \
-H "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8" \
-H "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.76 Safari/537.36" \
-H "Accept-Encoding: gzip, deflate, sdch" \
-H "Accept-Language: es-419,es;q=0.8,en;q=0.6" \
"http://www.example.com/index.html"
```
  With your Podfile example `pod` (0.36.0.rc.1) gets error:

> [!] Pods written in Swift can only be integrated as frameworks; this feature is still in beta. Add `use_frameworks!` to your Podfile or target to opt into using it.

So, you should set additional flag in the beginning if the Podfile.
 @cnoon  Done.
   :+1: 
  I need to make a `POST` request with an HTTP Body with a `JSON` object, but I also need to use url query parameters in the same request.

```
POST: http://www.mysite.com/api/create?param1=value&param2=value
HTTP Body: { foo : [ bar, foo], bar: foo}
```

Is this supported? How would I go about doing this?

Thanks
 I posted this on StackOverflow
http://stackoverflow.com/questions/28908680/multiple-encoding-types-for-alamofire-request

If it's already supported and I just need a usage example, then it should probably be answered there. If this is not a supported feature yet, it seems like something worth discussing implementing here.
 At this point, I've decided to solve this by manually encoding an `NSURLRequest` with the URL parameters, retrieving the URL from that request, and using that to create the final request. I've created a function to return the query parameter encoded request:

```
    private func queryParameterEncodedRequestURL(urlString: String,
    values: [String]) -> NSURL {

      let URL = NSURL(string: urlString)
      var request = NSURLRequest(URL: URL)

      let parameters = [
      "param1": values[0]!,
      "param2": values[1]!
      ]

      let encoding = Alamofire.ParameterEncoding.URL
      (request, _) = encoding.encode(request, parameters: parameters)

      return (request.URL, nil)
    }
```

This works fine, but I would definitely like to see Alamofire support multiple encoding types more easily. This feels like a workaround to me.

@mattt What is your opinion on implementing a native way to handle multiple encodings?
 @mattt I think it's not correct to name it `ParameterEncoding.URL` if it encodes parameters depending on request method.
 @mattt Ok, then `ParameterEncoding` should be only responsible for encoding and not for defining the place where encoded parameters are putted. And for example another `enum ParameterPlacement` could define where parameters could be placed.
Second way is to define `ParameterEncoding.URLQuery` that url-encodes parameters and puts them always in query part of URL.
And the third way is to make `query`, `queryComponents` and `escape` functions public so we do not copy-paste your code in `ParameterEncoding.Custom`.
My application makes POST request to service with url parameter which specify id of resource and JSON body. It's common thing for REST APIs.
 @mattt May be, but solution suggested by @AnthonyMDev and solutions in SO answers look more like workaround not like real and simple solution for this common case. I think that solution should be build in in Alamofire.
By the way who puts url-encoded parameters in request body? Isn't that bad taste?
 @mattt But Alamofire is not web (application) framework, am I right? It's http networking library for mobile applications which in modern world works with APIs designed in right way with JSON bodies and URLs that identifies resource. Url encoded POST request is mostly used for posting html form data. But in mobile applications there are no html web-forms and the only reason to use url-encoded body is compatibility with old web-services.
I still think that there is more flexible and not more complex way to do these things. I'll try to implement it.
 @mattt Totally agree! But why not to support modern web services out of box? That's what developers are expecting from shiny and new Alamofire :)
It would be awesome if there will be the way to define placement of url encoded parameters or separate `ParameterEncoding` for placing parameters always in URL for all request methods.
Sorry for bothering. I just think that this will save much time for other developers.
 I have the same problem I need to send JSON in the body but I need to add parameter in the URL, Does alamofire support this or I need some work around  
 @cesar-oyarzun-m The way I solved this was to create an extension on NSURL for adding query parameters, then I just added the parameters to my URL before creating the `Alamofire Request`

```
extension NSURL {

  func URLByAppendingQueryParameters(parameters: [String: String]?) -> NSURL {
    guard let parameters = parameters,
      urlComponents = NSURLComponents(URL: self, resolvingAgainstBaseURL: true) else {
        return self
    }

    var mutableQueryItems: [NSURLQueryItem] = urlComponents.queryItems ?? []

    mutableQueryItems.appendContentsOf(parameters.map{ NSURLQueryItem(name: $0, value: $1) })

    urlComponents.queryItems = mutableQueryItems

    return urlComponents.URL!
  }

}
```
 His this is my code  I just need to add timeout in the request, the encoding is using the request and the parameters, that is my problem.

```
enum Router: URLRequestConvertible {
case broadcast(String,[String: AnyObject])
var method: Alamofire.Method {
    switch self {
    case .broadcast:
        return .POST
    }
}

var path: String {
    switch self {
        case .broadcast(let timeout):
            return "/api/networks/current/broadcasts?=\(timeout)"
    } 
}

var URLRequest: NSMutableURLRequest {
    let URL = NSURL(string: hostUrl)!
    let mutableURLRequest = NSMutableURLRequest(URL: URL.URLByAppendingPathComponent(path))
    mutableURLRequest.HTTPMethod = method.rawValue
    mutableURLRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")
    mutableURLRequest.setValue("Bearer \(tokenSDK)", forHTTPHeaderField: "Authorization")
    switch self {
        case .broadcast(let timeout,let parameters):
            let reqBroadcast = Alamofire.ParameterEncoding.JSON.encode(mutableURLRequest, parameters: parameters).0
            return reqBroadcast
  default:
            expLogging("EXP Http Request : \(mutableURLRequest)")
            return mutableURLRequest
    }
}
}
```
 Your current code looks like it should work to me. I'm not sure what problem you are having using that. Can you please explain to me what the end result of your current method is, and why that isn't the desired result?
 I still see my request like this 
     `http://localhost:9000/api/networks/current/broadcasts0.000000=2000` 
I hardcode the timeout in the request 

```
var path: String {
switch self {
    case .broadcast(let timeout):
        return "/api/networks/current/broadcasts?=2000"
} 
}
```

Do you have example how to use your code?
 This may be due to the fact that your query parameter has no key. It's might be that somewhere in the parsing of the URL the query isn't recognized because it has no key and the parser is doing something weird.

I've never worked with query parameters that have a value and no key before, but, assuming you are designing the API, you may want to change if so that there is a 'timeout' parameter.

`http://localhost:9000/api/networks/current/broadcasts?timeout=2000`
 sorry my mistake yes I miss the key, I still see the same issue `http://localhost:9000/api/networks/current/broadcasts0.000000timeout=2000`
`PromiseKit: Unhandled Error: Error Domain=com.alamofire.error Code=-6006 "/api/networks/current/broadcasts%3Ftimeout=2000 does not exist" UserInfo={NSLocalizedFailureReason=/api/networks/current/broadcasts%3Ftimeout=2000 does not exist}`

For some reason the encoding is breaking the URL, I think the problem is the line 
    `URL.URLByAppendingPathComponent(path)`
 I fix this with by doing just this 

```
  case .broadcast(let parameters):
            expLogging("EXP Http Request broadcast parameters: \(parameters)")
            let reqBroadcast = Alamofire.ParameterEncoding.JSON.encode(mutableURLRequest, parameters: parameters).0
            reqBroadcast.URL = NSURL(string: reqBroadcast.URLString+"?timeout=2000")
            return reqBroadcast
```
 @AnthonyMDev Have you experience issues with JSON encoding ?, for some reason hasvalues after doing the encoding is transforming the string to different string 
original value `"channel": WwogICJzY2FsYSIsCiAgInRlc3QxIiwKICAwLAogIDEKXQ==,` 
value after JSON encoding `"channel": "WyJzY2FsYSIsInRlc3QxIiwwLDFd"`  
I'm doing this  `Alamofire.ParameterEncoding.JSON.encode(mutableURLRequest, parameters: parameters).0`
 @cesar-oyarzun-m No, I have not. These questions are better suited for StackOverflow. This closed issue is not really the appropriate place for them.
 For future reference, it is worth noting that `ParameterEncoding.URLEncodedInURL` now exists.
 BTW, you can mix URLEncodedInURL with JSON and possibly URLEncoded this way:
`
let rq = Alamofire.ParameterEncoding.URLEncodedInURL.encode(mutableURLRequest, parameters: baseParams).0
return Alamofire.ParameterEncoding.JSON.encode(rq, parameters: ["images": images]).0
`
 Just as input and another opinion on the original discussion between @mattt (who didn't seem to be interested in this feature at all) and @mxl:

The [JSON API](http://jsonapi.org) standard which is self-quotedly "a specification for building APIs in JSON" uses the HTTP body for sending and receiving object data in a special JSON format. It also defines ways to `include` relationships, `sort` by fields or even `filter` by them. These actions MUST (if supported) be sent as "query parameter(s)" ‚Äì or differently put they have to be URL encoded. See the [sorting documentation](http://jsonapi.org/format/#fetching-sorting) as an example.

I'm currently writing an API client for an API which was designed for Apps and complies to JSON API v1.0 ‚Äì one of the future standard formats in JSON APIs. Specifically the API uses [this Rails gem](https://github.com/cerebris/jsonapi-resources) as its implementation. And **neither** the specification **nor** the framework accept the above mentioned actions via Body parameters. So when I want to send data **and** do one of the defined actions at once I have to build the query part of the URL myself. Not only me, everybody who wants to use these features of such APIs in the future will need to.

I can't force anybody to change his opinion. But to me it seems the evidence that this feature is commonly requested and will be needed in the future to support modern APIs is undeniable. @Dschee While I agree with you that this seems to be a relatively commonly requested feature, there hasn't really been a proposal yet for an API to make this simple and clean. The workaround of using a custom `ParameterEncoding` is slightly tedious, but does work. I will try giving it a little bit more thought, but unless we come up with a way to do this without adding layers of complexity to the elegant APIs that `Alamofire` currently provides, I don't think we are going to get much support for this feature.

@jshier I am not a fan of `JSON API` myself either, but we have to consider that not all users will necessarily follow the same accepted practices. I can tell you that, if I was creating a web API, I would likely never have the need for encoding query parameters and a `JSON` body in the same request. However, I have to consume an API that was created by my company's web engineer, and he doesn't follow nearly ANY common practices for his API design (Our API isn't event RESTful). I regularly am consuming APIs where I am passing an object identifier into the query parameters and a dictionary of values to edit on the object in the `JSON` body. 

While I agree that the commonly accepted practices SHOULD usually be followed, not everyone has the luxury of consuming APIs that follow them. From my perspective, `Alamofire` has two primary design goals. 

1. To provide a simple, elegant API for basic usage that abstracts away the complexities of `URLSession`.
2. To provide the flexibility required for advanced usage, customization, and uncommon practices without compromising on point 1. As I thought more about this, I'm realizing that the only use case I can see for "multiple encoding types" is adding query parameters and having an `httpBody` of some other encoding type (`JSON`, `XML`, etc.). You can't combine multiple types of encoding into the body of the request. Your `Content-Type` has to be set to one type, so this only makes sense with query parameters.

Does this sound right, or is there some use case I'm overlooking @Dschee? Tackling the problem of supporting any combination of encoding methods is very different from allowing query parameters with another encoding style in the body. That sounds just right to me. I think it's the most common use case not already covered by Alamofire. I will try to add this feature to Alamofire in a backwards-compatible and clean way and submit a PR within the coming hours.

But your disliking of JSON API makes me wonder: What are you guys doing to make sure you don't have to reinvent the wheel again and again when designing APIs (e.g. sorting, pagination, including relationships in one request) and how are you trying to make sure client programmers have an easy time to consume many different APIs over time without rewriting a bunch of code everytime they consume a new one. JSON API is the closest thing to these goals that I know, but maybe I'm overseeing something? I'd be glad to learn from you guys, so please enlighten me. üòâ I've actually already started writing a proposal for how I would implement this. I'll finish it and post something in the morning. 

I'm all for a consistent, stable format for APIs, I just think JSON API makes some poor decisions. One of them being the exact example you have when bringing JSON API into this discussion. :) Haha okay, I see. :)

Well then, I'll wait for your post. Thanks for your help! If you have a proposal for how you would implement this, please post it. I'd love to hear it. But I wouldn't spend too much time working on a PR until we have come to an agreement on how this should work.  I'm more of a guy who writes his proposals in PRs and marks them as [WIP] (work in progress). This way the code is already within the project and I can see if my suggestion makes any tests fail or not. Also I find it hard to discuss about specific lines using the threading style, a GitHub review is so much easier imho.

Sure, I can post my proposal PR until morning in Nevada (it's morning here in Germany üòâ ). I've just posted my proposal as a PR in #1883. What do you think? @Dschee Thanks! I've made my comments there. We should probably move discussion of how to handle this over to the PR since this issue has been closed already for some time.  I think the content of the network request returns need CoreData to storage But you need to realize the NSCoding protocol wants to join
  See [RFC 3986  $ 3.4](http://tools.ietf.org/html/rfc3986#section-3.4)
  For escaping the query parameters I propose to use the iOS 7 API and above
stringByAddingPercentEncodingWithAllowedCharacters(NSCharacterSet.URLQueryAllowedCharacterSet())

The result is not the same as the current implementation which for instances escapes the / parameter whereas iOS does NOT
 @mattt OK, then you need to change the characters to escape because the current implementation escapes "/" and it should NOT
 @mattt This is perfectly correct. According to the [RFC 3986 $ 3.4](http://tools.ietf.org/html/rfc3986#section-3.4)

The characters slash ("/") and question mark ("?") may represent data  within the query component.
query       = *( pchar / "/" / "?" )

Indeed, Apple has perfectly implemented the RFC.
 @mattt Well you put back some older code because of memory consumption. In between you had exactly the behaviour that now you think is wrong?
My problem is that I am using a server that does not understand the URL if I escape the legal "/" character.
Would it be possible to have an option such as we can choose between escaping or not "/"?
 @mattt OK Thanks I will give it try! As long as there is a solution, I am fine with that! That said, we could have an option both for Alamofire and AFNetworking....
  Error in Playground: Module 'Alamofire' has no member named 'request'
How can I use Alamofire in Playground?
thanks
 @tianhao Did you solve this?
 I give up use it in playgound
  It would be great if someone can explain how to make NTLM request. 
 Thanks @mattt . Will do :+1: 
  The only thing keeping me away from using Alamofire over AFNetworking is the missing ability to use [SSL certificate pinning](http://initwithfunk.com/blog/2014/03/12/afnetworking-ssl-pinning-with-self-signed-certificates/).

It would be great if you could include this feature so I can get rid of this Objective-C framework within my SWIFT project.

If you already plan to implement this feature could you please give a time range until you might get to this?

I hope I did not miss this feature if it is already implemented.
 You did not miss it...it hasn't been implemented yet.

It is certainly something that the community is looking to support, but there's not a solid time frame around it yet. I'd say for the time being, you'll want to continue with AFNetworking, and keep a close eye on the Alamofire project for new features coming in.
 All right, will do! Thank you for your response.
 If I could up vote this, I would.
 Here comes another upvote
 :+1: 
 :+1:
 (y)
 :+1: 
 @cnoon Any timeline for a 1.3 launch?
 Thank you! 
 üëç
 üëç
 If you need help testing it, I would love to give a hand
 üëç
 +1 here are my hands!
 üëç
 +1
 +1
 Certificate pinning stopped working with Swift 3.0
I am using the following code:

```
let myServer = "...". //string in format without https://

let pathToCert = Bundle.main.path(forResource: "certificate", ofType: "der")
let localCertificate = NSData(contentsOfFile: pathToCert!)!

 let serverTrustPolicy = ServerTrustPolicy.pinCertificates(
            certificates: [SecCertificateCreateWithData(nil, localCertificate)!],
            validateCertificateChain: true,
            validateHost: true
        )

let serverTrustPolicies = [
            myServer: serverTrustPolicy
        ]

afManager = SessionManager(
            serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies)
        )

afManager.request("... some other domain ...", method: .get).response { response in
            log.info(response)
        }
```

I still get response (status code 200) from the other domain
What could be wrong here?
@cnoon :(((( Maybe a typo, did you mean "cer" instead of "der"?
`Bundle.main.path(forResource: "certificate", ofType: "der")`
 @ghecho I am not sure I follow you.
The certificate is in **.der** format, and it loads from the bundle.
Are you saying that **.der** format is not supported and I should always use **.cer** ? Ohh I see, no, my bad, I thought it was a typo and the certificate was in "cer" type. I just googled it and found out that "der" was a valid format. Sorry about that. @ghecho No problem man! Anyways, do you have slight idea what could be wrong here? @dvertovsek No idea, I would say as a blind guess that maybe trying the address with "https" but the strange thing is that you say that it worked before and also that it returns 200 OK. Anyway, if I came up with an idea I'll let you know. @ghecho Yep it returns 200 OK for **my domain**, and for **any other domain**, and im guessing this should not happen. OK man, thanks
@cnoon , thoughts?  When I build using Carthage, I get following error; but it works well when I build using Xcode -- not sure why

```
¬ª carthage build                                             
*** xcodebuild output can be found in /var/folders/vr/mtng044x7jb0_0hcchwjgl0w0000gn/T/carthage-xcodebuild.fM29Kb.log
*** Building scheme "Alamofire iOS" in Alamofire.xcworkspace
2015-03-03 19:44:08.029 xcodebuild[17886:502028]  DVTAssertions: Warning in /SourceCache/IDEXcode3ProjectSupport/IDEXcode3ProjectSupport-6267/Xcode3Core/LegacyProjects/Frameworks/DevToolsCore/DevToolsCore/SpecificationTypes/BuiltInSpecifications/Compilers/XCGccMakefileDependencies.m:77
Details:  Failed to load dependencies output contents from ``/Users/sarat/Library/Developer/Xcode/DerivedData/Alamofire-avhttqnzkfhwxwbmbfsrrqmwsvwp/Build/Intermediates/Alamofire.build/Release-iphonesimulator/Alamofire iOS Tests.build/Objects-normal/x86_64/DownloadTests.d''. Error: Error Domain=NSCocoaErrorDomain Code=260 "The file ‚ÄúDownloadTests.d‚Äù couldn‚Äôt be opened because there is no such file." UserInfo=0x7fed88584e60 {NSFilePath=/Users/sarat/Library/Developer/Xcode/DerivedData/Alamofire-avhttqnzkfhwxwbmbfsrrqmwsvwp/Build/Intermediates/Alamofire.build/Release-iphonesimulator/Alamofire iOS Tests.build/Objects-normal/x86_64/DownloadTests.d, NSUnderlyingError=0x7fed8ac6f5d0 "The operation couldn‚Äôt be completed. No such file or directory"}. User info: {
    NSFilePath = "/Users/sarat/Library/Developer/Xcode/DerivedData/Alamofire-avhttqnzkfhwxwbmbfsrrqmwsvwp/Build/Intermediates/Alamofire.build/Release-iphonesimulator/Alamofire iOS Tests.build/Objects-normal/x86_64/DownloadTests.d";
    NSUnderlyingError = "Error Domain=NSPOSIXErrorDomain Code=2 \"The operation couldn\U2019t be completed. No such file or directory\"";
}.
Function: void XCGccMakefileDependenciesParsePathsFromRuleFile(NSString *__strong, void (^__strong)(NSString *__strong))
Thread:   <NSThread: 0x7fed88584ea0>{number = 9, name = (null)}
Please file a bug at http://bugreport.apple.com with this warning message and any useful information you can provide.
** BUILD FAILED **


The following build commands failed:
    CompileSwift normal x86_64 /Users/sarat/github/Stanford/pmo/Carthage/Checkouts/Alamofire/Tests/DownloadTests.swift
    CompileSwiftSources normal x86_64 com.apple.xcode.tools.swift.compiler
(2 failures)
```
 Update fails here too:

```
*** Cloning Alamofire
*** Checking out Alamofire at "1.1.4"
*** xcodebuild output can be found in /var/folders/dw/wtbd233j0yd8vzjzlfz1wz1w0000gn/T/carthage-xcodebuild.pDAvwq.log
*** Building scheme "Alamofire iOS" in Alamofire.xcworkspace
** BUILD FAILED **


The following build commands failed:
    Check dependencies
(1 failure)
```
 @sharat Without the `xcodebuild` log, it will be impossible to diagnose the particular failure there.

@AndreasBackx That usually indicates a [code signing issue](https://github.com/Carthage/Carthage/issues/281). It's probably not caused by Alamofire.
 the log
@jspahrsummers 

```
${Carthage}/Checkouts/Alamofire/Tests/DownloadTests.swift:68:54: error: operand of postfix '!' should have optional type; type is 'String'
                XCTAssertEqual(file.lastPathComponent!, "\(suggestedFilename)", "filename should bsuggestedFilenameines)")
```

My xcodebuild version is

```
‚ûú  ~  xcodebuild -version
Xcode 6.1
Build version 6A1052d
```
 Alamofire [1.1.4](https://github.com/Alamofire/Alamofire/releases/tag/1.1.4) builds just fine for me:

```
$ xcodebuild -version
Xcode 6.1.1
Build version 6A2006
```
 It seems that I need to update my xcode version.üòÑ
 Ain't quite sure what happened after updating to latest Xcode (6.2). The errors disappeared and it's working fine!

@jspahrsummers - Sorry for not attaching the log. Just missed it.
I had the same problem mentioned by @raylua2566. It's working now anyway. 
  Are there any plans to make an Amazon S3 serializer like `AFAmazonS3Manager` for AlamoFire?
 I've decided I'm going to go ahead and take a shot at creating a new CocoaPod that is a subclass of `Alamofire.Manager` to handle AmazonS3 requests. 
Once I've got it finished, I'll link it here.
@mattt, If you would eventually like to include it in this repository, let me know.
 That makes sense. I'll let you know when I'm finished. Thanks.
 @mattt I've released an initial `0.1.0` version of my `AmazonS3RequestManager` for Alamofire.

It's going to be updated with a lot more functionality soon, but it works now. Just wanted you to be aware of it.

https://github.com/AnthonyMDev/AmazonS3RequestManager
   @indragiek  This has been resolved in PR #357 with additional fixes to the examples. :+1: 
  We should always follow the content encoding sent from the server instead of assuming UTF-8 or whatever the user has configured.

Note, `iso-8859-1` is the default encoding for HTTP 1.1. As such that is the default if a server didn't explicitly set it to utf-8.
  I am getting unexpectedly error sometimes in my response.

fatal error: unexpectedly found nil while unwrapping an Optional value
Printing description of serializationError:
Error Domain=NSCocoaErrorDomain Code=3840 "The operation couldn‚Äôt be completed. (Cocoa error 3840.)" (Unable to convert data to string around character 23447.) UserInfo=0x171668ac0 {NSDebugDescription=Unable to convert data to string around character 23447.}

Any suggestions on it. How do I resolve this issue other then change the response encoding to UTF-8
 ISO-8859-1 is not a valid encoding for JSON. As per the [JSON specification](http://www.ietf.org/rfc/rfc4627.txt) (3. encoding).

```
3.  Encoding

   JSON text SHALL be encoded in Unicode.  The default encoding is
   UTF-8.

   Since the first two characters of a JSON text will always be ASCII
   characters [RFC0020], it is possible to determine whether an octet
   stream is UTF-8, UTF-16 (BE or LE), or UTF-32 (BE or LE) by looking
   at the pattern of nulls in the first four octets.

           00 00 00 xx  UTF-32BE
           00 xx 00 xx  UTF-16BE
           xx 00 00 00  UTF-32LE
           xx 00 xx 00  UTF-16LE
           xx xx xx xx  UTF-8
```

Please correct me if this error isn't from the JSON deserialisation, but I can't find any other code-paths that result in a serialization error and you didn't explicitly state what you was doing. So I'm assuming JSON.

Apple's JSON API (which Alamofire is using) only allows Unicode:

```
The data must be in one of the 5 supported encodings listed in the JSON specification: UTF-8, UTF-16LE, UTF-16BE, UTF-32LE, UTF-32BE.
```
 Unrelated for JSON, but I've made #359 which will make Alamofire follow the server's encoding for `responseString`.
 Cool, Thanks for your response Kylef. I was doing JSON deserialization and I would make my back-end changed to be UTF-8 formatted response.
 I'm not sure whether it is related or not, but since upgrading to El Capitan this morning I'm getting `FAILURE with Error: Error Domain=NSCocoaErrorDomain Code=3840 "Unable to convert data to string around character 1845." UserInfo={NSDebugDescription=Unable to convert data to string around character 1845.}` for a response that worked just fine yesterday... is there a parameter I can pass to the request to address this?
 @jshier thank you for your response! 
how would you confirm it to be decodable as UTF-8 string?
I have now idea why all of a sudden the response from JSON throws this error. Also it comes from 3rd party API I have no control over..
  :tada: 
#353 should also be merged for the example project to build fully (didn‚Äôt want to duplicate those changes in this PR).

Travis will fail given the requirements for the xcode-6.3 branch.
 I would find this change useful. I would be great to have it merged into the `Xcode-6.3` branch.
 This change fixed my build in Xcode 6.3 beta 2.
 Thank you @rasterize and @mattt!
 Much appreciated, thanks for including this. I'm back on the `xcode-6.3` branch and running happily again.
  Thanks for another great library @mattt !
The code is far from finished, but I was wondering if you agreed with the general direction ?
It adds a **ServerTrustPolicy** enum, inspired by the **ParameterEncodig** one, as well as a chainable _serverTrustPolicy()_ function for requests.

I was not sure how to integrate globally into the Manager - if that's needed. I saw that for client credentials, the underlying NSURLSessionConfiguration can [provide them nicely](https://github.com/Alamofire/Alamofire/blob/master/Source/Alamofire.swift#L750). 
Would a new serverTrustPolicy property on the Manager, which, when set, assigns a policy to every created request be in the Alamofire spirit ?
 Just to note that after some further testing, the actual implementation is neither faithful to its documentation nor very secure, so this is very much a question on the high level API.

For future work, I guess I'm wondering what potential users expect when pinning either certificates or public keys. For example, should the default case expect the server to present the entire chain rather than a single leaf certificate potentially ? I guess I'm saying that after using AFNetwoking in just one TLS situation, I'd really appreciate guidance on what would make an easily usable and simple-to-get-right API for the majority case.
 This comment started as an attempt to recap some of the dicussion around this API, from blog posts, or AFNetworking issues such as:
- AFNetworking/AFNetworking#1906: request for pinning just root and/or intermediate cert.
- AFNetworking/AFNetworking#1852: public key pinnning discussion, [reedloden's comment](https://github.com/AFNetworking/AFNetworking/issues/1852#issuecomment-36199389) highlights best-pratice and usability while [pjjw](https://github.com/AFNetworking/AFNetworking/issues/1852#issuecomment-70788346) talks about his 2 root cert use-case

The sections below try to outline how the proposed `ServerTrustPolicy` enum would behave, but also why.

#### Certificates

The `.PinCertificates` case could work as follows. It would take a set of certificates to pin, whether roots or leaves, and would evaluate trust by calling out to the `SecTrustSetAnchorCertificates()` and `SecEvaluateTrust()` functions - a thin, straightforward layer. A host would therefore be trusted if **any** of the pinned certificates were within the chain it presents.
This hopefully makes the following use-cases straightforward:
- Pinning a parent (root/intermediate) certificate, with the host presenting a leaf certificate issued by this parent
- Pinning a self-signed non-CA certificate with the host presenting this same certificate.

Potential pitfalls:
- Pinning an entire chain - or any number of certificates - does not require all those certificates to be in the host chain but rather increases the pool of totally trusted certificates - regardless of their root/leaf status.
  How prevalent is this use-case though ? I would argue that for certificate pinning, the catered use-case should be to pin root/intermediate certificate(s). Otherwise, when pinning a leaf, might as well use public-key pinning (described below) to ensure both the same security and independence from the issuer, rather than just removing the potential benefit of certificate rotation.
- Different from AFNetworking

#### Public keys

For the `.PinPublicKeys` case, I am less sure how to proceed, in part because I do not know what the dominant use-case is. Should it support multiple keys ? Should it then verify that the pinned keys are a subset of the host chain's keys ? Or should it be similar to `.PinCertificates` and create a pool of trusted keys ? I personally like the simplicity of HPKP, detailed below.
Another peril [Adam Langley](https://www.imperialviolet.org/2011/05/04/pinning.html) mentions when hashing the public key and not the certificate's SubjectPublicKeyInfo:

> This is important because just hashing the public key leaves one open to misinterpretation attacks. Consider a Diffie-Hellman public key: if one only hashes the public key, not the full SPKI, then an attacker can use the same public key but make the client interpret it in a different group. Likewise one could force an RSA key to be interpreted as a DSA key etc.

On the one hand, it's possible to generate multiple types of keys within the opaque `SecKeyRef`, which gives hope that it holds on to this type info however there's really only one kind - [RSA](https://developer.apple.com/library/ios/documentation/Security/Reference/keychainservices/index.html#//apple_ref/doc/constant_group/Key_Type_Values) - defined in iOS. I suppose this unicity side steps the problem - it wouldn't be possible to re-interpret the key any other way, but I would love feedback on this.

###### HPKP

Another idea might be to follow the web's [HPKP](https://developer.mozilla.org/en-US/docs/Web/Security/Public_Key_Pinning), also summarized [here](https://projects.dm.id.lv/Public-Key-Pins_calculator#Public_Key_Pinning_Extension_for_HTTP_.28HPKP.29). This includes affordances for backup keys which might not be in the scope of a default Alamofire policy. However the basic principle is to pin a key and then check if it exists at any level in the host's chain.
 Certificate and public key pinning are implemented by adding a `ServerTrustPolicy` enum.
The API currently has 2 granularities. They are incompatible as the global level always has precedence if set. Perhaps it might be better to remove the request level method altogether ?
- at the `Manager` level, all requests will be affected when using `Alamofire.serverTrustPolicy =`
- at the request level, enabling code like `request(.GET, "https://example.com").trustPolicy(.InsecureTrustAny)`

The pre-existing closures in the session/task delegates are still present and can override this enum if needed.
A server is trusted if:
- its certificate chain is valid and _any_ certicate in this chain is within the set of pinned certificates. The host name is also always checked (though this might need to be changed)
- _any_ of its keys is contained within the set of pinned keys.

The `ServerTrustPolicy` enum provides easy-access vars to any certificates (or public keys of certificates) contained in the app bundle.

A simple example usage would be along the lines of:

```
Alamofire.serverTrustPolicy = .PinCertificates(ServerTrustPolicy.bundledCertificates)
Alamofire.request(.GET, "https://example.com", parameters: ["foo": "bar"])
```

or per request:

```
Alamofire.request(.GET, "https://example.com", parameters: ["foo": "bar"])
    .trustPolicy(.InsecureTrustAny)
```
 @briv It looks like you're on the right track here! I haven't reviewed the code but your summaries above sound like the correct/desired behavior to me (and I've done this cert pinning dance a few times). Thanks
 Thank you for the kind words. I'll send them right back for how sweet Alamofire is.

Since the global policy was over-riding request-level policies in a silent way, that is now out. It is definitely do-able but I didn't want to reorganize too much without consulting. Also to simplify using any code from these patches.
I'm not sure how much this TLS security policy should take away from those who would want total configurability - I suppose this is every API's trade-off =). My instinct says "very little" as Alamofire wants to cater to all use cases ? At the same time, I'm thinking that a TLS pinning API that makes it easy to shoot yourself in the foot is not the best.

To go on about this point, the `SessionDelegate` exposes 2 ways to potentially override challenge responses and the underlying `TaskDelegate`, which is however private to the external world, exposes another one. I wasn't confident to reorganize those out without any discussion, so this last set of changes just tries to do the minimum while making it (hopefully) easy to reuse those pieces in a different way if need be.

In summary, the latest changes are rebased and squashed to give:
- A `TLSTrustPolicy` enum which evaluates a server's TLS credentials. I think the `.Custom` case might not make as much sense anymore since the user might want to implement the delegate closure `sessionDidReceiveChallenge` at that point? Unless this enum takes over completely.
- A `TLSPolicy` var on the `SessionDelegate` which only acts as a convenience to set the `sessionDidReceiveChallenge` closure.
- A global `TLSPolicy` var to act on `Manager.sharedInstance`
- Some tests

An example usage:

``` swift
Alamofire.TLSPolicy = .PinCertificates(TLSTrustPolicy.bundledCertificates)
Alamofire.request(.GET, "https://example.com", parameters: ["foo": "bar"])
```

I'm more than happy to discuss, implement, re-juggle, or rework whatever you think is best, or just take a step back and wait for 1.3.0.
  I print my curl request through `debugPrintln` and it's working (with a 200 status code) when I'm try it in my Terminal :

``` http
curl -i \
    -u YOUR_TOKEN:api_token \
    -H "Accept-Language: en;q=1.0" \
    -H "Accept-Encoding: gzip;q=1.0,compress;q=0.5" \
    -H "User-Agent: TogglGoogleCalendar/com.cappie.TogglGoogleCalendar (1; OS Version 10.10.2 (Build 14C109))" \
    "https://www.toggl.com/api/v8/me"
```

But it's not working in my code (status code 403). Here's my (really) simple code :

```
let request = Alamofire
            .request(.GET, "https://www.toggl.com/api/v8/me", parameters: nil, encoding: ParameterEncoding.JSON)
            .authenticate(user: "YOUR_TOKEN", password: "api_token")
            .responseJSON { (request, response, data, error) in
                println(" -- RESPONSE -- ")
                println(response)
            }

println("-----------------------")
debugPrintln(request)
```

Did you ever had an issue like this ?
 Came here from google, cause I had a similar issue like @nicolas-besnard. So just for the record: don't use `.authenticate(...)` but add **authorization** header, as described here [toggl_api_docs](https://github.com/toggl/toggl_api_docs/blob/master/chapters/authentication.md). For setting it, see https://github.com/Alamofire/Alamofire/issues/32
  At the moment Carthage can build Alamofire for iOS but since it targets iOS 7, the resulting application cannot be submitted to iTunes Connect.

I already opened a bug report on Carthage to ask for the best course of action (https://github.com/Carthage/Carthage/issues/351), they suggested to open a bug report here.

I see that some bug reports have already been closed in the past because Alamofire needs to support iOS 7 (Is the Xcode project configured that way in order to have Travis build and test against that version of iOS?).

At this point I'm not sure how to proceed.
 A fresh checkout and build in Xcode produces this warning
`ld: warning: embedded dylibs/frameworks only run on iOS 8 or later`
Changing the deployment target from 7.0 to 8.0 solves the warning.
There are multiple reports that this warning causes rejection during App Store submission, _even though_ it will mostly run fine on Simulator / devices.
 I am seeing the same behavior. 

It seems to me that the best course of action would be to have the deployment target set to 8.0 in the project. That will solve the problem for Carthage and won't affect CocoaPods. 

For users that are deploying their app with a deployment target of 7.0, they cannot submit to Apple using Frameworks anyways. They will need to pull in the Alamofire.swift file manually into their project. This approach doesn't care what the deployment target is set to in the `Alamofire iOS` target because they are manually copying the file into their project.

Maybe there's another issue at hand that I'm not aware of at the moment (please comment if so), but it seems to me that the iOS deployment target in the project should be set to 8.0 to solve all the use cases for deployment.
 +1
 :+1: 
 While you may get a warning. You do indeed get a submission error:

```
ERROR ITMS-90362: "Invalid Info.plist value. The value for the key 'MinimumOSVersion' in bundle/Frameworks/Alamofire.framework is invalid. The minimum value is 8.0"
```
 @mattt Any opinion on this issue? I could make a PR bumping the minimum OS version requirements if you want.
 Oh wait, there's already a PR open: #375
  - Resolves this Travis error, fixing the build, by running tests on the iPhone 6 simulator:

```
xcodebuild: error: Failed to build project Alamofire with scheme Alamofire iOS
    Reason: The run destination iPad 2 is not valid for Testing the scheme 'Alamofire iOS'.
```
- Added some recommended ENV variables for `xcpretty`
- Speeds up `xcpretty` install by ignoring documentation
- Added a podspec linting step 
  I have a problem.
I won't be able to return a value.
Why... How do I solve?

``` swift
func getQuests(category: NSString, count: Int) -> NSArray {
        var quests = NSArray()

        Alamofire.request(.GET, apiUrlString, parameters: ["category": category, "count": count])
            .responseJSON { (request, response, json, error) in
                dispatch_async(dispatch_get_main_queue(), {
                    quests = json as NSArray
                })
        }

        println(quests)  #=> ()

        return quests
    }
```

I want you to help me.
 Please post this question on StackOverflow. I will answer it there.
 @tkrajacic 
http://stackoverflow.com/questions/28564801/i-wont-be-able-to-return-a-value-with-alamofire-in-swift

Thank you. 
  Hi! I'm new to iOS Development, I installed Alamofire as said in README, but I have this error as other users and I don't know how to solve it.

![captura de pantalla 2015-02-15 a las 22 08 42](https://cloud.githubusercontent.com/assets/5198677/6205016/3541530e-b55f-11e4-9b28-ae6fc815b984.png)
  After the switch to a universal framework to in #326, Xcode automatically chooses the latest version of iOS as the deployment target when compiling the framework for iOS (i.e. compiling with Xcode 6.3b1 results in iOS 8.3 being chosen as the deployment target).

This change explicitly sets the deployment target to iOS 7.0 to avoid this issue.
 @mattt Could you pick that commit onto the `xcode-6.3` branch as well? Thanks. 
 @mattt :+1: Thank you
  Hey there, 

I'm not sure if I do something wrong but I noticed the following 

If  I do 
let parms = ["start" : "20150101T000000+10", "end" : "20150102T000000+10"]
request(.GET, "http://awesomeUrl.com/", parameters:parms)

The parms are not added to the url. I would expect that the parameters which I pass to the get request automatically added to the url like  http://awesomeUrl.com?start=20150101T000000+10&end=20150102T000000+10

Also if I set the parameters manually like 

request(.GET, "http://awesomeUrl.com?start=20150101T000000+10&end=20150102T000000+10", parameters:parms)

The url will be not url encoded. I would expect something like 
http://awesomeUrl.com?start=20150101T000000%2B10&end=20150102T000000%2B10
  Hi i have issue on the json response, can any one help ?

here is my sample code using alamofire:

Alamofire.request(.POST, testURL, parameter: params)
         .responseJSON { (request, response, JSON, error) in
                  println(JSON)
         }

my issue here is the json response that i get is not a valid json .. 

sample json response:

{
    "completed_in" = "0.0164";
    message = "User Account does not exists.";
    status = 0;
}

i recieve semi-colon(;) it should be comma(,) right?
thanks, hope someone will help ..
 any help ?
 valid json 
{
    "completed_in": "0.0164",
    "message": "User Account does not exists.",
    "status": 0
}
  Thanks for everything that you have done on Alamofire! I can't seem to find a good example of how to do nested JSON serialization in the Alamofire documentation. I would be happy to contribute documentation back to the project if I can get some help. 

I would like to serialize [this JSON response](http://private-5bdb3-friendmock.apiary-mock.com/alamofire/nested). 

I have extended the `Alamofire.Request` object with the `ResponseCollectionSerializer` and `ResponseObjectSerializer`

Here is my attempt to get it to work. 

``` swift
final class Post : ResponseObjectSerializable, ResponseCollectionSerializable {

    let id: Int
    let title: String
    let body: String
    let author: Author
    let comments: [Comment]

    required init?(response: NSHTTPURLResponse, representation: AnyObject) {
        self.id = representation.valueForKeyPath("id") as Int
        self.body = representation.valueForKeyPath("body") as String
        self.title = representation.valueForKeyPath("title") as String

        // What do I do with the author object

        var authorObj: AnyObject? = representation.valueForKeyPath("author")

        if (authorObj != nil) {
            self.author = Author(response: response, representation: authorObj!)!
        }

        // What do I do with the comments Array?
        self.comments = Comment.collection(response: response, representation: representation.valueForKeyPath("comments")!)

    }

    class func collection(#response: NSHTTPURLResponse, representation: AnyObject) -> [Post] {
        var postList:[Post] = []
        for p in representation as [AnyObject] {
            postList.append(Post(response: response, representation: p)!)
        }
        return postList
    }

}
```

``` swift
final class Comment : ResponseObjectSerializable, ResponseCollectionSerializable {

    let id: Int
    let body: String

    required init?(response: NSHTTPURLResponse, representation: AnyObject) {
        self.id = representation.valueForKeyPath("id") as Int
        self.body = representation.valueForKeyPath("body") as String
    }

    class func collection(#response: NSHTTPURLResponse, representation: AnyObject) -> [Comment] {
        var commentList:[Comment] = []
        var commentArray = representation as [AnyObject]
        for c in commentArray {
            commentList.append(Comment(response: response, representation: c)!)
        }
        return commentList
    }

}
```

``` swift
final class Author : ResponseObjectSerializable {

    let id: Int
    let name: String

    required init?(response: NSHTTPURLResponse, representation: AnyObject) {
        self.id = representation.valueForKeyPath("id") as Int
        self.name = representation.valueForKeyPath("name") as String
    }
}

```

The representation is a Builtin.RawPointer

`(lldb) po representation`
`(instance_type = Builtin.RawPointer = 0x00007f8b9ae1d290 -> 0x000000010c7f4c88 (void *)0x000000010c7f4dc8: __NSArrayI)`

Any suggestions?
 Do you get any error when running this? Does the Author part work and not Comments part? We're doing something very similar but we're using SwiftyJSON. However, we never have nested serialized arrays, only string arrays but I guess they would work just as well as nested objects. 

The only potential problem I see with your code is that the `author` property in the `Post` class is not optional but your initializer does not guarantee the property is set to an instance.

Here is a small sample of our code. Hope this helps.

``` swift
final class Video: NSObject, ResponseObjectSerializable, ResponseCollectionSerializable {

    let identifier: String
    let contentType: String
    let videoType: String
    let duration: Float
    let genres: [String]?
    let posterUrl: String?

    let links: VideoLinks
    let channel: Channel?

    required init?(response: NSHTTPURLResponse, json: JSON) {

        var videoJson = json["data"]

        if videoJson == JSON.nullJSON {
            videoJson = json
        }

        self.identifier = videoJson["id"].stringValue
        self.contentType = videoJson["contentType"].stringValue
        self.videoType = videoJson["videoType"].stringValue
        self.duration = videoJson["duration"].floatValue
        self.genres = videoJson["genres"].arrayObject as [String]?
        self.posterUrl = videoJson["posterUrl"].string

        self.links = VideoLinks(videoJson["_links"])

        self.channel = Channel(response: response, json: videoJson["channel"])

        super.init()
        if videoJson == JSON.nullJSON {
            return nil
        }
    }

    class func collection(#response: NSHTTPURLResponse, json: JSON) -> [Video] {
        var videos: [Video] = [];
        for (index: String, video: JSON) in json["data"] {
            let videoObj = Video(response: response, json: video)
            videos.append(videoObj!)
        }

        return videos
    }
}

final class VideoLinks: NSObject {
    let channel: String
    let collection: String?
    let streamUrl: String

    init(_ json: JSON) {
        self.channel = json["channel"].stringValue
        self.collection = json["collection"].string
        self.streamUrl = json["streamUrl"].stringValue
    }
}


final class Channel: NSObject, ResponseObjectSerializable, ResponseCollectionSerializable {

    let identifier: String
    let name: String
    let descriptionText: String
    let genres: [String]?
    let slug: String
    let tags: [String]?
    let brandColor: String?
    let posterUrl: String?
    let logoUrl: String?

    required init?(response: NSHTTPURLResponse, json: JSON) {

        var channelJson = json["data"]

        if channelJson == JSON.nullJSON {
            channelJson = json
        }

        self.identifier = channelJson["id"].stringValue
        self.name = channelJson["name"].stringValue
        self.descriptionText = channelJson["description"].stringValue
        self.genres = channelJson["genres"].arrayObject as? [String]
        self.slug = channelJson["slug"].stringValue
        self.tags = channelJson["tags"].arrayObject as? [String]
        self.brandColor = channelJson["brandColor"].string
        self.posterUrl = channelJson["posterUrl"].string
        self.logoUrl = channelJson["iconUrl"].string

        super.init()
        if channelJson == JSON.nullJSON {
          return nil
        }
    }

    class func collection(#response: NSHTTPURLResponse, json: JSON) -> [Channel] {
        var channels: [Channel] = [];
        for (index: String, channel: JSON) in json["data"] {
            let channelObj = Channel(response: response, json: channel)
            channels.append(channelObj!)
        }

        return channels
    }
}
```
  Xcode 6.3 and Swift 1.2 beta is out :)

Please make it compatible to it. I think most of the compile errors are due to this:
- as! for failable casts ‚Äî Casts that can fail at runtime are now expressed with the new as! operator to make their potential for runtime failure clear to readers and maintainers of your code.
- The implicit conversions from bridged Objective-C classes (NSString/NSArray/NSDictionary) to their
  corresponding Swift value types (String/Array/Dictionary) have been removed, making the Swift type
  system simpler and more predictable. (18311362)
 First of all, there's already PR for this https://github.com/Alamofire/Alamofire/pull/338. 

Second, these changes are not backwards compatible, and probably should not be merged in until XCode 6.3 is in release.
 @Harper04: @DenHeadless is correct.

If you're using CocoaPods you can add `pod 'Alamofire', :git => "git@github.com:boek/Alamofire.git", :branch => 'swift-1.2beta'` to your Podfile. You'll get a compiler warning, but you should be able to continue development.
 Any advice for how to use the PR with Carthage?
 Of course, if I'd RTFM I'd have seen that you can use the PR in Carthage with `github "boek/Alamofire" "swift-1.2beta"`.
 @davejlong I haven't used Carthage, so I can't say for sure. But from what I read this should probably work `github "boek/Alamofire" "swift-1.2beta"`.
 Thanks, @boek! Maybe this should be in the readme.md of this project, since so many people have already upgraded to Swift 1.2 (at least from what I see on Twitter).  
 Besides: Xcode seems to overwrite the system wide swift compiler so even if you are running multiple versions of Xcode you can only compile the newest Swift style. Am i missing something? (reinstalling Xcode... m√§h)
 @Harper04 not sure if this would fix your issue or not, but if you go into the settings for XCode you can change the Command Line Tools on the Locations tab to a different version. I assume the Command Line Tools includes the Swift compiler.
 @boek Thanks so much, that got me going again.
@mattt Is there a way to install the `xcode-6.3` branch with `CocoaPods`?
 @mattblang `pod 'Alamofire', :git => "git@github.com:Alamofire/Alamofire.git", :branch => 'xcode-6.3'` should work for you
 @boek Oh great, thanks so much!  I get a warning `umbrella header for module 'Alamofire' does not include header 'Alamofire-Swift.h'`.  This doesn't seem to cause a problem, but I am just curious why it is looking for a header file.
 How can I add it as a submodule? 
 Now that Xcode 6.3 is available on the app store, will the 6.3 branch be merged into master?
 +1 for merging `xcode-6.3` into master
 @bipingm and @blakeperdue
This has already been merged into `master` and is available as `Alamofire 1.2.0` which is fully Swift 1.2 and Xcode 6.3 compatible. 

@mattt, if you get a chance, it would probably be a good idea to remove that `xcode-6.3` branch to avoid further confusion.
 Did you try the cocoapods? Worked fine with me. ¬†Are you sure you are using the stable version of xcode6.3 not the beta?

On Fri, Apr 10, 2015 at 3:55 AM, Blake Perdue notifications@github.com
wrote:

> @cnoon thanks, I switched back to `master`. I still cannot get it working on xcode 6.3. None of the existing manual installation methods work. I tried Alamofire's steps as well as these: http://stackoverflow.com/a/25872859
> 
> ## Any suggestions?
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/Alamofire/Alamofire/issues/339#issuecomment-91399485
 @samuelbeek I got 1.2.0 (ie, `xcode-6.3` merged into `master`) working fine. It was a stupid spelling mistake on my part (AlamoFire vs Alamofire, doh!). Thanks.
  Went through and fixed all the compilation errors caused by the upgrade to Swift 1.2
 I'm not sure if this is related to the updates in your PR or not, but, with Carthage, Alamofire won't build for iOS. Only the Mac framework is built in the builds directory.
  Just pulled the latest version making Alamofire into a universal project. However, now the main scheme doesn't want to build when looking at an actual device. It just errors with the following:

CodeSign error: code signing is required for product type 'Unit Test Bundle' in SDK 'iOS 8.1'

There is another scheme, but it doesn't let me build it. Is it possible something got a bit screwy with with the projects schemes/targets is the latest update or is it just me?

Note: This is an iOS project.
 Possibly something to do with this?

![screen shot 2015-02-09 at 2 12 25 pm](https://cloud.githubusercontent.com/assets/1707598/6106900/c49d58b2-b065-11e4-80dc-e555b27bb555.png)
 Right, in danger of posting too much on my own issue. The missing targets and extra scheme seem to be an error with my bit not removing schemes correctly.

I am still having the issue that the "Alamofire" scheme will not build the framework to the products directory. And to confirm, it's the "AlamofireTests" target that is producing the error I mentioned above.
 It seems that changing the Base SDK in the Alamofire project build settings to "Latest iOS" fixes the issue, and it all builds fine.

However, I'm guessing this means it'll break on OS X projects. Any solutions or ideas?
  From time to time I get a bad access code 1 in Alamofire.swift, line 748:

```
credential = NSURLCredential(forTrust: challenge.protectionSpace.serverTrust)
```

I can't figure out the reason, it seems to happen at random.

Tested in the iPhone6 simulator, XCode 6.1.1.
  IPHONEOS_DEPLOYMENT_TARGET was set to 7.0 at the project level. Framework bundles require iOS 8 or later.

This change will not affect iOS 7 usage as that requires the direct inclusion of the source file.
  After switching from using Alamofire.xxx to using a Manager instance i realized that some functions signatures were missing for upload.

Those new convenience functions allow us to use Manager.upload functions directly without having our own

``` swift
private func URLRequest(method: Method, URL: URLStringConvertible) -> NSURLRequest {
    let mutableURLRequest = NSMutableURLRequest(URL: NSURL(string: URL.URLString)!)
    mutableURLRequest.HTTPMethod = method.rawValue

    return mutableURLRequest
}
```
  Hey @mattt, here is my first version of UIKit categories (UIImageView and UIButton so far) for Alamofire. I'm not sure if you were intending to include it eventually or you don't want this categories at all in Alamofire. 

If the case is the latter ignore the PR.
  I'm using this code in an app and in its today extension:

```
var defaultHeaders = Alamofire.Manager.sharedInstance.session.configuration.HTTPAdditionalHeaders ?? [:]
defaultHeaders["User-Agent"] = "MyUserAgentString"
let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
configuration.HTTPAdditionalHeaders = defaultHeaders
let manager = Alamofire.Manager(configuration: configuration)
```

This works perfectly in the app, but in the extension it seems like the configuration is not used, because the user-agent-string is the default Alamofire string.
 @cnoon I'd probably remove the 1.2.2 tag here since there was no code changes.
  It appears that Alamofire skips common name validation for SSL certificates. I didn't expect it to bypass default security features of `NSURLSession`.

Example test case:

``` swift
func testSSLCertificateCommonNameValidation() {
  let URL = "https://dwellingofduels.net/"  // had to be some unfortunate site to serve as an example, sorry

  let requestHeadExpectation = expectationWithDescription("HEAD \(URL)")

  Alamofire.request(.HEAD, URL)
    .response { (request, response, _, error) in
      requestHeadExpectation.fulfill()

      XCTAssertNotNil(request, "request should not be nil")
      XCTAssertNil(response, "response should be nil")
      XCTAssertNotNil(error, "error should not be nil")
      XCTAssert(error?.code == -1202, "error should be NSURLErrorDomain Code -1202 'The operation couldn‚Äôt be completed'")
  }

  waitForExpectationsWithTimeout(10) { (error) in
    XCTAssertNil(error, "\(error)")
  }
}
```

In `TaskDelegate` class, there's method

`URLSession(session: NSURLSession!, task: NSURLSessionTask!, didReceiveChallenge challenge: NSURLAuthenticationChallenge!, completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential!) -> Void)!)`

Inside the method, there's a `switch` statement with `case NSURLAuthenticationMethodServerTrust`. If I change the following line

``` swift
credential = NSURLCredential(forTrust: challenge.protectionSpace.serverTrust)
```

to

``` swift
credential = session.configuration.URLCredentialStorage?.defaultCredentialForProtectionSpace(challenge.protectionSpace)
```

, then the test passes.

I don't know `NSURLSession` and Alamofire well enough to assess if this is the correct way to solve the problem. Thoughts?
 I'm surprised this issue doesn't generate much interest. I am not a security expert so by all means stop me if I'm wrong, but what @tkareine highlights here looks to me like a major breach.

I see a `// TODO: Incorporate Trust Evaluation & TLS Chain Validation` (https://github.com/Alamofire/Alamofire/blob/master/Source/Alamofire.swift#L784), but isn't it what NSURLSession does by default?

I tested with a sample app, using Charles SSL proxy to tamper with TLS requests made by Alamofire. With the current code, I can do whatever I want without installing anything on my device. If I just change the `disposition` to be `. PerformDefaultHandling` in case of `NSURLAuthenticationMethodServerTrust`, the TLS handshake now fails and I have to install a rogue certificate on my device to tamper with the requests.

What that means to me is that any app using Alamofire can be trivially hacked by someone posing as a free wifi at Starbucks. Am I misunderstanding something?
  Hello, I'm integrating AF manually. (dragging the project as a sub-project and am following the directions to copy the framework properly)

While I can import AF fine with no errors, when I try to make a basic request, the compiler doesn't recognize any AF methods such as `Alamofire.request`

Upon Command+Clicking into the `import Alamofire` file, all I see is the following listed:

```
import Foundation

// Alamofire.h
//
// Copyright (c) 2014‚Äì2015 Alamofire (http://alamofire.org)
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var AlamofireVersionNumber: Double
```

Previous versions of AF worked fine and this is only occurring now that I'm using it in a new project. 

Any ideas?

Thanks,
 I ended up using Carthage and things are working again.  Thanks Matt

On Mon, Feb 9, 2015 at 7:28 AM, Mattt Thompson notifications@github.com
wrote:

> I cannot reproduce following the instructions provided in the README. If
> your application target supports dynamic frameworks (iOS >= 8), I would
> strongly suggest using CocoaPods or Carthage.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub
> https://github.com/Alamofire/Alamofire/issues/330#issuecomment-73500725.
 I solved this issue by changing the Build Active Architectures Only settings.
<img width="1440" alt="screen shot 2015-08-15 at 10 14 58 pm" src="https://cloud.githubusercontent.com/assets/3723510/9291686/5b7fd772-439c-11e5-964f-421da2a27e3a.png">
 @Ethanator If I follow your solution "Undefined symbols for architecture x86_64" this is what I get. Any idea ?
 I use AF from Cocopods. And I met this error also.
Delete the `Alamofire` folder. Run `pod install` again.
It worked.
 I had this problem, tried rearranging build phases, cleaning, shutting down Xcode and everything else I found that applied to Alamofire using submodule. After all of that, I selected Alamofire in the project navigator, selected the xcode project in the targets pane, set all 'Build Active Architecture Only' to No, and the project built and ran  It doesn't seem like GET requests are translating array params correctly.

```
    let params: [String: AnyObject] = ["q": ["one", "two"], "target": "en"]
    Alamofire.request(.GET, "https://www.googleapis.com/language/translate/v2", parameters: params)
```

generates the url:

q%5B%5D=one&q%5B%5D=two&target=en

I think it's trying to added []'s for the POST case.  But in the GET case it should be q=one&q=two
 This is intended behavior. Per the README.md,

> Since there is no published specification for how to encode collection types, the convention of appending [] to the key for array values (foo[]=1&foo[]=2), and appending the key surrounded by square brackets for nested dictionary values (foo[bar]=baz) [is used].

Instead of using GET, you should consider using POST or PUT and passing values via JSON, XML, or another well-defined format. This could require server side changes obviously.

If server side is out of your control, you should consider manually encoding these parameters instead.
 Yea it's the google api endpoint, so it's out of my control.  The google API doesn't like that format.  I can construct it manually, thought I'd file it though so you guys are aware.
  Could you please explain how to mock Alamofire responses?
 Such questions should be posted on stackoverflow (as the Readme suggests)

Here is basically the same question already up:
http://stackoverflow.com/questions/26918593/unit-testing-http-traffic-in-alamofire-app

@mattt 's last comment suggests the best solution imho.
  unknown option character `X' in: -Xlinker
 You can't create static libraries with Swift, and hence with Cocoapods (if you are using Swift afaik).
See my answer in #324 about the error you are getting.
  This pull request removes the two frameworks `iOS Alamofire` and `OS X Alamofire` and replaces them with a single `Alamofire` framework that can work for both platforms. It makes use of configuration files which allow per-platform build settings.

```
FRAMEWORK_SEARCH_PATHS[sdk=iphoneos*]        = $(inherited) '$(SDKROOT)/Developer/Library/Frameworks'
FRAMEWORK_SEARCH_PATHS[sdk=iphonesimulator*] = $(inherited) '$(SDKROOT)/Developer/Library/Frameworks'
FRAMEWORK_SEARCH_PATHS[sdk=macosx*]          = $(inherited) '$(DEVELOPER_FRAMEWORKS_DIR)'
```

I think this is far more elegant than having two frameworks called `iOS Something` and `OS X Something` and it makes integration simpler as you only have a single framework to worry about, not having a bunch of conditional (if iOS link `iOS Alamofire`, if OS X link `OS X Alamofire`).
 This single scheme and multi platform configuration is interesting.
But this make Alamofire inconvenient with multi platform projects using Carthage for managing frameworks.
I got answer from Carthage project that will not support this configuration.
Carthage/Carthage#307
  I am using cocoapods to add Alamofire and Google+ to my swift based project. Google+ SDK is working fine but when i added Alamofire it start giving me this error 'framework not found Alamofire'. I tried adding "$(PODS_ROOT)/Alamofire/Alamofire" to Framework search path but it doesn't worked. Please let me know what am i doing wrong here. Thanks.

![screen shot 2015-01-31 at 11 21 45 am](https://cloud.githubusercontent.com/assets/1227465/5989407/2b6bbce0-a93c-11e4-9b02-d20d739a9a8e.png)
![screen shot 2015-01-31 at 11 22 02 am](https://cloud.githubusercontent.com/assets/1227465/5989408/2b6bc1d6-a93c-11e4-8439-6cfe0a6d50d7.png)
![screen shot 2015-01-31 at 11 26 00 am](https://cloud.githubusercontent.com/assets/1227465/5989406/2b69c30e-a93c-11e4-954a-38ef2d52bf75.png)
![screen shot 2015-01-31 at 11 26 09 am](https://cloud.githubusercontent.com/assets/1227465/5989409/2b6d956a-a93c-11e4-8932-0f711b97202b.png)
![screen shot 2015-01-31 at 11 26 23 am](https://cloud.githubusercontent.com/assets/1227465/5989410/2b6dccf6-a93c-11e4-88d2-60895c6e1d8b.png)
  Update of #321

What I did:

```
open Alamofire.xcworkspace 
```

then

![screen shot 2015-01-30 at 13 17 37](https://cloud.githubusercontent.com/assets/736506/5971137/88131ae8-a882-11e4-9b2f-5badd893cea5.png)

This PR should fix CI failure!
  ...ile
  I know for using Alamofire on iOS7, I have to add alamofire.swift file and wrap every thing in 'public struct alamofire', and it works fine, But there is no  way to add configuration with Manager.

Is there any other way to add configuration or it's just missing?
 Pretty sure this is covered in the README already:

> For application targets that do not support embedded frameworks, such as iOS 7, Alamofire can be integrated by adding the Alamofire.swift source file directly into your project. Note that any calling conventions described in the 'Usage' section with the Alamofire prefix would instead omit it (for example, Alamofire.request becomes request), since this functionality is incorporated into the top-level namespace.

``` swift
let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
let manager = Alamofire.Manager(configuration: configuration)
```
 @kylef Yes, That's how I used Manager while coding for iOS8, but in iOS7, after adding "Alamofire.swift" in project, you don't have access to Manager(configuration: configuration) in your Project.
 This is working perfectly fine for me in a newly created test project:

![screen shot 2015-01-28 at 13 47 44](https://cloud.githubusercontent.com/assets/44164/5938589/5ffbe33a-a6f4-11e4-8c00-0c187c54e576.png)

I'd suggest going though the README and insure that you are integrating correctly.
 @kylef Thank You, But I get this error "Alamofire.type does not have a member named Manager"

![screen shot 2015-01-28 at 5 24 58 pm](https://cloud.githubusercontent.com/assets/3043068/5938760/4516b8a0-a713-11e4-83cc-d758a2863761.png)

I finally ended editing Alamofire.swift and passing configuration as parameter to "func request()" and creating manager in alamofire.swift. it's a dirty solution, but at least it's working.
 You shouldn't be prefixing anything with Alamofire, see this quote from the README:

> For application targets that do not support embedded frameworks, such as iOS 7, Alamofire can be integrated by adding the Alamofire.swift source file directly into your project.  Note that any calling conventions described in the 'Usage' section with the Alamofire prefix would instead omit it (for example, Alamofire.request becomes request), since this functionality is incorporated into the top-level namespace.
 @kylef I found that solution here : 
https://github.com/Alamofire/Alamofire/issues/266#issuecomment-71411903
But Yes, You are right, and I'm gonna edit my code based on README file, but again same error persist for Manager.
 @mattt  No, I ended up finding some dirty solutions,
I just add this issue, to get fixed in future updates.
  Simple improvement of code
  Hey @mattt,

I've been working on a library built ontop of Alamofire to handle oauth refresh as well as some really interesting data validation and parsing. Overall we have been extremely pleased with Alamofire. The design is fantastic and it has truly been a pleasure to get to work with it. I can't wait to see how this evolves over the coming months!

The latest feature I've been working on is background session support. When digging into how it should integrate into Alamofire, I've hit some roadblocks. A really great discussion took place a couple months ago in #194 which documents some of the challenges. After reading through that thread multiple times, I started down the path of adding support for background sessions in Alamofire.

The initial problem I ran into was that I could not set the `SessionDelegate` `sessionDidFinishEventsForBackgroundURLSession:` closure. I couldn't even get the `delegate` property on the `SessionManager`. After digging in deeper, I realized that all the session delegate closures you have added are basically placeholders. None of them are being set to do anything. All the implementation is built into the task delegates. Once I understood the challenges, I decided to crack the nut wide open to "attempt" to understand what your placeholder closures "could" be used for.
#### Internal Session Delegate

The first thing that had to change was to make the `SessionDelegate` public along with the SessionManager `delegate` property. For the future iterations of Alamofire, I'm not sure you can possibly keep this internal. The reason is that by locking down those delegate callbacks, we can't get in to override the default behavior, even if we have to. While I think it is awesome to get so much default behavior for free, it is certainly necessary in certain cases for us to be able to access the session delegate callbacks (background session finishing) through mechanisms other than the response Serializers.
#### Overriding Session Delegate Closures

The next step was to make all the `SessionDelegate` closures public as well so we can actually set them. That part was easy, but the more I dug into how those closures were used, the more problematic it became. I realized that the logic for calling those closures was only partially implemented. Not all of the closures were being called in the delegate methods.

What makes the most sense to me is to have the closures be public allowing users to override any of the `SessionDelegate` methods if they need to. It also seems that the `SessionDelegate` should always prioritize the closures over the internal Alamofire implementation. This is why I make sure to always call the closure before the internal implementation if it is not nil.

There were also some small bugs in the closure declarations (81c69be0, bbf16e17), a missing closure (8b6af2fc) and a missing data task delegate call (dfab3f3f) that I fixed up.
#### Background Completion Handler

The last change that I made (582267b9) was to actually add a `backgroundCompletionHandler` closure property to the `SessionManager`. I'm still a bit on the fence about this change. It's certainly not necessary, but is a nice-to-have. By adding the property, we can automatically set up the `SessionDelegate` `sessionDidFinishEventsForBackgroundURLSession` closure to call the handler if it exists.

``` swift
required public init(configuration: NSURLSessionConfiguration? = nil) {
    self.delegate = SessionDelegate()
    self.session = NSURLSession(configuration: configuration, delegate: delegate, delegateQueue: nil)

    self.delegate.sessionDidFinishEventsForBackgroundURLSession = { [weak self] session in
        if let strongSelf = self {
            strongSelf.backgroundCompletionHandler?()
        }
    }
}
```

The only issue with the default implementation is that it doesn't give you the chance to handle your events before the handler is called. To do that you'd need to override the `sessionDidFinishEventsForBackgroundURLSession` closure directly. I think that's what most people will need to do when using background session downloads / uploads. That's why I'm a bit on-the-fence about this change.
#### Closures in the Session Manager

Another approach to this would be to expose the delegate closures directly in the `SessionManager`. This would allow you to keep the `SessionDelegate` internal, yet allow users to override those methods if they need to. This just seems completely wrong though from a design standpoint which is why I didn't go with this approach.
#### Summary

I'd love to get your thoughts around this approach and to see if I interpreted your placeholder closures correctly. IMO, I love this approach because it exposes the session delegate callbacks while still hiding all the internals of all the task delegates which is where all your default logic resides. I think this strikes a really nice balance. Most users will never have a need to override any of the behavior. In the rare case that you need to and really understand what you're doing, you can.
 I need these features as well. I want to be able to change redirect behavior like https://github.com/Alamofire/Alamofire/issues/314, and I also want to change authentication challenge behavior. This seems like it would enable both of my requirements.
 Hi @hborders, I just pulled the upstream master commits into my background_sessions branch. Feel free to fork it or work off it for now until @mattt gets a chance to review this PR and #350. We've already moved to the fork for an internal library we've been building b/c we really need the background session support as well.
 Thanks. I don't need it immediately, but I'll need it in a few months. Just trying to get out ahead of things. Not trying to pressure @mattt, just upvoting the feature.
 Awesome, thanks @mattt!
   You should ask these types of questions on [StackOverflow](http://stackoverflow.com/questions/tagged/alamofire) and tag `Alamofire`.
  Line 55, pod 'Alamofire', ~> '1.1' throws a CocoaPods error.

Proper format appears to be " pod 'Alamofire', '~> 1.1' "
  Hi
I am using Alamofire library and I am experiencing an issue where the results are cached from the url response and they are not clearing up. 
Can you help with that ? 
Here is the repository link. https://github.com/punjitllc/punjitIOS/tree/Release2 and it keeps on causing issue on the UI feed for table. 
  ValidationTest.swift has one error(Could not build Objective-C module '')
![2015-01-19 2 27 00](https://cloud.githubusercontent.com/assets/6139704/5796704/855a9b9e-9fe7-11e4-9751-ede3e8fbad2d.png)
 A little more information would be helpful. Are you just trying to build the Alamofire project, or your own app? I just pulled the latest version, and every target compiles fine and tests pass.
Do you use the latest version?
Also, it looks like you are using Objective-C somewhere. AFAIK Alamofire is not meant to be used with Objective-C. Use the excellent AFNetworking library instead.
 OK,thank you very much.i understand
  I tried to add Alamofire ( ~> 1.1.3 ) using Cocoapods ( 0.36.0.beta.1 ) in a OS X project with a Yosemite deployment target.

When I run pod install, it fails because of:

```
The platform of the target `Pods` (OS X 10.10) is not compatible with `Alamofire (1.1.3)` which has a minimum requirement of iOS 8.0.
```

The problem may be related to the spec currently available on https://github.com/CocoaPods/Specs/blob/master/Specs/Alamofire/1.1.3/Alamofire.podspec.json. It doesn't have any OS X target so maybe Cocoopods fails to check my project with iOS 8.0   

```
"platforms": {
    "ios": "8.0"
}
```

I should also note that using

```
 pod 'Alamofire', :git => "https://github.com/Alamofire/Alamofire.git"
```

fixes the issue because it fetches the Podspec from Alamofire itself, but I cannot use it because I'm trying to create an OS X Pod with Alamofire as dependency. 
 OK,thank you very much.
  to avoid extra main-thread switching on each request
  Code Signing Identity for Release is set to iOS Developer instead of iOS Distribution. This is causing issue with automated build tools like Jenkin's. Recommend changing the Code Signing Identity -> Release -> Any iOS SDK to iOS Distribution.
 It is also a problem if the project that uses Alamofire has different configurations than just debug/release. The current suggestions for how to integrate alamo don't seem to work in this scenario.
  I use Alamofire framework as a git submodule.
If I open the my project in Xcode (6.1.1) using Alamofire framework then Git shows:
-- BlueprintName = "Alamofire"
++ BlueprintName = "Alamofire iOS"
After the updating to last version (SHA:048d2386743a8469d5ae5acf20d8985ac4afc5bd) the issue 
appeared.

I reproduced this issue in Example project of Alamofire repository.
 In Tag 1.1.3 the issue is not present.
 @acalisesi This is due to the name being changed for this target (and the introduction of an OS X target) in c421c818e6bc15013f092477e49bd17629cdcf3f.

The name is now `Alamofire iOS` for the target.
  Hey Mattt,

Following #293 I've created a second test target that runs the test on OS X as well.

The `testDownloadRequest` failed on OS X because `NSURLRequest.suggestedFilename` returns `100` and `100.json` on iOS and OS X respectively.

Note that running the test on OS X creates a `100.json` file in `~/Documents` since its not running sandboxed which is later deleted in `tearDown()`, not sure if this is a problem in practice.
 The tests do pass locally and should pass on travis once Xcode 6.1.1 is available there.
 I can't get the OS X tests to pass on travis, removing them again for now to show that 640f8921fcef1afdd58744ac6544c8d8b90b399e actually fixes the travis build for the iOS test target.
 Great, thank you!
  hi, I'm trying to download some file, but api required some parameters and header, I'm trying like below 

```
        var headers = Alamofire.Manager.sharedInstance.session.configuration.HTTPAdditionalHeaders ?? [:]
    headers = [ "X-XXXX-API-Key" : "XXX",
        "X-XXXX-Identifier-Token" : "XXX",
        "accept":"application/json"]

    let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
    configuration.HTTPAdditionalHeaders = headers

    let manager = Alamofire.Manager(configuration: configuration)
    let destination = Alamofire.Request.suggestedDownloadDestination(directory: .DocumentDirectory, domain: .UserDomainMask)
    manager.download(.GET, "http://someURL.com/stream/api/doc?id=XXX&date=2015-01-05", destination: destination)
        .progress { (bytesRead, totalBytesRead, totalBytesExpectedToRead) in
            println(totalBytesRead)
        }
        .response { (request, response, _, error) in
            println(response)
    }
```

but it says "Extra Argument in Call"

How can I do that?
 Usually "Extra Argument in Call" is not the actual error in my experience but often the underlying problem is that you have the parameter types for functions wrong.
  When adding Alamofire in cocoapods, it's only possible when the iOS deployment target is 8.0. But Alamofire itself can be used in iOS 7, so I think the podspec should be changed...?
 Ok√©, thx!
  Inside the public class method `defaultHTTPHeaders` when the accepted language parameter is built, you are using the language ID array returned by `NSLocale`'s `preferredLanguages` that:

> Returns the user's language preference order as an array of strings.

But I think that, for a default value, is more correct to extract the codes from `NSBundle`'s `preferredLocalizations` array that contains:

> An array of NSString objects containing language IDs for localizations in the bundle.

In my opinion in most cases this library is used for API requests and is better that the results are in a language coherent with the actual language used by the UI of the app.
  I know embedded frameworks only work on ios 8+ but I think the podspec should reflect the minimum needed target. 

More info: In my case, I'm targeting ios7 and I'm still using embedded frameworks since it works on dev. For releasing I'll probably create a script later that moves the .swift files from the embedded framework to the target project.
 @Reflejo This will cause the podspec to fail validation with CocoaPods 0.36.0. See https://github.com/CocoaPods/CocoaPods/issues/2963
 @kylef Right, I guess it makes sense for now until there is another way on cocoapods to allow private builds targeting iOS7. For anyone reading this: [This is relevant](https://github.com/CocoaPods/CocoaPods/issues/1241)
  I'm a complete beginner with ios development, so apologies in advance if I'm asking something totally incorrect or obvious. I realize this question has been asked before, but that was before Cocoapods supported swift so the solution might be different now.

Since Cocoapods beta now supports swift packages, I've been trying to install Alamofire with it. Cocoapods works with several other swift packages, such as SwiftyJSON (the one I've personally tested), but with Alamofire, I keep on getting the error "could not build objective-c module 'Alamofire'". I'm assuming it's an Alamofire issue (so I'm posting here instead of stack overflow) since Cocoapods works with other swift packages. Is Alamofire missing something that tells xcode that it's a swift module rather than a objective-c module? 
 Hmm, it must be something with my project setup. I just created a new "single view application", `pod init`, added pod 'Alamofire' to the Podfile, `pod install`, added `import Alamofire` to the ViewController, and it works. To my knowledge, the only difference between this new project and the previous one is that this new one doesn't have a bridging header.
 Turns out, it was an issue with the neither. It was fixed by clearing out the build folder with `Command-Option-Shift-K`. Apparently there was something leftover from when I followed the older instructions in the Alamofire readme.

Anyways, CocoaPods and Alamofire seem to work together perfectly now.
 That helped me out. Thanks @aaronz8.
  It would make sense to be able to create a serializer that can for example return a `struct` from a response.
Since _Alamofire_ uses `AnyObject?` for Serializers this seems not possible.
Is there any particular reason, why this has to be an object type?

~~Switching out `AnyObject?` with `Any?` in the right places crashes the compiler with a segmentation fault though.~~ This is produced by the JSON and PLIST Serializers when using `Any`

Not sure why the cast from AnyObject? to Any? fails here:
`let JSON: Any? = NSJSONSerialization.JSONObjectWithData(data!, options: options, error: &serializationError)`
 I'm interested in this too.
 Something like this could work @mattt ?

https://github.com/bilby91/Alamofire/commit/2c88aeb83aa3846b2cf4d9da6ce626fb42e7aaf5
 +1 I hit this wall when I was trying to add a `Serializer` for a struct which conforms to a protocol `Decodable` from another framework `Argo`. So there's really nothing I can do to change the protocol.

@cnoon If I want to help with this, could you give me some guidance on how can it be done and what should be considered?
 I wrote a workaround using a Box class to wrap the structs. I took some shortcuts with the json part but you can get the general idea.  https://gist.github.com/jqsilver/82a515bfaca9a8552ad0
  NOTE: This PR first requires PR #290 to get merged.

I built a `UIImageView` extension with a supported `ImageCache` based off the `AFNetworking` `UIImageView` category. There are certainly some modifications, but the general idea and interface is the same. In Swift, we can't support a custom image response serializer unless we wrap the object inside some `NSObject` subclass in order to attach it to the `UIImageView` as an associated property. Curious to see what your thoughts are there.

I also made the assumption that you would like to start splitting `UIKit` extensions into separate Swift files and placing them in the iOS target. I could certainly modify this approach and wrap the entire set of logic in `#if os(iOS)` blocks if you would rather use that approach. This would also allow us to share the `ImageCache` logic with `OSX` if you wanted to. Had to start somewhere...
 Just as a heads up, I've started working on a separate library `AlamofireImage` to contain all this logic. If you're interested, see #290 for more details.
  This is my attempt at #212 and adds a new shared target for OS X 'Alamofire OS X' which uses the same Info.plist as the iOS target. I've renamed iOS target to 'Alamofire iOS'. I've verified in an app that it works on both platforms.

Given the following `Cartfile`:

```
github "mk/Alamofire"
```

Running `carthage bootstrap` against this outputs:

```
*** Checking out Alamofire at "1.1.6"
*** xcodebuild output can be found in /var/folders/lk/q34wnz8j0h93pc7rlck4stnc0000gn/T/carthage-xcodebuild.it0PZY.log
*** Building scheme "Alamofire iOS" in Alamofire.xcworkspace
*** Building scheme "Alamofire OSX" in Alamofire.xcworkspace
```
  Caching isn't working. Here is my setup:

``` swift
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {
        let URLCache = NSURLCache(memoryCapacity: 20 * 1024 * 1024, diskCapacity: 100 * 1024 * 1024, diskPath: nil)
        NSURLCache.setSharedURLCache(URLCache)
        return true
    }
```

I then have a button on a ViewController that calls the following code:

``` swift
var nsurlreq = NSMutableURLRequest(URL: NSURL(string: "http://api.randomuser.me/")!, cachePolicy: NSURLRequestCachePolicy.ReturnCacheDataElseLoad, timeoutInterval: 100)
Alamofire.request(nsurlreq).responseJSON { (request, response, json, error) in
    println(json)
}
```

I have also tried this:

``` swift
let config = NSURLSessionConfiguration.defaultSessionConfiguration()
config.URLCache = NSURLCache.sharedURLCache()
config.requestCachePolicy = NSURLRequestCachePolicy.ReturnCacheDataElseLoad
manager = Alamofire.Manager(configuration: config)
manager!.request(nsurlreq).responseJSON { (request, response, json, error) in
    println(json)
}
```

I have also tried using UseProtocolCachePolicy instead of ReturnCacheDataElseLoad and calling an endpoint with the header "Cache-Control: max-age=600, private".

The request/response never gets written to the cache. If the response is already in the cache, it retrieves it just fine... but never writes it (which is odd).

If I use the following code to make the call instead of Alamofire, the caching works fine:

``` swift
var nsurlreq = NSMutableURLRequest(URL: NSURL(string: "http://api.randomuser.me/")!, cachePolicy: NSURLRequestCachePolicy.ReturnCacheDataElseLoad, timeoutInterval: 100)
NSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue.mainQueue()) { (res, data, error) -> Void in
    let json = NSJSONSerialization.JSONObjectWithData(data, options: nil, error: nil) as NSDictionary
    println(json)
}
```
 Had the same issue on iOS 8.2.
I ended up saving the response to the shared cache manually.
Posted my solution to the [Stack Overflow question](http://stackoverflow.com/questions/27785693/alamofire-nsurlcache-is-not-working) that Mattt mentioned above.
 I have the same problem I have tried all of the approaches in the stack overflow post: 

```
  // create a mutable URL request.
        let mutableURLRequest = NSMutableURLRequest(URL: NSURL(string: url.URLString)!, cachePolicy: cachePolicy, timeoutInterval: timeout)
        mutableURLRequest.HTTPMethod = requestBuilder.method.rawValue
        mutableURLRequest.addValue("private", forHTTPHeaderField: "Cache-Control") 

 Manager.sharedInstance
            .request(mutableURLRequest)
            .response {(request, res, data, error) in
                    let cachedURLResponse = NSCachedURLResponse(response: response, data: (data as! NSData), userInfo: nil, storagePolicy: .Allowed)
                        NSURLCache.sharedURLCache().storeCachedResponse(cachedURLResponse, forRequest: request)}

```

When I turn off wifi on the phone I'm not getting any cached responses.
 Great! Thanks.
 Can someone tell me how to use NSURLCache with alamofire?
The answer posted [here](http://stackoverflow.com/questions/27785693/alamofire-nsurlcache-is-not-working) is pretty vague and looks more like a hack.

Can someone post a snippet here.
 Can someone help me on this?
 I believe the README mentions, Alamofire doesn't handle caching directly since it uses NSURLSession under the hood and that has caching built in for HTTP and HTTPS requests. I believe there are some links to helpful stackoverflow questions in this thread and a link in the README to Apple's documentation. 
 http://nshipster.com/nsurlcache/
  This PR is to make the document of `responseString` nicer :]
  Hey @mattt,

We need this functionality for a networking library we're building internally. The more I worked through it, I began to think this made more sense to live directly inside `Alamofire` rather than be an outside extension. I'm very interested to see if you agree. The only downside is that UIKit ends up being a dependency and I'm not sure how you feel about that. Either way, I based the inflation logic off of AFNetworking and ported it to Swift. I have it built inside a test app and it works flawlessly. I've also profiled it to make sure the inflation logic is running on the proper Alamofire queue.

Cheers,
Christian
 UIKit (iOS) shouldn't be a _hard_ dependency, it could be wrapped in `#if os(iOS)`. This library should still work on OS X.

I think there should be a `imageResponseSerializer` for OS X using NSImage too so the APIs are identical on both platforms.
 All great points @kylef. I will take a look today at adding support for `NSImage` as well. At the very least, I will certainly wrap all the current logic in a `#if os(iOS)` as you mentioned.
 Hey @kylef, I just added `NSImage` support in commit f2f7f98f.
 Hey @mattt, I'd love some feedback here when you get a chance. I would assume most users are going to want to be able to do this, I'm just not sure how you would like to expose this type of functionality. Do you want `UIKit` types of Serializers to live inside Alamofire directly? Thanks!
 Hey @mattt, I wanted to ping this again since it's been open for a month now. It would be awesome if we could get some feedback on some of these open PRs. Thanks dude as always!
 +1 This looks great. I really need to use this. @cnoon, until it get's pulled in, have you thought about taking this and #294 and making your own CocoaPod? I would love to see that.
 +1

I think this functionality would be a great addition to Alamofire.

If Mattt doesn't want this in Alamofire for some reason, I agree that a separate CocoaPod would be a reasonable compromise too.
 I noticed that it doesn't appear there are any unit tests in the pull request for this...?

@mattt, Would adding unit tests help get this into Alamofire?

I'm willing to help write these if it would help move this along. :)
 Just as a heads up for everyone, I've started working on a separate library `AlamofireImage` to contain all the response image serializers (this PR) along with the UIKit extensions (#294) and some other cool stuff. I'd say it's about 60% done at the moment. I'm planning on having this wrapped and released by the end of March at the latest to give everyone a sense of when this should be available.

I wanted to let everyone know (especially @AnthonyMDev and @JRG-Developer) in case they are waiting on this functionality or considering duplicating efforts.
 That's great! Thank you @cnoon !
Maybe we can make it cross platform and support OS X as well!
 Thanks @cnoon! I'm definitely waiting on this functionality! If there is anything I can do to help, please feel free to contact me!
 @cnoon Any word on `AlamofireImage`?
 Hey @AnthonyMDev, I have actually completed the majority of the library, but we're still trying to figure out exactly how to roll out it out. Once I have more details, I'll be sure to update this PR. Until then, please hang tight.
 @cnoon Thanks for the update. I will be waiting impatiently! ;)
 @cnoon Awesome, I really need this! Thanks so much, I can't wait for the release! ;)
 Hey @cnoon , any update on releasing this? I'd still really like to use it. Thanks.
 @cnoon I guess there are a few people waiting ;)

BTW You are all doing an incredible job pushing this library forward. You are doing so many people a big favor here! Thanks!
  I'm trying to HTTP POST to a server using your lib and I'm getting the following error when doing a HTTP POST:

`2015-01-05 19:37:07.137 PIPiOS[1021:26574] CFNetwork SSLHandshake failed (-9805)
2015-01-05 19:37:07.540 PIPiOS[1021:26574] CFNetwork SSLHandshake failed (-9805)
2015-01-05 19:37:07.942 PIPiOS[1021:26574] CFNetwork SSLHandshake failed (-9805)
2015-01-05 19:37:07.943 PIPiOS[1021:26574] NSURLConnection/CFURLConnection HTTP load failed (kCFStreamErrorDomainSSL, -9805)
<NSMutableURLRequest: 0x7f99425177c0> { URL: https://kmis.brookes.ac.uk/csms/w_secure.login }
nil
Optional(Error Domain=NSURLErrorDomain Code=-1200 "The operation couldn‚Äôt be completed. (NSURLErrorDomain error -1200.)" UserInfo=0x7f9944859110 {NSErrorFailingURLStringKey=https://kmis.brookes.ac.uk/csms/w_secure.login, NSErrorFailingURLKey=https://kmis.brookes.ac.uk/csms/w_secure.login, _kCFStreamErrorDomainKey=3, _kCFStreamErrorCodeKey=-9805, NSUnderlyingError=0x7f994259f3c0 "The operation couldn‚Äôt be completed. (kCFErrorDomainCFNetwork error -1200.)"})
2015-01-05 19:38:25.115 Oxford Brookes[1021:27197] Terminating since there is no system app.`

I was previously using the SwiftHTTP library and getting the same error. HTTP POST works fine through Java and PHP so I know there isn't anything wrong with the server. Any idea why this is happening?

PS: I'm testing on iOS Simulator targeting iOS 8.1, and yes I've checked date/time and it's fine
 Works just fine with Python as well, I'm definitely sure there's nothing wrong with the server configuration. I was hoping for an setAllowsInvalidSSLCertificate (as in your other lib) equivalent. 

My code and other details can be found here: https://github.com/daltoniam/SwiftHTTP/issues/43

Anyway, thanks
  I have tried about 7 times and in different ways to import this into my new project, and never works correctly. The project will build, but code completion doesn't work at all ever for this. It only completes the error domain and version number. If I type Alamofire and then .request it will complete that but if its not completing Alamofire then there must be something wrong? Its just very annoying to me for this not to work like it should.
 Same error.
 I did have `import Alamofire` at the top, that did nothing. Also I do not use CocoaPods or Carthage. Seems kind of stilly if it cannot be imported easily manually.
 @mattt @MaxHasADHD @sybex  I took my time to do a video, its not the best tutorial video but you can get an idea how to install this. https://www.youtube.com/watch?v=HJu0aIdJawk
  Bump podspec Alamofire version to latest release
  I wrote a wrapper around Alamofire to be used by my controllers written in both swift and objective c

Everything works fine in both objective-c and swift,  except in certain cases I need to pass the request object to the controller, in case the controller needs to cancel the request.

the problem is since the Request class is not marked with @objc compiler won't generate the method in the header, and therefore I can't use it on my Objective C code.

``` swift
public func fetchObject <T: AnyObject>(type: T.Type, path: String, completion: (T?, NSError?)->()) -> Request {

   let request = Manager.sharedInstance.request(requestWithPath(path, method: .Get, nil: parameters))

   request.responseJSON { (request, response, json, error) in

      if let anError = error {
         completion(nil, anError)
      }
      else {
         var convertedObject = ObjectMapper.sharedInstance().objectFromSource(json, toInstanceOfClass: type) as T?
         completion(convertedObject, nil)
      } 
   }

   return request
}
```
  Hi @mattt, thanks for Alamofire

I'm not an expert on functional programming I really engage with this topic a few month ago but I find the way they approach problem really interesting.

Do you see the talk from @jgallagher at [Functional Swift Conf](https://www.youtube.com/channel/UCNFUO_7gsLBk4YTmZoSTk5g?spfreload=10) called [Networking with Monads](https://www.youtube.com/watch?v=LqwrUmuodyY) ?
In this talk he explain the concept of deferred request which is a really interesting idea.

Do you think the [Deferred](https://github.com/bignerdranch/Deferred) mechanism as it place into Alamofire ?
Do you think you will add functional programming style stuff in Alamofire in the future ?
    My post request with alamofire is not sending the parameters!! This is my request:

```
func login(username: String!, password: String!, callback: (NSError?, AnyObject?) -> Void) {
        var params = [
            "login": username,
            "password": password
        ]

        Alamofire.request(.POST, baseURL+"login", parameters: params)
            .validate()
            .responseJSON {(request, response, data, error) in
                if(error != nil) {
                    var errMsg = data?["error"] as String

                    println(response?.statusCode)
                    println(errMsg)
                }
        }
```

And i'm getting from the server

```
Invalid login: undefined
```

The request data in responseJSON function is 

```
<NSMutableURLRequest: 0x7f8d4b751670> { URL: https://smarttbot.com/api/v1/login }
```

I already tried pass encoding: .JSON in the request function, but the problem persists! What i'm doing wrong?
  In other languages this is basic functionality, but it seems its a bit more difficult to pull of in Swift/Objc. It would be cool if Alamofire could honor the nsurlsession.connectionProxyDictionary and implement this functionality. 
 We use a firewall and this sort of feature would be very helpful for me
 +1
 Yes it appears to pass the proxy to the dictionary, which can even be verified by printing the proxy dictionary to the console once the Manager is instantiated.  However, with the dictionary passed with the correct keys as mentioned here: 

https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFProxySupport/index.html#//apple_ref/doc/constant_group/Property_Keys
the request appears to use my machine's ip :  http://prntscr.com/5muqk6

I have tested to verify that the proxy indeed works.
 Thanks Mattt, I'll continue my research and let you know. 
 Unrelated to Alamo but, @mikenolimits, did you ever found a solution for this? I'm starting to think NSURLSession is bugged or we (any many others) are doing something terribly wrong. I'm having the exact same issue.
 @mikenolimits  + in my case, only HTTP/S proxies had this issue, SOCKS is working perfectly fine
 @valentinradu HTTP/S proxies works fine in my case using charles to verify.
code like this:

```
    var proxyConfiguration = [NSObject: AnyObject]()
    proxyConfiguration[kCFNetworkProxiesHTTPProxy] = item.host
    proxyConfiguration[kCFNetworkProxiesHTTPPort] = port
    proxyConfiguration[kCFNetworkProxiesHTTPEnable] = 1
    let sessionConfiguration = AFManager.sharedInstance.session.configuration
    sessionConfiguration.connectionProxyDictionary = proxyConfiguration
    manager = Alamofire.Manager(configuration: sessionConfiguration)
```

and item 

```
 struct ProxyItem: Equatable, Hashable {
            let host: String
            let port: String
            let HTTPOnly = true

            var hashValue: Int {
                return host.hashValue ^ port.hashValue
            }
        }
```

In my case:
host: 10.x.xx.xx
port: 8888

One point according to the apple doc is that,  you should create a new URLSession when you changed the configuration. while using `Alamofire`, you should using a new Alamofire.Manager
  As shown here, I have attempted to replace the NSURLSession with my custom session that contains a proxy dictionary, however, when I query my API, I still get my machine's IP. Is Alamofire not honoring the custom session? 

http://stackoverflow.com/questions/27651567/setting-proxy-with-alamofire-session
  CocoaPods [officially](http://blog.cocoapods.org/Pod-Authors-Guide-to-CocoaPods-Frameworks/) supports Swift libraries now. Even though its still in beta, it works fine and there's a few third party Swift libraries already supporting CococaPods.

Can you add Alamofire to CocoaPods as well? 
 Moya uses Alamofire and it works fine with 0.35 of CocoaPods.

http://artsy.github.io/blog/2014/11/13/eidolon-retrospective/

It probably helps that Orta is a key CocoaPods person as well. ;)

Fuad Kamal
Anaara LLC
www.anaara.com
240.515.7578 (m)
214.279.1890 (f)
twitter: @flexRonin
behance: https://www.behance.net/fuadkamal
linkedIn: linkedin.com/in/anaara
photography: http://500px.com/fuad2

> On Dec 30, 2014, at 7:48 AM, Isuru Nanayakkara notifications@github.com wrote:
> 
> CocoaPods officially http://blog.cocoapods.org/Pod-Authors-Guide-to-CocoaPods-Frameworks/ supports Swift libraries now. Even though its still in beta, it works fine and there's a few third party Swift libraries already supporting CococaPods.
> 
> Can you add Alamofire to CocoaPods as well?
> 
> ‚Äî
> Reply to this email directly or view it on GitHub https://github.com/Alamofire/Alamofire/issues/280.
 @Isuru-Nanayakkara there is already a pull request tracking this: #218

@abunur Eidolon doesn't use CocoaPods 0.35, it uses CocoaPods from the Swift branch from git (which is what 0.36 is). https://github.com/artsy/eidolon/blob/1d1d72f540f20571d7805e210d31eca2b3b0e077/Gemfile#L3
 thanks for the clarification on this.  When I built Eidolon locally Ash told me they are using the ‚Äòbleeding edge‚Äô version of Cocoa pods, i.e. `gem install cocoapods ‚Äîpre`

installs the version of CocoaPods that you need to build it, or least that‚Äôs what I interpreted what he said as far as how to get the right version up. I did this and it works fine for me, but I‚Äôm also using their build scripts without which I could never get the project up and running.  I‚Äôm still a newb and totally lost when it comes to the Ruby stuff though so I guess I‚Äôve missed something.  When I call ‚Äúpod --version‚Äù from the command line it tells me I‚Äôm running 0.35.

thanks

Fuad Kamal
Anaara LLC
www.anaara.com
240.515.7578 (m)
214.279.1890 (f)
twitter: @flexRonin
behance: https://www.behance.net/fuadkamal
linkedIn: linkedin.com/in/anaara
photography: http://500px.com/fuad2

> On Dec 30, 2014, at 11:23 AM, Kyle Fuller notifications@github.com wrote:
> 
> @Isuru-Nanayakkara https://github.com/Isuru-Nanayakkara there is already a pull request tracking this: #218 https://github.com/Alamofire/Alamofire/pull/218
> @abunur https://github.com/abunur Eidolon doesn't use CocoaPods 0.35, it uses CocoaPods from the Swift branch from git. https://github.com/artsy/eidolon/blob/1d1d72f540f20571d7805e210d31eca2b3b0e077/Gemfile#L3 https://github.com/artsy/eidolon/blob/1d1d72f540f20571d7805e210d31eca2b3b0e077/Gemfile#L3
> ‚Äî
> Reply to this email directly or view it on GitHub https://github.com/Alamofire/Alamofire/issues/280#issuecomment-68370568.
 Hi,

am I doing something wrong?...

```
> pod --version
0.36.0.beta.1
> pod install
Analyzing dependencies
[!] Unable to find a specification for `Alamofire`
```
 @jsuder I don't think the pod spec is submitted to the master specification repository.

Try this until it is:

``` ruby
pod 'Alamofire', :git => 'https://github.com/Alamofire/Alamofire'
```
  This branch runs the tests and builds the example project to ensure it hasn't been broken. It includes the scheme's so it can be built from the command line.

Be sure to enable travis before merging.
  To maintain logical data integrity, the progress state of Request object should be changed before it will be available for delegates.
  how to set Accept:application/json or set "Content-Type" as "application/json",Thanks
  As of [0.36.0.beta.1](073888038b01bd1dd9c99537313ff1c9b44b86ec), CocoaPods supports Frameworks and Swift source files

I tested it with a basic project with the local podspec file. I wasn't sure if I needed to include the `.h` files as well to `s.source_files`. Let me know if I should make that change.
  Return nil download file destination to avoid excess moving of temporary file from itself to itself if we have not provided any download folder.
 The idea was to not copy downloaded file if we don't need it. Optional return value describes this case better than copying in itself. Or we could rather make destination parameter of download function optional.

```
destination: Request.DownloadFileDestination?
```
  Enabling this setting will allow use in extensions.
  Hello, I've included Alamofire to a project by following instructions in the README : git submodule add ...

The problem I have is that when I try to commit my project, I get an error message from Xcode: 

error: pathspec 'Alamofire/Alamofire.xcodeproj/project.pbxproj' did not match any file(s) known to git.

(Xcode : Version 6.1.1 (6A2008a), Yosemite 10.10.1)
  I both set my app's deployment target version and Alamofire framework target version to 7.0, success with exporting ad-hoc ipa file, but get error when submitting to iTunesConnect, see attachment:
![alamofire](https://cloud.githubusercontent.com/assets/2620575/5500738/923e5432-8786-11e4-80c1-f951baf22706.png)
  Sorry, I had post my question on [StackOverflow](http://stackoverflow.com/questions/27560445/how-to-enable-ssl-connections-in-alamofire)  
  I ran across an interesting crash case today that I wanted to get in front of the community. While I don't think it's incredibly likely that you will have too many people run into this case, I actually did today and thought I'd write a failing test for it that reproduces the crash.

The test creates a manager and then a request with that manager. The manager is then released before the request task is ever started. The `deinit` of the manager stack crashes every time.

I ran into this case because I wrote some integration tests where I was forgetting to cancel the request if I didn't end up running it. I was surprised that forgetting to resume the request actually causes the `deinit` to crash.

I haven't quite been able to figure out how to fix this case yet, but I wanted to at least get the test submitted to get some more experienced Alamofire eyes on the problem.
 Hello

I'm glad you bring the subject, I had similar discussion yesterday with  my friend. My question was: is the deinit of manager the right place to do the cleaning of NSURLSession?

Here is the tests we did:
https://github.com/cvasilak/AlamofireTest/blob/master/AlamofireTest/ViewController.swift#L23

We did 2 uploads:
-  the first one instantiating manager using the custom syntax, using  a local variable. The task get cancelled as soon as the local variable get deinitialized
- the second syntax using the function approach following the builder/fluent API pattern, the instance get return from each function, then the denit occurs later leaving the task time to complete.

I'll love to hear your view on that issue.
++
Corinne
 Or another suggestion, why not replacing the content of deinit by:
self.session.finishTasksAndInvalidate()
instead of:
self.session.invalidateAndCancel() 
  Unless there is a reason not to, would it be possible to check that box in the general tab of the Alamofire framework?
I'm interested in understanding the reason why it would not be a good idea if possible.
 If your `Alamofire.xcodeproj`, select the `Alamofire.framework` target, then select the `General` tab.
Under `Deployment Info`, there is a checkbox named `App Extensions [ ] Allow app extension API only`. When linking Alamofire with an app extension, Xcode throws a warning telling you that you're using a framework that may contain the use of APIs that are ineligible for use in an app extension. To suppress this warning, you check the box described above.

This is explained in the App Extension Programming Guide's [Handling Common Scenarios](https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html) section.

Please take a look at the following screenshot:
![](http://puu.sh/dB1CM/e310982cb2.png)

I understand that there may be valid reasons why not to check this box. However, if there are none, it would be great if Alamofire could check that box indicating that it is safe to use this library in app extensions as opposed to users to check that box manually on their side.
 Sweet! Thanks @mattt !
  Have no problem to work with Alamofire on ios7. But when trying to Archive project using Xcode6.1 for upload to itunes connect I get following error. Do you know what is wrong? Thank you

![alamofire](https://cloud.githubusercontent.com/assets/460056/5476703/d48cd8da-8624-11e4-8197-1fd7c1a45cd5.png)
 So what is the solution? do you mean that  if we use Alamofire , our app can not  support ios7  when we submitting to ItunesConnect?
 I have come to the same issue. What's the solution?
 Check out the source file section in readme.md file if using Alamofire targeting ios7. You can't use embedded frameworks.

On Jan 25, 2015, at 3:07 PM, amirhabibz <notifications@github.com<mailto:notifications@github.com>> wrote:

I have come to the same issue. What's the solution?

## 

Reply to this email directly or view it on GitHubhttps://github.com/Alamofire/Alamofire/issues/266#issuecomment-71398783.
 delete the embedded frameworks and copy Alamofire.swift file to your project then add struct to the Alamofire.swift like below: 

struct Alamofire {
    static let manager = Manager.sharedInstance
    static let URL = ParameterEncoding.URL
} 

and when you use Alamofire API use like this:
  Alamofire.manager.request(.GET, url2).responseJSON {(request, response, JSON, error) in ...
this is working  for me 
 Thank you. I followed the tutorial on github. I deleted the frameworks and
put the source code inside.

On Sun, Jan 25, 2015 at 10:50 PM, EzimetYusup notifications@github.com
wrote:

> delete the embedded frameworks and copy Alamofire.swift file to your
> project then add struct to the Alamofire.swift like below:
> 
> struct Alamofire {
> static let manager = Manager.sharedInstance
> static let URL = ParameterEncoding.URL
> }
> 
> this is working for me
> 
> ‚Äî
> Reply to this email directly or view it on GitHub
> https://github.com/Alamofire/Alamofire/issues/266#issuecomment-71411903.
 Hm, I target iOS8 and still get this problem. maybe I miss something here?
 Anyone stuck this like me just remove all framework and let's pod handle the ness, work for me.
  I wrote a helper class with which I make all my requests to a server. Most of the requests within this helper class work just fine, but one specific request is failing all the time.

Here's some of the code from my helper class:

``` Swift
let responseHandler = { (request: NSURLRequest, response: NSHTTPURLResponse?, object: AnyObject?, error: NSError?) -> Void in
    println("request: \(request) || response: \(response) || object: \(object) || error: \(error)")
}

// make custom request
let request = NSMutableURLRequest(URL: NSURL(string: fullPath)!)
request.HTTPBody = NSJSONSerialization.dataWithJSONObject(["session_key": "ABC"], options: nil, error: nil)
request.HTTPMethod = "GET"
request.allHTTPHeaderFields = ["Accept": "application/json", "Content-Type": "application/json"]

Alamofire.request(request).response(responseHandler)
```

Here's the output from the `println` line in the above code:

```
request: <NSMutableURLRequest: 0x1702007e0> { URL: http:/wolverine.movie-assistor.staging.c66.me/user } || response: nil || object: Optional(<>) || error: Optional(Error Domain=NSURLErrorDomain Code=-1017 "The operation couldn‚Äôt be completed. (NSURLErrorDomain error -1017.)" UserInfo=0x1702ea780 {NSErrorFailingURLStringKey=http://wolverine.movie-assistor.staging.c66.me/user, NSErrorFailingURLKey=http://wolverine.movie-assistor.staging.c66.me/user, _kCFStreamErrorDomainKey=4, _kCFStreamErrorCodeKey=-1, NSUnderlyingError=0x174240240 "The operation couldn‚Äôt be completed. (kCFErrorDomainCFNetwork error -1017.)"})
```

I tried resetting Simulator (since I read somewhere it might be a Simulator issue) and tried on my iPhone 6 ‚Äì but the problem still stays the same. Trying the same URL with the `CocoaRESTClient` worked fine, so I doubt it's an issue on the server side (leaves to the expected response `{"session_key" : "missing"}`).

Anyone know what the issue is?
 At first look I thought it's an issue with Alamofire. But I solved it in the meantime and you were right, it wasn't an Alamofire issue. See [here](http://stackoverflow.com/questions/27531259/nserrorfailingurlstringkey-kcferrordomaincfnetwork-error-1017-for-specific-re/27531876#27531876) on Stack Overflow for more information. Sorry for the inconvenience.
 at first check your network connection after that restart your simulator..
it's worked with me. 
  I have a dict with mixed values (strings, bools). When i encode the dict ([String: AnyObject])

``` swift
ParameterEncoding.URL.encode(mutableURLRequest, parameters: parameters.toDictionary()).0
```

The bool values are represented like ints (1 or 0). How can i use them like strings (true or false).
  I've gone over the install procedures again and again, but I still get "No such module".

Project has been added under my project, deployment target is the same (8.1) for both, under my build target for the main project I've added Alamofire under Target Dependencies, Link Binary With Libraries and I've added the Copy Frameworks step, set Destination to Frameworks and added the Alamofire.framework in there.

Cleared build dir, removed derived data dir, and yet when I try to do "import Alamofire" I get told there is no such module. If I do a normal build of my project or just Alamofire it builds just fine.

I'm at a complete loss here as to what to do.
 I was getting this error when I had "Build Active Architectures" set to NO for debug builds. Switching it to YES and ensuring the release builds were set to NO fixed the problem.
 I am getting the same error only when I archive in Release mode. It works perfectly fine in Debug mode as well as build in Release mode. But Archive in release mode fails. Any idea what could be the issue?
 Same for me. I can debug but I cannot archive my adhoc.
 Same error! Any help?  Cause I want to save some cookies and make Custom UserAgents, I've followed [this issue ](https://github.com/Alamofire/Alamofire/issues/111), and made a custom manager like this

```
    var cfg = NSURLSessionConfiguration.defaultSessionConfiguration()
    var cookies = NSHTTPCookieStorage.sharedHTTPCookieStorage()
    cfg.HTTPCookieStorage = cookies
    cfg.HTTPCookieAcceptPolicy = NSHTTPCookieAcceptPolicy.Always
    cfg.HTTPAdditionalHeaders = ["Accept-Encoding": "gzip;q=1.0,compress;q=0.5",
        "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36", "Accept-Language":"zh-CN,zh;q=0.8,en;q=0.6,zh-TW;q=0.4"]
    var mgr = Alamofire.Manager(configuration: cfg)
    var parameters:[String:AnyObject] = [
        "foo":"bar"
    ]
    var req:Request = mgr.request(.POST, "http://httpbin.org/post", parameters: parameters).responseString { (req, res, string:String?, err:NSError?) -> Void in
    }
```

when I use this manager to make get requests, it's ok, but when it make post requests like above, it always get NSURLError, which error code is -999.

```
Error Domain=NSURLErrorDomain Code=-999 "cancelled" UserInfo=0x79f6d440     {NSErrorFailingURLKey=http://httpbin.org/post, NSErrorFailingURLStringKey=http://httpbin.org/post,     NSLocalizedDescription=cancelled}
```
 after referenced to [this answer](https://github.com/Alamofire/Alamofire/issues/157), I've tried to add this manager as a property 

```
    var req:Request = self.mgr.request(.POST, "http://httpbin.org/post", parameters: parameters).responseString { (req, res, string:String?, err:NSError?) -> Void in

    }
```

but it still received the same error.
 I have the same problem. Did you find a solution? 
 After trying all the solutions provided above, my code still fails with same error. For my case, it's because I made too many requests within same session, which exceed the maximum limit (https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSURLSessionConfiguration_class/#//apple_ref/occ/instp/NSURLSessionConfiguration/HTTPMaximumConnectionsPerHost).

Sample code:

let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
configuration.HTTPMaximumConnectionsPerHost = 10   // Some arbitrary number that I feel big enough.
let manager = Alamofire.Manager(configuration: configuration)
 I have similar problem.
I uses a custom session manager.
"deinit" does not get called for the custom SessionManager so I believe that I am retaining the session manager properly.

The request looks something like this https://10.36.100.28/IZLogin.php?password=secret&username=davids

10.36.100.28 is a private ip on a test server behind our firewall

NSAppTransportSecurity sets NSAllowsArbitraryLoads to true. The ips are only know by the end customer.

```
<key>NSAppTransportSecurity</key>
<dict>
    <key>NSAllowsArbitraryLoads</key>
    <true/>
</dict>
```

The calling code looks like this 

```
                let sessionManager = credentials.usehttps ? credentials.sessionManager : Alamofire.SessionManager.default
                sessionManager.request(url, method: .get, parameters: param)
                .validate(statusCode: 200..<300)
                .validate(contentType: ["application/xml", "text/xml"])
                .responseString { response in
                    print(url, param)
                    print(response)
                }

public class HTTPSManager : Alamofire.SessionManager {
    deinit {
        print("HTTPSManager deallocated")
    }
    fileprivate convenience init(credentials: Credentials) {
        let serverTrustPolicies: [String: ServerTrustPolicy] = [
            credentials.ipwithport: .pinCertificates(
                certificates: ServerTrustPolicy.certificates(),
                validateCertificateChain: false,
                validateHost: true
            ),
            "insecure.expired-apis.com": .disableEvaluation
        ]
        let configuration = URLSessionConfiguration.default
        configuration.httpAdditionalHeaders = Alamofire.SessionManager.defaultHTTPHeaders

        self.init(configuration: configuration, serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies))
    }
}

// This is a stripped down version of the Credentials class so you get the idea
public class Credentials  {
    let usehttps = true
    private(set) var ipwithport: String
    private var _SessionManager: HTTPSManager? = nil
    var sessionManager: HTTPSManager {
        get {
            if nil == _SessionManager { _SessionManager = HTTPSManager(credentials: self) }
            return _SessionManager!
        }
    }
}

// Here is the console output for this call
[[Request]: https://10.36.100.28/IZLogin.php?password=secret&username=davids
[Response]: nil
[Data]: 0 bytes
[Result]: FAILURE: Error Domain=NSURLErrorDomain Code=-999 "cancelled" UserInfo={NSErrorFailingURLKey=https://10.36.100.28/IZLogin.php?password=secret&username=davids, NSErrorFailingURLStringKey=https://10.36.100.28/IZLogin.php?password=secret&username=davids, NSLocalizedDescription=cancelled}
[Timeline]: Timeline: { "Request Start Time": 496862619.408, "Initial Response Time": 496862619.875, "Request Completed Time": 496862619.875, "Serialization Completed Time": 496862619.875, "Latency": 0.467 secs, "Request Duration": 0.467 secs, "Serialization Duration": 0.000 secs, "Total Duration": 0.467 secs }]

```

Any help would be appreciated. Thanks.
 Sorry about not putting this on StackOverflow. Search engines send me here first. I updated my class to be

```
public class HTTPSManager : Alamofire.SessionManager {
    deinit {
        print("HTTPSManager deallocated")
    }
    fileprivate convenience init(credentials: Credentials) {
        let serverTrustPolicies: [String: ServerTrustPolicy] = [
            credentials.ipwithport: .pinCertificates(
                certificates: ServerTrustPolicy.certificates(),
                validateCertificateChain: false,
                validateHost: true
            ),
            "insecure.expired-apis.com": .disableEvaluation
        ]
        let configuration = URLSessionConfiguration.default
        configuration.httpAdditionalHeaders = Alamofire.SessionManager.defaultHTTPHeaders

        self.init(configuration: configuration, serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies))

        delegate.sessionDidReceiveChallenge = { session, challenge in
            let disposition = URLSession.AuthChallengeDisposition.useCredential
            let credential = URLCredential(trust: challenge.protectionSpace.serverTrust!)

            return (disposition, credential)
        }
    }
}
```

This overcomes the -999 error but it doesn't seem like the right answer. It seems like I shouldn't be over riding the session challenge code and I am just not setting up something right or perhaps Alamofire should provide a way for me to set this up properly.

Thanks in advance
  In the current implementation, I can't access logic for building those headers without creating the Alamofire SessionManager singleton like so.

```
Alamofire.Manager.sharedInstance.session.configuration.HTTPAdditionalHeaders
```

It seems that for those of us creating our own `SessionManager` subclasses, we should be able to access that header creation logic without having to instantiate the singleton object. This pull request extracts the header logic into a separate class method to allow subclassed `SessionManager` objects access.
  Example:

```
struct ResponseCode {
    static let OK = 200
    static let CREATED = 201
}
```

Code is more readable when using response codes.
  When I try to run my app on my iPhone 6+ iOS 8.1.1 I get this error.

dyld: Library not loaded: @rpath/Alamofire.framework/Alamofire
  Referenced from: /private/var/mobile/Containers/Bundle/Application/EDCBD2EC-XXX/myapp.app/myapp
  Reason: image not found

Works fine on the simulator, but not on my device. 
 I have the same issue.
Check if this helps: https://github.com/Alamofire/Alamofire/issues/101
 Fixed by revoking my developer certificate and creating a new.
     Easy mistake! I just happened to catch it and figured I should quick push up a PR.
  That's just a question.
Does Alamofire work with gzip?
Thanks a lot.
 What do you mean by "work with gzip"?
If you mean: "Does it handle gzipped responses", then yes. (I think this is handled further down at the cocoa layer?)
Those will be uncompressed for you.
 For all the people coming here like me wondering how to GZIP the body of the request produced by Alamofire's `ParameterEncoding` I have made a little extension.

Provided you use: https://github.com/1024jp/NSData-GZIP 
With [this extension](https://gist.github.com/blender/923f1c1de2f00514ed12) you can now gzip your request by calling `.gzipped` on the encoding.

Examples:

```
Alamofire.request(.POST, someURLString, parameters:["data":["verboseData":"veryVerbose"]], encoding:.JSON.gzipped)
```
 @blender, I am struggling using your NSData extension.  Just posted a question in your Issues on GitHub would be grateful for your assistance 
 @Hakkoos unfortunately I'm not the maintainer nor work on https://github.com/1024jp/NSData-GZIP. I'm afraid I can't help you there.
 Thanks @blender 
  When handling requests using a serializer (JSON, plist) it is possible that the response will valid `NSData` instance with 0 bytes which means the check for `data == nil` will pass and the serialization calls will fail. To prevent this, we can check if the `NSData` returned has bytes.
 Anyone have a change to look at this yet?
  When I use `responseJSON` I have to make sure `data` is `NSDictionary` before using it. It would be nice to have methods that explicitly expects JSON Array or JSON Object and fails when it doesn't get such response. It might be possible to do this with method overloading of `responseJSON` but I'm not familiar with Swift enough to make the call. 

Right now here is what I do:

``` swift
Alamofire.request(.GET, url, parameters: params).responseJSON { (_, _, data, error) in
            if let json = data as? NSDictionary {
                if let info = json["info"] as? NSDictionary {
                    self.updateAccount(acct, json: info)
                    completionHandler(acct)
                    return
                }
            }
}
```

With `responseJSONObject` I would be able to get rid of `if let json = data as? NSDictionary {` line and access `"info"` with subscript. 
  Splitting this out from #250.

The default singleton instance of `Alamofire.Manager` uses a configuration that adds compression to the `Accept-Encoding` header. curl's `--compressed` option does the same thing, but also will decompress the response. Indeed, it will end up having no effect on the request as the `-H` flag later on will override the `Accept-Encoding` header from the `--compressed` option.

Piping the response to `gunzip` or similar will be difficult, as the curl flags also include `-i`, putting headers in the response output.
  Many server frameworks (like JAX-RS in Java) expect array parameters to be send without square brackets: foo=1&foo=2. The current version of Alamofire always sends it with square brackets: foo[]=1&foo[]=2

This pull request adds a useSquareBracketsArrayParameter variable to the Manager to control whether or not square brackets are used.
  Also add `--compressed` flag to `curl` output.
 I'm confused.

In #219, you told me this:

> Even worse, I've seen apps even use these NSError objects verbatim to alert the user. Even for a savvy user, knowing that the app got a 404 is not actionable or useful.
>  _[...]_
> All of this leads me to believe that there's diminishing value in attempting to communicate anything through an NSError object.

While passing an empty `NSData` buffer to `NSJSONSerialization` does return `nil`, it also sets the `error` parameter to error 3840 for invalid JSON, something that you've certainly seen [plenty of](http://stackoverflow.com/questions/19720890/cocoa-error-3840-when-post-request-with-afnetworking-2) [frivolous](http://stackoverflow.com/questions/25953701/afnetworking-post-writes-to-server-and-returns-failure-error-cocoa-error-3840) [Stack Overflow](http://stackoverflow.com/questions/12286829/ios-cocoa-error-3840) [questions](http://stackoverflow.com/questions/19311342/cocoa-error-3840-on-afnetworking) [about](http://stackoverflow.com/questions/18080549/afnetworking-error-the-operation-couldn-t-be-completed-cocoa-error-3840). That `error` parameter gets bubbled up to the response handler.

Given a RESTful web service endpoint that can return JSON or return nothing with an appropriate status code, a successful request can return an error or not return an error and the developer would be left trying to glean information from an `NSError` object, something you've previously advised against.

Finally, given that there's no documentation in the API that `responseJSON` uses `NSJSONSerialization`‚Äîthough perhaps it's so obvious as to be implied‚Äîit doesn't seem like anybody should be depending on NSJSONSerialization behavior.

What am I missing?
   It's for the case when NSURLRequest passed to encode() contains a query component in it's url (e.g. http://example.com/movies?hd=[1])

Code already handled it but concatenated non-percent-encoded original parameters with percent-encoded query() return value.

Tests added.
  Hi,

I have compiled Alamofire in the same version of my project iOS deploy, arch, etc.

t is running OK from xcode to my device. But when i go archive to send to app store i get a lot of link errors.

Image:
https://www.dropbox.com/s/8fv61wr5qh3uww8/Screenshot%202014-12-02%2006.13.15.png?dl=0

Can you help me?
 But i have selected the same for every project. I dont change it.

Look:
1 - https://dl.dropboxusercontent.com/u/7386482/ss-erro-alamofire1.png
2 - https://dl.dropboxusercontent.com/u/7386482/ss-erro-alamofire2.png

It is so confusing :(
  Fix "Operand of postfix '!' should have optional type" by removing extraneous `!` after `URL`
  It's illogical (in my opinion) to force the user to not encode parameters into the URL, even though it may be bad practice. If the encoding is `.URL`, then let it be a URL encoding.

Forcing the user to not use a URL encoding gives him/her potential confusion, since there are no warnings or notifications saying that their encoding type was overridden and changed to `.JSON`.

Thanks!
 @mattt - I understand that, and sorry about that, but can you at least explain to me why you _force_ the user not to use URL encoding for parameters?

Anyways, you might consider logging to the user that the encoding type was changed, even though it's documented. 
  ![2014-12-01 10 40 54](https://cloud.githubusercontent.com/assets/982291/5242118/5bd8eb20-796f-11e4-9d58-b9abdbb44f0c.png)
![2014-12-01 3 31 37](https://cloud.githubusercontent.com/assets/982291/5242120/5bf484a2-796f-11e4-9a66-9292f3817611.png)
![2014-12-01 3 31 44](https://cloud.githubusercontent.com/assets/982291/5242119/5bdc832a-796f-11e4-8abc-ee40ad5e6da1.png)

Alamofire/Tests/DownloadTests.swift:71:54: Operand of postfix '!' should have optional type; type is 'String'

hi~ i came back here again ~~ sorry....
i don't know why this error is not show to you
  i upload issue

https://github.com/Alamofire/Alamofire/issues/243
  i have use Alamofire by git submodule. and i use recently Xcode version
and i find compile error when I build, and show this error message

/Users/MYPATH/Alamofire/Tests/DownloadTests.swift:71:54: Operand of postfix '!' should have optional type; type is 'String'

this code erorr
XCTAssertEqual(file.lastPathComponent!, "(numberOfLines)", "filename should be (numberOfLines)")

but i have chaged "file.lastPathComponent!" to "file.lastPathComponent"
and disappear error message
  Hi,

Im using the last swift class of Alamofire and im trying making post request to my server. You can test using GET or POST, i dont receive any get/post parameters.

``` swift
var parameters: [String : AnyObject]? = [String : AnyObject]?()
parameters?.updateValue("test1", forKey: "field1")
parameters?.updateValue("test2", forKey: "field2")

Alamofire.request(.POST, "http://ipacote.com/test.php", parameters: parameters).responseString { (request, response, data, error) in
    println(request)
    println(response)
    println(data)
    println(error)
}
```

I have made this simple script:
http://ipacote.com/test.php

Everything is working nice if a test from any place, but only with alamofire, it doesnt work. You can try a curl execution from command line:

``` bash
curl --data "field1=test-of-post" http://ipacote.com/test.php
```

Can anyone help me?
 Hi,

The problem is with parameters. It need be:

``` swift
var parameters = [String : AnyObject]()
parameters["field1"] = "value1"
parameters["field2"] = "value2"
```

Now it is working. Thx.
  Sets stream property when upload is called in stream
 Awseome :) The upload method also is buggy with multipart-data, i ended up using a NSURLRequest because it couldn't work properly
  Hi!
Before everything thanks for this amazing framework =)

I have been working with alamofire for a while, but finally i decided to rollback to AFNetworking for my swift project. But I can't remove it from the `Working Copies` option, i have followed many internet guides about how to remove submodules but Alamofire still is under `Source Code> Working Copies`.

Someone knows how to remove it?

Thanks in advance!
  In extension Alamofire.Request this:

```
return response(serializer: serializer, completionHandler: { (request, response, object, error) in
    completionHandler(request, response, object, error)
})
```

triggers this error: "Extra argument 'completionHandler' in call"

Thank you.
 I unfortunately could reproduce this, and it appears to be bad documentation obfuscated by a misleading error from XCode.  To see the real problem, create a dummy method response2 in your extension with the same signature as response:

```
public func response2(queue: dispatch_queue_t? = nil, serializer: Serializer, completionHandler: (NSURLRequest, NSHTTPURLResponse?, AnyObject?, NSError?) -> Void) -> Self {
    return self
}
```

if you then change your method to call response2 XCode should now find the real problem (object should be type T but is AnyAbject), which you can fix as follows:

completionHandler(request, response, object as? T, error)

The analogous code snippet for serializing a response collection casts object as? [T] as expected.
 My code version : Version 6.1 (6A1052d)
And i have latest code from repo; but i am still getting this error :(
  Hello,

I love Alamofire and it's quite a lifesaver. However, I feel like the process suggested of having to put the entire Alamofire project inside my project and adding an embedded binary that way seems very "hacky" to me. I don't see why everything in Alamofire is in a single file so I only have to drag one file into my project and I'm done. I understand that with the current method you should (theoretically, but doesn't for me) work with Playgrounds. However, I would much rather trade off that ability for simply having the whole library in one file.

Can you consider switching to a single file? If not that' fine, but if you could, it'd be great.

Thanks!
 You can use the single file, please read through the readme file.

> For application targets that do not support embedded frameworks, such as iOS 7, Alamofire can be integrated by including the Alamofire.swift source file directly, wrapping the top-level types in struct Alamofire to simulate a namespace. Yes, this sucks.

And you can check this issue #186, someone has implemented it.
  any suggestions about how to upload files with parameters using alamofire? 
  Is there a way to break chaining if some conditions are met?
For example, if you check below in `responseJWT` I want to check for some conditions and to be able to break chaining, so as the code inside `responseString` will not be executed.

Also from what I found so far, the response handlers are not being executed in the order defined in the code. So the code below first prints `2` and then `1` while I was expecting the opposite.

I think I can understand why this happens. Although, I wanted to ask if you know a way to make it work in the way I am expecting.

``` swift
Alamofire.request(.GET, "http://httpbin.org/get")
         .responseJWT { (_, _, jwtJson, error) in
                 println(1) 
                 println(jwtJson)

                  // can we break the chaining here if some conditions are met?
         }
         .responseString { (_, _, string, error) in
                 println(2)
                 println(string)
         }
```
 Thanks you a lot @mattt.
I can do what I need inside the responseJWT, although I thought it will be a nice idea to use chaining for that reason.
I see you points, and indeed the frameworks' behaviour of not blocking anything is better.
 > There are no guarantees about the ordering of chained responses

This really confused me (versus looking at the code locally and trying to reason about how it works). I've since realized that this comment is outdated. Specifically, [this commit](https://github.com/Alamofire/Alamofire/commit/83774b0f9be426e261a44a040701965d0817c68f#diff-8566d050bc5476c30a47ff3e37f237aa) (which occurred after the above comment) switched to an `NSOperationQueue` with `maxConcurrentOperationCount = 1`, which should guarantee that the chained response handlers are processed in order, one at a time, and consequently enqueue the associated block/closure onto the main dispatch queue (by default) - which is serial - and also process in order and one at a time.

I was trying to figure out whether I needed to explicitly protect against possible concurrent access to a shared resource accessed (only) from response handlers. I've come to the conclusion that since I'm using the main dispatch queue - which is serial - for all response handlers, that should effectively limit access to this shared resource to one response handler at a time.
 So with the updated comment, considering the following sample, will the chain break when it hits the return statement in .responseJWT and not execute .responseString?

```
Alamofire.request(.GET, "http://httpbin.org/get")
         .responseJWT { (_, _, jwtJson, error) in
                 println(1) 
                 println(jwtJson)
                  // can we break the chaining here if some conditions are met?
                 if (1==1){
                     return
                 }
         }
         .responseString { (_, _, string, error) in
                 println(2)
                 println(string)
         }
```
 At least on Alamofire 2, I don't believe the chain can break.. the closures (from each response handler) return Void, so there's no way to know to 'break the chain'. Each closure is added to a queue and once it's time to execute them, they're all executed in the order that they were added.

If the response had an error, all the handlers should see that error. Otherwise, I don't think there's a way to directly propagate information from one closure to the next.
  What I am trying to achieve is to read the response data even when the validation set, fails. The reason for doing that is because the API I am trying to access implements [application/problem+json](https://tools.ietf.org/html/draft-nottingham-http-problem-06).

So:

``` swift
Alamofire.request(.POST, "http://httpbin.org/post")
  .validate()
  .responseJSON { (_, _, JSON, error) in
    println(JSON)        // null
    println(error)       // Error Domain=com.alamofire.error Code=-1 "The operation couldn‚Äôt be completed. (com.alamofire.error error -1.)"
  }
```

fails as it should when status code is for example _400_, although I can't read the data inside response body by accessing the JSON.

I am currently trying to write an extension of Request for that, but without luck so far.

Thanks @mattt for this great library.
 Thanks @mattt. I will try to create a custom response handler.
 Hey @mattt 
First of all, thanks a lot for making this great library.

We are having issues with this right now as well. The HTTP/1.1 RFC specifies that the response for 4xx requests should return an entity contain an explanation of an error. Is there a way that we could have Alamofire support this case?

EDIT: [RFC Here](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4)
 +1
 +1
 +1 any update on this? this shouldn't be closed imo.
 Handling it with a custom response handler worked great for me. I can upload a sample if you want next week.

By indeed +1 for having this supported in Alamofire itself.
 Thanks @ziogaschr. That would be a nice workaround but I agree with @toothrot that this should be the default behavior according to RFC 2616.
 Thank you a lot @cnoon for the update and your great work. I will give this a check soon.
 @cnoon I just tested #791 & #792 in the project I am working on and I see many benefits. Thanks for the amazing work.

What I would like in advance is to be able to parse the error response data (according to RFC) in a `ResponseSerializer`. I am currently doing this but instead of using `Result.Failure()`, I have always to use `Result.Success(customObject)` and set the error and data in my `customObject`.

I see that data are exposed also to the response handler and the intention is to not handle them in `ResponseSerializer`. But talking only based on my project I will have to copy over the same code in more than 15-20 places to do so.

What I think will work nice is to have `Result.Failure(AnyObject, NSError)`.
 Hello @cnoon, it makes sense to comment directly on the other issues. Do you want me to move them?

When `.Failure` has to be called using my custom `ResponseSerializer` (e.g: named `responseCustomJSON`) I would like to parse the error data as JSON so as I don't have to do JSON parsing separately for each response handler. In that manner I would like to call `.Failure(customJSON, error)` or at least store it somehow in the `Result` in order to access it from the `Response` object.

Cheers
 Let's say that we are doing a POST which returns a `429` with these data:

```
XHR Response: {
  "status": 429, 
  "type": "https://sample.com/error/server-error", 
  "detail": "Some description text", 
  "title": "Rate limit‚Äù
}
```

> NOTE: I am using `validate(statusCode: 200..<400)`.

and now the `ResponseSerializer` with some pseudo code.

```
return ResponseSerializer { _, response, data, error in

            // a custom object that app uses
            let res = ResponseHandler()

            guard error == nil else {

                // set error in ResponseHandler
                // this will allows us to use .Success for now
                res.error = error

                // try to parse response data as JSON
                // if the response is an application/problem+json
                // it will create a JSON successfully
                // after that we will try to read its status
                if response?.statusCode != 204,
                    let validData = data,
                    let headers = response?.allHeaderFields
                        where headers["content-type"]?.lowercaseString.rangeOfString("application\\/problem\\+json", options: .RegularExpressionSearch) != nil
                {                    
                    // add problem+json to response
                    res.json = JSON(data: validData)
                }

                // NOTE: we want to parse `application/problem+json` so when available we use .Success() to pass the object back
                // return .Success(res)

                return .Failure(res, error)
            }

            guard let validData = data where validData.length > 0 else {
                let failureReason = "JSON could not be serialized. Input data was nil or zero length."
                let error = AQError.errorWithCode(.AQJWTSerialization, failureReason: failureReason)

                res.error = error

                // NOTE: we want to parse `application/problem+json` so when available we use .Success() to pass the object back
                // return .Success(res)

                return .Failure(res, error)
            }

            if response?.statusCode != 204 {

                // parse it as a SwiftyJSON
                res.json = JSON(data: validData)
            }

            return .Success(res)
        }
```

As you see above normally I am using `.Success` instead of `.Failure`.
The benefit that I get the error data parsed as JSON in this case.

I have two serializers which depend on such logic.
 Yes @cnoon makes much sense. Although, this will trigger many changes in my app code. 
When I started using Alamofire (back in v1 I think), it was cleaner to use it like this.

Thanks for your help and sorry for commenting on a closed issue.
  My app project have used cocoapods, and i create a object-c project.

1.Add Alamofire as a submodule by opening the Terminal, cd-ing into your top-level project directory, and entering the command git submodule add https://github.com/Alamofire/Alamofire.git
2.Open the "WeiDianApp.xcworkspace".
3.Open the Alamofire folder, and drag Alamofire.xcodeproj into the file navigator of "WeiDianApp.xcworkspace". 
4. In the tab bar at the top of that window, open the "Build Phases" panel. Expand the "Target Dependencies" group, and when i add it, there is no "Alamofire.framework".

When i open the "WeiDianApp.xcodeproj", and i can add "Alamofire.framework" in the "Target Dependencies" group;  but when i open the "WeiDianApp.xcworkspace",  i can't add it. 

How can i do it?
  Hi,

first of all thank you very much for this framework!

I want to use Alamofire in one of our projects but I need to customize the http header in all of the request and they are not the same. The requests are on seperate threads.

From what I understand I have to use a shared manager for manipulating header configuration like this:

```
        let manager = Alamofire.Manager.sharedInstance
        manager.session.configuration.HTTPAdditionalHeaders = [
            "Accept": "application/json"
        ]

        manager.request(.POST, "http://httpbin.org/post", parameters: ["foo": "bar"])
            .responseJSON { (request, response, JSON, error) in
                println(request)
                println(response)
                println(error)

                if JSON != nil {
                    println(JSON)
                }
        }
```

The problem with this code is that it is not thread safe. My second thread or a parallel thread gets the session configuration (same object due to shared instance) with the wrong accept header.

Is there a better way to do this on parallel threads? Or is there a way to instantiate a new Alamofire manager for each request?

Thanks in advance!

Cheers,

Alex
  I have mixed feelings about failable initializers, but I also deal a lot with missing or invalid data in my json responses.  The example you give of an object that implements ResponseObjectSerializable will crash if the "name" value is not a string.  

```
final class User: ResponseObjectSerializable {
  let username: String
  let name: String

  required init(response: NSHTTPURLResponse, representation: AnyObject) {
    self.username = response.URL!.lastPathComponent
    self.name = representation.valueForKeyPath("name") as String
  }
}
```

I'd propose something like this instead, to match the other serialization method signatures:

```
protocol ResponseObjectSerializable {
    class func buildFromResponse(response: NSURLResponse, representation: AnyObject) -> (Self?, NSError?)
}
```
 The code after your change @mattt does not compile:
`completionHandler(request, response, object, error)`
complains that AnyObject is not T, therefore I would need to change it to:
`completionHandler(request, response, object as T?, error)`

But even then your example is not there yet, because if there is a missing value it will still just crash instead of failing and returning nil with the message:
`fatal error: unexpectedly found nil while unwrapping an Optional value`
This happens when doing something liek this and the value is not present:
`self.name = representation.valueForKeyPath("name") as String`

What would be the best way of going about it?
    According to their documentation, Carthage needs shared scheme to build dynamic framework.

> Carthage will only build Xcode schemes that are shared from your .xcodeproj. You can see if all of your intended schemes build successfully by running carthage build --no-skip-current, then checking the Carthage.build folder.

Alamofire has scheme that builds dynamic framework, but it is not shared. So I made it shared.
I tested Carthage builds Alamofire.framework correctly on the [forked repository](https://github.com/ishkawa/Alamofire).

NOTE: new tag is required to notify update of this repository to Carthage.
 +1

Does this fix code signing issues as well?
 BTW, Carthage support isn't full without OSX target support #212 
  An alternative of Cocoapods is coming to town and it would be wonderful to support it. I try to use it with Alamofire and failed. And Alamofire really need an updated version to support OS X target too.

https://github.com/Carthage/Carthage
 @mattt A shared scheme is needed for full Carthage support. Please look at https://github.com/Alamofire/Alamofire/pull/228 and create a new release/tag after it's merged for Carthage to pick it up. Thanks!
  This happens for cookies included with a request, e.g.

```
curl -i \
    -X POST \
    -b "_api_session=Optional("...")" \
    -H "Content-Type: application/json" \
    ...
```

(possibly related to #91)
  How can I allow an invalid certificate? In AFNetworking, there was #define _AFNETWORKING_ALLOW_INVALID_SSL_CERTIFICATES_ 1
 Ok, thanks. 
 You can replace Alamofire's SessionDelegate's `URLSession(session:task:didReceivedChallenge:completionHandler:)`  method with the following to get around it.

```
public func URLSession(session: NSURLSession, task: NSURLSessionTask, didReceiveChallenge challenge: NSURLAuthenticationChallenge, completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential!) -> Void)) {


    //TODO: Remove this
    if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
        let trustedDomain "self.signed.domain.com"
        if challenge.protectionSpace.host == trustedDomain {
            let trustedCredential = NSURLCredential(forTrust: challenge.protectionSpace.serverTrust)
            completionHandler(.UseCredential, trustedCredential)
            return
        }
    }
    //TODO: No, Really Remove This


    if taskDidReceiveChallenge != nil {
        completionHandler(taskDidReceiveChallenge!(session, task, challenge))
    } else if let delegate = self[task] {
        delegate.URLSession(session, task: task, didReceiveChallenge: challenge, completionHandler: completionHandler)
    } else {
        URLSession(session, didReceiveChallenge: challenge, completionHandler: completionHandler)
    }
}
```

I don't know what other effects this code could have on the library, so I suggest you only use it until you get an verified SSL cetificate in place and if you're testing on a localhost server or on a server that doesn't have any private data because it's all fake just don't use https. If the remote server you're testing with does have confidential data you should **not** use this code, you should get a verified SSL certificate.

The developers behind Alamofire have a really good reason for not implementing a simply way to use invalid SSL certificates. It forces us library users to really consider the risks and ramifications of overriding the validation check.
 Here is a possible solution on how to accept invalid SSL Certificates in Alamofire. 

Add the following function in your AppDelegate class and call it in didFinishLaunching function:

func acceptInvalidSSLCerts() {
          let manager = Alamofire.Manager.sharedInstance
  print("trying to accept invalid certs")

```
      manager.delegate.sessionDidReceiveChallenge = { session, challenge in
          var disposition: NSURLSessionAuthChallengeDisposition = .PerformDefaultHandling
          var credential: NSURLCredential?

          print("received challenge")

          if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
              disposition = NSURLSessionAuthChallengeDisposition.UseCredential
              credential = NSURLCredential(forTrust: challenge.protectionSpace.serverTrust!)
          } else {
              if challenge.previousFailureCount > 0 {
                  disposition = .CancelAuthenticationChallenge
              } else {
                  credential = manager.session.configuration.URLCredentialStorage?.defaultCredentialForProtectionSpace(challenge.protectionSpace)

                  if credential != nil {
                      disposition = .UseCredential
                  }
              }
          }

          return (disposition, credential)
      }
  }
```

Reference:-> [Accepting invalid SSL certificates in Alamofire](http://swiftforums.org/forum/alamofire/32-accept-invalid-ssl-certificates-in-alamofire)
 @tvich1 hey can we enable and disable Invalid SSL Acceptance somehow? I tried your method, it works but it blocks URL OAuth in UIWebView.  Hi. I'm trying to launch custom completion handler as soon as all concurrent requests are finished. Something like this (I deleted unimportant code to make it easier to read):

``` swift
class APIManager {
    class var sharedInstance: APIManager {
        struct Static {
            static var instance: APIManager?
            static var token: dispatch_once_t = 0
        }

        dispatch_once(&Static.token) {
            Static.instance = APIManager()
        }

        return Static.instance!
    }

    func downloadAllData(allDataDownloadedCompletionHandler:(Any?)->Void) {
        var downloadRequests:[Request] = [Request]()
        var completionHandlerCounter = 0
        var allData = [AnyObject]()

        let requestCompleted: (Bool, AnyObject?)->Void = { downloaded, data in
            if downloaded && data != nil {
                // append downloaded data to result list
                allData.append(data)
            }

            // check if all requests has been already completed
            completionHandlerCounter = completionHandlerCounter + 1
            if completionHandlerCounter < downloadRequests.count {
                return
            }

            // all requests completed
            println("All data downloaded")
            allDataDownloadedCompletionHandler(allData)
        }

        let types = ["one", "two", "three"]  // there are actually about 10 requests called, but to make it simple I set it to 3
        for type in types {
            downloadRequests.append(self.downloadDataForType(type, completionHandler: requestCompleted))
        }
    }

    func downloadDataForType(type:String, completionHandler:((Bool, AnyObject?)->Void)) -> Request {
        return Alamofire.request(Router.TypeData(type: type)).response({ (request, response, xmlResponse, error) -> Void in
            // request finished
            println("Data for type \(type) downloaded")

            // let's parse response in different queue, because we don't want to hold main UI queue 
            var db_queue = dispatch_queue_create("db_queue", nil)
                dispatch_async(db_queue, {
                if response?.statusCode == 200 {
                    saveToDatabase(xmlResponse)

                    // IT CRASHES HERE !!!
                    return completionHandler(true, xmlResponse)
                }
                return completionHandler(false, nil)
            })
        })
    }
}
```

As you can see, APIManager is a singleton class and I am downloading data (running multiple concurrent asynchronous requests) with call 

``` swift
APIManager.downloadAllData(myCompletionHandler)
```

It works on simulator, but in Release version it use to fall often (**not always**) and in crashlog there is an error with this message:

```
partial apply forwarder for reabstraction thunk helper from @callee_owned (@unowned Swift.Bool, @in protocol<>?) -> (@unowned ()) to @callee_owned (@in (Swift.Bool, protocol<>?)) -> (@out ()) (APIManager.swift:0)
```

You can check full stacktrace here: http://pastebin.com/mJRLUkEe

I don't understand what is going on. Why does it crash? Why does it crash on release version only? And what does this error even mean? 

Any help is very **very** appreciated. Improvements or another idea how to check if all concurrent requests have been completed are welcome as well. Thank you very much.
 Well, I am playing around with `dispatch_group` right now:

``` swift
func downloadAllData(allDataDownloadedCompletionHandler:()->Void) {
    let dispatchGroup: dispatch_group_t = dispatch_group_create()
    let types = ["one", "two", "three"]  // there are actually about 10 requests called, but to make it simple I set it to 3
    for type in types {
        // enter group and run request
        dispatch_group_enter(dispatchGroup)
        self.downloadDataForType(type, group: dispatchGroup)
    }

    dispatch_group_notify(dispatchGroup, dispatch_get_main_queue(), {
        allDataDownloadedCompletionHandler()
    });
}

func downloadDataForType(type:String, group: dispatch_group_t) {
    Alamofire.request(Router.TypeData(type: type)).response({ (request, response, xmlResponse, error) -> Void in
        // request finished
        println("Data for type \(type) downloaded")

        // let's parse response in different queue, because we don't want to hold main UI queue 
        var db_queue = dispatch_queue_create("db_queue", nil)
            dispatch_async(db_queue, {
            if response?.statusCode == 200 {
               saveToDatabase(xmlResponse)
           }

            // leave group
            dispatch_group_leave(group)
        })
    })
}
```

I haven't found any issues related to it until now, so hopefully it is working correctly. I'll let you know if not.
 Sorry to bring this up again, but I'm trying to synchronize groups of requests that have to run in sequence, e.g.

```
[ group1: 
  [ req1: ========>     ]
  [ req2: ====>         ]
  [ ...]
]
// -- sync
[ group2:
  [ req1: =====>        ]
  [ req2: ==>           ]
  [ ... ]
]
// -- sync and exit
```

This procedure is supposed to run without any user interaction, in some background thread (actually, it's a classic offline data sync, with interdependencies between objects), and should signal completion in the very end.
I tried:
- dispatch semaphores (`dispatch_semaphore_*`): this doesn't seem to work, as the executing thread gets stuck in `dispatch_semaphore_wait` while the Alamofire thread seems to not be resumed at all (I'd guess that's interference with Alamofire's internal dispatch groups)
- dispatch groups (`dispatch_group_*`): this doesn't mix with Alamofire's dispatch group (resulted in INVOPs, most likely because of races for the queue)
- extending the Alamofire Manager by a `wait()` function that waits until the queue completes.  I couldn't get this to work either.

Is there any proper way of doing this kind of synchronization?  I would rather not resort to `q`-style promises and deferreds, as it makes things unnecessarily complex.  An help appreciated, thanks!
 @sikoried I hate to say it but I think you're really overthinking it. @mattt lays out some great ways to attack this problem which are all much easier than trying to use semaphores and / or groups to try to solve a threading issue that doesn't exist. All the requests return back to the main queue (unless you provide your own dispatch queue), so threading is not an issue you need to deal with.
 Ok, I must have missed those, so any help appreciated :-)  Meanwhile, I figured out that I can use `dispatch_group_*` as

```
let group: dispatch_group_t = dispatch_group_create()

dispatch_group_enter(group)
Manager.sharedInstance.request(...).responseSwiftyJSON { (req, response, json, error) in
  // ...
  dispatch_group_leave(group)
}

dispatch_group_notify(group, dispatch_get_main_queue()) {
  NSLog("All calls complete")
}
```

Which works, however, it's again using a callback block which is what I want to avoid.  Using `dispatch_group_wait(group, DISPATCH_TIMEOUT_FOREVER)` instead of `dispatch_group_notify` results in the thread being stuck in wait, presumably because it's executed before the request is processed.  It probably doesn't belong here, but I couldn't find a solution elsewhere:  Is there a way to have the thread yield, or have Alamo put the request on a separate background queue (that's independently executed) so that the main thread can actually wait?
 @sikoried have you ever found a good solution to this?
I'm running into a similar problem right now.
 This is because responseSwiftyJSON was dispatched to main queue, do this and your problem is solved.

``` Swift
return response(queue: dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0),responseSerializer: User.userResponseSerializer,
completionHandler: completionHandler)
```
 Thanks, @Nick-The-Uncharted, that solved my problem. All along, I thought it was an Alamofire issue when really it was SwiftyJSON. Using SwiftyJSON's response dispatched to the main queue (instead of the default) allowed me to wrap the Alamofire function in a dispatch group with dispatch_wait, and not hang the app.
  Hi,

It would be nice to have a similar mechanism like AFNetworkActivityLogger for AFNetworking so we can easily log Request / Response information.

Thank you,
Cosmin
  The README says Alamofire supports iOS 7.0 but the IPHONEOS_DEPLOYMENT_TARGET in project.pbxproj says 8.0.

I think IPHONEOS_DEPLOYMENT_TARGET should say 7.0, yes?
  Hi,

When I want to upload a video file with alamofire it works with this code

Alamofire.upload(.POST, "(Config().server)/api/video/add", outputURL)

But when I do this a second time it doesn't write the file correctly. It just uploads a moviefile I can't play.

Any ideas ?
 I can upload a video file the first time. But the second time it uploads a video file I can't play.

I think it has to be client side because when I rerun the xcode project it can upload the file. But when I restart my server I still have the same problem the second time. 

I've checked that the outputURL is the required video and the first time it uploads a video I can play.
The second time its a video I can't play but still a valid outputURL.
Alamofire.upload(.POST, "(Config().server)/api/video/add", outputURL)
  It will be cool to have the library with pods.
 Vote! Would be great.
 Cocoapods isn't quite ready to support Swift, but it is in progress. A podspec has been provided by https://github.com/Alamofire/Alamofire/pull/218 but wont likely be merged until Swift is fully supported.
  Stop me if I'm missing something, but once a response fails validation, there's no way to tell what failed.
 I'm not sure how providing less information at the API level forces better UI or fewer questions on Stack Overflow. If the onus is on developers to respond to failure accordingly, shouldn't they be able to respond better if they know why validation failed?

(The scenario I envision: all client networking errors are reported back to a service out of band as a diagnostic; a spike in unacceptable content types is much more actionable than a spike in generic validation errors.)
  I used your framework and it's app target as Example project in the pull-request CocoaPods/CocoaPods#2835, which will bring Swift support to CocoaPods. See [here](https://github.com/CocoaPods/CocoaPods/tree/swift/examples/Alamofire%20Example). I hope this okay for you. I'd love to see it published in the master spec repo.
 @mrackwitz The library target should be iOS 7/OS X 10.9
 @ValCapri: Yes, it _should be_. But show me a linker, which actually supports that. :wink:
![ld-error-frameworks-not-supported](https://cloud.githubusercontent.com/assets/1389011/5063083/c8ba488a-6dd8-11e4-9577-780d85d1f726.png)
**Edit**: But you're right about 10.9.
 It might still need a little time until a public stable release. Hopefully not so much time until a first prerelease, but we will ship a stable 0.35 first anyway. It was just a result of my efforts so far, and it is always good to have as realistic test conditions as possible. But no, it isn't blocking currently.
 Since CocoaPods 0.36 beta 1 is out, I think this is good to be merged (version needs bumping to 1.1.2). @mattt.
 The merged podspec seems out of date, particularly, 

  s.version = '1.1.0' -> '1.1.3'
  s.source = { :git => 'https://github.com/Alamofire/Alamofire.git', :tag => '1.1.0' } -> '1.1.3'

  s.ios.deployment_target = '8.0' -> '7.0'

Thanks in advance for the update above.
 Hum... Something is weird.
when I add Alamofire my Bridging header breaks. Older dependencies which where Objective-C bridged to Swift can't be imported anymore.
I'm using 0.36.0.beta.1
_Edit_ : Bridging Header is not needed anymoar just 'import LibraryName' in your swift files.
Still I had to add again import Foundation and import UIKit while they where not necessary before, no idea why
 @mattt do you have a timeline on submitting the spec to trunk?
 @thedamfr after upgrading to Cocoapods 0.36.0.beta.1, adding `pod 'Alamofire', '~> 1.1.3'` to my existing pod file that contains:

```
target 'MyApp', :exclusive => true do
  pod 'AFNetworking', '~> 2.5'
  pod 'ProtocolBuffers', '1.9.3'
  pod 'KSDeferred', '~> 0.2'
  pod 'Rollbar', '~> 0.1.2'
  pod 'Alamofire', '~> 1.1.3'
end
```

I receive the error **failed to import bridging header** and an error of **'AFNetworking.h' file not found'** on the line `#import "AFNetworking.h"` in the bridging header.
 @JustinDSN try changing that to either `@import AFNetworking;" or`#import <AFNetworking/AFNetworking.h>`.
 @JustinDSN just remove the bridging header.
and user import AFNetworking in you swift file. 
It's the way it works.
  Some services require authenticate by user but not required password. In this case, puts a empty string ("") works fine. But is not very "semantic", because password is not a optional type, 

Currently I need do this.

``` swift
request(.POST, path, parameters: parameteres)
.authenticate(user: "User", password: "")
```

But will better:

``` swift
request(.POST, path, parameters: parameteres)
.authenticate(user: "User", password: nil)
```

Or 

``` swift
request(.POST, path, parameters: parameteres)
.authenticate(user: "User")
```
  I have asked a [question](http://stackoverflow.com/questions/26922057/how-to-pass-same-parameter-with-different-value) about it in stack overflow. No answer yet. Can anyone please have a look.

Thanks.
  This allows to set a custom queue, for instance a background queue or a dedicated queue. If no queue is added, Alamofire will specify a queue (and default is main queue).

Usage:

``` Swift
Alamofire.request(.GET, "http://someurl.com")
.responseJSON() { request, response, json, error in
    // this will run in main queue
}

let backgroundQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0)
Alamofire.request(.GET, "http://someurl.com")
.responseJSON(queue: backgroundQueue) { request, response, json, error in
    // this will run in a background queue
}
```
  Fresh vanilla install of everything, using XCode6. Something here just isn't fitting right. The error i'm getting is "Could not build objective-c module "alamofire" on _import alamofire_. Here is a screen shot of the error i'm getting: 
![image](https://cloud.githubusercontent.com/assets/1017476/4967685/c807a2de-681f-11e4-86f2-7ed381882f22.png)

And a screenshot of my configurations:

![image](https://cloud.githubusercontent.com/assets/1017476/4967687/ea0ac65e-681f-11e4-8205-502b6d05d186.png)
 Are you using Xcode 6.1 or just 6?
Is the Alamofire directory within your projects directory or did you just add the project file?
Did you check the target settings of Alamofire Framework and make sure they are the same as the settings of your project?

BTW: You can easily produce this error, when you import a Framework within the framework target itself. Check your target affiliation of your swift files.
  Fix compiler error by making API Parameter Abstraction example match CRUD & Authorization example.
  - Added OSX target - generate framework for OSX 10.10 target.
- Tweaked DownloadTests.swift to avoid deleting entire OSX Documents directory during tearDown()
- OSX Tests passing with the exception of AlamofireDownloadResponseTestCase.testDownloadRequest()
  - Downloaded file is saved with **.json** extension instead of expected **\(numberOfLines) lastPathComponent**. Dunno... anyone?

Please excuse the two previous pull requests I closed them myself... :blush:
 would be awesome if you could merge your target into the main branch
  Hi,

I am unable to set the variable "HTTPAdditionalHeaders" in iOS but I am able to do so in iOS 8.

Anyone else come across this?
    This problem would be easier to reproduce on iOS devices with smaller RAM, I first found it on an iPod Touch 5 with 512MB RAM. It crashes everytime when I try to encode a POST parameter with more than 500 Chinese characters, and it only gives me an EXC_BAD_ACCESS with no further information. On iPhone 5 with 1GB RAM it can handle about 1300 Chinese characters but still crash if the limitation is exceeded. 

For quick reference, this is the `escape` function I copied from `Alamofire.swift` line 154

``` swift
func escape(string: String) -> String {
    let allowedCharacters =  NSCharacterSet(charactersInString:" =\"#%/<>?@\\^`{}[]|&+").invertedSet
    return string.stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacters) ?? string
}
```

I can almost sure the reason of the crash is `stringByAddingPercentEncodingWithAllowedCharacters` takes too much memory, this is particularly obvious when it's encoding Chinese or Japanese strings, maybe because the encoding process is more complex for these languages.

I discovered that if I slice the long string into small pieces and call `stringByAddingPercentEncodingWithAllowedCharacters` in batches like below will fix the memory peak problem, 

``` swift
func escape(string: String) -> String {
    let allowedCharacters =  NSCharacterSet(charactersInString:" =\"#%/<>?@\\^`{}[]|&+").invertedSet
    let batchSize = 100
    var escapedString = ""
    let stringLength = countElements(string)
    for var i = 0; i < stringLength; i += batchSize {
        let rangeLength = i + batchSize > stringLength ? stringLength - i : batchSize;
        let slicedString = (string as NSString).substringWithRange(NSMakeRange(i, rangeLength))
        escapedString += slicedString.stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacters) ?? slicedString
    }
    return escapedString
}
```

I don't even need to place `autoreleasepool` between each for loops, I suspect there is already a autoreleasepool inside the implementation of `stringByAddingPercentEncodingWithAllowedCharacters`

Then I was wondering why I've never encountered this issue in AFNetworking, so I read the source code of `AFURLRequestSerialization`. Turns out `stringByAddingPercentEncodingWithAllowedCharacters` is only available after iOS 7 and AFNetworking supports iOS 6 so it use the lower level API `CFURLCreateStringByAddingPercentEscapes` which does not suffering from this memory peak issue, or at least not so obvious.

So here're two possible solutions we have for now:
1. Do it in batches
2. Use the lower level API like AFNetworking does.

An  example project is provided to reproduce this problem: https://github.com/PrideChung/AlamofireEscapeCrashExample
 I can confirm this issue has been fixed, thanks for the hard work.
 what about Afnetworking 2.0? It could also crash when escaping long Chinese strings. It crash at stringByAddingPercentEncodingWithAllowedCharacters in this function "static NSString \* AFPercentEscapedStringFromString(NSString *string) ". Those are my Chinese strings "‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ".
 OK.Thank you.
 Does `stringByAddingPercentEncodingWithAllowedCharacters` still crash?  i want to implement a app that play music online,what should I do? 
  ```
class func collection(#response: NSHTTPURLResponse, representation: AnyObject) -> [City] {
     return []
}
```

If an API endpoint returns a collection of objects, how do I implement the above method? Simply returning [] is not working.
 @mattt I did, but it took quite a while until I got an answer. In the doc you talk about how to the json->object transformation but it is not really clear how to do it for a collection. 

For others having this problem: http://stackoverflow.com/a/26706726/401025
 @ArtworkAD My guide isn't finished yet but you might find it helpful: http://rexstjohn.com/lets-call-rest-apis-with-alamofire-ios-8-and-swift/. Working source using the JamBase API can be found here: https://github.com/rexstjohn/iOS8_REST_API_SWIFT. (I consider this article to be in Beta).
  Hello,
i did not find any cocoapods spec file to use alarmofire in custom projects. Is it planned to support cocoapods in future. This makes integration of alormafire much easier.
I would be really happy to use it like that.
Greetings
  I don't know how to solve it.
The file I removed and reload several times.
 I click the "import Alamofire" , it just some code

``` objc
import Foundation

// Alamofire.h
//
// Copyright (c) 2014 Alamofire (http://alamofire.org)
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var AlamofireVersionNumber: Double

```
 I solved this issue by changing the Build Active Architectures Only settings.
<img width="1440" alt="screen shot 2015-08-15 at 10 14 58 pm" src="https://cloud.githubusercontent.com/assets/3723510/9291687/71f4a618-439c-11e5-8ae9-15983229ffbc.png">
 @Ethanator Thank you, "I solved this issue by changing the Build Active Architectures Only settings." worked for me !!
 @Ethanator - That's not a "solution", doing that you are just postponing the error until the moment you want to Archive the app for the App Store. I'm struggling with this problem at the moment.
 I've also run into this issue when installing with CocoaPods (3.1.4) and manually including the target. Changing the Build Active Architectures Only settings did not work for me. Are there any other potential solutions? 
 +1
  Does Alamofire implement asynchronous `UIImage` loading in `UIImageView+AFNetworking`?
 No, from the README:

When should I use AFNetworking?

AFNetworking remains the premiere networking library available for OS X and iOS, and can easily be used in Swift, just like any other Objective-C code. AFNetworking is stable and reliable, and isn't going anywhere.

Use AFNetworking for any of the following:

UIKit extensions, such as asynchronously loading images to UIImageView
 Will AlamoFire support that feature in the future? (would you accept a PR for it?)
 @swilliams Just in case you still need it: https://github.com/Alamofire/Alamofire/pull/333
 @cnoon :+1: Thanks!
  Archive submission failed:

The app references non-public selectors in Payload: Framework/Alamofire.framework

allocBatch:withEntity:count:
allocWithEntity:fastIndexForKnownKey:
indexForKey:
 This has been around for all kinds of apps the past week. (Probably related to the xcode 6.1 release) I'm not sure why this occurs, but it's probably not Alamofire.

I have had this error, and it has been resolved without me doing anything but clean and delete derived data in xcode.

https://devforums.apple.com/message/1063323#1063323 (requires sign in, I know)
http://stackoverflow.com/questions/26476776/non-public-selectors-in-app
  First, thanks for this excellent library!

I'm seeing floating point imprecision when passing negative Doubles in a parameters dictionary. I believe I've narrowed narrowed it down to `components.map{"\($0)=\($1)"}` at Alamofire/Alamofire/Source/Alamofire.swift#L94

Here is sample code that demonstrates the issue:

``` swift
let lat: Double =  42.358056
let lon: Double = -71.063611

println("lon is \(lon)") // lon is -71.063611

let parameters:[String:AnyObject] = ["foo": "bar", "lat": lat, "lon": lon]
let encoding = Alamofire.ParameterEncoding.URL

request = encoding.encode(request, parameters: parameters).0

println("\(request.URL.query!)") // foo=bar&lat=42.358056&lon=-71.06361099999999
```

Regular string interpolation handles things correctly, but the value changes precision at the point when string interpolation occurs inside of the map transform.
 I've just tested and you can use a `NSDecimalNumber` to properly describe your Double ;)
  Digging around in Alamofire, trying to get background sessions to work, there seem to be a couple of issues: For background downloads to work, it must support the situation in which the app has been terminated while background tasks proceed in the background, but where the app is fired up again when all the background tasks are done. Unfortunately, `didFinishDownloadingToURL` appears to:
- look for the task delegate and if found, call the task's `didFinishDownloadingToURL` (which, if found, calls the task's `downloadTaskDidFinishDownloadingToURL` closure); and 
- regardless of whether it found it or not, it then calls the session delegate's `downloadTaskDidFinishDownloadingToURL` closure.

So, there are a couple of issues here:
1. The `Manager` object doesn't expose the `delegate`, much less the `SessionDelegate` class itself. I see no way, when reinstantiating the session manager (presumably in the app delegate's `handleEventsForBackgroundURLSession`) to specify the session's `downloadTaskDidFinishDownloadingToURL` or the `sessionDidFinishEventsForBackgroundURLSession` closures. We need some way to tell the session delegate what to do upon these two events in the absence of task-level delegates.
   
   I exposed these two closures at the `Manager` level, and that seems to remedy the issue.
2. There would appear to be a similar issue with `sessionDidReceiveChallenge`: You have no assurances that when the app is fired up again (having possibly previously been terminated) that the request will be found, and thus the credentials provided during the request might be lost. And the session-level `sessionDidReceiveChallenge` closure is specified at the `delegate` object (which is private), so I see no way to set this.
   
   I created a variable at the `Manager` level that exposed this closure, and it now works.
3. The task's `downloadTaskDidFinishDownloadingToURL` closure asks us to return a `NSURL` (because the delegate method will kindly move the file for us). Great. But the session's `downloadTaskDidFinishDownloadingToURL` also asks us to return a `NSURL`, but the closure's return value does not appear to be used. Either the session delegate method should use this return value to move the file for us (and by the way, it should presumably only call this if it didn't find the task-level closure of the same name) or this session level delegate should not ask us to return a `NSURL` so that we're not mislead as to its intent and we understand that we have to move the file ourselves.
   
   The session level closure should also probably provide us some indication as to whether it successfully moved the file already as a result of the task-level closure (if one was found). Right now, we don't have a reliable way of knowing whether the task level delegate was found and succeeded or not.
   
   Also, when doing background sessions, we'd like to not specify task-specific `downloadTaskDidFinishDownloadingToURL` at all (because it's very confusing to have both task-specific closure and session-level closure, too). The trailing closure in the `download` methods should optional, IMHO.

Now, perhaps you're handling this (namely, a previously terminated app having been restarted when background downloads are done) in some other manner that has eluded my analysis. But I had to make quite a few changes to Alamofire to have downloads resume when `NSURLSession` transparently fired up the app in the background again. If you need me to share some of my edits with you, let me know.
 @robertmryan thanks for describing your issues and sharing them here! I'm running into the same troubles wanting to use background downloads with Alamofire. It would be very useful if you pushed your changes to github (a fork under your own account for example) so we can reuse your work.

@mattt What are your thoughts on this and/or are you already working on this? I would love to put some time into this issue, since we would very much like to implement this in our new app. 
 I'm not sure I want to submit this as a pull request, because there are fundamental design considerations here. But here is my fork if you want to see the start of one way of addressing the background session limitations: https://github.com/robertmryan/Alamofire

Having tweaked Alamofire to support background sessions, I then obviously have to implement it. For example, I often use singleton for my `BackgroundSession`:

```
import Foundation
import Alamofire

class BackgroundManager : Alamofire.Manager {

    var savedCompletionHandler: (() -> ())?

    override class var sharedInstance: BackgroundManager {
        struct Static {
            static let instance = BackgroundManager()
        }

        return Static.instance
    }

    init() {
        let configuration = NSURLSessionConfiguration.backgroundSessionConfigurationWithIdentifier("com.example.app.background")
        super.init(configuration: configuration)

        // For this to work:
        //
        //   - `delegate` (and whole `SessionDelegate` class) must be defined as `public`
        //   - `sessionDidFinishEventsForBackgroundURLSession` must be defined as `public`, too

        delegate.sessionDidFinishEventsForBackgroundURLSession = {
            session in

            // record the fact that we're all done moving stuff around

            // now, call the saved completion handler

            self.savedCompletionHandler?()
            self.savedCompletionHandler = nil
        }

        //   - and `downloadTaskDidFinishDownloadingToURL` must be defined as `public`, too

        delegate.downloadTaskDidFinishDownloadingToURL = {
            session, downloadTask, URL in

            let folder = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true)[0] as String
            let path = folder.stringByAppendingPathComponent(downloadTask.originalRequest.URL.lastPathComponent)

            return NSURL(fileURLWithPath: path)!
        }

    }

    // I personally don't think `Manager` should have defined this
    // as `required`. Let me `override` it if I need, but if I don't
    // need to, why force me to?

    required init(configuration: NSURLSessionConfiguration?) {
        super.init(configuration: configuration)
    }
}
```

Then, when I want to initiate a bunch of background downloads, I can do something like:

```
for filename in array {
    let imageURL = baseURL?.URLByAppendingPathComponent(filename)
    BackgroundManager.sharedInstance.download(NSURLRequest(URL: imageURL!), destination: nil)
}
```

Obviously, the app delegate also needs to respond to `handleEventsForBackgroundURLSession`:

```
func application(application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: () -> Void) {
    BackgroundManager.sharedInstance.savedCompletionHandler = completionHandler;
}
```

In my above fork, I only tackled downloads, and one should really review uploads, too. And my implementation probably needs more error handling processing to be implemented, too. Frankly, I'd probably redesign the blocks to more intelligently handle the session delegate determining the success or failure of the request delegate. But hopefully this gets people thinking about this issue...
 Thanks for sharing your altered version of Alamofire and the above examples! Really useful to get background sessions working with the current version. I agree this is not the ideal solution and understand why you don't submit it as PR. Hope we have a robust Alamofire based solution in the near future, but this could help a lot of people out in the meantime!
 I'm a little confuse, the readme page has a section for Creating a Manager with Background Configuration, so it should support background download, but as stated above is not.
Are any official plans to fully support this?
 I just submitted a PR to address all these issues #317. Please take a look and possibly provide some feedback. With these changes, we can easily handle background sessions. Thanks @robertmryan for all your initial feedback in this ticket. That certainly made it easier to attack the problem. Hopefully we can get some traction from @mattt to see how this will pan out.

For anyone interested or in need, my fork and branch can be found [here](https://github.com/cnoon/Alamofire/tree/background_sessions).
 This issue has been resolved with the latest `1.2.0` release! Alamofire now has proper background session support.
  Not sure how else to describe this issue, other than putting `* 1.0` into my `println` call causes a build failure with an ambiguous error. I'm not sure what's going on here, so I'll post an example of code that compiles and code that doesn't.

Error thrown:

```
/MyPath/ViewController.swift:73:20: Could not find member 'GET'
```
# Won't Compile

``` swift
let url = "http://mplewis.com"
let destination = Alamofire.Request.suggestedDownloadDestination(directory: .DocumentDirectory, domain: .UserDomainMask)
Alamofire.download(.GET, url, destination)
    .progress( { some, all, total in
        println("\(all * 1.0 / total)")
    }).response( { request, response, _, error in
        println(response)
    })
```
# Will Compile

``` swift
let url = "http://mplewis.com"
let destination = Alamofire.Request.suggestedDownloadDestination(directory: .DocumentDirectory, domain: .UserDomainMask)
Alamofire.download(.GET, url, destination)
    .progress( { some, all, total in
        println("\(all / total)")
    }).response( { request, response, _, error in
        println(response)
    })
```
  Alamofire doesn't fetch data in Xcode 6.1 projects. Works only the first time after it's added to project, and when the project closes and reopens again, Alamofire.request causes this error:

```
fatal error: unexpectedly found nil while unwrapping an Optional value
```

Even example application won't work then.

![Screenshott](http://i.imgur.com/u7dOMCl.png)

I just noticed following errors in Alamofire.swift

```
Alamofire.swift:712:17: Use of unresolved identifier 'dispatch_suspend'
Alamofire.swift:771:13: Use of unresolved identifier 'dispatch_resume'
```
  404 is normally due to a resource not being found on the server at the location you specified in the URL. You sure you have the URL correct? I think you'd normally get 401 for unauthenticated. 
 Are you expecting the basic auth header to be sent as preauthentication? Unfortunately this isn't build in yet #32 
  A fix for Issue #141

There are some inconsistencies with resume data closure parameter being exposed in non-download request. See issue thread for more detail.

The thing is that we have to be sure we will be OK with such interface for the first version at least, because if we decide to change it later, it will likely be a breaking change.
  is it possible to track the progress of POST requests?
  Update CRUD example to work on Xcode 6.1
  I've tried to add Alamofire to a project where the target is iOS 7.0, and I'm stuck. From the docs:

> For application targets that do not support embedded frameworks, such as iOS 7, Alamofire can be integrated by including the Alamofire.swift source file directly, and making the appropriate changes to calling semantics.

I added Alamofire as a git submodule, added the source (Alamofire.swift) to my project, and tried to do the following:

```
enum Router: URLRequestConvertible {
    var method: Method {
        switch self {
        case .Search:
            return .GET
        case .GetOAuthToken:
            return .POST
        }
    }
    // more code here...
}
```

But it doesn't compile - the line `return .GET` is red with the following message:

> 'Method.Type' does not have a member named 'GET'

The problem, I think, is that the compiler is confused - it thinks `Method` is the type from the Objective-C runtime. When I hold command and click on Method, it takes me to some ObjectiveC runtime Swift file, and when I option-click on it, it says the declaration is `typealias Method = COpaquePointer`.

So that's where I'm stuck. How do I add Alamofire to a project with an iOS Deployment Target of 7.0?
 Thanks - I'll give that a shot. I'm going to go out on a limb and guess that there's no way for me to include Alamofire.swift in another file, right? Like, for example, a hypothetical WrapAlamofire.swift:

```
struct Alamofire {
    #include Alamofire.swift
}
```

I'm guessing this doesn't exist in Swift, but perhaps I just don't know it well enough. But this would make it super convenient - so every time I update Alamofire, I wouldn't need to wrap it in the struct again.
 @mattt Thanks again - I just had to wrap Method, then make some updates inside Alamofire.swift. For anyone who's looking, I've made the necessary changes to get it working in iOS 7 and pushed it up to [roadfire/Alamofire](https://github.com/roadfire/Alamofire).
 @mattt Would a pull request be helpful for you? I realize you probably wouldn't want this in master, but perhaps an ios-7.0 branch would make sense?
 Hmm, I've tried to wrap Alamofire in `struct Alamofire { ... }`, but I'm getting a few pages long list of errors and warnings and even some momentary SourceKit flashes... Most of the errors say "Declaration is only valid at file scope". Am I doing something wrong?
 Look at what I did in my fork at roadfire/Alamofire. I think I only wrapped the Method in the struct, and that worked for me. 
 It seems to work without wrapping anything, except I don't like having all those functions in the global scope. So I'm wrapping just the convenience functions at the end in a struct, though I need to change them all to `static` because otherwise they become instance methods of the struct.
 First thx for this wonderful project. second, could you post an explicit example of how could i implement this on iOS7, i have this snippet from avlelg:

//put this on alamofire.swift, then call it as Alamofire.manager.your_method
struct Alamofire {
static let manager = Manager.sharedInstance
}

but i dont know if this is the right way to use this, or if there is a proper way to use it on iOS7, an example would be highly desirable. thanks
 @MikeRzDev  , just as @joshuatbrown mentioned, you can check the code here, https://github.com/roadfire/Alamofire/blob/master/Source/Alamofire.swift#L28
 @pyanfield  mmm maybe im doing it wrong (im using xcode 6.1, with a ios 7 project with swift)
but when I try to call Alamofire.request this is what happens:

1) using joshuatbrown alamofire.swift
![screen shot 2014-11-26 at 10 23 27 pm](https://cloud.githubusercontent.com/assets/6407124/5211987/61f0614e-75bb-11e4-8383-0afac2089b81.png)

2) using the method I have described\* with alamofire.swift from Alamofire-Master
![screen shot 2014-11-26 at 10 25 40 pm](https://cloud.githubusercontent.com/assets/6407124/5211989/698f1350-75bb-11e4-8721-707edd3e7fee.png)

*Method: 
/put this on alamofire.swift, then call it as Alamofire.manager.your_method
struct Alamofire {
static let manager = Manager.sharedInstance
}

Anyway I just hope that this would get better to call using iOS7 in the future, thx.
 @MikeRzDev your method that
/put this on alamofire.swift, then call it as Alamofire.manager.your_method
struct Alamofire {
static let manager = Manager.sharedInstance
}

is work. And now i can use it in iOS7 with source file

@mattt is this the easiest way or proper way?
 As per the readme.md, I've wrapped the latest Alamofire.swift in a struct and modified some of the code to recognize the new struct. Hopefully it works for others as well.

https://gist.github.com/ChocolateMinht/00aa610da1b4e6c4bed6
 So I tried ChocolateMinht's code but I keep getting the same error saying: "Module 'Alamofire' has no member named 'request' "

Trying: 
        Alamofire.request(.GET, "http://www.google.com")

I am adding swift to an existing Objc project and wanted to try using Alamofire within the swift classes I am creating. 

Also I never get any autocompletes for me ... not sure why.
 I solved this issue by changing the Build Active Architecture Only settings.
<img width="1440" alt="screen shot 2015-08-15 at 10 14 58 pm" src="https://cloud.githubusercontent.com/assets/3723510/9291680/d5cab8f4-439b-11e5-944c-19d7ecc3a6d4.png">
  I know that AFNetworking has support for the iOS network activity indicator/spinner, but I looked everywhere and it doesn't seem like Alamofire supports this.
 @mattt I started going the `NSURLProtocol` route you mentioned, however got stuck pretty quickly while trying to implement my `startLoading()`/`stopLoading()` methods. From what I can tell, Alamofire currently does not expose much of its `SessionDelegate` class which manages the actual network callbacks for me to hook into (to hide the NetworkActivityIndicator once request completes).

Could you elaborate on your thinking a little more? Would that `NSURLProtocol` mechanism be able to fall back on most of the existing implementation of Alamofire or do you see the `NSURLProtocol` have its own `NSURLSession` and track its progress via its own delegate methods?

//edit: moving this to stackoverflow - http://stackoverflow.com/questions/27422675/custom-nsurlprotocol-to-show-hide-networkactivityindicator
 I just implemented this idea: https://github.com/marcelofabri/BigBrother
 @marcelofabri But your implementation overrides whole Alamofire.Manager implementation. You replace NSURLSession with NSURLConnection and then methods of NSURLSessionDelegate can't be executed.
    This may be a really simple question but in the CRUD & Auth example (https://github.com/Alamofire/Alamofire#crud--authorization) how do you pass in the oauthtoken?
 @johnbeynon I'm confused by this example too. Did you find a solution for modifying the AuthToken when passing the router enum to Alamofire.request?
 I did it like

```
 Router.OAuthToken = oAuthToken
        if let ticket = self.ticket {
            Alamofire.request(Router.TicketComments(ticket.id))
                .responseJSON { (request, response, data, error) in
                    if let comments: NSArray = data as? NSArray {

```

not sure if that will help???
 @johnbeynon Ah! That makes sense. Thanks man!
 Guys im also confused even with @johnbeynon response, how do you access 

```
static var OAuthToken: String?
```

I can not access it outside the scope of the ENUM
 @diogoCW You can set it like so:

```
Router.AuthToken = 'YOUR AUTH TOKEN'
```
 I always get a Error("The supplied authentication is invalid") error message and I do it the exact same way that the example shows. Am I missing something?
    I'm using a custom oAuth implementation, so I need to pass an "oauth_signature"  I'm using a GET request and supplying the parameters as a Dictionary to Alamofire.request(...)

The issue I'm seeing is that Alamofire does not encode the "+" that often shows up in oAuth signatures (after base64 encoding)  It appears that this is causing the server to barf on that signature. Other special characters like a "/" are percent-encoded by Alamofire, but the "+" is not. I was wondering if this is typical behavior, but noticed that AFNetworking DOES encode the "+" (I had implemented this custom oAuth scheme in AFNetworking before, and I'm just porting it to Swift+Alamofire)

So is this a bug or a feature and if it's a feature, how can I work around it?  I can't percent-encode the value myself before sending it to Alamofire, because then the "%" characters get double-encoded, which produces the incorrect string as well. Any thoughts on what I can do?
 #166 
  We are trying to use Alamofire in a project where we are unit testing. Unfortunately there are two things that make this difficult

1) Due to the nature of Swift, the way to stub out dependencies in a unit test is to inject them. However it is not possible to inject classes. A bit of Alamofire's magic is in its static `request` method, so using an `Alamofire.Manager` became painful. In order to inject Alamofire we have had to write a wrapper class as follows, that lets as treat Alamofire as an instance instead of a class:

``` swift
import Alamofire
class NetworkingManager {
    func request(method: Alamofire.Method, URLString: URLStringConvertible, parameters: [String: AnyObject]? = nil, encoding: ParameterEncoding = .URL ) -> Request {
        return Alamofire.request(method, URLString, parameters: parameters, encoding: encoding)
    }
}
```

This allows us to create `FakeNetworkingManager` which is a subclass of `NetworkingManager` and inject it into classes that consume it for unit tests.

2) When trying to create `FakeNetworkingManager` which overrides `request`, we need to return an `Alamofire.Request` object. However the initializer for `Request` is private. Since Swift's access control system is very strict, we could not find a way to implement an initializer such that we could create and return a `Request` object from our fake.

This PR is about making `Requests``s init method public, so we can return a FakeRequest in our tests and properly unit test our classes.

Thanks,
 Tim
 Matt,

I don't disagree with your reasoning around not implementing this change. However, being able to dependency inject this layer can be important, whether it be for general object cohesion and decoupling or unit testing. I am wondering what patterns we will start using in Swift projects to unit test around libraries and how libraries will be designed to support this. Perhaps you could expose protocols that other objects could implement? More food for thought as you go forward I suppose.

Thanks,
 Tim
  Alamofire.request and Alamofire.upload can't help me 
  There were still some optionals that needed to be unwrapped, and quotes need to be escaped when posting JSON content.
 Heh, this also annoyed me today :+1: 
   So... later today ? :)
  Are there any plans of getting Alamofire available as a cocoapod? I was quite surprised I wasn't able to find it there to be honest.
 The version 0.36.0.beta.1 of cocoapods has support to Swift dependencies, Quick testing framework is one example on how to create pods for this version.

Please refer to [this](http://blog.cocoapods.org/Pod-Authors-Guide-to-CocoaPods-Frameworks/) blog entry for more details.
   Great, Thanks!
  XCode 6.1 GM2 refuses to build Alamofire correctly, here are some fixes I applied to make it build again.
 Thanks guys!  Works great now!
  @troypayne +1
 ```
 var alamofireManager : Alamofire.Manager?

func some(){
 let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
 configuration.timeoutIntervalForResource = 2 // seconds

 self.alamofireManager = Alamofire.Manager(configuration: configuration)
 self.alamofireManager!.request(.GET, "http://example.com/")
   .response { (request, response, data, error) in

   }
 }
```

get it from http://stackoverflow.com/questions/27135735/setting-client-side-timeout-per-request-with-alamofire-swift
  I can't seem to be able to have an object conform to ResponseCollectionSerializable protocol. 
Here's my `UserViewModel` class:

``` swift
class UserNetworkModel: ResponseObjectSerializable, ResponseCollectionSerializable {

    var username: String!
    var password: String!

    init() {

    }

    init(username: String, password: String) {
        self.username = username
        self.password = password
    }

    required init(response: NSHTTPURLResponse, representation: AnyObject) {
        self.username = representation.valueForKeyPath("username") as String
        self.password = representation.valueForKeyPath("password") as String
    }

    class func collection(#response: NSHTTPURLResponse, representation: AnyObject) -> [UserNetworkModel] {
        return []
    }

    func toDic() -> Dictionary<String,AnyObject> {
        return ["username": self.username, "password": self.password]
    }
}
```

And ResponseCollectionSerializable is copied from the Readme example.

What am i doing wrong?
 Is there a way to do this without making the class final? Ideally I would like to inherit from this class.
 I changed the protocol to return [AnyObject] instead of [Self], this way no final needed.
Is this is good way to void final? Or we have better way? @mattt 
Thanks
 @meng-zhang  : After changing the protocol to return  [AnyObject] instead of [Self], it gives me an error inside the ResponseCollectionSerializable extension .
case .Success(let value):
                if let response = response
                {
//Error in this particular line. "type of expression is ambiguous without more context".
                    return .Success(T.collection(response: response, representation: value))
                }

what am i doing wrong? Do i need to change the ResponseCollectionSerializable extension too? 
@mattt: Is there a way to do this without making the class final? Ideally I would like to inherit from this class. 
 same issue. I have a super class which is adopting those protocols (object & collection serializable) and would like to subclass it, but can not due to the fact that the superclass must be `final` according to the those protocol methods. 
    I get these errors when I git clone the Alamofire repo then change to the xcode-6.1 branch and open the ios example:

/Users/slooker/Desktop/iOS Programming/Alamofire/Source/Alamofire.swift:106:43: '(Method, URLStringConvertible, parameters: [String : AnyObject]?, encoding: ParameterEncoding) -> Request' does not have a member named 'HTTPMethod'
/Users/slooker/Desktop/iOS Programming/Alamofire/Source/Alamofire.swift:109:17: 'NSURLComponents?' does not have a member named 'percentEncodedQuery'
/Users/slooker/Desktop/iOS Programming/Alamofire/Source/Alamofire.swift:110:41: 'NSURLComponents?' does not have a member named 'URL'

I've managed to repeat this process and have had someone on another machine with a fresh install of Xcode-6.1 GM Seed 2 replicate it as well.
 You are downloading the latest version of it?
I don't have these problems.
 getting the same errors, will try a clean update
 http://vimeo.com/108638201  

This shows me pulling from source and then changing to xcode-6.1 branch and the errors I'm getting when I open the included iOS Example project.  

(Ignore the first part of the video, I forgot to change the branch when I opened, so I had to close it, change branches then re-open)
 The problem section is around line 108 in Alamofire.swift:

```
 if let URLComponents = NSURLComponents(URL: mutableURLRequest.URL!, resolvingAgainstBaseURL: false) {
      URLComponents.percentEncodedQuery = (URLComponents.query != nil ? URLComponents.query! + "&" : "") + query(parameters!)
      mutableURLRequest.URL = URLComponents.URL
 }
```

`URLComponents` is an optional causing the errors getting thrown about `URL` and `percentEncodedQuery`. Unwrapping `URLComponents` like above silences those errors. The snippet above was just the result of me playing around. The actual solution should perhaps include a behavior if/when `NSUrlComponents` returns nil and does not get unwrapped. 

Not pull request nor total solution yet - but hopefully this helps someone. :)

Cheers
 This fixes the errors on line 108, but not the errors on line 106:  

```
        let method = Method(rawValue: mutableURLRequest.HTTPMethod)
```

 '(Method, URLStringConvertible, parameters: [String : AnyObject]?, encoding: ParameterEncoding) -> Request' does not have a member named 'HTTPMethod'
 Looks like that error is the same as this one:  https://github.com/Alamofire/Alamofire/issues/164
  I try this:

``` swift
Alamofire.request(.POST, url, parameters: json)
```

but XCode give me the error: "could not find member 'POST'"
 try Method.POST
 I still get some errors. Maybe is a installation error. Take a look in how I did it:
![captura de tela 2014-10-12 as 12 22 37](https://cloud.githubusercontent.com/assets/1590527/4606548/a3f1ab5e-5223-11e4-953c-c369fd49bb98.png)
The iOS target of Alamofire is the same that my project. What I did wrong? Can u help me?
 for me,i add "Almofire.h" file and "Almofire.swift" file into my project, and then use "request" method;hope to help youÔºõ
 Had similar issue.  Check that your .request parameters are of the correct type.  In my case, I was passing a [String] as the parameter field, but it's expecting a dictionary.  So I changed "parameter: emails" to "parameter: ["emails", emails]" and that error went away.

Essentially, the error message XCode was reporting was misleading...
 So here's how this error happens: the method signature you wrote doesn't actually match the Alamofire declaration, so type inference can't deduce that `.POST` means `Alamofire.Method.POST` - and by the way, `Method.POST` isn't specific enough.

Replacing `.POST` with `Alamofire.Method.POST` will uncover the true error - which was, for me like for @SteveNewhouse, parameters of the wrong type -  I had an optional as the parameter value. Replacing `parameters: ["foo": bar]` with `parameters: ["foo": bar!]` fixed the error.
 @leonid-shevtsov +1 "Replacing `.POST` with `Alamofire.Method.POST` will uncover the true error" Thank you
 @leonid-shevtsov Thank you for great tip!
  This change made the library work for me. 
 per the heads up by @Isuru-Nanayakkara in issue #53 
  This fixes #166 
 Thank you :)
 Would also fix #181 so this pull request has my upvote :)
  When parsing query parameters, the plus-sign (+) is interpreted as space. Shouldn't it therefore be part of the escaped characters list?
 Can't compile, got
Alamofire/Source/Alamofire.swift:109:17: 'NSURLComponents?' does not have a member named 'percentEncodedQuery'
Alamofire/Source/Alamofire.swift:110:41: 'NSURLComponents?' does not have a member named 'URL'
 Which Xcode version and which SDK are you compiling with?
  Hi,

I'm getting the following error on Xcode 6.1, not sure what I'm doing wrong.  Copied the framework as per instructions:

let method = Method(rawValue: request.HTTPMethod)

Alamofire.swift:106:43: '(Method, URLStringConvertible, parameters: [String : AnyObject]?, encoding: ParameterEncoding) -> Request' does not have a member named 'HTTPMethod'
 After change, I'm getting an error in the following line:
Value of optional type 'Method?' not unwrapped; did you mean to use '!' or '?'?
  Hey,

I am very fresh to to iOS development (Swift is my first attempt).

So I loaded a new project. Followed the instructions how to setup Alamofire, tried first examples and BAAM ! Error. I done some research and some say it is Xcode problem ... Is it ? Or am I doing something very wrong ?

![screen shot 2014-10-09 at 23 25 55](https://cloud.githubusercontent.com/assets/1636440/4583536/89819a50-4ff2-11e4-81c2-62410c23eed5.png)
 @Katafalkas. i have same issue. have you find any solution ?
 never mind. it was server problem.thanks
 I had this issue a lot with both XCode 6.1 and 6.2. The solution is to quit XCode and iOS Simulator and re-open them. The reason is you I was moving from work to home or vise-versa and WiFi network was changing. I hope this help others  :smile: 
 Similar problem when using the Charles Web Debugging Proxy.  I have to quit and restart the simulator when done using Charles. 
  Seems to be an issue with the URLEncoding.... 

``` swift
    var nowString = "Thursday, October 9, 2014 at 9:11 PM";
    Alamofire.request(.GET, "http://requestb.in/qhvdivqh", parameters: ["when": nowString])
```

```
Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '*** +[NSURLComponents setPercentEncodedQuery:]: invalid characters in percentEncodedQuery'
*** First throw call stack:
(
    0   CoreFoundation                      0x000000010d5a73f5 __exceptionPreprocess + 165
    1   libobjc.A.dylib                     0x000000010f0d5bb7 objc_exception_throw + 45
    2   CoreFoundation                      0x000000010d5a732d +[NSException raise:format:] + 205
    3   Foundation                          0x000000010da8909d -[__NSConcreteURLComponents setPercentEncodedQuery:] + 153
    4   Alamofire                           0x000000010d392045 _TFO9Alamofire17ParameterEncoding6encodefS0_FTPS_21URLRequestConvertible_10parametersGSqGVSs10DictionarySSPSs9AnyObject____TCSo12NSURLRequestGSqCSo7NSError__ + 8325
    5   Alamofire                           0x000000010d3c243d _TF9Alamofire7requestFTOS_6MethodPS_20URLStringConvertible_10parametersGSqGVSs10DictionarySSPSs9AnyObject___8encodingOS_17ParameterEncoding_CS_7Request + 477
    6                                 0x000000010d2f4e15 _TFC5S11AppDelegate11applicationfS0_FTCSo13UIApplication29didFinishLaunchingWithOptionsGSqGVSs10DictionaryCSo8NSObjectPSs9AnyObject____Sb + 1077
    7   S                               0x000000010d2f5196 _TToFC5S11AppDelegate11applicationfS0_FTCSo13UIApplication29didFinishLaunchingWithOptionsGSqGVSs10DictionaryCSo8NSObjectPSs9AnyObject____Sb + 502
    8   UIKit                               0x000000010de2c5a5 -[UIApplication _handleDelegateCallbacksWithOptions:isSuspended:restoreState:] + 234
    9   UIKit                               0x000000010de2d0ec -[UIApplication _callInitializationDelegatesForMainScene:transitionContext:] + 2463
    10  UIKit                               0x000000010de2fe5c -[UIApplication _runWithMainScene:transitionContext:completion:] + 1350
    11  UIKit                               0x000000010de2ed22 -[UIApplication workspaceDidEndTransaction:] + 179
    12  FrontBoardServices                  0x0000000111bdc2a3 __31-[FBSSerialQueue performAsync:]_block_invoke + 16
    13  CoreFoundation                      0x000000010d4dcabc __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__ + 12
    14  CoreFoundation                      0x000000010d4d2805 __CFRunLoopDoBlocks + 341
    15  CoreFoundation                      0x000000010d4d25c5 __CFRunLoopRun + 2389
    16  CoreFoundation                      0x000000010d4d1a06 CFRunLoopRunSpecific + 470
    17  UIKit                               0x000000010de2e799 -[UIApplication _run] + 413
    18  UIKit                               0x000000010de31550 UIApplicationMain + 1282
    19  S                               0x000000010d2f583e top_level_code + 78
    20  S                               0x000000010d2f587a main + 42
    21  libdyld.dylib                       0x000000010fcbc145 start + 1
    22  ???                                 0x0000000000000001 0x0 + 1
)
libc++abi.dylib: terminating with uncaught exception of type NSException
```
  ```
    Alamofire.request(.GET, "http://httpbin.org/get", parameters: ["foo": "bar"])
        .validate()
        .response { (_, _, _, error) in
            println(error)
    }
```

This results in the error:
'Request' does not have a member named 'validate'.
 https://github.com/slooker/TestAlamofire

There's a github repository that is a new project that I added the xcode-6.1 version of Alamofire to and then copied and pasted the example you have for validate().

![screen shot 2014-10-09 at 4 14 28 pm](https://cloud.githubusercontent.com/assets/161517/4585697/1a8a7622-500a-11e4-87de-f2cc5b033618.png)
 I'm open to suggestions...  I do a checkout like so:

git checkout https://github.com/Alamofire/Alamofire.git
cd Alamofire
git checkout xcode-6.1
cd ..
cp -rf Alamofire NewTestProject/

From there I follow the instructions on the install.

Then I just use the code that is in the example:

Alamofire.request(.GET, "http://httpbin.org/get", parameters: ["foo": "bar"])
         .validate()
         .response { (_, _, _, error) in
                  println(error)
         }

I'll try and screen cast my process.

On Thu, Oct 9, 2014 at 5:06 PM, Mattt Thompson notifications@github.com
wrote:

> I don't know what to tell you. validate exists and works just fine on the
> HEAD of the xcode-6.1 branch
> https://github.com/Alamofire/Alamofire/blob/xcode-6.1/Source/Alamofire.swift#L832-L842.
> If your local copy doesn't have it, your local copy is out of date.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub
> https://github.com/Alamofire/Alamofire/issues/161#issuecomment-58596482.
 This happens to me as well. (Module 'Alamofire' has no member named 'request')

It happens when I change build active architecture only to NO for debug.
If I set it to YES there is no error.
 I am seeing the same error as @ipeisong using Xcode 6.1.1 (6A2008a) and Alamofire 1.1.2. Anyone figure out how to fix this?
 This has happened to me a few times; Unfortunately the only answer I've come up with that is reliable is "Nuclear":  Delete the contents of "~/Library/Developer/Xcode/DerivedData". 

It appears to be more superstitious than fact based but it seems to work for me.
 Happening with me too.
 I have the same problem
 Happening with me too. Xcode 6.3 and Alamofire 1.2.3
 Same problem here
      The post data seems to be encoded twice when sending post data. The @ in the sent email encodes to %40 and then %2540.
The code

``` Swift
        let email = "name@gmail.com"
        let parameters = ["email": email]
        let URL = NSURL(string: "https://example.com")
        var request: Request = Alamofire.request(.POST, URL, parameters: parameters, encoding: .URL)
        println(request.debugDescription)
```

prints

```
$ curl -i \
    -X POST \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -H "Accept-Language: en;q=1.0,fr;q=0.9,de;q=0.8,zh-Hans;q=0.7,zh-Hant;q=0.6,ja;q=0.5" \
    -H "User-Agent: Test-Alamofire/testAlamofire.Test-Alamofire (1; OS Version 8.0 (Build 12A365))" \
    -H "Accept-Encoding: gzip;q=1.0,compress;q=0.5" \
    -d "email=name%2540gmail.com" \
    "https://example.com"
```

Reverting the changes made in #121 fixes this problem for me. 
  I want to create a custom manager instance and use it:

```
var configuration: NSURLSessionConfiguration = NSURLSessionConfiguration.defaultSessionConfiguration()

//add the Alamofire default headers to the configuration
configuration.HTTPAdditionalHeaders = Alamofire.Manager.sharedInstance.session.configuration.HTTPAdditionalHeaders

let manager = Alamofire.Manager(configuration: configuration)

let url = NSURL(string: "http://192.168.0.10/test")

manager.request( NSURLRequest(URL: url) )
    .response{(request, response, _, error) in
        println("\(error)")
    }
```

Which gives me an error:
Error Domain=NSURLErrorDomain Code=-999 "cancelled"

If i try this with the Singleton it works fine:

```
//let manager = Alamofire.Manager(configuration: configuration)
let manager = Alamofire.Manager.sharedInstance
```

Shouldn't the above code work with a custom instanced manager, too?

Thanks in advance.
 So about this issue how to implementation modified configuration with manager instead of using default configuration with sharedInstance?
 I had the same problem, is there a way to set up a specific session manager for modification instead of modifying the global default one?
 @cloud-hot @kohakugawa You just have to ensure that `manager` is retained. There are lots of ways you can do this. At the simplest level, for example, you could make it a stored property for a custom `NetworkManager` class:

```
import Foundation
import Alamofire

class NetworkManager {

    var manager: Manager?

    init() {
        let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
        manager = Alamofire.Manager(configuration: configuration)
    }
}
```
 @rainypixels , Thanks! I will try it later.
 http://stackoverflow.com/questions/30906607/about-alamofire-version-for-use-manager
 After trying all the solutions provided above, my code still fails with same error. For my case, it's because I made too many requests within same session, which exceed the maximum limit (https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSURLSessionConfiguration_class/#//apple_ref/occ/instp/NSURLSessionConfiguration/HTTPMaximumConnectionsPerHost).

Sample code:

let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
configuration.HTTPMaximumConnectionsPerHost = 10   // Some arbitrary number that I feel big enough.
let manager = Alamofire.Manager(configuration: configuration)
 help me !!!!

Error Domain=NSURLErrorDomain Code=-999 "cancelled" UserInfo=0x78fc41e0 {NSErrorFailingURLKey=myURL, NSErrorFailingURLStringKey=myURL, NSLocalizedDescription=cancelled}
 Can you print out the sample request using the debugprint()
 my method is:

-(NSURLSessionDataTask *)logingUser:(NSString *)user password:(NSString *)password completion:(void (^)(NSDictionary *results, NSError *error))completion {
    NSURLSessionDataTask *task = [self POST:kBASE_URL
                                 parameters:@{@"request" : @"login"}
                  constructingBodyWithBlock:^(id<AFMultipartFormData> formData) {
                      [formData appendPartWithFormData:[user dataUsingEncoding:NSUTF8StringEncoding] name:@"user"];
                      [formData appendPartWithFormData:[password dataUsingEncoding:NSUTF8StringEncoding] name:@"password"];
                  }
                                    success:^(NSURLSessionDataTask *task, id responseObject) {
                                        NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)task.response;
                                        if (httpResponse.statusCode == 200) {
                                            dispatch_async(dispatch_get_main_queue(), ^{
                                                completion(responseObject, nil);
                                            });
                                        } else {
                                            dispatch_async(dispatch_get_main_queue(), ^{
                                                NSLog(@"Received HTTP %ld", (long)httpResponse.statusCode);
                                                completion(nil, nil);
                                            });
                                        }
                                    } failure:^(NSURLSessionDataTask *task, NSError *error) {
                                        dispatch_async(dispatch_get_main_queue(), ^{
                                            NSLog(@"ERROR: %@", [Utility localize:@"Connection_Error"]);
                                            NSLog(@"ERROR-LOG: %@",error);
                                            completion(nil, error);
                                        });
                                    }];
    return task;
}

my  Log show:

 ERROR: Could not connect to the server

Error Domain=NSURLErrorDomain Code=-999 "cancelled" UserInfo=0x78fc41e0 {NSErrorFailingURLKey=myURL, NSErrorFailingURLStringKey=myURL, NSLocalizedDescription=cancelled}
 Are you sure your url is correct, since the address (https://vodafoneplazaapp.vodafone.es:20000/api.php) shows no endpoint.
 that is the URL, but managed not find the error in my code
 I have the same issue. When I configured the Security Policies:

```
.PinCertificates(
        certificates: ServerTrustPolicy.certificatesInBundle(),
        validateCertificateChain: true,
        validateHost: true
    )
```

I got this error:

```
Error Domain=NSURLErrorDomain Code=-999 "cancelled"
```

and when I disable the security policies, it works. What could it be the problem? The certificate? The server configuration?

Thanks
 Have you configured the App Transport Security (
http://stackoverflow.com/questions/30731785/how-do-i-load-an-http-url-with-app-transport-security-enabled-in-ios-9)
?

2016-01-05 7:58 GMT-08:00 nicopuri notifications@github.com:

> I have the same issue. When I configured the Security Policies:
> 
> .PinCertificates(
>         certificates: ServerTrustPolicy.certificatesInBundle(),
>         validateCertificateChain: true,
>         validateHost: true
>     )
> 
> I got this error:
> 
> Error Domain=NSURLErrorDomain Code=-999 "cancelled"
> 
> and when I disable the security policies, it works. What could it be the
> problem? The certificate? The server configuration?
> 
> Thanks
> 
> ‚Äî
> Reply to this email directly or view it on GitHub
> https://github.com/Alamofire/Alamofire/issues/157#issuecomment-169043226
> .
 Or, in the Alamofire official page (
https://github.com/Alamofire/Alamofire#app-transport-security)

2016-01-05 8:49 GMT-08:00 Yu Guo nyuguoyu@gmail.com:

> Have you configured the App Transport Security (
> http://stackoverflow.com/questions/30731785/how-do-i-load-an-http-url-with-app-transport-security-enabled-in-ios-9)
> ?
> 
> 2016-01-05 7:58 GMT-08:00 nicopuri notifications@github.com:
> 
> > I have the same issue. When I configured the Security Policies:
> > 
> > .PinCertificates(
> >         certificates: ServerTrustPolicy.certificatesInBundle(),
> >         validateCertificateChain: true,
> >         validateHost: true
> >     )
> > 
> > I got this error:
> > 
> > Error Domain=NSURLErrorDomain Code=-999 "cancelled"
> > 
> > and when I disable the security policies, it works. What could it be the
> > problem? The certificate? The server configuration?
> > 
> > Thanks
> > 
> > ‚Äî
> > Reply to this email directly or view it on GitHub
> > https://github.com/Alamofire/Alamofire/issues/157#issuecomment-169043226
> > .
 @guoyu1989 I fixed it! The problem was on the server side. The certificate was signed with SHA-1 instead of SHA256 and the key to generate the Certificate should be 2048, not 4096.
 I had very a stupid problem, maybe this can help someone. I used function that looks like this to get my authenticated operation manager.

```
func authenticatedOperationManager(block: operationManagerBlock) -> Void {
        self.getAccessTokenWithResponseBlock { (success, response) -> Void in
            if success {
                let accessToken = response as! String

                var defaultHeaders = Alamofire.Manager.sharedInstance.session.configuration.HTTPAdditionalHeaders ?? [:]
                defaultHeaders["auth-token"] = "\(accessToken)"

                let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
                configuration.HTTPAdditionalHeaders = defaultHeaders
                configuration.HTTPMaximumConnectionsPerHost = 10
                self.authenticatedOperationManager = Alamofire.Manager(configuration: configuration)

                block(manager: self.authenticatedOperationManager, error: nil)
            }
            else {
                block(manager: nil, error: "\(response)")
            }
        }
    }
```

As you can see, Manager is retained, MaximumConnectionsPerHost is set to something above 1 or 2 and everything else looks fine. Problem is, with this function I'm practically making a new Manager while the Manager is already working on some request - that's when the request gets cancelled. I needed to add this block just above let accessToken = ...

```
if (self.authenticatedOperationManager != nil) {
    block(manager: self.authenticatedOperationManager, error: nil)
    return
}
```
 you can try like this ,but i don't know why!

class NetworkManager {

```
var manager: Manager?
static let sharedInstance: Manager = {
    // work
    let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
    configuration.timeoutIntervalForRequest = 4
    configuration.timeoutIntervalForResource = 4
    configuration.HTTPAdditionalHeaders = Manager.defaultHTTPHeaders

    return Manager(configuration: configuration)
}()
init() {
    // does not work
    let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
    configuration.timeoutIntervalForRequest = 4
    configuration.timeoutIntervalForResource = 4
    configuration.HTTPAdditionalHeaders = Manager.defaultHTTPHeaders
    manager =  Alamofire.Manager(configuration: configuration)
}
```

}
 @karmaios 
I got the same problem, but I resolved it with the method following.

http://stackoverflow.com/questions/33146003/afnetworking-with-request-error-code-999

> You need to save the manager so that it lives for the full duration of the request. Save it in a property somewhere.

I created a static instance of Manager in my webapi class.

thanks
 dfgerg
 If your certificate is a self-signed certificate, you should set _validateCertificateChain_ to _false_. You can see this instruction in the Alamofire reference on github.

Follow an example bellow:

```
let serverTrustPolicy = ServerTrustPolicy.PinCertificates(
            certificates: [secCert!],
            validateCertificateChain: false,
            validateHost: true
        )
```
  I originally was getting an error with Alamofire when I tried to import it where it would tell me it could not build the objective-C module.  I changed the branch for Alamofire to xcode-6.1 and now I get these errors:

![screen shot 2014-10-07 at 2 11 26 pm](https://cloud.githubusercontent.com/assets/161517/4550457/d319896c-4e66-11e4-8828-42cee45de0a1.png)
 Hey troypayne.  That looks to be a separate error and I'd go ahead and create a separate issue for it.  

My error looks like it was because I already had xcode open with the Alamofire project imported into it.  When I checked out the xcode-6.1 branch and then copied it over, for some reason xcode didn't recognize the newer version.

I fixed this by deleting Alamofire complete from my project (and from the file system), closing xcode, then copying the xcode-6.1 branch into my project.  I then re-opened the project and re-added Alamofire and it seems to work.
  When performing a POST request like so:

```
Alamofire.request(
  .POST,
  loginURL,
  parameters: [
    "username" : "someusername",
    "pwd" : "coolpassword//"
  ],
  encoding: .URL)
  .responseString { (URLRequest, URLResponse, string, error) in
    println("\(string)")
}
```

The HTTPBody on the URL request escapes the parameters twice when the Method is POST:

```
116: mutableURLRequest.HTTPBody = (CFURLCreateStringByAddingPercentEscapes(nil, query(parameters!) as NSString, nil, nil, CFStringConvertNSStringEncodingToEncoding(NSUTF8StringEncoding)) as NSString).dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)
```

query(parameters!) already escapes the string, and then CFStringConvertNSStringEncodingToEncoding() percent escapes the already escaped string :(

```
coolpassword// 
```

becomes:

```
coolpassword%252F%252F 
```

when it should be:

```
coolpassword%2F%2F
```

Is there any reason why CFURLCreateStringByAddingPercentEscapes() is needed (removing it fixes this problem :smiley: )?
 Whoops! Looks like that just got merged in not long ago, thanks @mattt!
  Hello Matt, sorry for filing this as an issue, it really is more of a question than anything else. 

We are using Alamofire and love it! (thanks!). We are trying to now use it in a SSO context where an initial request would cause a redirect to a SSO solution (Shibboleth). While that initial request has not be resolved, all request should be queued until the credentials have been acquired. 

We are trying to find out how this could be done with Alamofire. We were looking at either doing a NSURLProtocol handler or a session delegate to detect the redirect to the known SSO url, and then do something to react to that and start the queuing process. 

Do you have any thoughts on how this could work with Alamofire and where we would tie into?

Thanks.
  apparently there was an issue when special symbols in the HTTP body were encoded twice, transforming string name@example.com into name%2540example.com
  Is there a way i can use Alamofire in iOS 7.0 project. If i copy just Alamofire.swift file to the project I don't have namespace and have to write just Manager.sharedInstance.request instead Alamofire.request or i have to put request only. Is there other way to use library in iOS 7.0 and some namespacing?
 #112 talks about embedded the framework for iOs 7, it would be better i guess if you include the library as stated in the readme (which was updated yesterday).
 Ok but if I include it as it is written in the readme it is embeded framework and i can't use it in iOS 7.0 target.
 yes you can, please follow the instructions mentioned in the linked issue, https://github.com/Alamofire/Alamofire/issues/112#issuecomment-57608716
and from the readme: (4. Ensure that the deployment target of Alamofire.framework matches that of the application target.)
 I've put all deployment targets (iOS Project and Alamofire) to 7.0, but I receive an error :
ld: warning: embedded dylibs/frameworks only run on iOS 8 or later
 Just clean it up. Close&Open xCode
It works for a lot of people.
Any way this is not an issue and should be on Stackoverflow
 So i've cleaned the project, deleted the derived data, quit xcode, but the warning still exists. I think that this is an issue because i could not use the library as for iOS 7. Is there someone who submitted and iOS 7.0+ app in the store with Alamofire lib
 yeah the error still exists, and it won't go anywhere, but you'll be able to use it normally and try it out in the simulator, even submitting the app would work. 
This warning has to do with XCode linker and swift support for iOs 7 as a framework.. but doesn't mean it won't work.. it's just warning, one of the few you can safely ignore, I believe ;)
 I've not been able to submit iOS 7.1 support (Following the instructions above with Xcode 6.0)...  Help?

App compiles and runs on iOS 7.1 device but it cannot be submitted via XCode or Application loader.
![screen shot 2014-10-09 at 9 21 27 am](https://cloud.githubusercontent.com/assets/364754/4569976/6ca9f682-4f54-11e4-9b91-6e32bd75868b.png)
 LightD commented 3 days ago
yeah the error still exists, and it won't go anywhere, but you'll be able to use it normally and try it out in the simulator, even submitting the app would work. 

Are you sure about submitting the app ?
 hmmmm.. I'm sorry guys, I don't have access to apple developer account, so I can't it out, I'm not sure what's the exact error or how to solve it, sorry I'm not much of help with this one :confounded: 
 @andrew-knott Did you find a solution?
 Dropped back to AFNetworking so I could submit.
 @andrew-knott Frameworks aren't supported before iOS 8. If you want to support iOS 7 and still use Alamofire you must copy the Alamofire.swift file into your target directly.
 @stephencelis, that is what i was saying, but @LightD told me that there is no problem about that and there is no problem for submitting the app
 @LightD's instructions say to make the deployment targets the same, in which case they'd both be iOS 8. If you must support iOS 7, make sure that:
1. The `Alamofire.swift` file's target membership includes your app target.
2. The `Alamofire.framework` does not exist in any of your target's build phases (dependency, linked library, or copy frameworks).
 So i can't use Alamofire.request(...) for example, just request(...)?
 @mmarkov93 Right, or shim things with a wrapper and aliased functions.

``` swift
struct Alamofire {
    static func request(/* ... */) -> /* ... */ { return request(/* ... */) }
    /* ... */
}
```
 Yes, i know that, but cant wrap it without changin the lib and cant just wrap the whole file. I was searchig a lot to get a working solution, but i can't find :(
 If you've already released your iOS 7 version to the app store and can afford to freeze that release in iTunes Connect, then you should be able to start using Alamofire in an iOS 8-only version.
 Yes i know. But i have requirement iOS 7.0+
 So you have a few options:
1. Wait till you can freeze your iOS 7 version and use Alamofire when you can develop for iOS 8.
2. Import `Alamofire.swift` directly into your project and omit the `Alamofire` module name when calling its functions.
3. Write your own shim, as instructed above.
 OK, I think the install docs need to be clarified. 
 @andrew-knott I appologize if my instructions were misleading :disappointed: 
@stephencelis Thnx for the clarification :+1: 
 @andrew-knott bump. The README should be clarified about how iOS 7 support is achieved. Current requirements section is misleading:
https://github.com/Alamofire/Alamofire#requirements
 Hey friends‚Äî  does anyone know of any issues with just changing the Alamofire Xcode project target to a Cocoa Touch Static Library, in order to achieve iOS 7 support?  This seems to be working for me so far (very preliminarily)
 @cblackcom last I heard Swift was not supported in a static library, but maybe they solved that and I missed it...
 Has anyone done "Write your own shim, as instructed above."?
  Hello

It's the return of the encoding bug 

```

*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '*** +[NSURLComponents setPercentEncodedQuery:]: invalid characters in percentEncodedQuery'
```

Exception breakpoint show that it's happen on line 109 of file Alamofire.swift

```
   if method != nil && encodesParametersInURL(method!) {
                let URLComponents = NSURLComponents(URL: mutableURLRequest.URL!, resolvingAgainstBaseURL: false)
                URLComponents.percentEncodedQuery = (URLComponents.query != nil ? URLComponents.query! + "&" : "") + query(parameters!)
```

I can get the URLComponents to be printed in console. But after diagnostics, I noticed that the exception is triggered when I add a space (" ") in my textfield. So I'm pretty sure the bug come from around.

More over this wasn't happening before I pull the submodule this morning. This bug was recently introduced.

Thanks,
Damien
 It's a call on Google Place API : https://developers.google.com/places/documentation/autocomplete
Parameters are classical 

```
    private func buildParameters(location : PFGeoPoint!) -> [String:AnyObject] {
        return [
            "input" : currentlyWorkingOnQuery,
            "key" : kPlaceApiKey,
            "location" : "\(location.latitude),\(location.longitude)",
            "types" : "address"
        ]
    }

    private func doQuery(forLocation location : PFGeoPoint) {
        Alamofire
            .request(Alamofire.Method.GET, googleAPIAutoComplete, parameters:self.buildParameters(location))
            .responseJSON { (request, response, data, error) in
                if(error == nil) {
                    self.parseData(data!)
                    self.closeQuery()
                }
        }
    }
```

If you type "2,rue" in the simulator as value for `currentlyWorkingOnQuery` it's successful
If you type "2,rue " the exception is raised.
 The problem is now, with the ampersand encoding change #146, if you supply a parameter value that is not ampersand encoded properly, NSURLComponents.percentEncodedQuery will throw an exception. That's mentioned int he documentation.

If I revert the change (back to using URLComponents.query), it works.
  I'm trying to make a post upload request with parameters but it does not work ... .

Swift compiler error display  ''Extra argument in call''

Here is my code    

```
   '' var data : NSData =   UIImagePNGRepresentation(UIImage(named: "file.png"))

    Alamofire.upload(.POST, self._selectedPatient.filesUrl, parameters:["key":"value"],data)
        .responseJSON { (request, response, JSON, error) in

            println(JSON)
    } ''
```

How can we make a post request with multiple parameters ?
 How can i upload a image along with parameter?? Eg i want to upload an album with images with its name and description?(Im totally new with IOS please help me)
 ![screen shot 2015-07-20 at 3 16 19 pm](https://cloud.githubusercontent.com/assets/12035987/8773512/6a3694b8-2ef2-11e5-9d7a-463cf0e506be.png)

Im getting error at .POST ,@cnoon
  I'm working with a Rails backend, and it seems like there is an issue with the GET request when JSON encoding is used (my parameter payload is a bit large, so I can't use URL encoding). I'm getting this error from Rails:  ERROR invalid body size

The POST requests with JSON encoding work fine, just the GET requests don't. Any ideas?
  If I try to make a request that has parameter value that has an ampersand in it, the ampersand is not encoded correctly. For example I see this being sent to my server:

token.php?value1=m6%23d7&8B&value2=roy.jaworski

When I should be seeing:

token.php?value1=m6%23d7%268B&value2=roy.jaworski

If I try to encode the value by replacing the & with %26 manually, the % gets encoded, which confuses things even more. 

I suspect I'm missing something, but I don't know what. I've tried both a get and post request with the same results. 

The way I'm preparing the parameter is as a simple array like this:

```
let requestParams = [
  "value1": "m6#d7&8B",
  "value1": "roy.jaworski"
]


Alamofire.request(.GET, requestUrl, parameters: requestParams)
  .response{ (request, response, data, error) in
  println(request)
  println(response)
  println(error)
}
```

Any assistance you can provide will be very welcome. 
 I think Alamofire is built upon the convention of building up the url for you based on passed parameters. However, I believe, as of now, the default operation does not encode the ampersand due to it being a permitted value in an encoded url.  However, this does cause some problems.  

I'd like to contribute to this project, and I'm working on adding a filter function as a pull request. The design is to encode all keys and values (including `&` and `?` when the filter is turned on.  This makes sure you get the desired behavior, unless you attempt to encode them yourself (which is when you'd turn the filter off).
 Hi,

Thanks for being so responsive.

I can confirm that in my tests, using the original code, the parameters are encoded correctly for get requests. Unfortunately for post requests it appears that the parameters are encoded twice. 

Could you investigate further? I'm new to Swift and would like to help, but I'm not sure where to start. 
  Alamofire was not including parameters whose value was an empty array in the URL request. I've added a check to handle an empty array, as well as two tests to ensure consistent behavior between URL and JSON parameter encoding.
  Greetings,

I'm trying to implement the CRUD & Authorization from the master readme (https://github.com/Alamofire/Alamofire#crud--authorization).

Using the XCode Version 6.1 (6A1042b) I'm seeing the following error message:

```
Undefined symbols for architecture i386:
  "__TF9AlamoFire7requestFPS_21URLRequestConvertible_CS_7Request", referenced from:
      __TFC16AlamoFireExample14ViewController11viewDidLoadfS0_FT_T_ in ViewController.o
ld: symbol(s) not found for architecture i386
clang: error: linker command failed with exit code 1 (use -v to see invocation)

```

Example implementation exposing the compile-time error can be viewed here:
https://gist.github.com/iamjason/13b21e25e0b4e2901544

Thanks for any help!
 @mattt Thanks!
    Since the dynamic embedded frameworks feature doesn't work with the deployment target set to iOS 7.x and Swift can't be compiled to a static library, the minimum iOS version to use should be changed to 8.0 with the current installation instructions.
  Although Alamofire provides a download api with a resume data block for resuming a previous canceled download, it seems that an API for obtaining the data block is missing. The resume data block provided by cancelByProducingResumeData is currently stored in TaskDelegate which is considering private to Request. 

A possible solution could be to extend the cancel API with a completion handler providing the caller with the generated resume data block:

```
public func cancel(completionHandler: (NSData!) -> Void) {
    if let downloadDelegate = self.delegate as? DownloadTaskDelegate {
        downloadDelegate.downloadTask.cancelByProducingResumeData { (data) in
            downloadDelegate.resumeData = data
            completionHandler(data)
        }
    } else {
        self.task.cancel()         
    }
}
```
 I have implemented it the way @zuschlag  had proposed (see related commit). 

Functionality is pretty straightforward, but certain implications arise. As the very same `Request` class is used for all types of tasks, adding resume data handler to `cancel()` leads to it being exposed in non-download cases, which is confusing. 

Yet, resuming downloads is a crucial use case. 

I personally think that it may be possible to encapsulate all this resume data logic entirely in `Manager`. I doubt that users would need any fine-grain control of where and how exactly this data is stored. 

@mattt ?
 Hi @ivanmoskalev your solution seems to fit our purpose. Have you had any response from @mattt?

In regard to encapsulating the resume logic in the Manager, then we have a case where we want to be able to "pause" and "restart" download between two different executions of the app, which means that we need to be able to obtain the resume block in order to persist it for future use. So unless this specific use case would be supported by the Manager, we require access to the resume block.
 Hi @zuschlag!

No, have not got any replies from Matt yet :(

As for the encapsulation, my original idea was something along the lines of implementing a following usecase:
1. Library user creates a download request with a flag `resumeIfPossible`:
   `Alamofire.download(.GET, URL, destination, resumeIfPossible: true)`
2. If the flag is set to `true`, `Manager` tries to find previously saved resume data for a given entity, and if it exists, automatically resumes the request
3. Resume data is automatically stored if `Manager` receives it from `NSURLSession` (either on cancel or on failure)
4. Resume data is persisted across launches and is managed by Alamofire entirely

I think that resume data is an implementation detail of a persistent download concept that can be very elegantly hidden by Alamofire.
 Hi @ivanmoskalev 

Do you plan to make a pull request out of your implementation? 
 Hey guys,

You can actually do this quite easily without modifying Alamofire at all. Your response serializer will receive the resume data that you need to resume the download. Here's a quick little example that I put together.

``` swift
import Alamofire

class Downloader {
    var cancelledData: NSData?
    var downloadRequest: Request?

    func startDownload() {
        let request = Alamofire.download(URLRequest(.GET, "http://some_big_file"), Request.suggestedDownloadDestination())
        request.response { request, response, data, error in
            if let error = error {
                if error.code == NSURLErrorCancelled {
                    self.cancelledData = data as? NSData
                } else {
                    println("Failed to download file: \(response) \(error)")
                }
            } else {
                println("Successfully downloaded file: \(response)")
            }
        }

        self.downloadRequest = request
    }

    func cancelDownload() {
        self.downloadRequest?.cancel()
    }

    func resumeDownload() {
        if let cancelledData = self.cancelledData {
            let request = Alamofire.download(resumeData: cancelledData, Request.suggestedDownloadDestination())

            request.response { request, response, data, error in
                if let error = error {
                    println("Failed to resume file download: \(response) \(error)")
                } else {
                    println("Successfully downloaded file: \(response)")
                }
            }
        }
    }
}
```

I hope that helps!
 Isn't there a way to get the path to the temporary file so that on the next run we can read the <code>NSData</code> from there and easily resume the download? As far as I can see, the path is only provided after the download is done, to move it to a permanent folder. 
 Sorry if I keep commenting this thread, but I also found out that when losing network connection (so not a simple <code>cancel()</code> request), the data returned to the <code>response</code> block is nil. No way to get the temporary data at least?
 Is it possible to obtain the resume data when calling `suspend()` to a request?

I just want to save the data in the case of app termination, but not want to `cancel()` the request. 
  As title suggests.
  Looks like some more things were made optional in beta3.
   No worries! I don't care who get credit as long as it works.
  I was a bit confused when reading the installation instructions as to which project I should update (my own or Alamofire). I've added a few clarifying words to the README.
  Using this example code I derived from the Readme documentation with the 1.0.0 release:

```
            Alamofire.upload(myMethod, myUrlString, myImageData).progress { (_, bytesWritten, totalBytes) -> Void in
                    myProgressView?.progress = Float(bytesWritten) / Float(totalBytes)
            }.responseJSON { (request, response, JSON, error) in
                println(JSON)
            }
```

Gives me the following error in XCode 6.0:
_Swift Compiler Error:_ **Could not find member 'responseJSON'**

`response` and `responseJSON` work well using the `request` method instead the `upload`+`progress` methods.

Am I doing something wrong or is this a bug?
 I just removed `responseJSON` and now **even the `progress` method is not working**. So this seems to be the underlying problem, I'm going to update the issue title accordingly.
 I just happened to solve this, it seems to be an issue with XCode (6.0.1) rather than with Alamofire. The error message is misleading. Here's to what I changed the code to to make it work:

```
Alamofire.upload(myMethod, myUrlString, myImageData).progress { (_, bytesWritten, totalBytes) -> Void in
        if let progressView = progressView {
            myProgressView.progress = Float(bytesWritten) / Float(totalBytes)
        }
    }
    .responseJSON { (request, response, JSON, error) in
        println(JSON)
    }
```

Note that I'm not using Optional chaining any more (`myProgressView?.progress = ...`), so that was the issue in case that someone else taps into the same problem.

EDIT: I have just filed a bug report to Apple about this behavior (#18500743).
 Is your Alamofire call the only expression in a trailing closure? If so, add a `return` line after your Alamofire call or do something like `let dummy = Alamofire.upload(myMethod...`

From the Swift documentation: 
‚ÄúSingle-expression closures can implicitly return the result of their single expression by omitting the `return` keyword from their declaration‚Äù

Most Alamofire methods return `Request`  for chain-ability and then Swift tries to return that from your single-expression closure (that probably is `-> Void`) and this causes a problem. That's why adding a `return` can resolve this problem. (I haven't found a more elegant work-around for this yet.)

This example shows the `Could not find member 'responseJSON'` error:

```
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) {
  Alamofire.request(Alamofire.Method.GET, HTTPBinRoute.Method(Alamofire.Method.GET)).responseJSON() {
    (request, response, JSON, error) in
    println(JSON)
  }
}
```
  Hi @mattt ,

I have some trouble with the features "manual validation"
Normally " Calling validate before a response handler causes an error to be generated if the response had an unacceptable status code or MIME type."

However,  when im doing  a request with a manual validation ,

```
Alamofire.request(.DELETE, phone.phoneUrl, encoding: .JSON)
                .validate(statusCode: 200..<300)
                .responseJSON {(request, response, JSON, error) in
                    if (error == nil){
                        // succeed
                        response?.statusCode
                        self._deletedPhones.removeLastObject()
                        }
                    }else{
                        // failed
                        if let dictionary = JSON as? NSDictionary {
                            println("JSON ERROR\(dictionary)")
                        println(error)
                        }
                    }
                }
```

I am suppose to get an error only if the statusCode is not  200..<300 right ?

But this is what i get  : 

```
Error Domain=NSCocoaErrorDomain Code=3840 "The operation couldn‚Äôt be completed. (Cocoa error 3840.)" (No value.) UserInfo=0x7f8fdd424760 {NSDebugDescription=No value.}

<NSHTTPURLResponse: 0x7f8fdd53d400> { URL: https://app.ubinect.fr/mobile/v2/environnement/404/personnes/patient/62766/telephone/15342 } { status code: 204, headers {
    Allow = "GET, PUT, DELETE, HEAD, OPTIONS, PATCH";
    Connection = "keep-alive";
    "Content-Length" = 0;
    Date = "Tue, 30 Sep 2014 11:50:51 GMT";
    Server = "nginx/1.4.5";
    Vary = "Accept, Cookie";
    "x-frame-options" = DENY;
    "x-xss-protection" = "1; mode=block";
} }
```

error is not empty so i can't make a difference between validate and failed request.

Maybe i do something wrong, but i still don't understand how i can easily implement, a validateResponse, and an ErrorResponse handler. 
 Understood.

Thank you.
 I am having the exact same issue. My server (in case of DELETE request) is not returning anything. Even though delete request is succesful and data in gone from server but on client I get an error. How to nicely handle it on the client side ?
 Oh my godness... Can somebody please fix this or write an easy explanation how to get rid of this error? I develop an app for a year and this is the only error I have not figured out and it is still showing over and over again.
 Did anybody fix this or found a workaround?
  There are plans for UIKit Extensions or they were really dropped on commit c2cfaeadb5c1ca?
  Since `Method.fromRaw()` returns an optional, it's safer, simpler & more future proof not to switch on string values in `prepareForSegue(_:_:)`
 Cool, no problem.
  Hello.

What do you think about replacing current JSON serializator by https://github.com/SwiftyJSON/SwiftyJSON ? It's pretty easy to use and works good. I had a lots of problems with current implementation in my project.
 @kirillplatonov  [Alamofire-SwiftyJSON](https://github.com/SwiftyJSON/Alamofire-SwiftyJSON) could be a simple solution.
  When you open my application, 5 decently large network requests fire off at the same time. If you scroll, more requests are fired. This results in application freezing mid-scroll and causes a choppy UX.

I have run tests where I wait 5 seconds after a request has fired before firing the next one and this seems to have gotten rid of the lag. This is not an ideal situation so I was wondering if there was a configuration of Alamofire that could help prevent this by placing the requests in a queue that is popped whenever there is an open slot.

I have tried setting HTTPMaximumConnectionsPerHost to 1 but it has no effect. Am I missing something?
 Thanks for the input! I was able to profile my application and it seems that because responseJSON was in the main thread I had accidentally stacked a lot of Core Data operations on the main thread and that caused the lag. By pushing this to the background thread my lag has disappeared.
  Related to #53.
 Also, with step 2 are you meant to drag the file above your project (creating a workspace) or below/on top of it.

> ‚Ä¶ drag `Alamofire.xcodeproj` into the file navigator of your Xcode project.
  When you need to customize a header or timeout, this makes the delta
between your existing code and code using the manager smaller.
 I would also like this change as it removes the Encoding magic that was present in the static convience method but missing from the `Manager`. This will allow us to inject a `Manager` into dependent classes. 

Why inject? Better de-coupling and easier to unit test as mentioned in #180.  
 Cool, thanks. I failed to update the README, which might make more sense using the new helper method for added symmetry
  I followed the installation steps, but I keep getting the following error:

```
dyld: Symbol not found: _NSURLAuthenticationMethodHTTPBasic
  Referenced from: /Library/Developer/Xcode/DerivedData/Sync-dqwtdopmwaheyjheaabinsggoynp/Build/Products/Debug/Alamofire.framework/Versions/A/Alamofire
  Expected in: /System/Library/Frameworks/CFNetwork.framework/Versions/A/CFNetwork
 in/Library/Developer/Xcode/DerivedData/Sync-dqwtdopmwaheyjheaabinsggoynp/Build/Products/Debug/Alamofire.framework/Versions/A/Alamofire
(lldb) 
```

The solutions listed in previous issues don't seem to work.

Steps
- Create blank project
- Add & checkout submodule at 6.1 branch
- Drag and drop Alamofire.xcodeproj in Project navigator
- Link Binary With Libraries -> Alamofire.framework
- Copy Frameworks -> Destination -> Frameworks -> Alamofire.framework

Changing the deployment target of the Alamofire project has no effect.

Any idea what else this could be?

Thanks in advanced! :+1: 
 I made a screencast doing everything step by step:
http://cl.ly/1o0c0p3l2Y34

Am I missing anything?
Thanks!
 The issue seems to be related to the OSX SDK. If I create a new iOS project and follow the steps above it works perfectly.

Also did a fresh Xcode Beta install on different machine, and got the same results.
 Getting the same error here. Here's my console output (a bit different then yours, @PhiloNL):

```
dyld: Symbol not found: _NSURLAuthenticationMethodHTTPBasic
  Referenced from: /Users/Dschee/Library/Developer/Xcode/DerivedData/Build/Products/Debug/Alamofire.framework/Versions/A/Alamofire
  Expected in: /System/Library/Frameworks/CFNetwork.framework/Versions/A/CFNetwork
 in /Users/Dschee/Library/Developer/Xcode/DerivedData/Build/Products/Debug/Alamofire.framework/Versions/A/Alamofire
(lldb) 
```

I just added Alamofire to my OS X project with XCode 6.1 beta 2 via `xcode-6.1` branch following the instructions (submodule etc.).

EDIT: I'm using XCode 6.1 beta 2 in OS X 10.9 Mavericks, not in Yosemite if this is necessary.
 Okay, I just **found a workaround** for this. The problem ist that Alamofire is set up for iOS projects and tries to compile against the wrong SDK. What you need to do is **change the Base SDK and Deployment target** of the Alamofire project/target. See the following screenshots:

![bildschirmfoto 2014-09-28 um 13 43 37](https://cloud.githubusercontent.com/assets/6942160/4434132/238f8cf2-4705-11e4-951f-138c389433b7.png)
![bildschirmfoto 2014-09-28 um 13 44 26](https://cloud.githubusercontent.com/assets/6942160/4434131/2388b74c-4705-11e4-86ff-79f002730bad.png)
 Thanks, that works!! :+1: 
 @Dschee thanks for your solution. 
 @Dschee Thanks a ton for this; just getting started on swift and am thrilled to have a nice http abstraction now working.
    I'm not getting it.  I create a manager, with `startRequestsImmediately = false`.  (Would be nice to set that at init time, btw.)  I call `manager.request(...).responseString(...).resume()`.  My block in `responseString` is not invoked.  (In fact, `responseString` never terminates.)

How is this intended to work?
 My pull (of a couple days ago) does not have said test or test file :) This is perfect; I will pull and try to figure out why my observed behaviour is different.  Thanks for the quick response!
  Found a minor error in the docs.
  I need to cancel some requests by tag or url, e.g. I send a search request "apple" and seconds later another "banana", but before that I have to cancel the request "apple".
In earlier versions I had solved this as follows:

``` swift
extension Alamofire.Manager
{
    private func cancelTasksByUrl(tasks: [NSURLSessionTask], url: String)
    {
        for task in tasks
        {
            if task.currentRequest.URL.description.beginsWith(url)
            {
                task.cancel()
            }
        }
    }

    func cancelRequests(url: String)
    {
        self.session.getTasksWithCompletionHandler
        {
            (dataTasks, uploadTasks, downloadTasks) -> Void in

            self.cancelTasksByUrl(dataTasks     as [NSURLSessionTask], url: url)
            self.cancelTasksByUrl(uploadTasks   as [NSURLSessionTask], url: url)
            self.cancelTasksByUrl(downloadTasks as [NSURLSessionTask], url: url)
        }
    }
}
```

Now the "getTasksWithCompletionHandler" method returns just empty arrays and I have no idea why.
 Hi @mattt , i tried to get a reference to my Alamofire.Request as you said but it didn't work.

This is why i get 

 NSForwarding: warning: object 0x7b958910 of class 'Alamofire.Request' does not implement methodSignatureForSelector: -- trouble ahead
Unrecognized selector -[Alamofire.Request cancel]

Could you please , give us  an example of how can we cancel a request ?

Thanks !
 Yes i am.

Here is an example of my code 

var _getMostRecentsPatientRequest : AnyObject?
    var _updatePatient : AnyObject?
    var _getLatestPatient : AnyObject?
    var _getPatients : AnyObject?

func startGetLatestPatient(){
        var user : User = _ubinect._user!

```
    var xHTTPAdditionalHeaders: [NSObject : AnyObject] = ["Authorization":  user.header]
    Alamofire.Manager.sharedInstance.session.configuration.HTTPAdditionalHeaders = xHTTPAdditionalHeaders
    _getLatestPatient =  Alamofire.request(.GET,_ubinect._selectedCabinet!.latestPatient, encoding: .JSON)
        .responseJSON {(request, response, JSON, error) in

            if (self._ubinect.isRequestValid(code: response?.statusCode as NSInteger!))
            {
                // r√©cuperation des patients

                if let lastUpdate :String = (((JSON as NSDictionary)["results"] as NSArray)[0] as NSDictionary)["date_updated"] as? String {
                    //self._ubinect._user?.lastUpdate = lastUpdate.dateValue()

                    self._ubinect.setLastUpdate(LastUpdate: lastUpdate.dateValue())
                   // println("LastUpdate \(self._ubinect._user?.lastUpdate)")

                }
                else{
                    println("Erreur startGetLatestPatient")
                }
            }
            else{
                println("Mode Hors ligne")
            }
    }
}
```

func stopRequest(){
        if(_getMostRecentsPatientRequest != nil){
            (_getMostRecentsPatientRequest as Alamofire.Request).cancel()
        }
        if (_updatePatient != nil){
             (_updatePatient as Alamofire.Request).cancel()
        }
        if (_getLatestPatient != nil){
            _getLatestPatient!.cancel()
        }
        if (_getPatients != nil){
            _getPatients!.cancel()
        }  
    }

I have a viewController in witch i do some request.
And I would like to stop all requests when the user leave this page.
 @mattt  problem solved.

I've noticed that the method called wasn't called from Alamofire.request but from my Anyobject.
 "Unrecognized selector" confused me.

I've just replace :

_updatePatient!.cancel()
by
(_updatePatient as Alamofire.Request).cancel()

Thank you for your fast answer ;)
 Master Roger! @ingouackaz 

Happy to see you here! (camill_a from Lille)
Please replace your dirty optional unwrapping :p

```
if (_getPatients != nil){
_getPatients!.cancel()
} 
```

By

```
if let pendingRequest = _getPatients {
    pendingRequest.cancel()
}
```
  Added extra documentation on how to checkout a specific branch
 Good point! :+1:  
  I have a project which uses Alamofire. What I usually do it, I checkout a copy of my source, drag and drop Alamofire project from wherever I have downloaded it. Add it to Target Dependencies and work with it.

This is an unnecessary task which I'm trying to stop. So what I need is to add Alamofire to my project for good so that I can check in my source along with it.

If I copy the entire Alamofire folder, I get all the iOS example projects and workspaces and everything. Besides if I add the entire directory, I get this build error **/Cannot load underlying module for 'XCTest'**.

Can someone please tell me what are the necessary files of Alamofire I need to copy over to my project and check in to git source control in order to not having to drag and drop every time?

Thank you.
 I've `CocoaPods 0.36.4` currently installed on my Mac. When I try importing it, I get `Cannot load underlying module for 'Alamofire'.`
 It seems like its an Xcode bug. One should run the project first before start using the dependencies..
 @mohdabdurraafay Thanks for the tip! it works!
 @mohdabdurraafay Thanks for the tip! it works!
 just Build the project once. Then try it. Works fine for me 
 Build the project once also works for me. Xcode 7.01.
 It works for me Xcode 7.0.1
 Worked for me to.
 It works. Thanks! (Xcode 7.2.1)
 `import Alamofire` after importing `UIKit`
Then comment it out, build the project.
Uncomment it. 

As Apple says, 'it just works'.. lol :D
 I'm not sure of your setup, however that `underlying module error` is usually because you have swift and objc code in the project and in this case, `Alamofire` should be added to the `embedded binaries` section when linking libs.
 Instead of adding all xcode project for my iOS application project, I am trying to add the attached file thru Link Binary with Libraries to my project, started getting *\* No such module 'Alamofire'**
![alamofire_framework](https://cloud.githubusercontent.com/assets/16364754/15032528/bd199254-1216-11e6-8dc3-752632fb9c77.png)
  "+" gets un-escaped as " " and treated as such by servers. It should be encoded to `%2B`
 Wow, that was fast. Thanks for the fix :+1: 
  `suggestedFilename` is `String?`
  This can be useful outside of Alamofire when creating custom
URLRequestConvertible objects
  Hi Mattt,

I have been using AlamoFire in a swift project to interface with an existing service I maintain.
The simple GET method work, but I have a couple of Password protected calls.
In AF networking this works perfect: 
[manager.requestSerializer
     setAuthorizationHeaderFieldWithUsername:userName
     password:password];
but when I try:
let credential = NSURLCredential(user: userName, password: password, persistence: .ForSession)
        var myRequest = request(.GET, "http://{host}/{application}/api/IDNumber/" + aIDNumber)
            .authenticate(usingCredential: credential)
            .responseJSON{ (request, response, JSON, error) in
                if (error == nil){
                    self.delegate?.parseJson(JSON!)
                }
        }
It keeps telling me It needs authentication.
I dug a bit more and I see the calls are not challenging the caller for credentials but expects the BasicAuthentication header to be there.
I use Firefox RESTClient successfully to test the services by adding Basic Authentication header

Please help?

Regards,

Brian Minnaar
  Is it available now?
 is it available now mby ?
 Hello guys. It is 3.0.0 and I'm still not sure if it is available? How can I add exception for self signed certificate? Right now it failing on SecCertificateCreateWithData inside ServerTrustPolicy object.
  ![bwttnoox 5 qggb7 e8q4](https://cloud.githubusercontent.com/assets/5953992/4344760/c78a71f4-40a3-11e4-89dd-89a50485db3e.jpg)
need your help,please~
 For Mac support you should use Xcode 6.1 Beta. OS X 10.10 SDK is not in Xcode 6.0.1.
 thank you 
    ld: embedded dylibs/frameworks are only supported on iOS 8.0 and later (@rpath/Alamofire.framework/Alamofire) for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
 Same issue here, do you have any fix?
 I believe this same problems in other projects : 

[Problem in Reactive Cocoa](https://github.com/ReactiveCocoa/ReactiveCocoa/issues/1480)

[Comments in similar problem in StackOverflow](http://stackoverflow.com/questions/25909870/xcode-6-and-embedded-frameworks-only-supported-in-ios8/25910262#25910262)

Thats problem is a limitation of Xcode 6 and Embedded Frameworks. 

:)
 I'm encountering this issue as well, it was attempted on a fresh project. A fix would be greatly appreciated. 
 Corrections are always well appreciated! ;-) 

But I will give one more researched to see if I can find a solution for this case. 
 looks like I am guilty of pebkac (classic case of misreading the install/config instructions). My apologies :P
 In Brazil we speak, BIOS problem (Bicho [ similar a animal ] Ignorant Operating System). Me these problems occur weekly. At least you learn a little more after them. Any problem warns that trying to find a solution together. 

Good Luck! :)
 Getting the same problem when trying to run on Xcode 6.
 Actually with XCode 6 (the one downloaded from AppStore), you have to follow the instructions in the readme, then you have to go to "Alamofire" project that you dragged to your project and change it's deployment target to the same deployment target of your project, this solved the problem, and it's running perfectly.
@mattt  I think it's safe to close the issue?
 I confirm @LightD workaround is efficient. @mattt Maybe add that last step to the Readme ?
 Confirming @LightD solution. Thanks! :+1: 
 Alamofile embedded framework cause any problem in iOS7? For me my embedded frameworks work on iOS7 also but they shouldn't according to documentation.Tried with a helloWorld project and framework.Any hints?
 @iNeerajatSigneasy as soon as you try to submit your app you will run in some itunes errors
 My app works totally fine on iOS7 device.Still it will be rejected by Application uploaded and is there any other way to support iOS7 with embedded frameworks.
 @iNeerajatSigneasy no. You will have to remove alamofire from your project. Then you can just copy and paste Alamofire.swift inside your project. This is the only solution I found.
 I have removed alamofier from project.My question is I am using an embedded framework to share code.And it gives a warning - Embedded dylibs/frameworks only run on iOS 8 or later.Will it get rejected by applications uploader? if yes is there any way to support embedded frameworks if my containing app needs to support iOS7.0 as well.
Thanks for answer.
 @iNeerajatSigneasy If you want to target iOS 8+ only you can use it as embedded framework. However if you want to target iOS 7+ it will be rejected while uploading, even before it is submitted for review. You will get this errors: https://cloud.githubusercontent.com/assets/364754/4569976/6ca9f682-4f54-11e4-9b91-6e32bd75868b.png

Please read this for more information: https://github.com/Alamofire/Alamofire/issues/152
 @LightD Thanks!
 i just created a test project you can look here https://github.com/leviyehonatan/cocoapods-lib-swift and it targets 7.1 and i t works, why won't alamofire target 7.0? because even though compiler supports it, the store doesn't support it?
 @leviyehonatan It won't pass Itunes Connect Validation
 Hi guyz 
I have got an official word from Apple "There is no way to use Embedded framework code in iOS7".
Although if your embedded framework code is only used in iOS8 there seems to be a way of conditional loading of embedded framework in iOS8.

Thanks
Neeraj
 Check this: https://github.com/devxoul/CocoaSeeds
  How to add custom HTTP header since 'defaultHeaders' is removed?
 @mattt I don't think it can be derived from the default manager as the exposed API is very limited.
![screen shot 2014-09-19 at 10 43 16 am](https://cloud.githubusercontent.com/assets/3182449/4330095/c1aef050-3fa6-11e4-8e52-c832d5390c56.png)

In this case should I just subclass the Manager? Or initiate a custom manager from the init method?
 @mattt Thanks, that's much better now.
 @mattt 

``` swift
Alamofire.Manager.sharedInstance.session.configuration
```

returns a copy of the session configuration object, so by modifying the headers doesn't allow the modification of the default manager session configuration, or adding custom headers.
 Now I get it. So new Manager it is. Alright.

On Saturday, September 20, 2014, Mattt Thompson notifications@github.com
wrote:

> Yeah, that's the point. If you want custom headers, pass it into the
> configuration of a new manager.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub
> https://github.com/Alamofire/Alamofire/issues/111#issuecomment-56203835.

## 

_Regards,_

_Ryne Cheow_ / iOS Application Developer
+65-98729056 / rynecheow@gmail.com

http:/www.facebook.com/rynecheow  http://sg.linkedin.com/in/rynecheow/

This e-mail message may contain confidential or legally privileged
information and is intended only for the use of the intended recipient(s).
Any unauthorized disclosure, dissemination, distribution, copying or the
taking of any action in reliance on the information herein is prohibited.
E-mails are not secure and cannot be guaranteed to be error free as they
can be intercepted, amended, or contain viruses. Anyone who communicates
with me by e-mail is deemed to have accepted these risks. I am not
responsible for errors or omissions in this message and denies any
responsibility for any damage arising from the use of e-mail. Any opinion
and other statement contained in this message and any attachment are solely
those of the author. The recipient should check this email and any
attachments for the presence of viruses. I accept no liability for any
damage caused by any virus transmitted by this email.
 For example

```
    //var xHTTPAdditionalHeaders: [NSObject : AnyObject] = ["Authorization": _user.header!]
     Alamofire.Manager.sharedInstance.session.configuration.HTTPAdditionalHeaders = xHTTPAdditionalHeaders
```
 ```
    // Creating an Instance of the Alamofire Manager
    var manager = Manager.sharedInstance

    // Specifying the Headers we need
    manager.session.configuration.HTTPAdditionalHeaders = [
        "Content-Type": "application/x-www-form-urlencoded",
        "Accept": "application/vnd.lichess.v1+json",
        "User-Agent": "007"
    ]
```
 Thank you ! @lfaoro 
 Another thank you @lfaoro!
 FYI, for anyone who finds this after googling, if you want to set custom headers for iOS 7 and 8, you need to follow this: http://stackoverflow.com/questions/26784601/setting-custom-http-headers-in-alamofire-in-ios-7-not-working

The methods mentioned on this issue work only for iOS8 (for me at least). The headers were not sent on iOS 7.0.1
  Hello,

do you have any timeframe for Multipart POST?
I would love to use Alamofire, but it's a show stopper for me.
 I'm going to use AFNetworking for now as suggested, but I'd love to see this in Alamofire as well!
AFNetworking is a lot of overhead just because of one of its many features ... ^^
 Same here. Do you have an idea of when it will be implemented?
 same here.I implemented most of my networking with Alamofire and just integrated AFNetworking for the multipart request...I would really love to see this feature implemented and great work so far, thanks!
 +1
 Would love to have it in Alamofire too
 Here is a quick&dirty patch I use: http://pastebin.com/k9CUJjry
Using AFNetworking works fine though.
 +1 who wants multipart support
 @db0company why not make a PR for this?
 @mente Because this is a quick&dirty solution that works for me but might not work for everybody since it's not complete and has hardcoded strings.
 +1 woo and thanks to @db0company - that patch is dope. nyan.
 @mattt looking to implement this using AFNetworking, any estimate on when it will be implemented in Alamofire?
 I've created a class function to upload single file as multipart/form-data based on [this SO answers](http://stackoverflow.com/questions/26121827/uploading-file-with-parameters-using-alamofire/28467829#28467829).

# Class

```
class Photo {
    class func upload(image: UIImage, filename: String) -> Request {
        let route = Router.CreatePhoto()
        var request = route.URLRequest.mutableCopy() as NSMutableURLRequest
        let boundary = "NET-POST-boundary-\(arc4random())-\(arc4random())"
        request.setValue("multipart/form-data;boundary="+boundary,
                         forHTTPHeaderField: "Content-Type")

        let parameters = NSMutableData()
        for s in ["\r\n--\(boundary)\r\n",
                  "Content-Disposition: form-data; name=\"photos[photo]\";" +
                    " filename=\"\(filename)\"\r\n",
                  "Content-Type: image/png\r\n\r\n"] {
            parameters.appendData(s.dataUsingEncoding(NSUTF8StringEncoding)!)
        }
        parameters.appendData(UIImageJPEGRepresentation(image, 1))
        parameters.appendData("\r\n--\(boundary)--\r\n"
                               .dataUsingEncoding(NSUTF8StringEncoding)!)
        return Alamofire.upload(request, parameters)
    }
}
```

# Usage

```
let rep = (asset as ALAsset).defaultRepresentation()
let ref = rep.fullResolutionImage().takeUnretainedValue()
Photo.upload(UIImage(CGImage: ref)!, filename: rep.filename())
    .progress { (bytesWritten, totalBytesWritten, totalBytesExpectedToWrite) in
        println(totalBytesWritten)
    }
    .responseJSON { (request, response, JSON, error) in
        println(JSON)
    }
```
 @tomoyuki28jp I don't have my head around Alamofire routes yet, can you provide the rest of the code for the Photo example?
 @captainchung Take a look at those SO answers.
http://stackoverflow.com/a/26747857/3958295
http://stackoverflow.com/a/27014372/3958295
 @mattt 

> **Until this is implemented**, AFNetworking's multipart form request functionality can be used in conjunction with Alamofire itself.

Shortly after you responded (8807fb86bf2e6f8ba979c3ab23bc3903eeab3c15), you added this to the README:

> Use AFNetworking for any of the following:
> [...]
> Multipart HTTP request construction

Sorry to bother you, but could you possibly clarify as to whether you still intend to implement this?
 +1
 @tomoyuki28jp 

how can i set the params with this input.

PATCH 
  "/api/accounts/1"
  Parameters: {"user"=>
                                   {"first_name"=>"Gretchen", 
                                    "last_name"=>"Gapol", 
                                    "profile_photo"=>#<ActionDispatch::Http::UploadedFile:0x007fab541ee658 @tempfile=#<Tempfile:/var/folders/qn/xhlfpmvd4gq15ycgj2gxqwxh0000gn/T/RackMultipart20150406-372-o4wrif>, @original_filename="mocking_jay.jpg", @content_type="image/jpeg", @headers="Content-Disposition: form-data; name=\"user[profile_photo]\"; filename=\"mocking_jay.jpg\"\r\nContent-Type: image/jpeg\r\n">}
              }

i want to put the image param in "profile_photo" 
 @cnoon Glad to hear this! Thanks for the update :+1:
 Any update ?
 In the meanwhile I have created a very general solution, based on previous comments and stackoverflow questions.
It does not require Routes just a NSURLRequest.
It allows to add multiple files to the multipart request, as well as other parameters or HTTP headers.
No hardcoded options, no assumptions: you can upload any kind of file, not just photos.

https://gist.github.com/ncerezo/b1991f8dfac01cb162c0
 http://stackoverflow.com/a/26747857/3958295
It's useful!!!

Thk God. I fixed problem.
 You can try this, it is working

``` swift
Alamofire.upload(
.POST,
        URLString: "http://blankapp.io/api/v1/update",
        multipartFormData: {
            multipartFormData in
            multipartFormData.appendBodyPart(fileURL: NSURL(fileURLWithPath: imagePath)!, name: "cover")
            multipartFormData.appendBodyPart(data: "Alamofire test title".dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!, name: "title")
            multipartFormData.appendBodyPart(data: "test content".dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!, name: "content")
            multipartFormData.appendBodyPart(data: "1".dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!, name: "type")
        },
        encodingCompletion: {
            encodingResult in
            switch encodingResult {
            case .Success(let upload, _, _ ):
                upload.responseJSON {
                    request, response, JSON, error in
                    println(JSON)
                }
            case .Failure(let encodingError):
                println("Failure")
                println(encodingError)
            }
        }
)
```
 Can you tell how much time (roughly) takes to implement it?
 @cnoon:  Do you have any tricks up your sleeve for diagnosing stalled uploads?  I am logging in `progress`, the backend in this case is Django Rest Framework on Heroku.  What I am seeing is that the upload pauses - my logs stop, and network activity goes to zero.  I am running on Wifi and otherwise have good bandwidth.  

(Thanks)
 @cnoon :
How can I use `public fund upload(
    URLRequest: URLRequestConvertible,
    multipartFormData: MultipartFormData -> Void,
    encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
    encodingCompletion: (Manager.MultipartFormDataEncodingResult -> Void)?)` method to upload a file with some parameters?

I tried by setting parameters as data for the `URLRequest` and adding file to `multipartFormData`, but the server is not getting the parameters and throwing some error.

Is this correct or should I add parameters as data to  `multipartFormData`?

I am using `Alamofire.ParameterEncoding.URL` for parameter encoding, should I change this to custom and append data with that?
  This is a quick fix for Xcode6.1-beta2.

iOS Example works well, but Xcode will crash when unit-testing for some reason...
 By the way, I use your Alamofire for my project https://github.com/inamiy/SwiftTask .
Fortunately, it works on my unit-testing.
 You can't just swap these yet because it is a breaking change for all non-beta users
 @coneybeare 
Exactly. It will be nice if @mattt can create a new unstable branch for this and future patches for unstable Swift itself :sleeping: 
  Instruction in readme are update accordingly
 You're welcome and ok :)

:+1: for CocoaPods for Swift
  The error is:
`dyld: Library not loaded: @rpath/Alamofire.framework/Alamofire
  Referenced from: /private/var/mobile/Containers/Bundle/Application/14FF0726-35EC-4B52-AC8B-58277E032310/iOS Example.app/iOS Example
  Reason: image not found`

I'm running Xcode 6.0 on Yosemite DP8. The device is an iPhone 5 running iOS 8 GM.
 Look at #101 
 Thx, #101 helped. Just added to `Alomofire.framework` to _Copy Files_ under _Build Phases_. The destination is to `Frameworks`.
 Same problem....
Iphone 5 and below have problem..
It is an issue
  When trying to use Alamofire with a target of OS X in Xcode 6.1 beta I get the following build error:

`Alamofire was rejected as an implicit dependency for 'Alamofire.framework' because it doesn't contain platform 'macosx' in its SUPPORTED_PLATFORMS 'iphonesimulator, iphoneos'`
 I wasn't even aware that a single framework could support both iOS and OS X until I saw this.

I'll check out the Xcode project, but any tips / advice would be great.
    ```
dyld: Library not loaded: @rpath/Alamofire.framework/Alamofire
  Referenced from: /private/var/mobile/Containers/Bundle/Application/XXX/Anachronos.app/Anachronos
  Reason: image not found
```

Xcode6 GM

I've read all the issues about this kind of problem, but couldn't solve the problem.

Also, there is the same issue in  iOS Example project:

```
dyld: Library not loaded: @rpath/Alamofire.framework/Alamofire
  Referenced from: /private/var/mobile/Containers/Bundle/Application/CEA6C4C1-C211-460C-8ECF-4FD9C66F1016/iOS Example.app/iOS Example
  Reason: image not found
```
 I had a similar issue
Build Phases
![zrzut ekranu 2014-09-15 o 21 08 34](https://cloud.githubusercontent.com/assets/28064/4277150/e5ff00b4-3d0b-11e4-9b81-55c439b6f2c1.png)
General
![zrzut ekranu 2014-09-15 o 21 09 23](https://cloud.githubusercontent.com/assets/28064/4277162/1e321eee-3d0c-11e4-9f5f-36691436b4a0.png)
 @Mikoj  Thank you very much!
 Also have the same issue with the example project, would be nice if the example built out of the box.
 Thanks @Mikoj 
 THANKS :-)
 I have the same question, I just do as Mikoj told, but i still crash on my iPhone, not in simulator.I really do not know how to do
 Me too as KevinIsSun said.. Is this really resolved?
 Thanks all for the insights in solving this issue.
Just one clarification. The "Embed Frameworks" option was not available on xCode 6.3 under Build Phases. It is actually a "Copy Files Phase" (clicking in the +) in the same Build Phases.
I had to do it too for other framework I use (SwiftyJSON).
 I have the same problem except that my Alamofire is embeded in a framework that is linked to my project‚Ä¶
dyld: Library not loaded: @rpath/Alamofire.framework/Alamofire
  Referenced from: /private/var/mobile/Containers/Bundle/Application/4D3EC3B3-70DF-44A1-878D-03D717C65CFD/Fabville Recette.app/Fabville Recette
  Reason: image not found
 Thank you very much!, This was very useful
 @Mikoj if this were SO, I would upvote you. thanks
 Still have the same issue, XCode 6.4, iOS 8.0+, Swift 1.2, using CocoaPods, Alamofire 1.3.

```
dyld: Library not loaded: @rpath/Alamofire.framework/Alamofire
  Referenced from: /private/var/mobile/Containers/Bundle/Application/76F222DA-1278-463E-976B-AA9C3497625E/XXX.app/XXX
  Reason: no suitable image found.  Did find:
    /private/var/mobile/Containers/Bundle/Application/76F222DA-1278-463E-976B-AA9C3497625E/RemoteMyApp.app/Frameworks/Alamofire.framework/Alamofire: mach-o, but wrong architecture
    /private/var/mobile/Containers/Bundle/Application/76F222DA-1278-463E-976B-AA9C3497625E/RemoteMyApp.app/Frameworks/Alamofire.framework/Alamofire: mach-o, but wrong architecture
    /private/var/mobile/Containers/Bundle/Application/76F222DA-1278-463E-976B-AA9C3497625E/RemoteMyApp.app/Frameworks/Alamofire.framework/Alamofire: mach-o, but wrong architecture
```
 @Mikoj It worked. Thank you!
 @Mikoj It worked. Thank you! :+1: 
 +1 @Mikoj 

Closed to prevent too many "thank you" and "you're awesome". 
 it's working, thanks
 @mushu8 Did you resolve this issue with Alamofire inside framework?
 @derpoliuk @mushu8 Came across this thread trying to solve a similar problem when adding a 3rd party framework to a framework i'm building.
I resolved it by heading to build phases and adding a 'new copy files phase'. Set destination to 'Frameworks' and then drag the framework into the list

(Example shows SDWebImage framework, but has universally solved the same problem I was having with Realm and MockingJay)
<img width="1200" alt="screen shot 2015-12-28 at 5 12 40 pm" src="https://cloud.githubusercontent.com/assets/982276/12016477/3b70728a-ad86-11e5-8b83-503889c864db.png">

Hope it helps

EDIT: Can't recommend this anymore; Although it works well in development Apple actually rejects apps that have a framework with embedded frameworks... Not sure why)
 I have the same problem ,It does not work ,how to dear the problem? for help online 
 @abury what that method produces in the client of your frameworks project is this:
<img width="305" alt="screen shot 2016-01-02 at 17 58 21" src="https://cloud.githubusercontent.com/assets/1238462/12076495/cf68c31e-b17a-11e5-930f-bef39b754b6c.png">

Unfortunately they will be able to see every framework you use in your own framework. I believe the correct way to do this (correct me if I'm wrong) is to get the client to include each framework themselves as all frameworks should be linked and copied app-level. It reduces problems with versioning of frameworks also I believe.

What I would like to do is embed frameworks inside my framework, and not have them accessible by, or even visible to, the user of my framework. Unfortunately I think that is not possible, so I am starting to think I cannot use Alamofire in my framework.
 @korovyev You're right in that it shows that the frameworks dependancies can be seen from within the framework itself (I didn't know it did that!) But I'm not sure that they can then be used in the host application.
I just tried to import one of those frameworks into the host application and it didn't recognise it. Only when I imported that framework into the host app itself did it work ok, so you shouldn't run into any issues with versioning.
Whether or not the client app should include dependancies themselves I think depends on how your designing the framework itself to be built. I want something that's simple for people to start using straight away without worrying about managing dependancies. While there may be a small duplication of code if the host app also chooses to use the same framework, it's a matter of < 500 kb (as well as being hypothetical)
Alternatively you can just include the raw source files and see if that works :smile: 
 ![monosnap 2016-01-05 15-47-14](https://cloud.githubusercontent.com/assets/5027726/12130968/a182affa-b3c3-11e5-8358-3b61dda55448.jpg)

Great.  WHICH ONE?
 @iparq Lol, not sure why you have so many there. I actually can't recommend that approach anymore. I've discovered that Apple actually rejects apps the include frameworks with embedded frameworks. Not idea why and it seems a bit counter intuitive, but thats the current way of it.
I ended up just including the source files of the frameworks I wanted into the framework. Not the cleanest (and gets even worse if they are Obj-C files as you have no bridging header file and have to use .h umbrella file which exposes them classes to the parent app) but that's literally the only solution for now.
 Still getting the same issue on iOS 9.1, with Alamofire 3.0.1. Tried some solutions found both on this page and on SO, but nothing seems to solve it
 Run into the same issue. It works on my device but then throw the error when i run it in the Simulator.
![screen shot 2016-05-19 at 8 25 22 pm](https://cloud.githubusercontent.com/assets/1859661/15416408/fb953fac-1dff-11e6-9002-702c786944b9.png)
 @troydo42 Same here...
 Had the same issue and finally solved it.
The app would run on the simulator but not my iPhone. It drove me crazy. After a few hours I went to the Keychain Access and realized that my certificate says (this certificate was signed by an unknown authority).

![cert](https://cloud.githubusercontent.com/assets/7313080/15700505/0b452aec-2789-11e6-8334-0b2ca5435c9e.png)

Solved this by following the steps [here](http://stackoverflow.com/questions/13820680/this-certificate-was-signed-by-an-unknown-authority).

I ran the app on my iPhone after that and it worked!
 Me I am getting this 

```
dyld: Library not loaded: @rpath/Alamofire.framework/Alamofire
  Referenced from: /private/var/containers/Bundle/Application/46774FDD-2C90-41A8-8BBA-EF0F34F37DD1/AppTest.app/Frameworks/SDKTest.framework/SDKTest
  Reason: no suitable image found.  Did find:
    /private/var/containers/Bundle/Application/46774FDD-2C90-41A8-8BBA-EF0F34F37DD1/AppTest.app/Frameworks/SDKTest.framework/Frameworks/Alamofire.framework/Alamofire: mmap() error 1 at address=0x00783000, size=0x00064000 segment=__TEXT in Segment::map() mapping /private/var/containers/Bundle/Application/46774FDD-2C90-41A8-8BBA-EF0F34F37DD1/AppTest.app/Frameworks/SDKTest.framework/Frameworks/Alamofire.framework/Alamofire
```
 @i3omar  After a full day of trying different things this was the missing thing that got me going. THANKS!
 What worked for me was this comment:
"Is there the Embed Frameworks build phase? If there isn't, you should add a new "Copy Files Phase", then select "Frameworks" for Destination, add frameworks to the list, and check "Code Sign On Copy" checkboxes."
 you are good!
 thanks very mach!
 @wilferrel Glad it helped!
 I also have the same issue.I tried every solutions above.But not working.Please help me to solve this.After adding framework in 'Copy Files Phase' and 'Linked libraries',in my project it shows the framework as in red color.So its telling like 'framework not found alamofire'
 I have tried.  And it could build..   u are very helpful.   thanks!  @Mikoj
 This issue also showed up for me ,please help meÔºÅ
 Hi,

Embed Pods framework is the reason for this.UITest -> Buildphases -> Embed
Pods framework is missing.Copy from target and paste it in UITest target.It
worked for me.

On Mon, Jul 25, 2016 at 12:18 PM, binjCN notifications@github.com wrote:

> This issue also showed up for me ,please help meÔºÅ
> 
> ‚Äî
> You are receiving this because you commented.
> Reply to this email directly, view it on GitHub
> https://github.com/Alamofire/Alamofire/issues/101#issuecomment-234853559,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/ATle3TB_PvvILNSqbfgPXJIBqo26B3eGks5qZFwsgaJpZM4CiG0e
> .
 I fixed, solution is
Project -> General Tab -> Linked Framworks and Libraries -> Choose AlamorefireImage.framework
 When you have this:
Project -> General Tab -> Linked Framworks and Libraries -> Choose AlamorefireImage.framework
Should the Status be "Required" or "Optional"?
 Besides Linked Framework and Embed, I also had to add a Copy Phase
 I resolve this issue as like followings.
In General->Embedded Binaries, I added necessary framework.
So app is working as well.
Thanks.
 Even after doing what was suggested by Mikoj I was still getting this error.  It wasn't until I set 'enable bitcode' to No in build settings that it started to work.  :/ Hi guys- I noticed that loads of people are still getting this error. 
I have found a fix that has worked for me and is pretty easy. 
I think its down to permissions.  I have logged the issue with Apple as they really need to fix this bug. 

When I changed the permission of the world Wide Developer cert to `Use System defaults` then it worked. I have included the steps and screenshots in the link below 

I would encourage you to log the ticket in apple bug report as mentioned here as Apple really should solve this massive error: 
[link to SO fix steps ](http://stackoverflow.com/a/41401354/559760)

 dyld: Library not loaded: @rpath/Alamofire.framework/Alamofire
  Referenced from: /var/containers/Bundle/Application/CC9B5DD0-5243-4044-8798-304DE53EE417/aswaq.app/aswaq
  Reason: no suitable image found.  Hi guys,I also get this error,and I still did not resolve after all of the methods usedÔºÅThen I did not fix the problem after changed the Xcode version, **but** I did not have a problem on another Mac.So what can I do? it got me crazy!!! Hi @peixuan197  it still happens periodically with me. I find that when I run my tests a second time - then it works ok.  
I suggest raising the issue as but with Xcode - its something that has clearly been introduced in the last two versions of xcode ( 8.21 for me) I never had this before. Compile times also seem to have gone up drastically.  

 - Log your bug here: https://bugreport.apple.com
üî• If you reference Apple bug: 29915305 - you can help them see how big the issue is. 


 Thank you very much!, This was very useful @Mikoj @OmarAlEisa , Special thanks to you, I did experienced this because I removed all certificates from my keychain!!! Thanks to you.  Tests in a loop calling GET to 10 URLs and for each iteration increases the memory usage
 I have pulled the latest version and I also experience that when I have periodically GET requests, the memory consumption will rise over time. I have read somewhere that you need to invalidate the session, but I am not quite sure how to do that while still being able create new requests. 

Can someone elaborate on how to use Alamofire correctly?
  I can't find easy way to setup HTTP Content-Type header for request.
Request.request is type of NSURLRequest so no-go with this one.
 Manager.sharedInstance.defaultHeaders["Content-Type"] = "application/json"
 like... per request is more desirable way to do it ;)
 You can use ParameterEncoding .Custom(let closure) and call encode func . Right now, it looks like using .URL with POST sets content-type to application/x-www-form-urlencoded when its not setup and .JSON sets it to application/json; charset=(charset)"
 I need to send a list of headers, how could I do it with Alamofire?
header.setValue("application/x-www-form-urlencoded", forHTTPHeaderField: "Content-Type")
header.setValue("application/vnd.lichess.v1+json", forHTTPHeaderField: "Accept")

Manager.sharedInstance.defaultHeaders - doesn't seem to even exist anymore.

Passing this closure doesn't seem to work:
let encodingClosure: (URLRequestConvertible, [String: AnyObject]?) -> (NSURLRequest, NSError?) = { (URLRequest, parameters) in
    let mutableURLRequest = URLRequest.URLRequest.mutableCopy() as NSMutableURLRequest
    mutableURLRequest.setValue("application/x-www-form-urlencoded", forHTTPHeaderField: "Content-Type")
mutableURLRequest.setValue("application/vnd.lichess.v1+json", forHTTPHeaderField: "Accept")
    return (mutableURLRequest, nil)
}
encoding: .Custom(encodingClosure)

Is there a solution?
 Finally found a solution! Been on it 4 hours! I'm such a noob :)

var manager = Manager.sharedInstance
//Passing all the headers you want!
manager.session.configuration.HTTPAdditionalHeaders = [
    "Content-Type": "application/x-www-form-urlencoded",
    "Accept": "application/vnd.lichess.v1+json",
    ]
var URL = "http://lichess.org/login"
var rq = request(.POST, URL, parameters: param
 The `Alamofire.request` method that accepts `.JSON` parameter encoding only accepts `[String : AnyObject]` and not an array. If you wish to post a JSON array, as @mattt said, you can add custom headers on a per-request basis like this (example of uploading JSON array):

``` Swift
let jsonArray: [AnyObject] = buildExampleData()
if NSJSONSerialization.isValidJSONObject(jsonArray) {
    let jsonData = NSJSONSerialization.dataWithJSONObject(jsonArray, options: nil, error: nil)!
    let url = NSURL(string: "http://example.com")!
    let request = NSMutableURLRequest(URL: url)
    request.setValue("application/json", forHTTPHeaderField: "Content-Type")
    request.HTTPMethod = "POST"
    Alamofire.upload(request, jsonData)
}
```

You can also do basic pre-authentication this way.

``` Swift
let plainString = "\(username):\(password)" as NSString
let plainData = plainString.dataUsingEncoding(NSUTF8StringEncoding)!
let base64Options = NSDataBase64EncodingOptions.allZeros
let base64String = plainData.base64EncodedStringWithOptions(base64Options)
request.setValue("Basic \(base64String)", forHTTPHeaderField: "Authorization")
```
  .gitignore for OSX, Xcode, Swift language
  Added an extension to Manager class that allows convenience calls to be called using instances other than Manager.sharedInstance.
  Whenever I try to run the tests, Xcode crashes.

Tried with Xcode6 GM and 6.1-Beta. Both on OS X 10.9.4

Here is the crashlog:
https://gist.github.com/tkrajacic/3630fde4fa136a2131ff#file-crashlog
 It should be a bug of Xcode.

Xcode should not crash with any code.
  Otherwise you see Optional(POST) instead of POST
  For now, ParameterEncoding.JSON doesn't have options anymore... this
updates the documentation to reflect that.

Fixes #86
  Since null is a perfectly valid JSON value, we should be able to do this:

```
let params:[String:AnyObject?] = ["a": nil, "b": 1]

Alamofire.request(.POST, "http://example.com", parameters:params)
```

However, since params is defined as `[String:AnyObject]`, this yields the following compiler error:

```
'AnyObject?' is not identical to 'AnyObject'
```
 No, I think you should use `NSNull` instead of `nil`, like

``` swift
let params:[String:AnyObject?] = ["a": NSNull(), "b": 1]

Alamofire.request(.POST, "http://example.com", parameters:params)
```

Underlaying `NSDictionary` not support `nil` as the value of a entry.
 Why do you prefer that? That seems objective-c-ish, not swiftish.

On Friday, September 12, 2014, YANKE Guo notifications@github.com wrote:

> No, I think you should use NSNull instead of nil, like
> 
> let params:[String:AnyObject?] = ["a": NSNull(), "b": 1]
> Alamofire.request(.POST, "http://example.com", parameters:params)
> 
> Underlaying NSDictionary not support nil as the value of a entry.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub
> https://github.com/Alamofire/Alamofire/issues/92#issuecomment-55435041.
 I think the reason is line 86 of `Alamofire.swift`

OC version of `NSJSONSerialization` has limits

```
The top level object is an NSArray or NSDictionary.
All objects are instances of NSString, NSNumber, NSArray, NSDictionary, or NSNull.
All dictionary keys are instances of NSString.
Numbers are not NaN or infinity.
```

Swift is based on Foundation.framework, things won't change much.

Swift version of `NSJSONSerialization` has the function signature
`class func dataWithJSONObject(obj: AnyObject, options opt: NSJSONWritingOptions, error: NSErrorPointer) -> NSData?`
, preventing things like `Dictionary<String,AnyObject?>` passing in.

Set nil value of a Dictionary for a key will remove that key.

So, one solution I came about is replacing occurrence of `nil` by `NSNull` before passing it into `NSJSONSerialization`. But iterating into a object is too expensive.  

So, why not `NSNull` ?

That's my consideration, maybe totally wrong.

Expecting a better solution.
 Why is the parameters dictionary using AnyObject vs Any?  i.e.  no support for nesting Swift Dictionaries/Arrays, etc...
 :+1:  to NSNull()
  i got crash can any one help me how to set dictionary value in parameter i am new to swift ...  
let parameters : [String: AnyObject] =
            [
                "user_name": [FBUserDataDict.value(forKey: "name")] as AnyObject,
                "user_email":["email" : FBUserDataDict] as AnyObject,
                "user_password":"" as AnyObject,
                "user_phone_number":"" as AnyObject,
                "user_registration_type":"facebook" as AnyObject,
                "user_onesignalid":"1" as AnyObject,
                "user_profile_pic_url":"" as AnyObject

```
    ]
```
 I think [String: Any] is dangerous for JSON parameter specification unless Alamofire does some post-manipulation of the parameters dictionary before sending it to the json serializer. It's all too easy to accidentally include a String? in the parameters and cause a crash at runtime.

What I'd like to see is a transformation of all nil optionals to NSNull() automatically during serialization. @jshier what do you think about that?
 Oh thanks for the link. That looks like the best solution until serialization is out of Obj-c world. The only downside I can see is the necessity to explicitly mark all optional parameter values as Any
 Yes I was referring to the ensuing awkwardness of creating the [String: Any] parameters with optional values as per SE-140. This isn't really an Alamofire problem anymore, rather awkward bridging between languages. I can't think of a better option so I don't have anything further to contribute. Thanks for the feedback.

FWIW this is the awkwardness I'm referring to:

When we put an Optional into an Any, we should warn on the implicit conversion:

```
let x: Int? = 3
let y: Any = x // warning: Optional was put in an Any without being unwrapped

// `print` takes parameters of type Any
print(x) // warning: Optional was passed as an argument of type Any without
         // being unwrapped

// `NSMutableArray` has elements of type `id _Nonnull` in ObjC,
// imported as `Any` in Swift
let a = NSMutableArray()
a.add(x)  // warning: Optional was passed as an argument of type Any without
          // being unwrapped
If passing the Optional is intentional, the warning can be suppressed by making the conversion explicit with as Any:

let y: Any = x as Any
print(x as Any)
a.add(x as Any)
```
 Problem Solved ! Here is the solution...

 let parameters : [String: AnyObject] =
                        [
                            "user_name": FBJSONdict["name"] as! String as AnyObject,
                            "user_email":FBJSONdict["email"] as! String as AnyObject,
                            "user_password":"" as AnyObject,
                            "user_phone_number":"" as AnyObject,
                            "user_registration_type":"facebook" as AnyObject,
                            "user_onesignalid":"1" as AnyObject,
                            "user_profile_pic_url":FBJSONdict["picture"] as! String as AnyObject

```
                ]

                print("\(parameters)")
```
 @jshier  Sorry! i thought this form is the best platform for solving & discussing on issues and find the solution. 
  Hi, debugPrint prints Method arg as optional string, so the result is:
$ curl -i \
    -X **Optional("POST")** \
    -H "Accept-Language: en;q=1.0,fr;q=0.9,de;q=0.8,zh-Hans;q=0.7,zh-Hant;q=0.6,ja;q=0.5" \
    -H "Content-Type: application/json; charset=utf-8" \
    -H "Accept-Encoding: gzip;q=1.0,compress;q=0.5" \

but it should be:
$ curl -i \
    -X **"POST"** \
    -H "Accept-Language: en;q=1.0,fr;q=0.9,de;q=0.8,zh-Hans;q=0.7,zh-Hant;q=0.6,ja;q=0.5" \
    -H "Content-Type: application/json; charset=utf-8" \
    -H "Accept-Encoding: gzip;q=1.0,compress;q=0.5" \
  I'm trying the examples from the page:

```
let user = "user"
    let password = "password"

    let credential = NSURLCredential(user: user, password: password, persistence: .ForSession)
    let protectionSpace = NSURLProtectionSpace(host: "httpbin.org", port: 80, `protocol`: "https", realm: "Fake Realm", authenticationMethod: NSURLAuthenticationMethodHTTPBasic)

    Alamofire.request(.GET, "https://httpbin.org/basic-auth/user/password")
        .authenticate(usingCredential: credential, forProtectionSpace: protectionSpace)
        .response {(request, response, _, error) in
            println(request.allHTTPHeaderFields)
            println(response)
    }

    Alamofire.request(.GET, "https://httpbin.org/basic-auth/\(user)/\(password)")
        .authenticate(HTTPBasic: user, password: password)
        .response {(request, response, _, error) in
            println(request.allHTTPHeaderFields)
            println(response)
    }
```

In both cases I'm getting a 401, regardless of the version of authenticate() that I use. I am targeting iOS 7.1 so I changed the project target. Thanks.
 Same thing here using authenticate(HTTPBasic, password) variant. XCode 6 (6A313) with iPhone 6 / iOS 8 Simulator.
 :+1:
 :+1: 
 it never adds the correct header/user/pass.
  With this pull request it's able to add some custom headers to uploads. Same way like you can already add custom headers to other Alamofire Requests.

Examples for some custom headers...
1. Accept Header
   Manager.sharedInstance.defaultHeaders["Accept"] = "application/json"
2. Basic Auth Header
       let plainString = "username:password" as NSString
       let plainData = plainString.dataUsingEncoding(NSUTF8StringEncoding)
       let base64String = plainData?.base64EncodedStringWithOptions(NSDataBase64EncodingOptions.fromRaw(0)!)
       Manager.sharedInstance.defaultHeaders["Authorization"] = "Basic " + base64String!
  Since embedded dylibs/frameworks only run on iOS 8 or later, is there going to be implementation for compiling a standard framework or static lib or are you planning to remove support for iOS7?
 I'm running into the same issue. Has anyone figured out a workaround?
 Same issue here! Anyone?
 Change the base build target version of the Alamofire .xcodeproj to 7.1.
 is this working?  I'm getting this error when running on an iPhone 4 7.1 dyld: Library not loaded: @rpath/Alamofire.framework/Alamofire
 @relytmcd you need to add Alamofire.framework in "Embedded binaries" in your application project
 @arnaudjbernard great, thanks!
 Is there a way we can do this if we are using CocoaPods? Or do we have to add the framework manually?
  #### Environment

Mac OS X 10.9.4
Xcode 6 beta 7
Alamofire @ commit 72206e5
#### Steps to reproduce
1. Create new Mac OS X project, simple Cocoa application
   - language: Swift
   - use storyboards: NO
   - document based: NO
   - core data: NO
2. Drag the Alamofire.xcodeproj into your new project (as instructed in the README file)
3. From the 'build phase' tab, add a target dependency, select Alamofire's framework
4. Open AppDelegate.swift, under `import Cocoa` add `import Alamofire`
5. Build and run
6. `../AlamofireDemo/AppDelegate.swift:10:8: No such module 'Alamofire'`
 I just got the same error with Xcode 6.1.1 and it worked fine before... I guess it's a Xcode bug... a very annoying bug though... 
 Me too! Same error on Macosx build
 yes, this happens with an embedded framework as well, definitely seems like an Xcode bug, cleaning a few times, nuking the DerivedData folder seemed to do the trick for me
 Well there is no sure shot solution for this. Just try to clean your code again and again. If it doesn't works, make sure that your Xcode is of latest version.

Reference:-> [Fixing Alamofire No such module error](http://swiftforums.org/forum/alamofire/39-how-to-fix-alamofire-no-such-module-error#post39) 

Try it. Hope it helps. Good Day!
  Update to  Xcode-6 Beta 7 , there are api changes to new beta version so Ive fixed this to work with Beta 7 version of Swift
  Hi! currently I am using Xcode6 beta 6  and my code is below 

 let request =  Alamofire.request(Alamofire.Method.GET, "http://nurane.otkur.biz/api/v1/address").authenticate(HTTPBasic: "azmet", password: "123456")

```
        .responseJSON {(request, response, JSON, error) in
            println(JSON)
            println(response)
             println(error)
            //  var err:NSError?
            var jsonResult = JSON as NSDictionary
            // var Data=jsonResult["data"] as NSDictionary
            // println("daadsfas")
            // println(Data)
            //   let results: NSArray = jsonResult ["data"] as NSArray
            //println(results)

            self.delegate.setAPIResult(jsonResult , isFirst: isFirst)
    }
```

and it is returnig this error bellow 
Optional(Error Domain=NSCocoaErrorDomain Code=3840 "The operation couldn‚Äôt be completed. (Cocoa error 3840.)" (Invalid value around character 0.) UserInfo=0x78f74320 {NSDebugDescription=Invalid value around character 0.})
fatal error: unexpectedly found nil while unwrapping an Optional value

and I also tried this 
  .responseString { (request, response, string, error) in

but always returnig 
Optional("Authentication failed")  error 
this url is works fine in android and objective-C 
I have also tried in post man it`s good
what is the problem ? thanks for ur helping
 @EzimetYusup Had this problem also it's explained in this issue: https://github.com/Alamofire/Alamofire/issues/32
 thanks
 It problem also caused by invalid json data:

Try to use responseString rather than responseJSON

Alamofire.request(.GET, self.endpointForFeed()).validate().responseString { response in
            print("response string: (response.result.value!)")
  Hi Matt,

First of all, thanks for the effort of going through creating this :) I am currently using Alamofire in a Mac OS X project (targeting 10.9 for now) instead of iOS (what most if not all seem to be using).

When I add Alamofire as a git submodule to my project all works fine when I run it from within Xcode. Initially I had the `image not found` issues (similar to #55, #64 and #75) but I was able to solve that by adding Alamofire to the Embedding libraries (under General) and changing Alamofire's `Base SDK` (in build settings) to `Latest OS X (OS X 10.10)` and its `Deployment Target` to `10.9`.

While all runs fine from within Xcode, I am still having issues with the Release Build crashing. Specifically on the following line:

```
Alamofire.request(.GET, "http://localhost:\(port)/xmlstats.do")
```

I am not sure why it is crashing, so hopefully you can shed some light on the issue...

This is the (part of the) stack trace:

```
Process:         MyApp [84129]
Path:            /Users/USER/Desktop/MyApp.app/Contents/MacOS/MyApp
Identifier:      com.something.MyApp
Version:         1.1.0 (1)
Code Type:       X86-64 (Native)
Parent Process:  launchd [491]
Responsible:     MyApp [84129]
User ID:         68009012

Date/Time:       2014-09-03 08:49:58.713 +0200
OS Version:      Mac OS X 10.9.4 (13E28)
Report Version:  11
Anonymous UUID:  000-000-000-000

Sleep/Wake UUID: 000-000-000-000

Crashed Thread:  0  Dispatch queue: com.apple.main-thread

Exception Type:  EXC_BAD_INSTRUCTION (SIGILL)
Exception Codes: 0x0000000000000001, 0x0000000000000000

Thread 0 Crashed:: Dispatch queue: com.apple.main-thread
0   com.alamofire.Alamofire         0x000000010618f29c _TTSVOSs9Character10SmallUTF16S0_Ss12SequenceType_GVSs17IndexingGeneratorS0__GS2_S0__Ss13GeneratorType___TFVSs11_StringCore6extendfRS_USs12SequenceType_USs13GeneratorType__FQ_T_ + 588
1   com.alamofire.Alamofire         0x000000010618f037 _TFSS6appendfRSSFOSs9CharacterT_ + 1191
2   com.alamofire.Alamofire         0x0000000106182741 _TTSSSSSSs24ExtensibleCollectionType_GSaSS_GSaSS_Ss12SequenceType_GVSs17IndexingGeneratorSS_GS1_SS_Ss13GeneratorType_OSs9Character_VSS5IndexS4_Ss16ForwardIndexType_SiSiSs18_SignedIntegerType_Si_SiSiSs33_BuiltinIntegerLiteralConvertible_VSs20_DisabledRangeIndex__S3__GS1_GSaSS__GS1_GSaSS__S2____TFSs4joinUSs24ExtensibleCollectionType_Ss12SequenceType_USs13GeneratorType__Ss16ForwardIndexType_Ss18_SignedIntegerType__Ss33_BuiltinIntegerLiteralConvertible___S1___FTQ_Q0__Q_ + 2577
3   com.alamofire.Alamofire         0x000000010616d5b3 _TFFFC9Alamofire7Managerg14defaultHeadersGVSs10DictionarySSSS_U_FT_GS1_SSSS_U_FT_SS + 1731
4   com.alamofire.Alamofire         0x000000010614cc32 _TFC9Alamofire7Managerg14defaultHeadersGVSs10DictionarySSSS_ + 66
5   com.alamofire.Alamofire         0x0000000106141864 _TFC9Alamofire7Manager7requestfS0_FCSo12NSURLRequestCS_7Request + 196
6   com.alamofire.Alamofire         0x0000000106161488 _TF9Alamofire7requestFTOS_6MethodSS10parametersGSqGVSs10DictionarySSPSs9AnyObject___8encodingOS_17ParameterEncoding_CS_7Request + 600
7   com.something.MyApp                 0x0000000105dc5032 _TFC10MyApp18MyAppInstance7refreshfS0_FFT_T_T_ + 1042 (MyAppInstance.swift:47)
```

And the snippet from line 47 causing the crash:

```
        Alamofire.request(.GET, "http://localhost:\(port)/xmlstats.do")
        .authenticate(HTTPBasic: "test", password: "test")
        .responseString { (request, response, string, error) in
              ...
        }
```

Cheers, Jeroen
 Actually, when I just upgraded to `Xcode 6 Beta 7` (and fixed the issues with Optionals), Alamofire is working fine in my Release Build. I guess it must have been a Beta 6 issue?
   Thanks for this. Got me up and running again this morning.
 Thank you!!
  Today, Apple released Xcode 6 Beta 7, which includes a number of breaking changes involving Foundation APIs and implicitly unwrapped optionals.

Needless to say, Alamofire no longer compiles.
 see [pull request 78](/Alamofire/Alamofire/pull/78)
  With the access control capability is not better use a private global constant variable instead of the struct thing to store the singleton?
In this way we can go from:

```
public class var sharedInstance: Manager {
    struct Singleton {
        static let instance = Manager()
    }

    return Singleton.instance
}
```

to:

```
private let sharedInstance = Manager()

public class var sharedInstance:Manager {
     return sharedInstance
}
```

has described by the team itself in a discussion on the Apple forum ([third response in the thread](https://devforums.apple.com/thread/229436?start=0&tstart=0))the global variable will be lazy instatiated with the use of dispatch_once. To me the code is much cleaner with the static variable that with the struct.
  I presume various closure-typed properties in [SessionDelegate](https://github.com/Alamofire/Alamofire/blob/4a38a22f7d8178e36969114d22acf7ffe71cdfb4/Source/Alamofire.swift#L223-L239), [TaskDelegate](https://github.com/Alamofire/Alamofire/blob/4a38a22f7d8178e36969114d22acf7ffe71cdfb4/Source/Alamofire.swift#L493-L496), [DataTaskDelegate](https://github.com/Alamofire/Alamofire/blob/4a38a22f7d8178e36969114d22acf7ffe71cdfb4/Source/Alamofire.swift#L493-L496) and [DownloadTaskDelegate](https://github.com/Alamofire/Alamofire/blob/4a38a22f7d8178e36969114d22acf7ffe71cdfb4/Source/Alamofire.swift#L744-L746) are intended to be used by clients to extend/override particular delegates behavior. If I get this right I see following issues in the current version:
1. Can't find a way to use these closures ‚Äì both Manager.delegate and Request.delegate are currently inaccessible through public API (the later is even explicitly marked as private)
2. Some of the SessionDelegate's delegate methods don't take into account related task delegate behavior:
   - [`willPerformHTTPRedirection`](https://github.com/Alamofire/Alamofire/blob/4a38a22f7d8178e36969114d22acf7ffe71cdfb4/Source/Alamofire.swift#L266-L273)
   - [`didReceiveResponse`](https://github.com/Alamofire/Alamofire/blob/4a38a22f7d8178e36969114d22acf7ffe71cdfb4/Source/Alamofire.swift#L303-L311)
   - [`didBecomeDownloadTask`](https://github.com/Alamofire/Alamofire/blob/4a38a22f7d8178e36969114d22acf7ffe71cdfb4/Source/Alamofire.swift#L313-L316)
   - [`willCacheResponse`](https://github.com/Alamofire/Alamofire/blob/4a38a22f7d8178e36969114d22acf7ffe71cdfb4/Source/Alamofire.swift#L326-L334)
3. SessionDelegate's [`didReceiveChallenge`](https://github.com/Alamofire/Alamofire/blob/4a38a22f7d8178e36969114d22acf7ffe71cdfb4/Source/Alamofire.swift#L275-L281) doesn't check if specific task delegate actually handled auth challenge, so the fallback to session-level handling doesn't work.
4. Some of the SessionDelegate's closures are unused:
   - [`taskDidReceiveChallenge`](https://github.com/Alamofire/Alamofire/blob/4a38a22f7d8178e36969114d22acf7ffe71cdfb4/Source/Alamofire.swift#L228)
   - [`taskDidSendBodyData`](https://github.com/Alamofire/Alamofire/blob/4a38a22f7d8178e36969114d22acf7ffe71cdfb4/Source/Alamofire.swift#L229)
   - [`taskNeedNewBodyStream`](https://github.com/Alamofire/Alamofire/blob/4a38a22f7d8178e36969114d22acf7ffe71cdfb4/Source/Alamofire.swift#L230)
   - [`dataTaskDidBecomeDownloadTask`](https://github.com/Alamofire/Alamofire/blob/4a38a22f7d8178e36969114d22acf7ffe71cdfb4/Source/Alamofire.swift#L233)
 I have the same problem here, would be great if those properties are public.
  As far as I can see in the current version every request gets its own delegate instance (of appropriate type) which is then used by the Manager to handle NSURLSession delegate callbacks. Therefore every delegate instance is retained by the Manager instance through .delegate > .subdelegates chain. This relation never gets broken, so every delegate instance is kept in memory at least until Manager instance is deallocated ‚Äì typically long after related request is completed. Since delegates use non-trivial amount of memory (to store response data) this causes significant memory overuse.
  set the baseURL for all request
 Hi @mattt , 
Could you please provide the link for documentation about constructing URLs with enum here. So that everybody come here can easily navigate to right place.

Regards, 
Johny
  When I run the example app in release mode I get the following `EXC_BREAKPOINT`. Based on my debugging, this happens whenever `join()` is called in release mode.

```
Thread 1Queue : com.apple.main-thread (serial)
#0  0x00000001004409cc in specialization <Swift.Character.SmallUTF16 with Swift.Character.SmallUTF16 : Swift.SequenceType, Swift.IndexingGenerator<Swift.Character.SmallUTF16> with Swift.IndexingGenerator<Swift.Character.SmallUTF16> : Swift.GeneratorType> of Swift._StringCore.extend (inout Swift._StringCore)<A : Swift.SequenceType>(A) -> () ()
#1  0x0000000100440760 in Swift.String.append (inout Swift.String)(Swift.Character) -> () ()
#2  0x0000000100435ca0 in protocol witness for Swift._ExtensibleCollectionType.init <A : Swift._ExtensibleCollectionType>(Swift._ExtensibleCollectionType.Self.Type)() -> Swift._ExtensibleCollectionType.Self in conformance Swift.String : Swift._ExtensibleCollectionType [inlined] ()
#3  0x0000000100435c68 in specialization <Swift.String with Swift.String : Swift.ExtensibleCollectionType, Swift.Array<Swift.String> with Swift.Array<Swift.String> : Swift.SequenceType, Swift.IndexingGenerator<Swift.String> with Swift.IndexingGenerator<Swift.String> : Swift.GeneratorType, Swift.Character, Swift.String.Index with Swift.String.Index : Swift.ForwardIndexType, Swift.Int with Swift.Int : Swift._SignedIntegerType, Swift.Int, Swift.Int with Swift.Int : Swift._BuiltinIntegerLiteralConvertible, Swift._DisabledRangeIndex_, Swift.Character, Swift.IndexingGenerator<Swift.Array<Swift.String>> with Swift.IndexingGenerator<Swift.Array<Swift.String>> : Swift.GeneratorType> of Swift.join <A : Swift.ExtensibleCollectionType, B : Swift.SequenceType>(A, B) -> A ()
#4  0x0000000100425824 in Alamofire.Manager.(defaultHeaders.getter : Swift.Dictionary<Swift.String, Swift.String>).(closure #1).(closure #1) at /Users/kriswallsmith/Developer/Alamofire/Source/Alamofire.swift:154
#5  0x0000000100407a34 in Alamofire.Manager.(defaultHeaders.getter : Swift.Dictionary<Swift.String, Swift.String>).(closure #1) [inlined] at /Users/kriswallsmith/Developer/Alamofire/Source/Alamofire.swift:144
#6  0x0000000100407a2c in Alamofire.Manager.defaultHeaders.getter : Swift.Dictionary<Swift.String, Swift.String> at /Users/kriswallsmith/Developer/Alamofire/Source/Alamofire.swift:139
#7  0x00000001003fd478 in Alamofire.Manager.request (Alamofire.Manager)(ObjectiveC.NSURLRequest) -> Alamofire.Request at /Users/kriswallsmith/Developer/Alamofire/Source/Alamofire.swift:193
#8  0x000000010041a108 in Alamofire.request (Alamofire.Method, Swift.String, parameters : Swift.Optional<Swift.Dictionary<Swift.String, Swift.AnyObject>>, encoding : Alamofire.ParameterEncoding) -> Alamofire.Request at /Users/kriswallsmith/Developer/Alamofire/Source/Alamofire.swift:926
#9  0x000000010006b9e0 in iOS_Example.MasterViewController.(prepareForSegue (iOS_Example.MasterViewController) -> (ObjectiveC.UIStoryboardSegue, sender : Swift.Optional<Swift.AnyObject>) -> ()).(requestForSegue #1) (ObjectiveC.UIStoryboardSegue) -> Swift.Optional<Alamofire.Request> at /Users/kriswallsmith/Developer/Alamofire/Example/MasterViewController.swift:67
#10 0x000000010006a960 in iOS_Example.MasterViewController.prepareForSegue (iOS_Example.MasterViewController)(ObjectiveC.UIStoryboardSegue, sender : Swift.Optional<Swift.AnyObject>) -> () [inlined] at /Users/kriswallsmith/Developer/Alamofire/Example/MasterViewController.swift:73
#11 0x000000010006a874 in @objc iOS_Example.MasterViewController.prepareForSegue (iOS_Example.MasterViewController)(ObjectiveC.UIStoryboardSegue, sender : Swift.Optional<Swift.AnyObject>) -> () ()
#12 0x0000000186a22924 in -[UIStoryboardSegueTemplate _perform:] ()
#13 0x0000000186584824 in -[UITableView _selectRowAtIndexPath:animated:scrollPosition:notifyDelegate:] ()
#14 0x00000001866416c0 in -[UITableView _userSelectRowAtPendingSelectionIndexPath:] ()
#15 0x00000001864deab8 in _applyBlockToCFArrayCopiedToStack ()
#16 0x00000001864508f4 in _afterCACommitHandler ()
#17 0x0000000181dde388 in __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__ ()
#18 0x0000000181ddb314 in __CFRunLoopDoObservers ()
#19 0x0000000181ddb6f4 in __CFRunLoopRun ()
#20 0x0000000181d09664 in CFRunLoopRunSpecific ()
#21 0x000000018ad3b5a4 in GSEventRunModal ()
#22 0x00000001864c2164 in UIApplicationMain ()
#23 0x000000010006d4e8 in top_level_code [inlined] at /Users/kriswallsmith/Developer/Alamofire/Example/AppDelegate.swift:26
#24 0x000000010006d498 in main ()
#25 0x0000000192046a08 in start ()
```
 I ended up forking from abeb96e34b28321f8b92975352bd5eab37b8334d and copying in your fixes so the framework-less version works in Xcode 6 Beta 6. This was the only way I could get things to work for me.

https://github.com/kriswallsmith/Alamofire/tree/not-a-framework
 @kriswallsmith Thanks. I hate dragging and dropping entire Xcode projects to mine. I added the source file from your fork but I keep getting various errors.

For this code, 

```
Alamofire.request(.POST, example.com/api, parameters: ["UniqueId": uniqueID], encoding: .JSON(options: nil)).responseJSON {(request, response, JSON, error) in
    println(JSON)
}
```

I get **Type 'String!' does not conform to protocol 'AnyObject'** error. `uniqueID` is in fact a string.

For this,

```
let parameters: [String: AnyObject] = [
    "DeviceCredentials": ["UniqueId": uniqueID],
    "Personalnumber": personalNumber
]

Alamofire.request(.POST, "example.com/api", parameters: parameters, encoding: .JSON(options: nil)).responseJSON { (request, response, JSON, error) -> Void in
    println(JSON)
}
```

I get this error **'(options: NilLiteralConvertible) -> $T13' is not identical to 'Alamofire.ParameterEncoding'**
 Thanks @mattt!
  This adds the ability to specify an arbitrary number of header bytes from the response data that's passed to the JSON parser.

It's pretty common to inject arbitrary headers before a JSON blob as an XSS security measure. I've added `responseJSONWithHeaderOfLength(x)`, which takes an `Int`. This will strip `x` bytes from the beginning of the response data before passing it to the JSON parser.
 @mattt thanks for considering it, I agree that an extension is probably a better fit for this.
  The URL was being output as `"Optional(http://domain.com)"` instead of `"http://domain.com"`.
  I can't user Alamofire With iOS Device . The error is "Library not loaded: @rpath/Alamofire.framework/Alamofire"  
How to solve the problem
  On Xcode 6 Beta 5, compiling the example app shows an error in the following line of code.  Has anyone else seen this as well?

```
        let options = NSJSONWritingOptions.allZeros
```

The error reported in XCode is: "NSJSONWritingOptions.Type does not have a member named allZeros."
 I should clarify I had installed beta 6, which I suspect is part of my problem here. I'll try to completely uninstall beta 6 and see if that resolves this issue...
 Same issue here. I'm using Xcode 6 Beta 5 and Alamofire commit ac7d2e903e69856d2e59909d9555c846f85785e0
 The solution for me was to reinstall beta 6. 
  What do you think of returning the JSON response "as Dictionary<String, NSObject>" instead of the raw NSDictionnary?

The result could be then read straight with "JSON["somefield"]!". Happy to do a pull request it it gets merged.
 Example:

```
Alamofire.request(.POST, path("/api/login"), parameters: body, encoding: ParameterEncoding.JSON).responseJSON {(request, response, JSONresponse, error) in
    let JSON = JSONresponse as Dictionary<String, NSObject>
    if response?.statusCode == 200 {
        callback( success: true )
    } else {
        NSLog("%@: %@", JSON["error"]!, JSON["field"]!)
    }
}
```
 Right. I assumed that it could only return a `NSDictionary` but it could also return an array. Is there anything else it could return? Fine it returns `AnyObject?` but the caller still to cast it to something else to be able to use it. Assuming it can only return a `NSArray` and an `NSDictionary`, maybe we could have `responseJSON` and `responseJSONArray`?
  JSON does not have option since https://github.com/Alamofire/Alamofire/commit/9f7c36531d6a23ab8b5bb3f456fb7a7c79370d65

Not sure if this was intended and/or permanent but in the mean time, it would be great to update the doc. I searched quite a bit and the actual compile error is not really helpful.
  :+1: 
 :+1: 
 :+1:
  Is there a branch? fork? anything? I'm about to start my own and just wanted to make sure there was no duplicate work being done. 
 You're wonderful, I spent most of yesterday trying to figure it out and got almost nowhere.
  i like this json library ,it's very easy to use
 https://github.com/lingoer/SwiftyJSON
could you support this ?
 Parsing client specific JSON is beyond the scope of this library, and is a responsibility placed on the specific client. SwiftyJSON is built in a way that lets you turn the JSON object returned from Alamofire into a `JSONValue` very easily.

Write a class that wraps Alamofire, providing custom GET, POST, etc. methods and use the .response() methods to call a success or failure block as appropriate for your code, passing along the JSON.
 I almost forgot about how wonderfully easy it is to do things like that in Swift. Changing my own implementation now!‚Äî
Sent from Mailbox

On Tue, Aug 26, 2014 at 2:12 PM, Mattt Thompson notifications@github.com
wrote:

> > Parsing client specific JSON is beyond the scope of this library, and is a responsibility placed on the specific client.
> > Well said, @justinmakaila.
> > 
> > ## Though I would say the easiest way to integrate would be to implement a `responseSwiftyJSON` method in an extension on Alamofire.Request.
> > 
> > Reply to this email directly or view it on GitHub:
> > https://github.com/Alamofire/Alamofire/issues/57#issuecomment-53464514
 responseSwiftyJSON ~~thanks
 Has anyone actually done this?
Having a hard time since JSONValue is of type enum, an does not conform to AnyObject. Is there an easy way to implement this?
Could Alamofire make it easier to implement, by allowing `Any` in Request.response instead of `AnyObject`..
 I have an implementation, I can post it later tonight‚Äî
Sent from Mailbox

On Sat, Sep 20, 2014 at 6:19 PM, Lars-J√∏rgen Kristiansen
notifications@github.com wrote:

> Has anyone actually done this?
> 
> ## Having a hard time since JSONValue is of type enum, an does not conform to AnyObject. Is there an easy way to implement this?
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/Alamofire/Alamofire/issues/57#issuecomment-56282201
 ```
import Alamofire

// MARK: Alamofire Extensions

typealias AlamofireResponseCompletionBlock = (NSURLRequest, NSHTTPURLResponse?, AnyObject?, NSError?) -> Void

typealias APIResourceResponseCompletionBlock = (NSURLRequest, NSHTTPURLResponse?, JSONValue?, NSError?) -> Void
typealias APICollectionResponseCompletionBlock = (NSURLRequest, NSHTTPURLResponse?, [JSONValue]?, Int?, NSError?) -> Void

internal extension Alamofire.Request {
    func collectionResponseJSON(completionHandler: APICollectionResponseCompletionBlock) -> Self {
        let completion: AlamofireResponseCompletionBlock = { request, response, JSON, error in
            var jsonData: JSONValue!,
                results: [JSONValue]?,
                nextCursor: Int!,
                requestError: NSError?

            if let data: AnyObject = JSON {
                jsonData = JSONValue(data)

                if error != nil {
                    requestError = self.serializeRequestError(jsonData, error: error!)
                } else {
                    results = jsonData["results"].array
                    nextCursor = jsonData["nextCursor"].integer
                }
            }

            dispatch_async(dispatch_get_main_queue(), {
                completionHandler(request, response, results, nextCursor, (requestError != nil) ? requestError! : error)
            })
        }

        return response(
            priority: 0,
            queue: APIManager.sharedInstance().callbackQueue,
            serializer: Request.JSONResponseSerializer(),
            completionHandler: completion
        )
    }

    func resourceResponseJSON(completionHandler: APIResourceResponseCompletionBlock) -> Self {
        let completion: AlamofireResponseCompletionBlock = { request, response, JSON, error in
            var jsonData: JSONValue!,
                requestError: NSError?

            if let data: AnyObject = JSON {
                jsonData = JSONValue(data)

                if error != nil || response?.statusCode >= 300 {
                    requestError = self.serializeRequestError(jsonData, error: error)
                }
            }

            dispatch_async(dispatch_get_main_queue(), {
                completionHandler(request, response, jsonData, (requestError != nil) ? requestError! : error)
            })
        }

        return response(
            priority: 0,
            queue: APIManager.sharedInstance().callbackQueue,
            serializer: Request.JSONResponseSerializer(),
            completionHandler: completion
        )
    }

    /**
    *  Attempts to serialize error json into an NSError object.
    *  @discussion If `json` is nil, returns `error`
    *
    *  @param json JSONValue representing the error
    *  @param error NSError that came back from Alamofire
    *
    *  @return NSError with JSON error serialized in userInfo["APIError"]
    */
    private func serializeRequestError(json: JSONValue?, error: NSError?) -> NSError? {
        var apiError: Error?,
            requestError: NSError? = error

        if let jsonError: JSONValue = json {
            apiError = Error(json: jsonError)
        }

        if apiError != nil {
            requestError = NSError(domain: "APIManagerErrorDomain", code: apiError!.code ?? -1111, userInfo: [
                "APIError": apiError!
                ])
        }

        return requestError
    }
}
```
 ^ @iUtvikler 
 @justinmakaila Works great! Thanks
 I have been looking since a days on "How to parse JSON response from Alamofire API in Swift?" but didn't get the answer yet! Please take a look on the below code and let me know what has o be done in this regard.
Alamofire.request(.POST, "MY URL", parameters:parameters, encoding: .JSON) .responseJSON
{
    (request, response, JSON, error) in

```
println(JSON?)
```

}
I am able to print the response but cannot assign in Dictionary or Array. Why so?
How can I parse the response from this method?
 I use something like the following. I'm not sure if it's the best way of doing it, but it seems to work for me.

```
Alamofire.request(.POST, "MY URL", parameters:parameters, encoding: .JSON)
    .responseJSON { (request, response, json, error) in
        if let object = json as? NSDictionary {
            println(object)
        }
}
```

This gives you a non-optional constant called `object` that you can then do with as you will.

It does however mean you have to know if your base structure is an array or a dictionary, so there are probably better ways of doing it to make it more abstract.
 Thanks for your answer! 
I tried that and I am able to print that object also but still I am facing issues in assigning the value from the Dictionary in the String form.
I am getting following response
{
    message = "succesfull login";
    sid = "";
    status = 1;
}

and I am trying something like this.
            if var dictionary = JSON as? NSDictionary
            {
                println(dictionary)  //1

```
            println(dictionary.objectForKey("status"))  //2

            var temp:String = dictionary.objectForKey("status")  //2                
        }
```

On line //3, I am getting following error,
Cannot convert the expression's type 'StaticString' to type 'AnyObject'

How can I store value in String so that I can use that? Why this all is so complex?
 You should take a look at https://github.com/SwiftyJSON/SwiftyJSON

there is also an extension to work with Alamofire

https://github.com/SwiftyJSON/Alamofire-SwiftyJSON
 You have to take it out as a string. So try something like the following.

```
var temp = dictionary.objectForKey("status") as? String
```

This will give you an optional String variable in `temp`.

I might be wrong but this type of questioning might be better moved to StackOverflow or similar places. As issues for Git repos are normally more for issue/bugs with the framework rather than use issues.
 I tried this 
var temp = dictionary.objectForKey("status") as? String
and it is returning nil but there is a value for the key "status".
Yes, I should ask that on Stackoverflow and I have posted my questions over there but nobody responded. That is why I here as I downloaded Alamofire from here. 

And my question is very simple and I am surprised why nobody can answer this.
 @violabg 
https://github.com/SwiftyJSON/Alamofire-SwiftyJSON
I downloaded that but SwiftJSON folder is empty and seems files are missing
Can you please let me know how can I use that?
 @harshcs My guess would be look into submodules in Git, I think that would be why you have an empty folder.

I've just noticed that your `"status"` value is an integer in the sample JSON you provided, not a `String` as you're trying to cast it as. So taking it out and casting as a String will return `nil` as it can't find a `String` so it returns `nil`. Try the following to get an optional `Int`:

```
let temp = dictionary.objectForKey("status") as? Int
```

Make sure you always double check what type the JSON value is. If you want to make it into a string this you could do something like the following:

```
let tempString = String(temp)
```
 @Baza207 aka James! :+1: 
Thanks a lot Baza! Actually server side developer sending the Bool value and internally it was getting converted in the Integer form but now it is working as I put a check for the Int value and its not Nil anymore. You saved me! :-)
 @harshcs can you describe the implementation that you did.
I am newbie to swift and Alamofire
  When I add Alamofire in my project I get the following Linker error:
Undefined symbols for architecture i386:
  "**TFSs15_arrayForceCastU___FGSaQ__GSaQ0**", referenced from:
      **TFFFC9Alamofire7Managerg14defaultHeadersGVSs10DictionarySSSS_U_FT_GS1_SSSS_U_FT_SS in Alamofire.o
  "__TFSs21_arrayConditionalCastU___FGSaQ__GSqGSaQ0_**", referenced from:
      __TFC9Alamofire7Request18cURLRepresentationfS0_FT_SS in Alamofire.o
  "__TFSs26_forceBridgeFromObjectiveCU__FTPSs9AnyObject_MQ__Q_", referenced from:
      __TFC9Alamofire7Request12authenticatefDS0_FT9HTTPBasicSS8passwordSS_DS0_ in Alamofire.o
      __TFCC9Alamofire7Request12TaskDelegate10URLSessionfS1_FTGSQCSo12NSURLSession_4taskGSQCSo16NSURLSessionTask_19didReceiveChallengeGSQCSo28NSURLAuthenticationChallenge_17completionHandlerGSQFTOSC36NSURLSessionAuthChallengeDispositionGSQCSo15NSURLCredential__T___T_ in Alamofire.o
      __TFC9Alamofire7Request18cURLRepresentationfS0_FT_SS in Alamofire.o
      __TFFFC9Alamofire7Managerg14defaultHeadersGVSs10DictionarySSSS_U_FT_GS1_SSSS_U0_FT_SS in Alamofire.o
  "_swift_stdlib_compareNSStringDeterministicUnicodeCollation", referenced from:
      __TFCC9Alamofire7Request12TaskDelegate10URLSessionfS1_FTGSQCSo12NSURLSession_4taskGSQCSo16NSURLSessionTask_19didReceiveChallengeGSQCSo28NSURLAuthenticationChallenge_17completionHandlerGSQFTOSC36NSURLSessionAuthChallengeDispositionGSQCSo15NSURLCredential__T___T_ in Alamofire.o
ld: symbol(s) not found for architecture i386
clang: error: linker command failed with exit code 1 (use -v to see invocation)

It does work when I open Alamofire.xcworkspace so it must be some configuration in my project? Any idea?
 Delete your DerivedData at ~/Library/Developer/Xcode/DerivedData/, then try again
 Awesome, thanks!
  ios 8 sim works fine,

same issue for me when i tried to build to a device on 7.1 and 8

dyld: Library not loaded: @rpath/Alamofire.framework/Alamofire
  Referenced from: /var/mobile/Applications/C7D0B079-85E0-4286-9BF2-64D1C6162F33/iOS Example.app/iOS Example
  Reason: image not found
(lldb)
 found a answer that seems to work for building the app

http://stackoverflow.com/questions/24333981/ios-app-with-framework-crashed-on-device-dyld-library-not-loaded-xcode-6-beta

So just add the framework to the embedded binaries in project -> general
 @troypayne Try changing the "Deployment Target" on `Alamofire.xcodeproj`

![screen shot 2014-08-27 at 4 05 59 pm](https://cloud.githubusercontent.com/assets/527931/4066697/7d5281e2-2e26-11e4-8b35-ad4563cec77c.png)
 @troypayne No problem, anytime
 You still can't submit to iTunes Connect using the above... 

![screen shot 2014-10-09 at 9 21 27 am](https://cloud.githubusercontent.com/assets/364754/4569019/0bbb9396-4f43-11e4-9849-07d7744bef1f.png)
 From the README it appears we need to "include the Alamofire.swift source file directly, wrapping the top-level types in struct Alamofire to simulate a namespace" in order to support iOS7. 
Can someone help with the meaning of "wrapping the top-level types in struct" part? 
I did this and it works, bu I wonder if there is any way that is more "elegant":

struct Alamofire {
    static let manager = Manager.sharedInstance
}

*I then call Alamofire.manager.request.....
 I am also stuck on this. 
 +1 why is this closed? I have exact the same problem, cannot submit to app store when targeting iOS7. Found my solution here https://github.com/Alamofire/Alamofire/issues/186 not very elegant but it works
 @andrew-knott Try dragging and dropping `Alamofire.xcodeproj` into your project and if you did that change its `Deployment Target` to whatever version to match your projects target.

I haven't tested it yet but it might work.
 Thanks, deployment was fine and dandy with AlamoFire. The problem was with App Store submission. 

I ended up using AFNetworking. 
 Wish I could help, I haven't submitted anything with this library. Might just be a bug http://stackoverflow.com/questions/3613406/info-plist-minimumosversion-value-is-invalid

Check the library `iOS Deployment Target` for release and check you own project also.
![screen shot 2014-12-04 at 20 11 26](https://cloud.githubusercontent.com/assets/527931/5309422/f63d56a4-7bf1-11e4-87f3-3204cb16ade5.png)

Hopes this helps anyone who needs it.
 @angelcasado @andrew-knott I tested this, changed deployment target etc. It was working fine when I build it directly on my phone. However itunes connect rejects the binary with a lot of errors. The solution that I found was having Alamofire.swift directly in my project.
 That's unfortunate; this library is pretty slick. Has anyone attempted with the latest Xcode 6.1.1?¬†

‚Äî
Angel

On Fri, Dec 5, 2014 at 3:21 AM, ArtworkAD notifications@github.com
wrote:

> ## @angelcasado @andrew-knott I tested this, changed deployment target etc. It was working fine when I build it directly on my phone. However itunes connect rejects the binary with a lot of errors. The solution that I found was having Alamofire.swift directly in my project.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/Alamofire/Alamofire/issues/55#issuecomment-65759779
 Having the same problem. Would be awesome to get a fix since I prefer using Alamofire over AFNetworking in Swift. 

Here is my error that will only occur when running the app on my iPhone 6+. Works fine in the simulator.

dyld: Library not loaded: @rpath/Alamofire.framework/Alamofire
  Referenced from: /private/var/mobile/Containers/Bundle/Application/EDCBD2EC-XXXXX/myapp.app/myapp
  Reason: image not found
 +1
 Add a Copy Files Phase in your applications Build Settings.

Set the `Destination` to "Frameworks" and add the `.framework`.
  I've added the Alamofire project as a sub-project, and include the product as a framework and target dependency. The linker fails whether I am building for iOS 7.1 or 8, regardless of the target architecture. Looks like casting issues, so probably Swift or a configuration problem. Anything stand out here?

```
Build target Alamofire

Undefined symbols for architecture armv7:
  "__TFSs15_arrayForceCastU___FGSaQ__GSaQ0__", referenced from:
      __TFFFC9Alamofire7Managerg14defaultHeadersGVSs10DictionarySSSS_U_FT_GS1_SSSS_U_FT_SS in Alamofire.o
  "__TFSs21_arrayConditionalCastU___FGSaQ__GSqGSaQ0___", referenced from:
      __TFC9Alamofire7Request18cURLRepresentationfS0_FT_SS in Alamofire.o
  "_swift_stdlib_compareNSStringDeterministicUnicodeCollation", referenced from:
      __TFCC9Alamofire7Request12TaskDelegate10URLSessionfS1_FTGSQCSo12NSURLSession_4taskGSQCSo16NSURLSessionTask_19didReceiveChallengeGSQCSo28NSURLAuthenticationChallenge_17completionHandlerGSQFTOSC36NSURLSessionAuthChallengeDispositionGSQCSo15NSURLCredential__T___T_ in Alamofire.o
  "__TFSs26_forceBridgeFromObjectiveCU__FTPSs9AnyObject_MQ__Q_", referenced from:
      __TFC9Alamofire7Request12authenticatefDS0_FT9HTTPBasicSS8passwordSS_DS0_ in Alamofire.o
      __TFCC9Alamofire7Request12TaskDelegate10URLSessionfS1_FTGSQCSo12NSURLSession_4taskGSQCSo16NSURLSessionTask_19didReceiveChallengeGSQCSo28NSURLAuthenticationChallenge_17completionHandlerGSQFTOSC36NSURLSessionAuthChallengeDispositionGSQCSo15NSURLCredential__T___T_ in Alamofire.o
      __TFC9Alamofire7Request18cURLRepresentationfS0_FT_SS in Alamofire.o
      __TFFFC9Alamofire7Managerg14defaultHeadersGVSs10DictionarySSSS_U_FT_GS1_SSSS_U0_FT_SS in Alamofire.o
ld: symbol(s) not found for architecture armv7
clang: error: linker command failed with exit code 1 (use -v to see invocation)
```
  I was using the previous version of Alamofire in beta 5 of Xcode. Today I uninstalled beta 5, installed beta 6 and deleted the old Alamofire file and added the latest one.

But I get this error wherever I have used Alamofire.

**Use of unresolved identifier 'Alamofire'**

I cleaned and built the project several times. Restarted the Mac but no avail. Does anyone else facing this issue?
 If you look at the code change the AlamoFire struct was removed, so if you were using AlamoFire.request just use "request".
 Looks like we're going to have to include Alamofire in our projects as a framework. I downloaded the ZIP and tried adding the Alamofire framework in "linked frameworks and libraries" and "target dependencies" but the linker is failing. Not sure if there's an official plan for Swift Cocoapods but I hope so. Instructions for including the framework would be helpful in the meantime.
 Frameworks are only available in iOS 8, right? So to use Alamofire like we used until now (`Alamofire.request()`) we'd need to require iOS 8.
 I don't get how you're supposed to use it as a framework?
I added several `.framework` dependencies in my project and it worked fine, but the `README` here calls for a `.xcodeproj` file. Dragging it didn't make it work. Any idea?
In the meantime I just added the source file and remove the `Alamofire.` in my sources.
 In case anyone hasn't figured it out yet. Once you drag the `Alamofire.xcodeproj` into your project go to your project target >> "Build Phases" under "Target Dependencies" press `+` and add the framework.

![screen shot 2014-08-27 at 4 05 54 pm](https://cloud.githubusercontent.com/assets/527931/4066637/9fcabd6c-2e25-11e4-92ab-8487f3efc063.png)

As for supporting iOS 7; I found it easy to change Alamofire's "Deployment Target" to iOS 7. I haven't really found a bug in doing this yet. This may be the cause of some errors if your project deploys with iOS 7.

![screen shot 2014-08-27 at 4 05 59 pm](https://cloud.githubusercontent.com/assets/527931/4066648/b9c22002-2e25-11e4-987f-7c08f136d1a0.png)
 @angelcasado I dragged and dropped the Alamofire.xcodeproj to my project, added the framework as a Target Dependency but still it doesn't work. And here's the kicker! When I build it, it fails without an error!

![screen shot 2014-09-02 at 2 28 11 pm](https://cloud.githubusercontent.com/assets/2551877/4115976/9f702092-327f-11e4-9a2e-cc56fa559ee2.png)
I have no idea why Alamorefire.framework is showing in red either.

@mattt  Is adding it as a framework the only option to add Alamofire to a project? Can't we just add the file like it used to be anymore?
 @Isuru-Nanayakkara I just spent an embarrassing amount of time trying to get things working as a framework...finally realized that I didn't add "import Alamofire" into my Swift classes.
 @luketheobscure Thanks, Luke. I finally managed to integrate it successfully. 
 Thanks @angelcasado, @luketheobscure !
 @luketheobscure  Thanks, you are a life saver!
 @luketheobscure @mattt forgot to import Alamofire into my class. _face palm_
 I am getting the same error. I followed all the steps but I was not sure about this step, I probably did something wrong because I don't see this "Targets" option in the side nav:

> In Xcode, navigate to the target configuration window by clicking on the blue project icon, and selecting the application target under the "Targets" heading in the sidebar.

I do not see the "Targets" heading in the sidebar. Where is this? 

The attached screenshot is what it currently looks like. You can see the framework is red, which to me implies that there was a build problem for the framework. 

![screen shot 2014-10-08 at 8 32 58 am](https://cloud.githubusercontent.com/assets/995208/4560876/5f7a2d76-4ef8-11e4-9b68-2d5242973db0.png)
 @mattcantstop You need to add the Alamofire.framework to the Target Dependencies, not Link Binary with Libraries,. 
 Ah, thanks. Overlooked that this go round.
 @Isuru-Nanayakkara - :+1:  Adding to Target Dependencies fixed it, Thanks! And step 6 on the read me should be changed.
 I just assumed I misread it @adooylabs. I can submit a pull request to make that change if people want. 
 @mattcantstop - Sounds like a good idea. :+1: 
 In my case, if this helps anyone, I found myself with Alamofire added in both places, Target Dependencies and Link Binaries With Libraries. And the error only went away once I removed it from Link Binary.
 Great angelcassado
  Are there instructions on setting up Alamofire for development? I'm new to XCode and it informs me "Xcode does not support opening folders without a project or workspace."

I'd like to get into the library, make some changes, and ensure all the tests pass, but I've not had luck setting it up.

Thanks
 I agree, even though I'm not new to XCode.
  Hi!
If you use serialization methods like `.responseJSON()` and any network error happens (like wrong url, canceling, whatever), the `error` parameter contains serialization error. But it should be the network error.
I've fixed it,  take a look please.
 It is considered as correct behavior - see https://github.com/Alamofire/Alamofire/pull/39
 Ok, but how can I determine that my request has been canceled or it was a network error? The error says me only that deserialization failed.
  Fixed issue https://github.com/Alamofire/Alamofire/issues/47.
 Thanks, this helped me.
 Thanks for the fix! I can run it on IOS 8 but when I open the file (Alamofire.swift) my SourceKitService gets terminated and I loose all Syntaxhighlightning. Even after a clean and deleting the DerivedData folder I still have this issue. 

It also looks like that the old "unwrapping" error from IOS 7 is back. Can you run it on IOS 7 or does anyone else have same issues with the SourceKitService?
  Building fails with the following errors.

```
Alamofire.swift:60:47: Cannot reference a local function from another local function
Alamofire.swift:69:47: Cannot reference a local function from another local function
Alamofire.swift:107:41: Optional type '()' cannot be used as a boolean; test for '!= nil' instead
Alamofire.swift:107:80: Value of optional type 'String?' not unwrapped; did you mean to use '!' or '?'?
Alamofire.swift:110:40: Optional type 'String!' cannot be used as a boolean; test for '!= nil' instead
Alamofire.swift:118:67: Value of optional type '[String : AnyObject]?' not unwrapped; did you mean to use '!' or '?'?
Alamofire.swift:126:77: Value of optional type '[String : AnyObject]?' not unwrapped; did you mean to use '!' or '?'?
Alamofire.swift:176:53: Bound value in a conditional binding must be of Optional type
Alamofire.swift:180:68: Operand of postfix '?' should have optional type; type is 'NSProcessInfo'
Alamofire.swift:212:36: Optional type 'String!' cannot be used as a boolean; test for '!= nil' instead
Alamofire.swift:681:21: Optional type '@lvalue ((Int64, Int64, Int64) -> Void)!' cannot be used as a boolean; test for '!= nil' instead
Alamofire.swift:795:17: Optional type '$T1' cannot be used as a boolean; test for '!= nil' instead
Alamofire.swift:814:35: Optional type 'NSURLProtectionSpace' cannot be used as a boolean; test for '!= nil' instead
Alamofire.swift:865:41: Value of optional type 'NSData?' not unwrapped; did you mean to use '!' or '?'?
Alamofire.swift:887:75: Value of optional type 'NSData?' not unwrapped; did you mean to use '!' or '?'?
Alamofire.swift:909:86: Value of optional type 'NSData?' not unwrapped; did you mean to use '!' or '?'?
Alamofire.swift:42:18: Cannot create a single-element tuple with an element label
```
 Many of them are due to the following changes that came with XCode 6 beta 6 (from the release notes):

> A large number of Foundation APIs have been audited for optional conformance, removing a
> significant number of implicitly unwrapped optionals from their interfaces. This clarifies the
> nullability of their properties and arguments / return values of their methods. This is an ongoing
> effort since beta 5.

I'll try to get them fixed. Let's see ...
 I fixed the errors and made a pull request. Apart from the stated change above there were also many errors due to the following change:

> Non-optional types may no longer be compared to nil, and ImplicitlyUnwrappedOptional no longer  conforms to BooleanType. (16848110)
 Additionally there seem to be issues with recursive functions in ParameterEncoding.Encode (error message is "Cannot reference local function from another local function.")
 Having the same errors and now nothing works.
I tried your pull request Dschee but I get about 5 olinker errors about missing architecture?

Has anyone got it to work? I have a demo tomorrow and I made the awful mistake of upgrading to beta 6...
 @gbachik Just switch back to beta 5. That's I am doing. 
 Yeh I'm about to! It was just hard to find a copy of x5 because I had removed it.
 I used Dschee's develop branch and everything works fine with beta6
 JAManfredi are you building on an actual device or the simulator? Can you try it on the sim for me?
I didn't want to immediately push to my phone for risk of breaking my demo.
 I was just running it on my simulator. Everything compiled fine and ran, and the network calls were successful. You running it on iOS 8? I was also using Yosemite if for some strange reason it is affecting anything.
 Yeh I am. I've got a hybrid app though, so I'm using podfiles and a workspace. I wonder if thats the issue.
 Hmm, I havent tried integrating Cocoapods into any Swift projects yet so I cant say. But that seems to be the difference between our projects then at this point.
 I run into the same problem when building it for real device. I wonder if @JAManfredi didn't have this problem just because he is running on simulator
 Since Swift is a change for the better for managing complexity and creating artful code, it'd be great if there were a tutorial included with this project specifically, that did explain the process.
 @cnbuff410 He actually did build it to a device.
I got my working too. Here's how.

Built all my cocoa pods, quit xcode, then took the whole project folder and moved it to a new directory. This breaks the cocoa pod link, and it still builds just fine because they're already compiled.

This was just some sheer dumb luck but everything is working fine now. 
The same might work for you guys.
  - Removed default arg of User's home directory
- Moved test `100.json` file to `Library/Caches` directory
- Pulled test classes out of extensions
- Fixed 100.json test
- Fixed bugs in empty data handling for JSON

You probably want to pick a better `NSError` domain.
  I have a parameter like this
let parameters = [
            "username":1,
            "password":"password",
            "data": [1]
        ]
I use request method to do that
let req = Alamofire.request(.POST, "http://localhost:8080/framework-test/api/user/test", parameters: parameters, encoding: Alamofire.ParameterEncoding.JSON(options: nil))
but have a compile error
'String' is not identical to 'NSObject'
because data is a array,and array contains int ,not String .
how to deal with it?

I am chinese , im not good at english.
 Thank you!
  In the spirit of increased type safety, consider a protocol as follows:

``` swift
protocol URL {
    func url() -> String
}
```

and instead of the convenience `request` method taking a `String` for the URL parameter, it would take a struct or class conforming to the URL protocol, and retrieve the actual string URL from the protocol method.

This would "suggest" to people that they should have defined objects for whatever endpoints they need for their app, rather than just typing in random strings all over the place.
  Right now, Alamofire uses the default access control qualifier, internal. Other targets in a project, such a unit tests, might want to access these internal classes, too (to make requests, for instance). I'm a bit unsure which classes, extensions, and functions should be public and which ones left internal. 

Related to #42. 
 I'm not sure how your unit tests are set up ‚Äì on [my project](https://github.com/AshFurrow/Moya), I have the Alamofire.swift file included in my framework target, which is linked against for the unit testing target. In my framework target, I was able to access the `Alamofire` class, since its public, but the methods in the extensions, like `request` and `response` are internal, so I couldn't access them. 

It's kind of an edge case, anyway, since I don't expect many people need Alamofire in their unit tests (I was just performing a sanity check when I ran into this problem). A possible solution would be including the Alamofire file in the unit test target, too. 
 I would include all framework sources in the tests target instead of linking a test target against a framework. This way you can still access the internal members of the, would be, framework.
  Adds a request convenience method that accepts a custom NSURLRequest.
  I need the ability to send an api token in the request header.  I'm not sure if this is the best approach, but for now this is working for me.
  Can't find a reason to let response serializers handle failed requests. If it is intended then current JSON and plist serializers should be updated to respect lower level errors.
  ...f Request object. This can fix #35 and #17. But I'm not very sure whether it will introduce new bug with download task under iOS 7 and OS X 10.9.

Looks like under iOS 7, `NSURLSessionDataTask` object is wrongly treated as `NSURLSessionDownloadTask`. While in `NSURLSessionDataDelegate`'s `URLSession(session: NSURLSession!, dataTask: NSURLSessionDataTask!, didReceiveData data: NSData!)` method, `dataTask` in this callback is actually a `NSURLSessionDownloadTask` object, and the unwrap result to an `NSURLSessionDataTask` object is `nil`, which lead to `nil` response data.

So I moved `NSURLSessionDataTask` above `NSURLSessionDownloadTask` and data task is correctly recognized. 

But I'm not very sure whether `NSURLSessionDownloadTask` object would be recognized as `NSURLSessionDataTask` under iOS 7 too. So this fix may be a new bug. 
  I needed this request format to be built.

```
{
  "DeviceCredentials": {
    "UniqueId": "sample string 1"
  },
  "Personalnumber": "sample string 1"
}
```

Below is my result,

```
let parameters = [
    "DeviceCredentials": ["UniqueId": uniqueID],
    "Personalnumber": personalNumber
]
```

Both _uniqueID_ and _personalNumber_ are of **String** type. I get no error at this point but when I try to add it to the request,

```
Alamofire.request(.POST, "https://www.example.com/api/", parameters: parameters, encoding: .JSON(options: nil)).responseJSON { (request, response, JSON, error) -> Void in
    println(JSON!)
}
```

I get this error at the parameters parameter, 
**'String' is not identical to 'NSObject'.**

Is there something wrong with my format or is this a bug?
 @mattt That worked! Thank you.
  Everytime I use the sample code supplied on http://nshipster.com/alamofire/, this error comes up. 
This is the code that is given:

```
Alamofire.request(.GET, "http://httpbin.org/get")
    .response { (request, response, data, error) in
        println(request)
        println(response)
        println(error)
}
```

and here is the piece of code that is erroring (line 182):

```
var mutableUserAgent = NSMutableString(string: "\(executable!)/\(bundle!) (\(version!); OS \(os!))") as CFMutableString
```
  See my comments on [Alamofire Issue 29](https://github.com/Alamofire/Alamofire/issues/29) [here](https://github.com/Alamofire/Alamofire/issues/29#issuecomment-51516437).
 Can confirm this fixes a fatal crash on iOS 7
 It is in order of specificity. I think I wrote confusingly. `task is NSURLSessionUploadTask` only returns true for upload requests, but `task is NSURLSessionDataTask` returns true for upload and data requests, and `task is NSURLSessionDownloadTask` returns true for all kinds of requests. So the delegate was being set to handle download tasks instead of data tasks.
 This fix allows me to use Alamofire on the iOS 7.1 simulator. My `.response` callback was getting `nil` instead of an `NSData` before.
  What is the syntax to just POST a string of JSON?

I'm having trouble getting my serialized objects to send to a server as it seems like the parameter needs to be in [key: value] format to send data, where as I am using [this class](https://gist.github.com/turowicz/e7746a9c035356f9483d) to serialize my objects.

Best,
  I'm trying to use the example from NSHipster to do Basic Auth. I form my request like so:

```
        Alamofire.request(.POST, "https://my.url.com/api/v1/auth")
            .authenticate(HTTPBasic: email, password: password)
            .responseJSON {(request, response, JSON, error) in
                println(request)
                println(response)
                println(JSON)
                println(error)
        }
```

Email and password are just strings here. I am getting a response suggesting that the credentials aren't attached.

```
Optional(<NSHTTPURLResponse: 0x7fb699783080> { URL: https://my.url.com/api/v1/auth } { status code: 401, headers {
    Allow = "POST, OPTIONS";
    Connection = "keep-alive";
    "Content-Language" = "en-us";
    "Content-Length" = 59;
    "Content-Type" = "application/json";
    Date = "Mon, 11 Aug 2014 13:34:36 GMT";
    Server = "gunicorn/17.5";
    Vary = "Accept, Accept-Language";
    "Www-Authenticate" = "Basic realm=\"api\"";
    "X-Frame-Options" = SAMEORIGIN;
} })
Optional({
    detail = "Authentication credentials were not provided.";
})
```

When I make the same request while using AFNetworking, I get a successful 200 response.

```
        let manager = AFHTTPRequestOperationManager()
        manager.requestSerializer.clearAuthorizationHeader()
        manager.requestSerializer.setAuthorizationHeaderFieldWithUsername(emailTextField.text, password:passwordTextField.text)
        manager.POST(
            "https://my.url.com/api/v1/auth",
            parameters: nil,
            success: { (operation: AFHTTPRequestOperation!,
                responseObject: AnyObject!) in
                println("JSON: " + responseObject.description)
            },
            failure: { (operation: AFHTTPRequestOperation!,
                error: NSError!) in
                println("Error: " + error.localizedDescription)
        })
```

If I'm making a mistake in my request with AlamoFire, would you mind pointing it out?
 I'm having the same issue. The example in the README actually doesn't work either.
 Came here to ask this exact question. @mattt I understand your answer, but maybe update the ReadMe to explain a bit more?
 Thanks for the clarification @mattt.

I'll explain for anyone else who may be running into this issue. Based on the implementation in AFNetworking, what I need to do is create the Authorization header myself instead of using the current authenticate method. In AFNetworking (and in general) this header should look like this.

`Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==`

Here, `QWxhZGRpbjpvcGVuIHNlc2FtZQ==` is `username:password` after Base64 encoding.

The issue with using AlamoFire over AFNetworking (for now) is that you have to do the Base64 encoding yourself. AFNetworing included an encoding implementation which was called behind the scenes while creating the header. All you had to do is pass in the username and password. That being said, I imagine @mattt or someone will add that functionality into AlamoFire at some point.
 This caught me too. Thank you for explaining! Code below to hopefully save someone else time.

``` swift
let plainString = "username:password" as NSString
let plainData = plainString.dataUsingEncoding(NSUTF8StringEncoding)
let base64String = plainData?.base64EncodedStringWithOptions(NSDataBase64EncodingOptions.fromRaw(0)!)
Alamofire.Manager.sharedInstance.defaultHeaders["Authorization"] = "Basic " + base64String!
```

Encoding code adopted from http://ios-blog.co.uk/tutorials/quick-tips/base64-decoding-in-ios-7-objective-c-and-ios8-swift/ 
 How about adding a pre-auth param to the `authenticate` method, with default value false?

For comparison, `HttpWebRequest` in .NET uses a [`PreAuthenticate`](http://msdn.microsoft.com/en-us/library/system.net.httpwebrequest.preauthenticate%28v=vs.110%29.aspx) property. I'm porting apps from Xamarin/C# to Swift.
 This caught me too.

Many APIs (including GitHub's popular API) do not send the `www-authenticate` header, and just expect an `Authorization` header to be sent with any requests, so the current behavior is not ideal.
 For future travelers, if you'd like to pre-authorize:

``` swift
let plainString = "\(user):\(password)" as NSString
let plainData = plainString.dataUsingEncoding(NSUTF8StringEncoding)
let base64String = plainData?.base64EncodedStringWithOptions(NSDataBase64EncodingOptions.fromRaw(0)!)

Alamofire.Manager.sharedInstance.session.configuration.HTTPAdditionalHeaders = ["Authorization": "Basic " + base64String!]

Alamofire.request(.GET, "http://example.com")
    .response {(request, response, _, error) in
        println(response)
    }
```
 Update for people seeing @loopj's comment in 2015: the README now notes that

> [Modifying the session configuration] is not recommended for Authorization or Content-Type headers. Instead, use URLRequestConvertible and ParameterEncoding, respectively.
 @brow Thanks for the heads up. Can someone please comment on why this is not recommended?
 I think the idea is that NSURLConnection is designed to manage stateful authorization for you according to [RFC 2617](http://tools.ietf.org/html/rfc2617) and therefore doesn't expect you to override the `Authorization` header.
 Just got trolled by this... :facepunch: 
 Same thing. :facepunch: :  
Quite confusing after AFNetworking (since I worried, when found, that `authenticate` called after `request`), but it's quite unclear for first time usage.

And update for @loopj code in favor of Swift 1.2:

``` swift
let plainString = "\(user):\(password)" as NSString
let plainData = plainString.dataUsingEncoding(NSUTF8StringEncoding)
let base64String = plainData?.base64EncodedStringWithOptions(NSDataBase64EncodingOptions(rawValue: 0))

Alamofire.Manager.sharedInstance.session.configuration.HTTPAdditionalHeaders = ["Authorization": "Basic " + base64String!]
```
 Very helpful post. Save my day!
 Thanks @skywinder - @mattt perhaps we could simply point out in the README that the HTTP basic auth challenge in Alamofire is different in nature to `setAuthorizationHeaderFieldWithUsername` in AFNetworking?
 @mattt I create feature-request #502, that can also solve this confusion in auth behaviours.
 Using the Alamofire.Manager.sharedInstance seems a little dangerous if, for example, I'm making multiple requests to different endpoints that require different credentials. Doing preemptive authentication seems like it's common enough to warrant an enhancement to the API. I like @macu's suggestion of adding a PreAuthenticate property or something similar
 Just ran into this as well. +1 for Authorization headers.... 
 As an update to @loopj  @skywinder implementation, with AlamoFire > 4.0.0, you can alternatively use the static func **authorizationHeader** in Request.swift, which conveniently does the encoding for you. Something like:

```
static func getRequestHttpHeaders() -> HTTPHeaders {
    let authTuple: (key: String, value: String)? = Request.authorizationHeader(user: user, password: password)
    return [authTuple?.key : authTuple?.value, $(OTHER_HEADERS)]
}
```
  Didn‚Äôt compile in Beta 5. Changed ? to ! as the content type header
must be set.
  I encountered a bug where the response is always empty on iOS 7. I don't really know what's going on but I thin I tracked it down to [this method](https://github.com/Alamofire/Alamofire/blob/master/Source/Alamofire.swift#L336):

``` swift
func URLSession(session: NSURLSession!, dataTask: NSURLSessionDataTask!, didReceiveData data: NSData!) {
  if let delegate = self[dataTask] as? Request.DataTaskDelegate {
    delegate.URLSession(session, dataTask: dataTask, didReceiveData: data) // never reached on iOS 7
  }

  self.dataTaskDidReceiveData?(session, dataTask, data)
}
```

On iOS 8 it enters the if block, on iOS 7 it doesn't.

I really don't know much about that stuff - I hope that's useful information and someone who understands this better than me can fix it ;)
 I'm having exactly the same issue. I went a bit further and found out that `self[dataTask]` is on iOS 7  `Request.DownloadTaskDelegate` and on iOS 8 `Request.DataTaskDelegate`. That's why it doesn't enter the block on iOS 7. 

The cause of this is in the [init method on Request](https://github.com/Alamofire/Alamofire/blob/master/Source/Alamofire.swift#L415). 

``` swift
if task is NSURLSessionUploadTask {
    self.delegate = UploadTaskDelegate(task: task)
} else if task is NSURLSessionDownloadTask {
    self.delegate = DownloadTaskDelegate(task: task)
} else if task is NSURLSessionDataTask {
    self.delegate = DataTaskDelegate(task: task)
} else {
    self.delegate = TaskDelegate(task: task)
}
```

The `init` receives `NSCFLocalDataTask` instance as a task parameter and strangely enough, on iOS 7 are both of these expressions evaluated as true:

`task is NSURLSessionDownloadTask`
`task is NSURLSessionDataTask`

Any thoughts on why it behaves like this?

Note: I'm running Xcode6-Beta5
 I'm not sure why it behaves this way, but I debugged that `if` with an upload, data, and download task and found that 
- an upload task returns `true` for every type check,
- a data task returns `true` for download and data, 
- and a download task returns `true` for only download.

What would you think of just rearranging the `else if` clauses?
 I've found this to be the case when running an OS X app on 10.9 as well. 
 Really strange. But with rearranging the else if's its working on IOS 7 and IOS 8.
 Cool. I made a pull request.
 :+1: thanks!
  Hi! I tried calling an API which has https scheme using NSURLSession but it failed with the following error.

**NSURLConnection/CFURLConnection HTTP load failed (kCFStreamErrorDomainSSL, -9813)**

Then I tried the same with Alamofire and it worked with no errors.

Upon further investigation, I found that implementing the following delegate method of NSURLSession can bypass the SSL errors.

```
public func URLSession(session: NSURLSession!, didReceiveChallenge challenge: NSURLAuthenticationChallenge!, completionHandler: ((disposition: NSURLSessionAuthChallengeDisposition, credential: NSURLCredential!) -> Void)!) 
```

Can somebody please explain is this the method used in Alamofire as well? I inspected the source file and saw its been mentioned. When I implemented this method I had to explicitly specify the host name. How does Alamofire handle it without depending on the host name?
  I am interested in adding an additional value to the following GET request's header:

``` swift
let galleryRequest = Alamofire.request(.GET, "https://api.imgur.com/3/gallery.json")
    .responseString { (request, response, string, error) in
         // Do something...
    }
```

The header in question is: `Authorization: Client-ID YOUR_CLIENT_ID` where the client_id would be my imgur client_id.

Thanks for the awesome library!
 Same comment as in https://github.com/Alamofire/Alamofire/issues/7 applies here as well. Would be great if new features weren't just closed but marked as new features. Thank you.
 @mattt Hi! Is your example valid for POST requests as well? I tried it but it returns **405 - method not allowed** error. 

I tried explicitly specifying the http method in the url request like this,

```
mutableRequest.HTTPMethod = "POST"
```

Then I got a **500 - internal server error**.

**EDIT**: Yes, I'm sending it as a GET request. That's the cause of the 405 error. I tested it using [hurl.it](http://www.hurl.it/). Please show how to add a http header of a POST request as well? Also how do I add normal parameters to this POST request?

**Attempt**: Okay, I got it working. The reason I got the 500 error was because I had forgotten to append the parameter. I accomplished it by adding these few extra lines.

```
mutableRequest.HTTPMethod = "POST"
let postString = "UniqueId=\(uniqueID)"
mutableRequest.HTTPBody = postString.dataUsingEncoding(NSUTF8StringEncoding)
```

Now it works fine. I hope you're working on something to simplify this process. :) 
 I would like to re-open this issue. Sending additional request headers is mandatory on any REST API.
 +1 @endel 
 +1 @endel 
 +1 @endel
 +1 @endel 
 - 1 @endel
 +1 @endel 
 :+1: too
 +1 @endel 
 +1 @endel 
 +1
 +1, so important feature, but...
 +1 @endel
 +1
 +1
 +1
 For custom headers and `POST` parameters I used something like this (Swift). Hope it helps.

```
/// Creates a POST to the API, returning an Alamofire request that
/// you can work with. Does NOT MAKE THE CALL
/// :param: params a dictionary of parameters to add to the body
func post(url: String, params: Dictionary<String, AnyObject>) -> Request {
  let URL = NSURL(string: url)!
  let req = NSMutableURLRequest(URL: URL)
  req.HTTPMethod = "POST"
  req.setValue("some-value", forHTTPHeaderField: "MyCustomHeader")
  req.HTTPBody = params.toURLString().dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: true)
  return Alamofire.request(req).validate(statusCode: 200 ..< 300)
}
```
    Would there be any interest in integrating a more idiomatic form of JSON serialization that also leverages some of Swift's benefits, rather than using NSJSONSerialization?  If so, would it make more sense to use an existing project like [SwiftyJSON](https://github.com/lingoer/SwiftyJSON), or to write something specifically for AlamoFire?
    @troypayne Have you seen the differences in beta 5?
http://adcdownload.apple.com//Developer_Tools/xcode_6_beta_5_za4gu6/xcode_6_beta_5_release_notes.pdf
 Beta 5 does away with comparing Optionals as Booleans using != and ==
This will be a simple fix.

Instead of
`if !someOptional {...}`
you now write
`if someOptional == nil {...}`
    Just had a brief look at the whole library. Great work! I learned quite a lot from it, thank you @mattt

I did some polish for it, if you'd like to have a look:
- Change some `var` to `let`.
- Change `let data = xxx; if data {}` to `if let data = xxx {}`. In other part of the lib, optional binding is being used. It would be better to use it here as well.
- Fix a space
- Add `Alamofire.` to the connivence `request` method, making it seems like others.
  From Xcode 6 beta 4, there is a protect level to restrict code access from outside of the module. One biggest impact is it is hard to write tests now. I noticed there are good tests for `Alamofire`, but I failed to setup them for Xcode 6 beta 4.

I have tried to create a framework or application target for the `Alamofire.swift` and then add the test files to the test target. While I can import the framework/application module and modify `Alamofire.swift` by adding `public` to the methods needs to be accessed from test target, I was stuck in this error below when compiling the test target: 

![snip20140804_1](https://cloud.githubusercontent.com/assets/1019875/3796232/d3511a22-1bc5-11e4-8ae0-c5fa271a1791.png)

I also tried this [pull request](https://github.com/Alamofire/Alamofire/pull/15) but with the same error. 

(BTW: I am on OS X 10.9.4 with Xcode 6 beta 4)

I wonder is there a good way for setting up tests for `Alamofire`? Any suggestion will be appreciated. Thank you. 
 Same problem here. I thought maybe it would be fixed by Xcode/Swift beta 5, but the error keeps popping up.
 > You're probably missing an import Foundation.

I created a repo [here](https://github.com/onevcat/Alamofire-TestDemo), which is containing necessary modification mentioned in the main post, to expose the class and function to test files. And I also tried to add `import Foundation` to the tests files, but with no luck to suppress the error.

The error is still there in beta 5. It's wired and I will keep on it.

(Maybe at last I need a beta 3 to run the test XD)
  It seems there is no need to create a request here.
 :)
  LINE:886            let JSON: AnyObject! = NSJSONSerialization.JSONObjectWithData(data as NSData, options: options, error: &serializationError)

ERROR ON : ios 7 for 4s 
 Same here. Looks like `data` is `nil` there for some reason.  `error` is also `nil` fwiw.  Not sure why yet.
 I see this error even using the example from http://nshipster.com/alamofire/.

``` swift
Alamofire.request(.GET, "http://httpbin.org/get")
         .responseJSON {(request, response, JSON, error) in
             println(JSON)
         }
```
 ``` swift
        return { (request, response, data, error) in
            var serializationError: NSError? // never assigned or unwrapped
            let JSON: AnyObject! = NSJSONSerialization.JSONObjectWithData(data, options: options, error: &serializationError)
            return (JSON, serializationError)
        }
```

As I wrote in the code above, `var serializationError` is never assigned to the error passed in the closure. I'll submit a pull request soon to fix this.
 Simply adding `= error` fixes the issue, but I'm not sure if it's up to the consumer to unwrap the error?
 If it's named `serializationError` I don't think setting it to `error` is correct. I think `JSONObjectWithData` is meant to put something in there.
 I have similar situation only for iOS 7 targets, got `nil` for `data`, but iOS 8 targets runs fine. 
 Ah, I'm using an iOS 7 phone. Looks like it works with an iOS 8 simulator. Wonder what the difference is.
  What's the purpose of this dispatch sync? Wont it block anyway?        

```
var dataTask: NSURLSessionDataTask?
dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) {
    dataTask = self.session.dataTaskWithRequest(mutableRequest)
}
```
 As far as I know, it will block another thread, instead of the parent
 Ah ok thanks matt :+1: 
 Just quickly, I thought the global dispatch queues were concurrent? Couldn't you still end up with the block executing concurrently on the global queue?
 > Just quickly, I thought the global dispatch queues were concurrent? Couldn't you still end up with the block executing concurrently on the global queue?

That is true, it would have to be a barrier block, but doing that on a global queue is kind of dangerous.
 Hi @mattt ,

Now it changed to concurrent queue, what is the benefit of using still?

 public func request(URLRequest: URLRequestConvertible) -> Request {
        var dataTask: NSURLSessionDataTask!

```
    dispatch_sync(queue) {
        dataTask = self.session.dataTaskWithRequest(URLRequest.URLRequest)
    } ................
```
  Hello, Mattt. 

Congratulations for the excellent work you have been doing (in this and all your other projects). I would like to say thank you on my behalf and, I believe, on behalf of the whole community of developers! :-) 

About the Alamofire library, I think that sooner or later it will need to undergo a restructuring to facilitate the understanding, use and future development. Perhaps the best time is now, before start popping other pull requests. 

This PR may be a starting point for this (assuming that I understood the development line correctly).

What do you think?

Kind regards, 

Van
  I like where Alamofire is going! But a quick feedback: I'm a bit confused with the method names that are not verbs:

response()
responseString(encoding: NSStringEncoding)
responseJSON(options: NSJSONReadingOptions)
responsePropertyList(options: NSPropertyListReadOptions)

Do you have any suggestions on alternative names?

By the way, a similar question: what do you see as the advantage of Chainable Request / Response methods? Could someone show me an example that clearly shows the advantage?
 Try reading this:

https://developer.apple.com/library/ios/documentation/cocoa/conceptual/CodingGuidelines/Articles/NamingFunctions.html

"Functions that query properties have a further set of naming rules:
If the function returns the property of its first argument, omit the verb."

-Mike

h4labs.com (@h4labs, @melling)
iOS Apps:  Chinese | French | German | Italian | Russian | Spanish
http://appstore.com/h4labs
Facebook: https://www.facebook.com/h4labs

> On Aug 2, 2014, at 6:58 AM, David Hart notifications@github.com wrote:
> 
> I like where Alamofire is going! But a quick feedback: I'm a bit confused with the method names that are not verbs:
> 
> response()
> responseString(encoding: NSStringEncoding)
> responseJSON(options: NSJSONReadingOptions)
> responsePropertyList(options: NSPropertyListReadOptions)
> 
> Do you have any suggestions on alternative names?
> 
> ¬Å\
> Reply to this email directly or view it on GitHub.
 1) This is a coding guideline for C functions, very different to instance methods.
2) Even Apple does not follow this rule: `CGRectGetWidth`, `CGRectGetHeight`
 If we are talking about names of `Getter Methods` (`getFoo` vs. `foo`), the Objective-C convention is a noun without verb (`foo` wins).

> 1) This is a coding guideline for C functions, very different to instance methods.

Maybe we should look at the [Accessor Methods](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingMethods.html#//apple_ref/doc/uid/20001282-1004202) part.

> 2) Even Apple does not follow this rule: CGRectGetWidth, CGRectGetHeight

Indeed, as they are C function or C macro, not (getter) method.
 But in this case, it is not an accessor method, or property, it's a function that takes arguments.
  This allows calling `Alamofire.request(URL)`. GET seems to be the most common request mode, so it makes sense to use it as a default. 

Implemented as a separate func because making `method` optional and unnamed would require re-ordering the params to avoid breaking existing implementations. I agree with having the request mode specified first anyway.

Also, added a test for it and updated the README.

Thanks for this great class!
 I think it won't be obviously API. It should be semantic methods (i.e. `.get()`, `.post()`, `.put()` ...) if you want any shortcuts for common http requests.

Btw, Swift has fantastic syntax sugar for enums, so we can use `AF.request(.GET, ...)` "as is" and don't breed unnecessary methods which needs to be tested, also.
  ...which is about half of [Texas](http://www.lib.utexas.edu/maps/texas/texas-general_soil_map-2008.pdf). 

Other than that Alamofire looks awesome!
  in IOS 7 device   

753 line          override var data: NSData { return self.resumeData! }
  '''swift syntax do not need in this line.

Signed-off-by: Kyungkoo kyungkoo.kang@yahoo.com
 This pull request is for fix #8 .
  line 217, ```swift code syntax do not work. so, this code syntax do not need it.
  This is a great library that's going to make writing networking code so much simpler!

I didn't spot an easy way to POST a body of non-standard type (e.g., XML or protobuf). Would it make sense to add a way to pass in an data or a string along with a custom Content-Type header to allow this use-case?

Example:

``` swift
Alamofire.request(.POST,  "http://httpbin.org/post",  data: data, contentType: "application/xml")
```

Alternatively, how about allowing a way to extend `ParameterEncoding` so that user can write their own serialization code to encode a Swift object into string etc.?
 @mattt, can't you just label this a "new feature" and leave it open? Otherwise many interesting ideas for future versions will get lost just because their state is marked "closed" which is not what issues IMHO should be used like. 

What you're doing here seems to be something like "this feature is too much for the current version, so I'll close it". What I would expect is something like "this feature is too much for the current version, so I'll mark it so" and give it either a corresponding label or use the GitHub milestone feature in the first place to mark all features you agree for the first version so.
 I don't wanna be disrespectful ‚Äì I mean you're the one with the big experience here ‚Äì but your explanation hardly satisfies my curious mind. I'm still wondering why you close ideas for future versions. I'd be happy to keep them opened or at least mark them within closed issues so that I can find them later as ideas for new versions.

But who am I to tell you something about maintaining great frameworks ... :)
 @Dschee I like the data/content-type suggestion, as well as adding headers a little quicker than the lower level requests.
 @bpudenz Me too. I was just curious and tried to learn something about process from @mattt. But he's too busy with others things. Hopefully great new frameworks! :)
 Would like to see that too.

(+1)
   :+1: Noticed this too, and was about to submit the same PR.
 Also noticed this and _did_ submit the same PR (#5). Woops!
