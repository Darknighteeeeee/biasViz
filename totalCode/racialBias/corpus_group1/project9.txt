  Nice find! Thanks!  Looks good to me! Thanks for working on this! Published `marko@4.4.7`  I think this is fair. Would you be interested in working on this? I think `silent` would be a good option for this. `silent` should be set to `false` by default. @nahtnam I would be more than happy to help you implement this feature. We love to welcome new contributors.

First off, you will need to add the `silent` option to the `enable` function: https://github.com/marko-js/marko/blob/fe60da9c111ae60613e567ab957b47e9b77cebea/src/browser-refresh.js#L4

As I said before, the `silent` option should default to `false`.

You will need to pass the options to the `hotReload.handleFileModified(...)` function call. The `hotReload` module can be found here: https://github.com/marko-js/marko/blob/master/src/hot-reload.js#L127. From there it's as simple as only running the `console.log` statements if `silent` is not `falsy`.

If you would like to work on this, or have any additional questions let me know! We'd love to get your help. @nahtnam Contributions are greatly appreciated and we are happy to answer any questions you might have related to this proposed change. I also agree it would be a good addition. @nahtnam here's the link to the contributors guide: https://github.com/marko-js/marko/blob/master/.github/CONTRIBUTING.md

All of the latest code is on master. You would want to fork the repo and create a new branch from master to implement the new feature and then submit a pull request using your new branch as the source. @nahtnam Great to hear that you will work on it! You do not need to add the option to `runtime`. Let  us know if you have any other questions.  #705 /cc @patrick-steele-idem @mlrawlings  @mlrawlings Can you please review and merge? Looks like the failing build is an unrelated timeout.  Thanks for the all of the fixes!  Hey @newyork-anthonyng, thanks for reporting the problem with the docs. Marko allows `<script/>` and I think we have gotten used to that, but you are right that we should update the docs since we are referring to a standard HTML file. If you can send a PR to update the following file that would be greatly appreciated: https://github.com/marko-js/marko/blob/master/docs/webpack.md

Thanks again!  First off, the following is not valid:

```marko
< input id=state.id  />
```

That prevents the HTML tag from being parsed. The initial space after the `<` needs to be removed:

```marko
<input id=state.id  />
```

That is a separate issue though...

It is somewhat of an odd restriction, but the ID for the root HTML element of a UI component needs to be static and (we need to provide a better error message... sorry about that!). The reason for this is that a UI component is uniquely identified by its ID and if the ID changes during a re-render then diffing/patching will break. Wrapping everything in a `<div>` (without the `id` attribute) will fix the `state is not defined` error and it is recommended to have a single top-level HTML element (for now, at least... see below):

```marko
class {
  onCreate() {
    this.state = { id: 1}
  }
}

<div>
  <input id=state.id  />
  <include('./include-target', {id: state.id}) />
  <include('./include-target') id=state.id />
</div>
```

Typically, you want to always avoid assigning an `id` to any HTML element when using Marko. You should either use `key` (to assign a scoped ID) or use `class` for targeting styling.

Marko does not currently correctly handle multiple dynamic top-level HTML elements correctly in all cases. We are working on a fix for that. @austinkelleher @mlrawlings, can either of you look into improving the error message if the ID for the top-level HTML is dynamic? Thanks. I'm keeping this issue open because we are not providing a good error message to the user. @patrick-steele-idem I'll get to working on this either later tonight or tomorrow.  We'll investigate. Thanks for reporting the problem. I'm not able to reproduce the issue using the [marko-webpack](https://github.com/marko-js-samples/marko-webpack) sample app. I tried using both `webpack@1` and `webpack@2` and I also used `npm@5`. Could you provide a sample app to reproduce the problem or more details on your setup?  I was not able to reproduce the issue using the [marko-webpack](https://github.com/marko-js-samples/marko-webpack) sample app. I tried using both `webpack@1` and `webpack@2` and I also used `npm@5`. Could you provide a sample app to reproduce the problem or more details on your setup? Thanks for providing the project, @arthurchenn!

@austinkelleher, can you please take a look at the provided project  to reproduce the problem? Thanks  I see client-side routing and scoped CSS as two gaps that we should fill (whether it be with a new marko-specific solution or integrating a third-party solution). We will be tackling the scoped CSS this sprint and we plan to do some more research and investigation for the client-side routing piece. In the meantime, maybe check out the following library for client-side routing: https://github.com/FormidableLabs/redux-little-router

With the approach that `redux-little-router` provides, there would not necessarily need to be any direct integration of the routing library with the view library (although they do provide React helpers). Seems like a promising approach, but I have not tried that library myself. @anupdineout Here are some resources for moving from Marko v3 to Marko v4:

- [ROADMAP.md](https://github.com/marko-js/marko/blob/ed6f06a7af8f991cc0735e1366a9737e65e74a92/ROADMAP.md) (may be slightly inaccurate)
- [Migration guide](https://gist.github.com/ianvonholt/9f700ec9a6def8655179b46f9f294e61) by @ianvonholt 
- [Medium Article: Marko 4.0 is here](https://medium.com/@mlrawlings/marko-4-0-is-here-837884c5f60d) @anupdineout 

> In Marko 4 u r proving state View architecture , We can eliminate Marko Widgets ?

Marko Widgets was merged into Marko and that has made things a lot more seamless. /cc @charlieduong94   `ui-components-playground` is using `marko-starter` under the hood. `marko-starter` is using `lasso`. Perhaps this isn't clear enough. Right now, we aren't actively pushing people to use `marko-starter` apps for production, but in the future we plan to encourage this. What do you think @patrick-steele-idem @mlrawlings? Should we switch the link to the `marko-lasso` sample?  Thanks!  This PR introduces a new "dist" directory that gets generated during a publish using babel and a set of babel plugins. Initially, we are only minifying property names, but we will eventually use this to introduce better error messages in the debug build and those error messages and warning messages will be stripped out for the "dist" build. The "dist" build will automatically get used if `NODE_ENV` is anything other than `undefined`|`development`|`dev` or if `MARKO_DEBUG` env variable is set.    When introducing the [unrecognized tags](https://github.com/marko-js/marko/wiki/Error:-Unrecognized-Tag) error was introduced, compiling from XML yields . Currently the only workaround for this is to create an `html-elements.json` file and ignore each individual tag used.

We should consider:

- When compiling Marko XML files (e.g. `template.xml.marko`, `template.marko.xml`) ignoring all unrecognized tags by default

- Introduce a wildcard into the `html-elements.json` for ignoring all unrecognized tags:

```json
{
  "<*>": {}
}
```

/cc @mlrawlings @patrick-steele-idem   This is a nice change. Thanks for that. Published `marko@4.3.1`. Thanks again.  Events are not getting handled from components that are included using `<include(input.renderBody)/>`

Example: https://github.com/austinkelleher/marko-render-body-events-bug @ianvonholt This one is kind of interesting and I'm not sure there is a good way to avoid the problem. With `marko@4.3` we changed how the page boots in the browser after at it renders on the server (https://github.com/marko-js/marko/issues/651). The new behavior is that only the input/state for the top-level UI component is serialized down to the browser and the top-level UI component is re-rendered with the serialized `input`/`state` in the browser when the page loads. The problem in this case is that the `input` for the top-level UI component (`<header-bar>`) includes a `input.renderBody(out)` function that is not serializable down to the browser so when the top-level UI component is re-rendered it has no children and the page does not fully boot.

I have an idea that might work. I am thinking that if we detect that a top-level UI component has a non-serializable functions on its `input` then we will revert to the old behavior for that component. @ianvonholt We ended up going with the following solution:

> I am thinking that if we detect that a top-level UI component has a non-serializable functions on its input then we will revert to the old behavior for that component.

This solved the problem in a transparent way with no code bloat.

New version published with fix: `marko@4.4.6`

We added some tests. Please let me know if you see any issues.  Hey, @juliojerrick. Check out [Marko vs React](https://hackernoon.com/marko-vs-react-an-in-depth-look-767de0a5f9a6) for an in depth comparison of Marko and React. The article has a [differences in rendering section](https://hackernoon.com/marko-vs-react-an-in-depth-look-767de0a5f9a6#ed58), which lists some details on how Marko's rendering is more performant. 

We also have plans to add `scoped` CSS like Vue. You can track this issue #666.

Hope this helps. We've talked about the performance in a few places, but here's a more consolidated view of why Marko is fast:

# Multiple compilation outputs

Marko compiles components differently for the server and the browser.

Given the following template:

```marko
<div>Hello ${input.name}!</div>
```

## Compiled for the server

The compiled output is optimized for streaming HTML output on the server:

```js
var marko_template = require("marko/html").t(__filename),
    marko_helpers = require("marko/runtime/html/helpers"),
    marko_escapeXml = marko_helpers.x;
 
function render(input, out) {
  out.w("<div>Hello " +
    marko_escapeXml(input.name) +
    "!</div>");
}
```

## Compiled for the browser

The compiled output is optimized for virtual DOM rendering in the browser:

```js
var marko_template = require("marko/vdom").t(__filename);

function render(input, out) {
  out.e("DIV", null, 3)
    .t("Hello ")
    .t(input.name)
    .t("!");
}
```

# High performance server-side rendering

Compared to solutions like React that exclusively do virtual DOM rendering (or if you are using JSX with Vue), Marko has a huge advantage for server-side rendering. When rendering to a virtual DOM tree on the server it's a two-step process to render HTML:

- First pass to produce an entire virtual DOM tree in memory
- Second pass to serialize the virtual DOM tree to an HTML string that can then be sent over the wire (this requires traversing the entire tree structure)

In contrast, Marko renders directly to an HTML stream in a single pass. There is no intermediate tree data structure.

# Compile-time optimization of static sub-trees

Given the following template:

```marko
<div>This is a <strong>static</strong> node</div>
```

Marko will recognize that the template fragment produces the same output every time and it creates the virtual DOM node once as shown in the following compiled output:

```js
var marko_node0 = marko_createElement("DIV", null, 3, ...)
  .t("This is a ")
  .e("STRONG", null, 1)
    .t("static")
  .t(" node");
 
function render(input, out) {
  out.n(marko_node0);
}
```

Rendering a static sub-tree has virtually zero cost.

In addition, Marko will skip diffing/patching static sub-trees

# Compile-time optimization of static attributes

Marko will also optimize static attributes on dynamic elements.

Given the following template:

```marko
<div.hello>Hello ${input.name}!</div>
```

Marko will produce the following compiled output:

```js
var marko_attrs0 = {
        "class": "hello"
      };
 
function render(input, out) {
  out.e("DIV", marko_attrs0, 3)
    .t("Hello ")
    .t(input.name)
    .t("!");
}
```

Notice that the attributes object is only created once and it is used for every render. In addition, no diffing/patching will happen for static attributes.

# Smart compiler

With Marko we favor doing as much at compile-time as possible. This has made our compiler more complex, but it gives us significant gains at runtime. We have ~90% code coverage and over 2,000 tests to ensure that the compiler is working correctly. In addition, in many cases the Marko compiler provides hints to the runtime for a given template so that the runtime can optimize for specific patterns. For example, Marko recognizes if an HTML is a simple HTML element with only `class`|`id`|`style` and the runtime optimizes for these virtual DOM nodes when doing diffing/patching (the Marko compiler generates codes that flags specific virtual DOM nodes).

The React (including React variants) runtime is typically used with JavaScript code generated by a JSX transform. JSX is just a simple transform for JSX elements to function calls. While there are  a few babel transforms that apply a few compile-time optimizations, the bulk of the optimizations are happening in the runtime since there is very little happening at compile-time.

On a related note, we don't promote the usage of the Marko compiler in the browser (even though you can make it work). The Marko compiler is targeted to work almost exclusively on the server and it is pretty hefty. In contrast, Vue supports the widely adopted use case of compiling templates in the browser (in addition to compiling on the server). That means that Vue needs to be more mindful of adding new features to the compiler that might increase page weight.

# Optimized data structures

Instead of rendering to a tree of virtual DOM nodes in the browser where children are represented by arrays, Marko renders to a tree where children are represented by a linked list. This reduces the memory allocation required and it is much faster in the use case of rendering virtual DOM nodes that get immediately thrown away. The virtual DOM data structures are heavily optimized as well for JavaScript runtimes based on known optimizations that V8 and others apply for given code structures and usage patterns. [Here's the VDOM runtime code](https://github.com/marko-js/marko/tree/c648b764f203d0c0284470d6267dfd9864a004f5/runtime/vdom).

# Optimized runtime

Marko has a heavily optimized runtime that has been benchmarked and fine-tuned over a long period of time. We extensively use profilers for Node.js and the browser and analyze generated opcodes to ensure that we maximize performance. We also aim to keep the code minimal to avoid introducing overhead. Lastly, we have created a variety of benchmarks that we have used to make sure we are staying fast:

- https://github.com/marko-js/isomorphic-ui-benchmarks
- https://github.com/marko-js/templating-benchmarks
- https://github.com/patrick-steele-idem/marko-vs-react (deprecated in favor of `isomorphic-ui-benchmarks`)

# Focused

Vue supports multiple ways to define a view:

- Vue templates in standard HTML (that is, an existing element in the DOM is targeted to be the template)
- Single-file components
- JavaScript string as Vue template
- JSX

Marko, on the other hand only supports and optimizes for one way of defining a view in a `.marko` file. Maybe Vue is doing a good job of equally optimizing all of those approaches to defining a view, but I suspect that is not the case.

----

I'm sure I could come up with some more reasons that Marko is fast, but I think that covers the bulk of the optimizations that Marko applies. Hope that answers your question. I'm going to close the issue, but feel free to add more comments here if you would like further clarification.
 @patrick-steele-idem your response would make for a very interesting blog post. This should really be posted on the markojs site somewhere for others to easily find! We just published an article to explain why Marko is fast! https://medium.com/@psteeleidem/why-is-marko-fast-a20796cb8ae3  Given the following template:

```marko
<style> 
#search-guide { 


} 
</style> 
<div id="search-guide"> 
  $ console.log( 'search-guide::state - ', state ); 
  <div> 
    <!-- state.len: ${ state.len } --> 
  </div> 

    <button on-click('pickSomething')>Pick Something!</button> 

    <hr> 

    Picked: ${ state.len } 
    Pick Something Else! 
    <!-- <button on-click('pickSomething')>Pick Something!</button> --> 
</div>
```

## From @ramses0:

...this gets stuck in an infinite loop after the on-click, due to it getting stuck in the weeds with the `style` tag during    `$__rerender: function(isRerenderInBrowser) {` ... `                var targetEl = targetNode.firstChild;
                while(targetEl) {
                    var id = targetEl.id;`
yes, i know it's a terrible dom structure (working on it, eventually ;) ), but for some reason this seems like the only component which has this problem, in many other place i'm using the "dangling style tag" structure w/o issue.
moving the <style> into the <div> seems to make it not get confused ... i could try to get a smaller repro and file an issue if necessary but wanted to share as i found it.  

i didn't pursue it too much b/c i had a workaround (dump `<style>` inside a single top-level `<div>` tag per component instead of outside) and i'm planning in revamping all my styles eventually anyway  When rendering on the server, the top-level UI component cannot have function references. Marko serializes the data for the top-level UI components rendered on the server. If you have a reproducible test case to better illustrate your problem that would be helpful.  Thanks for the docs! We love seeing additional integrations with Marko.  Thanks for the PR @Hesulan. I agree that this does not look right. I'm not sure if there was an underlying reason for this, so I'm going to leave this open until either Patrick or Michael looks at it too. /cc @patrick-steele-idem @mlrawlings   Thanks for the PR. This is actually the correct behavior. Using the `static-text` attribute, Marko ignores HTML tags. The Marko.js website is not rendering the output correctly though [here](http://markojs.com/docs/core-tags/#codemarko-bodycode). It should look like this:

```marko
<div>
    This is just one
    &lt;span if(foo)&gt;
        Hello ${THIS IS NOT VALID}!
    &lt;/span&gt;
    big text block
</div>
```

I'm going to go ahead and close this, but feel free to comment here if you have any additional feedback. Also, I've opened up https://github.com/marko-js/markojs-website/issues/11 to track the Marko.js website issue.  This change looks good to me. Do you mind squashing your commits? Thanks. Actually after given this some more thought, I'm not sure if this is the right approach for globally overriding the default for a component. I don't think the compiler config is the appropriate place for such configuration. Have you considered overriding the `<await>` tag? I'll create an example of this and post a link here.

 Here's an example of overriding the `await` core tag:

https://github.com/marko-js-samples/override-core-tag @mauricionr In the demo you'll see that I copied part of the `<await>` marko.json. This is my proposed solution for that: https://github.com/marko-js/marko/issues/686 @mauricionr After speaking with @patrick-steele-idem, we decided that instead of my old approach where I overrode the tag renderer and copying the `<await>` tag's `marko.json` file, we can just override the `await` tag completely and use a transformer to set the `timeout` attribute.

*await-timeout-transformer.js*
```js
module.exports = function(el, context) {
    if (!el.hasAttribute('timeout')) {
        el.setAttributeValue('timeout', context.builder.literal(30000));
    }
}
```

The [override-core-tag](https://github.com/marko-js-samples/override-core-tag) project has been updated with the changes. 

I'm going to go ahead and close this issue. Please let me know if you have any other questions.   This looks good to me. Thanks for the fix.  I believe this has been resolved. Closing the issue, but please feel free to add comments.  Related: https://github.com/marko-js/marko/issues/528  ## Bug Report

### Context
If you have an await tag in a template that only gets rendered by an action, like setting state after the initial render, the await tag will error. The "$__sync" property is set to true by the updateManager.$__batchUpdate().

You get the following error `Uncaught Error: Not allowed`. 

### Expected Behavior
It should run the await tag and wait for the promise to be fulfilled.

### Actual Behavior
Throws an uncaught error.

### Simple Example
This is a very simple example
```JavaScript
class {
    onCreate(){
        this.state = {
            promise: Promise.resolve(),
            selected: false
        }
    }
}
<div>
    <if(state.selected)>
        <await(p from state.promise)>
            done
        </await>
    </if>
    <else>
        I show first
    </else>
    <a href="#" onClick('setState','selected', true) >click me</a>
</div>
```

<details><summary>Additional Info</summary>

### Your Environment
<!-- Include as many relevant details about the environment you experienced the bug in -->
* Version used: 4.2.8
* Environment name and version (e.g. Chrome 39, node.js 5.4): Chrome
* Operating System and version (desktop or mobile): Windows 10

### Stack Trace
AsyncVDOMBuilder.js:171 Uncaught Error: Not allowed
    at r.beginAsync (AsyncVDOMBuilder.js:171)
    at t.exports (await-tag.js:231)
    at r (index.html:33)
    at renderer.js:195
    at Component.js:525
    at Object.s [as $__batchUpdate] (update-manager.js:63)
    at n.$__rerender (Component.js:520)
    at n.update (Component.js:470)
    at o (update-manager.js:44)
    at i (update-manager.js:16)

</details>
  HTML-style comments are already completely removed at compile-time and should never show up in the rendered output. For example, given the following template:

```marko
<h1>
    <!-- Hello ${name}! -->
</h1>
```

The output HTML would be:

```html
<h1></h1>
```

For removing console logging statements, that could be done using babel: https://www.npmjs.com/package/babel-plugin-transform-remove-console

Typically, babel is only used when generating JavaScript bundles for the browser, but you could also use babel to preprocess JavaScript files loaded by Node.js.


If I am misunderstanding your question regarding the comments removal please let me know. Marko doesn't process HTML-style comments in `<script>` tags. Anything inside a `<script>` tag can be any language so it wouldn't make sense for Marko to fully parse out the content of a `<script>`.

I also prefer to avoid using babel on the server, but just wanted to throw it out as an option. 

When you are in "JavaScript land" (e.g. inside a JavaScript function), Marko does not have much control because we don't want Marko to get in the business of rewriting JavaScript code.

Another option is to monkey-patch the `console` object to make the `console.log` method a no-op, but this might cause issues with debugging and would not be recommended, but here it is anyway:

```js
console.log = function noop() {};
```

A better option is to pull in a logging framework with configurable loggers so that you can control logging. With that approach, you would be going through your own logger instances instead of calling `console.log` directly.

I'm going to go ahead and close this issue, but feel free to comment here if you have any other questions.  For context, please see [Issue #651 - Proposal: serialize only input and state on top-level server-rendered UI components #651](https://github.com/marko-js/marko/issues/651)

This Pull Request introduces some important changes to Marko:

- Only the data (including `state`, `input` and properties added to the UI component instance) for _top-level_ UI components is serialized down to the browser (previously, this data was serialized for _every_ UI component rendered on the server)
- When the page boots in the browser, the top-level UI components are "partially" re-rendered using the serialized data
- As part of the partial re-render, the rendering logic executes but the DOM is not updated and no VDOM nodes are actually created (the partial re-render is only used to mount nested UI components)
- NOTE: If a top-level UI component is "split" (that is, rendering logic is not sent down to the browser) then the old behavior will be continued
- The `out.global` object is not serialized, but specify properties can be whitelisted to be serialized. For example, to have the `out.global.apiKey` and the `out.global.locale` properties serialized you would do the following:

```js
template.render({
        $global: {
            serializedGlobals: {
                apiKey: true,
                locale: true
            }
        }
    }, res);
```

There is a chance that this might break existing apps. To revert back to the old behavior on a page-by-page basis you can do the following:

```marko
<marko no-browser-rerender />

<html>
  ...
</html>
```

  @stephenbrady thanks for opening the issue. I added a test case and I am not able to reproduce. Can you please provide more details on how to reproduce? This looks to only be an issue with [marko-loader](https://github.com/marko-js/marko-loader). I haven't had a chance to investigate yet, but I am able to reproduce it. I think this is an issue with the way we're loading the css and how webpack interprets requires.  

Here, the inline css is passed as a query parameter to the internal code-loader:
https://github.com/marko-js/marko-loader/blob/master/src/index.js#L31-L32

But because webpack uses exclamation points in require statements as a loader syntax (`require('css!less!./path/to/style.less')`), the `!important` is throwing things off.

I'm doing something [weird](https://github.com/marko-js/marko-loader/blob/master/src/code-loader.js#L3-L6) to handle newlines, but we should probably replace that with a call to `escape` [here](https://github.com/marko-js/marko-loader/blob/master/src/index.js#L30) and `unescape` [here](https://github.com/marko-js/marko-loader/blob/master/src/code-loader.js#L5).

@stephenbrady Would you mind experimenting and creating a PR if things work out?  ```marko
style {
    div.__colors {
        /* ... */
    }

    ul.__colors {
        /* ... */
    }

    __colorLI {
        /* ... */
    }

    __disabled-button { 
        color: grey;
    }

    __enabled-button { 
        color: yellow;
    }
}

<div.__colors>
    <ul.__colors>
        <li.__colorLI>
            Red
        </li>
    </ul>

    <!-- Scoped styles can also be passed to other UI components: -->
    <fancy-button disabled-class=style('disabled-button') enabled-class=style('enabled-button')>
        Click me
    </fancy-button>
</div>
```

> NOTE: It would also be possible to use unscoped CSS alongside scoped CSS

The Marko CSS preprocessor would produce the following CSS code:

```css
div.colors_abc123 {
        /* ... */
}

ul.colors_abc123 {
        /* ... */
}

.colorLI_abc123 {
        /* ... */
}

.disabled-button_abc123 { 
    color: grey;
}

.enabled-button_abc123 { 
    color: yellow;
}
```

> NOTE: The CSS code that Marko preprocessors then would go through any user CSS processor specified (`style.less`, `style.scss`, etc.)


Finally, the Marko compiler would provide a `style` function variable similar to the following:

```js
var style = marko_style('_abc123');
// style('colorLI') --> 'colorLI_abc123'
``` I could see this getting messy very quickly. I would much rather like to have a `scoped` attribute like Vue. With the above implementation, you could mix the scoped and non-scoped CSS, which is much messier. Additionally, when a component is created, often times there will be component-specific styling. This means that there will be a lot of underscores in component styles.

## Mixed syntax can be messy

In the following example, it's difficult to see which specific styles are scoped and which specific styles are global without scanning the entire block:

```marko
// A mix of scoped and global styles
style {
    .non-scoped {
        /* ... */
    }
    div.__colors {
        /* ... */
    }

    ul.__colors {
        /* ... */
    }

    .more-non-scoped {
        /* ... */
    }
    __colorLI {
        /* ... */
    }

    __disabled-button { 
        color: grey;
    }

    .even-more-non-scoped {
        /* ... */
    }

    __enabled-button { 
        color: yellow;
    }
}
```

## Scoped Attribute

In the following example, you can easily see which styles are scoped and which styles are global:

```marko
style.scoped {
    .scoped-class { 
        /* ... */
    }

   div.colors { 
        /* ... */
   }
}

// Global styles can be included in the component too
style {
    .non-scoped-class { 
        /* ... */
    }

   div.another-non-scoped { 
        /* ... */
   }
}
```

You could use `less` or an another CSS extension as an additional attribute as usual:

```marko
style.less.scoped {

}

style.less {

}
```
 Sorry guys, but I am going to have to have a dissenting opinion here. We considered the Vue.js approach before creating this proposal, but there are some serious drawbacks with the  Vue.js approach:

## Vue.js approach drawback: scoped styles must be separated out from unscoped styles

It forces scoped styles to be separated out. For a single file UI components that is fine because it is just a separate block in the single file. However, that would be a problem when the developer wants to split the styles out to a separate style file. Do we allow `style.less` + `style.scoped.less`? That would be suboptimal because now styles are split across multiple files. A separator within the file could be used but that introduces more things to learn and the separator could be problematic (do we use a CSS comment?). You could argue that unscoped styles would not be needed alongside scoped styles, but I think that would be an odd restriction.

## Vue.js approach drawback: Marko must understand each compile-to-CSS language

Another drawback with the Vue.js approach is that it requires that Marko to be able to deeply understand and parse the style source in order to rewrite the styles. This means that Marko would need to have custom support for each render-to-CSS language (Less, Sass, Stylus, etc.) language so that it could render the style code into CSS so that it could then be deeply parsed to figure out all of the CSS class names and then modified to add an attribute selector. I don't think we want to go there.

 For example, given the following:

```marko
style scoped {
    .list-container:hover {
        background: orange;
    }

    @media (min-width: 250px) {
        .list-container:hover {
            background: orange;
        }
    }
}

<div>
    Hello World
</div>
```

Marko would need to figure how to preprocess the possibly non-CSS style source to produce the following CSS output:

```css
.list-container[data-m-21e5b78]:hover {
    background: orange;
}

@media (min-width: 250px) {
    .list-container[data-m-21e5b78]:hover {
        background: orange;
    }
}
```

We actually don't want Marko to render compile-to-CSS languages to CSS because we want that to be handled by the asset pipeline/bundler (e.g. Lasso or Webpack). This is because we allow global imports for Less and Stylus (and possibly others) and Marko would not have that context.

Contrast that with the proposal I gave above:

```marko
style {
    __list-container:hover {
        background: orange;
    }

    @media (min-width: 250px) {
        __list-container:hover {
            background: orange;
        }
    }
}

<div.__list-container>
    Hello World
</div> 
```

With a little regular expression magic, the `__` prefixed variables could be easily rewritten to the following:

```css
.list-container_21e5b78:hover {
    background: orange;
}

@media (min-width: 250px) {
    .list-container_21e5b78:hover {
        background: orange;
    }
}
```

The rendered HTML would be the following:

```html
<div.list-container_21e5b78>
    Hello World
</div>
```

In addition, since we would use a special prefix, Marko would not need to deeply parse the CSS to find all of the scoped CSS class names to be added to the output HTML.

## Vue.js approach drawback: scoped style classes cannot be passed to nested components

In my proposal above scoped style classes can be passed to nested UI components:

```marko
style {
    __disabled-button { 
        color: grey;
    }

    __enabled-button { 
        color: yellow;
    }
}

<div>
    <fancy-button disabled-class=style('disabled-button') enabled-class=style('enabled-button')>
        Click me
    </fancy-button>
</div>
```

With the Vue.js approach your best option would probably be to use less efficient and less reliable descendent selectors:

```marko
style scoped {
    .my-component .disabled-button { 
        color: grey;
    }

    .my-component .enabled-button { 
        color: yellow;
    }
}

<div.my-component>
    <fancy-button disabled-class='disabled-button' enabled-class='enabled-button'>
        Click me
    </fancy-button>
</div>
```

I'm making the assumption that the output CSS code would be the following:

```css
.my-component[data-m-21e5b78] .disabled-button { 
    color: grey;
}

.my-component[data-m-21e5b78] .enabled-button { 
    color: yellow;
}
```

## Vue.js approach drawback: not compatible with multi-file adaptive styles

At eBay, we support splitting out styles into multiple files for building adaptive UIs so we might have the following:

- `style.mobile.less`
- `style.mobile.ios.less`
- `style.less`
- ...

In order for that approach to work with the Vue.js approach, Marko would somehow need to figure out how to look at all of the possible style files to figure out if a particular CSS class name is a scoped CSS class name or not so that it can add the extra `data-*` attribute to the HTML elements that use those scoped class names.


## So you don't like underscores?

We also discussed the following option based on title case:

```marko
style {
    .ListContainer:hover {
        background: orange;
    }

    @media (min-width: 250px) {
        .ListContainer:hover {
            background: orange;
        }
    }
}

<div.ListContainer>
    Hello World
</div>  
```

I don't know how I feel about that, but I could definitely be onboard with it. I think the regular expression might be a little less reliable but we could put in a few restrictions to avoid that problem. We recommended the `__` prefix because it would fit into any compile-to-CSS language and `__` is commonly used to marko properties in JavaScript as private. A pro for the title case is that `.ListContainer` looks okay, but `.__list-container` looks bad. A con with the title case is that I don't like having to type uppercase characters (shift key), but "_" requires shift as well so that is super minor.

> It's an implementation detail, but the hash could be based on the file system directory path. That is, for any file in the directory we could figure out what the hash would be regardless if we are looking at `/path/to/style.less` or `/path/to/style.mobile.less`. It could then be the job of the asset pipeline/bundler to add the hashes to the CSS code (instead of Marko doing that work).

## Summary

- What I proposed above is a combination of scoped CSS and CSS modules
- It fits in nicely with any compile-to-CSS language without Marko having to deeply parse the compile-to-CSS source code
- It works with multi-file and single-file approaches
- It's easy to explain (a unique hash is added to scoped class names that have a special prefix or that are somehow recognizable)

Still think the Vue.js approach is better? Any other thoughts or proposals? How about double dot?

```marko
..list-container:hover {
    background: orange;
}

..list-container..tasty {
    background: chocolate;
}

@media (min-width: 250px) {
    ..list-container:hover {
        background: orange;
    }
}
``` @gilbert It's subjective but I am not sure double dot looks better than `.__my-class` or `.MyClass` and I suspect that the double dot will impact tooling and syntax highlighting for the render-to-CSS languages such as Less or Sass, but I have not verified (`..my-class` is not valid CSS but both `.__my-class` and `.MyClass` are valid CSS and should not cause any linting and syntax highlighting issues).  What is the recommended way to share common methods across widgets? Normally, I would extend a base class, but it seems this isn't possible since constructors are never called. 
 
I can't seem to find a clean way to extend ALL widgets with common functionality. Everything I try requires either mixing into the prototype of "class {}" or relying on doing composition within the onCreate method. Is there a better, cleaner, way to do this?

Side Note: My team is constantly fumbling with the class syntax in components because they are not real Classes. We are using es6 and Babel in our projects and Components are the one place that do not follow how real classes work. It's making things very confusing for our developers. Is there any way to use real classes with inheritance in Components? 

UPDATE: Sorry, I missed Patrick actually answered my side note in another ticket https://github.com/marko-js/marko/issues/619. Still, any examples of how to "nicely" mixin supporting methods?  Not sure what happened there. I'm investigating. Thanks for reporting the problem. I'll be publishing a new version of the website soon after I investigate a few other issues that others have reported. You can also run the website locally: 

```
git clone https://github.com/marko-js/marko.git
cd marko
npm install
npm link

cd ..

git clone https://github.com/marko-js/markojs-website.git
cd markojs-website
npm install
npm link makro
npm start
```  Do you have a `<body>` on your page? Are you explicitly using the `<init-components/>` tag? I am not able to reproduce (unless I render UI components into the `<title>` tag). Actually, I see the problem. It does look like a bug.  Can you please provide more of template for the UI component that is failing to render so that we can try to reproduce?

EDIT: Just saw that you link to your repo. Currently, the `key` attribute is only applicable within the context of a UI component with a backing `class`. A quick fix would be the following:

```marko
class { }

<div>
  <label for-key="somekey">${input.label}</label>
  <input key="somekey" type="text" placeholder="some placeholder" />
</div>
```

We plan on revisiting this limitation in the future. I will leave the issue open.  This is related to: https://github.com/marko-js/marko/issues/589

@mlrawlings We need to work on the fix for #589

The following template is not compiled as a UI component because of the surrounding `<if>`:

```marko
class {
    onCreate(input) {
        this.state = {
            foo: false
        };
    }
    onMount() {
        this.state.foo = true;
    }
}

<if(state.foo)>
    <div.foo></div>
</if>
<else>Loading...</else>
```

Keeping this issue so that we add it as a test case when we work on #589

  Thanks!  <!----------------------------------------------------------------------
  |     IF FEATURE SUGGESTION (skip to next section for bug reports)    |
  ---------------------------------------------------------------------->
## New Feature

### Description
_list.marko_
```marko
<ul>
    <li for(itemData in input.items)>
        <include(input.item, itemData)/>
    </li>
</ul>
```

_page.marko_
```marko
<list items=input.items>
    <@item(data)>
        ${input.name}
    </@item>
</list>
```

### Open Questions
<!--- What still needs to be discussed -->
Typically, `<tag(data)>` has been used to pass data to the tag, not receive data.  Is this a good pattern?
 I think it would be confusing to use the parens to define variables for the `renderBody()` function. I'll throw out something that might be a terrible idea:

```marko
<list items=input.items>
    <@item renderBody(data)>
        ${data.name}
    </@item>
</list>
```

I'm not really a fan of this either, because technically it becomes `function renderBody(out, data) {  }`


Maybe the following?:

```marko
<list items=input.items>
    <@item input(data)>
        ${data.name}
    </@item>
</list>
```

With destructuring?:

```marko
<list items=input.items>
    <@item input({name})>
        ${data.name}
    </@item>
</list>
```
  See: http://stackoverflow.com/questions/43202021/simple-client-side-rendering-not-working

We either need to implement this method or throw an error (and update the docs). We should implement it.  This would be a great first contribution for anyone looking to get involved. @harrisjose Please feel free. Just try to follow the coding style and keep code fast and small. Here's where you will be making changes:

https://github.com/marko-js/marko/blob/430ce144ccf658d79cf1868cba5851f19c75d5d1/runtime/vdom/AsyncVDOMBuilder.js#L302-L304

Keep in mind that `getNode()` returns a `DocumentFragment`. `DocumentFragment` nodes do not support `outerHTML` which is why this is currently broken (marko used to return the first top-level HTML element node).

Also, test cases :)

Thanks in advance Awesome! And don't hesitate to ask any questions. One of us will point you in the right direction ðŸ˜„  @harrisjose Yeah, that seems to be the case.  Sorry for taking so long to reply.  Is this something you're still working on/planning to work on?  The UI components compiler should ignore "key" attributes if the custom tag declares its own "key" attribute using `marko-tag.json`. There could still be some confusion to developers, but I think it's still the right thing to do.  Putting the logging behind a flag/attribute is definitely an option and I am not opposed to that. However, if you need that level of control, I would recommend not using the `<await-error>` tag and, instead, make sure there the promise is not rejected by providing your own `.catch()`. For example:

```
$ var userInfoPromise = getUserInfo()
    .catch((err) => {
        return {
            error: err
        }
    });

<await(userInfo from userInfoPromise)>
    <if(userInfo.error)>
        We are sorry, we were unable to retrieve the user information.
    </if>
    <else>
        Hello ${userInfo.firstName}!
    </else>
</await>
```

Thoughts?  This proposal impacts how UI components are bootstrapped in the browser when the page is initially rendered on the server. This proposal improves performance on the server and it reduces the chances that a developer will run into problems related to serialization/deserialization of UI component `state`/`input`/properties when a page is rendered on the server. This proposal should maintain backwards compatibility in most cases, but there are a few caveats (see the Caveats section below).

# Current situation

Currently, each UI component rendered on the server will have its `state`, `input` and properties serialized down to the browser. This works and it is relatively fast, except there are a few issues:

- Not everything is serializable
- All `state`, `input` and properties for nested UI components can usually be derived from its top-level UI component so it is most likely redundant to serialize data associated with nested components (NOTE: Marko will dedupe objects/arrays but there is still excess serialization)

> Not everything is serializable

As an example, a reference to a UI component class is not serializable as JSON. The following will not work as expected:

```
import someModule from './foo';

<some-nested-component some-module=someModule />
```

The `some-module` attribute will result in a property being added to the `input` for `<some-nested-component>` but if `someModule` is a JavaScript module that has functions then those functions will not be included in the serialized `input` and `someModule` will _not_ be a reference to the `./foo` module when the UI component mounts in the browser.

# Proposal

Instead of serializing the `input`/properties/`state` of every UI component rendered on the server, only serialize the information associated with the top-level UI component(s) (excluding top-level "split UI components" that are not renderable in the browser).  In addition, a re-render of top-level UI components should be triggered when the top-level UI component boots in the browser. A "complete" re-render it is not actually necessary since there is no need to update the DOM in the browser (i.e., there is no reason to render any virtual DOM nodes when booting in the browser). It is, however, necessary to run through all of the rendering logic in order to determine which UI components need to be created and to determine their `input`/properties/`state`.

# Caveats

- If a nested UI component derives its props/state or generates input properties from anything other than passed in `input` (e.g. `this.locale = out.global.locale`)` then that information will not be available when the UI component mounts in the browser.

# Status

This has been mostly implemented on my machine and it is working well for the apps that I have tested so far. More testing and optimization still needs to be done.

-----

Thoughts? Concerns? Feedback?  Do you have a use case in mind? Maybe some sample code that might make the need more clear? Thanks for the clarification. A fix will go out with the next release.  The `value` attribute is not valid for a `<textarea>` tag â€“ I suggest removing that. I haven't had a chance to verify, but it appears that the `\n` in the concise line is being preserved by the parser and added to the textarea body for every render. A temporary workaround would be to use the HTML syntax for the `<textarea>` tag:

```
div
  <textarea key='input' on-input('onChange')>${input.value}</textarea>
```

We'll investigate a fix in Marko. Thanks for reporting the problem.  That does indeed look like a bug. I'll investigate. The following line looks like the problem: https://github.com/marko-js/marko/blob/47d3fc36cb5f1c83b8257e8561375c5db8886ed8/runtime/vdom/helper-styleAttr.js#L19

If `value === 0` then the if condition will not evaluate. Interested in submitting a Pull Request to fix the problem? Actually, I'm going to go ahead and take this one. There are some other changes that I think need to be made. New version published with fix: `marko@4.2.2`

Thanks for reporting the problem!  **tldr; Don't use split UI components unless there is a really good reason to do so**

When using a split component (i.e., `component-browser.js` + `component.js`) then the JavaScript module bundler (e.g. Lasso.js) will only send down the `component-browser.js` and not `component.js` (assuming it is not nested within in an un-split component...). Split components allow the rendering logic to remain on the server (instead of also being sent to the browser). However, split UI components have the caveat that they cannot be rerendered unless the `component.js` is also sent down. You are seeing that error because `component.js` was not sent down to the browser and hence the rendering logic is missing in the browser for the UI component. The error message is cryptic and we should fix that (we need to improve error messages in development without adding bloat in production).

My advice would be to avoid using split UI components. Split UI components can have some benefits but they are usually a premature optimization with not too much gain.

I'm closing this issue because I think everything is working as intended (I'll open a separate issue for improving the error message). If you still have questions or concerns please feel free to add them here.  > It's amazing how simple it is to have universal components with Marko.

Thanks for the feedback!

Currently, the best option is to use a UI component to transfer the global variables to a shared module. Something like the following:

```marko
import myStore = from './path/to/my-store';

class {
    onInput(input, out) {
        this.someImportantData = out.global.someImportantData;
    }

    onMount() {
        myStore.setSomeImportantData(this.someImportantData);
    }
}

<div.top-level-ui-component>
</div>
```

Any other UI component or JavaScript module can do something similar to the following:

```marko
import myStore from './path/to/my-store';

$ var someImportantData = myStore.getSomeImportantData();
```

I'm thinking there might be value in some how marking certain globals as being serializable to the browser so that they will automatically show up in `out.global` on both the server and in the browser. I'm going to explore this option some more and try to put together a proposal that makes this intuitive. @rubennorte Would you be good with the following proposal:

```marko
class {
    get globals() {
        return ['title'];
    }
}

<div>
    Title: ${out.global.title}
</div>
```

Basically, the `globals` property on the component class definition would be used to specify the names of the global properties that should be serialized down to the browser. 

Look good? Any other ideas? @rubennorte Would this pattern work for you?

Define and include a `<global>` component that runs before any other component on the page:

```marko
class {
  onMount() {
    var global = {
      getImageUrl: (path) => `https://${ this.input.imageHost }/${ path }`
    }
    window.out = { global: global }
  }
}
```

Then include it in your layout:

```marko
<global imageHost=process.env.IMAGE_HOST />
```  Marko does not currently have a framework with native bindings like React Native, but you can certainly create a static build of your app and use Phonegap etc.

Check out: [marko-phonegap](https://github.com/marko-js-samples/marko-phonegap) Another developer built a mobile app using Marko + [Framework7](https://framework7.io/): https://twitter.com/rtalwar26/status/847702923198963716

I haven't used Framework 7 myself but it looks promising. I installed the [ConfEngine](https://itunes.apple.com/in/app/confengine/id1010574267?mt=8) app built using Marko and Framework7 and looks very nice on my iPhone.  Thank you for the detailed problem report and the working app. Very helpful!

I put in a fix to make this issue less common, but it has to do with the UI component first being rendered on the server and Marko not knowing that an attribute was added by an external library/code. When rendered initially in the browser this would not have be an issue. The fix skips removing non-Marko rendered attributes for keyed elements. The `key` is required to know for sure that the two elements being diffed are the matching elements.

New version published with fix: `marko@4.2.1`  You are right that the error message is not helpful. I've not seen that error message. Any suggestions on how to reproduce to see if we can improve the error message? Are you only able to trigger the problem when using `browser-refresh` and modifying templates?  Your approach looks good to me. However, you're trying to do root-level text, which may mess things up. Try wrapping your `input` and text within a `<div>`. Just wanted to mention that Marko has a [known limitation](https://github.com/marko-js/marko/issues/589) that does not allow dynamic top-level HTML elements or text nodes. Once we fix #589 then the wrapping `<div>` would no longer be needed. We have some ideas on how to fix the issue, but it's a little tricky.  Thanks for reporting the problem with the website. We're investigating This has been fixed. Thanks for reporting the problem!  We need to make this more clear in the docs, but `extends` can not be used with component classes. The reason for this is that marko internally makes every UI component inherit from an internal `Component` class and you can't have multiple base classes. If you really want to do mixins then the following will work:

```js
class Component {
  foo() {
    //the following 2 lines codes are working as expected.
    var bar = new Bar()
    bar.funcInMixin() //print 'funcInMixin called' in console

    // In fact,we want component instance has mixed function `funcInMixin`
    // Unfortunately `this.funcInMixin` is undefined, it caused unhandled exception
    this.funcInMixin()
  }
}

var mixins = {
    funcInMixin() {
        // ...
    }
};

Object.assign(Component.prototype, mixins);

export default Component;
```

Does that work for you? I'm closing the issue, but please feel free to add more comments here if you still have concerns or questions.  Can you not define both and use them only when you need to? I think we need better error reporting here, but a macro should only be declared once.  Try adding `no-update` to the chart div:

    <div class="chart" no-update /> The reason it was happening in the first place was because marko's vdom logic was causing your `chart` div to revert back to what you've written in the template.

If you still want to make use of `state.percent` (and thus marko's vdom), then this structure might work better for you:

```marko
<div class="col-md-12">     
      <span class="chart-wrapper">
        <span class="chart" no-update></span>
        <span class="percent">${Math.round(state.percent)}</span>      
      </span>
      <span class="btn btn-default" onClick('updateChart')>Update chart</span>
</div>
``` > like "props" and "state" in react?

Yes, that's correct.  We'll be putting some proposals on the table soon, but if anyone wants to share ideas or their favorite router, please feel free.  ```marko
import Hello from './path/to/hello';

<Hello name="Frank"/>
```

In addition, we could also overload the `import` syntax to allow importing a UI component based on the tag name:

```marko
import Hello from <hello>;

<Hello name="Frank"/>
``` @Hesulan you may be right. I'll throw out some other ideas:

```
import-tag <hello> as Hello;
import-tag <hello>; // if no "as" is specified then default to title case
``` What's the use case for this? Auto-detection has worked pretty well for me so far (that doesn't make me opposed to this though).  From Gitter chat:

Eldar @Eldar-X Mar 24 10:47
@patrick-steele-idem in component-browser.js following not working

```js
module.exports = class {
    onCreate() {
        this.state = {
            count:0
        };
    }
    increment() {
        this.state.count++;
    }
}
```

But this is okay

```js
module.exports =  {
    onCreate() {
        this.state = {
            count:0
        };
    },
    increment() {
        this.state.count++;
    }
}
```

Error message:

```
TypeError: component.$__setCustomEvents is not a function
    at Function.ComponentDef.$__deserialize (https://localhost:3000/bundles/admin/news.js:3725:15)
    at https://localhost:3000/bundles/admin/news.js:3919:37
    at Array.forEach (native)
    at Object.initServerRendered [as concat] (https://localhost:3000/bundles/admin/news.js:3918:19)
    at https://localhost:3000/admin:2:99
    at https://localhost:3000/admin:2:275
``` I tested with the upcoming Marko v4.2.0 release and I am not able to reproduce.

@Eldar-X Can you provide more details on how to reproduce the problem you mentioned in Gitter? I'm closing the issue for now, but if it is still a problem please let me know.  Thanks for reporting the problem @eltimn. We found some issues when converting the VDOM nodes to actual DOM nodes for certain input controls. We put in some fixes that will go out with the upcoming v4.2.0 released scheduled for a little later today. Thanks, again.  New version published with fix: `marko@4.2.0`

Thanks, again.  Thanks!  Are you interested in server-side performance or client-side performance or both? For server-side performance, Marko v4 is faster than Marko v3, but not by a huge margin. On the client-side, however, Marko v4 is much, much faster due to the introduction of VDOM rendering. Unfortunately, I don't have a 1-to-1 benchmark for Marko v3 vs Marko v4. What I can say is that Marko v3 is slower than React: https://github.com/patrick-steele-idem/marko-vs-react/tree/8d686de0782995d72bc26a058e84e938f0f8c2f9#client-side-rendering-performance

Marko v4, however, is much faster than React, Preact, Inferno and Vue: https://github.com/marko-js/isomorphic-ui-benchmarks

We just gave an internal talk at eBay and in the slides we talk about improvements that we made in v4 and we also have a few slides on performance: http://markojs.com/presentations/marko-v4/

I should also mention that Marko v4 includes a Marko v3 compatibility layer to allow Marko v3 and Marko v4 components to be used together. We need to do a little more work to make the transition easier, but if you are interested in going that route let us know. The Marko v3 compatibility layer does increase the page weight so migrating UI components to Marko v4 is recommended.

Hopefully that helps you convince your team to upgrade to Marko v4 :) If you need any more details let us know.  Thanks!  ## New Feature

### Description
Currently, the only thing you can pass to the onClick attribute is a string which has to be a method on the parent component class. Now that we can access  the component directly in the template, I'd like to propose being able to pass a function to call instead of a string, or at least to pass the context for which the method should be invoked.

### Context
- This would open up the opportunity to call methods exposed by child components without having to write methods on the main class just to facilitate a click taking an action on another component
```HTML
<child-comp key='child'></child>
<a onClick(args => component.getComponent('child').method(args), 'some arg'>Click Me</a>
```

- When transcluding components, you are forced to jump through hoops in order to call a method on the component which is transcluding the content. This would allow you to expose the component to the transcluded content and call the method on it, instead of the parent.

```HTML
<list data=[1,2,3,4,5] >
   <card onClick(() => list.setSelected(item)) data=item class=[selected]  />
</list>
```
Inside list
```HTML
class {
   setSelected(item){ this.state.selected = item }
}
<for(item in input.data)>
   <include(input.renderBody)  list=component item=item selected=(item==state.selected) />
</for>
```
Currently, in order to set the selected item on List when the Card is clicked, you have to do a chain like: 

Card Click -> Call Parent Save -> Save state on Parent -> Pass state to list -> list: save state -> pass selected to Card as var on include

This is all because the context of "card" is not list, despite it being used as a renderer (child) for List. If you could at least reference the component and pass it's method to the event handler, it would allow for better reuse of components without having to bind everything up to the parent component and then back down, just to set it's own internal state. I'd much rather have Card be able to set state and call methods on List, then have list emit an event that can be listened to by parents if they are so inclined.

Now, I'm not suggesting that we just bind transcluded content to the components state, as I'm sure there are legit use cases for treating it separate. This would simply allow you to do either.

As another example, take a carousel which provides Forward and Backward methods, but leaves it up to you to call them. Perhaops even offering a transcluded region within the component to place them.

e.g.

```HTML
<carousel items=data.items>
   <@nav>
      <a onClick(() => carousel.prev())>Prev</a> | 
      <a onClick(() => carousel.next())>Next</a>
   </@nav>
</carousel>
```
This style of composed widgets allows me to reuse carousel in many ways, without having to include a particular nav type into the component itself. I could provide another component in @nav that handled it as a paged list, for example.

### Possible Implementation
I would suspect this is an easy change as a simple type check on the first argument should tell you if you are trying to call a method on the parent component (String) or a function (Function).

### Discussion
I'll admit I don't love the need for the arrow function, but you need to supply context for the method execution, so it's either that or signature like event('method', context, ...args), or perhaps an object event({m: 'method', c: context}). I could be misinterpreting your comments, but I just want to make it clear that the following works in Marko v4 because Marko v4 supports binding additional arguments to an event handler (see: http://markojs.com/docs/components/#codeon-eventmethodname-argscode):

```jsx
class {
   setSelected(item){ this.state.selected = item }
}

<list data=[1,2,3,4,5] >
   <card onClick('setSelected', item) data=item class=[selected]  />
</list>
```

The reason for not allow functions to be used as the first argument to an event handler is that functions cannot be serialized down to the browser if the page is rendered on the server (functions are not serializable as part of JSON). With Marko v4, if the page is rendered on the server then event handlers will work as expected when the application boots in the browser. This is because we serialize the method name to the browser (it's just a `String`) and use that to handle the event in the browser.

Does that clarify? It clarifies why only strings are support, thanks! Unfortunately, your example is exactly what I'm trying to avoid. The selected state is not a property of the outer most component `class{}`, it's a property of the `List` component (`<list>`). I'm trying to set the value for `List` from `card`, without having to write the boiler plate on the outer most parent (`class{}`).

In order to have a click on `card` set `List`'s selected property, I have to write...
```HTML
class {
   setSelected(item){ this.state.selected = item } // boilerplate
}

<list data=[1,2,3,4,5] selected=state.selected>
   <card onClick('setSelected', item) data=item class=[selected]  />
</list>
```

This might be OK for a single component in a template, but when this component has 10+ child components that also transcludes stuff - says it's a `Page` component with multiple components in it's `body` - then I end up with tons of these event handlers and state values. And the only reason I need them is to pass the state from the `transcluded child` to it's `parent component`. I believe this also causes the whole outer parent `(class{})` to rerender because of a state change, when the change was really internal to the `list` component.


 What I'm really trying to achieve is this:

```HTML
class {
   // no state or event handlers
}
<list data=[1,2,3,4,5] >
   <card onClick(list.setSelected, item) data=item class=[selected]  />
</list>
```
Clicking a `card` would just set `List.setSelected = card.item` without bleeding functions/state into the outer `class{}` to facilitate. 

The only way I can do this now is to put `card` inside `list`'s template, then `card` can call `list` functions directly, but then my re-usability is less because I can't supply different `cards` for different appearances. 

Does that make sense? I have lots of examples where I'm using transclusion in this way, but the fact that the transcluded component/template is not in the context of the component that's including it, means I have to write boiler plate everytime. :( I can see this comment in the output of AttachBubbleEvents which "seems" to indicate you can provide a component ID for the method

```
// Attributes will have the following form:
// on<event_type>("<target_method>|<component_id>")
```

But I can't seem to figure out how to invoke it. Is there a way to say what component the target_method should be called on??? This would solve my problem if I could target a specific component_id.

It seems to be referenced again in `getEventAttribute` as 

` // <method_name> <component_id>[ <extra_args_index]`

But I never seem to be able to enter the if block for this because `virtualAttrs` is always set with the parent ID already. Here's a solution that I've used before:

```
class {
   // no state or event handlers
}
<list data=[1,2,3,4,5] >
   <card onClick('setState', 'selected', item) data=item class=[selected]  />
</list>
``` Thanks @mindeavor , I assume this would still require passing in `selected` to the list component to set it's state? It's better, but I still couldn't call methods on List from the event, which is the other part I'd like to do.

All we need is a way to tell onClick which component we want the method called on - assuming `key=id` is set ont he target we want...
```
onClick('id:method')
onClick('id method')
onClick('id|method')
onClick('method') eventId='id'
```

Anything like this that let us target the component to be called would solve all my issues :) 

But thanks for the tip @mindeavor  @patrick-steele-idem Any advice? Is it possible to set a target component for the method execution? The code seems to elude to it, but I can't figure out where it's set. I'm guessing in the AST somewhere?  I'm assuming you are using Marko v4 and if so the following works if you want to dump to the console output:

```
$ console.log('someVar:', someVar);
```

Or if you want to dump it to the browser as part of the HTML:

```
<pre>
  ${JSON.stringify(someVar)}
</pre>
```

`JSON.stringify` will only work if the object you want to dump doesn't have circular references. If that is the case, then you can use a [`util.inspect()`](https://nodejs.org/api/util.html#util_util_inspect_object_options) (a builtin Node.js module) for dumping to a String:

```
import util from 'util';

<pre>
  ${util.inspect(someVar)}
</pre>
```

Hope that answers your question. @seangates `console.log()` does not return a value so the `<pre>` tag will be empty, but the value will be written to the `console` at least :)  Scoped CSS is indeed useful, but having "just HTML" means you have to write JavaScript inside non-sytax-highlighted strings (and "just HTML" is not even technically true, since vue.js uses [dots in attribute names](https://vuejs.org/v2/guide/syntax.html#Modifiers)). The HTML-JS syntax is definitely a step forward in templating languages :) Hey folks, support for scoped styles is something we thought about when working Marko v4 and it is something we want to offer in the near future. The problem requires some thought because the solution needs to be compatible with the module bundler (webpack, lasso, etc.) and we would need to figure out how marko scoped styles would play nice with simple CSS and the various CSS preprocessor languages. @thisguychris Since you mentioned that you are interested in working on this, it would be great to hear some proposals. We need to find a good solution for Marko while considering existing solutions:

- [BEM](http://getbem.com/introduction/) 
- [Scoped CSS in Vue](https://vue-loader.vuejs.org/en/features/scoped-css.html)
- [React CSS modules](https://github.com/gajus/react-css-modules)
- etc.

Let's see some ideas :) @jordanbtucker I concede my incorrect point about the attribute names :) For code, I'm talking about code in HTML attribute value strings, not script tags. I put a proposal on the table: [Proposal: Scoped CSS using "__" prefix](https://github.com/marko-js/marko/issues/666)

Feedback greatly appreciated!  __tldr; Use `onCreate` instead of `constructor` because of limitations associated with native ES6 classes.__

With the release of 4.0, we added support for an `onCreate` lifecycle method which was able to be aliased as `constructor` when using the class syntax to define a component.

This was implemented as a [simple assignment](https://github.com/marko-js/marko/blob/e3547b97c00255d9692a2a5a652953773849d31c/components/defineComponent.js#L47).

Unfortunately, we have discovered that despite the claim that `class` is [just syntactic sugar](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes) over typical JS prototypal inheritance, this is not actually the case.  There are limitations around how the `constructor` is implemented.  Although the constructor is `typeof "function"'` and `instanceof Function`, it cannot be called without the `new` keyword and cannot use its prototype methods of `call` and `apply`.  This prevents us from dynamically inheriting from `Component` (which has a `constructor` that we would want to call _before_ the user's `constructor`. Also, `Component` is actually only inherited from in the browser).

We didn't catch this earlier because we used the ES5 equivalent of classes in our tests because phantomJS (which we use in our test suite) does not support ES6.

Additionally, `onCreate` is not _quite_ the same as `constructor`.  It is a lifecycle method that is called when the component is created.  In the case of a server render, handing off to the browser, it does not get called when mounting in the browser.  A component fires `create`, `input` and `render` on the server and then _only_ `mount` in the browser.  The way ES6 classes are implemented would necessitate that `constructor` be called both on the server and in the browser for these isomorphic renders, which is not what we'd like.

`constructor` will continue to work in from a single-file component (we already transpile to a plain object with an `onCreate` method), but we will add a deprecation warning when using `constructor`.

To summarize, [classes have issues](https://medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3#.42r2fz3zy) and internally, Marko does not use true classes.  We really only support the `class` syntax because it looks nice and you don't have to separate methods with commas. Is this also why I cannot use the "extend" keyword on a component class? I would have assumed with a transpiler that I could inherit from a base classes, but Marko throws an error about "a component cannot be a function." This kind of sucks as there are methods I find myself having to add to components over and over because I can't just inherit a base component. :( I usually end up with an ugly mixin object.  Fixed. New version of marko published: `marko@4.1.2`

CHANGELOG: https://github.com/marko-js/marko/blob/master/CHANGELOG.md#412 @jasonmacdonald Yeah, we probably need to make this more clear, but `extends` is not something we can support. Internally, marko creates its own class for each component that extends our base [Component](https://github.com/marko-js/marko/blob/master/components/Component.js) class and components can't extend multiple classes. `mixins` are the way to go.  Here's a question I've had and maybe you could add to your documentation: can you use `<await>` within components? Thanks for the PR! (sorry for being slow to merge this PR)

We'll be publishing a new version of the site soon.  @leili2017 can you confirm that installing `marko` as @jrop suggested works?

In any case, we should make it clear in the docs that you need to have `marko` as a dependency of your project  Thanks for the bug report. I will try to reproduce I am not able to reproduce the problem. Are you using Webpack? Might need to take a closer look to see what is wrong with your setup...  Convenience. I don't believe it's required That's a good question. We're actually going to make some related changes that we have been meaning to make that I suspect you will like. We'll get back to you soon.  This looks great. Would you be interested in providing a working koa app in the following repo: https://github.com/marko-js-samples/marko-koa

(I added you as a collaborator)  Thanks! I'll add some additional clarifications, but that is a nice addition. Thanks, again.  Hey Jordan, that's a very fair question. That was done for performance reasons since monkey-patching the prototype chain is more efficient then monkey-patching each `res` object that gets passed through for every request which is what would be required if we were to use middleware. 

With that said, there might be hope in using the [Express `mount` event](https://expressjs.com/en/api.html#app.onmount) to get access to the parent express app so that the prototype chain can be monkey-patched. That requires more investigation though. If you or something else is able to make the following work then it is something we would consider:

```js
const express = require('express')
const marko = require('marko/express')

const app = express()
app.use(marko()) // marko should be a function call that returns an `express()` app
```

Alternatively, it might not hurt to also support something like the following:

```js
require('marko/express/response').patch(express);
```  I believe the `key` attribute can only be applied to components. What are you trying to do? The `key` attribute can only be used within the context of a component as it stands now. We should probably make this more clear in the docs with updated text:

> The `key` attribute can be applied to both HTML elements and custom tags for UI components within the context of a component's view template.

I'm going to give it some more thought and see if it makes sense to support the `key` attribute outside the context of a component view template. I did some more investigation and verified that Marko is handling this correctly. Keys are _scoped_ IDs that are scoped within the context of a component. If there is no component then `this.getEl(elId)` wouldn't make sense. There should be a component definition for the template with the key (either an inline `class { }` or a `component.js` in the same directory). If you have any questions please let us know, but everything appears to be working as expected.  For consistency we should also automatically discover custom tags that are outside a directory  A new version should be published later today. Thanks!  Hey Fabien, sorry for the slow response. You can do the following to break out of concise syntax mode:

```
---
    <SubObject>
        <Value>primary</Value>
    </SubObject>
---
```

Does that work for you?  We want all compiled Marko templates to be loaded in strict mode to catch problems early. As an example, Marko uses `Object.freeze()` on the state object to prevent new properties from being added that won't be watched. Without strict mode adding properties will silently fail. Marko automatically transpiles the `class` syntax into an object declaration so that the compiled template will be ES5 compatible (assuming you aren't using other ES6 syntax). It produces something like the following:

_index.marko_

```jsx
class {
    foo() {

    }
    bar() {

    }
}

<div>
</div>
```

Compiled output:

```js
"use strict";
// ...
var marko_component = {
        foo: function() {},
        bar: function() {}
      }
// ...
```  With Marko v4, we now create an instance of the UI component when rendering a UI component, but the UI component instance is not publicly exposed so it is not possible to call instance methods in the marko template code. This proposal introduces a new `component` variable that can be used to reference the UI component instance as shown below:

```jsx
class {
    getFullName() {
        return this.input.firstName + ' ' + this.input.lastName;
    }
}

<div>
    Hello ${component.getFullName()}!
</div>
```

Thoughts? Concerns?

ðŸ‘  or ðŸ‘Ž  ?

/cc @mlrawlings @austinkelleher @philidem @mindeavor @ramses0

 Just to be clear @ramses0, you are in favor of this proposal as-is, correct?  I think it makes sense to have as an option, and see no harm in adding it. I like this proposal too. Thanks for the feedback. I will work on implementing this.  You should be able to nest `<await>` tags, but if you can run them in parallel, that's better to do anyway.  I believe `Promise.all` is your best bet. @mauricionr Are you rendering this client-side or server-side?  @Hesulan Thanks for reporting! `marko@4.0.0-rc.21` has been published with the fix  Thanks for the feedback @mauricionr !

Just to add to what @Hesulan said, minification and [minprops](https://github.com/mlrawlings/minprops) (not yet documented) are the only two things that are strongly recommended for production builds. But yes, we will be publishing a guide for production builds. I'll keep this issue open as a reminder. Thanks, again!    Marko v3 supports scoped vars:

```jsx
<var x=1 y=2>
  The `x` and `y` are scoped to this block.
</var>
```

We moved from `<var>` to `$ var` and need to rethink support for scoped variables in Marko v4. /cc @ramses0  Need to either add an error message or make changes to support dynamic top-level HTML elements. /cc @ramses0 Related:

```marko
class {
  test() {
    console.log('test');
  }
}

<for(_ in [0, 1, 2])>
	<div on-custom-event('test') />
</for>
```

Throws:
```
ReferenceError: __component is not defined
```

[try online](http://markojs.com/try-online/?gist=e2ea1d6b198e37077895c17e49f7038b) - [gist](https://gist.github.com/mlrawlings/e2ea1d6b198e37077895c17e49f7038b)

Adding a wrapper `<div>` or even a sibling `<div>` causes the `__component` variable to be pulled in properly.    Thanks for opening this bug report @smulder. We'll take a look.     Good news: can already use the `include` tag for this

```html
<include(input.renderBody)/>
```

Include actually looks for a `renderBody` property if its an object, so this works as well:
```html
<include(input)/>
``` Yeah, but `data` isn't going anywhere anytime soon and we won't be adding deprecation warnings for it right away either. But all the docs for Marko 4.0 will reference `input`  When users see `<for(var x in xs)>`, they think it's native JavaScript and try to do fancy ES6 stuff like destructuring.

Here's an actual attempt:

    <for(const [airport, { area, name, pos: { lat, lng } }] of Object.entries(geo.airports))>

I have two suggestions (not mutually-exclusive):

1. Rename `for` to `each` to avoid confusion
2. Give `for` native JS code support

This would be the last nail in the "uncanny JavaScript-like tags" coffin.  @tinovyatkin Can you provide more details?  When running the tests the file/line shows up correctly.

```
WARNING!!
The "<invoke>" tag is deprecated. Please use "$ <js_code>" for JavaScript in the template. See: https://github.com/marko-js/marko/wiki/Deprecation:-var-assign-invoke-tags
  at test/autotests/render/invoke/template.marko:7:33
```

Is the `<invoke>` node being added dynamically somehow?   Failure is intermittent.  Thanks for reporting this issue. This is a result of: https://github.com/marko-js/marko/issues/560. I will have a fix up soon. This should be fixed now. A new version should be published later today.     The CI build fail looks to be an intermittent failure.  Currently, Marko supports "scoped IDs" in the form of a "ref":

```html
<div>
  <button ref="ok" type="button">OK</button>
  <button ref="cancel" type="button">Cancel</button>
</div>
```

A nested element/widget can be looked up by a ref:

```js
var okButton = this.getEl('button');
```

A "ref" attribute results in an ID attribute being assigned to the final element. For example:

```html
<div>
  <button id="w0-ok" type="button">OK</button>
  <button cancel="w0-cancel" type="button">Cancel</button>
</div>
```

[morphdom](https://github.com/patrick-steele-idem/morphdom) uses the "id" attribute as a "key" to match up elements during a diff/patch. Therefore, marko is using the "ref" attribute for two purposes:

- To assign a key for diffing/patching
- To assign a key for referencing nested elements/widgets

A "key" is the more general term ("scoped-id" is more appropriate, but too long) and "key" is already well understood to be used for matching up elements during diffing/patching.

As a late breaking change for the Marko v4 release, we want to rename "ref" to "key". We will introduce deprecation warnings, but we do not want to ship the "v4" release with support for "ref".

Thoughts? Concerns? Thanks in advance. I think this is a good change. Does using a `ref` prevent the element from being messed with during a redraw? @Hesulan For better or worse, React and all of the React variants have already hijacked the "key" attribute: https://facebook.github.io/react/docs/lists-and-keys.html#keys

The `key` attribute that we are proposing for Marko would serve the exact same purpose as developers are used to with React. The only difference is that we would also be using the `key` attribute to allow an element/widget to be referenced by the `key` (that is, `getEl(<key>)`, `getWidget(<key>)`). In comparison, React has a separate concept of a `ref` which started out as a string, but is now a function: 

```jsx
<input
  type="text"
  ref={(input) => { this.textInput = input; }} />
```

That is another reason we want to get away from `ref`.

(side note, React requires a lot of code to reference an element... uggh)

@mindeavor 

> Does using a ref prevent the element from being messed with during a redraw?

No, it doesn't impact rendering. It only impacts how elements are matched up for diffing purposes. DOM elements with the same `key` are guaranteed to be diffed against each other. Even without specifying a `key` things will still render correctly, but the developer might notice unexpected behavior (e.g., focus moving to the wrong element or CSS transitions being applied incorrectly).

 Also, just to be clear, this would be a simple internal rename from `ref` to `key`. It would require minimal code change (although we would have to go fix all of the tests and sample apps :/ ). Thanks for taking this on @austinkelleher ! We want to show a deprecation warning initially and publish a new `rc` release. We will completely remove support for `ref` and the deprecation warnings when we do the final v4 release.    Just to clarify â€“ you meant to say "because a joined empty array is falsey", correct?  `getTemplateData` was necessary for v3 widgets because there was only `data` passed to the template and we needed some way to get `state` into the template as well as any input data you might have also needed.  

In v4, your template receives an `input` variable (also aliased as `data` for compatibility) and a separate `state` variable is available to your template if you set `this.state` in your component's class.  You can then access both `state` and `input` in your template.  You no longer need `getTemplateData` to make this data available to your template.  If you need to massage the input data that is being passed in as `input`, you can return a different value from `onInput`.

**Old:**
```js
module.exports = require('marko-widgets').defineComponent({
    template: require('./template.marko'),
    getInitialState(input) {
        return { count:0, color:input.color };
    },
    getTemplateData(state, input) {
        return state;
    },
    increment() {
        this.setState('count', this.state.count+1);
    }
})
```
```xml
<div w-bind>
    The current count is <span style={ color:data.color }>${data.count}</span>
    <button w-on-click="increment">+1</button>
</div>
```

**New:**
```jsx
class {
    constructor(input) {
        this.state = { count:0 };
    }
    increment() {
        this.state.count++;
    }
}

<div>
    The current count is <span style={ color:input.color }>${state.count}</span>
    <button on-click('increment')>+1</button>
</div>
``` `getTemplateData` was technically part of the v3 style legacy widgets, but the code was so intermixed that you could still use certain legacy methods with the new components. That code has now been split out - is there still a need for it, or was it just surprising? I wouldn't recommend it, but you could do the following:

```jsx
import { getTemplateData } from './component';

$ var data = getTemplateData(state, input);

<div>
    Hello ${data.name}!
</div>
```  Currently, if you have a template with the following
```xml
<some-tag-that-does-not-exist/>
```

The following HTML will be output:
```xml
<some-tag-that-does-not-exist></some-tag-that-does-not-exist>
```

We should instead throw an Error if the tag is not a standard HTML tag or has not been defined as a Marko custom tag.  This will help catch typos as well as users who might accidentally write concise style tags at the root when they meant text (or tried to write JS).  If you are using webcomponents, you will be able to list those tags in a `marko.json` file.

The Error message will contain helpful info.  Something like 

```
Marko does not recognize the <di> tag.  Did you mean <div>?  
If you do want to output the <di> tag as HTML, you can whitelist 
it in your marko.json file. See https://markojs.com/docs/somepage 
for more info.
``` @jsumners see the comment from @mlrawlings above. The idea is that you would need to whitelist the custom elements by registering them in your project's `marko.json`:

_src/marko.json:_

```js
{
  "<my-custom-element>": { /* empty */ }
}
```

It's a tradeoff, but I am in favor of catching problems earlier at compile-time. I suppose we could come up with a way for declaring non-standard tags as being tags that should passthrough. For example:

```
<!my-passthrough-tag></!my-passthrough-tag>
<-my-passthrough-tag></-my-passthrough-tag>
<my-passthrough-tag custom-element></my-passthrough-tag>
```

I'm not saying that is a good idea, but I am just through that out there. Personally, I think registering the tag in `marko.json` is a reasonable tradeoff since you also get autocompletion for free and better error checking and reporting at compile-time. We do already throw errors for mismatched tags.  This may come up more in concise mode since the tag does not need to be repeated, but also in HTML when using the self-closing syntax.

I'm not sure this is a good idea, but we could have a global "off" switch for this behavior if there are users that are heavily using Custom Elements and don't wish to list them all.  If there was info about how to do that in the docs linked in the error I think that would eliminate any potential confusion. I think @jsumners has a point. It might only make sense to throw an error on a would-be concise tag.

My vote is for disabling concise mode by default (with exceptions for `class`, `import`, and `export`), and making it easy to enable it via a flag. That should solve most all confusion around syntax. I can definitely see how having many tags to whitelist would be annoying.  For example [a-frame](https://aframe.io/docs/0.4.0/introduction/) has 20+ custom tags implemented as web components.  But if we allowed you to whitelist patterns like `<a-*>` it wouldn't be too bad.

@Hesulan If we're doing this it needs to be the default as one of the big reasons for these kind of helpful error messages is to help beginners who likely won't realize there's some way to opt-in to warnings.

@mindeavor 

> My vote is for disabling concise mode by default

While we could put some modifier in the template (e.g. `@concise`), I don't like the idea that concise users would have to put boilerplate in every file. Putting that configuration in a separate file would break syntax highlight so that would not be an option.

Root level text would also be an issue if there was some global way to turn concise on or off because what would be parsed as text in HTML mode would be parsed as concise tags in concise mode. I'm not convinced this is the right idea, but we could also only have the warning for tags names without dashes in their name.  Custom Elements [require hyphens in their names](https://www.w3.org/TR/custom-elements/#valid-custom-element-name) so we wouldn't catch those tags with this rule. When building a complex project you will often need to rename a UI component. It would be _really_ nice if you could recompile all of your templates to figure out exactly which UI components broke as a result of the name change. I'm strongly in favor of throwing an error when the Marko detects an unrecognized tag as long as we get the error message **perfect** (the developer should know exactly what to do to register the tag and it should be super simple). > I don't like the idea that concise users would have to put boilerplate in every file

Sorry, I meant a global flag. Something like `require('marko/compiler').config({ conciseSyntax: true })` > Sorry, I meant a global flag. Something like require('marko/compiler').config({ conciseSyntax: true })

That won't work because the syntax highlighter would not have that context and do syntax highlighting independently. Can there not be two highlighter definitions? Sublime supports it, at least. Someone enabling `conciseSyntax: true` will know that they're opting into extra syntax, and that they'll want to change to the relevant highlighter if they want those niceties. @Hesulan I don't dislike concise mode per se; I only point out that supporting both concise and normal syntax *at the same time* is the root of all these problems. If concise were opt-in, all the pitfalls disappear (or at least be hidden behind a global flag). If concise were disabled, @ramses0's examples of surprises would no longer be surprising; they would do what you'd expect in any HTML document.

```html
this is
for
you
<h1>Test</h1>
var not_a_var = "this is just text, just like HTML"

for this is text as well!

${ "interpolated" + "value" }
$ console.log("this is JS code. Iffy, but acceptable")

I am plain text
<my-custom-element>
  No problems here
</my-custom-element>
``` @Hesulan As clarification, the idea for this originally stemmed from the discussion we (@mindeavor, @ramses0 and I) had on how to reduce any confusion around syntax, specifically concise syntax at the root, but I think it has enough merit to stand on its own.  

That it would throw an error for unintentional concise tags at the root is only one benefit. Related to this, Patrick and I are looking at creating a "standard" of sort that could be adopted by web component libraries to make their custom tags visible to tooling.  

Marko's autocomplete in Atom was originally forked from [`autocomplete-html`](https://github.com/atom/autocomplete-html) and it was extended to autocomplete not just HTML elements, but also Marko custom tags that were discovered through directory scanning and `marko.json` files.

We're thinking that we could submit a PR back to the original package that would support discovering an `html-elements.json` in project, but also at the root of any packages that the project depends on.  This process and the format of the json file would be similar to the Marko process and format, which has worked well for us.

This would allow a web component package to simply add this file (which could be generated) and autocomplete would be made available to the `autocomplete-html` package (which has over 200k downloads).  There's an immediate benefit to doing so, but future tools would also be able to make use of this information.

And of course so would Marko.  If we could get the web community to adopt this, it would mean you might never (or rather, rarely) have to add definitions/exceptions for third-party custom element tags on your own.

That's definitely a big "IF", but between reaching out to other developers, possibly making some PRs to popular libraries and the fact that there's benefit to the libraries and end users (it's not purely driven by a need of Marko) it could very well work. Great idea. I fully support that. @Hesulan Saving people from root-level text is the whole point of this thread, isn't it? It's only a problem because of automatic concise mode.

> This will help catch typos as well as users who might accidentally write concise style tags at the root when they meant text (or tried to write JS). @Hesulan I know the goal is to prevent typos, but the only reason this came up is because of concise mode. After all, **any** custom element tag is valid HTML.

In *principle* there should be no errors thrown, because an unknown tag is 100% valid in the browser. However, in *practice* I don't feel that strongly about it, and wouldn't mind if these errors made it in.

Actually, this just dawned on me â€“ custom element tags are only valid HTML [if they contain a dash within the name](https://w3c.github.io/webcomponents/spec/custom/#h-note2). Since JavaScript keywords nor identifiers can contain dashes, doesn't that mean there is only a reason to throw errors on unrecognized single-word tags? oops, I totally missed his comment on that :) I still think starting with throwing on all unrecognized tags is a sane default and the error message would point you to information on how to configure things:

### Configuring in `marko.json`

Throw on any unrecognized tag (default value):
```js
{
    "ignore-unrecognized-tags": false || []
}
```

Turn off errors/warnings:
```js
{
    "ignore-unrecognized-tags": true || ["*"]
}
```

Turn off errors for tags with dashes:
```js
{
    "ignore-unrecognized-tags": ["*-*"]
}
```

Turn off errors for certain tags from polymer:
```js
{
    "ignore-unrecognized-tags": ["paper-*", "iron-*", "google-*"]
}
```

### Defining individual tags in `html-elements.json`

We still need to figure out the details on this, so this probably wouldn't make it in right away.

Defining tags in `html-elements.json` will make it so Marko recognizes them and won't throw, but Marko's atom plugin will also pick them up and make them available for autocompletion when authoring your templates and components.

The goal would be for authors of the web components to generate this file as part of the web component package.

```js
{
    "<paper-button>": {
        "url":"https://elements.polymer-project.org/elements/paper-badge",
        "description":"<paper-badge> is a circular text badge that is displayed on the top right corner of an element, representing a status or a notification. It will badge the anchor element specified in the for attribute, or, if that doesn't exist, centered to the parent node containing it.",
        "@for": {
            "type":"String",
            "description":"The id of the element that the badge is anchored to. This element must be a sibling of the badge.",
        },
        "@icon": {
            "type":"String",
            "description":"An iron-icon ID. When given, the badge content will use an <iron-icon> element displaying the given icon ID rather than the label text. However, the label text will still be used for accessibility purposes.",
        },
        "@label": {
            "type":"String",
            "description":"The label displayed in the badge. The label is centered, and ideally should have very few characters.",
        },
        "@target": {
            "type":"String",
            "description":"Returns the target element that this badge is anchored to. It is either the element given by the for attribute, or the immediate parent of the badge.",
        }
    }
}
 For the record, I now believe this was the right choice. After upgrading to rc.13, marko immediately informed me about two invalid tags that I forgot to change during a rename! ðŸ˜„  @mindeavor I experienced the same thing. We had some tests that were incorrectly referring to unregistered tags. I'm not very impressed with the Github Wiki system, but we decided to put details on errors in the Wiki: https://github.com/marko-js/marko/wiki/Error%3A-Unrecognized-Tag

Please let us know if you see any issues!  The `class` tag currently supports creating a component when anonymous:
```jsx
class {
   constructor() {}
}
```
But creates a normal JS class when it has a name:
```jsx
class Foo {
   constructor() {}
}
```

We want to remove the second functionality.  It will _always_ create a component's class and you can optionally name that class.  With the new `$ <code>` syntax, we have a better way to add JS to a template and no longer need these tags.  We do want to make them available for the v3 -> v4 migration.  Should we just add a deprecation warning or split them out into a `marko-v3-compat` package? My preference would be to split them out so we're rid of them as v4 users, but it makes things a little tricky with sub packages that export tags because taglibs outside of Marko are not global. Related: #379 I think a migration package is a good idea. If one intends to move from v3 to v4, installing a package would be the least of those efforts.

What do you mean by sub packages that export tags? @mindeavor Say I am using a package with a taglib that is intended to be share across apps, let's call it `ui-components` and say one of the tags it exports is `<ui-carousel>`.  

`ui-components` was developed against v3 and as such uses legacy widgets.  The way things currently stand with v4, these components should still be able to be used with a v4 app.

The problem in moving deprecated tags out to a package is that if the `<ui-carousel>` template uses the `<var>` tag, it wouldn't be discovered because templates only look for tags in packages that their package (in this case `ui-components`) directly depends on.  It wouldn't look at the application's dependencies to find `marko-v3-compat`.
 This really isn't an issue as we could use the not-really-documented [`taglibLookup.registerTaglib`](https://github.com/marko-js/marko/blob/master/compiler/index.js#L229-L234) to make it globally available.  But if there is any runtime code (which there isn't in this case) using that API can cause discoverability problems. @Hesulan We actually are using the parser in legacy mode in v3 and have a number of warnings, including the [switch from `-` to `--`](https://github.com/marko-js/htmljs-parser/blob/master/Parser.js#L1359-L1361).  The goal is to allow users to upgrade without any changes if there are no deprecation warnings in v3. This might be a crazy idea, but what about a `marko-v4-stepping-stone` package that enables v4 syntax for v3 and adds deprecation warnings for all the old stuff from v3? Oh interesting, I didn't know `<var>` could use body text like that. Is that scope actually enforced? > The introduction of $ var flavor=input.someFunc() kill the template and you end up with PHP all over again.

Let's be honest here: We don't get PHP simply because of `<? ?>` tags. Unless you consider Ruby on Rails and ERB to be PHP as well!

I do find the `<var x=10>...</var>` feature interesting. To avoid potential confusion with JS, maybe you could rename it to something like `<scoped x=10>`, for those who want that feature. Fixed by https://github.com/marko-js/marko/commit/768d8085f7adc8811e027ec7a88cae682a703a9e (thank you @austinkelleher !) The scoped variables use case is interesting. I'm not opposed to introducing something to support that use case, but I am not convinced `<var>...</var>` was the best solution. @ramses0, what are your thoughts on the following? :

```html
<div>
    <scope>
        $ var name = 'Frank';
        $ function doSomething() {
        
        }

        <span>Hello ${name}!</span>
    </scope>
    <!-- `name` and `doSomething` will be undefined here -->
</div>
```  â€¦ing the Node.js require hook.

Also allows passing `extensions` or `extension` as options to `handleFileModified`.  Hey @steebchen, this is a duplicate of [Issue #363 - Auto hot reload for any extensions provided when installing the Node.js require hook](https://github.com/marko-js/marko/issues/363). Would you have any interest in working on this? At the moment, that issue is lower priority, but we do plan to have it resolved by the time of the final v4 release. @austinkelleher has completed the work for this and we'll publish a new release candidate soon  @jasonmacdonald can you please point to the code? `Symbol()` should not be used in browser code and all of our tests are running in a very older version of V8 that doesn't support `Symbol` so I would not expect `Symbol` to be used. Also, which JS module bundler are you using (Lasso, webpack, etc.)? There is a "widgets/util.js" and a "widgets/util-browser.js". We remap the former to the latter by putting a `browser` field in the `package.json` file: https://github.com/marko-js/marko/blob/44c38e74ad1a0c515ab96a05169f9c096678a3c2/widgets/package.json#L6

All JavaScript module bundlers (including Browserify, rollup, lasso, webpack, etc.) should respect the `browser` field. If you can provide a simple app to reproduce the problem with `browserify` that would be helpful. It could be a bug in browserify or it could be some strange combination of things. We should definitely investigate because browserify is supported.  > I suspect this is working as intended

It is, but with a little work, we can get the result you want.

> I also tried using input.renderBody(out, WidgetB_data), inside WidgetB. But, that still seems to use WidgetA data.

@jasonmacdonald You're on the right track! 

Before we get to the solution, I want to show you _why_ this is what is happening (and why it makes sense).  This is a simplified version of what gets compiled for Widget A:

```js

function render(data, out) {
    widget_b({ 
        data:2, 
        renderBody: function(out) {
            out.w('<div>'+data+'</div>');
        }
    }, out);
}
```

So, it's no surprise that `data` comes from Widget A in this case.  Or that passing an additional value to `renderBody` didn't work, because it only has an `out` parameter &mdash; but we can change that.

In the `marko-tag.json` file for Widget A (or the `marko.json` file under the Widget A definition), you can add a new key [`"var"` or `"vars"`](https://github.com/marko-js/marko/blob/eb2351212d32fb09959d1823f347ce6203070b7f/compiler/taglib-loader/loader-tag.js#L452-L481) (note it is not prefixed with `@` like an attributes). `var` takes a string as its value while `vars` takes an array, but in both cases the variable(s) are added as parameters to the `renderBody` function.

So with this in your `marko-tag.json` for Widget A,
```js
{
    "var": "data"
}
```

The new output would be:
```js
function render(data, out) {
    widget_b({ 
        data:2, 
        renderBody: function(out, data) {
            out.w('<div>'+data+'</div>');
        }
    }, out);
}
```

And now `input.renderBody(out, data)` would work as expected.

**But**, I would recommend that you don't just name the parameter `data` as the user of Widget A may still want access to Widget A's data and you're essentially preventing the user from accessing it by naming the parameter the same.

There's also a more flexible value that can be passed to `var` (or as an entry in the `vars` array): 
an object with the key `"name-from-attribute"`.  This allows the user to specify what they want the parameter to be called:

Widget A's `marko-tag.json`:

```js
{
    "var": { "name-from-attribute": "param" }
}
```

Usage:

```jsx
<widgetB data="2" param="nestedData">
   <!-- trying to declare this inner content as a template 
   to be used to render the contents of Widget B -->
   <div>${nestedData}</div>
</widgetB>
```

The new output would be:
```js
function render(data, out) {
    widget_b({ 
        data:2, 
        renderBody: function(out, nestedData) {
            out.w('<div>'+nestedData+'</div>');
        }
    }, out);
}
```

And you can call `input.renderBody(out, data)` and that second `data` parameter will be made available in the `renderBody` method as `nestedData` &mdash; which the user chose. I also want to point out that we add one more layer on top of this for the await tag.  The await tag is used like:

```html
<await(value from promise)>
    ${value}
</await>
```

We transform this to the following in the [await transformer](https://github.com/marko-js/marko/blob/master/taglibs/async/await-tag-transformer.js#L28-L29):

```jsx
<await _var="value" _dataProvider="promise">
    ${value}
</await>
```

The await tag also has `{"name-from-attribute":"_var"}` specified in the [`marko.json`](https://github.com/marko-js/marko/blob/master/taglibs/async/marko.json#L53-L55)

Which results in `value` (in this case) being made the second parameter to `input.renderBody`.  Then we just wait for the promise to resolve and [pass the result to `renderBody`](https://github.com/marko-js/marko/blob/master/taglibs/async/await-tag.js#L120). This should work:

```html
<div for(item in items)>
    <invoke data.renderBody(out, item)/>
</div>
```

Note, that in 3.0 if `<tileList>` stateful, `renderBody` won't be available the second time around, but this is fixed in 4.0 if you do:

```html
<div for(item in items)>
    <include(data.renderBody, item)/>
</div>
``` Marko 4 includes widgets, so you don't need `marko-widgets` anymore @jasonmacdonald Adding the `marko-tag.json` file as you did is the correct thing to do. We'll revisit the docs for v4 to make things more clear. Since we are completely reworking the documentation I'm going to go ahead and close this issue. In the meantime, please let us know if you have any specific questions...happy to help.  We no longer want to hijack the standard HTML `<style>` tag to avoid confusion and future problems. Instead, we will use the following:

```css
style {
    .foo {
        background-color: 'red';
    }
}
<div>Hello World</div>
```

Or, with a specific CSS preprocessor language:

```css
style.less {
    .foo {
        background-color: 'red';
    }
}
<div>Hello World</div>
```  We've decided to stop hijacking the script tag and use concise style tags that look like JS instead.

### Deprecate `<script>` with export

Old:

```html
<script>
   module.exports = {
      handleClick() {
         alert('hi!')
      }
   }
</script>

<button on-click('handleClick')>Click me!</button>
```

New:

```jsx
class {
   handleClick() {
      alert('hi!')
   }
}

<button on-click('handleClick')>Click me!</button>
```

### Deprecate `<script template-helpers>`

Old:

```html
<script template-helpers>
   function sum(a, b) {
      return a + b;
   }
</script>

<div>The sum of 1 + 2 is ${sum(1, 2)}</div>
```

New:
```jsx
static function sum(a, b) {
   return a + b;
}

<div>The sum of 1 + 2 is ${sum(1, 2)}</div>
```


### Moving to an external file

One concern you may have is that with the `<script>` with export approach, the only change required to move a component to an external `.js` file was copy and paste.  Admittedly, it's not _quite_ that simple, but it's still really easy.

This template:
```jsx
import sum from './helpers/sum';

class {
   handleClick(a, b) {
      console.log(sum(a, b))
   }
}

<button on-click('handleClick', 3, 4)>Click me!</button>
```

becomes these two files

_component.js_
```js
import sum from './helpers/sum';

export default class {
   handleClick(a, b) {
      console.log(sum(a, b))
   }
}
```
_index.marko_
```xml
<button on-click('handleClick', 3, 4)>Click me!</button>
```

So we copied over _and had to add an export statement_.  Still pretty simple. What does moving static functions over to `component.js` look like? @mlrawlings Can you update this issue to also mention:

```js
static {
  function myHelper() { ... }
  var foo = 'hello';
}
```

I wonder if it makes sense to recommend `static { ... }` because it makes it a little easier to move those functions how to a separate file if needed (only the block content needs to be copied out) @mindeavor, @philidem and I had an impromptu discussion based on concerns raised in the Gitter chat room. The following proposal seemed to be liked by everyone:

```js
static {
    function myHelper() {
         /* ... */ 
    }

    class ViewModel {
        constructor(data) {
            this.data = data;
        }

        get fullName() {
            return this.data.firstName + this.data.lastName;
        }
    }
}

component style lang="less" scoped {
    .foo {
        background-color: 'red';
    }
}

component class {
    onInput() { /* ... */ }
    handleButtonClick() { /* ... */ }
}
```

Reopening the issue for discussion. It's not too late to voice your approval or concerns. Although I find that syntax ok, my ideal syntax would still be something like this:

```html
<script marko>
import helper from 'library';

class Component {
    onInput() { /* ... */ }
    handleButtonClick() { /* ... */ }
}

function myHelper() {
     /* ... */ 
}

class ViewModel {
    constructor(data) { /* ... */ }
    get fullName() { /* ... */ }
}
</script>


<style lang="less" scoped>
.foo {
    background-color: 'red';
}
</style>

<div class="the-component">
    <h1>${ state.name }</h1>
</div>
``` I think it's good and unsurprising that marko transforms `<style>` tags. I wouldn't want my styles to be inlined every time I use the component :)

If we really want to stay away from `<script>`, then we can use a different name instead:

```html
<component>
import helper from 'library';

class {
    onInput() { /* ... */ }
    handleButtonClick() { /* ... */ }
}

function myHelper() {
     /* ... */ 
}

class ViewModel {
    constructor(data) { /* ... */ }
    get fullName() { /* ... */ }
}
</component>
```

My primary preference is to have a single tag for all my JS code if possible. > I think it's good and unsurprising that marko transforms <style> tags. I wouldn't want my styles to be inlined every time I use the component :)

@mindeavor I mostly agree (which is why this is the current behavior), but there is the concern that someone could be using Marko as a pure template language (without lasso, webpack, etc) &mdash; something we still want to support.  Suppose you had a template like the following that you wanted to include in the `<head>` of many pages:
```html
<title>${data.title ? data.title + ' | Marko' : 'Marko'}</title>
<link rel="icon" type="image/png" sizes="32x32" href="/public/favicon.png" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<style>
    body { background:#f00; }
</style>
```
It would probably be surprising if your `<style>` tag didn't show up in the output.


> I really like this proposal. Correct me if I'm wrong, but I'm assuming the HTML syntax would look like:
> ```xml
> <static {
>    function myHelper() { /* ... */ }
> } />
> <component class {
>     onInput() { /* ... */ }
> } />

@Hesulan Yes that would be the equivalent HTML syntax, but I don't think that's a good idea (and Patrick is talking about potentially making that invalid).

> Would <static> still accept body content like <script marko-init> did?

It does not with the current implementation, but that would be trivial to implement.  It would require updating the syntax highlighter though.

 I would like to point out that I prefer the HTML syntax, _but_ I think it makes sense to use the concise syntax for these JS-like tags and other tags that don't directly affect the output, while still using the HTML syntax for tags that are actually involved in rendering the final HTML output.

`<script>` and `<style>` not ending up in the output HTML doesn't fit with the default expectation and for someone learning how to write a component, they will look up the documentation and follow what it says.  I don't think there's some default expectation that putting something in a `<script>` allows you to create component methods that can be attached to elements - this idea is foreign to HTML and why we need something like Marko in the first place.

Regarding `component class` or `component style`, everything in the template is _for_ the component.  It is redundant to say `component`.

For someone who is new to Marko, I really find it difficult to believe that someone would look at the following and not understand what is happening.  And I don't see how wrapping this in a `<script>` tag would make it any less intimidating.

![image](https://cloud.githubusercontent.com/assets/1958812/22353057/8e1b2186-e3d3-11e6-8476-e74234ab757e.png) @mlrawlings I generally agree with what you're saying. `style {}` is fine, and so is `class` in your simple example. Using curly brackets to differentiate between html tags and output is a good idea too.

The problem appears when you want something more than just a `class`. Specifically:

- Where do I put imports?
- Where do I put helper functions?
- Where do I put static data?

`class` is not really a class, but a special tag that looks like JavaScript. The current answers are in the same vein: a special `import` tag, a special `function` tag, and a special `static` tag. Put this together with `var`, `for`, and probably others, and you've reached an uncanny valley of javascript-but-not-really-javascript syntax.

The reason I was ok with `component class {}` was that the word `component` immediately tells you something special is going on, to up your guard and not think you can write just any JavaScript code in this file.

Another proposal with these things in mind:

```jsx
script {
  import helper from 'library';

  class Component {
    onInput() { /* ... */ }
    handleButtonClick() { /* ... */ }
  }

  var languages = ['js', 'css', 'html']

  function myHelper() {
     /* ... */
  }

  class ViewModel {
    constructor(data) { /* ... */ }
    get fullName() { /* ... */ }
  }
}

style {
  .count {
    font-size: 3rem;
    padding: 0.5rem;
    width: 3rem;
  }
}

<button on-click('handleButtonClick') />
<select>
  <option for(lang in languages) value=lang>lang</option>
</select>
``` The "component class" is special and I believe it deserves to be moved up to the root. I think a block consisting of curly braces is a good indicator that the code is JS/CSS. Taking your example, I think the following reads really well:

![marko-syntax](https://cloud.githubusercontent.com/assets/978214/22354955/014cc216-e3e5-11e6-9b43-a97c41a33595.png)
 â˜ï¸ @patrick-steele-idem That does look nice.

## Other thoughts

> and not think you can write just any JavaScript code in this file.

@mindeavor I understand that concern and I could probably be convinced to dial back some of the JS tags introduced in v4, specifically `class` (for non-component classes) and `function` and probably `invoke`, maybe even `assign` and `var` &mdash; we could require them to be within a JS block where any JS is valid.

Beside the fact that I like the component's class definition at the top-level, I really think that within the `static` block (or `script` as you suggested - but I think [static](https://en.wikipedia.org/wiki/Static_variable) is the right term) that it should be _"Just JavaScriptâ„¢"_.  You shouldn't have a special `class Component` that gets picked up in some magical way - that kind of stuff should happen in Marko land.

Here's my current thoughts on the list of "JS" tags we should support and their rational:

### `static { ... }` to embed static javascript code
We need a way to have code that runs statically, that is once when the template is loaded and then is available every time the template is rendered.  This beats `<script marko-init>` because this is not included in the output - see previous messages for more detail.

### `{{ ... }}` to embed runtime javascript code (in the `render` method)
Currently we have `var`, `invoke`, and `assign` tags (and we added `function` and `class` in v4) but maybe we deprecate those? We also have scriptlets (`<% ... %>`), but sticking with our curly brace notation seems to make sense and using something that could be interpolated in both HTML and concise syntax. (This would actually be a language level thing, like scriptlets, not a tag).

### `class { ... }` to define a component's class
Defining the component's class is somewhat special, and I don't think we should start modifying what you're expecting to be pure JS.  Just by seeing `class`, it lets you know exactly what syntax is allowed inside the `{ ... }` because it's a 1:1 match with JS.  (This would be my argument against something like `component {}`).

### `style { ... }` to define a component's style
We need a way to write styles and don't want to hijack the `<style>` tag.

### `import` to pull in external helpers
For one, this is ES6 syntax, but we generate CommonJS `require` calls, so you wouldn't need any extra transpilation step.  I also really feel like imports should be at the top outside of a block, but maybe that's not valid?

### `export` to export data attached to the template
There are some legitimate cases where you might want to export some values from a template.  The template lives in a `marko_template` variable that gets generated, but that shouldn't be manipulated directly, the `export` tag will do that for you.  (Having this tag also is somewhat of an argument for `import` to make things balanced).

### `var`
Do we need var?  It already exists in v3 and we probably don't want to remove it at this point, right?  I agree that it's kinda nice to not have to wrap `var` in `{ ... }`, but the same could be argued for any JS statement, so where do we draw the line?


## What about...

@patrick-steele-idem, @mindeavor What are your thoughts on this example?

```jsx
import { CurrencyFormatter } from './formatters';

static {
    var format = new CurrencyFormatter('usd');
}

class {
    constructor(input) { ... }
    adjustPrice(index, amount) { ... }
}

{{ var products = state.products; }}

<table>
    <tr for(i, product in products)>
        {{ var name = product.name;
           var price = product.price; }}

        <td>${ name }</td>
        <td>${ format(price) }</td>
        <td on-click('adjustPrice', i, -1)>- $1.00</td>
        <td on-click('adjustPrice', i, +1)>+ $1.00</td>
    </tr>
</table>
``` @mlrawlings I think dialing back the JS tags is a great solution. Having a minimal number of them makes me a lot more comfortable explaining and promoting the idea to others.

I think I agree with all your points in tandem; your example suits well with me. The only confusion I foresee is people trying to `import` or `require` within `static`, but good error messages should be able to mitigate.

The special tag for runtime code makes a lot of sense when you compare it to the `static` tag; presenting them together makes them easy to explain.

If you don't mind a bit of bikeshedding... I think `%{}` would be a nicer than `{{}}`, since it parallels with `${}` :) > If you don't mind a bit of bikeshedding... I think `%{}` would be a nicer than `{{}}`, since it parallels with `${}` :)

Totally fine.  I have some more thoughts to share on the stylistic front.  And would like your opinion on some of these things.

One _small_ issue I have with `static { ... }` is that it kinda seems as if the JS is scoped to that block, when in reality it's available throughout the template and even to the `class`.

If you look at the OP, `static` also supports an "inline" mode where you can have a single statement without a block:

```js
static var foo = 123;
```

I'm curious what you think of this mode, but I like that it brings the statement up to the top level, but I still know that anything following the `static` keyword is just JS.

In any case, I wonder if we could have something that gives us a similar experience for the runtime JS.  I still want something that could be (safely) interpolated within HTML.  


```jsx
import { CurrencyFormatter } from './formatters';

static var format = new CurrencyFormatter('usd');

class {
    constructor(input) { ... }
    adjustPrice(index, amount) { ... }
}

% var products = state.products;

<table>
    <tr for(i, product in products)>
        % var name = product.name;
        % var price = product.price;
        <td>${ name }</td>
        <td>${ format(price) }</td>
        <td on-click('adjustPrice', i, -1)>- $1.00</td>
        <td on-click('adjustPrice', i, +1)>+ $1.00</td>
    </tr>
</table>
```

In this case we would also support `% { ... }` for multiple statement if thats what you wanted to do.

Okay, so I used `%` in the example just because, but @patrick-steele-idem kinda hates the `%` symbol and I don't know that I really like it either.

We also looked at the following options:

Looks nice, kinda like a REPL prompt, but could be confusing with `${}`:
```js
$ var foo = 123;

// this has a space, so it's different than ${}
$ {
    var bar = 456;
}
```

Probably safe, but two characters:
```js
$$ var foo = 123;

$$ {
    var bar = 456;
}
```

Also looks like a prompt, but ruins any hope of using markdown in a template:
```js
> var foo = 123;

> {
    var bar = 456;
}
```
Only breaks nested blockquotes in markdown:
```js
>> var foo = 123;

>> {
    var bar = 456;
}
```
For reference:
> This is a block quote
>> This is a nested block quote ðŸ˜¢ 
> > This nested block quote has a space though and would still work (`> >`) `static` one-liners seem good; the keyword conveys something different than plain JS is happening.

To be honest, I'm ok with drawing the line at `var` for JS tags, so long as documentation uses the `<var />` form to avoid any confusion. If someone opts for writing concise syntax, they'll know that they're only stripping away some angled bracket characters, as opposed to writing plain JS.

With that said, I don't know if `%{}` (or `$${}` or whichever symbol chosen) needs a concise version. The current `${}` certainly does not, and the only difference between it and the former is that the former outputs nothing. @mindeavor Really appreciate your input on this. I do think we will end up in a good place and I think we all are in favor of reducing the number of special tags.

> With that said, I don't know if `%{}` (or `$${}` or whichever symbol chosen) needs a concise version.

Agreed. Whichever syntax we finally settle on, it will be the same for both concise and HTML.

We internally polled some devs at eBay and the following seems to be the most popular:

![marko-component](https://cloud.githubusercontent.com/assets/978214/22394142/f3d08f78-e4d4-11e6-88ed-f889c5929bf8.png)
 Huh... I think I like it :) Would a backslash `\$` allow you to insert literal dollar sign characters? > Would a backslash \$ allow you to insert literal dollar sign characters?

Yup, that's what I am thinking and that is what we allow if you need to escape placeholders.

If you are good with it, then I propose we move forward with `$ <code_block>` and `$${ <code_block> }`.

If anyone has any last minute objections please let us know!

/cc @austinkelleher @philidem @mlrawlings @Hesulan @Eldar-X  @mikewoo200 this past week I looked into what it would take to support linting of embedded JS inside Marko. We can do it in Atom very easily, but I think the main goal will be to ensure that the JavaScript is valid. In the future, when Marko supports source maps we can apply linting to the entire compiled output to catch problems such as undefined variables and unused variables (this cannot be done on individual embedded JS fragments). With source maps we can map the linter warning back to the location in the original template file. Here's another potential issue to discuss: Would any `$` enter "js mode", or does the `$` need to be the first non-whitespace character of its line?

Example:

```html
<div>
  $ console.log('x')
  Price range is $ for this venue.
  Price range is $$$ for that venue.
</div>
``` That's the plan - first non whitespace character, followed by a space

On Sun, Jan 29, 2017, 12:39 PM Gilbert <notifications@github.com> wrote:

> Here's another potential issue to discuss: Would any $ enter "js mode",
> or does the $ need to be the first non-whitespace character of its line?
>
> â€”
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/marko-js/marko/issues/547#issuecomment-275944198>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AB3jnOk12Z1yIi79QgScEITg3Wpipjyfks5rXPkVgaJpZM4LtAQG>
> .
>
 Both need to be at the start of the line or prefixed only by whitespace:

- Single line: `/^\s[$]\s/` 
- Multiline `/^\s[$]{2}\{/` @mikewoo200 

> But for style linting (spaces, indents) in the template, what can we do?

We could definitely come up with a way to enforce code style for embedded JS and Marko code as well. We'll probably need to explore that more after the v4 release. Copying thoughts from an internal discussion where we've decided `$ <code>` and `$ { <code> }` is the direction we're going to take.

----

So despite my initial reservations on `$ { ... }` I think this is the right approach.

It would only be allowed at the beginning of a line (`/\s*\$ \{/`):

```
$ var price = 5;
$ {
  var id = 0;
  function nextId() {
    return id++;
  }
}
```

Ambiguity has been the reasoning against this, but looking at it again, even without syntax highlighting, I think it is pretty clear (and it definitely looks nicer), and @scttdavs  has pointed out that with proper syntax highlighting it would be made _very_  clear (red `$` vs blue `$`, for example).

<img width="420" alt="screen shot 2017-01-30 at 9 35 49 pm" src="https://cloud.githubusercontent.com/assets/978214/22452575/4afce74e-e735-11e6-9b2f-af28c42a984b.png">

Part of the reason this makes sense is that we're already planning to allow `{}`, `()`, `[]`, etc. to allow the expression to continue to the next line:

```js
$ var foo = {
   bar: 1
}
```

But JS already supports a [block statement](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block), so we would actually have to special case `$ ` to _disallow_ `$ { ... }`.

And there is an issue with `$${ ... }` that could potentially end up with a confusing situation like this:

```html
<span.price>
    $${price.toFixed(2)}
</span>
```

So in order to get what you want in this case (`<span class="price">$5.00</span>`), you would need to escape the first `$`:
```html
<span.price>
    \$${price.toFixed(2)}
</span>
```

But if you actually wanted to output the multiline sequence (perhaps you're explaining how to use it), you need to escape the _second_ `$`:
```html
<code>
    $\${
        var price = 5;
    }
</code>
```

With the single `$`, escaping is straightforward:
```html
<code>
    \$ {
        var price = 5;
    }
</code>
```

It's a fairly subtle difference, but I do think that it's only going to be an issue in one direction:
```jsx
// I could see someone doing this
${
    var foo = 123;
    var bar = 456;
}

// I don't see this happening
<div>
    Hello my name is $ {name}.
</div>
```

In the above case, we're typically going to see multiple JS statements because we also allow the single line version:
```js
$ var foo = 123;
```

So, if you accidentally forget the space for a multiline JS block, it will compile to:

```js
out.w(escapeXML(var foo = 123;var bar = 456;));
```

That's going to be pretty easy to detect. @Hesulan What I meant is that the single line version, because we allow continuing, is also the multiline version.  So If we wanted to have a _different_ symbol (like `$$`) and didn't want the single `$` to allow multiline, it would take more work.

Your logic is pretty much how I implemented it: https://github.com/marko-js/htmljs-parser/commit/21958233e1c4c442e8e338dc14c537b813ffab2a#diff-61eec70114a46820c77ce5879a128729R658

I'm going to close this as the work has been completed.  Thank you everyone for your feedback and help in reaching this point! @jsumners I also dislike classes in general. However, the *concept* of a class fits perfectly with what a marko component is, and the class syntax is now officially part of the JS language. In marko's case, a class is the best tool for the job.

As I understand it, the only "floating JS blocks" marko 4 will support are `class` and `import`. I think this is reasonable, especially since they are so common (though I would push back against adding any more), and even then they are not really JS blocks, but tags. Real JS code blocks need to be written using either the `static` tag or the `$` runtime tag. @Hesulan `static` supports a block:

```
static {
  function myHelper() {
  }

  var foo = '123';
}
``` > On a related note, could <static> fall back to using body-text if the { /* ... */ } attribute is omitted? I think a lot of users would prefer that, and it would certainly ease the transition from <script marko-init>.

Hmm... do we only do it for `static`, or everything?  This might be a bad path to go down...

```html
<!-- Not quite JS -->
<class>
    constructor() {
        this.state = { count:0 };
    }
    increment() {
        state.count++;
    }
</class>

<!-- Highjacking the style tag again :( -->
<style>
    button {
        background:#fff;
    }
</style>

<!-- the "concise" equivalent is technically a language construct, not a tag -->
<$ var foo = 123/>
<$>
    var foo = 123;
    var bar = 456;
</$>

<!-- I don't think I have any issues with these -->
<static var foo = 123/>
<static>
    var foo = 123;
    var bar = 456;
</static>

<!-- I *would* take issue with this -->
<static function sum(a, b) {
    return a+b;
}/>

<!-- These are fine -->
<import foo from "file"/>
<export var num = 2/>
```
  Thanks for reporting the problem. I'm investigating now. Resolved. New version published with fix: `marko@3.14.1`

This bug had already been fixed in Marko v4.

Thanks again for reporting the problem.  You can immediately switch into HTML parsing mode by using an HTML delimited block:

```html
--
This is all parsed
as <strong>HTML<strong>!
--
```

Does that solve your issue? @patrick-steele-idem The parser allows disabling concise mode.  Do we (or can we) disable it for `.marko.html` and `.marko.xml` files? We could disable concise mode for `.marko.html`, but I'm not sure we want to go there because it breaks syntax highlighting (unless we refactor our syntax highlighting bundles). Sorry for the lack of docs on that @rgagnon24. We are completely reworking the docs for the Marko v4 release and things will be a lot more clear. Let us know if you have any questions, but closing this issue for now.   I pushed a fix. I will be publishing a new version very shortly. Thanks for reporting the problem @Eldar-X.  New version published: `marko@4.0.0-rc.6`

Please let us know if you see any other problems. Thanks!  @Eldar-X Would this cover your use-case? https://github.com/marko-js/marko/blob/bce3836d099854f3aa9f2f48fffb470cd7a78399/docs/04-core-tags.md#export

I'm going to implement this in a bit unless you have some feedback.  Can you explain a bit more? I'm not clear on what you are suggesting.  The `marko-magic` module enables game changing auto-detection for asset dependencies. I had thought that marko would absorb it all for v4, but it looks like `marko-magic` is still necessary for some lasso-related things.

For example, in the [ui-components-playground](https://github.com/marko-js-samples/ui-components-playground) I still see:

- `<lasso-head/>` and `<lasso-body/>` in the layout
- a `browser.json` for declaring a `style.less` dependency
- a `browser.json` for the home page, declaring the `<app>` and other browser dependencies.

Since marko is already at `v4.0.0-rc3`, I need to ask: are you all planning to release without the asset detection features? So technically, these changes will be outside of Marko and be a part of the Lasso taglib.  While Marko is at an RC, there are still some things to update in supporting packages and this is one of those things.

However, I would like to have some discussion around the Marko magic approach and if we should make all of it mainstream.  

Particularly, I have concerns about automatically injecting the Lasso head and body tags automatically.  I wonder if it's a bit weird that, since we use `head` as an injection point, that if there is no head tag you won't get any styles.
Likewise for body. I think requiring `<lasso-head/>` and `<lasso-body/>` is acceptable. It's the json files that I'm mostly concerned about; I want to write as few of those as possible :)  ## Version **2.0.0** of [fs-extra](https://github.com/jprichardson/node-fs-extra) just got published.

<table>
  <tr>
    <th align=left>
      Dependency
    </td>
    <td>
      fs-extra
    </td>
  </tr>
  <tr>
    <th align=left>
      Current Version
    </td>
    <td>
      1.0.0
    </td>
  </tr>
  <tr>
    <th align=left>
      Type
    </td>
    <td>
      devDependency
    </td>
  </tr>
</table>

The version **2.0.0** is **not covered** by your **current version range**.

Without accepting this pull request your project will work just like it did before. There might be a bunch of new features, fixes and perf improvements that the maintainers worked on for you though.

I recommend you look into these changes and try to get onto the latest version of fs-extra.
Given that you have a decent test suite, a passing build is a strong indicator that you can take advantage of these changes by merging the proposed change into your project. Otherwise this branch is a great starting point for you to work on the update.


---


<details>
<summary>Commits</summary>
<p>The new version differs by 40 commits .</p>
<ul>
<li><a href="https://urls.greenkeeper.io/jprichardson/node-fs-extra/commit/fcfa595ca022011ce0f61d337598a4573fe8eb3c"><code>fcfa595</code></a> <code>2.0.0</code></li>
<li><a href="https://urls.greenkeeper.io/jprichardson/node-fs-extra/commit/23f2b1d51d48a433a5ce8547190e84e2a36d12c0"><code>23f2b1d</code></a> <code>CHANGELOG: add issues</code></li>
<li><a href="https://urls.greenkeeper.io/jprichardson/node-fs-extra/commit/b34da2762a4865b025cac06d02d6a2f1f1027b65"><code>b34da27</code></a> <code>(Closes #344) LICENSE: update year</code></li>
<li><a href="https://urls.greenkeeper.io/jprichardson/node-fs-extra/commit/c010fff71f9d9d0b5789c44e5bad37e3e8fc1bd9"><code>c010fff</code></a> <code>Merge pull request #343 from mawni/readme-add-klawsync</code></li>
<li><a href="https://urls.greenkeeper.io/jprichardson/node-fs-extra/commit/90bd756785fc54aa10a9078e559076cf522fa622"><code>90bd756</code></a> <code>Readme: add klaw-sync link</code></li>
<li><a href="https://urls.greenkeeper.io/jprichardson/node-fs-extra/commit/ab644a48cbd3e51182d750f7d66609b5bfd5fe0d"><code>ab644a4</code></a> <code>Merge pull request #340 from jprichardson/docs</code></li>
<li><a href="https://urls.greenkeeper.io/jprichardson/node-fs-extra/commit/f6ee61e1bcad75bb12123c1a8a9b1e1f1c15cc15"><code>f6ee61e</code></a> <code>Add note about walk()'s removal, recommend jprichardson/node-klaw</code></li>
<li><a href="https://urls.greenkeeper.io/jprichardson/node-fs-extra/commit/3dc711f46776814df16a8b8bfb1528ac9d241e70"><code>3dc711f</code></a> <code>Add fs-promise as fs-extra-promise alternative</code></li>
<li><a href="https://urls.greenkeeper.io/jprichardson/node-fs-extra/commit/383a26985cab5b8a184cea9fa776d2fa6da8a5fe"><code>383a269</code></a> <code>Move API docs to seperate docs/ folder</code></li>
<li><a href="https://urls.greenkeeper.io/jprichardson/node-fs-extra/commit/a2904644f2ef2f77b1981788c899e2f6e06c140a"><code>a290464</code></a> <code>Remove Node v0.12 support message from README</code></li>
<li><a href="https://urls.greenkeeper.io/jprichardson/node-fs-extra/commit/fa408833fbdcd5bc5f4e8cf0af1207832a1a5c79"><code>fa40883</code></a> <code>Move klaw to devDeps</code></li>
<li><a href="https://urls.greenkeeper.io/jprichardson/node-fs-extra/commit/de1d48336fd801114ba9e2e609230565f669d6ef"><code>de1d483</code></a> <code>Merge pull request #339 from jprichardson/rm-walk</code></li>
<li><a href="https://urls.greenkeeper.io/jprichardson/node-fs-extra/commit/1f83cb0cdfc468b4a6b447a1b49b4492391ffb36"><code>1f83cb0</code></a> <code>Remove walk() &amp; walkSync()</code></li>
<li><a href="https://urls.greenkeeper.io/jprichardson/node-fs-extra/commit/cc1aaa949e221fab2976b563e4aa91b200ade7b5"><code>cc1aaa9</code></a> <code>Merge pull request #335 from jprichardson/move-tests</code></li>
<li><a href="https://urls.greenkeeper.io/jprichardson/node-fs-extra/commit/80ec80d394e348a33077042d83a98ccd071878e1"><code>80ec80d</code></a> <code>Merge pull request #334 from jprichardson/move-cleanup</code></li>
</ul>
<p>There are 40 commits in total. See the <a href="https://urls.greenkeeper.io/jprichardson/node-fs-extra/compare/2da7defbd3d3f140f4d2f4cfa7e89b11846a827a...fcfa595ca022011ce0f61d337598a4573fe8eb3c">full diff</a>.</p>
</details>

<details>
<summary>Not sure how things should work exactly?</summary>

There is a collection of [frequently asked questions](https://greenkeeper.io/faq.html) and of course you may always [ask my humans](https://github.com/greenkeeperio/greenkeeper/issues/new).
</details>


---


Your [Greenkeeper](https://greenkeeper.io) Bot :palm_tree:
   Also changes `--vdom -v` to `--vdom -V`. Thanks for working on this!  ## Version **2.0.0** of [md5-hex](https://github.com/sindresorhus/md5-hex) just got published.

<table>
  <tr>
    <th align=left>
      Dependency
    </td>
    <td>
      md5-hex
    </td>
  </tr>
  <tr>
    <th align=left>
      Current Version
    </td>
    <td>
      1.3.0
    </td>
  </tr>
  <tr>
    <th align=left>
      Type
    </td>
    <td>
      devDependency
    </td>
  </tr>
</table>

The version **2.0.0** is **not covered** by your **current version range**.

Without accepting this pull request your project will work just like it did before. There might be a bunch of new features, fixes and perf improvements that the maintainers worked on for you though.

I recommend you look into these changes and try to get onto the latest version of md5-hex.
Given that you have a decent test suite, a passing build is a strong indicator that you can take advantage of these changes by merging the proposed change into your project. Otherwise this branch is a great starting point for you to work on the update.


---


<details>
<summary>Commits</summary>
<p>The new version differs by 2 commits .</p>
<ul>
<li><a href="https://urls.greenkeeper.io/sindresorhus/md5-hex/commit/5d8f3a88b2de9bfdf7e4f07f253dd88c102814df"><code>5d8f3a8</code></a> <code>2.0.0</code></li>
<li><a href="https://urls.greenkeeper.io/sindresorhus/md5-hex/commit/386c34ebe3477dc2eaf6cfd111119fded06c2e22"><code>386c34e</code></a> <code>ES2015ify and require Node.js 4</code></li>
</ul>
<p>See the <a href="https://urls.greenkeeper.io/sindresorhus/md5-hex/compare/273d9c659a29e4cd53512f526282afd5ac1c1413...5d8f3a88b2de9bfdf7e4f07f253dd88c102814df">full diff</a>.</p>
</details>

<details>
<summary>Not sure how things should work exactly?</summary>

There is a collection of [frequently asked questions](https://greenkeeper.io/faq.html) and of course you may always [ask my humans](https://github.com/greenkeeperio/greenkeeper/issues/new).
</details>


---


Your [Greenkeeper](https://greenkeeper.io) Bot :palm_tree:
  ## New Feature

Perhaps related to #125

### Description

Allow the signature `setState(key, value)` to accept an Event object as its value (`e`), causing `setState` to extract `e.target.value`.

### Context

Forcing two-way data binding to be explicit is good in general, but for very basic cases it's a chore. For example, take the following component:

```html
<script>
module.exports = {
  onInput(attrs) {
    this.state = { password: '' }
  },
  setPassword(e) {
    this.state.password = e.target.value
  }
}
</script>

<div class="password-picker">
  <p>Your password is ${state.password.length} characters long</p>
  <input type="password" value=state.password on-input('setPassword') />
</div>
```

For this very basic task, I had to write a `setPassword` handler to capture user input into state. If I had more than input, I would have to either write more handlers, or write a generic handler that differentiates by some kind of key. In any case, it's something I have to write and think about every time I need to handle user input.

However, if `setState` were to accept an event as its value, it would allow me to write the following instead:

```html
<script>
module.exports = {
  onInput(attrs) {
    this.state = { password: '' }
  }
}
</script>

<div class="password-picker">
  <p>Your password is ${state.password.length} characters long</p>
  <input type="password" value=state.password on-input('setState', 'password') />
</div>
```

This avoids the need to write any handler at all, and remains very readable for what it does. For anything that needs something more complicated â€“ such as scrubbing out invalid characters for a phone number input  â€“ it's not hard to fall back to the "write your own handler" way of doing it.

### Open Questions

- Is this too "magical" for marko's taste?
- Would this work for all types of input?

### Is this something you're interested in working on?

Yes
 Just throwing this out there is a possible alternative:

```html
<script>
    module.exports = {
        handleNameChanged(value) {
            this.state.name = value.toUpperCase();

            if (this.state.name.length > 10) {
                this.state.invalidName = true;
            }
        }
    }
</script>

<input value:bind('name')/>
<input value:bind('name', 'handleNameChanged')>

<!-- OR: -->

<input bind('name')/>
<input bind('name', 'handleNameChanged')>
```

In theory, this could be implemented in user land (via a combination of a custom compile-time transform and a small runtime) and if it proves to be valuable then we could pull it into the core marko. Thoughts? For reference:

- React
  - [Forms/Controlled Components](https://facebook.github.io/react/docs/forms.html)
  - [Uncontrolled Components](https://facebook.github.io/react/docs/uncontrolled-components.html)
- Vue
  - [Form input Bindings](https://vuejs.org/v2/guide/forms.html)

 Coming from Mithril.js, I always liked teaching two-way data binding in this manner:

```js
var myData = 'initial'

var myComponent = {
  view: function () {
    return m('input[type=text]', {
      value: myData
      oninput: (e) => { myData = e.currentTarget.value }
    })
  }
}
```

The value in this is it uses plain DOM concepts (`value`, `oninput`, `e`), and the data flow is very clear (on the input DOM event, assign `myData` to the event target's current value).

In other words, there's very little magic to it. So far, Marko has also avoided data-flow magic for the most part, and is thus very close to plain HTML and JS; it's precisely why I was able to pick it up so easily.

HTML-based frameworks (including angular & vue) do not have the benefit of being plain JS, which is why those other frameworks add easy, "proprietary" ways to bind data â€“ they want to take the chore out of it. However, I don't think it's the best approach to take for these reasons:

- **The data flow is not clear.** When you see something like `v-model="x"` or `ng-model="y"`, it's not immediately clear what that's doing or where it's coming from. Contrast that with everything else Marko does, where all data originates from `state` (nice and explicit)

- **It takes away from other core features.** Marko already has `on-click('myMethod')`, a solid data-flow feature connecting JS and the view. It'd be nice if that were the primary way for JS to interact with your view, instead of having an additional syntax that splits common use cases.

I think changing `setState` (via the proposal) or adding a method of some sort (`on-click('set','x')` ?) will strike a good balance between lack of boilerplate and lack of magic.
 Here are some notes from various discussions:

```html
<script>
    module.exports = {
        onInput() {
            this.state.orders = [
                { id: '0', title: 'Foo', shipped: true },
                { id: '1', title: 'Bar', shipped: false },
            ]            
        },

        handleShippedChanged() {
            this.state['orders.${i}.shipped'] = foo;
        }
    }
</script>

<ul>
    <li for(i, order in orders)>
        <input type='checkbox' checked:bind('orders.${i}.shipped', 'handleShippedChanged')> Shipped?
    </li>
</ul>
```

```html
<script>
    module.exports = {
        onInput() {
            this.state.orders = [
                { id: '0', title: 'Foo', shipped: true },
                { id: '1', title: 'Bar', shipped: false },
            ]            
        }
        toggleShipped(i, event, input) {
            // Add support for a settting a property chain while maintaining
            // immutability
            this.setState('orders', i, 'shipped', input.checked);

            // Or, the long way
            var orders = this.state.orders = [].concat(this.state.orders);
            var order = orders[i] = Object.assign({}, orders[i]); // Create a clone of the order
            order.shipped = input.checked;
        }
    }
</script>

<ul>
    <li for(i, order in orders)>
        <input type='checkbox' checked=order.shipped on-change('setState', i)> Shipped?
    </li>
</ul>
``` I'm starting to really like the enhanced `setState` argument. I think ``on-change('setState', `orders.${i}.shipped`)`` is readable, intuitive, and convenient, assuming it does the "immutable update" that we discussed.

Another reason I think it's important to keep the data bind directions separate is to allow for different kinds of data binding without creating more esoteric language constructs. For example, if you have an `<input type="text" value:bind('name') />`, is the (DOM -> JS) data binding on the `oninput` or `onchange` event? Both are valid events; depending on your use case, you may want one over the other. @mindeavor Our thinking was `:bind` would look for _both_ `change` and `input` events.  But you're right, I've often had an `change` event handler on a text input to reformat a phone number **after** input, so it wasn't changing as the user typed.

The issue with  ``on-change('setState', `orders.${i}.shipped`)`` is that in this case, we want the value of `checked`, not `value`.   

We could add a new method: ``on-change('setStateFromState', `orders.${i}.shipped`, `checked`)`` @mlrawlings did you mean `setStateFromEvent`? Ideally `setState` would be smart about events. If I'm not mistaken, `checked` is an anomaly; all other input types store their user input within `elem.value`.

The [non-mutually exclusive] options I see are:

- Upgrade setState's logic to be something like `newValue = e.target.checked || e.target.value` when given an Event object value
- Add a `setStateFromEvent` for the generic case (maybe one would want to set state on a `data-`  attribute instead of input value) Checking in again â€“ that first bullet point would be very handy in small components and demos :)  Thanks for letting us know. New version published with those directories removed: `v4.0.0-rc.1`

The new version also includes https://github.com/marko-js/marko/issues/525  The signature for `onInput` should be `onInput(input, out)`. It is currently `onInput(input)`. /cc @ianvonholt  Closed via https://github.com/marko-js/marko/commit/2c04a4d916fb427e42ee923b3b66509bb26ac4f5

Note: When using [`setProps`](https://github.com/marko-js/marko/blob/master/widgets/Widget.js#L325-L346), `out` is not passed (nor was it passed to `getInitialState` in v3).  @mlrawlings I'm not seeing an issue related to `setProps`. Calling `setProps(newProps)` will cause the component to be rerendered with `newProps` as the input and a new `out` will be created to do the rerender and those things will be passed to `onInput()`. Am I misinterpreting your note?  Related: [#492 - Deprecate w-body in favor of include](https://github.com/marko-js/marko/issues/492) (there is a collapsed "Other Options Considered" section that has relevant details)

#418 is out-of-date after further discussions were made as part of #492. The feedback that we received was that no one really liked the usage of `<include()>` with an empty argument since it didn't make it clear what exactly was being included.  We settled on dropping `w-body`, and dropping the temporarily introduced `body-slot` attribute/tag, in favor of a universal `<include(target)/>` tag. We still need to capture this correctly in the final release notes and documentation, but for now [#492 - Deprecate w-body in favor of include](https://github.com/marko-js/marko/issues/492) contains the latest docs for this feature.

Hope that clarifies. While we want to avoid changes at this point, nothing is set in stone so if you have any thoughts or concerns then please share. I'm closing the issue but please feel free to add more comments here.  We've already deviated from JavaScript (in ways that I make more sense) and we would not want to introduce any breaking changes at this point. FYI, You can do the following if you want both the key/index and value when looping over the elements/properties of an `Array`/`Object`:

```xml
<for(colorIndex,color in ['red', 'green', 'blue'])>
</for>
```

That syntax works with objects too:

```xml
<for(colorName,colorHex in { red: '#f00', green: '#0f0', blue: '#00f' })>
</for>
```

If you still have suggestions/concerns, please let us know and happy to discuss some more, but closing issue for now. Thanks.  ## Bug Report

### Context

```html
<script>
module.exports = {
  onInput(attrs) {
    var content = 'Hello there!'
    this.state = {
      text1: `Text 1: ${content}`,
      text2: 'Text 2: ' + content
    }
  }
}
</script>

<div>
  <h3>${state.text1}</h3>
  <h3>${state.text2}</h3>
</div>
```

### Expected Behavior

```html
<h3>Text 1: Hello there!</h3>
<h3>Text 2: Hello there!</h3>
```

### Actual Behavior

```html
<h3>Text 1: </h3>
<h3>Text 2: Hello there!</h3>
```

### Your Environment

* Version used: v4.0.0-beta.12
 @mindeavor I would expect that to work since Marko shouldn't do anything special with the code inside the `<script>` block. Would you be interested in working on this? I don't think I would have the time to dig into the codebase in the near future, no :( @mindeavor No worries!

I think you are right, @Hesulan. Would you be interested in working on a fix?  Michael and I had a quick discussion and our conclusion was that we should update `htmljs-parser` to ignore Marko placeholders inside template literal strings in `parsed-text` mode.   Thanks!  Thanks for opening the issue. This has been fixed. Please see issue #509. If you upgrade to the latest beta you should be good to go   I think more changes are required. The `handleRootNodes` transform that is being used to do the implicit binding to all root elements is also internally adding the `w-bind` attribute to make everything work: https://github.com/marko-js/marko/blob/6aaf8679a88e53cef644582e51edca94517a51e4/widgets/taglib/TransformHelper/handleRootNodes.js#L202 Looks good. Thank you for working on that!  Thank you, @smulder, for finding these bugs! I'll be publishing a fix soon. New version published with fix: `marko@4.0.0-beta.9`  New version published with fix: `marko@4.0.0-beta.10`  New version published with fix: `marko@4.0.0-beta.11`

Thanks for reporting the problem!  Thanks for the fix! New version published with fix: `marko@4.0.0-beta.10`

Thanks, again, for the PR.  We should definitely consider improving the error message or handling this better, but the reason you are seeing the error is that you should typically never need to render a `<!doctype html>` node in the browser since it is only meant to be something interpreted by the browser when loading an HTML page rendered on the server. Just curious, what is your use case for needing to render an entire page (along with the `<!doctype>` tag) in the browser?

One option is to just not generate any code for the `<!doctype>` node when compiled for the browser. Another option is to show a friendly compiler error. Thoughts? Concerns? Alternative ideas?  Fixed! New version published: `marko@4.0.0-beta.8`    Hey @albertogasparin, it was necessary to deprecate a single hyphen in v3 because we have to remove support for single hyphens in v4 to support the improvement of allowing spaces in attribute values when the attribute value is a complex expression. If you are not able to get rid of the deprecation warning then that is a bug. I am investigating now and will publish a new version of `htmljs-parser` if necessary. I will update soon. Thanks for reporting the problem! Sorry for the bad deprecation warning when using a double hyphen. The problem has been fixed with `htmljs-parser@2.2.2`. I know the deprecation warnings can be a lot of noise, but we didn't see a good way to avoid this change as part of Marko v4. I hope it is not too much of a pain to update your code now, but we do plan on providing a migration tool a little later that would automatically fix the issue, but it is not ready yet.  Introduces colon alias destructuring support for `import`:

```javascript
<import { test: testAlias } from './test' } />
```  I agree that this should be supported. But you can use `as` for aliases:

```javascript
import { client as twilio } from '../../lib/twilio'
``` I wrote up a fix to support colon destructuring as it's supported in standard JS destructuring. I actually didn't know that colon destructuring is not supported in `import` destructuring, which I find quite surprising and inconsistent. I rejected my PR. This issue should be closed. /cc @patrick-steele-idem  We want to strictly follow the ES6 import syntax. Closing this issue. Thanks.  â€¦attrs attribute. Fixed merge conflicts /cc @patrick-steele-idem @mlrawlings   This has been resolved.  The easiest way right now to achieve what you want is to register your own custom tag that is configured to have a body of "static-text". 

For example, you could register your own `<static-text>` tag:

_src/components/static-text/marko-tag.json:_

```json
{
  "body": "static-text"
}
```

```xml
<static-text>
        Content
         More Content
        ${data.myVar}
</static-text>
```

Does that work for you?

Related: https://github.com/marko-js/marko/issues/343 NOTE: If you want to recognize placeholders (i.e. `${...}`) then you should use `parsed-text` instead of `static-text` Which version of `marko` are you using? I'll add a test case @eikaramba Sorry for the delayed response. I added a test case for what I was trying to explain. Please take a look at the following: https://github.com/marko-js/marko/tree/master/test/autotests/render/static-text-tag

The implementation for the `<static-text>` tag can be found in the following directory: https://github.com/marko-js/marko/tree/master/test/autotests/render/static-text-tag/components/static-text

NOTE: The test case was added to Marko v4 (master branch), but it should work the same in Marko v3

Does that clarify and does that solution work for you?  Notes:

- Use [minprops](https://github.com/mlrawlings/minprops) to reduce code size
- Use [envify](https://github.com/hughsk/envify) reduce code size  Fixes #477  Nice. Thank you!  Just some initial thoughts:

- It's already possible to embed a React component in a Marko component but we can definitely provide things to make this more seamless
- I'm definitely open to ideas on improving operability (in addition to the reasons you mentioned, but also because I would like to make it easier for teams to try or transition to Marko)
- If you use React when rendering on the server then you will have no choice but to rerender everything in the browser since React requires this (Marko does not require this)
- Seamless interoperability can become complex when trying to support both server-side and client-side rendering, but I think it is completely doable
- It seems reasonable to create a generic adapter component for embedding a React component in Marko (and vice versa)
- It's possible to translate a rendered Marko VDOM tree to a React VDOM tree with a performance hit (via tree traversal of the Marko VDOM output)
- Alternatively, a Marko component can be rendered and mounted during the `componentDidUpdate()` lifecycle method (client-side only)
- Usage ideas:

_Marko component with embedded React component (using Marko v4):_

```xml
import MyReactComponent from "./MyReactComponent";

<div>
  <react-component(MyReactComponent) name="Frank" age=30/>
</div>
```

React component with embedded Marko component:_

```jsx
import myMarkoComponent from "./my-marko-component";

// ...

return (<div>
  <Marko component={myMarkoComponent} name="Frank" age={30}/>
</div>)
```

I would to hear some more thoughts from others, but I just wanted to share my initial thoughts. Thanks for opening the issue. @mindeavor there have been some conversations about providing an adapter to support registering Marko UI components as Web Component custom elements, but we have not done anything further. After the v4 release we should do more exploration to see what is possible and capture it in our ROADMAP. Right now, the Marko v4 release is our top priority and we hope to get that finalized soon :)  I'm not opposed to this, but it is probably sufficient to add some extra metadata to the compiled template as a JavaScript comment such that it would be minified out in production. In addition, for Marko v4 we introduced support for inspectable metadata that gets added templates compiled for the server.

> (in addition, add `--version | -v` support to `markoc` command)

Can you open up a separate Github issue for that enhancement (this makes tracking progress easier)? Would you be interested in working on either of these enhancements? As we discussed a few days ago @patrick-steele-idem, we should also consider adding a note to the compiled output stating that it is compiled and to not edit it. e.g.

```js
// Compiled using marko@4.0.0-rc.5 - DO NOT EDIT
```

or

```js
// Compiled using markoc@4.0.0-rc.5 - DO NOT EDIT
```  This has been resolved.   Thank you! ðŸ‘   Good catch. Thank you! I'll work on adding a test    Thanks @johnjv!  ```xml
validate-input (input) => {
    var assert = require('assert');
    
    assert(input.label || input.renderBody, '"label" or "renderBody" is required');
}

<button class=['app-button'] onClick("handleClick")>
    <span include(data.label || data.renderBody)/>
</button>
```

For production builds, the `validate-input` tag should have no impact on the compiled template.

We should also consider enabling render-time input validation based `marko-tag.json` for simple validations.  This is an open-ended issue.

While code-coverage is not a perfect metric, it would be awesome to see our coverage reach 90% on this next release.  We use an autotests format for our tests, which make it really easy to add new tests, just copy a directory and modify it for the new test.  If you're interested in adding some tests and have questions, feel free to ask them here.

### Some high-impact places that could use better coverage:
- [ ] [runtime/dom.js](https://coveralls.io/builds/9270231/source?filename=runtime%2Fdom.js)
- [ ] preserved attributes when re-rendering in [widgets/Widget.js](https://coveralls.io/builds/9270231/source?filename=widgets%2FWidget.js#L578)
- [ ] rendering then using dom insertion methods when using the legacy widget api (`require('marko/widgets').defineComponent`) in [widgets/Widget.js](https://coveralls.io/builds/9270231/source?filename=widgets%2FWidget.js#L728)
- [ ] passing an object to `setState` in [widgets/Widget.js](https://coveralls.io/builds/9270231/source?filename=widgets%2FWidget.js#L340)
- [ ] a number of `builder` methods have no, or incomplete coverage in [compiler/Builder.js](https://coveralls.io/builds/9270231/source?filename=compiler%2FBuilder.js).  These tests could go in [test/autotests/codegen](https://github.com/marko-js/marko/tree/master/test/autotests/codegen).
- [ ] parsing a function expression in [compiler/util/parseJavaScript.js](https://coveralls.io/builds/9270231/source?filename=compiler%2Futil%2FparseJavaScript.js#L97)
- [ ] [compiler/taglib-loader/loader-taglib.js](https://coveralls.io/builds/9270231/source?filename=compiler%2Ftaglib-loader%2Floader-taglib.js)
-  [ ] error assertions (in many, _many_ locations)

### How to find other files that could use additional coverage:
- visit https://coveralls.io/github/marko-js/marko?branch=master
- scroll down to "Source Files on Master"
- sort by lines missed

![image](https://cloud.githubusercontent.com/assets/1958812/21169139/6cfff21a-c16e-11e6-864d-b20279e30354.png)  @yomed if you need a temporary workaround:

```js
<${String(data.type === 'primary' ? 'div' : 'span')}> 
``` I have confirmed this is still an issue in v4 as well. Re-opening as the fix needs to be back-ported to v3. `marko@3.13.1` has been published with this fix.  yeah as already stated, this is marko trying to avoid naming collisions. The import parser could use: 
https://github.com/marko-js/marko/blob/master/compiler/util/safeVarName.js
to generate a safe name, but it would still fail for:
```html
<import { asset } from 'asset' />
```
 A quick fix would be to just add a namespace to that function as well, so in the above case it would output:
```javascript
var m__asset = require("asset"),
    asset = m__asset.asset;
```
The namespace could be anything pretty unique, but you could technically still encounter the bug if you know it or miraculously name your var the same. Otherwise, I don't see an obvious solution other than digging into marko's naming collision logic.
@patrick-steele-idem @mlrawlings Thoughts? @tinovyatkin For now, we want Marko templates to compile to ES5-compatible code since compiled templates can either be loaded in the browser or on the server. On the server, the compiler requires Node.js v4+, but the runtime is ES5-compatible and works with IE9+ and all other modern browsers.

As it stands now, `import`/`export` is not finalized and that syntax is not natively supported by Node.js and browsers. We don't want to require the use of Babel for any of the core tags that we document as part of Marko so that means that Marko need to transpile `import`/`export` to something that is widely supported and since we are going to transpile we might as well make the code ES5-compatible for improved compatibility.

Regarding transpiling the following:

```xml
<import { asset } from '../../../shared/marko/asset' />
```

Something similar to the following would work:

```javascript
var asset_module = require("../../../shared/marko/asset"),
var asset = asset_module.asset,
```

A single `_` in the variable name should be sufficient for avoiding collisions since developers typically don't use `_` in variable names. However, we can make the variable as long or as short as we want since it won't matter after the code is minified.

At the moment, I am currently swamped. If anyone wants to work on fixing the compiled code for the `<import>` tag please let me know. Thanks in advance. I _think_ this is as simple appending `_module` or something [here](https://github.com/marko-js/marko/blob/8f4c884fba1d7460690de989d292968c613130cc/taglibs/core/util/parseImport.js#L33).

Along with the change I'd like to see an additional test making sure something like the following produces a sane output:

```html
<import { asset as test } from "./test1/asset"/>
<import { asset } from "./test2/asset"/>
``` > It just occurred to me that `require()` is expected to cache loaded modules:
> ```
> var foo = require('./foo').foo;
> var bar = require('./foo').bar;
> ```
> Not very pretty, but perhaps more readable, and definitely more collision-proof. Thoughts?

Other then still being slightly slower to execute, that code wouldn't minify as well so I would still like to see each module only be required once.  ```html
<custom-component emit('event1', 'event2')/>
```

would be equivalent to:

```html
<custom-component on-event1('emit', 'event1') on-event2('emit', 'event2')/>
```  @SebastiaandenBoer I think your issue is separate. I think you are forgetting to set the `Content-Type` header to ensure that the browser knows how to interpret the response from the server. You should be doing something similar to the following in your page controller:

```javascript
res.set({ 'content-type': 'text/html; charset=utf-8' });
```  Given:

_src/components/my-component/index.marko:_

```xml
<script>
module.exports = {
    handleButtonClick() {
    }
}
</script>

<style lang="less">
.foo {
}
</style>

<div class="foo">
</div>
```

The `<style>` code should be pulled out into `src/components/my-component/index.marko.less` at compile-time. The `lang` attribute should be used to determine the file extension and the default `lang` should be `css`.

The generated file should then be imported in the compiled template so that it will automatically be picked up by the bundler:

```
require('./index.marko.less');

// ...
```
  **Old:**

`./layouts/main/template.marko`:

```html
<!doctype>
<html>
<body>
    <layout-placeholder name="body">
        Default body content
    </layout-placeholder>
</body>
</html>
```

`page.marko`:

```html
<layout-use('./layouts/main/template.marko')>
    <layout-put into="body">
        Hello World
    </layout-put>
</layout-use>
```

**New:**

`./layouts/main/template.marko`:

```html
<!doctype>
<html>
<body>
    <if(data.body)>
        <include(data.body)/>
    </if>
    <else>
        Default body content
    </else>
</body>
</html>
```

`page.marko`:

```html
<include('./layouts/main/template.marko')>
    <@body>
        Hello World
    </@body>
</include>
```  <!--- Provide a general summary of your changes in the Title above -->

## Description
<!--- Describe your changes in detail -->
Deprecate `renderSync(data)` and `render(data, callback)` in their current forms.  Use `renderToString` instead as v4 will return a `RenderResult` instead of a string.


## Motivation and Context
With this notice in place, there shouldn't be any breaking changes when moving from v3 to v4 that don't already warn you in the current version.


## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [x] My code follows the code style of this project.
- [x] I have updated/added documentation affected by my changes.
- [x] I have read the **CONTRIBUTING** document.
- [x] No new tests, changes already covered by existing tests.
- [x] All new and existing tests passed.

  ## Description

adds import tag, works like: 
```html
<import mod, { b as bar } from "./bar" />
```

## Motivation and Context
Fixes https://github.com/marko-js/marko/issues/404

## Checklist:
- [x] My code follows the code style of this project.
- [x] I have updated/added documentation affected by my changes.
- [x] I have read the **CONTRIBUTING** document.
- [x] I have added tests to cover my changes.
- [x] All new and existing tests passed.
 Thanks for working on this @scttdavs!  I did a fairly quick code review and one issue I see is that we want to avoid parenthesis when using the `<import>` tag so that the user can write out the import in the ES6 way. Currently, it appears you are parsing the import statement from within the argument on the `<import>` tag:

```xml
<import({bar as b} from './bar') />
```

I would like to only support the following:

```xml
<import {bar as b} from './bar' />
```

The only code change that should be required is that you will need to loop over the attributes and join the attribute names by a space (e.g., `attributeNames.join(' ')`) to build the import string that is then parsed. For example, here is the AST after parsing `<import {bar as b} from './bar' />`:

```json
{
    "type": "TemplateRoot",
    "body": [
        {
            "type": "HtmlElement",
            "tagName": "import",
            "attributes": [
                {
                    "type": "HtmlAttribute",
                    "name": "{bar as b}"
                },
                {
                    "type": "HtmlAttribute",
                    "name": "from"
                },
                {
                    "type": "HtmlAttribute",
                    "name": "'./bar'"
                }
            ],
            "body": []
        }
    ]
}
``` 

Do you have any concerns about dropping the parens?

Also, I wouldn't bother mentioning `<script marko-init>` in the docs since that is deprecated.
 On a related note, we might have issues when we update the parser to handle commas so we probably need to provide a helper to get the raw string inside the open tag. Sure that looks like a simple change. I'll have time tonight to work on it
some more
On Sun, Nov 27, 2016 at 10:46 AM Patrick Steele-Idem <
notifications@github.com> wrote:

> On a related note, we might have issues when we update the parser to
> handle commas so we probably need to provide a helper to get the raw string
> inside the open tag.
>
> â€”
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/marko-js/marko/pull/448#issuecomment-263129223>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ADdocOk7n8rV_MlkhTxiTmDSWHACIHDlks5rCaXLgaJpZM4K9JxM>
> .
>
 @patrick-steele-idem What do you think of the above implementation in the last commit? Instead of joining the attribute names for now (sounds like comma parsing will conflict with that later), I add the tag string to the node, so `el.tagString ` returns `"<import foo from './foo' />"`, and we get all we need from that. Is there a better way of doing this? Still feeling my around :) `tagString` would have the problem that it would be different for concise vs non-concise unless we always stripped off the the starting `<` and the ending `/>` or `>`. If we strip off those characters then I am okay with using `tagString`. @patrick-steele-idem any more comments, or is this ready to merge? It's ready to merge :) I am just finishing up the changes to support nested `<@foo>` tags and I will merge your changes very soon. We will then publish a new beta release. Thank you, again! great, thx! Also made one slight more optimization, couldn't help myself ðŸ¤“   Thanks! ðŸ‘   Thank you for bringing this up. I think it makes sense to normalize the HTML string before doing the comparison to avoid issues related to having/not-having a new line character at the end:

```javascript
str = str.replace(/\s$/, '')
```

Or, possibly a little more conservative:

```javascript
str = str.replace(/(\r\n|\n)$/, '')
```

Thoughts? Agreed. Would you be interested in making this change to normalize the string before comparison?  Thanks for the PR @JeroenVdb, but I think it it is better to discuss how nested content is handled within the [Includes](https://github.com/marko-js/marko/blob/master/docs/language-guide.md#includes) section of the docs. I want to avoid adding a new section to the docs so I am closing this PR. Thank you though!  Thanks! ðŸ‘   ## Description

Making the render api consistent.

### Sync Render
Rendering synchronously now returns a RenderResult:
```js
var result = template.renderSync({});
result.appendTo(document.body);
result.getWidgets();
// etc.
```

**Differences:**
In v3, we return a string.  In order to make this a more painless switch, I will introduce a `renderToString` method in v3 and prompt users to switch to using that if they need that string output.

### Async Render

Calling `.render()` still returns an out:
```js
var out = template.render({});
out.on('finished', function(out) {
    
});
```

**Differences:**
In v3, there is no value passed to the `finished` event.  No breaking change here.


### Callback 

```js
template.render({}, function(err, result, out) {

});
```

**Differences:**
In v3, the callback is passed the `html` string instead of a RenderResult.  The third parameter, `out` is only passed for legacy reasons.  You can also access it from `result.out`.

### Promise

See also #439, #442.

```js
template.render({}).then(result => result.appendTo(document.body));
```

**Differences:**
In v3, then was not available.  No breaking change here.

### Widgets

`defineRenderer` and `makeRenderable`/`renderable` now include both `render` and `renderSync` that function similarly to above.  I plan to add `renderSync` to `marko-widgets@6` and warn users that are using the api like:

```js
widget.render({}).appendTo(document.body);
```

to switch to 

```js
widget.renderSync({}).appendTo(document.body);
```
or
```js
widget.render({}, function(err, result) {
    result.appendTo(document.body);
});
```

## Checklist:
- [x] My code follows the code style of this project.
- [ ] I have updated/added documentation affected by my changes.
- [x] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes.
- [x] All new and existing tests passed.


@patrick-steele-idem I'd like some eyes on this and the plan described above before merging.
@Hesulan How does the Promise implementation look?
  Hmm... I see the issue...  Unfortunately, our goal with #389 was to pass the stream as the value so you could do something like:
```js
template.render().then(out => out.appendTo(document.body));
``` @patrick-steele-idem Maybe we need to consider having a `RenderResult` that is separate from the stream.

```js
var result = template.renderSync();
var out = template.render();

out.on('finish', function(result) {});
out.then(function(result) {});

template.render({}, function(err, result) {});
```

Pretty much everything in the `outMixins` except `then`/`catch` would be a method of the `RenderResult`.


`result.out` could point to the original stream if necessary. > Maybe we need to consider having a `RenderResult` that is separate from the stream.

That's probably the right thing to do.

What are your thoughts on adding a `try...catch` to wrap the rendering of the template so that we can emit an `error` event in the `catch` clause? We would only do this if an `out` is not provided to the `template.render()` method.  Add support for an `extends` property to `marko.json`:
```js
{
    "<foo>": {
        "transformer":"./foo.transformer.js"
    },
    "extends": [ 
        "bar", // extend a node_module (gets marko.json from the root of the package)
        "./other/marko.json" // extend another marko.json file
    ]
}
```

This would allow a package to "export" tags from packages it depends on.

Open to other names: `includes`, `imports`, etc. The use case I'm thinking of is allowing one package to make the tags of another package available without the main application needing to depend directly on both.  

As an example, take your `let` and `const` package.  Maybe I want to create an `es6-taglib` package that would expose those tags as well as some others.
 In theory this sounds good, but it becomes a problem if the other `marko.json` being extended belongs to a nested package dependency and not a `peerDependency`. Nested dependencies may get installed into a `node_modules/` directory of the package with the parent `marko.json` which can cause problems since the `marko` compiler needs to generate `require()` calls to those nested dependencies. If a tag is purely a compile-time tag then it is not an issue, but it would be a problem for runtime custom tags that need to be imported into compiled templates.

I'm not sure there is a strong enough need for this at the moment, but we can discuss some more. Looks like [`taglibImports`](https://github.com/marko-js/marko/blob/master/compiler/taglib-loader/loader-taglib.js#L200-L248) with a small tweak will already do this.  Here are some replies:

> The promise resolution procedure must only access the `.then` property once.

Why do you say that?

> If attempting to retrieve the `.then` property throws an error, then the error must be caught and the resulting promise must be rejected with the error as the reason. (It currently isn't being caught.)

I don't see a need for this since accessing the `.then` property should throw an error if it is a `Promise`.

> The `.catch(onRejected)` method is neither defined nor required by the specification

`catch` is part of the specification: http://www.ecma-international.org/ecma-262/6.0/#sec-promise.prototype.catch

While we could fall back to `.then(null, onRejected)` in the case of no `.catch()`/`.fail()` method, but I'm not seeing a need for that.

> Should Marko actually be trying to handle Promise resolution directly, or would it be better to rely on a native/polyfilled `Promise` implementation?

Marko should rely exclusively on the native `Promise` implementation and that is what is happening now on `master`. 

> The `<await>` tag, however, needs to be usable in pre-ES5 environments, which leaves either a built-in polyfill or just more compliant handling code as the only options.

In the case of the `<await>` tag, Marko is never actually creating a `Promise` (it is just continuing the `Promise` chain of an existing `Promise`). In an ES5 environment you would need to use a native `Promise` polyfill or use a third-party library (`bluebird`, `q, etc.) to create the `Promise` instance.

> However, I've also noticed one other issue: The `<await>` tag currently accepts either a value, a Promise, or a node-style function (last argument is an error-first callback).

The `<await>` tag accepts a `Promise`, a Node.js-style callback function or a "resolved" object. I'm not seeing a problem with this approach.

---

Marko has some logic to handle old-style `Promise` objects, but for the most part we are assuming that a `ES6`-style `Promise` is being provided: file:///Users/psteeleidem/Library/Application%20Support/Dash/DocSets/JavaScript/JavaScript.docset/Contents/Resources/Documents/developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Promise.html

I'm not seeing a need to change anything related to the comments above. We still need to decide if we want to wrap the `render(data)` call with a `try...catch` to reject the promise. Currently, we don't have a single `try...catch` block in `marko` for performance reasons (functions with `try...catch` are not optimized by V8) @Hesulan these are great points, but I think we should focus on the `Promise` specification as defined as part of EcmaScript and implemented by Node.js and browsers (and polyfills). I would welcome as many tests as possible to make sure the Marko implementation holds up to all edge cases for the native `Promise` implementation, a popular `Promise` polyfill and maybe `q` and `bluebird`. For example, we need to make sure we have a test case for a synchronous error when rendering a template and using `.then()`/`.catch()`. Does that seem reasonable?  @cheft, Marko v4 will be IE9+, so I would plan for that, but I believe we're currently IE8+ on v3.

I'm going to close this, but feel free to ask if you have more questions.
  When an error occurs within an `<await>` tag, the rest of the page continues rendering and we log a n error message to the console, but there is no indication in the browser that an error occurred.  When using something like `browser-refresh`, developers aren't constantly having to look at the console, so it might be nice to give a big red error indication in `NODE_ENV=development` mode. I agree. The default implementation should show inline error messages for `<await>` tags that fail in development. If the user provided an `<await-error>` then that should always be used.

On a somewhat related note, we probably want to start making use of `process..env.NODE_ENV` to show more friendly error messages in development mode without bloating runtime code for production. We should then update lasso to transform `process.env.FOO` references to include the actual value of the environment variable when doing a non-development build. This would allow code to be minified out. While we could use [envify](https://github.com/hughsk/envify) as a module transform, we would also want to run that transform on non-JavaScript modules (i.e. vanilla JS) as part of an output transform.  The point of the layout taglib is to be able to include another template (`<layout-use>`) and insert content (`<layout-put>`) at various insertion points (`<layout-placeholder>`).  I'd like to make this more generic and concise.

@patrick-steele-idem has already done work on making `<include>` work to replace `w-body` (#418) and I think we can take this one step further to replace the need for layout-specific tags.

**Old:**
`./layouts/main/template.marko`:
```html
<!doctype>
<html>
<body>
    <layout-placeholder name="body"/>
</body>
</html>
```
`page.marko`:
```html
<layout-use('./layouts/main/template.marko')>
    <layout-put into="body">
        Hello World
    </layout-put>
</layout-use>
```

**New:**
`./layouts/main/template.marko`:
```html
<!doctype>
<html>
<body>
    <include(data.body)/>
</body>
</html>
```
`page.marko`:
```html
<include('./layouts/main/template.marko')>
    <@body>
        Hello World
    </body>
</include>
```

### `@` tags

As seen above, I'm also proposing the ability to prefix a tag with the `@` symbol to indicate that it should be passed as an attribute. I chose `@` because we already use it to indicate attributes in `marko.json` and it looks nice.

These are like [nested tags](http://markojs.com/docs/marko/custom-taglibs/#nested-tags) but more concise and don't require defining attributes in `marko-tag.json`.

Only putting the `@` at the front will require a change to the parser to support, but I think it would be worthwhile:
```html
<@body>
    Hello World
</body>
```
vs
```html
<@body>
    Hello World
</@body>
```

These `@` tags would work for *any* tag, so we could use layout concepts easily for custom tags as well:

**New:**
`./components/layout/index.marko`:
```html
<!doctype>
<html>
<body>
    <include(data.body)/>
</body>
</html>
```
`page.marko`:
```html
<layout>
    <@body>
        Hello World
    </body>
</layout>
```

### Passing values to `@` tags?

Perhaps we could also allow passing an argument to the `@` tag, indicating the name of a data variable:

```html
<my-component>
    <@body(foo)>
        Hello ${foo}!
    </body>
</my-component>
```

would compile to:
```
my-component({
    body: function(foo, out) {
        out.w('Hello '+escapeXML(foo)+'!');
    }
});
```
and could be called within `my-component` like this:
```html
<include(data.body, 'World')/>
```

 Thoughts?
/cc @philidem @austinkelleher @charlieduong94 @Hesulan 
 The other question this raises is should we deprecate [nested tags](http://markojs.com/docs/marko/custom-taglibs/#nested-tags) in favor of `@` tags?

**Old:**

``` html
<await(foo from data.fooPromise)>
    <await:error>
        Something bad happened
    </await:error>
    ${foo}
</await>
```

**New:**

``` html
<await(foo from data.fooPromise)>
    <@error>
        Something bad happened
    </error>
    ${foo}
</await>
```
 I just realized that `<await:error>` isn't a thing.  It's `<await-error>` which gets transformed into an attribute at transform time... haha ðŸ˜ .  But I'm thinking we could still use `<@error>` in this case.

@Hesulan My thinking on the `<@tags>` is that they would need to be the immediate children of the target parent, so there wouldn't be any ambiguity.  
 I suppose another question is how to handle multiple instances of a tag.  Currently, with nested tags, you define in the `marko-tag.json` whether a nested tag can have multiple instances.  If it can, it's always passed as an array.  

Without defining that upfront I think we're left with passing it as a single value if there's only one `<@tag>` and as an array if there are multiple.  React does this with its children prop and I don't really like it.  They ended up providing a collection of [helpers](https://facebook.github.io/react/docs/react-api.html#react.children) because it's hard to work with.

You _could_ do something like the following to ensure a value is an array before looping over it:

``` html
<var tabs=[].concat(data.tab)/>
<ul>
    <li for(tab in tabs)>${tab.name}</li>
</ul>
<div class="tab-content" for(tab in tabs)>
    <include(tab)/>
</div>
```

Or maybe you **have** to define an entry for nested tags if you want multiple: `"@tabs <tab>[]"`.  Otherwise the compiler throws an error.
 I like this suggestion and here are some thoughts:

-----

I think it should be `<@foo>...</@foo>` (with the `@` repeated in the ending tag)

-----

Attributes should be allowed on `<@>` tags:

```xml
<@placeholder tag="div">Loading...</@placeholder>
```

-----

`<@bar>` should be shorthand for `<foo:bar>`. The only challenge is that the `<@bar>` would just need to be matched with the first ancestor custom tag:

The following are equivalent:

__Old:__

```xml
<app-tabs>
    <app-tabs:tab title="Home">Content for Home</app-tabs:tab>
    <app-tabs:tab title="Profile">Content for Profile</app-tabs:tab>
    <app-tabs:tab title="Messages">Content for Messages</app-tabs:tab>
</app-tabs>
```

__New:__

```xml
<app-tabs>
    <@tab title="Home">Content for Home</@tab>
    <@tab title="Profile">Content for Profile</@tab>
    <@tab title="Messages">Content for Messages</@tab>
</app-tabs>
```

-----

Nested tags currently compile down to an object with each attribute resulting in a property and a `renderBody(out)` function if the nested tag has body content. The nested tags get discovered at render time by rendering the body and the nested tags register themselves with the parent tag when they get rendered but they otherwise produce no output at that time. This allows nested tags to be repeated, have conditional logic, etc.:

```
<app-tabs>
    <for(person in family)>
        <@tab title=person.name>
            Hello ${person.name}! You are ${person.age} year(s) old.
        </@tab>
    </for>
</app-tabs>
```

However, we can optimize this by handling nested tags that are direct children of a parent tag:

```xml
<app-hello name="Frank">
  <@message>Have a good day!</@message>
</app-hello>
```

__Old compiled output:__

```javascript
app_hello_tag({
      name: "Frank"
  }, out, 0, function renderBody(out, app_hello_tag0) {
    app_hello_message_tag({
        renderBody: function renderBody(out) {
          out.w("Have a good day!");
        }
    }, out, app_hello_tag0);
  });
```

__New compiled output:__

```javascript
app_hello_tag({
        name: "Frank",
        message: {
            renderBody: function renderBody(out) {
                out.w("Have a good day!");
            }
        }
    }, out);
```

We could even optimize for a single `if()` condition surrounding the nested tag:

```xml
<app-hello name="Frank">
  <@message if(someCondition)>Have a good day!</@message>
</app-hello>
```

```javascript
app_hello_tag({
        name: "Frank",
        message: someCondition && {
            renderBody: function renderBody(out) {
                out.w("Have a good day!");
            }
        }
    }, out);
```

-----

__tldr; Introduce`<@tab>` as shorthand for `<tabs:tab>`__  I think a test for this should live in `test/autotests/api`. An example is: `test/autotests/api/require-render-to-stream`.
 Also, the API has changed in v4, and I don't think this is an issue anymore, but I think this change should be back ported to v3.
 I saw it's against the v3 branch. Nice. LGTM /cc @mlrawlings 
 Actually I have a small suggestion after reviewing the code in v4. What do you think about changing the implementation to be more uniform with the v4 implementation?

https://github.com/marko-js/marko/blob/master/runtime/stream.js#L40
 I like it.  Thanks @jsumners and @austinkelleher!
 @jsumners Just published `marko@3.12.1`
  ## Description
Deprecate w-on* attributes for handling widget events. Added support for registering event handlers with on*().

## Motivation and Context
This is part of the Marko v4 roadmap.

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [x] My code follows the code style of this project.
- [x] I have updated/added documentation affected by my changes.
- [x] I have read the **CONTRIBUTING** document.
- [x] I have added tests to cover my changes.
- [x] All new and existing tests passed. Thanks!
   I'm not sure what's up with Coveralls. It's running twice.
    Here are my thoughts:

Marko should not be in the business of transpiling JavaScript. If a developer wants to use ES6 functionality, then the code should pass through unmodified. On the server, you wouldn't want to transpile the code since later versions of Node.js have great ES6 support.

There is one exception and that is ES6-style imports:

``` xml
//html syntax:
<import foo from "./foo"/>

// concise syntax:
import foo from "./foo"
```

ES6-style imports are not currently enabled by default in any browser and are not supported in Node.js. However, we like the syntax and semantics of ES6-style imports so we want to support it.

Specifically related to the `let` and `const` tags, I want those to pass through as-is as there ES6 keywords. No transpiling is required on the server and no transpiling is required for modern browsers. If the user wants to support older browsers then they would need to enable babel to run on `.marko.js` files to produce ES5-compatible code.

Could integrate babel? Maybe, but I don't think we should since the JS module bundler will typically be doing transpiling anyway.
    Thank you @Hesulan! For completeness, I think it is great that you worked on this. The tests are failing because we have some tests for the "taglib lookup" that will fail if you add new core tags. You simply need to update the following two files to include your new core tags (i.e. `const` and `let`):
- https://github.com/marko-js/marko/blob/master/test/autotests/taglib-lookup/forEachTag/expected.json
- https://github.com/marko-js/marko/blob/master/test/autotests/taglib-lookup/getTagsSorted/expected.json

(you just need to copy the text from `actual.json` over to `expected.json`)

Please do add tests when you get a chance. Copying and modifying the following test is sufficient for now: https://github.com/marko-js/marko/tree/master/test/autotests/render/var
 I don't really like the idea that `var`, `let`, and `const` are treated the same by the compiler. I think if we introduce these new tags, they need to function differently. For example this is okay with `var`:

``` html
<!-- This is okay! -->
<var nameUpper=data.greetingName.toUpperCase() nameLower=data.greetingName.toLowerCase()>
    Hello ${nameUpper}!
    Hello ${nameLower}!
    <var nameUpper=data.greetingName.toLowerCase()  nameLower=data.greetingName.toUpperCase()>
        Hello ${nameUpper}!
        Hello ${nameLower}!
    </var>
</var>
```

But it should throw a compile time error using `let`:

``` html
<let nameUpper=data.greetingName.toUpperCase() nameLower=data.greetingName.toLowerCase()>
    Hello ${nameUpper}!
    Hello ${nameLower}!
    <!-- Compiler throws an error! -->
    <let nameUpper=data.greetingName.toLowerCase()  nameLower=data.greetingName.toUpperCase()>
        Hello ${nameUpper}!
        Hello ${nameLower}!
    </let>
</let>
```

`const` should also be treated like like a `const` in JavaScript, so if we declare `<const>` and try to use the `<assign>` tag below it, the compiler would throw an error:

``` html
<const nameUpper=data.greetingName.toUpperCase() nameLower=data.greetingName.toLowerCase()>
    Hello ${nameUpper}!
    Hello ${nameLower}!
    <!-- Compiler throws an error! -->
    <assign nameUpper=data.greetingName.toLowerCase()/>
</const>
```

What do you think @patrick-steele-idem / @mlrawlings / @philidem ?
 @austinkelleher, `let` and `const` would compile to code that uses `let` and `const`. 

Also, just wanted to point out that `let` is beneficial in the following contrived situation:

```
<let foo='Frank'/>

<if(someCondition)>
    <let foo=123/>
    <!-- do something with foo -->
</if>
<else>
    <let foo=456/>
    <!-- do something with foo -->
</else>

<div>
  Hello ${foo}! <!-- Outputs "Hello Frank!" -->
</div>
```

Within the body of custom tags, `var` happens to be scoped correctly since marko automatically wraps the body of custom tags in a `renderBody(out)` function.
 @mlrawlings Can you please review this PR and decide on next steps? Thanks.
 I'm torn on what to do here.  These are language level features, so I don't think they belong in an external package.  If we're going to support this, I don't want to handle transpiling.  I'd either be in favor of letting it pass through unchanged (node 6+), or if we want to support 4/5 prepend `'use strict';` to the template.

On the other hand, I'm not sure we really need them.  The only real benefits are they introduce a temporal dead zone and `const` can't be redefined.

And taking Patricks example from above, we already have a way to create a TDZ of sorts:

``` html
<var foo='Frank'/>

<if(data.someCondition)>
    <var foo=123>
        <!-- do something with foo -->
    </var>
</if>
<else>
    <var foo=456>
        <!-- do something with foo -->
    </var>
</else>

<div>
  Hello ${data.foo}! <!-- Outputs "Hello Frank!" -->
</div>
```

The `es6-taglib` taglib idea is interesting, but I don't think it's necessary.  We will always be able to write something that is es5 compatible for core taglibs.  It's only these places where we're trying to emulate the javascript language.

Also, userland tags might require es6, and we don't have control over that, but also I'm not sure we want to introduce something at the core that when used in userland modules forces the application using them to transpile or drop support for older platforms.
 @Hesulan I think that makes sense.  `marko-layout` and `marko-async` started out as separate packages that eventually were merged into core.  The same could happen here.  I'm going to go ahead and close this issue, but do publish that package so we can play with it.  And maybe we can reopen this in the future.
  ## Description
Added the "ref" and "for-ref" attributes, which replace the now deprecated "w-id" and "w-for" attributes. 

Added warnings to discourage the usage of "w-id" and "w-for".

## Motivation and Context
This change is for the upcoming marko v4 release (see ROADMAP.md).

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [x ] My code follows the code style of this project.
- [ x] I have updated/added documentation affected by my changes.
- [ x] I have read the **CONTRIBUTING** document.
- [ x] I have added tests to cover my changes.
- [ x] All new and existing tests passed.
 Thanks for the PR @charlieduong94 ! Your changes look great. I did make a small change to include the location information for a deprecation warning. For example:

```
The "w-id" attribute is deprecated. Please use "ref" instead. (test/autotests/widgets-browser-deprecated/widget-render-to-iframe/components/app-iframe-content/template.marko:3:4)
```

If you are interested in any other issues, please let us know. Thanks again!
  Currently, `htmljs-parser` switches into HTML parsing mode when the first character of a concise line is `$`. This was a deliberate decision at the time, but it results in unwanted differences between the HTML and concise syntax. Currently, in order to have a dynamic tag name, the HTML syntax must be used. We want to fix that.

Given the following template:

```
${isInline ? 'span' : 'div'} - Hello World
```

Given a value of `true` for `isInline`.

Old output:

```html
span - Hello World
```

Expected new output:

```html
<span>Hello World</span>
```

 TODO: Output warning in old parser used by Marko v3. Something similar to:

```
WARNING!!
The behavior of `${` at the start of a line in concise parsing mode will
be changing in Marko v4. To avoid problems in the future, you should
make the following change right away:

OLD: ${foo}
NEW: - ${foo}

See: https://github.com/marko-js/marko/issues/425
```  This change allows whitespace in complex expressions such as the following:

``` xml
<assign name=lastName.toUpperCase() + ', ' + firstName.toLowerCase()/>
```

See related PR for `htmljs-parser`: [htmljs-parser PR #37](https://github.com/philidem/htmljs-parser/pull/37) Only handling this for the `var` and `assign` tag is a reasonable suggestion. I think I might be okay with that. What do you think @mlrawlings ?
 The parser does support entering into new parsing modes based on the tag name so that is certainly an option. It's also possible that the `var` could handle making sense of the separate attributes (divided by spaces) and group things back together, but that might get messy.
 @Hesulan It's certainly safer to make this apply to only `var`/`assign` because there is no possibility that an operator in a variable name is valid.  However, I'm concerned that there may be confusion if I can do `<var sum = 1 + 2 />` but not `<counter start = x + 1 />`.  

@philidem also suggested that if we were to do this it should be across the board at the parser level.

### Reasoning

I certainly understand that this can impact readability:

``` html
<custom-tag count = 1 + 2 + 3 class = foo style = styles.foo />
```

vs.

``` html
<custom-tag count=1+2+3 class=foo style=styles.foo />
```

However, I see the main reason for this is to be able to write code in `.marko` that looks like js:

``` js
import { calc } from './helpers'

var sum = data.value + 5
var calculated = calc(data.value, 2)

<div>${calculated}</div>
```

### Another possibility

I don't know if this is a good idea, but I'll throw it out there:

What if we required comma separation when using whitespace around `=`:

``` html
<custom-tag count = 1 + 2 + 3, class = foo, style = styles.foo />
```

Which actually lines up with JS pretty well:

``` js
var count = 1 + 2 + 3, x = foo
```

@patrick-steele-idem and I had also talked about allowing a semicolon at the end of a concise tag:

``` js
var count = 1 + 2 + 3, x = foo;
```
 Using comma separation is an interesting idea, I do like the fact that it aligns with JS. The down side is that it may cause confusion if it's only required when using whitespace.
 Good discussion. After giving it some thought, I think the comma solution is the best option and it should be allowed for all tags (not just `var`/`assign`). The parser should be updated such that, when encountering a comma, would combine everything after an attribute `=` and before the `,` together to allow the following to work as expected:

``` xml
<custom-tag count = 1 + 2 + 3, class = foo, style = styles.foo />
```

I think that provides a good balance to being like HTML (space-separated attributes), while also being like JavaScript.

Are we okay with the comma being used sometimes, but not all times for the same tag?:

``` xml
<!-- commas sometimes: -->
<custom-tag count = 1 + 2 + 3, class = foo style = styles.foo />
```

The only possible edge case is that the comma was supposed to be part of the expression, but I can't think of any reason that would ever be the case.

Similarly, I am still in favor of allowing a `semicolon` to end a tag such that the following would be allowed:

``` xml
<var foo=123, bar=456;/>
var baz=456;
```

Thoughts?
 As a side note, a comma would allow the following in concise mode:

```
var foo=123,
    bar=456
```

The comma at the end of the line would make it clear that additional attributes are expected and the parser would say in the tag parsing mode even if the EOL is reached.
 @patrick-steele-idem What about if the last (or only) attribute has spaces?

``` xml
<custom-tag count = 1 + 2 + 3 />
```

In concise mode, if we allow a semicolon as an indicator that this is the last space separated value, that could work:

``` js
var foo,
    count = 1 + 2 + 3;
```

What if the comma/semicolon syntax was specific to concise mode?  We're trying to make things look more like JS, but there's nothing wrong with wrapping the value in parenthesis:

``` xml
<custom-tag count = (1 + 2 + 3) />
```
 Patrick and I were just discussing this and realized that there could be some other issues:

### Text content on same line

Content on the same line would be an issue:

``` js
tag baz = 3 - Hello, World;
```

_Is that `<tag baz=3>Hello, World;</tag>` or `<tag baz=(3 - Hello) World />`?_

### Multi-line values

Attribute value split across multiple lines:

``` js
var foo = doSomething()
    .chain1
    .chain2
```

_Are `.chain1` and `.chain2` property accessors, or shorthand divs with classes?_

I suppose in this case it would be easy enough to say that multiline values **_must**_ be wrapped in parenthesis. 
 **Here's my proposal:**

- When parsing _attribute value_, encountering whitespace followed by a character that is not a binary operator character (except for `-` in concise mode and `>` in HTML mode) will keep the parser in the _attribute value_ mode.
- When parsing _attribute value_ in _concise mode_, encountering `-` will switch to single line HTML mode (this is the current behavior)
- When parsing _attribute value_ in _HTML mode_, encountering `>` will end the current tag (this is the current behavior)
- When parsing _attribute name_ or _attribute value_, encountering a `,` (comma) will be treated as an attribute delimiter. All whitespace (including newline character) will be ignored after the comma is encountered until the next non-whitespace character is encountered. A mix of commas and whitespace can be used as delimiters within the same tag.
- When parsing _attribute name_ or _attribute value_, A `;` (semicolon) will always be treated as an attribute delimiter and will not be part of the attribute name or value. Unlike the comma, a semicolon cannot be used to wrap attributes across multiple lines. (I think we still need to discuss this more) I just made a PR implementing this and some related parser updates. I'd love some feedback from everyone that has contributed to this discussion. https://github.com/philidem/htmljs-parser/pull/42

 Fixed with upgrade to `htmljs-parser@^2`   If `out.error()` is called the `finish` event is still emitted. That would result in both `reject` and `resolve` being called. I'm not sure what the `Promise` spec says should happen when that occurs, but we should probably add code to make sure that `resolve` is not called when `reject` is called. Do you mind investigating that?
  `w-bind` â†’ `widget` or `component`

See also #393 #395 #399 

__Update:__ we decided to remove `w-bind` and alternatives completely. If you want to bind a widget to the DOM nodes you need to name the file `widget.js`, `component.js` or embed an inline `<script>` tag in the template with a `module.exports`/`export default`. @Hesulan We decided to not allow that anymore @Hesulan The problem with `<widget-types/>` was that all possible widgets ended up being bundled up by the JavaScript module bundler. The better alternative is to have a single widget that can delegate out to a particular widget implementation or to conditionally remap the JavaScript widget module to the correct module at bundling time. Lasso supports conditional remaps (see `requireRemap` in https://github.com/lasso-js/lasso#nodejs-style-module-support). There are better workarounds and deprecating `w-bind`/`<widget-types>` simplifies Marko and simplifies documentation. I hope that clarifies.    Thanks for opening the issue @cdhowie. You are right that it is missing from the language guide. We did document this feature in the "What's New in Marko v3", but we did not move over those docs into the language guide: http://markojs.com/docs/marko/what-is-new-marko-v3/#tag-body-content-parsing

On a related note, marko uses [htmljs-parser](https://github.com/philidem/htmljs-parser) and that parser automatically switches into `parsed-text` mode when parsing both `<script>` and `<style>` tags (see: [philidem/htmljs-parser/Parser.js](https://github.com/philidem/htmljs-parser/blob/4a1b907092a512bc1f2e22f52a24ea9cf1dfc3ff/Parser.js#L2520-L2521[). This means that the parser won't recognize HTML tags inside `<script>` and `<style>` tags since those tags do not contain HTML. Therefore, you should very rarely need to know about the `marko-body` attribute. You should only need to know about `marko-body` text if maybe you are creating a custom tag that allows non-HTML content to be nested. When creating a custom tag you can specify the `body` parse mode as shown below:

_src/components/my-script-wrapper/marko-tag.json:_

``` json
{
    "body": "static-text",
    "preserve-whitespace": true
}
```

Hope that helps! 

I'm keeping the issue open so that we update the docs. We are currently extremely busy with all the work associated with the upcoming [Marko v4](https://github.com/marko-js/marko/milestone/2) release so if you would be interested in fixing the docs, please feel free to submit a PR to the following docs file: https://github.com/marko-js/marko/blob/master/docs/language-guide.md
 To be honest, I could probably be swayed towards making the default `static-text` (instead of `parsed-text`) for `<script>` and `<style>` tags in Marko v4. Allowing expressions in `<script>` blocks was kept around because a lot of earlier developer were doing something similar to the following:

``` html
<script>
window.foo = ${JSON.stringify(bar)};
</script>
```

On a related note, marko has special escaping rules for expressions inside the `<script>` tag to make sure `</script>` does not get rendered inside a string.

[Marko v4 will integrate Marko Widgets](https://github.com/marko-js/marko/blob/master/ROADMAP.md) and make it much easier to serialize extra data/state down to the browser that then gets passed to the widget constructor.

> Anyway, documenting marko-body would've at least made it easier to correct the problem when we figured out what it was.

Agreed. Keeping this issue open so that we at least fix the docs with Marko v4.

/cc @mlrawlings @philidem Thoughts?
  `extension` and `extensions` properties are both now supported and consolidated. A few things to discuss:

- The consolidation function takes a `requireObj`, which is the Node.js `require` in `node-require.js`. I did this so it was easy to mock in a unit test without having to pollute the actual `require` object.
- I put `consolidateExtensions.js` in a new folder `util/`. I am open to other suggestions as to where to put this module. I do like the idea of having a `util/` folder at the top-level though. Changes already manually merged. Closing PR. Thanks for working on this!
  Bug on jQuery Proxy when w-id contains dash/hyphen, see issue #391 

## Description

Bug on jQuery Proxy when w-id contains dash/hyphen (e.g `w-id="submit-button"`)

## Motivation and Context

This PR contains fix for issue #391 

## Screenshots (if appropriate):
None

## Checklist:
- [x] My code follows the code style of this project.
- [ ] I have updated/added documentation affected by my changes (comment: not relevant to this issue)
- [x] I have read the **CONTRIBUTING** document.
- [x] I have added tests to cover my changes.
- [x] All new and existing tests passed.
 Thanks for the fix! I will back port your fix to Marko Widgets v6 and update here when published.
 New version of `marko-widgets` published with your fix: `marko-widgets@6.4.1`

Thanks again!
  ### Background: why `<script marko-init>` exists

For the most part, all of your template ends up in a render function

A template like this:
```xml
<var name="World"/>
<div>Hello ${name}</div>
```
compiles to something like the following (oversimplified) output js:
```js
function render(data, out) {
    var name = 'World';
    out.w('<div>Hello'+name+'</div>');
}

module.exports = new Template(render);
```

But there are times when you might want to add initialization code outside the `render()` function so that it doesn't run everytime the template renders, only when the template is first required.

So `<script marko-init>` has fulfilled this need.

### Why we want to change

A template like this:
```html
<script marko-init>
    var format = require('format');
</script>
<var name="World"/>
<div>Hello ${format(name)}</div>
```
compiles to something like the following (oversimplified) output js:
```js
var format = require('format');

function render(data, out) {
    var name = 'World';
    out.w('<div>Hello'+format(name)+'</div>');
}

module.exports = new Template(render);
```

A `<script>` tag usually puts code into the output html, but in this case, we're highjacking it because of the `marko-init` attribute and using the code as part of the render logic.

We actually already have a construct that is meant to add arbitrary javascript in template render logic: [scriptlets](https://github.com/marko-js/marko/blob/21a43c010a75ca06857598f49ea3368b3e33c3c2/docs/what-is-new-marko-v3.md#scriptlets).

But scriptlets, like most other things, run within the context of the `render` method.

### The proposal

By default, scriptlets, `<var>`, `<assign>`, etc. would continue to run within the context of the render method, but we will introduce a new tag: `<render>`.

A template like this:
```html
<var format=require('format')/>
<render>
    <var name='World'/>
    <div>Hello ${format(name)}</div>
</render>
```
compiles to something like the following (oversimplified) output js:
```js
var format = require('format');

function render(data, out) {
    var name = 'World';
    out.w('<div>Hello'+format(name)+'</div>');
}

module.exports = new Template(render);
```

Now the structure of the template matches up fairly well with the structure of the output js. :+1:

Obviously anything outside of `<render>` would not be allowed to write to `out` as `out` wouldn't be in scope.  We should detect this and throw an error at compile time. I definitely have some concern around having to wrap all the template code just to introduce some JavaScript initialization code. With that said, it doesn't look as bad with the concise syntax:

``` html
var format=require('format')

render
    var name='World'
    <div>Hello ${format(name)}</div>
```

You could even make it look like a method by adding parens and possibly a `data` param:

``` xml
var format=require('format')

render(data)
    var name='World'
    <div>Hello ${format(data.name)}</div>
```

And finally, that could allow for ES6 argument destructuring:

``` xml
var format=require('format')

render({name})
    <div>Hello ${format(name)}</div>
```
 I agree with wrapping everything in a `<render>` not being so great. Would that be required, or optional, only if you need code generated out of the context of the render function?

If the goal is to deprecate `<script marko-init>` with the already established expectation of a `<script>` tag, why not add a new tag called `<init>`, or something else?

```html
<init>
    var format = require('format');
</init>

<var name='World'/>
<div>Hello ${format(name)}</div>
```
or
```html
<init>
    <var format=require('format')/>
</init>

<var name='World'/>
<div>Hello ${format(name)}</div>
``` @Hesulan The `<import>` tag does hoist outside the `render` function, see the [import-tag test](https://github.com/marko-js/marko/tree/master/test/autotests/compiler/import-tag) and its [expected output](https://github.com/marko-js/marko/blob/master/test/autotests/compiler/import-tag/expected.js).

Importing modules is a big reason `<script marko-init>` was needed (just look at every example in this thread), but you might need to do something like this:

```html
<import { createFormatter } from "./format"/>
<var format=createFormatter({ lang:'en' })/>

<render(data)>
    <var name='World'/>
    <div>Hello ${format(name)}</div>
</render>
```


```js
import { createFormatter } from "./format";
var format = createFormatter({ lang:'en' });

render(data)
    var name = 'World';
    <div>Hello ${format(name)}</div>
```

I think the actual implementation of `<render>` would internally rely on the equivalent of the suggested `<init>` tag.   You'd loop over each top level element and if you found a `<render>` tag, you'd move all the other top-level elements into an `<init>` tag.  The `<init>` tag would then generate the code for its children and instead of putting that code in the render method it would place it towards the top of the file.  The question is should this `<init>` tag be an internal thing or should it be exposed as an alternative?

@patrick-steele-idem You've talked about requiring the parens on `<render>` and maybe that makes sense.  But we should also require an actual argument there: the name of the `data` variable.

Wrapping the whole template in `<render(data)>` would leave things as they are now.  `<render()>` would be invalid.

As for the `<init>` name, would `<load>` make more sense?  If you're not using the require hook, you would call `marko.load('./template.marko')` and that's the point at which this init/load code is run.

_Almost_ makes me want to do something like `<on-load>` and `<on-render>`, but let's not. Closed via https://github.com/marko-js/marko/commit/2980546f7c3309ec11a268ea0d4a801506c4ab6b  I think that's a good suggestion, although I would probably use `WARNING` instead of `ERROR`. Would you be interested in submitting a PR to improve marko? Thanks for opening the issue.

NOTE: Marko v4 development is on master and Marko v3 is on the [v3 branch](https://github.com/marko-js/marko/tree/v3) 
  Thanks for opening the issue @tinovyatkin, but that is the expected behavior since Marko is using the JavaScript rules for parsing a String attribute value. This means that JavaScript escape sequences starting with the `\` character must be valid JavaScript escape sequences. In your case you need to escape the backslash character so that the JavaScript parser doesn't treat it as a JavaScript String escape sequence:

``` html
<input type="text" pattern="\\w{2,20}" />
```

While this is not a bug in Marko, I admit that the escaping of those characters is less than ideal. What are your thoughts on enhancing Marko to allow a JavaScript regular expression for the attribute value?:

``` html
<input type="text" pattern=/\w{2,20}/ />
```

(we could update the compiler so that the output would be as expected)
 We should do this.  It's come up [before](https://github.com/marko-js/marko/issues/306#issuecomment-225099028).

It should be as simple as adding the following to the `escapeXmlAttr` function:

``` js
if(attr instanceof RegExp) {
    let str = attr.toString();
    return str.slice(1, str.lastIndexOf('/'));
}
```

The only thing is that html style regex don't support flags, so I'm thinking we just drop them?
  It is not safe to remove whitespace inside a `<script>` because the code inside a `<script>` tag is not HTML rules so we cannot use the HTML whitespace removal rules. If marko were to remove whitespace inside `<script>` tags then there is a good chance that it would break the code. If you want to safely remove whitespace inside a `<script>` tag then you would need to use a JavaScript minifier (the performance would be really slow so you would not want to run the minifier for every request). 

If you want go advanced, you can create your own compile-time transform that removes whitespace that is appropriate for your use case.

Hopefully that answers your question, but please feel free to add more comments here if not.
  Hey @basickarl, at first glance your setup looks correct. Are you seeing any errors? Do you see the `<init-widgets>` tag in the final HTML output (you shouldn't, but that might be a clue)? 
 No longer an issue. Closing.  Hey @sriver111, we'll need more details to help you out. Have you tried using [browser-refresh](https://github.com/patrick-steele-idem/browser-refresh) to enable hot reloading of templates? Here's a sample app that demonstrates hot reloading that I recommend checking out: https://github.com/marko-js-samples/marko-hot-reload
 @sriver111 would it be possible to share a minimal project to reproduce the problem? I'm not able to reproduce, but it is possible that a Windows-specific issue has creeped in.

FYI, hot reloading works in the following way:

When hot reloading is enabled, the `Template` class is monkey-patched to proxy all of the rendering methods in order to check if the template needs to be reloaded or not before calling the original method. In addition, when a `.marko` file is modified it is deleted from the `require.cache` so that it can be reloaded through the Node.js module loading system. I can share more information, but just wanted to give you an idea how it works.
 Glad you got it working. Closing the issue. Thanks for the update.
  Looks like a bug. I am investigating and should have an update soon. Thanks for opening an issue!
 Should be fixed now. We were missing a test case that should have caught an internal API change. New version published with fix: `marko@3.11.7`

Thanks, again.
  There are no `try...catch` blocks in marko so exceptions will not be caught by marko (this includes render-time exceptions due to programming errors in marko templates). 

Certain errors (such as timeouts associated with the `<await>` tag) will be emitted on the target stream. You can listen for those errors by adding a listener for the `error` event:

``` javascript
res.on('error', function(err) { ... });
```

If you use promises then promises will have an implicit `try...catch` block. If the promise passed to an `<await>` tag gets rejected then the `<await-error>` tag can be used to show alternate content: [`<await-error>`](http://markojs.com/docs/marko/async-taglib/#<code>&ltawait-error><code)

It's good practice to make sure you have an uncaught exception handler for any Node.js app that will gracefully close any connections and shutdown the app.

Hope that helps, but let us know if you have any other specific questions. I'm going to go ahead and close this issue, but please feel free to add more comments below.
  Currently, the process for [discovering taglibs](http://markojs.com/docs/marko/custom-taglibs/#taglib-discovery) is determined per template by the following:
1. search for `marko.json` in the same directory as the template, and then in each parent directory up to the project root (until a `package.json` is found).
2. for each dependency in the `package.json`, search for a `marko.json` at the package root.

This provides encapsulation as each template can only be modified by taglibs in its own package and packages it directly depends on.  It also provides consistent behavior no matter how the `node_modules` directory structure ends up due to dependency flattening of `npm@3` or `yarn`. :+1:

However there are cases where it could be useful to have global taglibs that are discovered by **every** template.  Here's a few ideas:
- A security transform that puts a [`nonce`](https://developer.mozilla.org/en-US/docs/Web/Security/CSP/CSP_policy_directives#strict-dynamic) attribute on all inline script tags
- A asset management transform that allows relative paths to be specified for resources (ex. `<img src="./foo.png"/>`) and includes the resolved file in the build.
- etc.
 @mlrawlings Any thoughts on how to register global taglibs?
 I have few thoughts on this:

**1**. Add methods to force inclusion of a directory or package:

``` js
require('marko/compiler').taglibFinder.includeDir(dirPath);
// Where 'dirPath' is an absolute path to the folder containing marko.json 

require('marko/compiler').taglibFinder.includePackage(packageName);
// Where 'packageName' is the name of the node_module containing marko.json 
```

I don't particularly like this because I'm not a fan on having the application compile templates differently than the command-line tool, test, etc.  This becomes a source of hard-to-find problems.

**2**. Keep searching up after finding a `package.json` and load parent's packages' taglibs as well.   This would make the global behavior the default, though not truly global as taglibs would trickle down, but not up.   I could potentially see some unwanted behavior with this approach, but the top level would always be in control of what was added in, so it might not be so bad.  Another issue is dependency flattening.  One dependency might be a dependency of another but they could be siblings in the directory structure due to flattening.  This could lead to unexpected behavior.

**3**. Allow taglibs to specify a `"global":true` option in `marko.json`.  For discovery purposes (and sanity?)  only top level dependencies (those directly depended on by the main application) would be able to register global transforms, renderers, etc.  If the top level application wanted to register a global transform, it would be required to do so in a `marko.json` at the root of the package.  The only challenge with this would be determining the root application.  We could potentially do something with searching up to the root of the filesystem and the highest directory with a `package.json` is assumed to be the app root.  Or we could use `process.cwd()` as a heuristic. 

Option 3 is looking the best at this point, but I'm open to other suggestions.
  For performance reasons, if a render completes synchronously then the callback is invoked synchronously. Therefore, if you repeat the rendering when the callback is invoked then you will eventually get a `Maximum call stack exceeded` error because the stack trace keeps growing.

The simple solution is to break up the stack trace using `setImmediate()`:

``` javascript
bench('marko', (next) => {
    const template = require('./post.marko');
    template.render(data, () => {
        //throw away the render output
        setImmediate(next);
    });
});
```

If you add `setImmediate` for `marko` then make sure you also add it for `handlebars` so that the results are not skewed.

On a related note, have you taken a look at the following benchmarks that include `marko` and `handlebars`?: https://github.com/marko-js/templating-benchmarks

It's very easy add add a new comparison group with your own templates. If you want to improve those benchmarks with more comparisons I would encourage you to send a PR.

If you have any other questions or issues please let me know.
  ## New Feature
### Description

<!--- Provide a detailed description of the change or addition you are proposing -->

This is kinda a rough idea I've been throwing around in my head for a while now and figured I should put it out there:  I'd like Marko to provide a way to automatically inject a custom tag at the end of a page.
### Context

There's a number of tags in our ecosystem (some of these eBay specific) that we end up having users add to their layout templates right before the closing `</body>` tag.  Often users will forget to add one an wonder why something isn't working.

``` xml
<body>
    ...
    <await-reorderer/>
    <lasso-body/>
    <init-widgets/>
    <gh-footer/>
    <gh-body-js/>
    <tracking-cookies/>
    <tracking-images/>
    <tracking-body />
    <browser-refresh/>
    <site-speed-bottom/>
</body>
```
### Conciderations

<!--- What still needs to be discussed -->

Tags could already implement something basic by hooking into the closing body tag, but it's possible someone renders a template without a `<body>` tag.  Google even [recommends](https://google.github.io/styleguide/htmlcssguide.xml?showone=Optional_Tags#Optional_Tags) to omit it.  Ideally, the insertion point for these tags would be just before `</body>` or, if that's not found, at the end of the top level template.

Async is also something that needs to be considered.  

> Example: In the case of `<init-widgets/>`, we would only want to include it on the page if there are widgets on the page.  But it could be that the only widget is in an `<await>` block and therefore we don't know that we need to init widgets until that block is executed.

Finally, some tags (like `<init-widgets/>`) require that the javascript has been loaded before them.  And it's likely that a tag to insert that javascript (like `<lasso-body/>`) would also be using this system to insert itself.  So perhaps we need some system of priority.  Or tags could choose between append/prepend.
 It would also be ideal if we could do this without adding code to every generated template.
  Looks good. Thank you!
 @yomed Thanks for these docs related PRs!  We definitely appreciate it!
  Hey @jdnichollsc, thanks for the feedback and welcome to Marko! 

You are doing everything correctly, except you for got to register the Node.js require hook for Marko templates. You should add the `require('marko/node-require').install();` line to your main JavaScript file:

``` javascript
require('marko/node-require').install(); // â† Add this line

var express = require('express');
var router = express.Router();
var template = require('../views/index.marko');

/* GET home page. */
router.get('/', function(req, res, next) {
  res.marko(template, { title: 'Express' });
});

module.exports = router;
```

Without that line, Node.js will try to load Marko templates as JavaScript modules. The Node.js require hook for Marko registers a custom loader for Node.js that will automatically compile `require`d `.marko` templates to JavaScript modules so that they can be loaded by the Node.js module loading system.

Hope that solves your problem, but let us know if you run into any other issues.

Cheers.
 The `require('marko/node-require').install();` line just needs to run once at the very beginning. In your case, you just need to add it to the top of your `./app.js` file.

We tried to make this clear in the docs for using Marko with Express: http://markojs.com/docs/marko/express/

It's also discussed in more detail as part of the Getting Started guide: http://markojs.com/docs/marko/get-started/#template-loading

If you still think there is room for improving the docs please let us know or submit a PR (at the top of every docs page on [markojs.com](http://markojs.com/) there is a "Improve this page" page link).
  <!--- Provide a general summary of your changes in the Title above -->
## Description

<!--- Describe your changes in detail -->

Opening this for feedback & discussion.  This PR adds `await:error` and `await:timeout` events.  I will add documentation for these before we merge.
## Motivation and Context

<!--- Why is this change required? What problem does it solve? -->

<!--- If it fixes an open issue, please link to the issue here. -->

To allow applications to listen for errors that occur in an `<await>` tag, even if the error is handled by the template. For logging purposes and such.
## Checklist:

<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->

<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [x] My code follows the code style of this project.
- [x] I have updated/added documentation affected by my changes.
- [x] I have read the **CONTRIBUTING** document.
- [x] I have added tests to cover my changes.
- [x] All new and existing tests passed.
  ðŸ‘ Very much appreciated. Thanks!
  Looks great. Thanks!
  Marko supports custom attributes on standard HTML tags. You would need to write a compile-time transform to process those custom attributes. It's not hard, but it is definitely more in the "advanced usage" category. A compile-time transform can also process standard HTML attributes if you choose.

Here's some relevant docs that show an example of a transform processing a custom `if` attribute: http://markojs.com/docs/marko/compiler/advanced/#transform-stage

Sometimes it is easier to explain in code so I will push a sample app that will hopefully make things clear. I'll provide an update here soon.
 Hey @jasonmacdonald, it took a little longer because I got pulled into some other things, but here is a project that I hope clarifies how to handle custom attributes: https://github.com/marko-js-samples/marko-custom-attributes 

I'm going to go ahead and close this issue, but if you would like more details please feel free to post comments here.
 You're welcome. You just need to use `marko.json` to register the compile-time transform, but you can still use the `components` directory.
  Hey Ryen, I don't think this is an issue with the Marko middleware since there is no way for Marko to know that the response is going to be the same before rendering. I think the responsibility of setting the cache headers and setting HTTP status codes should reside in your application logic. If you have any more thoughts please share.
 In order for `res.marko()` to send a 304 it would need to buffer the response in order to calculate an etag based on the final HTML output and then use that etag to determine if 304 should be sent based on incoming request and it would also need to set the etag header for the response. That is certainly something we could offer as a feature, but it would need to be opt-in since buffering would prevent streaming/progressive HTML rendering (a huge reason to use Marko). In a perfect world, your page controller would calculate the etag independent of template rendering (this would would have the advantage that there would be no CPU cycles and memory wasted rendering a template that didn't need to be rendered).

I'm not opposed to offering feature as an enhancement, but it would need to be opt-in. If it something you are interested in working on, here is the related code:
- https://github.com/marko-js/marko/blob/master/express.js
- https://github.com/jshttp/fresh
- https://github.com/jshttp/etag

Please let me know if you are interested in working on this.
 And just to add. something like the following might be nice:

``` javascript
res.marko(template, templateData, { etag: 'weak' });
```
 Did you go any farther with this @RyenNelsen? Generating a hash of the data would work if the output is completely based on the backend data, but it would definitely require some extra CPU cycles. Depending on how your backend data is structured, you could store a "version"/"revision"/"last modified" or some other value with the data to track changes to the data and use that value to also set the `etag` and check freshness. That would all be outside the scope of marko. The only thing that marko could do is buffer up the output HTML in order to calculate an etag and compare freshness to conditionally send down a `304 not modified`
  I think changing the name of the package will disrupt things too much. Also, we merged the functionality of `autocomplete-marko` and `hyperclick-marko` into the main [language-marko](https://atom.io/packages/language-marko) package. It's unfortunate that the search results for `marko` are in such a bad order, but I'm not sure there is much we can do about that right now. I did add keywords to the `package.json` so hopefully that will help: https://github.com/marko-js/atom-language-marko/commit/9e5976ed29daca646b251c6a86f06992341e7284
  Currently, the Marko compiler compiles a template to a program that, when executed, will render an HTML string to a stream. This is perfect for the server, but it is less than ideal in the browser since the HTML string must be parsed using something like `innerHTML` in order to update the DOM. Instead, we plan to update Marko to support a new "virtual DOM" output mode for the compiler and an accompanying virtual DOM runtime. The templates will continue to be compiled to a program that renders an HTML stream for the server, but templates will be compiled to render to a virtual DOM tree in the browser. Supporting multiple compilation outputs will allow optimizations in the browser that were not possible before.

To make things more clear, let's take a look at an example template:

``` xml
<h1 class="title">
    Hello ${data.name}!
</h1>

<if(data.colors.length)>
    <ul>
        <li for(color in data.colors)>
            ${color}
        </li>
    </ul>
</if>
<else>
    <div class="empty">
        No colors!
    </div>
</else>
```

The current compiled output for the above template is similar to the following:

``` javascript
function render(data, out) {
  out.w("<h1 class=\"title\">Hello " +
    escapeXml(data.name) +
    "!</h1>");

  if (data.colors.length) {
    out.w("<ul>");

    forEach(data.colors, function(color) {
      out.w("<li>" +
        escapeXml(color) +
        "</li>");
    });

    out.w("</ul>");
  } else {
    out.w("<div>No colors!</div>");
  }
}
```

We are planning to go with the following virtual DOM output when compiled for the browser (not exact):

``` javascript
var attrs0 = { class: 'title' };

var el0 = createElement('div', { class: 'empty' }, 1 /* child count */)
    .text('No colors!');

function render(data, out) {
    out.element('h1', attrs0, 1)
        .text('Hello ' + data.name + '!');

    if (data.colors.length) {
        out.beginElement('ul');

        forEach(data.colors, function(color) {
            out.element('li', null, 1)
                .text(color)
        });

        out.endElement();
    } else {
        out.node(el0);
    }
}
```

A few things to note:
- Optimization: static subtrees are pulled into variables that are only initialized once and reused for every render
- Optimization: static attributes that are on dynamic elements are pulled out to static variables
- Optimization: Diffing is skipped when comparing static subtrees
- Async rendering will continue to be supported on both the server and in the browser. Async fragments will begin with a partially constructed virtual DOM subtree
- `out.write()` will not be allowed when rendering to a virtual DOM
- `out.getRootNode()` can be used to get the root [DocumentFragment](https://github.com/marko-js/marko-vdom#documentfragment) node for the virtual DOM tree being rendered.

Tasks:
- [x] Provide a virtual DOM implementation that is compatible with morphdom. Done: [marko-vdom](https://github.com/marko-js/marko-vdom)
- [x] Update [morphdom](https://github.com/patrick-steele-idem/morphdom) to support diffing the real DOM with a compliant virtual DOM. Done: [morphdom PR #83](https://github.com/patrick-steele-idem/morphdom/pull/83)
- [x] Update the Marko compiler to support multiple output modes
- [x] Implement the codegen for the virtual DOM output mode (almost done)
- [x] Optimize using `isSameNode()` for static subtrees
- [x] Update [async-writer](https://github.com/marko-js/async-writer) to support a virtual DOM runtime. Done: [async-vdom-builder](https://github.com/marko-js/async-vdom-builder)
- [x] Merge in [raptor-renderer](https://github.com/raptorjs/raptor-renderer) functionality into [async-vdom-builder](https://github.com/marko-js/async-vdom-builder) and [async-writer](https://github.com/marko-js/async-writer)
- [x] Additional optimizations for static attributes on non-static sub trees
- [x] Default to `vdom` output for [lasso-marko](https://github.com/lasso-js/lasso-marko)
 @PierBover Anything is possible because Marko allows for custom compile-time transforms and custom code generators for custom tags and this allows for custom JavaScript to be inserted into the compiled template to attach event listeners or whatever else is needed.

Marko Widgets is an example of a UI components library that utilizes compile-time transforms to supports declarative event bindings for both DOM events and custom widget events. Marko Widgets allows named events to be bound to a named widget method. How Marko Widgets handles event binding is a subtle implementation detail, but it allows the browser to pick up right where the server left off and, unlike with React, it is not necessary to rerender the UI in the browser if it was already rendered on the server. The reason React requires that the UI be rerendered in the browser is because a reference to a listener function on the server can't be passed down to the browser so all the server is really providing is the raw HTML.

More details: http://markojs.com/blog/a-closer-look-at-marko-widgets/#how-does-event-delegation-work
 @ianvonholt for now we only have raw numbers (no fancy graphs) for a benchmark of the new [marko-vdom](https://github.com/marko-js/marko-vdom) implementation that shows very significant speedups when measuring the time it takes to build a virtual DOM tree compared to a real DOM tree, as well as the time it takes to walk a virtual DOM tree compared to a real DOM tree: https://github.com/marko-js/marko-vdom/blob/master/docs/benchmark-results.md

While a virtual DOM implementation provides some significant gains, I suspect the bigger improvements will come from the fact that we can now skip rerendering parts of a template that are constant. That is, the improved compiler will separate out a DOM subtree to a virtual DOM node that is only created once and used for every rerender. On top of that, we also mark that virtual DOM node as constant so that Marko Widgets will completely skip diffing entire DOM subtrees that are constant. This was not really possible before when rendering to an HTML string since the entire HTML string was being parsed to produce a real DOM even though many of the HTML strings were constant.
  There are a few reasons we have kept `writeToDisk` enabled:
- In development, seeing the output `.marko.js` file is helpful for debugging and understanding
- In production, templates are not recompiled if the application server needs to restart since the compiled out from the previous startup was written to disk. This makes startup times slightly faster

Since disabling `writeToDisk` is as simple as `require('marko/compiler').configure({ writeToDisk: false })` I'm in favor of keeping the current behavior. I'm open to other thoughts though.

@mlrawlings @philidem any thoughts? 
 @hustcer templates should always be compiled on the server. When you call `require('./template.marko')` on the server the template will be compiled and loaded at that time. When you use a JavaScript module bundler to send down templates they will be compiled during the bundling process. If that doesn't answer your question I would recommend joining us on Gitter to discuss: https://gitter.im/marko-js/marko
 I would agree that it would be nice to remove these files by default if only because it makes things seem simpler.  I will say though, that these compiled output files were extremely helpful in understanding how `marko` works at a lower level - though that's certainly not a requirement in order to _use_ `marko`.

The other concern I have is that runtime errors will reference a line/column in the generated `*.marko.js` file, so if that file is not readily available, debugging becomes more cumbersome.  

Potential solutions:
 - sourcemaps
 - write out the generated file on error @Hesulan Regarding source maps, our parser already has line/column start/end positions for every tag/attribute/etc. so that's definitely a good starting point and I'm thinking with the changes made to the way we generate code in v4, it might not be _too_ difficult to get the code writer to map changes back to the positions of the nodes its writing.  Then we would need some kind of way to track where newly generated nodes came from.  This would probably require the core transforms and user-generated transforms to give the compiler hints about what it's doing.  This would be especially true when custom parsing tag/attribute argument expressions.

I actually just recently added a `_currentNode` property to the context, so if we connect the builder to use that we might be able to track things in many cases, but I there would still be cases where you might need to pass in an original node to a builder method, possibly with position offsets.  

I definitely think we can get this to work.  We just need the time to spend on it.

In the short-term, maybe controlling `writeToDisk` via an environment variable would be easiest:

```
MARKO_WRITE_TO_DISK=true npm start
```

or something more generic like:
```
DEBUG=marko npm start
```




 That's an interesting thought @mindeavor. It's a little more verbose, but a tag such as one of the following would be easier to implement::

```xml
<write-to-disk/>
<!-- or -->
<marko-compiler write-to-disk/>
<!-- or -->
<marko-debug/>
<!-- or -->
<marko-compiler debug/>

<div>
  Hello ${data.name}
</div>
```  I don't quite follow. Marko templates are resolved and loaded through the Node.js module loading system just like normal JavaScript modules. There's no "views dir" and there is no root path when using marko directly. Can you provide more details and code to illustrate the problem you are seeing?
 As Patrick said, we use node's module resolution to handle finding the template.  If you really wanted to have a views directory, you could roll something yourself using the `require('marko').load()` function which expects a fully resolved filesystem path.  In our examples we use `require.resolve` to get that path, but there's nothing stopping you from resolving it relative to some views directory, but that would all happen outside the scope of Marko.   Maybe something along the lines of [this](https://gist.github.com/mlrawlings/d92b5c1d89abefbba66e2d8af5c47eef).

However, I would recommend having your `render` function take the loaded template as a parameter:

``` js
var template = require('./index.marko')

app.use(({ res }) => {
  res.send(200, marko.render(template, { name: 'Trek Engine' }))
})
```

We do something similar in the [`marko/express`](https://github.com/marko-js/marko/blob/master/express.js) submodule to provide the [`res.marko`](http://markojs.com/docs/marko/express/) method.
  I think what needs to happen here is that in addition to `.marko` and `.marko.html`, we should also look for any extensions that were registered via `require('marko/node-require').install()`.

For example:

``` javascript
require('marko/node-require').install({ extension: '.marko' });
require('marko/node-require').install({ extension: '.marko-xml' });
require('marko/node-require').install({ extension: '.foo' });
```

We should check to see if the path ends with `.marko`, `.marko-xml` and `.foo`.

Thoughts? Would you be interested in working on this @jlarsson?
  Hey @fundon. marko uses the [Apache 2.0](http://www.apache.org/licenses/LICENSE-2.0) license. I'm not a lawyer, but if you are just depending on marko (and not modifying it) then you don't need to do anything. Any distribution of marko need to include a copy of the license (which will be the case if you  are installing from npm or directly from Github).

If that doesn't answer your question then please let me know, but I am going to go ahead and close the issue.
 @fundon yes. as long as you are not modifying and redistributing marko then it doesn't matter what the license is for your project.
  Hi @Eldar-X, what version of Safari are you using and which OS? When I test Safari version 9.1.2 (11601.7.7) on OSX everything is working as expected using the following sample app: https://github.com/marko-js-samples/marko-progressive-rendering

It will vary by browsers, but most browsers must receive a minimum threshold of bytes before the initial render. It's possible that for your app you are not sending down enough HTML for the initial HTML and this is causing the browser to just buffer the received HTML instead of rendering the initial page. If you can provide more details on your setup or a sample app I will investigate some more.
  Hey @basickarl, here's what I consider to be a good directory structure:

``` clojure
/
 â¤· .cache/ (auto-generated-files)
 â¤· config/
    â¤· development.json
    â¤· production.json
 â¤· node_modules/ (installed-modules)
 â¤· src/
    â¤· components/
       â¤· some-component/
          â¤· test/
          â¤· index.js
          â¤· style.css
          â¤· template.marko
          â¤· template.marko.js
       â¤· .../ (additional-components)
    â¤· layouts/
       â¤· _common/ (files-common-to-all-layouts)
       â¤· main/
          â¤· fonts/
             â¤· sanfrancisco.woff2
          â¤· images/
             â¤· logo.webp
          â¤· style.css
          â¤· layout.marko
          â¤· layout.marko.js
       â¤· .../ (additional-layouts)
    â¤· pages/ (directory-of-pages)
       â¤· home/ (the-home-page)
          â¤· components/ (components-used-by-home-only)
          â¤· images/
             â¤· hero-image.webp
          â¤· index.js (home-route-handler)
          â¤· style.css 
          â¤· home.marko
          â¤· home.marko.js
       â¤· .../ (additional-pages)
    â¤· app.js
 â¤· static/ (auto-generated-files)
 â¤· test/ (test-related-files)
 â¤· package.json
```

 And to touch on some of your other questions:

### **How does one create a template which nests another template?**

_template.marko_

``` xml
<ul for(item in data.items)>
    <include('./item.marko') name=item.name />
</ul>
```

_item.marko_

``` xml
<li>${data.name}</li>
```

### **tags vs. widgets?**

Typically you'll see widgets implemented as custom tags.  A widget's template uses the `w-bind` attribute to link to a JavaScript file that contains its client-side behavior.

### **what is [marko.json](http://markojs.com/docs/marko/custom-taglibs/#markojson)?**

Marko will automatically look for directories under `components/` and [scan them](http://markojs.com/docs/marko/custom-taglibs/#scanning-for-tags) for custom tags.  If you want to define individual tags, use custom transforms, or scan a directory other than `components/`, you'll need to use this file to provide the configuration.  It used to be that you needed this file even if all your components were under a `components/` directory, which is why you'll find it in many examples.

### client marko rendering (both non widget and widget) is still unclear to me

A module bundler is needed to use marko client side, webpack [should work](https://github.com/marko-js/marko/issues/44), but I don't have any experience using it with marko.  We're currently working on some improvements (performance and otherwise) to client-side rendering.  We should update the docs and give some better examples once that work is complete.

### I would like to see an example project which touches all areas so I can see how they could be fit together

We have an sample project that makes use of Marko, but currently it's internal to eBay.   We'd need to remove some eBay specific things from the app, but it would probably be worthwhile to make that generally available.

### I think explaining from scratch for beginners who have just come from i.e. jQuery how marko works will draw a lot more attention to it.

I agree.  This is an area where we could use some help if you're willing.  It would be amazing to start seeing some training content provided by people outside the project maintainers.  I think when you're just starting to learn something you're in a unique position to help people at the same place, as things become familiar we tend to forget the aspects that used to be difficult for us.  

If you have more questions, feel free to join us on [gitter](https://gitter.im/marko-js/marko) and welcome to the community! :tada:
 @davidenq everything under `src/` includes all application source code (both server-side, client-side and isomorphic code). In most cases, whether or not code is client-side or server-side will depend on how the code is used. Do you have any other specific doubts?
 I'm going to go ahead and close this issue. If you still have unanswered questions, please feel free to add comments here or open a new Github issue.
 @basickarl You can pass the data as the second argument for the `<include(path[, data])>` tag:

``` xml
<ul for(item in data.items)>
    <include('./item.marko', item) />
</ul>
```

See: http://markojs.com/docs/marko/language-guide/#includes
 @Anant-Raj 

The `components/` directory can exist in multiple places in your project and they are scoped. We recommend the following directory structure:

```
my-app/
    components/ â† top-level UI components shared by all pages/routes
    routes/
        about-me/
            components/ â† UI components scoped to the about-me route
            index.marko
        index/
            components/ â† UI components scoped to the index route
            index.marko
   ```

You can see this project structure in action as part of our starter app: https://github.com/marko-js-samples/marko-starter-demo

Let me know if you would like more details, but hopefully that answers your question.  No worries. I still think it was confusing since the docs say that they are deprecated, but we don't say why or which method should be used instead. I'll fix this to avoid confusing others. Thanks for opening the issue.
  See: https://github.com/marko-js/marko/issues/357
  The builtin `empty`/`notEmpty` helpers will be removed in Marko v4 and will be deprecated in v3 (with console warning).

If still needed, these helpers can still explicitly be imported:

``` html
<script marko-init>
var empty = require('marko/helpers/empty');
var notEmpty = require('marko/helpers/notEmpty');
</script>
```

Alternatively, you can simply check the array length or ensure that a string is not "falsey".
# Why?

The `empty`/`notEmpty` helpers were automatically being added to every compiled template. While they can be helpful, we feel it is better if the developer explicitly imports only the exact helpers that your code depends on for improved modularity. Also, when adding support for [inline marko templates](https://github.com/marko-js/marko/issues/349) we found that these `empty`/`notEmpty` helpers could conflict with other JavaScript code since all static code/imports are added at the top of the JavaScript file.
 @briceburg I suppose one possibility would be to introduce a new option in `marko.json` to opt-in for the `empty`/`notEmpty` helpers, but I don't think it is a good idea to go there. Personally, I would just use `<if(data.commits && data.commits.length)>` instead of a helper. If you have any other thoughts or ideas please share.
  Thanks. Appreciated ðŸ˜„ 
  <!--- Provide a general summary of your changes in the Title above -->
## Description

<!--- Describe your changes in detail -->

Previously there was a difference in the way empty string (`""`) was handled when it was a literal value.  It now uses the raptor-util behavior for both literals and dynamic values.
## Motivation and Context

<!--- Why is this change required? What problem does it solve? -->

<!--- If it fixes an open issue, please link to the issue here. -->

Fixes #327
## Checklist:

<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->

<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [x] My code follows the code style of this project.
- [x] I have updated/added documentation affected by my changes.
- [x] I have read the **CONTRIBUTING** document.
- [x] I have added tests to cover my changes.
- [ ] All new and existing tests passed. 

**The tests will fail until raptorjs/raptor-util#4 is merged and published**
  Thanks for letting me know. I have fixed the `.npmignore` file and published a new version with *.orig files excluded
  ## Description

Currently when a node/tag is marked with "preserve-whitespace", the whitespace is being preserved for only directly nested text. The expected behavior should be that whitespace should be preserved for all directly nested text and any text nested at any level below the node.
## Motivation and Context

[Issue #345](https://github.com/marko-js/marko/issues/345)
## Checklist:
- [X] My code follows the code style of this project.
- [X] I have updated/added documentation affected by my changes.
- [X] I have read the **CONTRIBUTING** document.
- [X] I have added tests to cover my changes.
- [X] All new and existing tests passed.
  ## Checklist:
- [X] My code follows the code style of this project.
- [X] I have updated/added documentation affected by my changes.
- [X] I have read the **CONTRIBUTING** document.
- [X] I have added tests to cover my changes.
- [X] All new and existing tests passed.
  Actual usage will be the following:

``` javascript
var defineRenderer = require('marko/defineRenderer');

module.exports = defineRenderer({
    template: require('./template.marko'),
    getTemplateData: function(input) {
        var firstName = input.firstName;
        var lastName = input.lastName;

        return {
            fullName: firstName + ' ' + lastName
        };
    }
})
```

NOTE: `defineRenderer` should be required as a sub-module (`require('marko/defineRenderer')`). This was done to avoid adding any extra weight to the main `marko` runtime.
  Some notes:
- The parser is working as expected
- This is not really a bug, but it is a "gotcha"
- We should offer a custom tag to avoid the situation where nested body content is ended too early.

One possible solution:

``` xml
<marko-parser body='static-text'>
    <section>
        <div>Other Content</div>
        <section>Content Goes Here</section>
    </section>
</marko-parser>
```

Thoughts?
  ## Description

<!--- Describe your changes in detail -->

Allows excluding the `components/` dir itself, in addition to its parent directory (presumably where a `marko.json` would have been found.
## Motivation and Context

<!--- Why is this change required? What problem does it solve? -->

<!--- If it fixes an open issue, please link to the issue here. -->

Fixes #340 
## Checklist:

<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->

<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [x] My code follows the code style of this project.
- [x] I have updated/added documentation affected by my changes.
- [x] I have read the **CONTRIBUTING** document.
- [x] I have added tests to cover my changes.
- [x] All new and existing tests passed.
  I'm testing this using a render test.  Is that fine?
 I think a render test is great because it easy to write tests based on the output HTML. Alternatively, you could add a taglib lookup test if you felt the need to inspect some of the internal data structures similar to the following: https://github.com/marko-js/marko/blob/master/test/autotests/taglib-lookup/custom-tag/test.js
 Amended commit has been merged: https://github.com/marko-js/marko/commit/80999593551b08d5a838daed462eb7561a735ec5

New version published with improvement: `marko@3.8.0`

Closing PR.
  There are no `try...catch` blocks in Marko (for performance reasons, but also because the Marko runtime wouldn't know how to best handle the error). A common strategy for error handling in Node.js is to gracefully close all connections when an uncaught error occurs and to shutdown the process. The following is a good read: https://www.joyent.com/node-js/production/design/errors

However, another good alternative is to use promises. Promise implementations use an implicit `try...catch` so you can do the following to catch any errors when rendering the initial HTML that is rendered synchronously:

``` javascript
function controller(req, res) {
    new Promise(function(resolve, reject) {
            template.render({name: 'Frank'}, res);
        })
        .catch(function(err) {
            res.end();
            // Handle the error...
            console.log('Templating rendering failed! ', err);

        });
}
```

In addition, if you are using the [`<await(...)>`](http://markojs.com/docs/marko/async-taglib/#<code>&ltawait><code) you can provide a promise as the data provider to handle the errors when rendering portions of your template asynchronously.

Also, we plan on adding a promise API method soon: https://github.com/marko-js/marko/issues/251

Does that answer your question?
  @bkuri, the implementation of `builder.text` looks like this:

``` js
text(argument, escape, preserveWhitespace) {
    if (typeof argument === 'object' && !(argument instanceof Node)) {
        var def = arguments[0];
        return new Text(def);
    }
    argument = makeNode(argument);

    return new Text({argument, escape, preserveWhitespace});
}
```

so try passing `true` as the third parameter:

``` js
return builder.htmlElement 'script', {}, [
    builder.text builder.literal(js), false, true
]
```
  @bkuri Thanks! Since you've already got a branch for this, would you mind running the tests (`npm test`) and fixing the one that fails?  It's actually asserting that `literalUndefined === null`! ðŸ˜† 
  @bkuri This one also fails due to the test being incorrect... oops!
  @aniruddh-a this looks like an issue with Lasso and not Marko. Do you mind moving this issue over to https://github.com/lasso-js/lasso and providing more details on your lasso version? Thanks!
 Lasso issue: https://github.com/lasso-js/lasso/issues/155
  This branch is a starting point for encouraging contributions to Marko with the following:
- [x] Highlight how to get involved in the `README.md`
- [x] Add a `CONTRIBUTING.md`
- [x] Add an `ISSUE_TEMPLATE.md`
- [x] Add a `PULL_REQUEST_TEMPLATE.md`
  @aniruddh-a and I were discussing how custom tags are discovered, and he wondered why it couldn't just be done automatically.  This might be a good idea to explore.

Essentially, it would function kinda like `node_modules` except based on the `components` directory (which has become a standard way of doing things).  The taglib lookup could search first in the current directory for a `components` directory and continue walking up to the project root to discover tags.

This actually mirrors the way that `marko.json` files are discovered and could be done in the same step.

Thoughts?

/cc @marko-js/maintainers 
 My initial reaction is that I don't like introducing too much convention since it makes things feel less flexible and introduces more magic. There's also the overhead of now looking for both a `marko.json` file and a `components/` folder. I feel like adding a `marko.json` file with a single `tags-dir` property is insignificant and it is extremely flexible. I will let others weigh in though.
 @patrick-steele-idem To reiterate what Yoni said, we already have convention within the `tags-dir`, this just takes it one step further.  I think it makes sense as a default.  ðŸ° ðŸŽ© âœ¨

@yomed This would allow a structure like:

```
/
 â¤· src/
    â¤· components/
        â¤· some-component/
           â¤· components/
               â¤· some-subcomponent/
           â¤· renderer.js
           â¤· template.marko
    â¤· layouts/
        â¤· main/
           â¤· components/
               â¤· some-layout-specific-component/
           â¤· layout.marko
    â¤· pages/
        â¤· home/
           â¤· components/
               â¤· some-page-specific-component/
           â¤· index.js
           â¤· template.marko
```

without a `marko.json` at each level.
  /CC @philidem @mlrawlings 

Not ideal, but you can using a space character: `<img alt=" ">`

With that said, I think we should revisit the rules for rendering attribute value. I think the following would be more appropriate...

Giving the following template:

``` xml
<img alt=someExpression/>
```

| someExpression | Current | Proposed |
| --- | --- | --- |
| `undefined` / `null` / `false` | `<img>` | `<img>` (no change) |
| `true` | `<img alt>` | `<img alt>` (no change) |
| `''` | `<img>` | `<img alt="">` |

While this would be a change, I am not sure it would actually break anything. Thoughts?
 @patrick-steele-idem I'd lean towards your table rather than creating a list of exceptions.

I was just testing and I think we've got some weird behavior...

`<img alt="">` becomes `<img alt>`

but

`<img alt=data.alt>` becomes `<img>` if `data.alt === ''`

This is weird, but also means that we could probably leave `alt=""` untouched if it's a string literal and keep the current behavior if it's a variable that contains an empty string as its value (if we want to).  Or maybe we should make it consistent...

@yomed Out of curiosity, is there any reason why you couldn't forgo the `alt` attribute and use `role="presentation"` or `aria-hidden`?  And does `alt` behave differently than `alt=""`?
 @yomed If you ask me, even `alt=""` is kinda a hack used to stop the screen reader from reading out the url to the image.  But `role="presentation"` or `aria-hidden` explicitly tell the screen reader to ignore it because it's for presentational purposes only.  

In any case, we should probably fix this.
 I'm in favor of updating Marko to follow the proposed table above as part of a minor release. The chances of actually breaking anything are extremely low since the worst case is that there will be an attribute with empty quotes when there was no attribute before. Any objections?
 @yomed I don't know that this is a definitive test, but here's what WAVE has to say:
http://wave.webaim.org/report#/http://output.jsbin.com/majejevelu

It would seem that `alt` and `alt=""` are equivalent.  I've also seen recommendations for an image to "be given empty/null alternative text", although they go on to show `alt=""` in examples.

@patrick-steele-idem What are your thoughts on leaving the current behavior for variables and leaving the empty string when it's specified as a string literal?

Although, it might be useful to have the behavior from the table if you're generating a list of images from something like:

``` js
[{ src="/1.png" alt="something"}, { src:"2.png", alt="" }]
```

Though I'd say chances are pretty good that given a list of images like this, they should all have `alt` content or should all have an empty/null `alt`.
 > @patrick-steele-idem What are your thoughts on leaving the current behavior for variables and leaving the empty string when it's specified as a string literal?

I would want things to be consistent regardless of whether or not the attribute value is a literal value or a dynamic expression.
  /CC @philidem @mlrawlings @tindli 

Thank you for the detailed write up, @nicolashery! This seems completely doable with some tweaks to the compiler and runtime. For example, we would need to modify the `FunctionDeclaration` AST node to support extra type information for params.

Personally, I am not yet using TypeScript. I'm not opposed to TypeScript, but I also haven't had a strong desire to start using it. Because of that, I may not be the best person to work on this. I would rather someone who is actively using TypeScript to do the coding, but I can definitely help point you in the right direction. As long as the code changes are clean and well-tested then I have no objections to this proposal.

Regarding open questions:

> Source-maps & errors: If a runtime error occurs in the generated JS, can we show the line in the .marko file that caused it?

That may be nice and I think that is  also doable without drastic changes. For example, the compiler would need to attach source mappings to parsed expressions. It's definitely something I have thought about, but we haven't had any time to come up with a formal proposal or implement it. With that said, I have found source maps to be somewhat problematic and often end up disabling them (e.g. when doing Atom plugin development with CoffeeScript). Instead, we have focused on making sure the compiled output is extremely readable. For that reason, supporting source maps has been a low priority.

> Editor integration: A nice feature of TypeScript is the auto-completion and real-time type-checking. Would it be feasible to have that directly in the the .marko file?

I would have to take a look at how TypeScript autocompletion works for other files, but I suspect this will be challenging. Maybe the template can be compiled to TypeScript and source maps could be used to generate autocompletions as the user is editing the `.marko` file? It seems like that would probably be too slow, but maybe not.

---

Please let me know if you are interested in contributing and we can discuss a plan of action.

Any thoughts from others?
 I think this will be possible once the changes here are hashed out: https://github.com/Microsoft/TypeScript/issues/6508 . They are solving some angular-2-specific problems that should also make it easier to typecheck `.marko` files, since they are pretty similar in structure.    @Hurtak this isn't actually a problem Marko can solve since putting dynamic values inside a `<script>` block is inherently unsafe. Wherever you are allowing user data to be inserted into a script block you should be using `JSON.stringify()` to ensure that it is only data and not code:

``` xml
<script>var x = $!{JSON.stringify(data)}</script>
```

In this case, HTML escaping is disabled because encoded HTML entities are not decoded if they are inside `<script>` tags.

However, if the stringified data contains an ending `</script>` tag then that will prematurely end the `<script>` block so you need to do the following:

``` xml
<script>var x = $!{JSON.stringify(data).replace(/<\//g, '<\\u002F')}</script>
```

With that said, using `<script>` tags with dynamic code is still very dangerous. It's best to put user data into DOM attributes so that it is guaranteed not be executed. For example:

``` xml
<div data-foo=JSON.stringify(data)>
```

The data can then be extracted from the DOM using code similar to the following:

```
var foo = JSON.parse(el.getAttribute('data-foo'));
```

I'm going to close this issue because it doesn't require any changes to Marko, but we should probably put together a more complete security guide.
 @Hurtak also, if you have any thoughts or suggestions on how we might be able to avoid the security problems associated with `<script>` tags please share. If we can provide a helper of some sort then that might not be a bad idea.
 @Hurtak The `escapejs` filter that django provides is a little odd since it assumes that the character being escaped inside a JavaScript string, but after giving it some thought that's probably an okay assumption. I think I'm coming around to escaping special HTML characters using the JavaScript string escape sequence in the  context of a `<script>` block. It's definitely better than the current code that escapes special HTML characters inside `<script>` blocks using HTML entities which is absolutely not what we want.

For example, given the following template:

``` html
<script>
    var foo = ${JSON.stringify(data.foo)};
</script>
```

And the given data:

``` javascript
{
    foo: {
        name: 'Evil </script>'
    }
}
```

The output is currently the following:

``` html
<script>
    var foo = {"name":"Evil &lt;/script>"};
</script>
```

(browsers do not decode HTML entities inside `<script>` blocks... `<script>` tags are special)

The output should be the following:

``` html
<script>
    var foo = {"name":"Evil \u003C/script>"};
</script>
```

I'm going to reopen this issue and investigate a proper fix. Thanks for opening this issue and thank you for your persistence :)
 New version published: `marko@3.7.1`

See [CHANGELOG.MD](https://github.com/marko-js/marko/blob/master/CHANGELOG.md#371) for a longer description of what exactly changed: 
 @yomed 

> With this fix in place, is there still any reason to avoid putting data in inline scripts? 

This was done in preparation for support CSP. However, as long as we put a CSP `nonce` attribute on the inline `<script>` tag then we are still able to use inline `<script>` tags. In a future version of Marko Widgets we plan on switching to using `<script>` tags to pass data down to the browser for performance reasons. So to answer your question, no, there is no good reason to avoid putting data in inline script tags.
  Looks good. Thanks!
  Thanks for the improvement! New version published with fix: `marko@3.6.2`

Please let me know if you see any other issues. Thanks, again.
  Hey @thomastorfs, thanks for reporting the problem. I'm going to see if I can reproduce, but if you could provide more details that would be great.
 I suspect you are seeing this issue because there are multiple instances of `marko` being loaded at runtime and each instance is being configured independently. This could happen if you have different versions of `marko` being used in your project and that would prevent de-duping from happening when installing the node modules. Do you see multiple lines for `marko` when you run `npm list`?

In either case, I decided to make the Marko configuration a true "singleton" by attaching it to the global scope. This may or may not solve your problem depending on which versions of `marko` are being loaded in your project, but once you are using only the latest version then it should fix the issue in the situation that there are multiple instances of marko being loaded.
 @thomastorfs @aaronshaf would either of you be able to share a minimal project to reproduce the problem? I was not able to reproduce the problem. Thanks!
 @jasonmacdonald thanks for digging in and figuring out the issue. I don't see any harm with passing along the configuration provided when calling `require('marko/node-require').install({config...})` to `require('marko/compiler').configure(...)` . This would make the configuration truly global as expected.

NOTE: You should not be referencing `global.__MARKO_CONFIG` in your code since that is an implementation detail that could change in the future.
  - Fixes #314 - Remove hyphens from include props
- Deprecated:
  - Properties passed in using the `<include>` tag should not be access using hyphens.

For example, given the following template:

``` xml
<include("./include-target.marko") first-name='Jane'/>
```

The `first-name` data should be accessed using the `firstName` property:

``` javascript
var firstName = input.firstName;
// NOT: var firstName = input['first-name'];
```
 Looks good!
  @patrick-steele-idem and I have discussed adding a tag to marko's core that handles streaming in an elegant way.

The syntax that we're looking at is the `<on>` tag:

``` xml
<ul>
    <on(user in data.usersStream)>
        <li>${user.name}</li>  
    </on>
</ul>
```

We'd also support a more verbose syntax for generic EventEmitters:

``` xml
<on('data' as user in usersStream until 'end')>
```

> **Note:** `<for(x in stream)>` was considered, but it would complicate the looping logic of regular for loops and require the stream logic to be present even for templates that never make use of it.  We need something that is syntactically different so we can distinguish at compile time.
> 
> **Note 2:** we also considered `<for-async(x in stream)>` and `<for await(x in stream)>` however `<on>` has the benefit of making sense when used with any EventEmitter.

In many ways, the `<on>` tag will be similar to the `<await>` tag ([previously `<async-fragment>`](https://github.com/marko-js/marko/pull/312)), however the `<on>` tag will also flush multiple times throughout it's rendering cycle.

There is a tradeoff to consider around flushing.  If we flush after each iteration, content will be pushed to the browser sooner, but if we buffer a few iterations and gzip is enabled, the resulting payload will be smaller.  We need a good default for flushing and an easy, intuitive way to configure it.  

We also need to figure out what should be provided by the tag, and what interesting use cases we want to support.  One that comes to mind immediately is infinite scrolling.

All that said, here is my proposed set of attributes for the `<on>` tag:
- `@var` - parsed from the argument, the variable to be used inside the body of the tag
- `@event` - parsed from the argument, the name of the event to listen to, defaults to "data"
- `@endEvent` - parsed from the argument, the name of the event that signifies the end of the loop, defaults to "end"
- `@data-provider` - parsed from the argument, the stream or emitter we're listening to
- `@name` - the name of the `<on>` tag.  used for debugging and the `show-after` attribute
- FUTURE: `@client-reorder` - the `<on>` tag will not block the rest of the page, JS is required on client
- FUTURE: `@show-after` - when `client-reorder` is set to true then displaying this instance's content will be delayed until the referenced `<await>` or `<on>` instance is shown.
- ~~`@buffer-count` - how many iterations of the `<on>` tag to buffer before flushing~~
- ~~`@buffer-duration` - if the time since the last flush is greater than the buffer duration, then the `<on>` tag will flush its buffer, regardless of the current buffer count~~
- `@timeout` - if the time since the last chunk of data was emitted is greater than the timeout, then the `<on>` tag will timeout
- ~~`@total-timeout` - if the time since the rendering started is greater than the total timeout, then the `<on>` tag will timeout~~
- `@error-message` - a message that is shown if the stream emits an error
- `@timeout-message` - a message that is shown if the stream times out
- FUTURE: `@placeholder-message` - a message that is shown while the `<on>` tag is streaming
- `@empty-message` - a message that is shown if the stream ends without emitting data
- `@finish-message` - a message that is shown when/if the stream completes successfully

Also, we'll provide `<on-placeholder>`, `<on-error>`, `<on-timeout>`, `<on-empty>`, and `<on-finish>` as alternatives `*-message` attributes.
 **Example time:**

Let's say we want to create a list that has a few users in it and a button to load more users.  Those users come from some service call.  With `<await>` we'd do something like this:

``` xml
<await(users from data.usersProvider) client-reorder>
    <await-placeholder>
        <card>
            <loading-indicator/>
        </card>
    </await-placeholder>
    <for(user in users)>
        <card>
            <img src=user.avatar />
            <info>
                <name>${user.name}</name>
                <handle>${user.handle}</handle>
            </info>
        </card>
    </for>
    <button>load more</button>
</await>
```

In this case, the placeholder card would spin until the data gets back from the service call, then we render the user cards and load more button and replace the placeholder with these.

With `<on>` and a stream, we could do this instead:

``` xml
<on(user in data.usersStream) client-reorder>
    <on-placeholder>
        <card>
            <loading-indicator/>
        </card>
    </on-placeholder>
    <card>
        <img src=user.avatar />
        <info>
            <name>${user.name}</name>
            <handle>${user.handle}</handle>
        </info>
    </card>
    <on-finish>
        <button>load more</button>
    </on-finish>
</on>
```

In this case, the placeholder would spin until all user cards have loaded.  As each user is emitted by the stream, a user card would be rendered and inserted right before the loading card.  Once all user cards were loaded, the load more button would be displayed and the placeholder removed.

Here's a [mockup](http://output.jsbin.com/nikifen) of the difference.
 More thoughts:

It might be useful be able to see what iteration you're on like the `<for>` tag's  `status-var`.
- Each time through the status var would contain the current iteration: `0, 1, 2, 3 ...`
- On the `end` event the status var would contain the number of iterations, similar to the way things work in a native `for` loop:

``` js
for(var i = 0; i < array.length; i++) {
    console.log(array[i]);    
}
assert(i === array.length);
```

This could be used to: 
- show a different `timeout-message` or `error-message` base on whether any data had already been rendered:

``` xml
<on(user in data.usersStream | status-var=loop)>
    <on-timeout>
        <if(loop.getIndex() > 0)>
            We timed out, but at least we got some data!
        </if>
        <else>
            We timed out and got nothing...
        </else>
    </on-timeout>
    ${user.name}
</on>
```
- In the same way, it removes the need for `empty-message`
 This sounds great! We would be able to use this right away. We're basically doing this manually in a renderer.js file ourselves now, but this is much cleaner and doesn't require us to expose all the `out.beginAsync` stuff to create our own stream.

Are there any strong feelings in making this a separate tag? Would it make sense to just have `<await>` accept a stream in addition to promises and callbacks? Or does that have mostly to do with the terminology of await in ES2017? @scttdavs The main difference, is in passing a stream to `<await>` you would need to buffer the stream until it completes, where as `<on>`'s body would be called every time a `data` event was emitted from the stream and could flush out multiple times.

I actually just [threw something together](https://github.com/mlrawlings/marko-on-tag) this afternoon because another team at eBay was asking about this.  It doesn't have any of the timeout/placeholder/buffering/flushing/etc. in place, but it's a good starting point.

I probably won't have time to revisit this for a little while, so if you're interested in working on this, that would be awesome!

/cc @rajaramu (on the aforementioned team at eBay) I think there's enough differences between handling a `Promise` vs a `ReadableStream`/`EventEmitter` that it makes sense to keep the tags separate and I think it will make things less confusing and easier to document. I could be wrong though and I might be convinced that `<await>` could be extended to support both a Promise that gets flushed once when resolved versus a `ReadableStream`/`EventEmitter` that will flush for every event. We still need to finalize this proposal before doing any work so if you have any thoughts on usage please share. I kind of like that implementation too. One concern I would have is that there's no clear way to use `<on-finish>` from Michael's example (or any of the other sub-tags).

I think `<on-finish>`, in particular, is important because given his example linked above, the one of a `load more` button below the users. What if it is not known whether there are more users to load until data from the stream comes in? In which case you may need a `load more` button or may not. So being able to render it after the steam ends when that information is available would solve that. I'll throw out another proposal:

```xml
<ul>
    <await(data.usersStream)>
        <on('data' as user)>
            <li>${user.name}</li>  
        </on>
    </await>
</ul>
``` @mlrawlings @philidem @tindli @austinkelleher @Hesulan @scttdavs  should we go forward with using `<await>` with nested `<on()>` tags (see above)? @patrick-steele-idem - I like that syntax a lot. @patrick-steele-idem I like the new proposal, especially reusing with `<await>` since the use cases seem so similar. So given that example and the new nested tag feature (which is done now?), would it look like:
```html
<ul>
    <await(data.usersStream)>
        <@on('data' as user)>
            <li>${user.name}</li>  
        </@on>
        // how is content here handled?
    </await>
</ul>
```
I also had a question in the comment above^ There's the potential argument against `<@on>` because it would need to be transformed:

`<@on('data' as user)>` would get transformed to `<@on(user) event='data'>` which would generate code like:
```js
{
    on:[{
        event:'data',
        renderBody:function(out, user) {
            out.w('<li>'+escapeXML(user.name)+'</li>';
        }
    }]
}
```

@scttdavs The rules around content outside `@` tags is a little weird...  Anything outside an `@` tag will come through as `input.renderBody`, except if there are dynamic `@` tags in which case `renderBody` is run and the `@` tags register themselves on the parent and in that case, no content output is allowed in the `renderBody`.

In the case of the `<await>`/`<@on>` combination, `renderBody` would _not_ be called.  We should probably thrown an error in that case.  _This:_

``` xml
<async-fragment data-provider=data.userDataProvider var="user">
    Hello, ${user.name}
</async-fragment>
```

_becomes this:_

``` xml
<await(user from data.userDataProvider)>
    Hello, ${user.name}
</await>
```

**Tag changes:**
- `<async-fragment>` => `<await>`
- `<async-fragments client-reorder/>` => `<await-reorderer/>`
- `<async-fragment-placeholder>` => `<await-placeholder>`
- `<async-fragment-timeout>` => `<await-timeout>`
- `<async-fragment-error>` => `<await-error>`

A transform is provided that will transform the async-fragment versions of these tags to the await version, so nothing will actually break, but a deprecation message will be logged to the console during template compilation.

This is primarily a syntax change.  All tag attributes remain the same, except that `var` and `data-provider` are now specified in the `<await>` tag's argument.

**Event changes:**
- `asyncFragmentBegin` => `await:begin`
- `asyncFragmentBeforeRender` => `await:beforeRender`
- `asyncFragmentFinish` => `await:finish`
- `asyncFragmentClientReorder` => `await:clientReorder`

The async-fragment versions of these events are still emitted, so as to not immediately break modules that make use of these events.  Those libraries should begin to migrate as we'll likely remove the duplicate events at some point.
 I forgot to mention:

Currently, the output JS looks something like this:

``` js
//...

      await = __loadTag(require("../../../../taglibs/async/await-tag"));
//...
      await({
          dataProvider: data.userDataProvider,
          _name: "data.userDataProvider",
          renderBody: function renderBody(out, user) {
             out.w("<div class=\"foo\">Hello,  "+escapeXml(user.name)+"</div>");
          }
      }, out);
//...
```

and while this actually works, I'm not thrilled about `await` being used as a variable/function name.

We could probably utilize a [list of reserved words](https://gist.github.com/mlrawlings/724cc0c3bd4635b7f6541df9526fd084) and append `Tag` to custom tags that match an item in that list.  In this case we'd have `awaitTag({}, out)`.
 Very nice and much cleaner. Thanks for working on this! The only thing that kind of bothers me is the `from` keyword...it works, but just want to make sure we explore all syntax options, what are your thoughts on reversing the syntax?:

``` xml
<await(data.userDataProvider as user)>
    Hello, ${user.name}
</await>
```

I read that as "await on `data.userDataProvider` and store the result as the `user` variable". It also is a little closer to the actual JavaScript syntax where `await` is in front of the expression that produces the `Promise`:

``` javascript
var user = await data.userDataProvider;
```

(of course, in JavaScript the variable is on the left hand side...)

I could probably go either way, but just wanted to throw the alternate option out there.

What do you think?
 Both make sense when you read them as a sentence:

```
await user from theUserDataProvider
```

```
await theUserDataProvider as user
```

`from` has the benefit of the variable name being to the left of the statement, which is closer to for loops and assignments, where as `as` has the benefit, as you said, of keeping `await` closer to the provider that it is awaiting which is how it's done in JS.

I'm kinda leaning towards `from`, but it may be just 'cause it's what I've had in my head while thinking about this... what does @tindli, @philidem, and the rest of the community think?

`as` _is_ two characters shorter than `from`...  
 So after thinking about this a bit more, I've come to the conclusion that I'm not so much awaiting the promise, because I already have the promise.   I'm awaiting what I get when the promise is fulfilled.  

In our example, the `userDataProvider` is just an means to an end.  The only reason I care about the `userDataProvider` is that it will eventually give me the `user`.  The `user` is what I really want.  I am awaiting the `user`.

If I could, I'd simply write

``` xml
<await(user)>
```

But that doesn't give enough information.  `<await>` doesn't know where the `user` comes `from`.

``` xml
<await(user from userDataProvider)>
```

Ah. Okay, it comes `from` the `userDataProvider`. Now `<await>` can get me my user.

---

Also, all feedback has either been neutral or in favor of the `from` syntax.

Let's go with `from`.
 @mlrawlings 

> Let's go with `from`.

Sounds good to me. I'll be spending a little more time reviewing and will publish a new version soon. In the meantime, would you be interested in updating the migration tool to migrate to the new await syntax from Marko v2? We should also consider making the migration tool a little smarter to look at the version of `marko` installed to determine how the code should be parsed and migrated.
  Hey @darkwebdev, just wanted to say that I haven't had a chance to investigate since I was out of the office this past week. I hope to investigate this a little later this week. Thanks for reporting the problem and thanks for your patience!
 Fixed. See: https://github.com/marko-js/marko-widgets/issues/153

Thanks for reporting the problem!
  Great. Thank you!
  Thanks for the improvement, @oxala! New version published: `marko@3.5.0`

If you get a chance, do you mind updating the following docs?: https://github.com/marko-js/marko/blob/master/docs/custom-taglibs.md 

Thanks, again
  Only set `prevClassName` when the `className` has been pushed to `finalClassNames`, otherwise future `className` values will be appended to a class that doesn't get included in the final output.  This effectively limits the number of classes to 2.
 Thanks for the fix! New version published: `marko@3.4.9`
  An attribute value needs to always follow the rules of JavaScript parsing. Unfortunately, that does introduce some deviation from the HTML spec. However, Marko is not using an HTML parser, but rather the [HTMLJS](https://github.com/philidem/htmljs-parser) parser, and the HTMLJS parser always parses an attribute value as a JavaScript expression. We would not want to special case various attributes since that would makes things problematic.

It might be helpful to think of it has having to write JavaScript code to set an HTML value:

``` javascript
var input = document.createElement('input');
input.setAttribute('pattern', '[\\w0-9]+'; 
// Note that the backslash character needs to be escaped.
```

Hope that answer satisfies your issue, but please let me know if not.
 > I understand the underlying issue. But my opinion is that when writing HTML within the template we shouldn't have to remember "no, this isn't really HTML, it's an escaped JavaScript string."

I definitely understand where you are coming from. To keep things simple we want to only support one way of parsing things and found that JavaScript expressions were a much better fit for attribute values. The only thing that you need to remember is that the right-hand side of an attribute value is always a JavaScript expression (at least it is consistent).

> I think a solution to this, and probably other cases, would be to have a <raw></raw> Marko directive.

We could, in theory, introduce a new syntax to break out of the rules of standard JavaScript parsing for an attribute value to support a "raw" value, but that would introduce more complexity and likely very little gain. Hypothetically, we could support triple quotes (borrowed from CoffeeScript) or something random:

``` xml
<input type="text"
           name="username"
           placeholder="username"
           spellcheck="false"
           autocomplete="off"
           autocorrect="off"
           pattern="""[\w0-9]+""">
```

Do you think that is worth considering? I'm leaning towards no, because I want to keep the syntax rules simple, but I am open to the idea if there is enough interest.
 /cc @philidem @mlrawlings @tindli Thoughts?
 I'm not sure adding something that deviates further from html (`=!` or anything else) to get back to html really makes sense.  

My biggest concern is that someone new to marko may not realize wha the issue is with the error presented.  Given that it's a pretty standard js error maybe this isn't really a concern.  It might be worth it if we could point out this difference in parsing when it comes up though.

I do understand not wanting to double escape.  It's a pain when you have to use strings to pass to `new RegExp()` too.  For this specific case, I think it would be nice to be able to use a js regex as the value (we'd have to remove the beginning and ending `/` after calling `.toString()`) :

``` coffeescript
<input pattern=/[\w0-9]+/>
```

Are there other attributes other than `pattern` that might parse unexpectedly?
 If we want to change the way strings are parsed, the only thing I think we should consider is changing the default.  The only change worth making is one that allows you to paste in valid HTML without any changes, otherwise it's easier to explain "strings are JS strings" rather than introducing additional syntax.

However, I'm not sure this is a good idea.  As to what other attributes this might affect, I guess the better question is where does the HTML attribute string spec deviate from the JS string spec?  Is it just that `\` needs to be escaped or are there other differences?
 One (probably bad) thought: attempt to parse as JS value, and if that fails, fall back to the HTML way of parsing attributes.
  - Adds additional event info (finished/timedout) to the data emitted from <async-fragment> tags. 
- Ensures that renderBody() is not called again if the fragment has already finished (timed out).
- Fixes `npm run test-async`
- Removes a redundant `async-fragment` timeout related test
 Thanks for the PR! New version published with fixes/improvements: `marko@3.4.7`

Still need to back port to Marko v2
 Fix back ported to Marko v2. New version of Marko v2 published: `marko-async@2.2.2`
  Thanks for reporting the problem. New version published with fix: `marko@3.4.5`

Please let me know if you still see any issues. Thanks!
  Adds coverage reporting through istanbul and coveralls.  We'll need to set up marko on [coveralls](https://coveralls.io/), but it's a pretty painless process.
 Awesome! Thank you for taking the time to do that. I have finished setting up coveralls and now we have a working badge. Thanks again!

> Did you consider using `--include-all-sources` in the istanbul command for coverage against the whole codebase?

@yomed: Would you be interested in trying that out to see if it makes the coverage more accurate?
  Thanks for the PR @mlrawlings!

New version published with improvement: `marko@3.4.2` 
  Hey @cantoine, loaded templates are stored in the Node.js require cache. Marko supports hot reloading functionality, but you need to provide a file watcher or use [browser-refresh](https://github.com/patrick-steele-idem/browser-refresh). I recommend taking a look at `browser-refresh`, you will get hot reloading for free on the server and in the browser if you launch your app using `browser-refresh`. If you don't want to use `browser-refresh`, please see the following sample app:

https://github.com/marko-js-samples/marko-hot-reload

Please let me know if you still have questions.
  Thanks for the fix to the docs! I'll publish a new version of the site now.
  Great, thank you! I'll publish the new docs now.
  When using <include> tag like so:

```
<include template="./deferred.marko" template-data="data" />
```

if deferred.marko has a widget bound to it in the `w-bind` attribute, the widget.js is not registered and invoked.
 I would not expect that to be the case. Would it be possible to set up a simple project to reproduce the problem? Or, could provide more details on your setup?
 @sidsakhadeo is this still an issue for you?
 Closing this issue.  If this is still an issue in v3, feel free to reopen.
  New version published: `marko@3.3.0`

Thanks!
  It doesn't look to be a problem in `browser.json`. The error is originally thrown by the html-js parser used by marko: https://github.com/philidem/htmljs-parser/blob/master/Parser.js#L51

@sanjeevashrivastava Are you using an older version of marko/htmljs-parser? I am not able to reproduce the problem using your exact template. Are you using an `npm-strinkwrap.json` that is locking your app to older versions of npm dependencies?
 That's really bizarre... That is the latest version of `htmljs-parser` and I am not able to reproduce with the exact version. Can you please attach your template file to this Github issue? I'm wondering if there are some Windows vs Unix line ending differences that are causing problems.
 I'm still not able to reproduce. It looks like the parser is reading the string too far for you (it's going past the ending quote for the string). I see no reason for this to happen and the test I added is passing...
 @sanjeevashrivastava do you mind spending some more time trying to isolate the problem? Some things to try:
- Put a space after the second double quote: `<lasso-page package-path="./browser.json" />`. Does that fix the issue?
- Reduce the template to the following to see if it still fails:

``` xml
<lasso-page package-path="./browser.json"/>
```
- Do you have a different `marko.json` file in the `views/admin` folder that might be causing issue? If so, can you remove that `marko.json` to help isolate the issue?

Finally, what version of `lasso` do you have installed?
 Thanks for the details. I was able to reproduce the issue using the uploaded file. I should be able to figure it out this morning now that I can reproduce. I'll update when I know more.
 Just an update. I found the issue. The htmljs-parser is not handling a [byte order mark (BOM)](https://en.wikipedia.org/wiki/Byte_order_mark) character sequence being added by your editor. BOM characters are pretty rare, but I am working on a fix to skip over those characters.

In case you are really curious, due to the BOM characters, the parser doesn't recognize the `<` character at the beginning and it is therefore parsing in concise mode. In concise mode the parser does not look for `/>`/`>` ending character sequence.
 Also, FYI:

From Wikipedia:

> The Unicode Standard permits the BOM in UTF-8, but does not require nor recommend its use. Byte order has no meaning in UTF-8.

Marko expects templates to be encoded using UTF-8. Again, we still will make the change to strip the BOM characters, but just sharing that BOM characters are not recommended in UTF-8 files.
 Fixed by https://github.com/philidem/htmljs-parser/commit/baf43d342a6263bc3955a95183a15621df767cc7

New version of `htmljs-parser` published with fix: `htmljs-parser@1.5.13`

Please let me know if you see any issues. Thanks!
  @GenaANTGOfficial when a marko template is compiled it will produce a `*.js` file next to the original file and the generation that new file is triggering a restart. The reason you are seeing the infinite restart after upgrading to Marko v3 is that Marko v3 will always recompile the template in development to avoid caching problems. You should update your `nodemon` config to ignore changes to `*.marko.js` files: https://github.com/marko-js/marko#nodemon

Or, better yet, use [browser-refresh](https://github.com/patrick-steele-idem/browser-refresh) :)
  Looks great! What are your thoughts on renaming `injectInto(express)` to `patchExpress(express)`?
 Awesome. Thank you
  I believe this is no longer needed after support for merging in `res.locals` to `out.globals` was added for Express. Closing issue.
  Good catch. Thank you for the fix!
    Thanks for the question @taecilla and thanks for the reply @davidenq! It sounds like the question was answered so I'm closing the issue. 
  Thanks for the PR but for convenience, we need to keep the docs folder as part of the npm package since the app that generates the docs for marko.json pulls in the `marko` npm package directly from npm to get the defaults. You can, of course, npm link in `marko`, but that adds a little friction. 
  Hey @bitinn, sorry for not being able to respond earlier. We definitely need to add better docs for the new syntax (we have plans to do this very soon). FYI, all of the following are equivalent:

``` xml
p - hello there, <strong>username</strong>.
```

``` xml
p
  - hello there, <strong>username</strong>.
```

``` xml
p
  ---
  hello there, <strong>username</strong>.
  ---
```

``` xml
p
  - hello there,
  strong - username
  - .
```

There are four ways to enter into HTML parsing mode:

**Option 1. HTML tag:**

```
<div>
  [this will be parsed as HTML]
</div>
```

**Option 2. HTML line after tag/attributes:**

```
div - [this will be parsed as HTML]
```

**Option 3. Single line HTML block:**

```
div
  - [this will be parsed as HTML]
```

**Option 4. Multiline, delimited HTML block:**

```
div
  ---
  [this will be parsed
  as HTML]
  ---
```

For the multiline, delimited HTML block, the delimiter just needs to be two or more characters so the following also works:

```
div
  -----
  [this will be parsed
  as HTML]
  -----
```

Sorry this wasn't explained better in the docs. Please let me know if you have any other questions. Also, please join us on Gitter if you haven't already: https://gitter.im/marko-js/marko
  Hi @jainprash, I believe that had already been fixed 12 days ago: https://github.com/marko-js/marko/issues/266

Which version of `marko` are you using?
 I believe this issue has been resolved.
  It looks like the code is being hit by the following breaking changes: https://github.com/nodejs/node/wiki/Breaking-changes-between-v5-and-v6#path

However, we shouldn't be passing in `undefined` for the path so we should fix that. I'll take a look. Thanks for reporting the problem!
 Tests for marko are passing on Node v6. Please let me know if you find any other issues. Thanks, again!
  I'm opening this issue to gauge the community's interest in a Atom plugin with advanced features that may include the following:
- [x] Smart autocompletion for custom tags and standard HTML tags ([get it](https://github.com/marko-js/atom-autocomplete-marko#marko-autocomplete-package))
- [x] Smart autocompletion for tag attributes based on tag schema files ([get it](https://github.com/marko-js/atom-autocomplete-marko#marko-autocomplete-package))
- [x] Pretty printing with syntax switcher ([get it](https://github.com/Glavin001/atom-beautify#installation))
- [x] Block commenting
- [x] Click to go to tag definition ([get it](https://github.com/marko-js/atom-hyperclick-marko#marko-hyperclick-package))
- [ ] UI component generator
- [ ] Anything else?

The more developers that are interested will help us make a stronger case for investing in this functionality.

Related issues:
- [WebStorm plugin](https://github.com/marko-js/marko/issues/272)

(I'll open a similar Github issue for Sublime Text and Visual Studio Code)
 Hey @BryceEWatson, thanks for working on the generator/scaffolding functionality. I like the setup, but I think we need to offer more flexibility and possibly provide the ability for the developer to provide their own "component template directories". As an example, not every developer is going to use `.less`. Also, I think we can simplify the code if we just provide a way to copy a directory tree while doing variable replacement (in files and in filenames, and possibly supporting conditional files as well).

As much as I dislike Yeoman, it might be worth providing Yeoman generators and piggy backing off [atom-yeoman](https://atom.io/packages/atom-yeoman).

Another option is to build a new, generic "Generator" plugin for Atom (independent of Yeoman) and there also be "Generator Provider" plugins. We could then provide a Generator Provider plugin for Marko, but other developers could publish their own. It's possible that something like this already exists, but I haven't seen it.

Thoughts?
 @Eldar-X I took on the challenge and we now have support for tag matching and synchronized editing of opening and closing tags in Atom: https://github.com/marko-js/atom-language-marko#tag-matching

There was some learning along the way, but it was a much more difficult task than expected (lots of edge cases), but I am very happy with the end result. You owe me a beer :)

As a side note, we have merged all of the Atom plugins ([atom-language-marko](https://github.com/marko-js/atom-language-marko), [atom-autocomplete-marko](https://github.com/marko-js/atom-autocomplete-marko) and [atom-hyperclick-marko](https://github.com/marko-js/atom-hyperclick-marko)) into the main [atom-language-marko](https://github.com/marko-js/atom-language-marko) package. The other packages are now deprecated and they were made into no-ops (feel free to uninstall `autocomplete-marko` and `hyperclick-marko).

Please let us know if you see any issues.
 @tinovyatkin, Patrick and I are not planning on picking up a VS Code plugin in the near future, but @pcanella mentioned he might be interested in working on one.
 @tinovyatkin I did take a look into what it would support autocomplete with VS Code and it wasn't too bad. The main difference between VS Code and Atom is that the autocomplete functionality is required to be provided as a separate process. But as @mlrawlings said, we don't plan on working that in the near future. At the moment we are busy preparing for the next major release of marko (development is happening on master).
  I'm opening this issue to gauge the community's interest in a WebStorm plugin with advanced features that may include the following:
- [ ] Smart autocompletion for custom tags and standard HTML tags
- [ ] Smart autocompletion for tag attributes based on tag schema files
- [ ] Pretty printing with syntax switcher
- [ ] Block commenting
- [ ] Click to go to tag definition
- [ ] UI component generator
- [ ] Anything else?

The more developers that are interested will help us make a stronger case for investing in this functionality.

Related issues:
- [Atom plugin](https://github.com/marko-js/marko/issues/273)

(I'll open a similar Github issue for Sublime Text and Visual Studio Code)
 > Also a default widget component files generator via right-click would be nice.

Great suggestion @wmossman. I'll update the description to include that. Thanks!
 @yask123 So far, most of our tooling effort has been focused around the atom editor (see #273).  We've not got WebStorm on our roadmap right now, and we don't have a lot of expertise with the java-based IntelliJ plugin system.  

Our hope is that a developer that is familiar with the WebStorm ecosystem could look at the atom implementation to add support for WebStorm.
 @davidmoshal Thanks for pointing this out, I believe that _is_ intentional as we don't have a true webstorm integration, but webstorm [can import tmbundles](https://www.jetbrains.com/help/webstorm/2016.3/importing-textmate-bundles.html).  We should definitely make this clearer on that page.  Thanks for reporting the problem @CestDiego. That would be a typo. In the upper right of the page you will see a "Improve this page" link. That will take you to the source markdown file if you want to clean it up. I would just remove the `var style = ;` line. If you don't have time to send a PR please let me know, but a PR would be greatly appreciated. Thanks again! 
  Hi, I have a question regarding to the usage of macro for marko@v3. I defined the following macros in `helpers.marko` and want to use it in another file. For example,

helpers.marko

```
<macro csrf-meta-tags(csrf)>
    <meta content=csrf name="csrf-token">
</macro>

<macro javascriptIncludeTag(src)>
    <script type="text/javascript" src=src></script>
</macro>
```

I want to use it in `application.marko`. How can I do this? I tried the include but it didn't work for me
 Just found out this http://markojs.com/docs/marko/custom-taglibs/
 Sorry, to reopened this again. I have some questions regarding to the usage of macro in multiple files. What is the benefit of using macro over custom-taglibs? Also for template inheritance like layout-taglib, how can I the layout can understand the data from current template?

For example,

index.marko

```
<layout-use("./layout.marko")>
    <layout-put into="title">My Page</layout-put>
    <layout-put into="body">BODY CONTENT</layout-put>
</layout-use>
```

layout.marko

```
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title><layout-placeholder name="title"/></title>
</head>
<body>
    <p>
        <layout-placeholder name="body"/>
        <custom-tag env=data.env />
    </p>
</body>
</html>
```
 If I run `marko.load('index.marko').stream({ env: 'production' })`, the layout.marko will not understand data.env right?
 Hey @hung-phan, sorry I wasn't able to respond earlier.

A macro is just inline include/partial that can only be used within the current template.

An include is a partial that is separated to a separate file so that it can be used by other templates.

A custom tag is a more powerful version of an include that allows some JavaScript code to act as the "rendering controller" for the custom tag. In addition, a custom tag can be mapped directly to a template. Custom tags also have the benefit that they are easier to use since they get registered with a tag name.

A layout is just a reusable template that has placeholders

Here's some guidance on deciding when to use what:
- Use a macro if you need to repeat some HTML within the same template
- Use an include if you need to break up a template into multiple templates and all of the files are closely related and in the same directory.
- Custom tags are almost always a better option than includes since they are the most flexible and offer better encapsulation of rendering logic. 
- Use a layout template when you have multiple pages or components that share a common layout/structure

> Also for template inheritance like layout-taglib, how can I the layout can understand the data from current template?

You an pass data to a layout template as the second argument to the `<layout-use>` tag (see http://markojs.com/docs/marko/layout-taglib/#layout-data):

``` xml
<layout-use("./layout.marko", { foo: 'bar' })>
    <layout-put into="title">My Page</layout-put>
    <layout-put into="body">BODY CONTENT</layout-put>
</layout-use>
```

The data object passed in as the second argument will be available in the layout template as part of the `data` object (e.g. `data.foo`).

> If I run `marko.load('index.marko').stream({ env: 'production' })`, the `layout.marko` will not understand `data.env` right?

You should use sparingly, but you can pass "global" data that is available to all templates. See: http://markojs.com/docs/marko/language-guide/#global-properties

Therefore, you can do the following:

``` javascript
marko.load('index.marko').stream({
    $global: {
        env: 'production'    
    }
})
```

Global data is available in all templates (even templates for custom tags) or wherever you have access to the `out`. For example: 

``` xml
<span>The current environment is ${out.global.env}</span>
```

Hopefully that answers your questions, but please let me know if you need more clarification. I'm going to go ahead and close the issue, but please feel free to reopen or add more comments here and I will take a look.
 It did resolve my problem. Thanks @patrick-steele-idem.
 @hustcer creating a custom tag is as simple as creating a `template.marko` file. 

For example:

`src/components/app-my-helper/template.marko`

``` xml
<div>
  Hello ${data.name}!This is my awesome helper.
</div>
```

That's all that is required to create a custom tag. No other files are required.

The custom tag can then be used in any directory at or below the `src/` directory. For example:

`src/pages/home/template.marko`:

``` xml
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Hello</title>
    </head>
    <body>
        <app-my-helper name="Frank"/>
    </body>
</html>
```

For more details: http://markojs.com/docs/marko/custom-taglibs/#scanning-for-tags
  @1N50MN14 The `w-preserve-attrs` attribute only works on standard HTML elements (not custom elements). You should, instead, be adding the `w-preserve-attrs` attribute to the root HTML element in the template for the `<mywidget>` UI component. Please let me know if that does or does not solve your problem.
 I believe this is a non-issue so closing. Please reopen if I am mistaken. Thanks.
  @Bluejay47 when I try to compile your exact template I get the following error:

```
An error occurred while trying to compile template at path ".../template.marko". Error(s) in template:
1) [.../template.marko:2:4] Line has extra indentation at the beginning
```

Which is what I would expect. The `<html>` tag should not be indented. The following compiles with no issue:

``` xml
<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Estimake.co</title>
        <include template="./partials/includes.marko" />
        <link rel="stylesheet" type="text/css" href="editProject.css">
        <script src="editProject.js" type="text/javascript"></script>
    </head>
    <body>
        <include("./partials/menu.marko", data)/>
        <include("./partials/footer.marko")/>
    </body>
</html>
```

Please let me know if I am missing anything.
 Indentation only matters for top-level HTML elements. Once you are within an HTML tag, the indentation does not matter as long as you are not using the concise syntax.

Do you mind messaging me on Gitter to help debug your issue? I am not able to reproduce. https://gitter.im/patrick-steele-idem
  We need to use relative URLs so that docs will be correct on different branches. Thanks.
  Hey @christensson, in Marko v3 we dropped support for `$<var_name>` (without the curly braces). Therefore, you don't need to escape the `$`, but does seem odd that having `\$` in the attribute is causing a syntax error. I'm looking into it. Thanks for reporting the problem.
 Ok, I took a closer look. It's not actually a bug in Marko. The right-hand side of an attribute is parsed as  a JavaScript expression and the string definition must follow the rules for defining a JavaScript string.

If you run the following code in your JavaScript console you will see the same error:

``` javascript
JSON.parse('"\\$foo"');

// Output in Chrome/V8: SyntaxError: Unexpected token $(â€¦)
// Output in Firefox: SyntaxError: JSON.parse: bad escaped character at line 1 column 3 of the JSON data
```

With that said, I think we can improve the error message and we definitely need to fix `marko-migrate`. I'll keep working on on this. Thanks again.
 By the way, if you want to fix your template you should update it to the following:

``` xml
<li data-bind="\\$foo" for(color in data.colors)>
```

(with JavaScript, you need to escape the `\` if you want it to show up in the output)

I'm still working on updating `marko-migrate`, but I have improved the error message produced by the parser.
 I see. I will update `marko-migrate` to ensure the following:

Input Marko v2 template:

``` xml
<div class="\$foo"></div>
```

Output Marko v3 template:

``` xml
<div class="$foo"/>
```

Thanks for clarifying.
 Still investigating and adding more tests. It appears there might be some other issues that I need to resolve.
 Took a little more thought than expected, but the `marko-migrate` script has been updated to properly handle backslash characters in front of placeholders. If you would like to try the migration again, please install the latest version of `marko-migrate`:

``` bash
npm install marko-migrate@^1.0.13 --global
```

Please let me know if you still see issues. Thanks!
  Thanks for reporting the problem. I'm looking into it.
 @lohfu I was not able to reproduce the problem using a fresh `npm install`. I tried to recreate your setup and the template is compiling as expected:

``` javascript
function create(__helpers) {
  var str = __helpers.s,
      empty = __helpers.e,
      notEmpty = __helpers.ne,
      escapeXml = __helpers.x,
      loadTemplate = __helpers.l,
      navigation_template = loadTemplate(require.resolve("./components/navigation/template.marko"));

  return function render(data, out) {
    navigation_template.render({}, out);
  };
}

(module.exports = require("marko").c(__filename)).c(create);
```
 Hey @lohfu, just wanted to check in and see if you were able to reproduce. Thanks. 
 Thanks for creating the repo... I was able to reproduce the problem and am looking into it this morning. I'll update when I know more. Thanks again.
 Hey @lohfu, I realized later that I was trying to reproduce the problem using the `<include>` tag. Once I saw that you were using a custom tag mapped to a template it was easy to reproduce and easy to fix. Technically, everything was working as expected, but it would cause problems if a transform was looking at the file extension for the `require`/`require.resolve` path and not the fully resolved path. 

Anyway, the problem was fixed. New version published: `marko@3.1.5`

Please let me know if you see any other problems. Thanks!
  Thanks for the improvements! New version published: `marko@2.10.0`
  New version published with fix: `marko@3.0.7`

Please let me know if you still see issues.
  Could you provide more details on the directory structure? It looks like `<customTag2>` is not being discovered relative to the location of the `customTag/template.marko`. Are `<customTag>` and `<customTag2>` registered in the same package? Where is your `marko.json` relative to `customTag/template.marko` and `customTag2/template.marko`? 
 That does look pretty simple. The names of the custom tags are case-sensitive. If the directory name is "CustomTag2" then the custom tag will be `<CustomTag2/>`. Is that possibly the reason that `<customTag2>` is not being found?
 I'm not able to reproduce using the following sample app:
https://github.com/patrick-steele-idem/marko-issue-259

Do you see any differences between your app and the sample app I created?
  Proposal:

``` xml

<!-- marko-concise attribute: -->
<ul marko-concise>
  li.foo - Red
  li.foo - Green
  li.foo - Blue
</ul>

<!-- <marko-concise> tag: -->
<ul>
  <marko-concise>
    li.foo - Red
    li.foo - Green
    li.foo - Blue
  </marko-concise>
</ul>
```

In both cases, output should be:

``` html
<ul>
  <li class="foo">Red</li>
  <li class="foo">Green</li>
  <li class="foo">Blue</li>
</ul>
```
 @philidem any update on this?
 The fix for this wasn't as straight-forward as I had first thought and I haven't had a chance to revisit it lately.
  I agree with you both that this is needed. I will create a repo with a few links as a starting point and add more links as I find them and hopefully others can help make it better as well.

I'm also going to push our product teams at eBay to work on some blog posts that share how we are using Marko and Marko Widgets at eBay. It will take a little longer, but I also want to gather some numbers on how many UI components our teams have created (there's a lot) so that people will better idea how heavily Marko is being used at eBay. Teams have also done some interesting things with Lasso.js as well to create webapps that have specialized content for various devices. I'll definitely keep this issue open and hopefully will have something to show very soon.

Thanks!
 That would be really awesome @regiellis. I feel like if we just can get a few people blogging, then that would help a ton with awareness. If you want, I would be happy to review any early drafts :) 
  ``` xml
<!-- you're doing something like this: -->

<macro myMacro(label)>
    <h1>${label}</h1>
    <div w-body/>
</macro>

<div w-bind if(data.rootTagName === 'div')>
    <myMacro label="Hello World"/>
</div>
<span w-bind if(data.rootTagName === 'span')>
    <myMacro label="Hello World"/>
</span>
<p w-bind else>
    <myMacro label="Hello World"/>
</p>

<!-- try this instead: -->

<${data.rootTagName} w-bind>
    <h1>${label}</h1>
    <div w-body/>
</>
```
 I also investigated this issue and while I think we could make it work, it would complicate the code for an edge case. The workaround that @mlrawlings suggested above should work so I'm going to go ahead and close this issue.
 Hey @tbashor, there was a bug in Marko that prevented the Marko Widgets compile-time transformers from working on tags with a custom tag name. This has been fixed:  https://github.com/marko-js/marko/blob/master/CHANGELOG.md#374

Please let me know if you still see issues. Thanks!
  @tbashor by any chance, do you have any intermediate `package.json` files? The taglib finder stops when it gets to the "root" of the package? The root of the package is determined by looking for a `package.json` file with a `"name"` property. I suspect that the search for taglibs is being ended prematurely due to the root directory not being as expected. FYI, here is the code that is used to discover taglibs for marko: https://github.com/marko-js/marko/blob/master/compiler/taglib-finder/index.js

Please let me know if that is the case. Thanks.
 @tbashor We did change the logic for discovering taglibs to address some problems. It's linked to from the [What's New in Marko v3](http://markojs.com/docs/marko/what-is-new-marko-v3/#marko-taglibjson-â†’-markojson), but here is the relevant Github issue with details: https://github.com/marko-js/marko/issues/224

From that description of what changed do you see any issue that would be impacting your project? If needed, we can always adjust things slightly, but from what I can tell your project should be fine as long as there are no additional `package.json` files that are causing the root directory to be different than one what is expected. Since your plugins have `package.json` files it seems like that might be the cause, but I don't fully understand your project structure.

If you are able to create a minimal project to reproduce the problem that would be helpful.
 @tbashor also, here are the relevant docs: http://markojs.com/docs/marko/custom-taglibs/#taglib-discovery
 Thanks for the update @tbashor. Let me know if you run into any other issues and glad to see that you have migrated to Marko v3. 
  /CC @philidem @mlrawlings 

I would like to see a method that returns a promise, but I would prefer to avoid a breaking change. The purpose of returning the `AsyncWriter` instance was to be compatible with the `EventEmitter` API (`on`, `once`, `emit`, etc.) that `AsyncWriter` implements. For example:

``` javascript
template.render({ hello: "world" })
    .on('foo', function(e) {

    })
    .on('error', function(e) {

    })
    .on('finish', function() {

    })
```

What are your all thoughts on utilizing the native promise implementation to provide a new `renderAsync` method?:

``` javascript
var template = require("template.marko");

template.renderAsync({ hello: "world" })
    .then(function (html) { ... })
    .catch(function (err) { ... });
```
 I'd rather modify `async-writer` to be a [thenable](https://promisesaplus.com/) by adding `.then` and `.catch`

I've seen other libraries such as [`superagent`](http://visionmedia.github.io/superagent/) and [`mongoose`](http://mongoosejs.com/docs/promises.html) implement a promise-like interface that plays well with anything that is duck-typing rather than looking at `instanceof Promise` (which is most everything due to things like `bluebird` and `q`).  

It would support both

``` js
template.render({ hello:"world" })
    .then(function (html) { ... })
    .catch(function (err) { ... });
```

and

``` js
template.render({ hello:"world" })
    .on('error', function(e) { ... })
    .on('finish', function() { ... })
```

And with async/await you'd be able to do:

``` js
var html = await template.render({ hello:"world" })
```

We could also implement a `.promise` function (or some other name) that returns a true `Promise` for cases where it is needed.

<details>
<summary>

Expand for possible implementation</summary>



``` js
{
    then(fn, fnErr) {
        var promise = new Promise((resolve, reject) => {
            var buffer = ''
            this.on('data', data => buffer += data)
            this.on('error', error => reject(error))
            this.on('finish', () => {
                try {
                    resolve(fn(buffer))
                } catch(err) {
                    reject(err)
                }
            })
        })
        if(fnErr) {
            promise = promise.catch(fnErr)
        }
        return promise
    }
    promise() {
        return this.then(x => x)
    }
    catch(fn) {
        return this.promise().catch(fn)
    }
}
```

</details>
 I like the suggestion to implement the `then` and `catch` methods on the `AsyncWriter` instance. Let's go forward with that approach.
 FYI: it should be sufficient to add the `then()` and `catch()` methods to [OutMixins.js](https://github.com/marko-js/marko/blob/master/runtime/OutMixins.js) since those mixins are added to both `AsyncStream` and `AsyncVDOMBuilder`
 NOTE: We want to follow the rules for having a consistent rendering API: https://github.com/marko-js/marko/issues/389

That is:

``` javascript
template.render({})
    .then(function(out) {
        out.appendTo(document.body);
    });
```
  Thanks for the improvement! I'll publish in just a bit
 New version published: `marko@3.0.3`

Thanks again.
  The user of the "data grid" component can pass a `renderer(input, out)` function associated with a UI component to the "data grid" component for use as a cell renderer:

_In JavaScript_

``` javascript
var cellRenderer = require('src/components/app-my-component').renderer;
```

Usage of the "data grid" custom tag within a template:

``` xml
<app-data-grid cell-renderer="data.cellRenderer"/>
```

Within the template for the "data grid" component, the cell renderer can be invoked similar to the following:

``` xml
<tr>
  <td>
    <invoke function="data.cellRenderer({ ... }, out})"/>
  </td>
</tr>
```

Let me know if that doesn't answer your question.
 We'll be simplifying this as part of Marko v4: https://github.com/marko-js/marko/issues/139

Closing this issue.
  Do you have any specific use cases in mind?  Would something like a Marko DevTools chrome extension be better suited for accomplishing your goals?
 Would be nice to have a convention for enabling "Marko Debug Mode". For example, via an environment variable:

```
DEBUG=marko node server.js
```

In debug mode, we could add extra information to templates. For example, What if we automatically added a `data-template-path` attribute to the root HTML element(s) of every compiled template?:

``` html
<div data-template-path="/my-project/components/foo/index.marko">
    <h1>Foo</h1>
    <div>
        <div data-template-path="/my-project/components/bar/index.marko">
            <h2>Bar</h2>
        </div>
    </div>
</div>
```

This information could be helpful to developers, but it could also be used to enable more advanced in-browser development tools.
 Comments might provide more info if say, `bar` includes `baz`:

``` html
<!-- Begin: /my-project/components/foo/index.marko -->
<div>
    <h1>Foo</h1>
    <div>
        <!-- Begin: /my-project/components/bar/index.marko -->
            <!-- Begin: /my-project/components/baz/index.marko -->
                <div>
                    <h2>Baz</h2>
                </div>
            <!-- End: /my-project/components/baz/index.marko -->
        <!-- End: /my-project/components/bar/index.marko -->
    </div>
</div>
<!-- End: /my-project/components/foo/index.marko -->
```
   Thanks @davidenq! I probably won't have a chance to take a closer look until next week, but I'm thinking we should stick with the componentized directory structure with a `src/components/` directory and a `src/pages/` directory. Thoughts?
 Thanks for sharing @jsumners, I updated the Hapi docs to correctly set the content type header: https://github.com/marko-js/marko/commit/951c0dc906677725e3083061dbd2ae2575205d2c 
 Added sample: https://github.com/marko-js-samples/marko-hapi  @felixsanz I think you should proceed with the solution that I recommended because `<marko-compiler-options>` is treated very special inside `Parser.js` and never gets added to the AST so I don't think @patrick-steele-idem's suggestion would help here. I would recommend setting some type of _flag_ to `true` to indicate that the next newline character should be discarded. The flag should be reset back to `false` after you processed the next block of character data (so that you don't inadvertently remove the wrong newline character).
  @yomed do your component files also live in a directory that matches the same name?

For example, do you have something like:
`my-widget/my-widget.marko`
`my-widget/my-widget.less`
`my-widget/my-widget.js`

I'm wondering if we should add one more convention that will check for `*.marko` file that has a filename (ignoring the extension) that matches the component directory?

Alternatively, maybe we can read this setting from the `marko.json` file (or `marko-taglib.json in v2)? Similar to how the directory that will be scanned to find components can be configured.

I use to name my component files similar to your convention but then I decided to embrace the Marko convention since it does have some nice benefits.

Specifically, I like these benefits of the standard convention:
- Easy to copy & paste a directory to "clone" an existing component (don't have to rename the individual files)
- The convention does help keep Marko projects similar to each other and each component has similar files.

The downside is that you might need to type a little extra into your IDE's search box when searching for file.

That said, I don't think we ever wanted Marko Widgets to be _too_ opinionated so I think we could consider allowing an alternative convention.

I would be interested to hear thoughts from others.
 You can create a `marko-tag.json` file with the following:

``` json
{
  "template": "./my-component.marko"
}
```

With that said, I am curious as to why you think there is less typing when navigating in your IDE. For example, in Atom or Sublime if I want to open a template file for a UI component I start typing a portion of the component name followed by a few letters in "template" or "marko" and then it will quickly take me to the template belong to a specific component (thanks to fuzzy matching). For example:
![screen shot 2016-02-28 at 8 05 29 pm](https://cloud.githubusercontent.com/assets/978214/13384825/d05606ca-de56-11e5-9e08-8958d7f2f1ae.png)

The only con that I am aware when not repeating the directory name is that Atom still doesn't differentiate the file correctly when there are multiple files with the same basename opened. I opened up an issue against Atom that is worth checking out: https://github.com/atom/atom/issues/7345#issuecomment-113577006

Also, there are good reasons to keep the main file named `index.js` so won't it look strange to have one file named `my-component.marko` and another named `index.js`? Also, repeating the directory name is not DRY and has all of the issues that @philidem mentioned.

Making the convention more flexible to allow a repeated directory name would introduce more file system checks so I would rather not go that route. We could, in theory, introduce a new setting that could be put in the `marko.json` file at the root of the project to change the convention or to allow a custom user resolver.

With that said, there are benefits to have more consistency within the community. For example, we would like to introduce more developer tools to scaffold out new UI components and we would only want to support one convention. How attached are you to repeating the directory name in each of the nested files? Like @philidem, I also started out with the repeated directory name in nested files, but I switched and I would never go back.
  I would be in favor of using the official reserved words for ES5 and beyond. However, maybe we should add a warning to discourage their usage and maybe also add an option to disable the warning? We could rely on a environment property as quick hack (which would require smaller code change).

For example, something like `MARKO_DISABLE_RESERVED_WORD_WARNING=true ./build.sh` (disable the warning and launch the build).
 That would be a bug if reserved words are not being allowed as property names. The intention was to only not allow reserved words as variable names:

``` javascript
// Should not be allowed:
var short = 'foo';

// The following should be fine though:
data.short = 'foo';
```

I'll add a test case to see if I can reproduce. If I am not able to reproduce I'll probably ask for more details.
  I realize I am slow to reply to this, but it's a little hard to say with the issue is. From what I can tell, maybe both the `renderer.js` and `template.marko` are not being found? I think I might need to take a closer a look at your code when you get a chance.
 @yomed I'm closing this, re-open it if it still needs to be addressed
  Thanks for PR, @scttdavs. I have backported the improvement to Marko v2 and published a new version: `marko@2.9.0`

Thanks again.
  Here's one proposal:

``` xml
<import-tag "component-a" as componentA>
<import-tag "component-b" as componentB>

<invoke-tag(foo ? componentA : componentB) name="Frank" count=30/>
<invoke-tag(foo ? componentA : componentB, { name: 'Frank', count: 30 })/>
```

The `<import-tag>` tag would import another tag _renderer function_ at compile time and the tag rendering function would be accessible using the provided variable.

The following would also work:

``` xml
<import-tag "component-a" as componentA>
<import-tag "component-b" as componentB>

<invoke (foo ? componentA : componentB)({ name: 'Frank', count: 30 }, out)/>
```

In either case, the compiled code would be probably be similar to the following:

``` javascript
function create(__helpers) {
  var str = __helpers.s,
      empty = __helpers.e,
      notEmpty = __helpers.ne,
      escapeXml = __helpers.x,
      __loadTag = __helpers.t,
      componentA = __loadTag(require("../component-a/renderer")),
      componentB = __loadTag(require("../component-B/renderer"));

  return function render(data, out) {
    (foo ? componentA : componentB)({
      name: "World",
      count: 30
    }, out);
  };
}

(module.exports = require("marko").c(__filename)).c(create);
```

Thoughts? Suggestions? Concerns?
 @yomed @tindli @philidem Thoughts?
 @mlrawlings I like your suggestion of using `<...>` to denote tag name and `{...}` to denote module. Hopefully it's not too clever but I'd use this feature!
 @scttdavs Resolving a custom tag is relatively "expensive" and requires reading from the file system and require calls really need to be analyzable via static code analysis so that things will work with a JavaScript module bundler. For the completely dynamic use case, it's best to use `<invoke>` and to just pass in the component renderer for each component.
 Closing this issue in favor of extending `<include>` to support rendering components/custom tags: [Issue #139: Allow dynamic custom tags to be used with `<include>`](https://github.com/marko-js/marko/issues/139)
   Thanks @yomed. We are very close to a alpha release and I'm excited for others to start using the new Marko! Still a few more tasks left before the first alpha release: https://github.com/marko-js/marko/issues?q=is%3Aopen+is%3Aissue+milestone%3A3.0-alpha

There were a lot of commits across marko and [htmljs-parser](https://github.com/philidem/htmljs-parser), but we now have a much more extensive test suite (well over 500 individual tests and counting for marko, marko-widgets and htmljs-parser) so I feel free confident that things will work as expected.

We hope to have an alpha release early next week and the migration tool will come a little later. 
  This is the first time I have heard about this, but I have not had to a lot of development for mobile. Without actually trying to reproduce, it would appear that @yomed is right and that maybe Safari is not recognizing the elements as clickable and is not bothering to emit an `onclick` event. Here is the relevant section in the Safari developer docs:
https://developer.apple.com/library/ios/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html#//apple_ref/doc/uid/TP40006511-SW6

It appears that a workaround might be to attach a dummy `onclick` handler:

``` html
<span onclick="void(0)">...</span>
```

@pcanella or @yomed can either of you verify the dummy `onclick` workaround?

We actually make the decision at compile-time on whether or not to use event delegation or direct event listeners based on the event type: https://github.com/marko-js/marko-widgets/blob/526a04f46bcdbd292a46572c34fdb1b4a305bc08/taglib/TransformHelper/handleWidgetEvents.js#L123-L137

We could special case the `click` event and add code to do a direct event listener in mobile Safari and rely on event delegation in all other browsers.

If more details can be provided then we can definitely look into some possible fixes. Thanks for reporting the problem.
 For the record, adding `onclick: pointer;` to the style of your element causes Safari to trigger a click event when you touch it on mobile.  Nice to see that you are digging into the code for the Marko v3 compiler :)

I understand why you are expecting a different output, but the reason you are seeing the behavior that you are seeing is that at parse time we build all of the nodes in the AST based on the tag definitions and we associate the code generator when the node is initially created. Therefore, when the Marko parser encounters the `<div>` node it is creating an `HtmlElement` node and the `HtmlElement.prototype.generateHtmlCode` method is being used as the code generator for the node. Changing the tag name does _not_ change the code generator and I think it is best to keep that way. However, you can create a new replacement node in your transformer (instead of modifying the existing node):

``` javascript
module.exports = function transform(el, context) {
    console.log('CALLED TRANSFORM')

    if (el.getAttributeValue('transform')) {
        var newTagName = 'new';
        var newAttributes = {
            foo: context.builder.literal('bar')
        };

        var newEl = context.createNodeForEl(newTagName, newAttributes);
        el.replaceWith(newEl); // Remove the old HtmlElement out of the tree and replace it with the new one
    }
}
```

NOTE: I just added the `replaceWith(newNode)` method as a convenience method (see https://github.com/marko-js/marko/commit/2ce5493c9afaa1389f943946bc7e4d19ddf134b1) You will need to pull the latest code if you want to test the above code.

Hope that makes sense. Please let us know if you have any other questions/thoughts/concerns. Thanks!

I'm going to go ahead and close this issue, but feel free to respond here.
  Why are you bundling the Marko compiler? I feel like all that should be bundled are the compiled templates and the marko runtime.
  Hey @stevus, it looks like you are using browserify to build a JavaScript bundle to be loaded on the server (not the browser). That's not the normal use case and it breaks "dynamic" requires. However, let me see if I can put in a workaround for you. 
 Fixed. See: https://github.com/raptorjs/raptor-logging/issues/4

New version of `raptor-logging` published: `raptor-logging@1.0.8`

Please let me know if that works for you. Seems reasonable what you are trying to do, but you might run into edges like this again.
  With a few tweaks to the current parser, we could simultaneously support a new concise, Jade-like syntax. A sampling of the proposed syntax is shown below:

``` xml
<!-- Basic JavaScript constructs -->
var colors=['red', 'green', 'blue']

<!-- Placeholders, looping and conditionals -->
ul if(notEmpty(colors)) 
    li for(color in colors)
        | <b>${color}</b>
div else | No colors!

<!-- Custom tags with wrapped attributes -->
greeting [name="Frank"
    message-count=10]

<!-- Macros -->
macro navLink(href, title, isActive)
    li class=(isActive ? 'active' : null)
        <!-- HTML-JS parsing mode in the same document -->
        <a href="href">
            ${title}
        </a>

ul
    navLink href="/" title="Home" isActive=true
    navLink('/about', 'About', false)
```
 From various interactions I have found that there are a lot of people who would consider using Marko, but much prefer the Jade syntax. On the flip side there are a lot of developers that dislike the Jade-style syntax because it is too far removed from real HTML.

With that in mind, Marko has a lot of benefits that are independent of the input syntax/dialect:
- High performance and minimal runtime
- Custom tags
- Extensible at compile-time
- Async rendering
- CommonJS modules as compile output
- Marko Widgets support
- etc.

The input template is relatively small (but important) piece of Marko. I believe that if we can offer a Jade-like dialect for Marko then we will be able to attract additional developers to the project.

It's of course worth pointing out the negatives of supporting an alternate dialect:
- Fragmentation within the Marko community
- Development cost of supporting a two dialects (hopefully a minimal, one time cost)

Regarding "Fragmentation within the Marko community", my thinking that is better to grow the community. In addition, I want to keep the two dialects very similar such that there is a direct and perfect translation between the two. In fact, we could easily provide tools for converted from one dialect to the other with no change in behavior or loss of information.

Regarding "Development cost of supporting a two dialects", I do feel like development effort is not too burdensome and it will be a single parser that supports both dialects.

We are leaning towards using an alternate `.jarko` file extension for Marko with the Jade-like syntax. All of the Marko documentation would use the non-concise syntax and there would be one page of documentation that would explain the rules for the concise syntax for those who want to use it.

I opened the issue to invite discussion so if you have any other thoughts please share.
 I was on the fence about this at first but there a lot of people that are passionate about Jade so there must be some merit for its success. One of the subtle but elegant things about the _jarko_ dialect that has been proposed is that you could drop in normal HTML or Marko and it would just work because the parser would know to switch to HTML/Marko mode when it sees an opening tag.

If Jarko was available, I would definitely give a try to see if it would grow on me. I might enjoy not having to type all of those `<` and `>` characters.

Also, does anyone feel like the _Jarko_ name is a bad idea? Could it lead to confusion? The alternative might be that we refer to it as _concise Marko_ but I am not sure if that is better.
 Initially I didn't think it was a good idea, but I feel like the concise syntax might grow on me as well. It would need proper editor support for good syntax highlighting. I suspect that if I were to use the concise syntax then I might have a hard time switching back to the non-concise syntax. I like that the concise syntax allows the normal HTML syntax to be mixed in. This allows regular HTML to be pasted in without having to take the time to reformat it.

I'm very curious to se what the community thinks as well. I'm willing to put this out there as an experiment to see what others gravitate to.
 I am aware of the rename to "pug" but a lot of people are still going to remember it as Jade. The name "mug" was also proposed (which kind of fits in nicely with the coffee/java/javascript theme).

What are your thoughts on "mug" as the dialect name?

As far as as the development effort to support another dialect, I think @patrick-steele-idem has done a lot of great work to make the effort minimal so I don't think that is a big concern (but maybe we'd learn differently after experimenting a little). The event-based parser would emit the same events for both dialects so might not be that bad.
 > There are only two hard things in Computer Science: cache invalidation and naming things.
> 
> -- Phil Karlton
 As @tindli mentioned. We have no intentions to get rid of the HTML syntax. We are only trying to figure out if the HTML dialect can coexist with the concise syntax. We have the following options:
1. Only allow concise syntax for a separate file extension (e.g. `.jarko`)
2. Allow concise syntax and HTML syntax in same file (starting out in concise mode is probably the only good option)
3. Don't bother with concise syntax at all

Supporting mixed dialects in the same file (option 2) almost works perfectly exactly when a developer who prefers HTML wants to put plain text at the root (outside an HTML tag). The parser would need to start out in concise mode and that would cause the first word of the plain text to be "incorrectly" interpreted as a tag name (it needs to be prefixed)

There's also still some debates around the concise syntax. @tindli pointed out that `.` might be a better choice since you don't have to press the shift key (easier to type). I would much prefer to avoid the shift key.
 > I was under the impression that Marko was designed to adhere to the Rule of Least Power. By promoting Jade, it's no longer adhering to that rule.

@danrichman For Marko v3 syntax and the concise Jade-like syntax would parse into exactly the same AST (the same internal representation). Therefore, there would be no difference in power. The Jade-like syntax is just HTML without `<` and `>` and indentation is used to control nesting and there is one extra prefix symbol to escape out of indentation mode...everything else is identical. Neither dialect brings any extra power to the table.
 > @patrick-steele-idem Isn't there more to Jade than that? Conditionals, extends, etc. Wouldn't Jade developers just end up demanding those more powerful features?

@danrichman maybe starting this conversation with "Jade" was a bad idea. We are less interested in the features of Jade and more interested in the concise syntax that it offers.

> Wouldn't Jade developers just end up demanding those more powerful features?

Marko has all those features (and more) already, but in just a different form. For example, Marko doesn't have support for an `extends` keyword, but it does offer a `layout` taglib for doing the same thing in a cleaner and more extensible way (I would argue, at least). Marko has conditionals, looping, custom tags, etc.
 Good points @danrichman 

Maybe we should deviate more from Jade to make the distinction clear. We are not trying to be Jade (I think the rules for Jade are overly complicated and error-prone), but we are trying to potentially appeal to people who like a minimal syntax and that don't like typing a lot of redundant symbols.

I'm going to give the concise syntax some more thought over the weekend and will share more later.

Thank you, all, for your feedback!
 @danrichman thanks for pointing us to the Angular discussion. I imagine it might be more confusing using two distinct templating engines (not just different dialects) to build a page as is the case when doing server-side rendering of page built for Angular. I was never a fan of Angular because of the inability to pre-compile templates and I think they kind of created that problem themselves and I don't think they have a good solution. I don't think Marko has that issue since the client and server templating language will be same (regardless of whether it's the concise or non-concise dialect).

Thanks @scttdavs! Good to hear from the Jade camp :) I've always had an easier time reading HTML with all of the extra braces but I am sure that is more due to what I am use to. I think I have always rationalized typing a few extra characters for the sake of readability. It might be time to retrain my brain so that I can get faster readability and less typing.

I'm still in favor of offering a new concise syntax as an experiment and give people the challenge to try it for a little while to see if we can change some opinions. I'm curious how my own productivity would be impacted...
 Thanks for sharing your thoughts @scttdavs 

> But then again, I've used haml and jade for years, so the HTML like syntax seems like a step backward to me.

I have heard a lot of similar comments from people who like Jade. From what I have gathered, those who have used Jade or HAML (and stuck with it) would have a really hard time going back to HTML. 

For my own benefit, I took the time to find some real world Marko templates from the eBay code base and converted them by hand over to the concise syntax. I picked samples that were on the large/complex side and am finding that the HTML-based templates just look more complex than they really are and it takes me longer to make sense of the code. I'm starting to feel that the concise syntax is something that can grow on you, but that most people (me included) initially dislike it. I'm going to continue to experiment with the concise syntax. Thanks again for sharing your thoughts.
 Hey @danrichman, I definitely understand where you are coming from and share your concern about documentation.

As a point of comparison, Markdown is kind of a similar story. Markdown is a concise version of HTML, but it lets you drop into HTML mode at anytime. Therefore, with Markdown you can use the concise Markdown syntax to produce HTML documents or you can use regular old HTML. With that approach you kind of get the best of both worlds and everyone is happy. The HTML within Markdown files is in no way limited by the support for a concise Markdown syntax. It's worth noting that you can't switch to concise Markdown mode within an HTML tag.

What if Marko supported something similar and allowed both concise HTML and regular HTML within the same Marko file? This could not be done with a plugin and, instead, it would require a more flexible template parser. Sure, you could use two separate parsers (or two separate plugins), but that would be a lot of duplicate code when one happens to be a superset of the other (assuming blended mode).

If we want to ever support the blended mode within the same `.marko`  file by _default_ then it would need to happen before the next major release. The benefit of supporting the blended mode by default is that we would have a consistent file extension (i.e. `.marko`) that "works for everyone". We have until the v3 release to decide.

If we are good with not supporting a blended mode, then we could release support for a blended mode using a different file extension at any point in the future (or never).
 Hey @danrichman. That would be awful if periods were required for regular HTML, but fortunately that option is not on the table :) With mixed mode support, the following document would be a completely valid Marko template and parse hopefully as you would expect:

``` xml
<div class="something">
  <!-- Everything inside this tag will be parsed as HTML -->
  <h2>Heading 2</h2>
  Some <b>bold</b> text. Some <em>emphasis</em>.
  <div class="something-else">
    Good thing there are no
    more periods.
  </div>
</div>
<!-- You can also use the concise, indentation-based dialect in the same document!: -->
div class="something"
    h2 - Heading 2
    - Some <b>bold</b> text. Some <em>emphasis</em>.
    div.something-else
        ---
        Good thing there are no
        more periods.
        ---
```

NOTE: The sample template above uses the latest syntax that I am experimenting with. It has a lot of advantages over Jade and should feel very natural.

Does that look good to? Best of both worlds?
 @danrichman There will never be periods. I think the following sample template would be what you are looking for and it would also be completely valid:

``` xml
#another-div
    <div class="something">
        <!-- Everything inside this tag will be parsed as HTML -->
        <h2>Heading 2</h2>
        Some <b>bold</b> text. Some <em>emphasis</em>.
        <div class="something-else">
            Good thing there are no
            more periods.
        </div>
    </div>
    span.foo - Hello ${data.name}!
```

The above Marko template would render the following HTML:

``` html
<div id="another-div">
    <div class="something">
        <!-- Everything inside this tag will be parsed as HTML -->
        <h2>Heading 2</h2>
        Some <b>bold</b> text. Some <em>emphasis</em>.
        <div class="something-else">
            Good thing there are no
            more periods.
        </div>
    </div>
    <span class="foo">
        Hello ${data.name}!
    </span>
</div>
```

The problem with Jade is that you can't simply paste in valid HTML code into a Jade document and expect things to work. We can definitely do better than Jade. If we get this right then I see no reason why anyone would want to use Jade.
 Marko v3 now supports mixed mode parsing to allow the concise syntax and the HTML syntax within the same document. When the alpha release is published (hopefully soon) we will continue to gather feedback.

All docs will continue to use the HTML syntax since that is more approachable to new users.
  Hey @grawlinson, it looks like you are expecting well-formed XML as output (not HTML). is that correct? The `<meta>` tag happens to be defined by the HTML grammar as a self-closing/open-only tag. Marko defaults to HTML mode. If you want well-formed XML as output, then you should use the `.marko.xml` file extension which may not be documented :/ Please let me know if that works for you.
 Hey @grawlinson, you need to install the Node.js require extension for `.marko.xml` by doing the following:

``` javascript
require('marko/node-require').install({ extension: '.marko.xml' });
```

Without that line, Node.js is trying to load your `.marko.xml` file as a JavaScript module. Please let me know if that solves your problem or if you are still facing issues.
  It definitely needs some improvement.  It needs to be more of a tutorial rather than a list of features that a beginner might find useful.

I like the idea of filename labels.  I think we could create a nice widget (using Marko of course) that could take a directory path and create the widget from that.  Maybe it could be generated from a gist so that users on reading on github would still be able to view code snippets.  Maybe that's not worth it and they should just read it on markojs.com.
  Several people have asked about the security implications of allowing end-users to edit Marko templates. I too have wished for this ability but have held off allowing it because it is currently unsafe. We should assess the options for loading and running templates within a sandbox. Examples of unsafe template code includes scriptlets (e.g. `{% process.exit(1) %}`) and JavaScript expressions (e.g. `<div if="process.exit(1)">`). Also, the CommonJS/Node.js `require` function is currently exposed to the template which would allow the template to access the module cache (this is dangerous).

Two ideas have been proposed to support this:
1. Use the Node.js built-in `vm` module to load and run Marko templates within a sandbox
2. Staticly analyze the Marko template source code to find unsafe code and prevent compilation or provide whitelist of tags and features that can be used in sandbox mode

Personally, I think option `2` (static analysis) would be too error-prone but it is worth exploring.
 Hey @AminaG what option are you leaning towards (sandbox or static code analysis)?
 One thing not mentioned by @philidem is that the `out` could leak potentially sensitive objects if you are not careful. For example, if you render to the HTTP response stream in an Express app then you could do the following:

``` javascript
var res = out.stream;
var app = res.app;
// User now has a reference to the Express app instance
```

This can be avoided if you don't render directly to the HTTP response. For example:

``` javascript
template.stream(templateData).pipe(res);
```

You also have to be careful with data stored in `out.global` (see: http://markojs.com/docs/marko/language-guide/#global-properties).

Just wanted to make note of these subtle but important details for future reference.
 I think vm2 spawns a new process which is a good option for most security.
What if we used web worker? They might have sufficient isolation as well.

On Mon, Dec 28, 2015, 12:29 PM AminaG notifications@github.com wrote:

> I prefer sandbox via vm or vm2 (https://github.com/patriksimek/vm2).
> Regular VM, of node can make the entire process not responding while
> (true) {}.
> 
> â€”
> Reply to this email directly or view it on GitHub
> https://github.com/marko-js/marko/issues/192#issuecomment-167607882.
 I'm also leaning towards the sandbox (at least for now). Fortunately, the runtime for marko is tiny. All template loading happens in the following two functions: https://github.com/marko-js/marko/blob/de673d362e993263a926bf40d34f018aa6320ccf/runtime/loader.js#L33-L69

Once you have the source, you will need to load the source in a separate sandbox and you will need to provide your own pseudo globals: `require`, `module`, `__dirname`, `__filename`

The sandbox will not have the Node.js module loading system but you will need to shim in a fake module loading system for marko to work.
 I'm not convinced vm2 is completely needed, but out-of-process rendering of templates is possible (rendering will have to be async). 
 Marko doesn't depend on any globals.

You would just need to load the marko runtime in the separate process. However, it is challenging to load the marko runtime without the Node.js module loading system. For that reason, I think it is better to use an in-process sandbox and have the runtime be loaded outside the sandbox, but to have the template be loaded within the sandbox. If you want to try and load marko without a module loading system in a separate process then that will definitely be the safest, but it, again, it will be more challenging without the Node.js module loading system.
 I think the JavaScript API should provide a sandbox option and if true then
behavior can be different due to the additional constraints. I don't think
we have to worry about globals not working on sandbox. Also the global data
could be stranded and sent to other process.

On Mon, Dec 28, 2015, 12:36 PM AminaG notifications@github.com wrote:

> Out-of-process will make all global not works. It is break-change. Can we
> do that kind of break change to Marko?
> 
> â€”
> Reply to this email directly or view it on GitHub
> https://github.com/marko-js/marko/issues/192#issuecomment-167608790.
 Yes, that is a good suggestion @AminaG :

``` javascript
var template = require('marko').load(src,{secure:true})
template.render(templateData, stream)
```
 @AminaG this definitely can't be a breaking change. The "sandbox" functionality should be an opt-in only and that option should only be recognized on the server.
 Looking more closely at vm2 I see that there is support for a Node.js module loading system. That makes vm2 more applealing.
 @AminaG There are timeouts, but they are only for async timeouts (not CPU bound loops).
 My recommendation is to go forward with [vm2](https://github.com/patriksimek/vm2), but to allow the sandbox to be more pluggable and flexible. It is better if `marko` does not have a direct dependency on `vm2`. Something more like the following:

``` javascript
var NodeVM = require('vm2').NodeVM;

var options = {
    console: 'inherit',
    sandbox: {},
    require: true,
    requireExternal: true,
    ...
    requireRoot : "./"
};


var sandbox = new NodeVM(options);

var template = require('marko').load(templatePath, {
  sandbox: sandbox
});

template.render(templateData, ...);
```

Timeout only makes sense for the render method, but that is not supported for vm2. You would have to use an out-of-process solution for that.
 Just realized that vm2 doesn't allow you to whitelist external modules (only native modules)... Really??
 From the docs:

> IMPORTANT: Timeout is only effective on code you run trough run. Timeout is NOT effective on any method returned by VM.
> IMPORTANT: Timeout is not effective for NodeVM so it is not immune to while (true) {} or similar evil.

Therefore, timeout would not be effective for the `template.render()` method.
 > Maybe it is possible to add modules to VM2 context using the sandbox option, instead of requiring it:

That's possible, but it would mean that the templates would need to be compiled differently if they are loaded sandbox mode. It's worth exploring.
 My guess is that everything in the vm2 sandbox has to be serializable since
it gets sent to other process but maybe I'm wrong.

On Mon, Dec 28, 2015, 12:57 PM AminaG notifications@github.com wrote:

> Maybe it is possible to add modules to VM2 context using the sandbox
> option, instead of requiring it:
> 
> sandbox={marko: require('...'), `marko-async`:require('marko-async')}
> 
> What do you think/
> 
> â€”
> Reply to this email directly or view it on GitHub
> https://github.com/marko-js/marko/issues/192#issuecomment-167614396.
 Hey @philidem, I think you misread. The vm2 sandbox is in the same process.
 > vm.call('setTimeout(function(){process.exit()},60000)')

I don't see how that helps. Also, `process.exit` won't be available in the sandbox :)
 vm2 is not a lot of code. May be worth forking and improving to add support for whitelisted external modules. Basically, for any required module file, search up the directory tree to find the parent package name and check if that particular package has been whitelisted.

Only problem (for me at least) is that vm2 is written using CoffeeScript... 
 Actually, after giving it some more thought, vm2 is probably good as-is. As long as the native Node.js modules (`fs`, `process`, etc.) are blocked then I suppose there really is no security risk. I can see the reasoning for only supporting whitelisting of native Node.js modules.
 Actually, I take that back, a non-native module might have a native binary built from C++ that could be an attack vector. I suspect that those those non-native binaries would still be allowed to be loaded when using vm2, but I could be wrong.
 If you go with the out-of-process solution, then, yes, the template data needs to be serializable to JSON. vm2 is in-process so I don't think passing in helper functions or using data from closures is a problem.
 I recommend trying out vm2 further. If we run into limitations, we can always improve vm2, but I still think vm2 is in the best direction.
 @AminaG 

> So, there is any solution how to to stop vm2, in case of infinite loop

Yes, you need to invoke the `template.render()` method using the `vm.runInThisContext(code, { timeout: 999 })` method or `script.runInContext(contextifiedSandbox, { timeout: 999 })`. Using the latter is recommended since it can be used to execute a precompiled script (i.e., faster). See: https://nodejs.org/api/vm.html#vm_new_vm_script_code_options

UPDATE: It looks like vm2 may not expose the underlying `vm` interface, so that might require a fork.
  Currently, compiled templates are written next to the original file. It might be nice to offer the ability to place compiled templates in an alternate root directory. For example:
- `my-app/.marko-compiled/src/components/foo/template.marko.js`
- `my-app/node_modules/some-installed-package/.marko-compiled/src/components/bar/template.marko.js`
 @adammcarth I don't think putting compiled templates directly under the `node_modules` is the best choice since it I think it is an abuse of that folder and would not be expected by end users. I think putting compiled templates under a `.marko-compiled` directory at the root directory of the package associated with the template is the right thing to do. Yes, you would have to make sure that directory is included in `.gitignore` but I think that is okay.

NOTE: I adjusted the original text because there was a typo.

As a side note, one of the potential benefits of compiling a template and keeping it right next to the original file is that as a package prepublish step you can pre-compile all Marko templates, delete the original Marko template files (temporarily) and all of the requires would work and return the precompiled template. That is, if you you have a `require('./template.marko')` call in your code, Node.js will first look for `template.marko` and not find it and then it will look for `template.marko.js` and find that. That way, you can use the Node.js require extension for Marko during development, but when you publish your package you would only publish the pre-compiled templates (not the original Marko source files) and it would not be required for a user of the package to install Marko's Node.js require extension.

Thoughts?
 The current thinking is that we can make this an option by introducing a new configuration option in `marko.json` similar to the following:

``` json
{
  "compiled-output-dir": "./.marko-compiled",
   ...
}
```

After updating the compiler for Marko v3 and working on this task it became clear that we won't actually be able to directly load the template from the alternate directory. We would merely be writing it disk at the alternate location for reference purposes (and possibly to avoid recompiling in production). The stack trace would still need to match up where the original `.marko` file is on disk in order for any `require()` calls to work as expected.

It's also a little unclear if this setting would be applied globally. Currently, we only search up to the root of the package to find a `package.json` file so installed packages would currently not share the option if it comes from a `marko.json` in the root package. We might need to consider other options if we want the configuration option to also apply to all installed packages.
 This is not on our roadmap, but we're not opposed to it if someone from the community would like to tackle it.  If you want to take a stab, let us know and we'll help if necessary.

As far as directory naming, I think a sensible directory would be `.cache/marko` since Lasso and other modules already use `.cache/` to store cached files so this way we're not cluttering the top level directory.
  Hey @tropperstyle, thanks for the PR. I'll fix the jshint error that your code introduced and publish a new version. Thanks for the improvement.
 Hey @tropperstyle. I updated the code so that it still only did one pass through the directories: https://github.com/marko-js/marko/commit/a55f3bb82b2cc232903373afd6af3a654fea5299

New version published: marko@2.8.0

Please let me know if you find any issues with the new code. Thanks!
  Hey @patbegg, thanks for reporting the problem. I'll take a look into it. What version of npm are you using? 

_EDIT: Didn't notice the npm version in the issue title. Please disregard :)_
 Hey @patbegg, are you sure `marko-layout` is not being installed? I wasn't able to reproduce the problem with the latest npm version (v3.5.1). The latest version of `npm` flattens all of the installed `node_modules`. If that is the case then you should find `marko-layout` as a child of your top-level `node_modules` directory and that is perfectly fine. 

If you were using an older version of `npm` and then later switched to a new version of `npm` then I suggest forcing a recompile of all your templates since the directory structure may have changed and the compiler might need to recalculate relative paths that get generated. You can force a recompile using either of the following approaches:

Option 1) Force a recompile of templates by setting the `MARKO_CLEAN` environment variable to `true` (recommended):

```
MARKO_CLEAN=true node index.js
```

Option 2) Use the `markoc` command line utility to delete the generated `*.marko.js` files:

```
markoc . --clean
```

Please let me know if that solves your problem. Thanks.
 Hey @patbegg, glad that solved your problem.

If you know the directory structure is exactly the same on both machines then it is okay to copy over the compiled templates. If there is any chance that the directory structure will be different then I would just not copy the compiled templates and, instead, have them be lazily compiled on the target machine as you did.

How about we open another issue to track the docs improvement? I'm going to go ahead and close this issue for now. 
  Hey @ashishcpatel2, thanks for reporting the issue. I'm not going to have a chance this weekend to take a look, but I'll take a closer tomorrow. I'll update you as soon as I know more. Thanks again.
 Hey @ashishcpatel2, just wanted to provide an update that I was able to reproduce the problem and I have added a test case. It looks like things almost worked, but there is a bug in the taglib loader that is preventing the deeply nested tags from being properly registered. I am still investigating to see what is required to be changed to support deeply nested tags.
 Hey @ashishcpatel2, I pushed a fix to allow nested tags to be arbitrarily deep.

New version of marko published: `marko@2.7.31`

Thanks for your patience. Please let us know if you run into any other issues. Thanks for your help. 
  I like the idea of using **01. Configuration File**. As a slight variation, I would recommand `.marko` (not `.markoc`) because I don't it's necessary to distinguish between Marko runtime and compile-time options.

I know that @patrick-steele-idem is hard at work on Marko v3 so maybe we could target this feature for that version?
 And, regarding having a separate `marko-taglib.json`, I'm actually liking your idea of converging on a single file. This would also make the compiler a little simpler since it wouldn't have to look for two files when looking for configuration.

The only downside with using something like `.marko` is that files that start with "." are ignored by default in Unix-like operating systems. Maybe `marko.config`, `marko.config.json` or `marko.json` instead?
 Thank you for sharing your detailed thoughts, @adammcarth and @philidem! 

:+1: on `marko.json`. After giving it some more thought I'm also in favor of using `marko.json` to both register custom tags and provide compiler configuration.

I'm also in favor of requiring that this file be placed in the root directory of the package. Currently we allow `marko-taglib.json` to be placed in any directory and the compiler just searches up from the template file. This works, but it introduces the overhead of searching the file system and it also results in marko searching outside the main project's directory which is not good.

I also agree that we should wait until the next major version of `marko` to make this change since it is a breaking change, and we have wanted to revisit taglib loading anyway. I'll add this to the roadmap (which still needs to be written up and formally shared).

If you have any other thoughts or suggestions please share. Thanks again!
 Supporting `require('marko').configure({})` is not bad, but the problem is that if the command line compiler is used to compile a template then it won't be configured the same way. Ideally, configuration would all be loaded declaratively from files. The only problem is if configuration needs to be environment specific.

> I don't like the idea of messing with Node's require function, so I don't use marko/node-require. I use marko.load() for loading templates.

Longer term, I would like to see an npm `prepublish` step that modifies all code as such:

_Before:_

``` javascript
var template = require('./template.marko');
```

_After:_

``` javascript
var template = require('./template.marko.js');
```

With that approach, you still get the convenience of requiring a template, but you don't have to worry about installing the require extension for production usage and third party packages wouldn't depend on the Node.js require extension for Marko. The Node.js require extension for Marko is only there for convenience because it allows for less code to load a template:

``` javascript
var template = require('./template.marko');
var template = require('marko').load(require.resolve('./template.marko.js'));
```

In this case, I think it is better to be pragmatic instead of worrying about violating some Node.js tenet. The fact is, Marko is really just a transpiler that takes your Marko template file and converts it into a CommonJS module that Node.js can load and that is compatible with any JavaScript module bundler. The Node.js require extension for marko is just doing the transpiling on first require. Babel provides a Node.js require extension for ES6 transpiling.
 Global configuration is now supported by:

``` js
require('marko/compiler').configure({ writeToDisk: false, preserveWhitespace:true });
```
  Hey @adammcarth, thanks for the question. That is something we have thought about, but we decided _not_ to build an Express view engine for various reasons:

The Express view rendering engine only supports callback-style view rendering that is not compatible with streaming. As a result, the Express view rendering engine has worse performance and less flexibility. On top of that, the Express view rendering engine includes its own view resolving code (instead of just using the Node.js module resolving code) and it requires global/app-level configuration to make everything work. Finally, the Express view rendering engine introduces a new way to render a template that only works on the server and only with Express. The Express view rendering engine, while simple, is far more complicated than just rendering a template directly to an HTTP response stream. The only drawback to not using the Express view rendering engine is that if your templates or view rendering code needs information associated with the incoming request then you must manually add that data to the template data (possibly using [$global](http://markojs.com/docs/marko/language-guide/#global-properties)). I guess another possible "drawback" is that you need to require in the template in the view controller code, but I see that as a good thing since it promotes modularity.

I wrote a blog post on this topic that you should check out as well: [Bypassing Express View Rendering for Speed and Modularity](https://strongloop.com/strongblog/bypassing-express-view-rendering-for-speed-and-modularity/)

Hope that answers your question! Let us know if you have any other questions. Thanks again.
 Hey @adammcarth, glad you found that article helpful. Pretty much every product team at eBay building webapps on the Node.js stack have adopted the modular directory structure and the feedback has been very positive. I also see a similar trend with other frameworks and libraries.

For a blog post, I think that directory structure looks good. A page typically has a top-level route associated with and it will typically have a unique page controller and page template. For the [markojs.com blog](http://markojs.com/blog/), there are a set of pages associated with the blog that you can take a look at: https://github.com/marko-js/markojs.com/tree/master/src/pages/blog

Those pages each have a corresponding route. I prefer to put all of the routes in a single place so that anyone looking at the application source code can quickly figure out which routes map to which pages.

The layout taglib is used to separate out page layout from page content in cases where you have multiple pages that share a common layout. For example: https://github.com/marko-js/markojs.com/tree/master/src/layouts/default

I hope that helps.
  Hey @leonli, sorry for the delayed response, but better late than never...

What I found works well is to also require non-JavaScript module dependencies in your component's `index.js` file as shown in the following code:
https://github.com/marko-js-samples/ui-components-playground/blob/63cf6d30928d28060d293bbae1c171f598adc506/src/components/app-button/index.js#L1

Also, if you put a `browser.json` next to an included JavaScript module then it will automatically be processed and all of the referenced client-side dependencies will be included.

That way, if the UI component is sent to the browser then the required CSS will also be included. Also, all of the required client-side dependencies for nested UI component's will be included automatically when you bundle up the root UI component.

Does that answer your question or do you have another more specific suggestion on how to improve how CSS dependencies are included.
 Hey @leonli, I'm just going through issues to do some housecleaning. I'm going to go ahead and close this issue, but if this is still an issue/question please feel free to add more comments. Thanks.
  Good catch. Marko is isomorphic and works on the server (Node.js) and in any browser. You will need a JavaScript module bundler (browserify, [Lasso.js](https://travis-ci.org/lasso-js/lasso), etc.) to transport the compiled templates to the browser and everything will work exactly as it does on the server. I'll update the README and website to make this clear. Thanks for letting us know.
 Website updated. Please let us know if you see any other issues with the website or docs. Thanks again.
 Great. Thanks for the feedback, @wheresrhys!
  Hey @redben, that is the expected behavior. Anything inside `${ ... }` is just JavaScript and it will be evaluated just like any other JavaScript code (if you take a look at the compiled code this should be clear).

Because Marko templates compile down to CommonJS modules you can import the `lodash/object/get` function to provide safe access to nested properties as shown below:

``` xml
<require module="lodash/object/get" var="get"/>
<p>Author ${get(data, 'author.name')}</p>
```

You'll need to install `lodash` into your project for the above code to work:

``` bash
npm install lodash --save
```

If you don't want to use a third-party module, you can also do the following:

``` html
<p>Author ${data.author and data.author.name}</p>
```

NOTE: `and` is a special operator that gets converted to `&&`. See: http://markojs.com/docs/marko/language-guide/#expressions

Does that work for you? Hope that clarifies. Let us know.
 Hey @redben, it's true that many templating engines interpret expressions and handle safely reading nested properties. However, doing that by default results in worse runtime performance and it limits the power of the templating language since expressions cannot be arbitrary JavaScript code. Marko has always tried to be be as close to pure JavaScript wherever possible. This keeps the runtime tiny, improves performance and it allows templates to be more powerful.

In theory, we could offer the `get` as a builtin helper to avoid having to import it. Something worth considering (especially if it is only imported if it is used in the template). Thoughts?
 Hey @redben, what's nice about marko is that it only requires in things that are required. That way when you use a JavaScript module bundler to send a compiled template to the browser there is no extra baggage. As long as we made it so that the `get` function was only `require`'d if used then I see no harm as offering that as a feature. The hard part is figuring out if `get` is required because currently aren't fully parsing the JavaScript expressions used in a template (using something like esprima or acorn), but that is something we are considering for the next release of marko. Probably low priority though since there is a fairly clean workaround. Thanks for your feedback.
  Hey @designeng, thanks for the PR, but I think we need to keep the test case as-is. While `require('marko').stream(templatePath)` is not the recommended API, it is still supported and we should keep that test case around to make sure it continues to work. There is another test case that tests `marko.load..stream': https://github.com/marko-js/marko/blob/56d23b07bdc4ca2a20ebce868a3982277c97c618/test/api-tests.js#L170-L191

Look good to you?
 Thanks, @designeng! I appreciate the feedback. 
  Hi @Globik, let's start with your first question:

> I opened the file next morning I'v seen that marko engin rewrite the file of his own way with helper's javascript functions, but my Hallo ${data.name}! is gone, simple disapeared.

When a Marko compiles a template such as `template.marko` it will generate a new file next to the original file named `template.marko.js`. The original source file is definitely not deleted. If it is gone it is because you accidentally deleted it but most likely you are just not noticing it. The generated JavaScript file is what gets loaded by Node.js (or sent to the browser).

---

And for your second question:

> The server must be restart to keep changes in the template file every time. So bad and slowly for a site developing. Is it true?

Depends on how you are watching files. Make sure you add `*.marko.js` to your ignore patterns (e.g. `.gitignore`). Since the `*.marko.js` files are generated at runtime you will want to make sure those files are ignored.

---

And for your final question:

> Only opening tags are modified for conditionals and looping???

When you make an element conditional using the `if` attribute or if you make it repeated using the `for` attribute then both the starting and ending tag will be wrapped. Hopefully it is clear from the `Try Online` example: http://markojs.com/try-online/#Simple_Hello_World

---

Let us know if you have any other questions.
 Hey @Globik, I'm just going through issues to do some housecleaning. I'm going to go ahead and close this issue, but if this is still an issue/question please feel free to add more comments. Thanks.
  I believe this issue has been resolved with improvements to the [deresolve](https://github.com/raptorjs/raptor-modules/blob/04fc6554b800277e1c62b4e1d66586bfb45acf90/resolver/lib/deresolve.js) function. If I am mistaken, please reopen the issue. Thanks.
  Seems reasonable! Double-checked the travis documentation and this looks like a safe way to force container infrastructure to be used.
 Thanks for the fix, @zephraph.

I don't think your change was the cause, but for some reason the Travis CI build is failing now :disappointed: I'll retry in a bit, but if you find a solution please share.
 I think the failed build was my fault because I closed the pull request and
then reopened it. The build error message seems to imply that this was the
reason for failure. Subsequent builds have succeeded.

On Fri, Oct 16, 2015 at 8:51 AM, Zephraph notifications@github.com wrote:

> @patrick-steele-idem https://github.com/patrick-steele-idem which
> build? The only thing that I saw that has failed recently was a rebuild
> that triggered on my PR after it was merged (which failed because the git
> ref that PRs point to are deleted after merge).
> 
> â€”
> Reply to this email directly or view it on GitHub
> https://github.com/marko-js/marko/pull/157#issuecomment-148708406.
  You'll need to make sure tag.name is not overridden due to this line:
https://github.com/marko-js/marko/blob/master/compiler/taglibs/taglib-loader/scanTagsDir.js#L140
 Hey @zephraph, are you still interested in this PR? My opinion is that I don't think it is a good idea for the tag name to be defined in the renderer or in the `marko-tag.json`. I think it is better for the tag name to be defined in the `marko-taglib.json` file or have it be set based on the directory name (when using the directory scanning feature). What do you think?
 I'm also a fan of minimizing how much code gets put into configuration files such as `marko-tag.json` and `marko-taglib.json` so I think it is better to have the convention of using a directory scanner to discover custom tags and for the custom tag name to automatically match the name of the parent directory. I think it would be a mistake to allow the developer to choose a tag name that doesn't match the parent directory name since it would make things confusing.

Also, currently, if you _aren't_ using a directory scanner then you must use a _map_ to define custom tags and that requires that the tag name always be declared in the `marko-taglib.json`:

``` json
{
  "<my-custom-tag>": "./path/to/my-custom-tag/marko-tag.json",
  "<another-custom-tag>": { "@foo": "string", ... }
}
```

It wouldn't make sense to allow the developer to redefine the tag name in the `marko-tag.json` or in the `renderer.js` file since it was already declared in the parent taglib.

I propose that we not merge this PR if you are cool with that :) Let me know.
  Is that code being included inside an inline `<script>` block that inside a Marko template?
 Hi @baburammy, I am having a hard time understanding the issue and how it relates to Marko Widgets based on the details provided. It looks to me that the issue is completely unrelated to Marko and Marko Widgets, but I could be missing something.

With that said, I would not be using jQuery to execute the inline JS. It is better to send down the inline JS without the surrounding `<script>` tag. Instead, just send down the raw JS code and use `eval(response.inlineJs)` to run the inline code.

If you have a sample project or more code that you can share that would make it easier for me to provide help.
 Hey @baburammy, I'm just going through issues to do some housecleaning. I'm going to go ahead and close this issue, but if this is still an issue/question please feel free to add more comments. Thanks.
  That's true @viviangledhill.

However, if you want the image to go through the Lasso.js asset pipeline then you should use the `<lasso-img>` tag:

``` xml
<lasso-img src="./foo.jpg"/>
```

This might produce the following HTML output depending on how Lasso.js is configured:

``` html
<img src="/static/foo-25b047cc.jpg" width="100" height="100">
```

The referenced image will also be moved into the appropriate output location. If there are any plugins to minify images then those plugins will process the image as well.

Here are the docs that were just added: https://github.com/lasso-js/lasso#%3Classo-img
 @viviangledhill automatic conversion to webp is a good suggestion. Assuming the webp image is cached I don't see it being too expensive. The tricky part is that we would have to have a good mechanism for making Lasso.js aware of the target browser's user agent so that it can optimize accordingly. Maybe open a separate Github issue for that feature request to Lasso.js?

I'm going to go ahead and close this issue, but let us know if you run into any other issues related to images and Lasso.js. Thanks.
  Yes, require extensions are deprecated, but I'm not too concerned. As stated in the docs:

> Since the Module system is locked, this feature will probably never go away.

I disagree with their decision to deprecate the feature, but I do think there are better ways to extend the module loading system to add support for new compile-to-JavaScript languages such as JSX and marko. Worst comes to worst, we provide a script to precompile all templates to JS and use `require('template.marko.js')` instead, but that would impact developer usability since it would introduce an unnecessary build step that we don't have now. 

How we have implemented the Node.js require extension for marko avoids the problem of having a global. The global require extension that gets installed by marko simply delegates the compilation to JS to the appropriate marko compiler based on where the source template is on disk. There is no harm with registering the require extension multiple times and in different packages.

On a related note, I would like to see a tool that can be used to precompile all templates and that replaces all `require('./template.marko')` calls with `require('./template.marko.js')`. This would be useful as a `prepublish` script for publishing shared packages that make use of Marko templates.
 That's true that `require.extensions` was deprecated, but I am not too concerned. According to the docs:

> Since the Module system is locked, this feature will probably never go away. 

I disagree with their decision to deprecate that feature without providing a suitable alternative. There's definitely a need for compile to JS languages such as Marko and JSX. Forcing a precompile makes things more difficult and more complicated since it introduces an unnecessary build step that is not needed now. Worst comes to worst, we could precompile all templates and require the `.marko.js` files directly....

The Node.js require extension for marko avoids most of the problems with globals since the require extension just delegates the template compilation to the appropriate version of marko based on where the template is located on disk. There is no harm in installing the marko require extension multiple times and it can be multiple versions of marko in a single app.

On a related note, I do think there would be a benefit to offer a tool for Marko that could be used as a `prepublish` script to replace all `require('./template.marko')` calls with `require('./template.marko.js')` and to have it precompile all templates in the process.
 Hey @yomed, I'm just going through old issues to do some housecleaning. I'm going to go ahead and close this issue, but if this is still an issue/question please feel free to add more comments. 

As a separate issue I think we should explore the option of precompiling all templates and updating the JS code as a prepublish step. Please feel free to open an additional Github issue if you have specific thoughts on how to avoid using `require.extensions`. Thanks.
  At eBay we are using a very similar approach to handle localization. However, instead of adding additional methods to `out.global` we just pass the `out` object to various helper methods. For example:

``` javascript
var locale = getLocale(out);
```

If you are rendering to an HTTP response directly using `template.render({...}, res)` then you can access the underlying response stream and the request object by doing the following:

``` javascript
var res = out.stream;
var req = res.req; // Works for Express, not sure if it works for Koa
var locale = getLocaleFromRequest(req);
```

NOTE: For Koa you can render directly to the HTTP response stream by doing the following:

``` javascript
app.use(function *() {
  template.render({...}, this.res)
}); 
```

I don't use Koa so I am going by what @jlarsson said in the following issue: https://github.com/marko-js/marko/pull/144

The benefit of this approach is that the developer does not have to explicitly use the `$global` property to add things to `out.global`. The disadvantage is that this approach won't work if you are not rendering directly to an HTTP response stream.

Does the approach described above work for you?
 Also, you could create a custom compile-time tag to introduce a new JavaScript i18n variable in your template. For example:

``` xml
<i18n-var name="i18n"/>

<layout-use template="./boilerplate.marko">
    <layout-put into="content">
        <h1>${i18n.__('Welcome!')}</h1>
    </layout-put>
</layout-use>
```

I think that approach is cleaner. We have a similar taglib for our eBay apps.

If you want help going that route, I can put together a sample app to show how it can easily be implemented. The docs on compile-time tags is lacking at this point (https://github.com/marko-js/marko/issues/100).
 Hi @taecilla, sometimes it is just easier to explain in code, so I created a sample app to hopefully make things clearer about what I am proposing. Please check out the following app:

https://github.com/marko-js-samples/marko-koa-i18n

Key notes:
- Enable the `koa-i18n` middleware in your main `server.js` file and add some locales
- Just put `i18n` object into the `out.global` property when you render the page template:

``` javascript
this.response.body = require('./template.marko').renderSync({
    $global: {
        i18n: this.i18n
    }
});
```
- Use the `<i18n-var>` tag to add a new JavaScript `i18n` var to your template at compilation time whose value will be `out.global.i18n`
- In your template you can then do the following:

``` xml
<i18n-var/>
${i18n.__('hello', data.name)}
```

Does that look like a clean solution to you?
 Hi @taecilla, I only passed in `i18n` using `$global` because you were _not_ rendering directly to the HTTP response stream. If you were to do the following:

``` javascript
template.render({ ... }, this.response);
```

Then you could access the `i18n` variable as shown below:

``` javascript
var response = out.stream;
var koaContext = response.ctx;
var i18n = koaContext.i18n;
console.log(i18n.__('howAreYou'));
```

The easiest way to automatically associate a template rendering with a request/response is to render directly to `this.response`. Alternatively, you could create your own Koa plugin that introduces a `this.renderTemplate(template, templateData)` method for rendering the top-level page template:

``` javascript
module.exports = function *() {
    this.renderTemplate(template, { name: 'Frank' });
};
```

Your Koa plugin could then auto-populate any globals into the template data object.

There's alternatives to avoid having to explicitly pass in `$global` everywhere :)
 Hey @tropperstyle, it looks like a bad validation check at the following line:
https://github.com/marko-js/marko/blob/56d23b07bdc4ca2a20ebce868a3982277c97c618/compiler/taglibs/taglib-loader/scanTagsDir.js#L89

That line should probably be updated to not throw an error if the tag has a transformer:

``` javascript
if (!tagDef.renderer && !tagDef.template && !tagDef.transformer) {
```

Do you want to try it out locally and send a PR if it solves your problem?

Thanks,
Patrick
 Hey @taecilla, I'm just going through issues to do some housecleaning. I'm going to go ahead and close this issue, but if this is still an issue/question please feel free to add more comments. Thanks.
  Thanks for the fix! New version published: `marko@2.7.23`
  For context, please see [Proposal: Replace HTML parser with a new parser that recognizes attribute types](https://github.com/marko-js/marko/issues/90)

All of the details are not finalized for the new parser and template syntax, but we wanted to go ahead and create this issue to start the discussion and see if there was interest from folks in the open source community taking ownership of this task. Happy to answer any questions :)
 So the main thing that we need to do is fix how attributes are delimited. If the marko tag definition says that an attribute is a string or if the attribute is not defined in the tag then surround the tag with double quotes. For expressions, numbers, boolean, and non-string types simply then surround then remove the quotes and surround the value with parentheses. For example, transform `some-number="123"` to `some-number=123`.

The new for-loop and if/else/else-if syntax should be used in place of the standard attributes. For example, `<div for="x in y">` should become something like `<div for(x in y)>`.

We can keep the marko-tag.json files for reference but they wouldn't be used anymore to infer attribute types (since type will always be an expression now). Also note that marko-tag.json files would still need to be used for describing tag transformers.

The migration tool should probably leverage `htmljs-parser` to parse the old templates since it will be able to properly parse the new and old syntax. This would be helpful in case the migration tool is ran multiple times for the same templates.

This isn't a comprehensive guide but I think these are the key things that would need to be migrated.
  Thanks for the PR. 

I see the following jshint error that looks like a problem:

```
taglibs/core/core-tag-transformer.js: line 113, col 55, 'UnlessNode' is not defined.
```

Can you please add tests and update the docs? For the docs you will need to update the following file:
https://github.com/marko-js/marko/blob/master/docs/language-guide.md

For the tests, please duplicate the following directory and update it to test the new `unless` attribute and the new `<unless>` tag:
https://github.com/marko-js/marko/tree/master/test/fixtures/templates/if-else

Thanks,
Patrick
 We are using a simple string compare for "actual" and "expected" and any whitespace difference will cause the test case to fail. I suspect you are using Atom and it is automatically adding a trailing new line when you save the "expected" file to disk. You can disable the feature by adding the following to your `User Config` file:

```
"*":
  // ...
  whitespace:
    ensureSingleTrailingNewline: false
```
 Hi @kristianmandrup, the code changes and test look good, but why did you completely reformat the markdown for the docs? It looks like the markdown changes were just stylistic changes, but now the style will be different in the other markdown files. I would rather use the old style unless there is a good reason to switch. Can you please only change the relevant docs for `unless` and we can discuss stylistic changes to the Markdown as a separate Github issue/PR. Thanks.
 Thanks for the PR, @kristianmandrup. New version published: `marko@2.7.22`

The stylistic changes that I was referring to was the Markdown syntax for declaring headings and bold. I reverted those changes and updates the docs for Conditionals:
- https://github.com/marko-js/marko/commit/4a58db78ee36acd39bc90a18bee24578863e904d
- https://github.com/marko-js/marko/commit/1e19886a5a443f1b4ad6d5b90fba89d9dfc8fd61

I also published the new docs to markojs.com. Please let me know if you see any issues. Thanks again.
  Hi @jlarsson, thanks for the PR. I see where you are going with this but I do have some concerns. Adding a `try...catch` will prevent the frequently called code from being optimized by V8 and it will also only catch any synchronous errors. I'm more inclined to add the `try...catch` block around the following line:

https://github.com/jlarsson/marko/blob/3c51134965474d30de7e4e7e82f68cb3de822d0b/runtime/marko-runtime.js#L252

Thoughts? Can you make that change?

On a related note, Koa relies on a returned `Readable` stream, but in most Express apps we are writing directly to the `Writable` HTTP response stream without creating an intermediate stream (faster...):

``` javascript
var template = require('./template.marko');

module.exports = function(req, res) {
    template.render({ ... }, res);
}
```

 Just throwing that out there :)

Glad you are enjoying marko!
  That wouldn't be hard to implement but I always find `unless` confusing when reading CoffeeScript code. I'm sure I could get use to it though.
  Hi @kristianmandrup, I think that would be independent of Marko. In your application's main script (on either the server or client) you could run code to do what you are asking. In the Marko templates your expressions are just JavaScript so there would be no problem there.

However, I would recommend not using globals and to instead use `require` to import any JavaScript modules into your templates or other JavaScript code. Also, people might not be happy if you monkey patch the prototypes for core JavaScript types (unless they are polyfills).

Let me know if you still think that there is something that can be done to solve your common use case :)
 Hey @kristianmandrup. I'm going to go ahead and close this issue since you can make changes on your side to meet your needs. I don't think `marko` should be introducing any globals or making it easier to introduce globals. I think it is better to stick with the CommonJS way of importing dependencies using `require`. Let me know if you have any thoughts or suggestions. Thanks. 
  New version published with fix: `marko@2.7.24`
 Thanks for reporting the problem!
 De-duping is not happening if the found taglibs are coming from the cache...
  That's supported. Please see: https://github.com/marko-js/marko#loop-status-variable

That works for you, correct?
  Hi @kristianmandrup, thanks for the PR, but your changes broke tests (please run `npm test` first). I hope you don't mind, but I went ahead and made changes in marko core to support the following:

``` xml
<html-element tag-name="hello-${data.myTagName}" class="my-class" foo="bar">
    My nested content
</html-element>
```

Output:

``` html
<hello-world class="my-class" foo="bar">
    My nested content
</hello-world>
```

See: https://github.com/marko-js/marko/issues/137
 Not exactly... supporting dynamic components is a little tricky. It's kind of supported if you use `<invoke function="..."/>` but that's not a clean solution. We talked about adding support for something similar to the following:

``` xml
<register-dynamic-tag tag="ui-component-one"/>
<register-dynamic-tag tag="ui-component-two"/>

<dynamic-tag tag="ui-component-${data.variant}" name="Frank" message-count="${30}"/>
```

Is that along the lines of what you are thinking?
 It's doable, but it would require a little more work than what was required for `<html-element>`. I opened a Github issue: https://github.com/marko-js/marko/issues/139

I support that proposal, but I won't be able to work on it for at least a week or two. I need to finish up the marko website ([http://markojs.com.com](http://markojs.com/)!!!) and put together a blog post announcing Marko Widgets v5.

In the meantime, I recommend:

``` xml
<app-foo name="Frank" message-count="${30}" if="data.variant === 'foo'"/>
<app-foo name="Frank" message-count="${30}" else-if="data.variant === 'bar'"/>
<app-baz name="Frank" message-count="${30}" else/>
```
  `attrs` currently only applies HTML tags (not custom tags). You can, however, do the following:

``` xml
<icon-item c-data="item">
```

However, now that you point it out. We should allow: 

``` xml
<icon-item attrs="item">
```

I will make that change.
 Fixed. New version published: `marko@2.7.17`
  Since there is currently no JavaScript engine that natively supports ES6 modules, why not just use babel to transpile the ES6 module code into [mostly] equivalent ES5 code (that uses CommonJS module syntax)? Once you have ES5 code you can build browser JavaScript bundles using almost any of the popular JavaScript module bundlers (or the JavaScript module bundler can do the transpiling). That seems like a better strategy than buying into a custom module loading system such as SystemJS or jspm (each with their own quirks and proprietary features). When I look at SystemJS and jspm I am reminded of RequireJS and all of the ugly configuration that it required. If SystemJS or jspm do not support the [browser field spec](https://gist.github.com/defunctzombie/4339901) for remapping a server-side JavaScript module to a different browser-side JavaScript module then that would be a problem for marko. I recommend using [Lasso.js](https://github.com/lasso-js/lasso) or [Browserify](http://browserify.org/) (or possibly [Webpack](http://webpack.github.io/)) as your JavaScript module bundler for building client-side bundles of your JavaScript code.

I would not recommend trying to make marko (or any other module written in the Node.js way) work with RequireJS. Have you considered transforming your AMD code into CommonJS so that you can drop AMD and RequireJS completely (both are dying technologies).

With that said, if someone in the community wants to build a custom Marko loader for SystemJS or jspm then I'll try to help out, but it is not something I am interested in coding.
 I investigated integrating Babel a while ago and found that it was very
easy although I was waiting on some changes from Babel to make it more
efficient. Specifically, the Babel transpiler builds the Abstract Syntax
Tree (AST) of the code and we were hoping to leverage their AST instead of
also parsing it with esprima. I think Babel has since made some changes to
make it easier and better for tools like Lasso (bundler) to utilize ES6 via
Babel.

On Wed, Aug 26, 2015 at 11:08 AM, Patrick Steele-Idem <
notifications@github.com> wrote:

> Since there is currently no JavaScript engine that natively supports ES6
> modules, why not just use babel to transpile the ES6 module code into
> [mostly] equivalent ES5 code (that uses CommonJS module syntax)? Once you
> have ES5 code you can build browser JavaScript bundles using almost any of
> the popular JavaScript module bundlers (or the JavaScript module bundler
> can do the transpiling). That seems like a better strategy than buying into
> a custom module loading system such as SystemJS or jspm (each with their
> own quirks and proprietary features). When I look at SystemJS and jspm I am
> reminded of RequireJS and all of the ugly configuration that it required.
> If SystemJS or jspm do not support the browser field spec
> https://gist.github.com/defunctzombie/4339901 for remapping a
> server-side JavaScript module to a different browser-side JavaScript module
> then that would be a problem for marko. I recommend using Lasso.js
> https://github.com/lasso-js/lasso or Browserify http://browserify.org/
> (or possibly Webpack http://webpack.github.io/) as your JavaScript
> module bundler for building client-side bundles of your JavaScript code.
> 
> I would not recommend trying to make marko (or any other module written in
> the Node.js way) work with RequireJS. Have you considered transforming your
> AMD code into CommonJS so that you can drop AMD and RequireJS completely
> (both are dying technologies).
> 
> With that said, if someone in the community wants to build a custom Marko
> loader for SystemJS or jspm then I'll try to help out, but it is not
> something I am interested in coding.
> 
> â€”
> Reply to this email directly or view it on GitHub
> https://github.com/marko-js/marko/issues/134#issuecomment-135055021.
 Glad to hear @wheresrhys, thanks for sharing! I know you are using webpack, but I recommend checking out Lasso.js... I think it is pretty awesome and it offers a lot of features that webpack doesn't offer :) 
  Hi @kristianmandrup, I'm not sure if it makes sense to pull this into core just yet. Here's the same functionality provided as a separate module published to npm: https://github.com/marko-js/marko-tag-body

Does that work for you? 
 There's some really cool stuff that you can do simply by transforming the AST during the compilation stage. It definitely needs to be documented. I'm glad you were able to get your hands dirty and learn some of the tricks for marko!
  Did you forget the `w-bind`?
 `w-body` is also only for widgets (anything prefixed with `w-` is handled by `marko-widgets`). If you are not using `marko-widgets` then you need to do the following:

``` xml
<div class="ui $data.ui accordion">
    <invoke function="data.renderBody(out)" if="data.renderBody"/>
</div>
```
 It's more complicated for the `marko-widgets` use case since `marko-widgets` will handle preserving nested HTML content when the outer widget is rerendered. It will also handle updating the nested HTML content when the outer widget does not need to be rerendered, but new nested content was provided. In addition, `w-body` must be bound to a container HTML element in order for everything to work.
 Hi @kristianmandrup, you don't need to patch marko to support this. It can be done completely in user land. Let me put together a separate project that you can use as an example.
  First off, it's all just code so we can make anything work :) I don't see anything here to suggest that you would need a difficult change and I would be surprised if second-level imports are not supported. If that is the case then we should fix it. I'll add a test case and see what I can figure out.

Also, can you please clarify on the following?:

> Looks like the problem is in part caused by using browser-refresh

What makes you think that?
 Great. Thank you. I'll take a look now.
 Thanks for the sample project, @kristianmandrup. I was able to reproduce the problem pretty quickly and I have put in a fix. New version published: `marko@2.7.14`

Let me know if you see any other issues. Thanks again!
 :+1: on logging. The [debug](https://github.com/visionmedia/debug) module would probably be the most appropriate since you could launch the app with `DEBUG=marko node server.js` to see exactly what marko is doing during compilation. Do you mind opening a separate Github issue to describe what type of logging you would be interested in for marko?
 @kristianmandrup, please try the following:

```
MARKO_CLEAN=true node your-app.js
```

That will force all templates to be recompiled.
 Do you see any issue with the test case I added? It was pretty much your code with some extra things removed and the test cases are passing.

Do you by any chance have a circular dependency in your imports?
 I just pushed a small change to handle circular imports, but I don't think that is impacting you because otherwise you would have seen a `Maximum call stack` error. Here's the fix I pushed: https://github.com/marko-js/marko/commit/608d9092bbc71ac5e79a0b8c0ec15d9de88698b3
 Is your app crashing?

Do you think you would be able to provide a fork of marko with a failing test case?
 Are those global imports in an installed node module?
 If `buildLookup()` is not being called then that would suggest that no templates are being compiled. Make sure you run your app with `MARKO_CLEAN=true node app.js` to force all templates to be recompiled.
 The logic for disabling the `checkUpToDate` looks fine to me so `MARKO_CLEAN=true node app.js` should force all templates to be recompiled. Are you sure that is not happening?
 If you are using the Node.js require extension then it will be here:

https://github.com/marko-js/marko/blob/8035b5de72fc8258f88bcccec41e9e8ce0ff4245/node-require.js#L28
  Was that a question and then an answer to your own question? :)

Should I close this issue, or do you think we need to improve the docs for `renderBody(out)` as it relates to Marko?: https://github.com/marko-js/marko#tag-renderer
  Thanks!
  Thanks!
  Glad to have you on this project!
  Hi @kristianmandrup, if you have a `marko-tag.json` and you don't declare a certain attribute then it is considered a "splat" attribute and it is added to a special "*" property. The fix is to declare the `"@data": "expression"` attribute in your `marko-tag.json` file. See: https://github.com/marko-js/marko#defining-attributes

With that said, the Marko compiler should probably throw an error at time unless you explicitly add the "@*" attribute.  I'm going to investigate.

Also relevant: https://github.com/marko-js/marko/issues/90 (Proposal: Replace HTML parser with a new parser that recognizes attribute types)
  Thanks for reporting the confusing error message. I just pushed a commit that should make things less confusing. New version published: `marko@2.7.10`

Please let me know if you see any other issues. Thanks.
 You're welcome.

For Marko Widgets, we hope to release v5 next week. I've been focusing on benchmarking and testing this week and I do not expect the API to change for the final v5 release. That is, I encourage you to use the latest beta version now so that we can find and fix any bugs sooner :)

I'm not sure if you have had a chance to review, but I have updated the docs and added benchmarks to `morphdom`. See: https://github.com/patrick-steele-idem/morphdom

I've also updated the benchmarks we used to compare performance of Marko Widgets with React using the latest `5.0.0-beta.2` release: [Marko vs React: Performance Benchmark](https://github.com/patrick-steele-idem/marko-vs-react) (summary: React and Marko Widgets perform almost identical in the browser, but Marko Widgets is 10x faster when rendering on the server. In addition, Marko Widgets is much more lightweight)
  Hi @zwhitchcox, you might want to try reversing the order of the `this.body` and the `this.type` assignments as shown below:

``` javascript
'use strict';
require('marko/node-require').install();

let koa    = require('koa')
let app    = koa()
let template = require('./views/index.marko');

app.use(function* () {
    this.type = 'type/html'
    this.body = template.stream()
})
server.listen(3000);
```

I don't use Koa, but I suspect that when you assign the stream to `this.body` that it commits the response body. If that is the case, then the `Content-Type` header may not be sent correctly.

I also updated your code to use the Node.js require extension :)

Let me know if that does or does not solve your problem.
 Doh :)

I bet if the page HTML would have looked like HTML the browser would have been cool with it so it probably didn't help that it only rendered `hello`.
 Hey @Globik, 

Probably better to open a separate Github issue in the future, but I'll try to answer your questions below.

> So is correct: `this.type = "html";`

The following is the correct content type for HTML responses:

``` javascript
this.type = 'text/html; charset=utf-8';
```

> Your marko is "simple" enough, but how do I build a binary tree with marko?

Marko supports macros (inline functions for rendering HTML) and those functions can be called recursively: http://markojs.com/docs/marko/language-guide/#macros

You will want to do something similar to the following:

``` xml
<def function="renderTree(node)">
    <div class="node">
        <span>${node.value}</span>
        <div class="left">
            <invoke function="renderTree(node.left)" if="node.left"/>
        </div>
        <div class="right">
            <invoke function="renderTree(node.right)" if="node.right"/>
        </div>
    </div>
</div>

<invoke function="renderTree(data.rootNode)"/>
```

> Where is marko's tutos can i find?

Definitely start with the screencasts if you haven't watched those yet: https://www.youtube.com/playlist?list=PLZUgs-F38XXQJBxA58UqnwTVMZS_uza_C

Also check out:
- [Try Marko Online](http://markojs.com/try-online/)
- [Language guide](http://markojs.com/docs/marko/language-guide/)
- [Sample apps](https://github.com/marko-js-samples/)

If you think there are particular tutorials that are needed please share by opening a Github issue. Also, please join us in the Gitter chat room and we will be happy to answer any questions you might have: https://gitter.im/marko-js/marko
  Hi @dtrikannad,

I'm assuming you are using the [flash](https://github.com/expressjs/flash) module for Express. I've not used that module, but according to the documentation the flash messages are stored in the `res.locals.flash` variable and they are an array in the following form:

``` json
{
    "type": "info",
    "message": "message"
}
```

I would recommend just passing the flash messages to your page template as part of the template data similar to the following:

``` javascript
var template = require('./template.marko');

app.get('/', function(req, res) {
    template.render({
            flashMessages: res.locals.flash
        }, res);
});
```

And then in your template:

``` xml
<ul>
    <li for="flashMessage in data.flashMessages">
        <b>Type:</b> ${flashMessage.type}<br>
        <b>Message:</b> ${flashMessage.message}
    </li>
</ul>
```

I hope that answers your question.
 Hi @dtrikannad, glad that solved your problem. Do you have a stack trace with your 500 error? Marko doesn't have any `try...catch` blocks so any exception is just going to bubble up. If you are not seeing a proper stack trace in your logs then I think there are issues with how your server is configured and that is going to cause more problems for you in the future. Did you you add your own uncaught exception handler (e.g. `process.on('uncaughtException', function(err) { ... })`);? Are you using promises (promises catch exceptions and will silently eat them in some circumstances)?

If you are desperate you can do the following:

``` xml
{% try { %}
<require module="../private_libraries/globals_v1.js" var="globals"/>
<if test="!globals.isEmpty(data.messages)">Not Empty</if>
{% } catch(e) { console.error(e); } %}
```

(using embedded scripts is not recommended!)

I hope that helps
 Hi @dtrikannad, I'm going to close this issue, but if you are still facing issues related to debugging then feel free to comment here or open another Github issue.
 Hey @crash85, the "flash messages" are stored in a session that persists across redirects. See:
 https://github.com/expressjs/flash/blob/92fd748feb60c9a277622ce75ef7091735796af9/index.js#L6-L8

As an addendum to my earlier response, whenever you pass flash messages to the template to be rendered you should just also clear out flash messages from the session:

``` javascript
var template = require('./template.marko');

app.get('/', function(req, res) {
    var flashMessages = res.locals.flash;
    if (flashMessages) {
        flashMessages = res.locals.flash.concat([]); // Clone the flash messages before clearing
        res.locals.flash.length = 0; // Remove all of the elements from the flash messages stored in the session
    }  

    template.render({
            flashMessages: res.locals.flash
        }, res);
});
```

I don't use sessions in my app and I don't use the `flash` module, but that should work for you (assuming you have Express sessions set up correctly).
  Nice improvement. Thank you!
  Hi @williamvivier, I created a `<USER_HOME>/emmet/snippets.json` file and I also needed to update my Atom `keymap.cson` file (`Atom` â†’ `Open Your Keymap`):

_`keymap.cson:`_

``` coffee
'atom-text-editor[data-grammar~="marko"]:not([mini])':
    'tab': 'emmet:expand-abbreviation-with-tab'
```

_`<USER_HOME>/emmet/snippets.json:`_

``` json
{
    "marko": {
        "extends": "html",
        "snippets": {
            "for": "<for each=\"${1:item} in ${2:items}\">$3</for>",
            "@for": "for\"${1:item} in ${2:items}\"",
            "attrs=": "attrs=\"${1:expr}\"",
            "if": "<if test=\"${1:condition}\">$2</if>",
            "@if": "if=\"${1:condition}\"",
            "else-if": "<else-if test=\"${1:condition}\">$2</else-if>",
            "@else-if": "else-if=\"${1:condition}\"",
            "else": "<else>$1</else>",
            "var": "<var name=\"${1:name}\" value=\"$2\"/>",
            "assign": "<assign var=\"${1:var}\" value=\"$2\"/>",
            "require": "<require module=\"${1:module}\" var=\"$2\"/>",
            "op": "<optimizer-page package-path=\"${1:./optimizer.json}\"/>",
            "oh": "<optimizer-head/>",
            "ob": "<optimizer-body/>",
            "use": "<layout-use template=\"${1:./path/to/template.marko}\">\n    <layout-put into=\"${2:target}\">\n        ${3:content}\n    </layout-put>\n</layout-use>",
            "placeholder": "<layout-placeholder name=\"${1:name}\"/>",
            "put": "<layout-put into=\"${1:name}\"/>",
            "async": "<async-fragment data-provider=\"${1:data.myDataProvider}\" var=\"${2:varName}\">\n    ${3:}\n</async-fragment>",
            "bind": "w-bind=\"${1:./widget}\"",
            "include": "<include template=\"${1:./path/to/template.marko}\"/>",
            "?": "{?${1:expression};${2:trueTemplate};${3:falseTemplate}}",
            "def": "<def function=\"${1:name}(${2:params})\">\n    ${3:}\n</def>",
            "invoke": "<invoke function=\"${1:name}\" ${2:arg1Name}=\"${3:arg1Value}\"/>",
            "comment": "<html-comment>$1</html-comment"
        }
    }
}
```

Also, I had opened up an issue against the Emmet Atom project on Github that has relevant discussion: https://github.com/emmetio/emmet-atom/issues/206

Ideally, the Marko plugin for Atom would automatically enable Emmet support, but right now the Emmet API has limitations that prevent this.

Hopefully editing those two files enables Emmet for you, but let us know if you are still running into issues.
 Hey @williamvivier, I'm just do some housecleaning and am reviewing old issues. I'm going to go ahead and close this issue, but if you are still having issues getting Emmet to work with Marko please let us know. Thanks! 
  Hey @kristianmandrup, I'm just going through old issues to do some housecleaning. I'm going to go ahead and close this issue, but if this is still an issue/question please feel free to add more comments. 

On a related note, I plan on sharing a marko roadmap later this week. Work is [in-progress](https://github.com/marko-js/marko/tree/htmljs-parser) to integrate the new [htmljs-parser](https://github.com/philidem/htmljs-parser) as discussed in the following proposal: https://github.com/marko-js/marko/issues/90

The new syntax is much cleaner and more powerful. For example:

``` xml
Hello ${data.name}!

<ul if(notEmpty(data.colors))>
    <li for(color in data.colors)>
        ${color}
    </li>
</ul>
<div else>
    No colors!
</div>

<if(notEmpty(data.colors))>
    <ul>
        <for(color in data.colors)>
            <li>
                ${color}
            </li>
        </for>
    </ul>
</if>
<else>
    <div>
        No colors!
    </div>
</else>
```

We will also be introducing a cleaner syntax for macros/functions:

``` xml
<function renderTree(node)>
    Name: ${child.name}

    Children:
    <ul if(node.children)>
        <li for(child in node.children)>
            <renderTree(child)/>
        </li>
    </ul>
</function>

<renderTree(data.node)>
```

And ES6-style imports:

``` xml
<module-imports>
    reverse from "./helpers";
    foo from "./foo";
</module-imports>

Hello ${reverse('Frank')}
```

Just wanted to share with you, because I think these changes will likely impact how you are doing things with the jade transpiler. If you have feedback, please share!

Thanks.
  Thank you again, @merwan7, for the contribution!
  Hi @sandro-pasquali, the Marko compiler processes `${expression}` found in JavaScript strings to produce compiled JavaScript code that uses concatenation to achieve the expected result. Essentially, you get the benefits of ES6 template strings inside Marko templates and there is no conflict with ES6 since the code is transpiled to ES5 compatible code at compile time.

For example, given the following template:

``` xml
${"Hello ${data.name}"}
```

The compiled code will be similar to the following:

``` javascript
"Hello "+data.name
```

Interestingly, if you want to use ES6 template strings you can still do that by using backticks instead of string quotes (Marko only process `${...}` tokens inside JavaScript strings). For example, given the following template:

``` xml
${`Hello ${data.name}`}
```

The compiled output will be the following:

``` javascript
`Hello ${data.name}`
```

The above compiled code will work exactly as expected in web browsers that support ES6.

Hopefully that answers your question, but let me know if not.
  Hi @kristianmandrup, can you please provide more details on your use case and why you need this feature? I think that will allow is to provide a better solution to your problem.

Also, we want to make ensure that templates still compile through the command line compiler and other tools. If application code must first register taglibs as you described then that would mean that other tools would not work as expected unless they also some how loaded your application code to register the additional taglibs.

On a related note, Marko does support the ability for a taglib to import another taglib (here's a link to the [relevant code in loader-taglib.js](https://github.com/marko-js/marko/blob/156f04ed3537b3e1d0561f87a3353ac7e0c1f543/compiler/taglibs/taglib-loader/loader-taglib.js#L138)). Not sure if that would solve your problem though.

Please provide more details on your use case. Thanks!
  Interesting. It looks like the html parser we are using (i.e., [htmlparser2](https://github.com/fb55/htmlparser2) is processing the `<%` tags, and I don't think it would be reasonable to change that HTML parser. 

Marko is designed to render pure HTML code. While you can use it to render JSP code you will have to avoid using the special JSP tags in your Marko template. 

I suggest the following workaround:

## Create a custom tag to render the JSP directives and scriptlets

``` xml
<jsp-directive type="page" contentType="text/html;charset=UTF-8" language="java"/>
<jsp-directive type="taglib" prefix="sec" uri="http://www.springframework.org/security/tags"/>
<jsp-directive type="taglib" prefix="spring" uri="http://www.springframework.org/tags"/>

<jsp-scriptlet>

</jsp-scriptlet>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>

</body>
</html>
```

The JavaScript renderer for the `<jsp-directive>` tag might look like the following:

``` javascript
module.exports = function render(input, out) {
    var type = input.type;
    out.write('<%@ ' + type);

    var attrs = input['*'];
    for (var k in attrs) {
        if (attrs.hasOwnProperty('k')) {
            out.write(' ' + k + '="' + attrs[k] + '"');
        }
    }

    out.write('%>');
};
```

The JSON declaration for the tags might look like the following:

``` json
{
    "<jsp-directive>": {
        "renderer": "./jsp-directive-tag.js",
        "@type": "string",
        "@*": "string"
    },

    "<jsp-scriptlet>": {
        "renderer": "./jsp-scriptlet-tag.js"
    }
}
```

Let me know if you still have questions.
  Hi @ahmadnassri, the Marko compiler puts the compiled templates next to the original template because the Node.js module loader is context aware and we want the stack traces to match up with location that the Node.js module loader associates with the loaded compiled template. That is, the location of the JS module on disk matters since it impacts how `require`'d modules are resolved. Currently, we calculate all of the relative paths based on the original template location on disk and we therefore put the compiled template module next to the original template file. While we could place the compiled template at a different location on disk, we would need to change how the relative `require` paths are generated. Also, at a minimum, each module in the application would need to have its own parallel directory tree for compiled templates so that the required Node.js modules would be resolved relative to the module that contains the template. Something like the following:

```
my-app/
    .marko-compiled/
        foo/
            template.marko.js
        bar/
            template.marko.js
    foo/
        template.marko
    bar/
        template.marko
    node_modules/
        my-installed-module/
            .marko-compiled/
                foo/
                    template.marko.js
                bar/
                    template.marko.js
            foo/
                template.marko
            bar/
                template.marko
```

However, I would be concerned about the impact on usability if we move compiled templates to a parallel directory tree. There were also be other impacts on usability that would need to be explored. I don't want to dismiss your suggestion, but unfortunately it is not as simple as changing where the compiled template gets stored on disk.
 Hey @ahmadnassri, we added an option to disable writing compiled templates to disk:

``` javascript
require('marko/compiler').defaultOptions.writeToDisk = false; 
```

Please see issue #150 and commit 370ac4b3ab2adc078b0b1c79f8f58186cd8074e9.

If that is an acceptable solution then I would like to close this issue. Please let me know. Thanks.

Does that resolve this issue?
 Do you have an recommendation for a cleaner way to set the option? We can always adjust.
  Hi @thomasJang, can you please provide more clarity on what you are asking? The `marko-taglib.json` files are found relative to the template being compiled using the following search path: https://github.com/raptorjs/marko#taglib-discovery

If you can provide more details on what you are trying to accomplish I should then be able to provide better help. Thanks.
 Hi @thomasJang, the location cannot be changed because that would break other things (for example, the command-line compiler would not work). While we could make it possible to register additional `marko-taglib.json` files via code, I don't think that would be a good idea.

Not sure if it solves your use case but you can create a `marko-taglib.json` that imports other taglibs as shown below:

``` json
{
    "taglib-imports": [
        "./path/to/another/marko-taglib.json"
    ],
    ...
}
```

Can you provide more details on your use case? Why do you need `marko-taglib.json` files to be in another location?
 Sounds good. If you run into any specific issues or get stuck please feel free to post a new issue. It's pretty easy to change things if necessary so just let us know. Thanks and good luck with your coding!
  Hi @thomasJang, the marko compiler strips all whitespace by default (including trailing new lines). You can disable whitespace removal by doing the following:

``` javascript
require('marko/compiler').defaultOptions.preserveWhitespace = true;
```

You'll need to force a recompile all your templates. The easiest way to do that is to set the `MARKO_CLEAN` environment to `true`:

```
MARKO_CLEAN=true node .
```

Of course, you can also just append the new line in your code:

``` javascript
tmpl.render(data, function(err, output){
    if(!err)
        grunt.file.write(dest, output + '\n');
    else
        grunt.log.error(err);
});
```

Hopefully that answers your question, but if not please let me know.
 Also, please check out the following docs: [Marko >> Whitespace](https://github.com/raptorjs/marko#whitespace)
  Hi @snapwich, this question has come up before and here is a relevant discussion: https://github.com/raptorjs/marko/issues/6

The main reason for writing the compiled template to disk is so that stack traces will be valid in case there is an exception thrown during template rendering. By design, the Marko template compiler produces very readable JavaScript output. It would be extremely frustrating to debug a JavaScript exception if the loaded source code was not available.

In addition, the compiled template _must_ be loaded through the Node.js module loader (or a compatible CommonJS module loader of some sort). If you take a close look at the compiled output of a template you will see that most templates make heavy use of the `require` function that is only available inside the context of a CommonJS module. The `require` function is used to load included templates, custom tags, etc. In other words, you can't just `eval` the compiled output and expect things to work.

In theory, we could provide an option to disable the writing of the compiled Marko template to disk with a small code change but I think that would be undesirable. I'm happy to discuss some more and would not necessarily be opposed to a PR (as long as the default was still to write the compiled template to disk).

Let me know if you still have questions. Thanks.
  Hi @kristianmandrup, you should probably be using custom tags instead of partials. Custom tags are superior to vanilla partials in many ways and are often easier to use.

Instead of the following:

``` xml
<include template="../../path/to/header.marko" ... />
```

Just make header a custom tag:

``` xml
<my-header .../>
```

With custom tags, the path of the partial template doesn't matter and Marko makes it easy to utilize custom tags provided by installed Node modules. Custom tags can be associated with a JavaScript renderer or just a template (if a JavaScript renderer is not needed).

It is considered a bad practice to use includes/partials where the target partial template is outside the current directory of the parent template. That is, a partial is probably fine if it the parent template and the partial template are in the same directory.

If you create a Node.js module that is to export custom tags, just put a `marko-taglib.json` in the root of the module. I recommend taking advantage of directory scanning for automatically discovering taglibs based on the directory structure. Please see [Scanning for Tags](https://github.com/raptorjs/marko#scanning-for-tags).

The marko compiler will automatically discover the exported taglib of installed modules and make the taglib available to any template that has the taglib in its search path. Please see [Taglib Discovery](https://github.com/raptorjs/marko#taglib-discovery)

I hope that answers your question. Please let me know if you would like to discuss some more. I will try to put together a sample project that illustrates creating and utilizing custom tags.
 Closing issue for now, but please feel free to add additional comments. Thanks.
  While [consolidate.js](https://github.com/tj/consolidate.js/) doesn't support streaming, we should still add marko support for better visibility to this project.

I'm requesting help from the community in sending a Pull Request to the [consolidate.js](https://github.com/tj/consolidate.js/) project to add support for the marko template engine. Thanks in advance!
 There are two issues with that PR:
- Issue 1) It doesn't cache the loaded template
- Issue 2) Marko needs both the template's source (as a string) and the  template's file system path.

**For issue 1:** make sure you use the provided cache to cache the loaded marko template: https://github.com/gregwebs/consolidate.js/blob/8592fed81cd4483ff433b3fdc1d5ea190e004097/lib/consolidate.js#L525

**For issue 2:**  I believe the template's file system path is provided as `options.filename` based on the following line:
https://github.com/gregwebs/consolidate.js/blob/8592fed81cd4483ff433b3fdc1d5ea190e004097/lib/consolidate.js#L138

You can then use the marko [`load(templatePath, templateSrc)`](http://markojs.com/docs/marko/javascript-api/#loadtemplatepath-templatesrc-options--template) method to load the template:

``` javascript
var template = marko.load(str, options.filename);
```

And then to render the loaded template:

``` javascript
template.render(options, fn);
```

I don't like the Express view engine (see [Bypassing Express View Rendering for Speed and Modularity](https://strongloop.com/strongblog/bypassing-express-view-rendering-for-speed-and-modularity/) and I don't like `consolidate.js`, but for visibility to marko it is probably worthwhile to enable marko template rendering via consolidate.js... The biggest downside is that streaming/progressive HTML rendering won't work.

Thanks for looking into it @seangates!
 See: https://github.com/tj/consolidate.js/pull/255
 @bitinn I've not used `metalsmith`, but loaded `.marko` templates are loaded and cached by the Node.js module loading system the same as normal `.js` modules. That is, they are cached in `require.cache` and deleting from `require.cache` will cause the template to be reloaded on the next `require()` of the template. `metalsmith-watch` supports a `invalidateCache` that might work. 

`marko` also supports a special `hot reload`: https://github.com/marko-js-samples/marko-hot-reload. You'll need to use your own file watcher to tell `marko` when a file is modified and `marko` will ensure that all templates automatically hot reload such that the next time they render they will be render based on the modified source.

Please let me know if you need more details @bitinn.  Closed via https://github.com/tj/consolidate.js/pull/255. Thanks @fabsrc!  Hi @kristianmandrup,  I updated the docs to mention the `template-data` attribute that is supported on the `<include>` tag. For your example, you would want to do the following:

``` xml
<include name="xyz.marko" template-data="${data}"/>
```

Here's a link to the relevant docs that now mentions the `template-data` attribute:
https://github.com/raptorjs/marko#includes

Please let me know if that doesn't solve your problem.

Thanks.
 Hey @jcc2303, can you please provide more details on your problem? I believe it is best to open a separate Github issue because your code seems unrelated to what @kristianmandrup described. Please clarify. Thanks.
  Hi @jackhorton, this is not clarified in the docs, but if the `template` attribute is a dynamic expression (not a static string) then the expression should resolve to an already _loaded_ template. You can load the template in the template itself as shown below:

``` xml
<require module="../relative/path/to/template.marko" var="myLoadedIncludeTemplate"/>
<include template="$myLoadedIncludeTemplate" />
```

However, if it usually cleaner for the include template to be loaded by the custom tag/controller and for it to be provided as part of the view model to the template.

``` xml
<include template="$data.myLoadedIncludeTemplate" />
```

I'll update the docs, but let me know if that doesn't work for you.

There are two ways to load a template in your JavaScript code:

Option 1)

``` javascript
var myLoadedTemplate = require('marko').load(require.resolve('./template.marko'));
```

Option 2)

``` javascript
require('marko/node-require').install(); // Called once in your application main script
// ...
var myLoadedTemplate = require('./template.marko');
```

Option 2 is recommended
 Hi @jackhorton, just an update: I put in a minor tweak to allow the `template` attribute to be a dynamic path that can be relative. It is still recommended to preload the include target and pass a reference to the fully loaded template. This mainly because JavaScript module bundlers that do static code analysis will not find dynamically required templates.

New version published: `marko@2.7.4`

Please let me know if you have any questions or still have issues. Thanks. 
  Hi @yomed, instead of a custom tag (which is associated with a renderer function) you can invoke a `renderer(input, out)` function directly:

``` javascript
data.renderers=[
    require('../foo'),
    require('../bar'),
    require('../baz')
]
```

``` xml
<for each="renderer in data.renderers">
    <invoke function="renderer(myInputObject, out)"/>
</for>
```

I don't know exactly how that fits into your app, but hopefully you get the idea. FYI, a custom tag is resolved to a renderer at compile-time.

Please let me know if that doesn't solve your problem.
 Assigning a `w-id` attribute to an `<invoke>` tag currently doesn't work because of how the compile-time transform is implemented for marko-widgets. I'll look into seeing if it can be supported with a small code change. Can you please open a Github issue against the [marko-widgets](https://github.com/raptorjs/marko-widgets) project?
 marko-widgets was updated to support the `w-id` attribute with the `<invoke>` tag: https://github.com/raptorjs/marko-widgets/issues/46

Closing this issue.
  You mentioned two separate issues:

> what if class name is coming dynamically from the JavaScript object.

For that you will want to use the custom `attrs` attribute which allows attributes to come from a JavaScript object: https://github.com/raptorjs/marko#attrs

> Also there is inconsistency across marko for defining JavaScript expression. Some places its using ${}, some places it dosent needs ${} and here its using {?condition;value} (WITHOUT $ sign)

That is a known issue that would be solved with the following proposal: https://github.com/raptorjs/marko/issues/90 (Proposal: Replace HTML parser with a new parser that recognizes attribute types)

Please let me know if that does or does not address your concern so that I can close this issue. Thanks.
 Hi @SunnyGurnani, If an attribute type is declared as `expression` (such as `value` attribute for the `<assign>` tag) then the attribute value is assumed to be a valid JavaScript expression. Therefore you would need to have the value be valid JavaScript such as the following:

``` javascript
<assign var="viewDetailsClass" value="data.listingModel.bin.binAction ? 'btn' : 'btn btn--primary'"/>
```

Longer term, we want to have everything be JavaScript. Again, this would be solved by the following proposal: https://github.com/raptorjs/marko/issues/90 :)
  For the benefit of those outside eBay, here's the template that you shared:

``` xml
<div ${helper.renderAttributes()} >
    Please inspect my container element and you will find dynamic content is not evaluated
</div>
```

The above is not valid HTML and will not be parseable. However, the equivalent alternative is to take advantage of the custom [attrs](https://github.com/raptorjs/marko#attrs) attribute as shown below:

``` xml
<div attrs="helper.getTrackingAttributes()">...</div>
```

Where the `helper.getTrackingAttributes` is implemented as shown below:

``` javascript
function getTrackingAttributes() {
    return {
        "attr1": "attr1Value",
        "attr2": "attr2Value"
    }
}
```

Alternatively, you could use a custom compile-time transform to add the attributes to allow for something similar to the following:

``` xml
<div tracking-attrs/>
```

The benefit of a custom compile-time transform is that it could add extra validations to handle the case where an element may be missing an `id` or some other attribute.

Let me know if this answers your question or if you would like more help with a custom compile-time transform.
 Hi @SunnyGurnani, I was hoping to put together a sample app to demonstrate custom compile-time transforms to process custom attributes, but I have been pretty swamped. In the meantime, it might be helpful to understand how marko-widgets utilizes compile-time transforms.

Here is the implementation for the marko-widgets compile-time transform:
https://github.com/raptorjs/marko-widgets/blob/master/taglib/widgets-transformer.js#L21

Here is the taglib that registers the transform:
https://github.com/raptorjs/marko-widgets/blob/master/marko-taglib.json#L70

I still hope to improve the docs for this advanced feature, but hopefully this helps in the meantime. Thanks for your patience. 
 Closing this issue. I have opened another issue to improve the docs for compile-time transforms to better explain how custom tags and custom attributes can be processed at compile-time: https://github.com/raptorjs/marko/issues/100
  Currently, Marko is using an HTML parser. An HTML parser treats every attribute value as a `String` type regardless of how it is written.

For example, with an HTML parser the following lines are all equivalent:

``` xml
<my-component foo=123/>
<my-component foo="123"/>
<my-component foo='123'/>
```

As a result of this limitation, Marko relies on custom tag schemas to associate a type with an attribute value or the developer must use the `${<javascript-expression}` syntax. Tag schemas are great for documentation but they are a pain to maintain and they make usage of a custom tag ambiguous. Not to mention, the `${<javascript-expression}` syntax can only be used with attributes that have a `string` type (not `expression`, `boolean`, etc.).

The author of the `<my-component>` tag can separately declare the type for an attribute and developer viewing a template wouldn't know the attribute type unless you consulted the tag schema:
It would be great if the parser used by Marko treated _all_ attribute values as _JavaScript expressions_. Spaces will end an attribute value unless the space is in a quoted string or within a parenthesis/square brackets/curly braces block. Finally, we would support `${<javascript-expression>}` usage within [ES6 Template strings](http://tc39wiki.calculist.org/es6/template-strings/) (i.e. strings "quoted" using backticks). The following illustrates what is being proposed.

``` xml
<my-component number=1/>
<my-component variable=name/>
<my-component complex-expression=1+2/>
<my-component complex-expression-with-spaces=(a + b)/>
<my-component simple-string="hello"/>
<my-component simple-string='hello'/>
<my-component dynamic-string=`hello ${name}`/>
<my-component string-concatenated=("hello "+name)/>
<my-component boolean=true/>
<my-component array=[1, 2, 3]/>
<my-component object={hello: 'world'}/>
<my-component function-call=data.foo()/>
<my-component complex-function-call=(data.foo() + data.bar())/>
```

Now that we are using a custom parser, we can also improve the syntax for conditionals and looping as @onemrkarthik suggested:

``` xml
<div if(x > 5)>
   Do something
</div>

<ul>
   <li for(color in colors)>
       ${color}
   </li>
</ul>

<ul>
   <li for(color in colors; status-var=loop)>
       ${loop.getIndex+1}) ${color}
   </li>
</ul>
```

Here's what for-loops and conditionals would look like as tags:

``` javascript
<if(x > 5)>
    <div>
        Do something
    </div>
</if>

<ul>
    <for(color in colors)>
        <li>
            ${color}
        </li>
    </for>
</ul>

<ul>
    <for(color in colors; status-var=loop)>
        <li>
            ${loop.getIndex+1}) ${color}
        </li>
    </for>
</ul>
```

Thoughts? Concerns?
 Hey @SunnyGurnani, as for JavaScript arrays and objects, we should make sure the following works as well:

``` xml
<my-component array=[1, 2, 3]/>
<my-component object={hello: 'world'}/>
```

I'll updated the proposal. Thanks for the feedback
 Hi @pswar, good question. Yes, any valid JavaScript expression is allowed on the right-hand side and will be copied to the compiled JavaScript template verbatim. I'll update the proposal to make this clear. Thanks for the feedback
 Do you think that for parsing simplicity we should require expressions to be wrapped with parentheses? If you can get it work without parentheses that would be great but I could see how that might be tricky.

For example, consider:

``` xml
<my-component object=someFunc (1) />
```

That space after `someFunc` might look like a new attribute to the parser.

This would be safer in all cases:

``` xml
<my-component object=(someFunc (1)) />
```
 Hey @philidem, I see where you are coming from, but requiring parenthesis would actually make things more confusing I think. It would be a bad idea to require that variable names be wrapped in parenthesis like the following:

``` xml
<my-component variable=(foo) />
```

The following is better:

``` xml
<my-component variable=foo />
```

In this case, `foo` just happens to be a simple variable expression (not a function call).

I think using a space (outside of a code block) is the best way to delimit attributes.
 Hi @vedam, you bring up a good question regarding the use of backticks for template strings. Adopting backticks would make things more like JavaScript, but my initial reaction is that why not allow number quoted strings to be treated as template strings? We are processing all of these strings at compile-time to find the dynamic parts so there is no performance hit at runtime. Also worth mentioning is that we already support dynamic parts in normal quoted strings so switching to backticks would make things potentially problematic for developers migrating to the new version (migration is also a very important topic that needs to be discussed since this proposal would definitely be a breaking change). The only negative about not using backticks is that developers would need to escape the `$` character inside quoted strings if it is not intended for a dynamic part. I'm leaning towards not supporting backticks, but I would like to get more thoughts from others since I think it is definitely worth discussing some more.
 Hey @vedam, I'm actually okay with supporting backticks, but I would want to transpile the code to its ES5 equivalent so that it works in older browsers that do not support that ES6 feature.

For example,

``` javascript
`foo ${name}`
```

Would be transpiled to the following:

``` javascript
'foo ' + name
```

I think the end result would be the same. I agree with your sentiment that the right-hand should just be JavaScript...this makes Marko more intuitive and more powerful.

If we agree to support backticks, then the question becomes: should we also support dynamic parts in normal quoted strings or should dynamic parts only be allowed in ES6 template strings?
 :+1: for supporting string templates with backticks

I think usage of backticks is a good idea and I think the Marko compiler could easily convert the string template to ES5 JavaScript.

Let's make this happen!
 To @patrick-steele-idem's question, I would suggest only support variable replacement in string templates which are delimited with backticks. That is, don't do variable replacement within strings delimited with `"` and `'`.

Since migration tool seems necessary, I think we should convert any existing string attribute values to ES6 templates (using backticks).
 Hi @SunnyGurnani, what is being proposed is that the right-hand side is _always_ a JavaScript expression. If it is valid JavaScript expression then it can go on the right hand side and it will actually be copied into the compiled JS verbatim. Even if right-hand value is a simple string it would still be a valid JavaScript expression. I think this will make things the least confusing.

The only special case is for attributes that are interpreted at compile-time (e.g. `for="color in ['red', 'green', 'blue']`)

Seem reasonable?
 Thanks for the comments @pswar. Some related thoughts:

1) I think we are saying the same thing. I'm in favor of _only_ allowing `${...}` in strings that use back ticks as "quotes" (not in strings quoted using double or single quotes). For example:

``` xml
<my-component my-dynamic-string=`Hello ${data.name}!`/>
```

On top of that, we would transpile ES6 template strings to an ES5 equivalent.

2) If you want to have a string of `"[1, 2, 3]"` then you would just do: `mystring="[1, 2, 3]"`. If you want an Array of `[1, 2, 3]` then you would just omit the quotes: `myarray=[1, 2, 3]`
 NOTE: I have updated the proposal to reflect that `${...}` should _only_ be allowed in ES6 template strings.
 Hi @DanCech, this is still a developing proposal so nothing is set in stone. My thinking is that this is definitely going to be a breaking/major change and old templates will need to be migrated to work correctly with the new Marko version. We would want to make the migration as easy as possible so at a minimum we would need to provide a tool that would automatically update existing Marko templates to conform to the new parser by doing things such as the following:

**Old:**

``` xml
<my-component foo="Hello ${data.name}"/>
```

**New:**

``` xml
<my-component foo=`Hello ${data.name}`/>
```

As another example, if a custom "foo" attribute is declared as an "expression" type then the following conversion would happen:

**Old:**

``` xml
<my-component foo="data.name"/>
```

**New:**

``` xml
<my-component foo=data.name/>
```

---

Beyond that, if you are concerned that it would be hard to unlearn the old handling of `${...}` in attribute values or that you still prefer all `${...}` to be processed in all strings then that would be a good argument for going back to the old behavior and allowing `${...}` in _all_ quoted strings. Honestly, I could go either way since I see the value in both choices.
 Hi @SunnyGurnani, I think there might be a misunderstanding because with the updated proposal we want to go _closer_ to the simplicity of pure JavaScript. Instead of tag schemas, we are saying that an attribute value is simply a pure JavaScript expression and nothing more and nothing less. Marko has always been close to JavaScript by design but with the latest proposal we want to take it even closer. That is, Marko aims to be a perfect blend of JavaScript and HTML :)
 Also, @SunnyGurnani, the parenthesis are only needed in situations where a "complex" expression has spaces that would have otherwise ended the attribute value.
 The idea is that the `foo` attribute in the following Marko template:

``` xml
<my-component foo=`Hello ${data.name}`/>
```

Would compile to the following property definition in JavaScript code:

``` javascript
foo: "Hello " + data.name
```

NOTE: there would no signs of the backticks in the final compiled output because we want the code to work in ES5 and not just ES6

We could absolutely interpolate `${...}` in normal quoted JavaScript strings, but then we are slightly changing the rules of JavaScript which may be surprising to some users if we say "the right-hand side of an attribute is just JavaScript".
 Hi @SunnyGurnani, technically we don't need to support `${...}` but just just makes the code easier to write and read compared to using string concatenation. 

It did occur to me that we also currently support `$<var-name>` (without the curly braces) which is technically not part of the ES6 template strings spec. We could require `${<var-name>}` but that seems like it would require extra code for end users unnecessarily. That is something we should also discuss. Thanks for the feedback so far!
 A big plus of marko for me is that it can be used with editors that understand HTML/XML (syntactically at least) instead of treating it like a big lump of characters, providing e.g. live linting and structure-aware navigation. In order to do so they need to parse it and that would likely be broken by adopting a custom syntax for attributes.
 And then you have JavaScript template strings: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings

The problem with `{ ... }` is that it appears all of the time in HTML markup. For example, inline style sheets:

``` xml
<style>
.foo {font-weight: bold;}
</style>
```
 Read your comment too fast, @aaronshaf. I thought you were suggesting `{ ... }` over `${ ... }` (which other templating languages choose... including Angular and Dust).

My problem with supporting the following:

``` xml
<my-component foo={`Hello ${data.name}`} />
```

Is that I really feel like it would be cleaner if the right-hand side of an attribute is _always_ treated as a JavaScript expression. The following code is a valid JavaScript expression:

``` javascript
`Hello ${data.name}`
```

The following is also a valid JavaScript expression despite the additional surrounding parenthesis added for grouping:

``` javascript
(`Hello ${data.name}`)`
```

But the following is not a valid JavaScript expression:

``` javascript
{`Hello ${data.name}`}
```

(curly braces are only valid for block statements)

That is, you can't do the following in JavaScript:

``` javascript
var foo = {`Hello ${data.name}`};
```

I would rather not introduce new symbols for the sake of introducing new symbols if that makes sense.
 Great suggestion, @onemrkarthik. I like that the `for(color in colors)` and `if(x > 5)` directives match up very nicely to pure JavaScript. I'm going to update the original proposal to include your suggestions. Thanks!
 Fixes. Thanks, @onemrkarthik 
 Great feedback @kristianmandrup. What are your thoughts on the fragmentation that would result from supporting two different syntaxes?
 FYI, I started working on a new parser that will better understand JavaScript expressions in HTML attributes (e.g. `<custom message="Hello ${name}!" count=100 large=true complex=(a + b)>`). The key difference between the existing HTML parsers is that attributes will _not_ need to be surrounded by quotes (quotes should only be used if the attribute value will be of type _string_). 

See https://github.com/philidem/htmljs-parser

The base HTML language is handled just fine but I am still working on:
- Placeholders within content: `<div>${xyz}</div>`
- Placeholders within attribute string expressions: `<div class="${xyz}">`
- Placeholders within placeholders: `<div class="${"abc ${def}" + 123}">` (hopefully wouldn't be used very often)
- Better flow control syntax: `<for(a in b)>`, `<div for(a in b)>`, and `<div if(a === b)>`

There's also going to be additional work inside Marko to switch to new parser and there will be some breaking changes that need to be addressed with a template migration tool perhaps.

If anyone has some additional thoughts about the Marko syntax and improvements that could be made, then please let me know! Thoughts and feedback on the parser are also welcome.
 Nice work, @philidem! Thank you for the hard work to make this happen. This will be a huge improvement to Marko and it will be nice to be able to do away the `marko-tag.json` files in most cases.

We'll definitely have to think about transforming old templates. The big thing is that if an attribute is declared as an `expression` then we will need to transform the template to drop the attribute quotes. For example:

Old:

``` xml
<my-custom-tag data="data.someFunction()">
```

New:

``` xml
<my-custom-tag data=(data.someFunction())>
```

We'll also need to transform `if`, `for`, `else-if` and `else`(?) attributes to use the new directive syntax.

I'm sure there will be some other transformations as well, but it is definitely doable.

Thanks again.
 Still actively working on the parser and I'll push some more changes later today. There's still a lot of heavy work to do in Marko to leverage the parser and I think we're leaning toward making breaking changes while also providing a migration tool.

So nothing in the immediate future will be available but still working hard to get this done! I'll probably have to get feedback from @patrick-steele-idem when it is time make changes to Marko. Perhaps we can document the plan to see if we can help from the community as well.
 We could definitely start on the migration tool right now so that it would be ready and well-tested in time for the switch to the new parser. That's an area where we could definitely use some more help from the community. I'll open another Github issue for that task.
 Thoughts on the following?:

``` xml
<var foo=1 hello='World'/>
```

Output JavaScript:

``` javascript
var foo=1;
var hello='World';
```

Old style:

``` xml
<var name="foo" value="1"/>
<var name="hello" value="'World'"/>
```
 Yes, like `<var foo=1 hello='World'/>`!

Also, I would like to propose this:

Declare function:

``` xml
<function doSomething(a, b, c)>
</function>
```

Call function:

``` xml
<doSomething(a, b, c) />
```
 Also, we currently support simple conditionals in Marko:

``` xml
<div class="{?data.isActive;active}">
```

How should we support that with the new parser?

This should of course work in the new parser, but it is a little uglier:

``` xml
<div class=data.isActive?'active':''>
```
 @yomed one variable per line is a coding style. Doesn't really matter to the compiler and it could go either way.
 Thanks for the feedback @yomed. I'm leaning towards standard JS as well. 
 I agree @mlrawlings. That's definitely allowed in Marko v3 and would work as expected. Thanks for pointing that out. I'm definitely looking forward to the new Marko v3 syntax :)
 This feature has been implemented.
  Hi @aaronshaf, can you please be more specific on which aspects of the Angular 2 syntax interest you? Some of the syntax is related to event binding, one-way versus two-way data-binding, etc.

On a related note, this has been discussed in a few other issues, but longer term we are thinking about replacing the HTML parser with a new parser that can recognize types of attributes. With an HTML parser every attribute is a string regardless if it is quoted or not. Here's what we are thinking:

``` xml
<my-component number=1/>
<my-component expression=(a + b)/>
<my-component string="hello"/>
<my-component string-concatenated=("hello"+a)/>
<my-component boolean=true/>
```

Thoughts?
 Hi @aaronshaf, I decided to create a more formal proposal for introducing typed attributes. Please take a look at the following and provide feedback if you get a chance: https://github.com/raptorjs/marko/issues/90 
 Closing this issue in favor of the proposal for #90. We want to make Marko a more powerful blend of JavaScript and HTML by adopting JavaScript as the type for all HTML attributes.
    Hi @kobenauf, I am not able to reproduce the issue so there must be something else that is coming into play. What version of `marko` are you using?

I created a simple project to test with and everything renders as expected:
https://github.com/patrick-steele-idem/marko-issue-82

Please try to reproduce the problem in that project or share your own simple project to reproduce the problem. Thank you.
 Correct, each standalone template needs to be independent and well-formed HTML since each template is parsed using an HTML parser. In practice this is really not a limitation but it does put a constraint on how to code your templates. I recommend using the layout taglib to piece together your page instead of includes. Please see: https://github.com/raptorjs/marko#layout-taglib

Please let me know if that does or does not work for you. I'm going to go ahead and close this issue, but we can discuss some more here if you would like or in the Gitter chat room: https://gitter.im/raptorjs/marko
  If I am following correctly then I would agree with @DanCech that you are looking to do a server-side redirect. Please let us know if that is the answer you are looking for or if there is a question more specific to Marko.
  Thanks for the improved fix!
 New version published with fix: `marko@2.4.3` 
  Try this:

``` javascript
var markoCompiler = require('marko/compiler');
markoCompiler.compile(templateStr, templatePath, function(err, compiledCode) {
    if (err) {
        return callback(err);
    }
    // handle compiledCode here
});
```

The `templatePath` argument is used for resolving taglibs/includes and error reporting; there doesn't actually have to be a template file at this path.

Let me know if that works for you and I can close this issue.
 The "Try Online" section of the raptorjs website does client-side compilation of Marko templates:
http://raptorjs.org/marko/try-online/

The client code that does the compiling is here:
https://github.com/raptorjs/website/blob/master/src/components/app-marko-try-online/widget.js

This uses [Lasso](https://travis-ci.org/lasso-js/lasso) (formerly named "Optimizer") instead of Browserify.

Is not possible to pre-compile your templates during build or on server-side? This would be the most efficient way to compile templates.
 Hi @yazla, it's almost always a bad idea to compile a template in the browser with any template engine (compilation is relatively slow and sending the compiler to the browser introduces a lot of extra overhead). The Marko compiler is designed to run on the server in a Node.js environment where it can access the file system and have access to other taglibs installed via npm. Sorry Marko didn't work out for you, but I think you should reconsider compiling templates in the browser.

Just to be clear, if you do what is suggested in the docs and enable the [markoify](https://github.com/raptorjs/markoify) transform for browserify then the compiled template will automatically be sent down to the browser and your code to render templates will just work. Please see the [Using Browserify](https://github.com/raptorjs/marko#using-browserify) section in the docs. Let us know if you still have questions.
 @yazla, I see where you are coming from, but I still don't see why it is any different to bundle up the compiled templates versus the uncompiled templates. The compiled template is just a standard CommonJS module that exports a function that can be used to load a `Template` instance. For example:

``` javascript
var template = require('marko').load(require('./my-template.marko.js'));
```

The above code works if the template has already been compiled (i.e. the `*.marko.js` file already exists). In the case where the template is not compiled the `markoify` transform will do that for you automatically if the code to load your template is in the following form:

``` javascript
var template = require('marko').load(require.resolve('./my-template.marko'));
```

If it helps, you can use the `markoc` command line compiler to compile all of your templates to CommonJS modules beforehand. For example, to compile all templates in the current directory and all sub directories:

``` bash
npm install marko --global
markoc .
```

I hope that helps.
 Hi @tonii75, the compiler does work in the browser but it does require that you use the Lasso.js module runtime in the browser since the Browserify module runtime doesn't support dynamic requires. For the "Try Marko Online" feature we are using the compiler in the browser. Here's the relevant code:
https://github.com/marko-js/markojs.com/blob/master/src/components/app-try-marko/index.js

I hope that helps. If you want to discuss further might be better to open a new Github issue.
  I'm not seeing any failing tests and our CI never reported any failing tests. I will take a look and see if I can reproduce and report back soon.

Thanks for reporting the problem.
 @viviangledhill I just did a refresh `npm install` with the latest code of `marko@2.4.0` (`master` branch) and I am still not able to reproduce the problem. Which version of marko are you testing with?
 I also tested with the latest code on the `v1.6` branch and am not able to reproduce.
 Also, one other thought: if you have `marko-layout` or `marko-async` installed as dependencies in your project then you should remove those dependencies. Both `marko-layout` and `marko-async` are core dependencies of `marko` and are already included. Having multiple versions of those modules might be causing problems in your app.
 @viviangledhill Did you try deleting your `node_modules` directory?
 Ok. Interesting. I'll look into making a change to prevent the core taglibs from loading multiple times even though it is an edge case. Thanks for the update and I'm glad you got everything working.
  Thanks for improving the documentation!
  @patbegg Can you confirm what version of marko you have installed? This looks to be the same bug that was previously fixed: https://github.com/raptorjs/marko/issues/60

I am not able to reproduce the problem when compiling the following template with the latest version of marko (`v2.3.2`):

``` xml
<layout-use template="./layout.marko">
    <layout-put into="foo">
        <div class="c c2 span-8-collapse">
            <div class="c-inner">
                <dl class="summary-list">
                    <dt>
                        <h3>Intuitive Features Wrapped Up In a Smart Interface</h3>
                    </dt>
                    <dd>
                        <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</p>
                        <span class="blue">&#9656; </span><a href="/features">Explore the Features</a>
                    </dd>

                    <dt>
                        <h3>Pay-as-you-go + Monthly Plans Available</h3>
                    </dt>
                    <dd>
                        <p>Whether you're publishing lots or publishing little we have a plan that's great value and can scale up/down as your needs do, and you're free to cancel anytime.</p>
                        <span class="blue">&#9656; </span><a href="/pricing">Choose a plan that's right for you</a>
                    </dd>
                    <dt>
                        <h3 class="green">Start Now - No Obligation 14 Day Free Trial</h3>
                    </dt>
                    <dd>
                        <p>We don't expect you to make a decision before you've kicked the tyres and shown your boss so we offer a no obligation 14 day free trial to everyone.</p>
                        <span class="green">&#9656; </span><a href="/features#analytics" class="green">Bored of reading and want to try it for yourself? Start your free trial now</a>
                    </dd>
                </dl>
            </div>
        </div>
    </layout-put>
</layout-use>
```
 @patbegg The [view-engine](https://github.com/raptorjs/view-engine) modules were an attempt to normalize the APIs for rendering templates across multiple template engines and to ensure that all templates are loaded as CommonJS modules, but it never really got any traction. We'll fix bugs (and update dependencies when requested), but if you are just using Marko then I would suggest dropping the usage of the `view-engine` modules and just use `marko` directly for loading and rendering templates (no middleman and less overhead). While not officially deprecated, I personally don't think it is worthwhile to continue investing in or using the `view-engine` modules. If you still want to use `view-engine` then please let me know and if you find issues please open the issue against the appropriate Git repo.

In the mean time I will look into doing a new release for the [view-engine-marko](https://github.com/raptorjs/view-engine-marko) module. Thanks.
 Update: A new major version of `view-engine-marko` was published that tracks `marko@^2`: `view-engine-marko@2.0.0`

To upgrade to the latest version:

``` bash
npm install view-engine-marko@^2 --save
```

I'm closing the issue for now. Please let me know if you still see issues and we can reopen if needed.
  Hi Sara,

Does your `<app-fieldset>` custom tag have a `renderer.js`? If so, which syntax of the following does your `renderer.js` use?

**Option 1:**

``` javascript
exports.renderer = function(input, out) { ... }
```

**Option 2:**

``` javascript
module.exports = function renderer(input, out) { ... }
```

If you have a circular dependency you need to use **Option 1** since it allows for a partially loaded module to be returned. It is recommended that you always use the syntax shown in **Option 1**. If you do not have a `renderer.js` then I'll probably need more details to reproduce the problem.

Thanks,
Patrick
 This issue was fixed as part of the fixes for #66. Closing this issue, but please let me know if you are still facing problems. Thanks.
  @schetnikovich Excellent proposal! You did a great job capturing the disconnect between nested tags and how their values are actually used by the parent widget. I think you're exactly right that they're more like attributes since the complex values for the nested tag get stored the same way as attributes (based on the proposals we have so far).

We need to make sure that this remains valid HTML. I don't think the HTML parser will allow `.` and `@` in the tag names (haven't verified this yet), and for that reason we could try to use XML namespaces instead of a new syntax. For example:

``` xml
<app-tabs>
    <app-tabs:tab label="Tab 1">
        Content for Tab 1
    </app-tabs:tab>
    <app-tabs:tab label="Tab 2">
        Content for Tab 1
    </app-tabs:tab>
</app-tabs>
```

At one name every tag could be put into a namespace but then we decided to require that all tags be named uniquely. For example, instead of creating a namespace with name "app" and using `<app:tabs>` we moved toward `<app-tabs>`. I think we need to completely remove that namespace code.

Also, I wonder if we can support nested tags within nested tags. For example, using the namespace notation:

``` xml
<app-tabs>
    <app-tabs:tab>
        <app-tabs:tab:label>Tab 1</app-tabs:tab:label>
        Content for Tab 1
    </app-tabs:tab>
    <app-tabs:tab>
        <app-tabs:tab:label>Tab 2</app-tabs:tab:label>
        Content for Tab 1
    </app-tabs:tab>
</app-tabs>
```

If the HTML parser will allow `@` and `.` in an HTML tag then it might be worth considering that notation as well. We could fork the HTML parser that we are using. There is a precedence of using `@` to indicate attributes. If we could interpret `@` to mean "this tag belongs to the closest parent tag" then we could automatically bind nested tags as attributes to parent tag. If the nested tag is not the direct descendant then maybe we could support a qualifier.

For example, simple case that doesn't require qualifiers:

``` xml
<app-tabs>
    <@tab>
        <@label>Tab 1</@label>
        Content for Tab 1
    </@tab>
    <@tab>
        <@label>Tab 2</@label>
        Content for Tab 1
    </@tab>
</app-tabs>
```

For example, less simple case that does require qualifiers:

``` xml
<app-tabs>
    <if test="data.readOnly">
        <@app-tabs.tab>
            <@label>Tab 1</@label>
            Content for Tab 1
        </@app-tabs.tab>
    </if>
    <@tab>
        <@label>Tab 2</@label>
        Content for Tab 1
    </@tab>
</app-tabs>
```

Also, if we go this route then we'll need to enhance the Marko syntax highlighter for Atom (and possibly create one for other editors such as Sublime Text). Even on Github you can see that the syntax highlighter doesn't know how to highlight tags with `@`.

If we hit limitations with the HTML parser that we're using then maybe we should consider writing our own because that would provide some other niceties.

I've been interested in doing this:

``` xml
<app-button size=${data.buttonSize}></app-button>
```

I'm definitely going to think about this some more!
 Thanks for the proposal, @schetnikovich. I like the idea of having a shorthand for nested tags. 

Technically, HTML 5 does allow any character for the tag name but the first character must match`[a-zA-Z]`. This only made clear if you look at the tokenization spec:
http://www.w3.org/TR/2011/WD-html5-20110113/tokenization.html#tag-open-state
http://www.w3.org/TR/2011/WD-html5-20110113/tokenization.html#tag-name-state

Therefore, unless we fork the parser that we are using and are willing to break syntax highlight in all HTML editors then we should conform to the HTML spec.

I don't consider `<attribute>` as a replacement for repeatable nested tags for two reasons:
- Marko already supports nested `<attr>` tags that can be used to add HTML attributes to the parent element (not documented, but [here is a relevant test](https://github.com/raptorjs/marko/blob/9e3bbfe882af26e9eda63a5e86e69651a3a3dfcb/test/fixtures/templates/nested-attrs/template.marko#L4-L5))
- Real attributes cannot be repeated

Just to be clear, the following is already supported:

``` html
<app-tabs>
    <app-tab>
        <attr name="label">Tab 1</attr>
        Content for Tab 1
    </app-tab>
    <app-tab>
        <attr name="label">Tab 2</attr>
        Content for Tab 2
    </app-tab>
</app-tabs>
```

Regarding nested tags, I think we should consider the following options:

## Option 1: Use a colon to namespace nested tags:

``` html
<app-tabs>
    <app-tabs:tab label="Tab 1">
        Content for Tab 1
    </app-tabs:tab>
    <app-tabs:tab label="Tab 2">
        Content for Tab 2
    </app-tabs:tab>
</app-tabs>
```

Pros:
- The colon character is already associated with namespacing and a nested tag is namespaced within a parent element.
- In the future, we may want to support a short-hand by dropping the parent namespace part (e.g., `<app-tabs:tab>` â†’ `<:tab>`
- Most HTML editors should not have a problem with a colon character in a tag name

Cons:
- Looks like XML namespaces (can be a turn off to some people)
- Colon character is harder to type (requires the `SHIFT` key)
- More typing

## Option 2: use a period to namespace nested tags:

``` html
<app-tabs>
    <app-tabs.tab label="Tab 1">
        Content for Tab 1
    </app-tabs.tab>
    <app-tabs.tab label="Tab 2">
        Content for Tab 2
    </app-tabs.tab>
</app-tabs>
```

Pros
- Same as Option 1 _plus_ the period character is easier to type (no `SHIFT` key)

Cons
- Not sure how most HTML editors, parsers and linters will feel about a `period` character in the tag name
- More typing

## Option 3: Use a dash separator for the nested tag name:

``` html
<app-tabs>
    <app-tabs-tab label="Tab 1">
        Content for Tab 1
    </app-tabs-tab>
    <app-tabs-tab label="Tab 2">
        Content for Tab 2
    </app-tabs-tab>
</app-tabs>
```

## Option 4: Use no explicit namespacing and just rely on a unique tag name:

``` html
<app-tabs>
    <app-tab label="Tab 1">
        Content for Tab 1
    </app-tab>
    <app-tab label="Tab 2">
        Content for Tab 2
    </app-tab>
</app-tabs>
```

---

Thoughts on which option is best? I'm leaning towards Option 2 (using a period as a separator), but I think we need to see how various tools feel about a period in the tag name.
 @schetnikovich I think I missed the main purpose of your proposal. Your goal was to normalize attributes and nested tags and I think that is a good idea. What do you think of the following variation?:

`app-tabs/marko-taglib.json`:

``` json
{
    "attributes": {
        "orientation": "string",
        "tabs": {
            "type": "object[]",
            "nested-tag": {
                "name": "tab",
                "attributes": {
                    "label": "string",
                    "body": "string"
                }
            }
        }
    }
}
```

You would then have two options for passing in the array of tabs:

## Using the tabs attribute:

``` html
<app-tabs tabs="[ { label: 'Foo', body: 'Content for Foo' }, { label: 'Bar', body: 'Content for Bar' }, ... ]"/>
```

## Using the nested tab tag:

``` html
<app-tabs>
    <app-tabs.tab label="Tab 1">
        Content for Tab 1
    </app-tabs.tab>
    <app-tabs.tab label="Tab 2">
        Content for Tab 2
    </app-tabs.tab>
</app-tabs>
```

---

Also, there is no right answer on whether or an attribute is more appropriate then a nested tag for passing input to a custom tag. Key differences between attributes and nested tags is that attributes cannot be repeated and attributes cannot contain complex markup. Nested tags do not have those limitations. I believe we need to support both attributes and nested tags.
 Completely agree with your comments @DanCech. Even if it is more typing, I think it is better to have some concept of explicit namespacing and I think it is better to avoid the colon character. I could go either way on `<app-tabs.tab>` vs `<app-tabs-tab>`, but I am leaning towards `<app-tabs.tab>` because the syntax makes it clear that it is a nested tag (i.e. not a top-level tag) and that will hint to the user where the nested tag is defined. 

As for `<attr>`, yes that feature is officially supported. It is an oversight that the documentation does not mention `<attr>` tag. Pull requests welcome :)
 I'm in favor of supporting the dot-notation for using nested tags in your HTML. A short-hand of only using something like `<.tab>` would be great too if we can tweak the HTML parser.

I have a new proposal for `marko-tag.json` that should reduce the characters via a short-hand notation.

I propose that we use "@" as a property prefix to identify attributes instead of having to nest them under a `attributes` property.

For example:

``` json
{    
    "@orientation": "string",
    "@tabs <tab>[]": {
        "@label": "string",
        "@body": "string"
    }
}
```

The `@tabs <tab>[]` portion of the example above would be interpreted as:
"tabs can also be provided via one or more nested tab tags"

Thoughts?
 Great suggestion @philidem! I really like the much flatter and more concise structure and I think it allows us to capture all of the same information. I do have a few minor concerns:
1. Symbols have meaning (slightly higher learning curve)
2. The fact that the `tabs` attribute is an expression type would be implicit instead of explicit

We can mitigate the first concern by first introducing developers to the long-hand form (that we would always need to support) and then provide the equivalent short-hand syntax.

:+1: for the following:

``` json
{    
    "@orientation": "string",
    "@tabs <tab>[]": {
        "@label": "string",
        "@body": "string"
    }
}
```
 Just an update. Based on the feedback shared in this Github issue (and the related Github issue of #61) we have made changes to support the following:
- Better support for tags with a parent/child relationship
- Shorthand syntax for defining tags and attributes

The Pull Request is still being reviewed, but you can find the details in the CHANGELOG for the upcoming `marko@2.4.0`: https://github.com/patrick-steele-idem/marko/blob/parent-child/CHANGELOG.md#240

Here's the Pull Request with the changes: #68 

Feedback on this Pull Request is greatly appreciated. Thanks!
 Support for parent/child relationships has been completed. Closing issue.
  Sorry for the delayed response, but better late than never...

You have a few options:

**_Option 1) Access req/res properties using `out.stream`**_

Assuming you render the top-level page template directly to an HTTP response stream using `template.render(viewModel, res)`, you can access the HTTP request and response objects by doing the following:

``` javascript
exports.renderer = function(input, out) {
    var res = out.stream;
    var req = res.req; // The "req" property is added to the "res" object by Express
}
```

**_Option 2) Use continuation local storage (CLS)**_

You could use something like [continuation-local-storage](https://github.com/othiym23/node-continuation-local-storage) (or [request-local](https://www.npmjs.com/package/request-local) which is a small wrapper on top of CLS) to make request-specific information automatically available to all templates and modules, but I've found that CLS can be very problematic. I think you are better off passing in the request-specific globals via the `$global` property or going with Option 1. 

---

I hope that helps. Please feel free to reopen this issue if you would like to discuss some more.
  Currently, to set up a parent/child relationship between custom tags requires a decent amount of code.

Here's an idea how it can be improved:

Let's say we want to achieve the following:

``` html
<app-tabs orientation="vertical">
    <app-tab label="Tab 1">
        Content for Tab 1
    </app-tab>
    <app-tab label="Tab 2">
        Content for Tab 2
    </app-tab>
</app-tabs>
```

This could be described in a single `app-tabs/marko-taglib.json` as shown below:

``` json
{
    "attributes": {
        "orientation": "string"
    },
    "nested-tags": {
        "app-tab": {
            "target-property": "tabs",
            "repeated": true,
            "attributes": {
                "label": "string"
            }
        }
    }
}
```

In the renderer, the nested tabs could be accessed using the `input.tabs` property that will be an array:

``` javascript
exports.renderer = function(input, out) {
    var tabs = input.tabs;
    tabs.forEach(function(tab) {
        // ...
    });
};
```

Another example:

``` html
<app-overlay visible="false">
    <app-overlay-header>
        This is the header content
    </app-overlay-header>
    <app-overlay-body>
        This is the body content
    </app-overlay-body>
    <app-overlay-footer>
        This is the footer content
    </app-overlay-footer>
</app-overlay>
```

This could be described in a single `app-overlay/marko-taglib.json` as shown below:

``` json
{
    "attributes": {
        "visible": "boolean"
    },
    "nested-tags": {
        "app-overlay-header": {
            "target-property": "header",
            "repeated": false
        },
        "app-overlay-body": {
            "target-property": "body",
            "repeated": false
        },
        "app-overlay-footer": {
            "target-property": "footer",
            "repeated": false
        }
    }
}
```

In the renderer, the nested header, body and footer content could be accessed as shown below:

``` javascript
exports.renderer = function(input, out) {
    var header = input.header;
    var body = input.body;
    var footer = input.footer;

    console.log(typeof header.renderBody); // Output: 'function'
    console.log(typeof body.renderBody); // Output: 'function'
    console.log(typeof footer.renderBody); // Output: 'function'
};
```
 I like this concept a lot. It might be helpful to include a snippet of what the compiled output might look like so that we can discuss.

Here are some alternate property names for configuring the nested tag:
- **target-property:** property (a little shorter)
- **repeated:** limit (a numeric value), repeatable

Alternatively have just "target-property" and use `[]` to denote allowed repeatability:
- Allow any number of tabs: `target-property: "tabs[]"`
- Allow one tab: `target-property: "tabs[1]"`
- Allow two tabs: `target-property: "tabs[2]"`
- Allow only a single tab: `target-property: "tab"`

Also, perhaps the target property should always be an array and don't require the compiler to check constraints about repeatability of nested tag.

Something even crazier to avoid some of the JSON clunkiness:

``` json
{
    "attributes": {
        "visible": "boolean"
    },
    "nested-tags": [
        "app-overlay-title => title",
        "app-overlay-header => header[]",
        "app-overlay-body => body[1]",
        "app-overlay-footer => footer[]"
    ]
}
```
 I like the idea of dropping the `repeated`/`repeatable` property and, instead, just use the `[]` suffix to denote something that is repeatable. However, I don't think we should allow `[<max_count>]`.

I think I prefer `target-property` since it I think it is a little more clear that this is the name of the target property.

I don't think we need the short-hand because it prevents attributes from being defined for the nested tags, but I might be able to be persuaded.
 I am worried that repeatable will be the most common case and that people will forget to add the `[]` to the target property name. That's why I was wondering if we should always assume arrays...

I like the shorthand notation for the most common case. We can implement the longhand approach first and then see if shorthand makes sense.
 Definitely don't want to have nested tags always produce an array. I think that will make the tag renderer more complicated than it needs to be.
 @patrick-steele-idem and I discussed this and the proposal looks more like this:

``` json
{
    "attributes": {
        "orientation": "string"
    },
    "taglib": {
        "tags": {
            "app-tab": {
                "target-property": "tabs[]",
                "attributes": {
                    "label": "string"
                }
            }
        }
    }
}
```

Basically, you can now declare taglibs within other tags. If the **target-property** exists for a tag then this creates the parent/child relationship between the parent tag and the child tag. When taglibs are declared within another tag, then that taglib is associated with a parent taglib.
 Thanks for summarizing @philidem. I'm going to start the implementation now.
  New version of marko published with fix: `marko@2.2.2`

Thanks for setting up the project to reproduce the problem and thank you for bringing this problem to our attention!
  Hey @tindli, I'm going through old issues to do some housecleaning. I am going to go ahead and close this issue. If you think that we need to improve the docs in various areas, I would recommend opening a Github issue for each proposal for better tracking purposes.

FYI, I actually haven't done any extensive tests to see how Google indexes pages with client-side reordering. I would be curious to know the answer to that :) However, we have aimed to only do out-of-order rendering for non-bots and browsers with JS enabled. For bots and non-JS users the recommendation has been to not enable client-side reordering (`client-reorder="false"`). Thanks!
  Hi @patbegg. We use an HTML parser that follows the same HTML parser rules as a web browser so each templates should be valid HTML documents which means you can't break out the opening and closing tags for an element into separate templates. However, that is not really a problem in practice and the recommended solution is to use the [layout taglib](https://github.com/raptorjs/marko#layout-taglib) to define the skeleton of your page. For your example, you would want to do something like the following:

**_src/pages/home/template.marko:**_

``` html
<layout-use template="../layouts/default/template.marko">
    <layout-put into="title">My Page Title</layout-put>
    <layout-put into="body">content here</layout-put>
</layout-use>
```

**_src/layouts/default/template.marko:**_

``` html
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title><layout-placeholder name="title"/></title>
</head>
<body>
    <app-header/>
    <div>
        <layout-placeholder name="body"/>
    </div>
    <app-footer/>
</body>
</html>
```

Let me know if that does or does not solve your problem.
 You're welcome. I hope that solution worked out for you.
  Welcome to Marko and Node, @patbegg! There are two ways to pass along data:
1. As part of the attributes on the custom tag
2. As part of global data that is made available to all custom tags (as part of the `out` object).

You want to take advantage of the second option and provide global data. This is described in the following section of the docs: https://github.com/raptorjs/marko#global-properties

Here's some code that matches your example:

``` javascript
template.render({
        $global: {
            env: 'development'
        },
        ... // All other non-global data
    });
```

And then in any rendered template:

``` html
<if test="out.global.env == 'development'">
```

NOTE: `out.global.env` is used instead of `data.env`.

Please confirm that that solves your problem. Let us know know if you have any other questions.
 Glad that solved your problem. Happy coding!
  Let's create some logos for Marko!

I'll start things off with a really _rough_ sketch of an idea:

![marko-logo-small](https://cloud.githubusercontent.com/assets/978214/6374693/ce18ec78-bccf-11e4-968f-7c06ae73e8e6.jpg)

Please feel free to take that idea and make it better or come up with something completely different.

All logos submitted here will be assumed to be licensed as public domain / [CC0](http://creativecommons.org/about/cc0).

Contributors to the final logo will get credit on the main page and a custom printed T-Shirt with the logo on it!
 @pdajlido I like the logo with the pink lettering because it is simpler. I like the visual elements added around the lettering, but what is the meaning of the lattice decoration?

Also, I think it works well if the graphic part of the logo could be used independent of the "Marko" text and for the graphic part to be easily recognizable and unique (if that makes sense).
 Instead of `><><` (which looks like two X's), I would lean more towards `<><>` since it matches how the characters would appear in an HTML tag. Maybe something can be done with a double diamond :)
 I like the upper-right "M" logo. Might want to create a companion logo that contains "Marko" as well. I do like the diamond concept.
 I didn't see two "X"s at first but now that's all I see for "><><". Maybe "<><>" As @patrick-steele-idem suggested would be better.
 @seangates Even "dumb" ideas can inspire something better! What is "Mark" though? Just kidding :)
 ![marko-logo-01](https://cloud.githubusercontent.com/assets/978214/6874018/bd5efd20-d479-11e4-9f0e-24ca36bfbc08.png)
 @patrick-steele-idem Maybe ".Marko" instead of "Marko."

Or maybe ".marko" (lower case)
 ![marko-logo-01](https://cloud.githubusercontent.com/assets/978214/6875756/1917e016-d487-11e4-9b7e-f7fdc7e6a75a.png)
![marko-logo-02](https://cloud.githubusercontent.com/assets/978214/6875757/19198b6e-d487-11e4-9bce-098856955d3d.png)
 Hah, nice @pdajlido! I'm curious as to what others think of adding a character to the logo, but I might like it :) A logo with a character seems to have worked well for [Yeoman](http://yeoman.io/)
 Also, for Marko Widgets you could modify the dude to be a mad scientist.
 Thanks for the contributions, @pdajlido! 
 ![marko-logo-03](https://cloud.githubusercontent.com/assets/978214/6877648/975279c6-d498-11e4-9b92-bfb4afaf571f.png)
 Hey folks, while we had a some great submissions we decided to get the help of some professionals. We started a logo contest on 99designs.com yesterday and are getting some great submissions:

https://99designs.com/logo-design/contests/create-logo-marko-open-source-programming-project-ebay-531819/entries

If you have any thoughts please share so that we can provide feedback to the designers. Also, after the contest progresses some more I'll share a poll so that we can get more input. Thanks!
 Link to contest entries?
 Accidentally pressed the wrong button... Comment updated with link to contest. Thanks.
 Hi folks,

We created two separate polls to help us choose a logo (99designs.com limits each poll to only 8 logos each):

Poll 1: https://99designs.com/logo-design/vote-d19zuf
Poll 2: https://99designs.com/logo-design/vote-3qyhyb 

Please vote! Thanks!
 Hi folks,

Thank you all for the votes in the earlier polls! We have one more poll (last one, I promise). Please give your ratings for the last set of designs:

Final poll: https://99designs.com/logo-design/vote-bdarln

We will use the final poll to help select the winner. Thanks in advance!
 Marko has a new logo!

![Marko Logo](https://cloud.githubusercontent.com/assets/978214/9265711/774768ca-41f4-11e5-81ee-8fff2cae7e9a.png)
  @fierysunset Is the problem that the `attribute` input value in your example is not available when using `c-input`? Since you can only have one input to the tag (`c-input` takes precedence in this case) I am guessing that `attribute` will not be passed along. Technically, I think the compiler should flag this as an error.

Here are some alternatives:
- Put the value of `attribute` into `data.someObj` and use `<tagname c-input="data.someObj" />`. For example:

``` javascript
<assign var="data.someObj.attribute" value="test" />
<tagname c-input="data.someObj" />
```
- Don't use `c-input` but allow wildcard attributes for `tagname` tag. See https://github.com/raptorjs/marko#defining-attributes
- Declare a `data` (or some other name) attribute for `tagname` that could be used as an alternate way to provide input. You could then use it like:

``` html
<tagname data="data.someObj" attribute="test"/>
```

Because `data` is not a special attribute, the renderer for `tagname` could access both `data` and `attribute`.
 I think the desired behavior is for the attributes to be merged into the data object provided by `c-input`. The properties provided via attributes should take precedence over the properties in the the `c-input` object. Also, we should not modify the object provided via `c-input` and instead create a new object with the merged properties.

Is that what you are thinking as well, @fierysunset ? Thoughts @philidem ?
 Also, there are plenty of workarounds to avoid making this change, but I do think it is something we should just go ahead and fix since the current behavior of silently discarding the attributes when used in conjunction with `c-input` is not right.
 New version published: `marko@2.3.0`
  Please fix the jshint error so that the build will pass. Also, jshint plugins/packages for your code editor are really helpful if you don't have one installed.

See https://travis-ci.org/raptorjs/marko/jobs/54955691
 Published marko@2.1.4
Thanks Sean!
  How about the following?:

_component-library/marko-taglib.json__

``` json
{
    "taglib-imports": ["./package.json"]
}
```

Behind the scenes, Marko would read the `package.json` file to find the `dependencies` object. It would then loop over all of the module dependencies and do the following:

``` javascript
var taglibPathToTry = require.resolve('<module_name>/marko-taglib.json');

if (taglibPathToTry) {
    // Import the current taglib
}
```

Sound good?
 New versions published with enhancement:

`marko@1.6.7`
`marko@2.1.0`

Test for new feature are passing, but documentation has not been updated. Sample usage:
https://github.com/raptorjs/marko/blob/5a918e85d0a6e38e0aae4c96f5db273e48e1080b/test/test-project/marko-taglib.json#L102

Let me know if you see any issues.
  I agree. The interdependencies between modules and out-of-date modules can cause some strangeness. Besides keeping the changelog up-to-date, we should see if there is a way to detect incompatibilities at runtime when in development mode (might be a tooling issue). Perhaps something that could inspect the `package.json` and `node_modules` to look for inconsistencies.
 Hi @barwin. We do maintain a CHANGELOG.md for Marko:  https://github.com/raptorjs/marko/blob/master/CHANGELOG.md

However, I think an "Upgrade Guide" is needed as well to describe what steps should be taken to upgrade to a new major version. This would be similar to the "Upgrade Guide" added for Marko Widgets: https://github.com/raptorjs/marko-widgets/blob/master/CHANGELOG.md#upgrade-guide

Any other suggestions for making the changelog better?
  # Short answer

Yes, you can use Marko with webpack. You just need to enable the [markoify](https://github.com/raptorjs/markoify) Browserify transform for webpack: https://github.com/raptorjs/marko#using-browserify

To use a browserify transform with webpack you can use the following webpack loader: https://github.com/webpack/transform-loader

In theory, it would probably be trivial to build a custom Marko loader for webpack, but it is not something we have plans to do. If you or someone else wants to introduce a marko-loader for webpack I'm sure that would be helpful to others.

# Long answer

Marko templates compile down to standard CommonJS JavaScript modules. If you pre-compile all of your templates, then the following code will always work with webpack or any other JavaScript module loader:

``` javascript
var template = require('marko').load(require('./template.marko.js'));
```

You can pre-compile your templates using the `markoc` command line utility. For example:

``` bash
markoc .
```

Pre-compilation is kind of a pain since you need to typically set up a file watching service (or Gulp/Grunt build script) compile on templates on change, but it works.

To avoid pre-compilation, we recommend the following code to load a template:

``` javascript
var template = require('marko').load(require.resolve('./template.marko'));
```

That code will work on the server-side no problem, but Browserify and WebPack do not recognize and support `require.resolve` so you must use a Browserify transform to compile the Marko template automatically and transform the code to the following:

``` javascript
var template = require('marko').load(require('./template.marko.js'));
```

That's exactly what the following Browserify transform does for you: https://github.com/raptorjs/markoify

---

I hope that answers your question.

As a side note, you might want to consider using the [optimizer](https://github.com/raptorjs/optimizer) since it is more feature-rich JavaScript module bundler that also supports CSS, code splitting, bundling, lazy loading, etc.
 I've not tried using marko with webpack, but I suspect that the webpack bundler is choking due to the following lines: https://github.com/raptorjs/raptor-logging/blob/b5045817e413e29077fa6fc7ac9de3243167c679/lib/raptor-logging.js#L1-L7

I'm not sure what to suggest in this case, because it seems like a bug in webpack since [lasso](https://github.com/lasso-js/lasso) and [browserify](http://browserify.org/) have no issues. If anyone knows of a workaround for webpack please share.
 Hey @wheresrhys, I think the right thing to do here is to use the [markoify](https://github.com/marko-js/markoify) Browserify transform with Webpack using the transform loader for webpack:
https://github.com/webpack/transform-loader

The `markoify` transform will auto compile the referenced Marko templates and transform the code to require the generated `.marko.js` file (e.g. `require('./tpl.marko.js')`. Have you given that a try?

Unfortunately, generating the following code would _not_ work since the referenced template may not already be compiled:

``` javascript
__loadTemplate(require("../../components/nav/tpl.marko.js"), require)
```

Marko is designed to generate code that always works on the server. We use `require.resolve('./template.marko')` instead of `require('./template.marko')` because the Node.js require extension for Marko is optional. We provide transforms for JavaScript module bundlers so that referenced templates will automatically be compiled and required in. I hope that clarifies.
 Hey @wheresrhys, were you able to get things working with with the `markoify` transform? If you still think it is need to generate compiled code differently such that it doesn't use `require.resolve('./foo.marko')` and instead uses `require('./foo.marko')` then it might be reasonable to offer that as a compile-time option:

``` javascript
require('marko/compiler').defaultOptions.useRequireExtension = true;
```

I'm doing some housecleaning so I am going to go ahead and close this issue, but please feel free to open another Github issue if you would like to pursue the proposed idea or any other ideas. Thanks!
 @naumovs thanks for sharing. If you are interested in maintaining a loader for others to use I can give you access to `github.com/marko-js/marko-loader`, or the webpack folks may let you maintain the repo at `github.com/webpack/marko-loader`. It would be great to have an official webpack loader for those who want to use webpack (even if the code for the loader is trivial). It would be also good to update the marko docs to describe usage with webpack. Please let me know if you are interested in helping out.
 Marko has been updated to be compatible with wepback. New version published: `marko@3.10.1`

Also see: https://github.com/marko-js/marko-loader
 > It does work, although I'm still getting Webpack warnings:

Yes, for now there is no way to remove the warnings without potentially breaking things. In the next version of Marko we can revisit how the optional "streams" module is enabled for the browser.
  @maxwarch I think you meant to ask this question as a Github issue and not a Pull Request. Please open a Github issue with your question and we can discuss there. Thanks.
  Topics to include:
- Creating nested tags using the following:
  - `body-function`
  - `import-var`
- Compile-time transformers
- Compile-time nodes
- Tag renderers
- `marko-taglib.json` and `marko-tag.json`
 The Marko compile-time API is getting a much-needed refactoring with Marko v3. The plan is to finally provide docs for how to extend Marko at compile-time with Marko v3.
  It is. I think you are running into a problem because you have an instance of `<mytag>` that is _not_ nested within another `<mytag>`. This is causing the scoped `__children` variable to be undefined and you are seeing an error. I suggest the following:

``` json
"import-var": {
    "children": "typeof __children === 'undefined' ? null : __children"
}
```

That should avoid the `__children is undefined` error.
 Glad that worked for you and glad to see that you are taking advantage of these features!

Also, you might want to avoid a generic variable name such as `__children` and instead use `__mytag` or something that makes it clear where the variable came from and avoids possible variable collisions.
 Sounds good. You are right that the documentation related to `body-function`, `renderBody(out)` and `import-var` could be improved. The plan is to eventually provide a separate Markdown document that goes into much more depth on building custom taglibs. There's actually a lot of really interesting things you can do at compile time using a custom transformer that manipulates the AST before the code generation phase. In the mean time, if you have any questions on how to accomplish something please ask here or on Gitter.

I would be curious to check out your wrapper around rendering a React component. I do feel like these two technologies do play nice together and welcome any solutions that can bridge the two.

Closing issue now that you have a working solution.
  Thanks for the fix! New version published: `marko@1.5.4`
  Fixed by 90f7dbf8c496d7c65d776042472fdbac646ef0d0
  This is a known issue with a clean workaround. Marko ignores HTML comments and this breaks IE conditionals since the comments are never written to the output. I've suggested the following workaround in the past:

Create a custom tag named `<app-html>` that maps to the following renderer:

``` javascript
module.exports = function render(input, out) {
    var lang = input.lang;

    out.write(
        '<!DOCTYPE html>' +
        '<!--[if lt IE 7]> <html class="lt-ie9 lt-ie8 lt-ie7" lang="' + lang + '"> <![endif]-->' +
        '<!--[if IE 7]> <html class="lt-ie9 lt-ie8" lang="' + lang + '"> <![endif]-->' +
        '<!--[if IE 8]> <html class="lt-ie9" lang="' + lang + '"> <![endif]-->' +
        '<!--[if !IE]> --><html lang="' + lang + '"><!--<![endif]â€”>');

    input.renderBody(out);

    out.write('</html>');
};
```

Then in your page layout or page template:

``` html
<app-html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Hello World</title>
        ...
    </head>
    <body>
        ...
    </body>
</app-html>
```

Output:

``` html
<!DOCTYPE html>
<!--[if lt IE 7]> <html class="lt-ie9 lt-ie8 lt-ie7" lang="en-us"> <![endif]-->
<!--[if IE 7]> <html class="lt-ie9 lt-ie8" lang="en-us"> <![endif]-->
<!--[if IE 8]> <html class="lt-ie9" lang="en-us"> <![endif]-->
<!--[if !IE]> --><html lang="en-us"><!--<![endif]â€”>
    <head>
        <meta charset="UTF-8">
        <title>Hello World</title>
        ...
    </head>
    <body>
        ...
    </body>
</html>
```

The benefit of this approach is that the HTML template is cleaner. In theory, we could look into a code change to introduce special handling for IE HTML comments. I'm open to ideas and/or Pull Requests, but hopefully the workaround solves your problem for now.
 New version published with improvement: `marko@2.7.0`
 Thanks for letting me know @yomed. IE conditional HTML comments are automatically preserved now so the workaround discussed is not needed. 
 That's true, variables inside comments are not resolved. Does keep the template code cleaner as well. Thanks for sharing.
  The HTML syntax does not allow attribute types to be distinguished (similar to JSON). This is unfortunate, but short of introducing a new language we must live with a separate schema that informs the compiler of the types of each attribute. Alternatively, we would assume that every attribute is a string and for `$`/`${ }` to change the type (more typing and ugly).

Therefore, in your example, you would just need to do the following:

``` json
{
    "attributes": {
        "viewModel": "expression",
        "options": "expression"
    }
}
```

If we were willing to depart from an HTML parser, we could create our own HTML-like parser that supports the following:

``` html
<my-component number=1/>
<my-component expression=(a + b)/>
<my-component string="hello"/>
<my-component boolean=true/>
```

If we were to go that route then we would lose syntax highlighting/completion/validation support from existing HTML editors and tools like [Emmet](http://emmet.io/).
 Closing issue as I don't think there are any short-term actionable items. If you disagree please feel free to add comments.
 Hey @pedramphp, please provide comments on the following proposal: https://github.com/raptorjs/marko/issues/90 
  Can you provide more details or a reproducible test? I have not run into a case where the stack trace was not valid. Are you sure the problem does not reside in your code?
 @pedramphp ping. Can you please provide more details?
 I just created a project to try and reproduce and I am not able to reproduce the problem. Here is the error that I see logged:

```
/Users/psteeleidem/temp/marko-issue-25/components/app-foo/renderer.js:3
Â  Â  var a = t.a;
Â  Â  Â  Â  Â  Â  Â ^
TypeError: Cannot read property 'a' of null
Â  Â  at Function.module.exports (/Users/psteeleidem/temp/marko-issue-25/components/app-foo/renderer.js:3:14)
Â  Â  at module.exports.t (/Users/psteeleidem/temp/marko-issue-25/node_modules/marko/runtime/helpers.js:127:14)
Â  Â  at render (/Users/psteeleidem/temp/marko-issue-25/template.marko.js:9:5)
Â  Â  at Object.Template.render (/Users/psteeleidem/temp/marko-issue-25/node_modules/marko/runtime/marko-runtime.js:126:9)
Â  Â  at Object.<anonymous> (/Users/psteeleidem/temp/marko-issue-25/index.js:2:10)
Â  Â  at Module._compile (module.js:456:26)
Â  Â  at Object.Module._extensions..js (module.js:474:10)
Â  Â  at Module.load (module.js:356:32)
Â  Â  at Function.Module._load (module.js:312:12)
Â  Â  at Function.Module.runMain (module.js:497:10)
```

I don't believe the problem is with Marko. Please check your project setup because I suspect you have some error handling code that is not displaying caught errors correctly. 
  Hi @bkniffler, a custom tag is just a mapping to a `render(input, out)` function that gets resolved at compile time. It's possible to invoke a render function directly instead of going through a custom tag and I think that might help in your case. This is done using the [`<invoke>` tag](https://github.com/raptorjs/marko#invoke) as shown below:

``` html
<!-- Loop over components, each which as a render function and an input model -->
<div for="item in data.components">
   <!-- Invoke the render function for the current item using the current item's input model -->
    <invoke function="item.render(item.value, out)"/>
</div>
```

NOTE: A loaded template also has a `template.render(input, out)` function so you could also do the following:

``` html
<invoke function="item.template.render(item.value, out)"/>
```

I'm not sure if you are using the RaptorJS Optimizer or Browserify, but the RaptorJS Optimizer supports dynamic requires while Browserify does not. Therefore, if you are using the RaptorJS Optimizer then you can send down all of the templates that may be needed on the client and dynamically require them instead of relying only on static code analysis. You can use a glob pattern to send down all of the templates in a directory as shown below:

_optimizer.json_

``` json
{
    "dependencies": [
        "*.marko"
    ]
}
```

Those templates could be dynamically required doing something similar to the following:

``` javascript
var template = require('marko').load(require.resolve('./components/' + componentName + '/template.marko'));
```

NOTE: We currently don't register the `*.marko.html` extension for the [optimizer-marko](https://github.com/raptorjs/optimizer-marko) plugin so you might need to send a PR for the plugin.

Does this help in your use case? If not, please provide more details.
 @bkniffler I would recommend an approach that uses a single component/tag that simply delegates rendering to multiple other components/renderers.

For example, I often run into the use case of choosing a template based on a `type` or `layout` attribute. Consider the case where you might want to do something like this:

``` xml
<app-message type="info">${data.message}</app-message>
<app-message type="warning">${data.message}</app-message>
<app-message type="error">${data.message}</app-message>
```

Depending on your use case, this might be simpler than having three separate tags (`app-info-message`, `app-warning-message`, and `app-error-message`, for example).

In this example, `app-message` may have a template for each type of message. The `app-message` renderer would simply choose the right template based on the type.

The `app-message` component would have a `renderer.js` with something like this:

``` javascript
var marko = require('marko');

var TEMPLATE_BY_TYPE = {
    info: marko.load(require.resolve('./info.marko')),
    warning: marko.load(require.resolve('./warning.marko')),
    error: marko.load(require.resolve('./error.marko'))
};

module.exports = function(input, out) {
    // find the template that maps to the given type
    var template = TEMPLATE_BY_TYPE[input.type];
    if (!template) {
        throw new Error('Invalid type "' + input.type + '".');
    }

    // now render the template
    template.render(input, out);
}
```

In summary, I think this logic of choosing a template would be easier to read if the developer moved this logic to the renderer. I don't think there would be much benefit of implementing this "choosing" logic in the template.

Please let me know if you still don't think the solution from @patrick-steele-idem or myself would help in your use case (or if you are still looking for a more elegant solution).
  The meaning of `render-tag-if` is unclear since it could easily just be interpreted to be the same as `if`. That is, `render-tag-if` doesn't make it clear that only the body will render if the condition evaluates to `false`. `body-only-if` makes it clear that only the body content will be rendered (not the surrounding tag) if the condition evaluates to `true`.

Since `body-only-if` will rarely be used, I'm inclined to keep its usage as-is. What do you think?
 I didn't know about `body-only-if` until I saw this issue, but after learning about it I would recommend keeping `body-only-if`. For me, the intention is to only render the body (and less about only rendering the tag). Kind of confusing but I think it works :)
 @pedramphp, I agree with you that `body-only-if` feels a little backwards, but I am not seeing a better name. Thank you for the suggestion, but let's stick with `body-only-if` unless you have another idea on how this functionality could be provided in a less confusing way. 
  Syntax highlighting for Marko templates in Sublime would be great. Personally, I switched to from Sublime to Atom and am happier with Atom. I don't remember the exact method for creating a new language file for Sublime, but here is the grammar file that I created for Atom:
https://github.com/raptorjs/atom-language-marko/blob/master/grammars/marko.cson

I'm sure it is possible to write a tool that converts the Atom grammar into a Sublime grammar, but it is not something that I have time to do right now. I think it would be great if someone from the community could contribute Sublime support.
 That's awesome, @merwan7... thank you for the contribution! Do you mind submitting a PR to marko to add `sublime-marko` to the [Tools](https://github.com/marko-js/marko#tools) section in the marko `README.md` file?

Out of curiosity, how did you go about converting the Atom grammar file to work for Sublime? Was there an existing tool that you used? 

Thanks again!
 Just closing old issues... Syntax highlighting in Sublime now works for Marko thanks to the PR submitted by @merwan7 that was merged: https://github.com/wbond/package_control_channel/pull/4652
  I have no objections to adding support for `*.marko.html` except that most editors only let you set file associates based on the last part. Therefore, you would likely lose the ability to have custom syntax highlighting for Marko template files and instead have to settle for HTML syntax highlighting, which is not too terrible I suppose.

Please see my comment I added to your Pull Request and please make sure the tests pass by running `npm test`. 

Thanks for sending the PR.
 New version published: `marko@1.4.0`
 Thanks for the PR, @bkniffler. Updated code looks good.
  Yes, you are correct. Sorry for the missing docs. I don't mind adding the missing docs, but Pull Requests are always welcome.
  Example:

``` html
<some-component c-input="{ message: 'Hello World' }"/>
```

_src/components/some-component/renderer.js:_

``` javascript
module.exports = function render(input, out) {
   var message = input.message; // 'Hello World'
}
```

"template-data" is similar, but it only works for includes. Only one should be documented for consistency.
 FYI, in Marko v3 we are moving to the following syntax:

``` xml
<some-component({message: 'Hello World' })/>
<some-component(data.someObject)/>
```

Will keep issue open because we still need to update the docs.
  Custom tags are resolved to a "renderer" module at compile-time so it is not possible to support something like `<app-test-${path} ...>`. However, a custom tag is mapped directly to a renderer and you can invoke the renderer directly to have the HTML be written to the output stream. One option is to create a custom tag that delegates rendering to the appropriate renderer based on some internal logic. Something like the following:

`src/components/app-test/renderer.js`:

``` javascript
var rendererA = require('./variant-A/renderer');
var rendererB = require('./variant-B/renderer');
var rendererC = require('./variant-C/renderer');

module.exports = function render(input, out) {
    if (input.type === 'A') {
        rendererA(input, out);
    } else if (input.type === 'B') {
        rendererB(input, out);
    } else if (input.type === 'C') {
        rendererC(input, out);
    }
}
```

This nice thing about that approach is that to the outside world there is only a single tag, but internally the custom tag renderer can delegate to the appropriate implementation.

Let us know if that works or doesn't work for you.
 ping. 

Can you please let me know if the proposed solution meets your needs so that I can close this issue or keep it open? Thanks.
  Hi @mattfysh, Marko will remove unnecessary whitespace based on some builtin rules, by default. These rules are partially based on the rules that browser's use to normalize whitespace and partially based on the goal of allowing nicely indented markup. These rules are as follows:
- For whitespace before the first child element: `text = text.replace(/^\n\s*/g, '')`
- For whitespace after the last child element: `text = text.replace(/\n\s*$/g, '')`
- For whitespace between child elements: `text = text.replace(/^\n\s*$/g, '')`
- Any contiguous sequence of whitespace characters is collapsed into a single whitespace character

FYI, the whitespace removal happens in the following code:
[marko/compiler/TextNode.js:112](https://github.com/raptorjs/marko/blob/71ffdf3e4cce257fbd0c09d072462e1e04a207bb/compiler/TextNode.js#L112-L124)

It's possible to disable whitespace removal on a per-element basis using a special attribute applied to a parent element. It's also possible to disable all whitespace removal by changing an option for the compiler. Unfortunately the docs are currently lacking for both these options so I'll describe them below for now:

Option 1) Disable whitespace removal using the `c-whitespace` attribute:

``` html
<div c-whitespace="preserve">
    <my-first-tag>
    <my-second-tag>
</div>
```

Option 2) Disable all whitespace removal by changing a compiler option

``` javascript
require('marko/compiler').defaultOptions.preserveWhitespace = true;
```

Also, you can avoid whitespace removal by avoiding the new line character. For example, the following whitespace between the elements will be preserved:

``` html
<my-first-tag> <my-second-tag>
```

I'll work on adding some formal documentation on the whitespace removal rules. Do these options meet your needs or are you looking for a different solution?
 @mattfysh, I added some documentation to clarify how Marko deals with whitespace:
https://github.com/raptorjs/marko#whitespace

Please let me know what you think.

Thanks,
Patrick
 Perhaps we should add a tag that can be used to enable preservation of whitespace.

For example, something like this:

``` xml
<preserve-whitespace>
<my-first-tag>
<my-second-tag>
</preserve-whitespace>
```

Sometimes there isn't a convenient parent tag to add the `c-whitespace="preserve"` attribute
 I agree regarding introducing a `<preserve-whitespace>` tag. I have added Issue #11 to the backlog.
 Marking issue as closed since additional docs were added clarifying the whitespace rules for Marko. If there are still issues please let us know. Thanks.
  From looking at the code it does look like the taglib loading relies on a path to json file. I'll investigate making changes to allow loading a taglib from object in memory.
 Just to elaborate on @philidem comments (and this may be more information than you need), we only want to support declarative registration of custom tags for the following reasons:
1. Tags need to be discovered at compile time (the templates compile differently based on the set of known tags) and the tags need to be available at runtime (which may be on the server or the client) and it would be awkward to have to register custom tags in both places.
2. The `markoc` command line compiler should to be able to compile templates without running any user JS code (that is tags need to be discovered based on a declarative mechanism)
3. There is no single lookup for all tags and custom tags are discovered relative to a template's location on disk. Among other things, this allows installed modules to have their own custom tags that would not pollute the parent application.
4. Templates are compiled such that custom tag renderers are `require`'d and this allows client-side JavaScript module bundlers to automatically include only the tags that are needed by a compiled template module

I can't think of any reason that you would need to programmatically register new tags at runtime, but if you share more details about your use case then maybe I can offer better help.

Thanks for the feedback. Let us know if you have any more questions.
 Also, if you have ideas on how we can improve how tags are registered then please feel free to share, but there is a requirement that it needs to be declarative (for the reasons above).
 I did investigate this and I came to the same conclusion as Patrick. I think it would have technically been possible to support the definition of tags through a code change but this goes in the opposite direction of modularizing tags and the components that use them. The discovery mechanism for finding tags is an important feature of Marko that allows tags/components to be shared without having to require users to manually register tags. For this reason, I would discourage manually registering tags and instead rely on the discovery of tags from `marko-taglib.json` and `marko-tag.json` files. I would also like to know if relying on these files prevents your project from using Marko effectively.
  On the server-side, the templates utilize the NodeJS module loader so that code in the template can leverage `require()` just like any other CommonJS module. In order to allow requiring modules via relative path, the template module itself needs to have a path which is why it is written to disk. Also, the copy that is written to disk is used for the up-to-date check.

I wonder if there is some hackery that we could do to fake module loading of in-memory code and making it think it is at a specific path.

A while ago, for development in NodeJS, I tried to use a technique of strategically removing modules from the cache but this caused a lot of inconsistencies and I eventually decided to just restart the app (I was really hoping to find a solution that clears the cache...). Perhaps you should consider the route of restarting the app when a source file changes?
 The fact that Marko writes the compiled template to disk in order to load them has very little to do with preventing changes to a template from being reflected without a restart. In fact, in the earlier versions the loader did not write the compiled source to disk and instead used Node.js internals to load the compiled module directly from a source String (see https://github.com/raptorjs/marko/blob/v0.2.0-beta/runtime/lib/loader.js#L6-L17). In case you are curious, the reason we switched to loading compiled templates from disk is so that stack traces would be accurate and it also makes debugging much easier for developers (compiled templates can be debugged just like any other loaded JavaScript modules).

What prevents changes to a template from being immediately reflected is the fact that once the template is loaded there are no checks at each render call to verify if the template is up-to-date and there is no file watching service to invalidate loaded templates. Both of these approaches would add overhead and bring in additional dependencies. With Marko, templates are typically loaded once when a parent module is first required and loaded templates only hold a reference to the JavaScript render function and nothing else. The only cache is the Node.js module cache and the templates are typically referenced as part of the closure of another function. To reload a template without a restart you would need to delete the template module from the `require.cache` and you would need to call `load()` again for all of the templates that were modified.

With that said, it's obviously very important for template changes to be reflected immediately. Otherwise, using Marko would be extremely painful. At eBay, we have had a lot of success with using the [browser-refresh](https://github.com/patrick-steele-idem/browser-refresh) module to automatically restart the server whenever files are modified and the browser-refresh module starts a Web Sockets server to tell web browser pages to reload. This works for all types of resources (CSS/Less/Stylus, JavaScript, Marko templates, Dust templates, etc.) and it ensures that the application is always in a good state since we don't have to worry about messing with Node.js internals to hot reload modules. As long as the server restarts quickly (and it should) then this makes development very productive.  Also, with the browser-refresh module you don't have to change how you structure your application at all. When you want to use the browser-refresh module then you simply use the `browser-refresh` CLI to run the Node.js process, otherwise you just use the standard `node` executable. If you want to try out [browser-refresh](https://github.com/patrick-steele-idem/browser-refresh) with a real app that uses Marko, please check out the sample [weather](https://github.com/raptorjs/raptor-samples/tree/master/weather) app.

If you really don't want to rely on server restarts then you could monkey-patch the loader that `marko` uses to add additional hooks to reload modified templates. Perhaps something like the following:

``` javascript
require('marko-hot-reload').enable(require('marko'));
```

Internally, `marko-hot-reload` module could use [chokidar](https://github.com/paulmillr/chokidar) to detect changes to Marko templates and loaded templates would need to have additional code that runs before each render call to see if the loaded template is still up-to-date. I would advise against going that route and to use [browser-refresh](https://github.com/patrick-steele-idem/browser-refresh) instead, but there are definitely options.

If you have any thoughts please let me know.
 We could make it an option to disable writing a compiled template to disk, but writing the compiled template to disk also provides the benefit that the template does not need to be recompiled if the server is restarted which is kind of nice. I agree that the extra noise of additional files is kind of annoying, but it's a tradeoff. Atom will at least grey out files that are .gitignored (with the option to hide the completely). 

Regardless of if a template is written to disk or not, the resulting module still needs to be loaded through the Node.js module loader. Since a compiled template is loaded through the Node.js module loader you would still need to clear the module from the `require.cache` in order for the template to be reloaded (compiled Marko templates rely heavily on the `require` function so they have to go through the Node.js module loader). Please give [browser-refresh](https://github.com/patrick-steele-idem/browser-refresh) a try and let us know if that doesn't work out for you.

If you were interested in making writing a compiled to disk optional then I would consider a pull request since I think that is a harmless feature. Also, I am not opposed to a separate module enabling hot reloading of Marko templates, but I would rather not pollute the core marko module with that functionality. I'm going to go ahead and close this issue unless you still think there needs to be something done.
 I decided to reopen this issue. After giving it some thought I came up with a clean way to enable template reloading without requiring a full server restart. I'm working on the solution now.
 I have completed the work to add support for Marko template hot-reloading. Usage:

``` javascript
require('marko/hot-reload').enable();
require('fs').watch('somedir', function (event, filename) {
    if (/\.marko$/.test(filename)) {
       require('marko/hot-reload').handleFileModified(filename);
    }
});
```

If hot-reloading is enabled (which should only be done in development), the loaded templates are monkey-patched to detect file changes. If a Marko-related file is modified then the appropriate caches are cleared out so that templates are correctly reloaded. 

Marko still depends on an external file watching service to detect file modifications. That is, Marko does _not_ start its own file watching service to detect changes to `*.marko` files. I added `browser-refresh` integration. If `browser-refresh` is used to start your app then it is already starting a file watching service and the `marko` module can be notified by the `browser-refresh` module when a file is modified (via inter-process communication). To enable hot-reloading _and_ `browser-refresh` integration, the following code should be used:

``` javascript
require('marko/browser-refresh').enable();
```

NOTE: If the app was _not_ started using `browser-refresh` then the above code will be a no-op.

For more details, please see: https://github.com/patrick-steele-idem/browser-refresh#controlling-reloading
 I'll try to reproduce and get back to you.

On a related note, I recommend doing the following:

``` javascript
var formulaTemplate = marko.load(require.resolve('./web/marko/formula.marko'))
app.get('/formula', function(req, res) {
  formulaTemplate.render({}, res)
})
```

The `stream()` method will unnecessarily produce an intermediate stream when it is more efficient to write to the existing `res` stream.
 @Solido, I was not able to reproduce even after installing io.js (v1.0.2). What version of express and marko are you using. Do you have a simplified project that I could try? 
 Hi @Solido, I'll try to answer your question below, but I recommend joining the Marko Gitter chat room for more realtime help: https://gitter.im/raptorjs/marko

Gitter provides great desktop and mobile apps. Definitely recommend checking it out.

<hr>

With Marko you must explicitly pass along any required data to the other templates. Each template gets its own `data` variable.

You didn't share all of your code, but if you are using the `<layout-use>` tag then you can just pass along any data to the target template by doing something similar to the following:

``` html
<use-layout template="path/to/some/layout.marko" some-data="foo">
  <!-- ... -->
</use-layout>
```

The target layout template can then access the data as shown below:

_path/to/some/layout.marko:_

``` html
<div>
  $data.someData
</div>
```

Output:

``` html
<div>foo</div>
```

There's also a feature to support "global" data that is automatically made available to all templates. This feature is supported, but it needs to be documented. The usage is shown below:

``` javascript
var template = require('marko').load('template.marko');
template.render({
    $global: {  // $global is special
      someData: 'foo'
    }
  }
```

You can then access that data in any of your templates using `out.global`:

``` html
<div>
  $out.global.someData
</div>
```
  Great. Thank you for the corrections.
/n  Fix up dangling backtick.

Include missing code snippet.

<!--- Provide a general summary of your changes in the Title above -->

## Description
<!--- Describe your changes in detail -->

## Motivation and Context
<!--- Why is this change required? What problem does it solve? -->
<!--- If it fixes an open issue, please link to the issue here. -->

## Screenshots (if appropriate):

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [ ] My code follows the code style of this project.
- [ ] I have updated/added documentation affected by my changes.
- [ ] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes.
- [ ] All new and existing tests passed.
 
[![Coverage Status](https://coveralls.io/builds/11773032/badge)](https://coveralls.io/builds/11773032)

Coverage remained the same at 89.518% when pulling **fe094a4cc22123f010b1dde482209784b663a6c1 on newyork-anthonyng:feature/an/fix-marko-vs-react-docs** into **37e3dcc4f5a9a3b1628e6dfe5ca3875c57ee75f4 on marko-js:master**.
  <!--- Provide a general summary of your changes in the Title above -->

## Description
<!--- Describe your changes in detail -->
Add silent option to browser-refresh and hot-reload.
## Motivation and Context
<!--- Why is this change required? What problem does it solve? -->
<!--- If it fixes an open issue, please link to the issue here. -->

https://github.com/marko-js/marko/issues/709
## Screenshots (if appropriate):
N/A
## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [ ] My code follows the code style of this project.
- [ ] I have updated/added documentation affected by my changes.
- [ ] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes.
- [ ] All new and existing tests passed.
 
[![Coverage Status](https://coveralls.io/builds/11770843/badge)](https://coveralls.io/builds/11770843)

Coverage decreased (-0.005%) to 89.518% when pulling **218050114bf778c14dfda18fe4c830b800201fef on nahtnam:silent** into **deb95bb48fdcba68de93a029c6975b8ce04c75b9 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/11770843/badge)](https://coveralls.io/builds/11770843)

Coverage decreased (-0.005%) to 89.518% when pulling **218050114bf778c14dfda18fe4c830b800201fef on nahtnam:silent** into **deb95bb48fdcba68de93a029c6975b8ce04c75b9 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/11770843/badge)](https://coveralls.io/builds/11770843)

Coverage decreased (-0.005%) to 89.518% when pulling **218050114bf778c14dfda18fe4c830b800201fef on nahtnam:silent** into **deb95bb48fdcba68de93a029c6975b8ce04c75b9 on marko-js:master**.
  <!----------------------------------------------------------------------
  |     IF FEATURE SUGGESTION (skip to next section for bug reports)    |
  ---------------------------------------------------------------------->
## New Feature
Add an option (`quiet`, or `silent`) that will stop console outputs.
### Description
<!--- Provide a detailed description of the change or addition you are proposing -->
Add the option somewhere like: `require('marko/browser-refresh').enable({ quiet: true });`, that will stop console.logs like the following from being printed.
```
[marko/hot-reload] File modified: /Users/nahtnam/Desktop/testing/app/templates/hello/index.marko
```
### Context
<!--- Why is this change important to you? How would you use it? -->
<!--- How can it benefit other users? -->
I am working on a site and my console output every time my server restarts is bloated. To reduce clutter it would be great to have a quiet option that would only print if there is an error or warning.
### Possible Implementation
N/A
### Open Questions
N/A
### Is this something you're interested in working on?
No I could try, but someone would have to go over the code since I have almost no experience with Marko.

EDIT: Is the main branch master, or something else? I cant find a contributors guide. @patrick-steele-idem @austinkelleher Thanks for your comments. I think I know how to do it. My only question is:

Here: https://github.com/nahtnam/marko/blob/master/src/hot-reload.js#L38 I will add a `option` parameter which will check is `silent` is defined (defaults to false). Do I add that option to the `runtime` variable so the silent option can be accessed in the other functions? I still need to finish the checklist but its a start.  
[![Coverage Status](https://coveralls.io/builds/11767095/badge)](https://coveralls.io/builds/11767095)

Coverage increased (+0.004%) to 89.527% when pulling **f73c2364d53375ba8931d4fc0a53bd97c0e54fba on 705-dynamic-root-id-attr** into **fe60da9c111ae60613e567ab957b47e9b77cebea on master**.
 
[![Coverage Status](https://coveralls.io/builds/11769889/badge)](https://coveralls.io/builds/11769889)

Coverage increased (+0.03%) to 89.558% when pulling **4e6d1fc4cf71227eb0b049e8d0711f37f86e594d on 705-dynamic-root-id-attr** into **fe60da9c111ae60613e567ab957b47e9b77cebea on master**.
 
[![Coverage Status](https://coveralls.io/builds/11769889/badge)](https://coveralls.io/builds/11769889)

Coverage decreased (-0.01%) to 89.509% when pulling **4e6d1fc4cf71227eb0b049e8d0711f37f86e594d on 705-dynamic-root-id-attr** into **fe60da9c111ae60613e567ab957b47e9b77cebea on master**.
  Closes #706.

<!--- Provide a general summary of your changes in the Title above -->

## Description
<!--- Describe your changes in detail -->

## Motivation and Context
<!--- Why is this change required? What problem does it solve? -->
<!--- If it fixes an open issue, please link to the issue here. -->

## Screenshots (if appropriate):

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [ ] My code follows the code style of this project.
- [ ] I have updated/added documentation affected by my changes.
- [X] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes.
- [ ] All new and existing tests passed.
 
[![Coverage Status](https://coveralls.io/builds/11754177/badge)](https://coveralls.io/builds/11754177)

Coverage remained the same at 89.524% when pulling **1b67ac33214058bb524ac4bcd8348c48a62b589b on newyork-anthonyng:feature/an/fix-webpack-readme** into **9e334a8986c9f3752bf5ec37e23e163887adf851 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/11754177/badge)](https://coveralls.io/builds/11754177)

Coverage remained the same at 89.524% when pulling **1b67ac33214058bb524ac4bcd8348c48a62b589b on newyork-anthonyng:feature/an/fix-webpack-readme** into **9e334a8986c9f3752bf5ec37e23e163887adf851 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/11754177/badge)](https://coveralls.io/builds/11754177)

Coverage remained the same at 89.524% when pulling **1b67ac33214058bb524ac4bcd8348c48a62b589b on newyork-anthonyng:feature/an/fix-webpack-readme** into **9e334a8986c9f3752bf5ec37e23e163887adf851 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/11754177/badge)](https://coveralls.io/builds/11754177)

Coverage remained the same at 89.524% when pulling **1b67ac33214058bb524ac4bcd8348c48a62b589b on newyork-anthonyng:feature/an/fix-webpack-readme** into **9e334a8986c9f3752bf5ec37e23e163887adf851 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/11754565/badge)](https://coveralls.io/builds/11754565)

Coverage remained the same at 89.524% when pulling **71416584f1a494f039ef07b076d8e7b20cbbf01f on newyork-anthonyng:feature/an/fix-webpack-readme** into **9e334a8986c9f3752bf5ec37e23e163887adf851 on marko-js:master**.
  <!----------------------
  |     IF BUG REPORT    |
  ---------------------->
## Bug Report
Typo inside the `webpack` markdown file.

### Context
<!--- Provide a more detailed introduction to the issue itself, and why you consider it to be a bug.  How has this bug affected you? What were you trying to accomplish? -->
```html
<!doctype html>
<html>
<body>
    <script src="static/bundle.js"/>
</body>
</html>
```
As far as I know, the `<script>` tag cannot be self-closing, and should be changed to:
```html
<script src="static/bundle.js"></script>
```
I can make a PR to fix this if this makes sense.
### Expected Behavior
<!--- Tell us what should happen -->

### Actual Behavior
<!--- Tell us what happens instead -->

### Possible Fix
<!--- Not obligatory, but suggest a fix or reason for the bug -->

<details><summary>Additional Info</summary>

### Your Environment
<!-- Include as many relevant details about the environment you experienced the bug in -->
* Version used:
* Environment name and version (e.g. Chrome 39, node.js 5.4):
* Operating System and version (desktop or mobile):
* Link to your project:

### Steps to Reproduce
<!--- Provide a link to a live example, or an unambiguous set of steps to -->
<!--- reproduce this bug include code to reproduce, if relevant -->
1. 
2. 
3. 
4. 

### Stack Trace
<!-- If an error is thrown, provide the stack trace here -->

</details>
 @patrick-steele-idem Awesome. I'm starting to dig into Marko and was assuming that it supported self-closing script tags.

I created a new [PR](https://github.com/marko-js/marko/pull/707) to address this. Let me know if anything else is needed.  ## Bug Report

### Context
component state is out of scope inside the include tag

### Expected Behavior
pass state variable to included template

### Actual Behavior
state is undefined

### Steps to Reproduce
I have a component something like

```marko
class {
  onCreate() {
    this.state = { id: 1}
  }
}

//works fine
< input id=state.id  />

//state is undefined
<include(/path/to/generic/input, {id: state.id}) />
<include(/path/to/generic/input) id=state.id />
```

### Stack Trace
```
Uncaught ReferenceError: state is not defined
    at render (index.marko:40)
    at safeRender (renderable.js:6)
    at Template.render (renderable.js:136)
    at doInclude (include-tag.js:17)
    at includeTag (include-tag.js:30)
    at render (index.marko:45)
    at Template.renderSync (renderable.js:69)
    at Object.<anonymous> (index-desktop.marko.js:12)
    at __webpack_require__ (bootstrap e38ec24â€¦:19)
    at Object.<anonymous> (emitter.js:2)
``` That's great, worked straight away. Thanks for the quick response. The space after the input was a typo. Will avoid using id in the future :)  Seems to be related with #702 as error is the same staying at `4.4.2` solves the problem Installing `4.4.5` works fine for me with `npm@5`. Can't reproduce that on node 8 with NPM5 and `4.4.6`, so, it was either my misconfiguration or something already fixed. Will close the issue, thank you!  everything worked fine up until upgrading to marko 4.4.0, when building with webpack, this error cropped up
`var markoCompiler = !(function webpackMissingModule() { var e = new Error("Cannot find module \".\""); e.code = 'MODULE_NOT_FOUND'; throw e; }());`
Downgrading to marko 4.3.1 could fix the problem.
What's wrong? please! I added a github project to reproduce the problem
https://github.com/arthurchenn/markoissue702  Documentation is not proper , We are developing Progressive Web App .  we need client side Routing Mechanism like Iron Router or react Router and Ember Routing  .  Check out https://github.com/marko-js/marko/issues/645 Hey @mauricionr  , Marko 4.*
We have developed webiste and mobile website using Marko 3.* and Marko Widget . Can you suggest We want to upgrade to Marko 4 . Like Marko start providing state  in Marko 4 . Please suggest me regarding this  @gilbert  @patrick-steele-idem  : Can you suggest me  for Marko 4  , We are using marko 3.3 and marko widget . I want to upgrade for marko 4 . In Marko 4 u r proving state View architecture , We can eliminate Marko Widgets ?  @anupdineout this issue https://github.com/marko-js/marko/issues/626 has good stuff about markov3 and markov4 @patrick-steele-idem  any suggestion for Progressive Web app in Marko Js for Mobile website . Can you provide any documenation  or git demo project . i'm following lighthouse 2.0 for best practices on PWA

`npm install -g lighthouse` I dont know , @patrick-steele-idem  , https://github.com/FormidableLabs/redux-little-router  does not provide support for MarkoJS have you seen this one @anupdineout https://github.com/charlieduong94/marko-path-router ? @mauricionr  @patrick-steele-idem  Can you help me to use es6 in MarkoJS 4.  @mauricionr  @patrick-steele-idem  

https://github.com/charlieduong94/marko-path-router ?
I checked this , its not working for me  . I need Client Side routing , otherwise , I need to switch the Technology from Marko4 to React . Please Suggest  Why is not working for you? Hello @anupdineout, I would be happy to help you get `marko-path-router` set up. Please create an issue on my repo detailing the problems you are having so that we can work through them together. @charlieduong94  Thanks for reverting back . Thats was some issue with KOA Aysnc setup . Now working for me   â€¦ayground" does not contain lasso

<!--- Provide a general summary of your changes in the Title above -->

## Description
<!--- Describe your changes in detail -->

## Motivation and Context
<!--- Why is this change required? What problem does it solve? -->
<!--- If it fixes an open issue, please link to the issue here. -->

## Screenshots (if appropriate):

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [ ] My code follows the code style of this project.
- [ ] I have updated/added documentation affected by my changes.
- [ ] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes.
- [ ] All new and existing tests passed.
 
[![Coverage Status](https://coveralls.io/builds/11658451/badge)](https://coveralls.io/builds/11658451)

Coverage increased (+0.4%) to 89.824% when pulling **be03de928ebdf7bcbb390e29b2f3832285de847d on tindli:patch-2** into **a1e6310f08c5816e98c831863bbe8d7cb08bdf8b on marko-js:master**.
  <!--- Provide a general summary of your changes in the Title above -->

## Description
<!--- Describe your changes in detail -->

## Motivation and Context
<!--- Why is this change required? What problem does it solve? -->
<!--- If it fixes an open issue, please link to the issue here. -->

## Screenshots (if appropriate):

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [ ] My code follows the code style of this project.
- [ ] I have updated/added documentation affected by my changes.
- [ ] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes.
- [ ] All new and existing tests passed.
 
[![Coverage Status](https://coveralls.io/builds/11658199/badge)](https://coveralls.io/builds/11658199)

Coverage remained the same at 89.468% when pulling **3a1580d5a6473906c26bc329590627aab065e609 on tindli:patch-1** into **1551993272726fbf2edd35eb20845a63954f902d on marko-js:master**.
  
[![Coverage Status](https://coveralls.io/builds/11611428/badge)](https://coveralls.io/builds/11611428)

Coverage decreased (-0.7%) to 89.496% when pulling **2d0d8000cb9fd577f1eb81932799d6691c369613 on dist-dir** into **3d757a20f39bcb4dc5ae48b4b0d7ed7288e4c407 on master**.
 ðŸ‘ðŸ»  
[![Coverage Status](https://coveralls.io/builds/11594315/badge)](https://coveralls.io/builds/11594315)

Coverage increased (+0.004%) to 90.21% when pulling **4cf05973a593210fefa30bc863371ae4ce214ab9 on 695-xml-unrecognized-tags** into **3d757a20f39bcb4dc5ae48b4b0d7ed7288e4c407 on master**.
 
[![Coverage Status](https://coveralls.io/builds/11594315/badge)](https://coveralls.io/builds/11594315)

Coverage increased (+0.004%) to 90.21% when pulling **4cf05973a593210fefa30bc863371ae4ce214ab9 on 695-xml-unrecognized-tags** into **3d757a20f39bcb4dc5ae48b4b0d7ed7288e4c407 on master**.
   
<!--- Provide a general summary of your changes in the Title above -->

## Description
<!--- Describe your changes in detail -->
enable res.marko can catch a error safe
use like 
```javascript
res.marko(..).catch((err) => {
  next(err);
})
```
## Motivation and Context
<!--- Why is this change required? What problem does it solve? -->
<!--- If it fixes an open issue, please link to the issue here. -->
enable res.marko can catch a error safe
see issue #692

## Screenshots (if appropriate):

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [x] My code follows the code style of this project.
- [ ] I have updated/added documentation affected by my changes.
- [ ] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes.
- [x] All new and existing tests passed.
 
[![Coverage Status](https://coveralls.io/builds/11540128/badge)](https://coveralls.io/builds/11540128)

Coverage remained the same at 90.206% when pulling **6fff9dea1dca773c37fa52e0b3bb1009fd48b827 on moonrailgun:patch-1** into **c648b764f203d0c0284470d6267dfd9864a004f5 on marko-js:master**.
 my pleasure  I actually started encountering this today and have provided an example:

https://github.com/ianvonholt/marko-widget-test/tree/4.4.2

It seems that the onMount of child components is not being executed at all, nor are events being assigned. 

If the parent component has no component logic, no `module.exports` or `class {}`, then it works just fine. 

I provided two examples one with the class logic, one without.  

 I've sat on this one for a couple days and I have to say that I have no definitive conclusion on my stance with this. I understand the performance gains with only having the input/state for the top-level UI component serialized down to the browser. However, this method makes the combination of components rather lacking. 

With the current behavior in `marko@4.3+`, each instance where a developer is going to want nested components to be different for every page will fail to fully boot. Unless, that is, the developer explicitly creates different variations of the parent component with the desired top level UI components, or the component is utilized just as a template. The former bloats the number of components while the latter would remove any sort of logic you may want to apply to the parent component.  @patrick-steele-idem I was just looking through the commit log, looks wonderful. 

I'll run it through some tests on my end and let you know if there are any problems.   I am using vue.js at the moment and am interested in Marko. They are very similar and make it easy to transition one to the other. The one thing noticed is Marko is missing "scoped" but that's for another discussion. No one?   ### Question

Thank you so much for making components take reference in the latest beta version! But it seems like it only takes references from marko template (static). If I want to pass function reference from `component.js` down to child component, the child component still not able to receive the reference. I'm not sure if I'm using it correctly or not. Could you share some working demos to demonstrate passing reference from `component.js` down please? Thanks again! Hi @patrick-steele-idem, thanks for the response. 

I was not able to reproduce this time, maybe I didn't use it correctly that time. But I did encounter a different problem. The references passed down does not able to recgonize the correct execution context. 

/test-component/index.marko
```html
<test-inner-component handler=component.handler />
```

/test-component/component.js
```javascript
module.exports = {
  onCreate () {
    this.value = 'value'
  },
  handler () {
    return this.value // or do anything with the current controller context
  }
}

```

/test-inner-component/index.marko
```html
<div>
  <button on-click('click')>Click</button>
</div>
```
/test-inner-component/component.marko
```javascript
module.exports = {
  click () {
    console.log(this.input.handler())
  }
}
```

Supposely, the console should have a log as `value` printed when I click the button in the `test-inner-component`. But it actually printed `undefined`. 

I even tried to bind context for the function reference in `test-component` at `onCreate`, `onInput` or `onMount` like `this.handler = this.handler.bind(this)`. None of them actually work. 

Could you advise how this `pass reference` suppose to work? Does it only suppose to work without any context? 

Another use case I can think of is to pass marko component into another component, but that leads to another question I created: https://github.com/marko-js/marko/issues/684. How can I pass in a fully functional component (with template and controller) into another component? The only way I'm aware of it to pass in something like this: `require('./a-component.marko')`, but how can I associate a controller with that template? 

Sorry for the long question and thank you for the help. 
  A piece of documentation describing how to use Marko alongside [Huncwot](https://github.com/zaiste/huncwot). I'd be happy to hear your feedback.

## Description
I'm building a library similar to Express and Koa called Huncwot. I'm planning to use Marko as its default (and only) view engine. Huncwot is inspired by Clojure's ring with routes as (pure) functions returning *data* describing responses. In this pull request I'm describing how to use Marko with Huncwot.

## Motivation and Context
Server-side integration example using Huncwot is simpler and requires less code for the same result as in Koa or Express.

## Screenshots (if appropriate):

## Checklist:
- [x] My code follows the code style of this project.
- [X] I have updated/added documentation affected by my changes.
- [X] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes. (N/A)
- [ ] All new and existing tests passed.
 
[![Coverage Status](https://coveralls.io/builds/11347864/badge)](https://coveralls.io/builds/11347864)

Coverage remained the same at 90.204% when pulling **ecbf3a306ddcc6d303a2c45a5bcb9b7ce35a147d on zaiste:docs-marko-huncwot** into **71cc431b1e9f2b59aeaf394ff6a9e9510ff1d8de on marko-js:master**.
  Currently, this:
```js
app.locals.foo = 'foo!';
app.locals.serializedGlobals = { foo: true };
```
Doesn't work, because [`component-globals-tag.js`](https://github.com/marko-js/marko/blob/master/components/taglib/component-globals-tag.js#L20) sets each property to `false` after reading them. If there's a reason for doing that, I can't find it, and removing that line fixes the problem. 
[![Coverage Status](https://coveralls.io/builds/11338800/badge)](https://coveralls.io/builds/11338800)

Coverage decreased (-0.0009%) to 90.203% when pulling **3f5e28b4e7612a2254d6a600d755fec5e4241b93 on Hesulan:serialized-globals-no-set** into **ee9b70cf33a71715f2c0b6f394ab3b3054c4419c on marko-js:master**.
  ## Description
Was reading through docs and found some html entities.

## Motivation and Context
Pretty sure they were not suppose to be there ðŸ˜œ.

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [x] My code follows the code style of this project.
- [x] I have updated/added documentation affected by my changes.
- [x] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes.
- [ ] All new and existing tests passed.
 
[![Coverage Status](https://coveralls.io/builds/11312862/badge)](https://coveralls.io/builds/11312862)

Coverage remained the same at 90.204% when pulling **adf7801490f9b785b49c0c4e19950fc0ccd95cc8 on DylanPiercey:patch-1** into **ca27cb54b3c3e0f7a07a5aa9cbe19f56348b811b on marko-js:master**.
 Gotcha, thanks!  <!--- Provide a general summary of your changes in the Title above -->

## Description
<!--- Describe your changes in detail -->
Adding option to customize default timeout for await tags

## Motivation and Context
<!--- Why is this change required? What problem does it solve? -->
<!--- If it fixes an open issue, please link to the issue here. -->
We use await a lot and we need to customize the default await timeout for all await tags and we think this will help us to fix the timeout problem

I've opened an issue asking about this thing #621 

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [x] My code follows the code style of this project.
- [ ] I have updated/added documentation affected by my changes.
- [x] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes.
- [ ] All new and existing tests passed.
 
[![Coverage Status](https://coveralls.io/builds/11250601/badge)](https://coveralls.io/builds/11250601)

Coverage increased (+0.0009%) to 90.228% when pulling **6582b5b4a703458aa6cc7c4930abc52ec6cd5951 on mauricionr:default_await_timeout** into **29eb4d2c0066ecfa3e57d2b8bd8134617f4340fb on marko-js:master**.
 Squashed @austinkelleher 

Thanks :rocket:  
[![Coverage Status](https://coveralls.io/builds/11251597/badge)](https://coveralls.io/builds/11251597)

Coverage increased (+0.0009%) to 90.228% when pulling **8c534d926eaa86bfe5b41208412088fd227c7c6e on mauricionr:default_await_timeout** into **29eb4d2c0066ecfa3e57d2b8bd8134617f4340fb on marko-js:master**.
 @austinkelleher i will discuss with my team about override the `<await>` tag, thanks for the demo! i saw @austinkelleher, really good proposal, and with this override, looks like we will be able to override any core tag? Thanks @austinkelleher and @patrick-steele-idem simpler than the other aproach  <!--- Provide a general summary of your changes in the Title above -->

## Description
Marko global defaults and user globals aren't merged. If user globals exists the `defaults` are ignored.


## Motivation and Context
Look at https://github.com/marko-js/marko/issues/677

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [X] My code follows the code style of this project.
- [ ] I have updated/added documentation affected by my changes.
- [X] I have read the **CONTRIBUTING** document.
- [] I have added tests to cover my changes.
- [ ] All new and existing tests passed.

Tests suite doesn't works on windows! I will open an issue for this. 
[![Coverage Status](https://coveralls.io/builds/11201181/badge)](https://coveralls.io/builds/11201181)

Coverage increased (+0.002%) to 90.225% when pulling **5bcf5043012b3cf91056ae30fdc8ae6278fb9ec6 on StarpTech:merge_marko_globals_and_marko_defaults** into **e03362d94265e1d490b1a14fd515e7d16e5c876d on marko-js:master**.
  # Environment
Windows
NodeJs: v7.9.0
Marko: beta

The framework runtime variables in `out.global`
```
components:GlobalComponentsContext
uid: 1
```

are serialized to (in browser)
```
components: undefined
uid: NaN
```
when I access them in client side component. 

Another question is why they exists in the "user global" space ? This data should be land in a seperate namespace. Found the issue here https://github.com/marko-js/marko/blob/845c177be67bce46cc55b1d64b7e451dfe5c01da/components/util-browser.js#L1 window.$MG (defaults) must be merged.

Next issue is the `components` property. global `components` was purposefully set to `undefined` https://github.com/marko-js/marko/blob/845c177be67bce46cc55b1d64b7e451dfe5c01da/components/ComponentsContext.js#L41 Hi, yes my PR has been merged.   Right now I'm changing the component state with events. When a value changes (e.g. in an input tag) I use the on-change or on-keypress events to handle state changes. However in a form with a lot of states you need to have a lot of event handlers in the component class.
It gets unwieldy to have full control over all the business logic. It would be easier and clean to have an attribute like angular or vue.js (v-model, model.. or something like this) that takes a property of the state object and update it automatically.
I don't know if such a feature is already available but from the documentation I haven't seen anything like that.
Is it possible to implement a 2 way data binding out of the box? or, if not possible, can you suggest the best pattern to manage such cases?
Thanks.
  This is happening in 4.3.1 as well with callback and promises in the await tag.   ## New Feature

### Description
I'd like to be able to pass an option to renderToString that removes comments from that template. Perhaps also console.log calls.

### Context
Sometimes when I'm developing, especially in the view file which spits out most of my HTML page, I want to comment out / in certain sections - such as code for analytics trackers or other such things. This is so I can easily add / remove features as I develop without losing the code.

For now I mostly use Marko for server-side rendering my base HTML page which I plug another view engine (ReactJS) on top of. The ability to remove / add certain `<meta>` tags or some JavaScript on the fly using comments would be great - as these things are often changing. Right now all my pages are rendered with all the commented out sections too, which is adding to page size.

### Possible Implementation
Have an options object that can be passed to renderToString, with something like:
```
{
  removeComments: true,
  removeConsole: true
}
``` Oh, I wasn't aware that HTML-style comments were being removed. Looking back at my project I see that certain tags I commented out that way have actually been removed. That's cool.

It's mainly the JavaScript part of my code that I've been commenting out sections of - inside of HTML `<script>` tags. It seems these comments are not removed.

I might have to look at a babel solution then - although I've just tried to get rid of any babel on my server recently. When I do a `require` of the `.marko` file template, would the server know to transform the resulting JavaScript file which is generated by Marko? There doesn't seem to be a place where I actually reference the JavaScript file directly, and could potentially pass it to a babel transformer. I don't want babel to by default transform every JavaScript file because that can become a bit heavy.  
[![Coverage Status](https://coveralls.io/builds/11130285/badge)](https://coveralls.io/builds/11130285)

Coverage increased (+0.03%) to 90.296% when pulling **6ff3706ed1152d993a56ed2a081f3ea1fda8f29a on issue-651** into **9604a853ee3a2f487caa9add6a0173d02301109f on master**.
  ## Bug Report

### Context
Unable to use CSS rule `!important` in style block of marko file.

### Expected Behavior
The following is valid CSS in a marko file.
```
style {
  .foo-class {
    height: 50px !important;
  }
}
<div.foo-class/>
```
### Actual Behavior
Error when compiling:
```Module not found: Error: Can't resolve 'important;/n  }"}'```

### Your Environment
<!-- Include as many relevant details about the environment you experienced the bug in -->
* Version used: v4.2.7
 That'd be consistent. I am using `marko-loader`. The PR (https://github.com/marko-js/marko-loader/pull/13) that I just submitted against the `marko-loader` repo resolves this issue for me.  Having a dedicated section for scoped attributes would be a lot nicer than prefixing each class with `__`. I think most people would prefer to use only scoped css for their components and having to write `__` for every class in both the css and the template can get quite annoying after a while. 

Although when mixing global and scoped styles with @austinkelleher 's approach, there could end up being some confusion about what classes are scoped or not when looking at a pretty involved template with lots of styling going on. But then again, Vue users doesn't seem to be too bothered by that. I agree with the scoped attributes like:

```css
style.less.scoped {

}

style.less {

}

style.scss.scoped {

}

style.scss {

}
```

Instead of:

```css

    .global-button-selector { 
        color: grey;
    }
    __disabled-button { 
        color: grey;
    }
```

which in my opinion looks a bit messy and doesn't feel **concise** like most of the framework. I talked to @austinkelleher about this a while back and I've warm up to the idea of keeping scoped and non-scoped css classes under the same style block. I think that making class names that start with a capital letter scoped would end up working well. It feels less yucky compared to `.__`. 

There are languages out there that have different functionality for things that start with a uppercase or lowercase letter. For example, functions, structs, and struct attributes in `golang` that start with a capital letter are exported and are available outside of the package they are defined in, while lowercased variants are kept within the scope of the package. Although this is backwards from what was proposed (and `go` is _very_ different from css), I don't think the concept would be too foreign.

If marko ended up going this route, I think that it would have to be an opt in feature. It could end up breaking layouts for some people. You know, double underscore looks weird at first, but looking back on this thread a few weeks later it doesn't look bad at all. I think I prefer it since you can tell something different is happening, as opposed to the capital letters that look like a naming convention. *Note: I'll probably update after I get more sleep and have time to think*

I'm kind of wracking my brain on this one. On one hand, easy of implementation is obviously critical. On the other, this doesn't feel like a solid solution. 

### Main Concern: Tight coupling between scoped nature of css and markup

If I started off with 

```html
<button.primary/>
```

```css
.primary {
  color: blue;
}
```

but I decided suddenly that there was a conflict and I needed to scope it.

```css
.__primary {
  color: blue;
}
```

If I forget to update the markup or miss a reference then there could be a non-obvious style bug introduced. 

---

I know that's very likely obvious, but the above combined with the fact that the `__` needs to be added for everything scoped just seems error prone to me. 


# Modified Vue-like approach

Vue takes a pipelined approach. 

scoped styles -> vue-loader -> preprocessor -> internal vue-loader postcss plugin

Using a grouped approach like @austinkelleher mentioned would require something similar. 

## Implementation

**In a single file marko component**

```html
<button.primary/>

styles.scoped.less {
  button.primary {
    color: blue;
  }
}
```
*Generated output*
```css
button.primary[data-m-3ds24df] {
  color: blue;
}
```

The flow here would be more or less the same as vue's.

**In a split component**

style.mobile.css (Phase 0 -- source)
```css
scoped {
  button.primary {
    color: blue;
  }
}
.global-class {
  color: red;
}
```

Phase 1 -- marko transform

```css
@scoped(data-m-3ds24df) {
  button.primary {
    color: blue;
  }
}
.global-class {
  color: red;
}
```

Phase 2 -- postprocessor
Phase 3 -- marko-scoped-postcss

```css
button.primary[data-m-3ds24df] {
    color: blue;
  }
.global-class {
  color: red;
}
```

## Intended Results*
- Solves "scoped styles must be separated out from unscoped styles." 
  - Separation exists still, but can be localized to a file
- Solves: "Marko must understand each compile-to-CSS language." 
  - Look for a common denotation in each of the files like `@scoped` or something similar but unique. 
- Doesn't solve: "scoped style classes cannot be passed to nested components." 
  - I don't think this is a best practice to begin with, but it's still obviously an issue. 
- Might solve: "not compatible with multi-file adaptive styles." 
  - I would be very interested to know how this works to begin with. Regardless, after marko figured out what styles that component depended on it'd have to check for `@scoped`. If that was present, you'd just add the attribute directly onto every direct node of that component. (I'm not sure but I believe that doesn't extend to children). 


***Note: I'm making a lot of assumptions here that I don't have all the info to back up.**

Granted, I understand that this is significantly more complex than the proposed solution. Technically, given @patrick-steele-idem's note about the implementation details of the proposed solution I could see it just being a standalone webpack/lasso plugin anyway.
 @zephraph thanks for bringing attention to this topic again. I really don't see the issue with having marko support multiple CSS preprocessors. 

Having to install the desired preprocessor: SCSS, Less, PostCSS or Stylus via NPM so it's available to compile styles.scoped.less, styles.scoped.scss, etc is a minor trade-off in order to improve readability and improve the framework's usability. I am strongly of the opinion that all styles in a component should be scoped to that component by default.

Instead of `.__foo` to indicate that the `.foo` class is private, I would prefer to have to prefix something like `.GLOBAL.foo` to escape the particular component.

Consider this option:

```
style {
    .foo { color: red; }
    i { color: blue; }
}

global-style-exports {
   i { color: pink; }
}

<div class="foo">
  <i>Hello</i> <b>World</b>
</div>
```

Much discussion about CSS on the internet revolves around "global by default" was a misfeature in CSS (similar to it being in a misfeature in JS).  In the above example- it should be hard for styles to escape from the component. @ramses0, I really like the idea of all component styles being scoped by default. That would definitely be a breaking change though.    ## Bug Report

### Context
opening tag-brackets (`<`) being improperly converted to `&lt;`

[source](https://github.com/marko-js/marko/blob/master/docs/syntax.md#directives)
![source](https://cloud.githubusercontent.com/assets/23745012/24867738/79794f80-1e0e-11e7-9a2b-8ea816c9c5d5.png)

[rendered](http://markojs.com/docs/syntax/#directives)
![rendered](https://cloud.githubusercontent.com/assets/23745012/24867739/79ead6be-1e0e-11e7-9499-251eec545676.png)

### Expected Behavior
output:
``` marko
<strong if(true)>
    Marko is awesome
</strong>
```

### Actual Behavior
output:
``` marko
&lt;strong if(true)>
    Marko is awesome
&lt;/strong>
```

<details>
### Your Environment
* Version used: 4.2.7
* Environment name and version: Firefox 52, Chrome 57
* Operating System and version: Ubuntu 16.10
</details> where can the latest rendered master be seen?  ### Environment
Marko: 4.1.1
Node: 7.4.0
### Expected Behavior
Should only render the value.
### Actual Behavior
It renders javascript tag and the value.

### Steps to Reproduce

```marko
    <@title>
        <await(recipe from input.recipe)>
            ${recipe.name}
        </await>
    </@title>
```
will produce
```marko
<title>test&lt;script&gt;(function(){var w=window;w.$components=(w.$components||[]).concat({"w":[["s0",0,{},{"d":null,"b":null}],["s1",1,{"year":2017},{"d":null,"b":null}]],"t":["/recipe-detail$1.0.0/src/components/app-nav/index.marko","/recipe-detail$1.0.0/src/components/app-footer/index.marko"]})||w.$components})()&lt;/script&gt;</title>
```  ## Bug Report

### Context
Whilst trying to programmatically render components, one of the components started throwing an exception `Render error. Exception: Error: No component found`. After further investigation, I narrowed it down to whether any element within the component has a `for-key` or `key` attribute.

### Expected Behavior
The component should render as normal.

### Actual Behavior
With a `for-key` attribute, the following exception is thrown when `renderSync()` is called:
![image](https://cloud.githubusercontent.com/assets/19622548/24833117/5640d312-1c74-11e7-9825-7d9e549a5234.png)

With a `key` attribute, the following exception is thrown when `renderSync()` is called:
![image](https://cloud.githubusercontent.com/assets/19622548/24833126/7b45b43e-1c74-11e7-9083-af34dc8cb0d2.png)

<details><summary>Additional Info</summary>

### Your Environment
* Marko v4.2.6
* Chrome 57.0.2987.133 (64-bit), Node 6
* macOS Sierra 10.12.4

### Steps to Reproduce
I've created [a quick repository](https://github.com/edwarddamato/playground) where you can replicate this issue.

### Stack Trace
Stack traces provided above.

</details>
 Yeah, that fixes it. I'll keep an eye on this. Thanks!  ## Bug Report

### Context
On a new component with `index.marko`, create a single `<if(state.myVar)>test</if>` and run the server.
 
### Expected Behavior
The component `index.marko.js` should contain `function render(input, out, __component, component, state) {`

### Actual Behavior
The component `index.marko.js` contains `function render(input, out) {`

### Your   ##Environment
* Version used: marko@4.2.7
* Environment name and version (e.g. Chrome 39, node.js 5.4): Chrome 57.0.2987.133 , node.js 7.2.1
* Operating System and version (desktop or mobile): desktop MacOS X 10.12.4 beta

### Steps to Reproduce
1. Create a component with a single line `<if(state.myVar)>test</if>`
2. Add `onCreate` to component where `this.state = input`
3. Add `onMount` to component where `this.setState('myVar', 123)`
4. Pass component to a page
5. Load the page

### Stack Trace

```
events.js:160
      throw er; // Unhandled 'error' event
      ^

Error: Render error. Exception: ReferenceError: state is not defined
    at render (**/views/components/my-form/index.marko.js:29:7)
    at renderCompontent (**/node_modules/marko/components/taglib/helpers/renderComponent.js:3:5)
    at render (**/views/components/app/index.marko.js:21:3)
    at renderer (**/node_modules/marko/components/renderer.js:191:9)
    at render (**/views/pages/form/index.marko.js:33:3)
    at safeRender (**/node_modules/marko/runtime/renderable.js:6:9)
    at Template.render (**/node_modules/marko/runtime/renderable.js:136:20)
    at ServerResponse.response.marko (**/node_modules/marko/express.js:47:18)
    at app.get (**/server.js:74:7)
    at Layer.handle [as handle_request] (**/node_modules/router/lib/layer.js:93:5)
    at AsyncStream.error (**/node_modules/marko/runtime/html/AsyncStream.js:411:13)
    at Timeout._onTimeout (**/node_modules/marko/runtime/renderable.js:17:22)
    at ontimeout (timers.js:365:14)
    at tryOnTimeout (timers.js:237:5)
    at Timer.listOnTimeout (timers.js:207:5)
```  <!--- Provide a general summary of your changes in the Title above -->

## Description
<!--- Describe your changes in detail -->
+ clarify on-* wildcard usage
+ event handler basic and advanced notes
+ events comparison with dom, jquery, marko
+ link to example https://github.com/marko-js/markojs-website/pull/10

## Motivation and Context
<!--- Why is this change required? What problem does it solve? -->
<!--- If it fixes an open issue, please link to the issue here. -->
In the chat earlier we found an opportunity to improve the docs around event handlers.

## Screenshots (if appropriate):

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [x] My code follows the code style of this project.
- [x] I have updated/added documentation affected by my changes.
- [x] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes.
- [ ] All new and existing tests passed.
 
[![Coverage Status](https://coveralls.io/builds/10973696/badge)](https://coveralls.io/builds/10973696)

Coverage remained the same at 90.146% when pulling **13a2c81fddfe14a60149c86e233b41a613cad64d on tcrowe:on-event-doc-04062017** into **8019774911de50cf41c4b50963ac15dae8d4be7a on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/10973696/badge)](https://coveralls.io/builds/10973696)

Coverage remained the same at 90.146% when pulling **13a2c81fddfe14a60149c86e233b41a613cad64d on tcrowe:on-event-doc-04062017** into **8019774911de50cf41c4b50963ac15dae8d4be7a on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/10973696/badge)](https://coveralls.io/builds/10973696)

Coverage increased (+0.5%) to 90.615% when pulling **13a2c81fddfe14a60149c86e233b41a613cad64d on tcrowe:on-event-doc-04062017** into **8019774911de50cf41c4b50963ac15dae8d4be7a on marko-js:master**.
   Can I take this on ? I've got some free time these days and Im looking to get started around here. Thanks for the pointers guys. Will hopefully get this done over the weekend :) Okay so noob question, the only way to get the html out of a document fragment is by first appending it to a div and then getting its innerHTML right ? Is there any other way that I could be doing this ? Any progress on this yet? `renderToString` on the browser would be pretty nice to have. @mlrawlings Im still interested to work on this. Although I kinda stopped looking into this because I never could decide if the method I suggested was the way to go forward. @patrick-steele-idem @mlrawlings If the expected behaviour is to return the first top level element, we could just return the `outerHtml` from `this.___getNode().firstChild`. This works but I'm not sure this is the way forward.

Also, if I append the document fragment from `___getNode()` to a dummy VElement I created using `appendChild`, and try to access the firstChild it should give me the first child of the document fragment right ? This does not seem to be happening. Any ideas ?  ## Bug Report

### Context
I have a couple of Marko 3 components that have a `key` attribute that after upgrading to marko 4 break the whole page when used.

I believe `key` is now a reserved attribute.

### Expected Behavior
Component works

### Actual Behavior
Page fails to render and the following error is logged: `Render error. Exception: Error: No component found`

### Possible Fix
Allow key if defined in marks-tag.json of component.

<details><summary>Additional Info</summary>

### Your Environment
<!-- Include as many relevant details about the environment you experienced the bug in -->
* Version used: 4.2.4
* Environment name and version: node.js v7.8.0
* Operating System and version (desktop or mobile): mac OS Sierra

### Steps to Reproduce
<!--- Provide a link to a live example, or an unambiguous set of steps to -->
<!--- reproduce this bug include code to reproduce, if relevant -->
1. Create component with defined `key` attribute
2. Use in a page
3. Everything breaks

### Stack Trace
<!-- If an error is thrown, provide the stack trace here -->

</details>
  ## Bug Report

### Context

When using `<await-error>` to deal with rejected promises, marko calls `console.error` with the error. See https://github.com/marko-js/marko/blob/master/taglibs/async/await-tag.js#L111 .

For us this has two consequences:

- The console.error call ends up in stdout. In our container setup we use stdout for logging, with JSON entries. The marko output confuses our log parser.
- It's inconsistent to warn about an error in the case where the developer has explicitly provided an error handling tag.

### Expected Behavior

`<await-error>` tag does not cause `console.error` to be called.

### Actual Behavior

`<await-error>` tag does causes `console.error` to be called.

### Possible Fix

Having this logging can be useful during dev. Maybe ut could be behind a flag or something, so you can pass `silent-error=true` to the `<await>` tag or similar?

### Your Environment

* Version used: 4.1.2
* Environment name and version: node v6.6.0

### Steps to Reproduce

1. Load the code from https://gist.github.com/runeh/7adf1873b45ffa9d0b6723da4e410f4c into http://markojs.com/try-online/ 
2. Look at output in error console
 I ended up changing our code to deal the promise rejection in the renderer. But that seems unidiomatic, given that there are tags meant for dealing with timeouts and errors inside of await?

Anyway, it still feels counter-intuitive to me that there is `console.error` output in a case where I've explicitly added code to deal with the error. I would prefer it not logging on my behalf in that case.  This proposal seem to be more secure too, since arbitrary properties will no longer be "leaked" to the browser. > If a nested UI component derives its props/state or generates input properties from anything other than passed in input (e.g. this.locale = out.global.locale)` then that information will not be available when the UI component mounts in the browser.

Does this now mean that accessing the out stream from `onInput` will no longer be serialized and sent to the browser for components? @ianvonholt, we wouldn't need that hack if globals were also serialized and/or we could define the global object when initializing components in the browser. I created #646 specifically for that.  Should it? @patrick-steele-idem it's certainly not a problem to use `if(!` instead, I just was under impression that `unless` is some sort of global attribute like `if`...  Hi, in `Marko 4.2.1` a newline is inserted and my cursor jumps to the end of the textarea on every input if I try to bind its value to the state:

![marko-textarea](https://cloud.githubusercontent.com/assets/3694962/24590462/e0c79ec0-17ed-11e7-96cb-3dced2487006.gif)

**custom-input.marko**

```
class {
  onChange(e) {
    this.emit('change', e.target.value)
  }
}

div
  textarea key='input' on-input('onChange') value=input.value -- ${input.value}
  p
    strong -- ${input.value}
```

If I remove the strong tag that outputs `input.value` it works fine. If I use an `input` instead of the `textarea` it works fine as well. If I remove the `${input.value}` from the `textarea`'s body it works as well but then the initial `input.value` isn't shown.

The code is server-rendered so I'm guessing that this has to do with serialisation maybe?

Full code: https://github.com/maximilianschmitt/lasso-test

Thanks for your help! Thanks for your feedback @mindeavor. I'm removing `value` but this does not fix the issue unfortunately. Hey @patrick-steele-idem! Thank you for your help. I can verify that your proposed workaround of using the HTML syntax works. :)  Hello

## Bug Report
I was moving a div around the page with the mouse, then I got a weird behavior. I'm quite new with all this stuff but it looks like a bug.
### Context
Marko template:
`div style={position:'absolute',top:0} -- test`
Rendering:
`var bloc = require('./bloc');`
`bloc.renderSync().appendTo(document.body);`
### Expected Behavior
<!--- Tell us what should happen -->
'top' property should be set to zero and the text should be displayed at the top of the page.
### Actual Behavior
<!--- Tell us what happens instead -->
The value 0 for 'top' is ignored and the 'top' property is not set in the style (according to FF inspector). The text is displayed at the default position that depends on previous elements in body.
- No error message.
- Negative values are accepted and the position of the div is correct
- Same problem with 'left' property (not tested with other ones)
- Same problem when state is changed with code

<details><summary>Additional Info</summary>

### Your Environment
<!-- Include as many relevant details about the environment you experienced the bug in -->
* Version used: marko 4.2.0
* Environment name and version: node.js 6.10.0-win-x64 Firefox 52.0.2
* Operating System and version: Windows 10 desktop



</details>
 I surely could not have be so quick. I don't even know how I can test modified codeâ€¦ I may be more helpful in some days/weeks.
Many thanks.   When I try to write something like the stop-watch component in the try online section, i get the following error when the script try to update the component:

```
Uncaught TypeError
    at Component.$__rerender (pages-1407d337.js:3344)
    at Component.update (pages-1407d337.js:3305)
    at updateComponents (pages-1407d337.js:1890)
    at updateUnbatchedComponents (pages-1407d337.js:1862)
    at pages-1407d337.js:1841
$__rerender @ pages-1407d337.js:3344
update @ pages-1407d337.js:3305
updateComponents @ pages-1407d337.js:1890
updateUnbatchedComponents @ pages-1407d337.js:1862
(anonymous) @ pages-1407d337.js:1841
```


below is the function where I hit the error: 


```
$__rerender: function(input) {
   if (input) {
      this.input = input;
   }
    var self = this;
    var renderer =  self.$__renderer;

    if (!renderer) {
        throw TypeError();
     }
.............................
```

`self.$__renderer` is undefined.


In my case there's a template rendered by express with marko/express.
The template has a tag called sidebar. This tag is where the code lives and it's build using the multi files structure:
component-browser.js
component.js
index.marko.

- component-browser.js handles the OnMount() and browser events.
- component.js handles onCreate()

In the onMount() I declared and assigned the intervalId to the global setTimeout() function that change the state using this.state.width every 1 second. (I'm using es6 function syntax so that the `this` scope is preserved)
When the interval changes the state i get the error i mentioned above.

Can you please help to understand where I'm wrong ?
Thanks

 I'm having the same issue on version 4.2.1. @maximilianschmitt If you are using a main template you can try to something like this:

`template.marko`
```
include(input.lasso)
<!doctype html>
html
  head
    app-head(input)
    lasso-head
  body
    div id="main-app"
      app-header(input)
      app-body(input)

    browser-refresh enabled="true"
    lasso-body

  <!--custom scripts-->
  <include(input.scripts)/>
```

`page.marko`

```
include('~/theme/html.marko')
    @lasso
        lasso-page package-path="./browser.json"
    @title -- Dashboard
    @body
        app-main
```

Notice the @lasso tag in the page.marko file. Instead of putting the `lasso-page package-path=".."` tag in the main template I delegated the page to send it to the main template that receive it at the top of the file with the tage `include(input.lasso)`

I don't know why but that solved the issue for me.
Furthermore I removed the component-browser.js file and write both the server and client logic inside the component.js file  Thanks for the clarification @patrick-steele-idem and @ovidius72! :)  I'm testing Marko for server-side and client-side rendering and I've been looking for a way to define the global variables (`out.global`) when bootstrapping client-side components. Is it possible?

At the moment I'm just seeing that `input` and `state` are passed from backend to client, but global variables are left blank in the page (and I rather use specific globals in the client).

Sample code (using intentionally bad practices):

server:
```
<h1>${out.global.title}</h1>

...

template.stream({
  $global: {
    title: 'Foo'
  }
});
```

client:
```
import component from '...';
import markoComponents from 'marko/components';
markoComponents.init();

// How can I define $global?
```

Thanks for the hard work. It's amazing how simple it is to have universal components with Marko. I'm not sure if I got it right. From what I see you're suggesting using the `onInput` handler to assign the global values in the server to the component input so it's serialized in the HTML for the client. Then in the client, the `onMount` handler is called and the serialized input is put again in the store with the globals. Am I right?

Apart from being a little "hacky" IMO, my problem with that approach is that the thing I'm putting in globals are functions, not serializable values. For more context, they're a translation function (which already has the locale and the translations set for the current request) and a function to get urls (which rely on an internal mapping, e.g.: '/img/logo.png' => 'https://some-cdn.com/img/logo-v1234.png'), among other things. I use dependency injection a lot and I'd like to inject the client-side versions of those functions in the template.

I can come up with a hack to do this but I wanted to know if the library itself provided access to the `out` object being used in the client. Would you consider implementing it o accepting a PR that did that? @patrick-steele-idem I like your approach because we work with the same interface `out.global` but you always have to define which propertys are serialized to the browser right? It would be nice if we could work in the same way as on server side. In my opinion "global" data shouldn't need manual adjustment in every component.

Intial state should be that the whole `$global` object will be serialized.

```marko
class {
}
```

```marko
<div>
    Title: ${out.global.title}
</div>
```

If you dont want to serialize everything we can define a whitelist (with some tooling)

```marko
class {
    get globals() {
        return ['title'] // only title
        return ['!title'] // all except title
        return ['foo.bar'] // only bar
        return [] // share nothing
    }
}
```
If you dont define a globals getter everything is shared.

```marko
<div>
    Title: ${out.global.title}
</div>
``` Sorry for the delay.

Before telling what my preference would be, take into account that I'm not using Marko in production, I'm still playing with it to evaluate if it fits my needs (my company's).

I think we should be able to pass top-level input and globals in the client initialization as we do with server-side rendering.

If in the server we do:

```javascript
template.stream({
  currentPage: 'Home page',
  $global: {
    staticUrl: () => { ... }
  }
});
```

We should be able to do so in the client:

```javascript
import component from '...';
import markoComponents from 'marko/components';
markoComponents.init({
  $input: {
    // Add variables to the serialized input
  },
  $replaceInput: {
    // Replace all serialized input
  },
  $global: {
    staticUrl: () => { ... } // client-side version
  },
  $replaceGlobal: {
    ...
  }
});
```

The problem with this approach, as far as I know, is that there's no guarantee that there will only be a single top-level component in the page, so passing these values to markoComponents.init could be problematic (although it'd solve my needs).

My use case is something like this (and it's already working with Nunjucks):

```javascript
$ const { staticUrl } = out.global;

<img src="${staticUrl('/img/logo.png')}">
```

@gilbert that pattern may work for me but I'd need many changes in my code to be able to import the function that resolves urls, as I rely a lot on dependency injection. The function that resolves urls is not so simple as appending the path to a variable CDN hostname, but all paths are mapped to a cache-friendly version. Also I don't think it's a good idea to use `out` as a global variable in `window`. In case this weren't possible having a reference to the `out` variable used to initialize components would also be enough:

```javascript
import component from '...';
import markoComponents from 'marko/components';
Object.assign(markoComponents.out.$global, {
  // My global variables
});
markoComponents.init();
```

Or having access to the serialized data:

```javascript
import component from '...';
import markoComponents from 'marko/components';
const serializedState = markoComponents.getSerializedState();
Object.assign(serializedState, {
  // My variables
});
markoComponents.init();
```
  Hi. Just read about Marko recently. Can Marko be used for mobile app development - does it have anything similar to React Native or Ionic? I'm using marko for a progressive web app, so i guess marko can do it

marko <3 mauricionr,

Can you talk a bit about how you do it? Do you use any other libraries/frameworks? Thanks. @mauricionr if you have the time, a write up or a github starter repo would be really appreciated. 

Grouping efforts towards building something like https://github.com/nuxt/nuxt.js for marko would be great, I'm willing to contribute, however it seems like there are still a few missing pieces to the puzzle such as client side routing. So an example of a barebones PWA with client side routing and offline capabilities would make a good starting point. I'm using the pwa [checklist](https://developers.google.com/web/progressive-web-apps/checklist) from google and the [sw-toolbox](https://github.com/GoogleChrome/sw-toolbox), and i'm not using client side routing.

@sebastianmacias @selforganized i will put the example in my repo :rocket: 

 @sebastianmacias @selforganized 

I started implement service worker in my demo at [PWA Road Show SÃ£o Paulo](https://events.withgoogle.com/pwa-roadshow-latin-america/#content)

checkout of my [demo repo](https://github.com/mauricionr/marko-pwa) and [live demo](https://lit-headland-75537.herokuapp.com/)

![image](https://cloud.githubusercontent.com/assets/2263551/24765410/0d67703a-1ace-11e7-86b6-3b96f0693b65.png)


Hope this can help with PWA :rocket:  @mauricionr thanks! will be checking it out later this week I will get some free time to improve them :) Bro , I need client side Routing mechanism for MarkoJS + Marko Widgets with SEO things .Please suggest me regarding   Hi again!

For a project I'm looking at building with Marko 4 (I'm on `Marko 4.2.0`), I want an `input` element to be autosized so that the width of the input always matches the width of its value. The following works fine for the most part:

```
static var autosize = require('autosize-input')

class {
  onMount() {
    // resize the input on input
    autosize(this.getEl('input'))
  }

  onChange(e) {
    this.emit('change', e.target.value)
  }
}

div
  input key='input' value=input.value on-input('onChange')
  -- ${input.value}
```

However, on the first input (e.g. entering a space) the `style` attribute (that the autosize-module sets) seems to be removed:

![marko-autosize](https://cloud.githubusercontent.com/assets/3694962/24577712/37153aec-16d3-11e7-971f-91822d449d6b.gif)

Full code: https://github.com/maximilianschmitt/lasso-test

I wonder if this is intentional behaviour? I've also tried manually resizing in the `onRender` and `onUpdate` hooks but this causes flickering.

Now finally I modified `autosize-input` to return the style and use Marko's state to update the `style` together with the `input`'s value. This solves my issue above but with this pattern the cursor of the `input` jumps to the end if I enter a character:

```
static var autosize = require('autosize-input')

class {
  onCreate() {
    this.state = { autosize: {} }
  }

  onMount() {
    var component = this

    // on every input, call my callback with the calculated style
    autosize(this.getEl('input'), null, function (style) {
      component.state.autosize = style
      component.setStateDirty('autosize')
    })
  }

  onChange(e) {
    this.emit('change', e.target.value)
  }
}

div
  input key='input' style=state.autosize value=input.value on-input('onChange')
```

![marko-autosize2](https://cloud.githubusercontent.com/assets/3694962/24577803/4c669560-16d5-11e7-9c4d-ed088b85a8d6.gif)

Full code: https://github.com/maximilianschmitt/lasso-test/tree/cursor-jump

Thanks for your help! :) Hey, thanks! Interesting to hear what caused the issue. `4.2.1` fixed it for me. :) Thank you!  Hi! When I'm developing I sometimes I edit several files for something to work. Sometimes however I receive the following error:

```
  Error: Render error. Exception: TypeError: renderFunc is not a function
      at safeRender (/home/karl/dev/instanty/node/node_modules/marko/runtime/renderable.js:6:9)
      at Template.render (/home/karl/dev/instanty/node/node_modules/marko/runtime/renderable.js:131:20)
      at Readable._read (/home/karl/dev/instanty/node/node_modules/marko/runtime/stream.js:44:17)
      at Readable.read (_stream_readable.js:350:10)
      at resume_ (_stream_readable.js:739:12)
      at _combinedTickCallback (internal/process/next_tick.js:80:11)
      at process._tickCallback (internal/process/next_tick.js:104:9)
      at AsyncStream.error (/home/karl/dev/instanty/node/node_modules/marko/runtime/html/AsyncStream.js:411:13)
      at Timeout._onTimeout (/home/karl/dev/instanty/node/node_modules/marko/runtime/renderable.js:12:22)
      at ontimeout (timers.js:380:14)
      at tryOnTimeout (timers.js:244:5)
      at Timer.listOnTimeout (timers.js:214:5)
```

That I receive and exception is brilliant. However it would be really *really* nice if it could reference where my application is breaking. Or am I missing something? Hi! Unfortunately I can't recreate it at will I'm afraid. It however does seem to popup for me quite often. Here is a longer log:

```
[browser-refresh] Triggering refresh of client styles...
[browser-refresh] Refresh triggered
[browser-refresh] Refresh triggered
[browser-refresh] File has been changed: src/client/components/app-footer/_flags.scss
[browser-refresh] Special reload: /src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[browser-refresh] Triggering refresh of client styles...
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso] File modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[lasso/browser-refresh] StyleSheet modified: /home/karl/dev/instanty/node/src/client/components/app-footer/_flags.scss
[browser-refresh] Triggering refresh of client styles...
[browser-refresh] Refresh triggered
[browser-refresh] Refresh triggered

  Error: Render error. Exception: TypeError: renderFunc is not a function
      at safeRender (/home/karl/dev/instanty/node/node_modules/marko/runtime/renderable.js:6:9)
      at Template.render (/home/karl/dev/instanty/node/node_modules/marko/runtime/renderable.js:131:20)
      at Readable._read (/home/karl/dev/instanty/node/node_modules/marko/runtime/stream.js:44:17)
      at Readable.read (_stream_readable.js:350:10)
      at resume_ (_stream_readable.js:739:12)
      at _combinedTickCallback (internal/process/next_tick.js:80:11)
      at process._tickCallback (internal/process/next_tick.js:104:9)
      at AsyncStream.error (/home/karl/dev/instanty/node/node_modules/marko/runtime/html/AsyncStream.js:411:13)
      at Timeout._onTimeout (/home/karl/dev/instanty/node/node_modules/marko/runtime/renderable.js:12:22)
      at ontimeout (timers.js:380:14)
      at tryOnTimeout (timers.js:244:5)
      at Timer.listOnTimeout (timers.js:214:5)

Render error. Exception: TypeError: renderFunc is not a function
    at safeRender (/home/karl/dev/instanty/node/node_modules/marko/runtime/renderable.js:6:9)
    at Template.render (/home/karl/dev/instanty/node/node_modules/marko/runtime/renderable.js:131:20)
    at Readable._read (/home/karl/dev/instanty/node/node_modules/marko/runtime/stream.js:44:17)
    at Readable.read (_stream_readable.js:350:10)
    at resume_ (_stream_readable.js:739:12)
    at _combinedTickCallback (internal/process/next_tick.js:80:11)
    at process._tickCallback (internal/process/next_tick.js:104:9)

  Error: Render error. Exception: TypeError: renderFunc is not a function
      at safeRender (/home/karl/dev/instanty/node/node_modules/marko/runtime/renderable.js:6:9)
      at Template.render (/home/karl/dev/instanty/node/node_modules/marko/runtime/renderable.js:131:20)
      at Readable._read (/home/karl/dev/instanty/node/node_modules/marko/runtime/stream.js:44:17)
      at Readable.read (_stream_readable.js:350:10)
      at resume_ (_stream_readable.js:739:12)
      at _combinedTickCallback (internal/process/next_tick.js:80:11)
      at process._tickCallback (internal/process/next_tick.js:104:9)
      at AsyncStream.error (/home/karl/dev/instanty/node/node_modules/marko/runtime/html/AsyncStream.js:411:13)
      at Timeout._onTimeout (/home/karl/dev/instanty/node/node_modules/marko/runtime/renderable.js:12:22)
      at ontimeout (timers.js:380:14)
      at tryOnTimeout (timers.js:244:5)
      at Timer.listOnTimeout (timers.js:214:5)

Render error. Exception: TypeError: renderFunc is not a function
    at safeRender (/home/karl/dev/instanty/node/node_modules/marko/runtime/renderable.js:6:9)
    at Template.render (/home/karl/dev/instanty/node/node_modules/marko/runtime/renderable.js:131:20)
    at Readable._read (/home/karl/dev/instanty/node/node_modules/marko/runtime/stream.js:44:17)
    at Readable.read (_stream_readable.js:350:10)
    at resume_ (_stream_readable.js:739:12)
    at _combinedTickCallback (internal/process/next_tick.js:80:11)
    at process._tickCallback (internal/process/next_tick.js:104:9)
```

To get rid of the error I just have to stop my npm script `npm run dev` and start it up again, where I got the following error:

```
  Error: An error occurred while trying to compile template at path "/home/karl/dev/instanty/node/src/client/components/app-footer/index.marko". Error(s) in template:
  1) [src/client/components/app-footer/index.marko:32:0] The closing "footer" tag does not match the corresponding opening "span" tag
  
      at handleErrors (/home/karl/dev/instanty/node/node_modules/marko/compiler/Compiler.js:82:21)
      at Compiler.compile (/home/karl/dev/instanty/node/node_modules/marko/compiler/Compiler.js:151:9)
      at _compile (/home/karl/dev/instanty/node/node_modules/marko/compiler/index.js:89:33)
      at Object.compile (/home/karl/dev/instanty/node/node_modules/marko/compiler/index.js:103:12)
      at doLoad (/home/karl/dev/instanty/node/node_modules/marko/runtime/loader/index-default.js:133:45)
      at load (/home/karl/dev/instanty/node/node_modules/marko/runtime/loader/index-default.js:5:16)
      at Object.<anonymous> (/home/karl/dev/instanty/node/src/client/components/app__sign-in/index.marko.js:21:27)
      at Module._compile (module.js:571:32)
      at loadSource (/home/karl/dev/instanty/node/node_modules/marko/runtime/loader/index-default.js:47:20)
      at doLoad (/home/karl/dev/instanty/node/node_modules/marko/runtime/loader/index-default.js:140:24)
```

The error above is expected as my code isn't correct.

So the rendersync error seems to happen when I use browser refresh, I edit a file which is incorrect, it trys to re-render and then tries to update the client. As stated, to fix the rendersync error I just have to manually stop and start my `npm run dev` script.

My `npm run dev` is as follows: `"NODE_ENV=development NODE_PATH=\"$(pwd)\" browser-refresh --nolazy --inspect=9229 src/index.js"`

I'll update if I see anything new or figure out a pattern.  Hi!

I've been developing with React for the past 2 years and using Marko really feels nice and fresh. :) I love how fast and lightweight it feels

But one thing I couldn't figure out and found no examples for, is keeping the `value` of an `input` in sync with the component's `state`. With React, you do `<input value={state.value} onChange={this.onChange} />` where `onChange` calls `setState({ value: e.target.value })` and it just works.

Intuitively I thought the correct way to go about this in Marko would be to do something like this:

```
class {
  onCreate() {
    this.state = { value: 'Hello' }
  }

  handleInput(e) {
    this.state.value = e.target.value
  }
}

input value=state.value on-input('handleKeydown')
-- ${state.value}
```

`keyDown` is being called, however the component is not rerendering if I type in the input. The text next to it (`-- ${state.value}`) always says `Hello`. Also, the `input` only seems to pick up every second character I type in. If I add a `setStateDirty('value')` to my `handleInput`-function, the input's value always stays at `Hello`. I can tell (by logging) that in this case the component is rerendering (with no visible result though).

Is my approach fundamentally wrong? How do you normally keep state and input components in sync?

Thanks for your help!

Best,
Max @mindeavor ah, thank you! :)  ## Bug Report

### Context

At markojs.com, clicking the tab next to "Color picker" gives a js error.

### Expected Behavior

Switch tabs.

### Actual Behavior

Error.

### Possible Fix

I'm totally new here.

<details><summary>Additional Info</summary>

### Your Environment
<!-- Include as many relevant details about the environment you experienced the bug in -->
* Version used: n/a
* Environment name and version (e.g. Chrome 39, node.js 5.4): Chromium Version 56.0.2924.76 Built on Ubuntu , running on LinuxMint 18.1 (64-bit)
* Operating System and version (desktop or mobile): ibid
* Link to your project: n/a

### Steps to Reproduce
1. load markojs.com
2. open error console (clean at this point)
3. click said link

### Stack Trace

```
Uncaught Error: Not allowed
    at h.beginAsync (index-83c75fc1.js:63)
    at c.exports (index-83c75fc1.js:110)
    at index-83c75fc1.js:111
    at b.f (index-83c75fc1.js:71)
    at h._ (index-83c75fc1.js:111)
    at index-83c75fc1.js:112
    at b.f (index-83c75fc1.js:71)
    at g._.l.r.type (index-83c75fc1.js:112)
    at index-83c75fc1.js:55
    at index-83c75fc1.js:47
beginAsync @ index-83c75fc1.js:63
c.exports @ index-83c75fc1.js:110
(anonymous) @ index-83c75fc1.js:111
b.f @ index-83c75fc1.js:71
h._ @ index-83c75fc1.js:111
(anonymous) @ index-83c75fc1.js:112
b.f @ index-83c75fc1.js:71
g._.l.r.type @ index-83c75fc1.js:112
(anonymous) @ index-83c75fc1.js:55
(anonymous) @ index-83c75fc1.js:47
b._t @ index-83c75fc1.js:41
_S @ index-83c75fc1.js:47
update @ index-83c75fc1.js:47
h @ index-83c75fc1.js:41
f @ index-83c75fc1.js:41
(anonymous) @ index-83c75fc1.js:41
```

</details>
  ## Bug Report

### Expected
I try to build Mixin  mechanism for enhancing marko componentï¼Œ unfortunately, it seems component instance was created out of normal way. 

### Code

[___mixins.js : L5 - L13___](https://github.com/wujjpp/marko-starter-kit/blob/master/src/core/mixins/mixins.js#L5-L13)

```
export default (...mixins) => {
  class MixedComponent {}
  for (let mixin of mixins) {
    for (let name of Object.keys(mixin)) {
      MixedComponent.prototype[name] = mixin[name]
    }
  }
  return MixedComponent
}
```

[___history-mixin.js : L1 - L6___](https://github.com/wujjpp/marko-starter-kit/blob/master/src/core/mixins/history-mixin.js#L1-L6)
```
export default {
  funcInMixin() {
    console.log('funcInMixin called')
  }
}
```

[___component.js : L5 - L23___](https://github.com/wujjpp/marko-starter-kit/blob/master/src/routes/mixin/components/app-main/component.js#L5-L23)
```
import {
  Mixins,
  HistoryMixin
} from '../../../../core/mixins'

var MixedBaseClass = Mixins(HistoryMixin)

class Bar extends MixedBaseClass {}

export default class MyClass extends MixedBaseClass {
  foo() {
    //the following 2 lines codes are working as expected.
    var bar = new Bar()
    bar.funcInMixin() //print 'funcInMixin called' in console

    // In fact,we want component instance has mixed function `funcInMixin`
    // Unfortunately `this.funcInMixin` is undefined, it caused unhandled exception
    this.funcInMixin()
  }
}
``` @patrick-steele-idem Thanks for your help, it works.

___foo-mixin.js___
```JavaScript
export default {
  foo() {
    console.log('function called in foo mixin')
  }
}
```

___bar-mixin.js___
```JavaScript
export default {
  bar() {
    console.log('function called in bar mixin')
  }
}
```
___mixins.js___
```JavaScript
export default (...mixins) => (component) => {
  for (let mixin of mixins) {
    Object.assign(component.prototype, mixin)
  }
  return component
}
```
___component.js___
```JavaScript
import {
  Mixins,
  FooMixin,
  BarMixin
} from '../../../../core/mixins'

class MyComponent {
  callFunc() {
    this.bar()
    this.foo()
  }
}

export default Mixins(FooMixin, BarMixin)(MyComponent)
```
  `macro` needs to be rewritten!!

```marko
   <if(xxx)>
      <macro yy()>
        ... if ...
      </macro>
   </if>
   <else>
      <macro yy()>
         .. else ...
      </macro>
   </else>
```

```javascript
"use strict";
function render(input, out) {
	if(xxx){
		function macro_yy(){
			out.w("... if ...");
		}
	}else{
		function macro_yy(){
			out.w("... else ...");
		}
	}

	macro_yy();   //  it will be throw 'ReferenceError: macro_yy is not defined'  in strict model

}

``` @mindeavor Yeah, that's what I'm doing

```marko
<macro yy()>
   <if(xxx)>
      ... if ...
   </if>
   <else>
      ... else ...
   </else>
</macro>
``` @patrick-steele-idem  thanks  ## Bug Report
NOTE: I'm not sure if it is a BUG, but the vue's behavior is we wanted.

### Code

___/routes/index/index.marko___
```
<html>
  <head>
    <title>Welcome | Marko Demo</title>    
    <script src="https://unpkg.com/jquery"/>
    <script src="https://unpkg.com/easy-pie-chart/dist/jquery.easypiechart.min.js"/>
  </head>
  <body>
    <app-main/>
  </body>
</html>
```

___/routes/index/components/app-main/index.marko___
```
style {
  .chart {
    position: relative;
    display: inline-block;
    width: 110px;
    height: 110px;
    margin-top: 50px;
    margin-bottom: 50px;
    text-align: center;
  }
  .chart canvas {
    position: absolute;
    top: 0;
    left: 0;
  }
  .percent {
    display: inline-block;
    line-height: 110px;
    z-index: 2;
  }

  .percent:after {
    content: '%';
    margin-left: 0.1em;
    font-size: .8em;
  }
}

class {
    constructor() {
        this.state = { count:0 };
    }
    onMount(){
      $('.chart').easyPieChart({
        easing: 'easeOutBounce',
        onStep: function(from, to, percent) {
          $(this.el).find('.percent').text(Math.round(percent))
        }
      })
      this.chart = $('.chart').data('easyPieChart')
      this.chart.update(Math.round(Math.random() * 200 - 100))
    }

    inc() {
        this.state.count++
    }
    dec(){
      this.state.count--
    }

    updateChart(){
      this.chart.update(Math.round(Math.random() * 200 - 100))
    }
}
<div id="app">
  <div>
    <span>Count: ${state.count}</span>
    <button onClick("inc")>inc</button>
    <button onClick("dec")>dec</button>
    <span>--> Click the "+" or "-" button, will cause canvas(generated by easy pie chart plugin) be removed, vue doesn't has this issue</span>
  </div>
  <div>
    <span class="chart">
      <span class="percent"/>
    </span>
    <button onClick("updateChart")>Update chart</button>
  </div>
</div>

```
### Steps
After page loaded, the easyPieChart create a canvas inside `<span class="chart"><canvas ..... /></span>`, if you click `Update chart` button, the chart will be refreshed, all things goes well, but if you click `inc` or `dec` button, the canvas disappeared.  actually, we want canvas keep in document.

Vue has the right behavior(we wanted), I have created the same [demo app of vue version](https://jsfiddle.net/wujjpp/or132f6L/) 

Also, I have uploaded the [marko version of  demo app](https://github.com/wujjpp/marko-vdom-issue.git)


 @mindeavor Thanks for your reply, and fixed issue in this case.  but it cause `<span class="percent">${Math.round(state.percent)}</span>`  no longer to be updated.
Although, we can create special DOM structure to avoid the issue, but it make DOM structure more complex. Anyway, **Thanks for your solution again.**

[___template.marko : L58-L64___](https://github.com/wujjpp/marko-starter-kit/blob/master/src/routes/test/components/app-main/index.marko#L58-L64)
```
<div class="col-md-12">     
      <span class="chart" no-update>
        <span class="percent">${Math.round(state.percent)}</span>      
      </span>
      <span class="btn btn-default" onClick('updateChart')>Update chart</span>
</div>
```
[___component.js : L8-L51___](https://github.com/wujjpp/marko-starter-kit/blob/master/src/routes/test/components/app-main/component.js#L8-L51)
```
export default class Test {
  onMount() {   
    $('.chart').easyPieChart({
      easing: 'easeOutBounce',
      onStep: function(from, to, percent) {
        //$(this.el).find('.percent').text(Math.round(percent))
      }
    })
    this.chart = $('.chart').data('easyPieChart');
    this.chart.update(this.state.percent)
  }
  ...
  updateChart() {   
    this.state.percent = Math.random() * 200 - 100
    this.chart.update(this.state.percent)
  }
```

  @mindeavor Correct, create special DOM structure for handling.
 @mindeavor I have another question: 
what's the difference between "input" and "state"? like "props" and "state" in react? @mindeavor Thanks  ### Open Questions
<!--- What still needs to be discussed -->
I understand marko can be used with a number of server side frameworks like express that handle URL dispatching but does it include any client side router or are any plans to support this?

Thanks I like the JSX-syntax support in React Router. Also need solid support of server-side rendering. The Inferno port of React Router is probably worth looking at: https://github.com/infernojs/inferno/tree/master/packages/inferno-router Any update on this? 

Besides the router I think a router-link core component would be needed,  similar to this: https://router.vuejs.org/en/api/router-link.html  :+1: Maybe something like `<taglib('./path/to/taglib') />` or `<marko-tag('./path/to/tag.marko') />`, to avoid overloading `import`? I agree with @mindeavor that auto-detection has worked extremely well. 

Are you proposing this change instead of defining a `tags-dir` withn a `marko.json`?  Looks like bug is fixed. I just reinstall all my modules and now everything work like expected I'm getting this error: 

`Uncaught TypeError: component.$__setCustomEvents is not a function`

when using multi files structure for components and exporting as a class.  `module.exports = class {}.`
It works when a literal object is exported `module.exports = {}.`
 
marko version is  4.2.0
node: 6.10  <!----------------------
  |     IF BUG REPORT    |
  ---------------------->
## Bug Report

I'm trying to use `$!{}` to output some HTML that is generated on the server, but it's not rendering.

### Context
<!--- Provide a more detailed introduction to the issue itself, and why you consider it to be a bug.  How has this bug affected you? What were you trying to accomplish? -->

I am passing an `input` tag like this: `<input type="text" value="" />`. Looking at the element in chrome devtools it looks like:  `<INPUT type="text" value=""></INPUT>`. If I edit the element in devtools to be like the input it works fine.

### Expected Behavior
<!--- Tell us what should happen -->

It should output: `<input type="text" value="" />`

### Actual Behavior
<!--- Tell us what happens instead -->
It outputs:  `<INPUT type="text" value=""></INPUT>`
### Possible Fix
<!--- Not obligatory, but suggest a fix or reason for the bug -->

<details><summary>Additional Info</summary>

### Your Environment
<!-- Include as many relevant details about the environment you experienced the bug in -->
* Version used: 4.1.3
* Environment name and version (e.g. Chrome 39, node.js 5.4): Node 6.9.2
* Operating System and version (desktop or mobile): Ubuntu 16.04

### Steps to Reproduce
<!--- Provide a link to a live example, or an unambiguous set of steps to -->
<!--- reproduce this bug include code to reproduce, if relevant -->
Add the following component to your app:

```
class {

  onCreate() {
    this.state = {
      html: "<input type='text' name='test' value='x' />"
    }
  }
}

<div>$!{state.html}</div>
```
<!-- If an error is thrown, provide the stack trace here -->

</details>
 A regular `div` tag works fine, although the tag is upper-cased. An `img` tag has the same problems as `input`, so it seems to be a problem with tags that don't require a closing tag. Excellent. Thank you.  Related to: https://github.com/marko-js/marko/issues/619

<!--- Provide a general summary of your changes in the Title above -->
Replaced constructor with onCreate
## Description
<!--- Describe your changes in detail -->

## Motivation and Context
<!--- Why is this change required? What problem does it solve? -->
<!--- If it fixes an open issue, please link to the issue here. -->

## Screenshots (if appropriate):

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [ ] My code follows the code style of this project.
- [ ] I have updated/added documentation affected by my changes.
- [ ] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes.
- [ ] All new and existing tests passed.
 
[![Coverage Status](https://coveralls.io/builds/10717211/badge)](https://coveralls.io/builds/10717211)

Coverage remained the same at 90.093% when pulling **3558b5a0dff24ec65d0b29d7c4b6017c9e41ca83 on basickarl:patch-1** into **e24c00eb8b34242173a81eaee3a0c1e6ce4d54b7 on marko-js:master**.
  ### Context

Hey @patrick-steele-idem , i'm using marko v3 in production and i'm trying to convince my team to upgrade to marko v4

I'm trying to find the performance diff between v3 and v4

Do you guys know where i can find? or do you guys have something to help me speed up this upgrade

Thanks! Both :rocket:  Really Thanks in advance @patrick-steele-idem :beers:   Updated `counter.marko` example in `ReadME.md` file to use `onCreate()` instead of `constructor()` 
[![Coverage Status](https://coveralls.io/builds/10645416/badge)](https://coveralls.io/builds/10645416)

Coverage remained the same at 90.093% when pulling **3b3e10d1e156a93d65b752cacc4d494c0f6e1ca4 on krypton97:master** into **3c604ed11f2b815ea4fe369471a2555b03383399 on marko-js:master**.
  You actually can serialize functions, I'm working on a dashboard using VueJS that takes advantage of that.  with nunjucks i can {{ var | dump }}, what is the equivalent for marko? @patrick-steele-idem Yes, deleted my comment. ;-)  ### Open Questions
How do you implement css in isolation with markojs?  With the movement of component based authoring instead of document.  People found that its better to isolate css selectors to per component as opposed to its default cascading nature.

Is this something marko js aim to solve?

### Is this something you're interested in working on?
Yes
 Do you mean having a separate stylesheet for each component? You can either use the new `style { ... }` tag, or put a `style.css` in the component's directory and make sure your bundler finds it.

If you mean actually *restricting* the CSS to specific sections of the final document, as far as I know that's not possible (except in Firefox with `<style scoped>`). Other frameworks just quietly add extra classes and selectors to make it *look* that way. More of the latter,

It's not possible doing it in css alone.  However, it is possible with the help of a build step. Basically obfuscating the classname with hashes eg. `.container` _becomes_ `.cn2o3j`.

Prior art are css-modules, styled-components, styled-jsx.
 This is one of the reasons I'm still using Vue.js. It has support for scoped CSS via classname injection.

The other reason is that .vue files are just HTML files, so you don't need to use prefixes like `$` or `-`, and they don't need their own editor extensions for syntax highlighting. @mindeavor, I don't want to derail this topic, but .vue files support `<script>` and `<style>` elements,  so there's no need to put your JavaScript in a string.

And according to the [HTML spec](https://html.spec.whatwg.org/multipage/syntax.html#attributes-2), there's nothing wrong with dots in attribute names.

See [Single File Components](https://vuejs.org/v2/guide/single-file-components.html) for more information.

![image](https://cloud.githubusercontent.com/assets/468153/24052357/3882643a-0b03-11e7-874e-d47865057648.png) @patrick-steele-idem I think I'm leaning towards Vue's implementation as a recommendation. Which is just hooking up to post-css.  With post-css you can basically create any transform you want, sass, less, css-modules.

Since we'll all shoving this down to compiler step.  There won't be any added bulk to the final output.

 +1 Vue like implementation Random idea: if the style processing can actually take a list of processors then a `scoped` processor could perhaps be created. This would allow things such as `style.scoped { ... }` and `style.less.scoped { ... }`. +1 Vue like implementation :+1:   On a related note, should `class { ... }` be renamed to `component { ... }`? That seems like a more accurate description, fits better with the theme (`style { }` => `style.css`, `component { }` => `component.js`), and would be less likely to confuse new users who expect it to behave like an ES6 `class`. I use a lot of classes outside of Marko specific code and use the onCreate method instead of the constructor method to avoid confusion. I advocate removing the `constructor` method and standardize the `onCreate` method across both `module.exports` and the `Marko` class component definition.   <!--- Provide a general summary of your changes in the Title above -->

## Description
The `await` tag basic implementation and advanced use signature.

## Motivation and Context
I wanted to fill in the basic implementation because it's so handy. If you think this will help users I will also volunteer to document the advanced usage but doing so could take a whole page. Your thoughts?

## Screenshots (if appropriate):

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [x] My code follows the code style of this project.
- [x] I have updated/added documentation affected by my changes.
- [x] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes.
- [ ] All new and existing tests passed.
 
[![Coverage Status](https://coveralls.io/builds/10542523/badge)](https://coveralls.io/builds/10542523)

Coverage remained the same at 86.815% when pulling **2ed2fe3e6c9d5b4ee62645871d490682c7d66ec1 on tcrowe:await-docs-basic** into **bce2727c60a1072aaaef3cff682408a079b9977a on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/10542570/badge)](https://coveralls.io/builds/10542570)

Coverage remained the same at 86.815% when pulling **2b05f8d5803af2a70f20e53ba1f78a88c969ec6e on tcrowe:await-docs-basic** into **bce2727c60a1072aaaef3cff682408a079b9977a on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/10542629/badge)](https://coveralls.io/builds/10542629)

Coverage remained the same at 86.815% when pulling **623610bf0262af56826812359387ff9b7f8003a3 on tcrowe:await-docs-basic** into **bce2727c60a1072aaaef3cff682408a079b9977a on marko-js:master**.
 @mindeavor Yes you can. You can discover a lot about it from here:
https://github.com/marko-js/marko/search?utf8=%E2%9C%93&q=await You're welcome! ðŸ‘   <!----------------------------------------------------------------------
  |     IF FEATURE SUGGESTION (skip to next section for bug reports)    |
  ---------------------------------------------------------------------->
## New Feature

### Description
<!--- Provide a detailed description of the change or addition you are proposing -->

### Context
<!--- Why is this change important to you? How would you use it? -->
<!--- How can it benefit other users? -->

### Possible Implementation
<!--- Not obligatory, but suggest an idea for implementing addition or change -->

### Open Questions
<!--- What still needs to be discussed -->

### Is this something you're interested in working on?
<!--- Yes or no -->

<!----------------------
  |     IF BUG REPORT    |
  ---------------------->
## Bug Report
I started out following the webpack-marko integration tutorial on http://markojs.com/docs/webpack/
and got the error message "error in cannot find module 'marko/compiler' " even with webpack version 1.14.0.

### Context
<!--- Provide a more detailed introduction to the issue itself, and why you consider it to be a bug.  How has this bug affected you? What were you trying to accomplish? -->

![image](https://cloud.githubusercontent.com/assets/26175060/23806596/203176dc-0577-11e7-9360-70c1c5e68089.png)

### Expected Behavior
<!--- Tell us what should happen -->

### Actual Behavior
<!--- Tell us what happens instead -->

### Possible Fix
<!--- Not obligatory, but suggest a fix or reason for the bug -->

<details><summary>Additional Info</summary>

### Your Environment
<!-- Include as many relevant details about the environment you experienced the bug in -->
* Version used:
* Environment name and version (e.g. Chrome 39, node.js 5.4):
* Operating System and version (desktop or mobile):
* Link to your project:

### Steps to Reproduce
<!--- Provide a link to a live example, or an unambiguous set of steps to -->
<!--- reproduce this bug include code to reproduce, if relevant -->
1. 
2. 
3. 
4. 

### Stack Trace
<!-- If an error is thrown, provide the stack trace here -->

</details>
 I think this is because `marko-loader` does not depend on the `marko` package.  If you install the marko package this should work:

```sh
npm install --save-dev marko
# or
yarn add --dev marko
``` To be clear, this is consistent behavior for any webpack `*-loader`: For example, when using the babel-loader, babel-core needs to be installed separately. Try this , if you like [marko starter kit](https://github.com/wujjpp/marko-starter-kit)  <!----------------------
  |     IF BUG REPORT    |
  ---------------------->
## Bug Report

### Context
<!--- Provide a more detailed introduction to the issue itself, and why you consider it to be a bug.  How has this bug affected you? What were you trying to accomplish? -->
I was working on a personal project and wanted to replace an existing rendered component with the newly rendered one using the following code:

```javascript
var $featured = document.querySelector('.featured_fish');
var featuredFish = require('../fh-featured-fish');

// featuredFish reference: 
//  https://gist.github.com/pcanella/da7eb300409034ed93c2ffe7525ed656

featuredFish.render(f).then(function(result){
        result.replace($featured);
});
```

Then, in console I get the following issue 

`Uncaught (in promise) TypeError: destroyElRecursive is not a function(â€¦)beforeRemove @ bundle.js:3670replace @ bundle.js:3691(anonymous function) @ bundle.js:5274`


### Expected Behavior
<!--- Tell us what should happen -->
Ideally, it should just replace the dom element, right?

### Actual Behavior
<!--- Tell us what happens instead -->
`Uncaught (in promise) TypeError: destroyElRecursive is not a function(â€¦)beforeRemove @ bundle.js:3670replace @ bundle.js:3691(anonymous function) @ bundle.js:5274`

### Your Environment
<!-- Include as many relevant details about the environment you experienced the bug in -->
* Version used: V4
* Environment name and version: Version 54.0.2840.71 (64-bit)
* Operating System and version (desktop or mobile): OS X on Chrome
* Link to your project: Not up yet, so I really don't have a repo at the moment...

### Stack Trace
<!-- If an error is thrown, provide the stack trace here -->
`Uncaught (in promise) TypeError: destroyElRecursive is not a function(â€¦)beforeRemove @ bundle.js:3670replace @ bundle.js:3691(anonymous function) @ bundle.js:5274`
</details>
 @patrick-steele-idem ah! I am actually using browserify/markoify for this specific instance. This is my script I run before `app.js` runs

`"browserify -g markoify --extension='.marko' assets/js/main.js -o assets/js/bundle.js`

My "main.js" file just has some document level event binding (working on getting rid of that, but it doesn't really affect marko at all)  Don't understand. Why not just use a function? @andersea It actually hooks into a built-in extension system that's been part of `require()` since almost the beginning, but it has also been deprecated for nearly as long ([require.extensions](https://nodejs.org/api/globals.html#globals_require_extensions)).

It was originally decided that the added convenience outweighed the risk (#78). However, with the related changes Patrick mentioned, this may be the perfect time to rethink that.

Also, it's not *necessary* to use the extension, the old way still works without it:
```js
var template = require('marko').load(require.resolve('./path/to/template.marko'));
``` Thanks for that answers. Closing.  Koa 2.0.1 is released as `latest` version, so, these docs needs to be updated. Also added gzip example to feature Koa + Marko streaming flexibility. 
[![Coverage Status](https://coveralls.io/builds/10482007/badge)](https://coveralls.io/builds/10482007)

Coverage remained the same at 87.104% when pulling **f6af3372e757fff3c414dc3702a9675919860074 on tinovyatkin:master** into **aec7ae301361754943aabbaca52464188a0f28f1 on marko-js:master**.
  <!--- Provide a general summary of your changes in the Title above -->

## Description
The developer can `require` marko files then use component auto init.

I found out about it in the [marko-webpack/src/pages/home/client.js](https://github.com/marko-js-samples/marko-webpack/blob/master/src/pages/home/client.js) file.

## Motivation and Context
It may be helpful to include it in the documentation.

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [x] My code follows the code style of this project.
- [x] I have updated/added documentation affected by my changes.
- [x] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes.
- [ ] All new and existing tests passed.
 
[![Coverage Status](https://coveralls.io/builds/10456017/badge)](https://coveralls.io/builds/10456017)

Coverage decreased (-2.8%) to 87.074% when pulling **25c38059755b1f6b6ac81af4a94b2525a77a8417 on tcrowe:comp-auto-init** into **6e5f5fe4f3cc02abcb124097254dc8c13d1534fe on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/10456017/badge)](https://coveralls.io/builds/10456017)

Coverage decreased (-2.8%) to 87.074% when pulling **25c38059755b1f6b6ac81af4a94b2525a77a8417 on tcrowe:comp-auto-init** into **6e5f5fe4f3cc02abcb124097254dc8c13d1534fe on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/10456017/badge)](https://coveralls.io/builds/10456017)

Coverage decreased (-2.8%) to 87.074% when pulling **25c38059755b1f6b6ac81af4a94b2525a77a8417 on tcrowe:comp-auto-init** into **6e5f5fe4f3cc02abcb124097254dc8c13d1534fe on marko-js:master**.
  I noticed that docs for express integration just have you `require('marko/express')`, which means it's using the side-effect pattern to modify the global `express.response` object.

The typical express middleware pattern would be:

```js
const express = require('express')
const marko = require('marko/express')

const app = express()
app.use(marko)
```

Is there a specific reason marko/express doesn't use the middleware pattern?

Looking at [marko/express.js](https://github.com/marko-js/marko/blob/v4.0.0/express.js), it doesn't seem like it needs to cause side-effects to integrate with express.

Using side-effects instead of the middleware pattern means that you can't isolate marko integration to a specific express app, route, or path. Granted, the current implementation is opt-in (you only call `res.marko` if you need to) but if more features are added to express integration, the inability to isolate the integration may become a problem.  I am new to Marko, and I found a tricky error when I try to layout the html page in sections.

src/component/app-sections/index.marko
```html
<div class="panel-body" style="background-color: #eee;">
      <form class="form-horizontal" key="anything" role="form">
         <div class="form-group" for(section in data.sections)>
          <label class=['col-md-3', 'control-label'] style="text-align: left;">
            ${section.label} <if(section.requiredField)><span.field_req_designator>*</span></if>
          </label>
          <div class='col-md-9'>
            <include(section)/>
          </div>
      </form>
</div>
```

When I add "key" attribute like this `<form class="form-horizontal" key="anything" role="form">`, it will report such an error below. If I removed the key, everything compiles fine.
```
[marko/hot-reload] Template successfully reloaded: /Users/dofu/git/epnportal/src/components/app-sections/index.marko.js
events.js:160
      throw er; // Unhandled 'error' event
      ^

Error: Async fragment failed. Exception: Error: No component found
    at Error (native)
    at getCurrentComponent (/Users/dofu/git/epnportal/node_modules/marko/components/taglib/helpers/getCurrentComponent.js:13:15)
    at Object.render (/Users/dofu/git/epnportal/src/components/app-sections/index.marko.js:20:21)
    at hotReloadProxy (/Users/dofu/git/epnportal/node_modules/marko/hot-reload/index.js:82:31)
    at Object.render (/Users/dofu/git/epnportal/src/components/app/index.marko.js:62:3)
    at hotReloadProxy (/Users/dofu/git/epnportal/node_modules/marko/hot-reload/index.js:82:31)
```

The rest pieces of code:
~/src/component/app/index.marko
```html
<div>
  <app-sections>
    <@section label='Advertiser' requiredField=true>
      <app-dropbox name='advertiser' options=dropboxAdvertiser />
    </@section>
</div>
```

~/src/component/app-sections/marko-tag.json
```json
{
  "@sections <section>[]": {
    "@label": "string",
    "@requiredField": "boolean",
    "@*": "string"
  }
}
```

I am really excited to see Marko v4 coming out with many new features, bravo! @mindeavor In the [official document](http://markojs.com/docs/components/#codekeycode), it mentions:  
The key attribute can be applied to **both HTML elements and custom tags for UI components**. If applied to an HTML element, a unique id attribute will be added to the HTML element. The assigned ID will be a concatenation of the parent component ID with the provided value of the key attribute.

I think my use case is to apply on the html element. And, later, I can use `this.getEl(elId)` to manipulate the DOM. @patrick-steele-idem Thanks for the clarification, that makes sense!  ## Bug Report

### Context
I'm trying to use a single-file component as `components/{name}.marko` instead of `components/{name}/index.marko`.

### Expected Behavior
App starts and is able to serve that page (localhost:8000).

### Actual Behavior
The stacktrace below is thrown when the app starts.

### Your Environment
* Version used:
  * marko 4.0.0
  * lasso 2.11.5
  * lasso-marko 2.3.0

### Steps to Reproduce
1. clone https://github.com/drewfish/marko-bug606
2. run `npm install`
3. run `node server.js` and see the error as mentioned

### Stack Trace
```
/Users/drew/dev/node-moomet/research/bugx/node_modules/marko/compiler/Compiler.js:84
        throw error;
        ^

Error: An error occurred while trying to compile template at path "/Users/drew/dev/node-moomet/research/bugx/components/page-meter/index.marko". Error(s) in template:
1) [components/page-meter/index.marko:9:13] Unrecognized tag: meter-channel - More details: https://github.com/marko-js/marko/wiki/Error:-Unrecognized-Tag

    at handleErrors (/Users/drew/dev/node-moomet/research/bugx/node_modules/marko/compiler/Compiler.js:82:21)
    at Compiler.compile (/Users/drew/dev/node-moomet/research/bugx/node_modules/marko/compiler/Compiler.js:151:9)
    at _compile (/Users/drew/dev/node-moomet/research/bugx/node_modules/marko/compiler/index.js:89:33)
    at Object.compile (/Users/drew/dev/node-moomet/research/bugx/node_modules/marko/compiler/index.js:103:12)
    at compile (/Users/drew/dev/node-moomet/research/bugx/node_modules/marko/node-require.js:52:38)
    at Object.markoRequireExtension [as .marko] (/Users/drew/dev/node-moomet/research/bugx/node_modules/marko/node-require.js:120:27)
    at Module.load (module.js:487:32)
    at tryModuleLoad (module.js:446:12)
    at Function.Module._load (module.js:438:3)
    at Module.require (module.js:497:17)
``` Hmm... it looks like I can workaround this by adding entries to my marko.json like this:
```json
{
    "<meter-channel>": {
        "renderer": "./components/meter-channel.marko"
    },
    "tags-dir": "./components"
}
``` Looking at the implementation of compiler/taglib-loader/scanTagsDir.js this might be a feature request (instead of a bug) ðŸ˜„   ## Bug Report

### Context
When a component `class` has a parsing issue, the exception thrown has a typo. Additionally, `Error:` is appended to the message twice.

### Expected Behavior
The error should read: `Unable to parse JavaScript for **component** class.`

### Actual Behavior
The error output is: `Unable to parse JavaScript for componnet class. Error: Error:`

### Possible Fix
Fix typo and remove `Error:`. Can tackle this issue if needed.  Hello,

I am using Marko (great tool by the way!) to generate XML.
I have a Â«rootÂ» .marko file and a few included files. I would like to keep the indentation in the rendered file for various reasons.

However, when I indent the xml tags in the included file, I have this error:
` Line has extra indentation at the beginning`

The root .marko file looks like this:
```
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<myxml>
    <include("./myxml-include.marko", data)/>
</myxml>
```

And the included file (note the indentation):
```
    <SubObject>
        <Value>primary</Value>
    </SubObject>
```
Is there a way to remove this formatting rule?

Thanks! Thanks, it's working!  I have a question.

What about the templates that have `Class` like in marko widget?

Since The bodies of class declarations and class expressions are executed in strict mode.

And what about the compiled templates also use class?

Thanks!

reference:

https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes Got it @patrick-steele-idem thanks!  Biggest reason for this is parity with `onClick` which has access to the full data/state/input context.

index.marko-current
```
<div onClick('handleFoo')>click</div>
```

component.js:
```
module.exports = {
   handleFoo( e ) {
     alert( this.getFullName() );
   }
   getFullName() {
     return input.firstName + " " + input.lastName
   }
}
```

Compare the `-current` and `-proposed` convenience, debuggability, consistency, etc.

For some (many?) functions, eventually those component functions may move to a more structured project lib, but during initial development, having all functions available in `this.*` and `component.*` is extremely convenient.

index.marko-proposed
```
<div onClick('handleFoo')>${ component.getFullName() }</div>
$ console.log( component.getFullName() )
```

index.marko-current
```
import helper from './helper'
<div onClick('handleClick')>${ helper.getFullName( input, state ) }</div>
$ console.log( helper.getFullName( input, state ) )
```

component.js-current
```
import helper from './helper'
module.exports = {
   handleClick() {
     alert( helper.getFullName( input, state ) );
   }
}
``` Yep... just pointing out why it's an improvement over the current options / alternatives.

`${ component.getFullName() }` would make me very happy. :-)  I got an situation here.

My team is using `await` in a page that we need to handle more then one Promise
They tried to use something like this

```HTML
<await(data from firstProvider)>
    <await(complementData from secondProvider)>
    </await>
</await>
```

They said to me they got some errors with nested `await` and i was thinking in two solutions for this scenario

I was thinking about wrap the Promises in an especifc provider and use `Promise.all(requests)`

or create a custom tag like this one `<await-all(data from [Promise1, Promise2, ....])</await-all>`

What is the best solution to implement something like this?

What do you think about it??

Thanks and i'm in love with marko :rocket:  ```HTML
<var watcher=Promise.all([firstProvider(), secondProvider()] />
<await(response from watcher) ></await>
```

i will test something like this! Here's my demo/test about this issue

https://github.com/mauricionr/marko-demo

```HTML
<var watchers=Promise.all([data.promise1, data.promise2]) />
```

the service 

```javascript
module.exports = () => {
    return new Promise((resolve, reject) => {
        request.get(config.categories, (error, response, body) => {
            setTimeout(() => {
                resolve(JSON.parse(body));
            }, 5000)
        })
    })
}
```
the controller

```javascript
module.exports = (req, res) => {
    template.render({
       name:'Mauricio Nunes dos reis',
       colors:['red', 'green', 'blue'],
       promise1:categorieService(),
       promise2:categorieService()
   }, res)
}
```

the view

```HTML
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Marko Demo</title>
    </head>
    <body>
        <h1>Marko Demo</h1>
        <h2>${data.name}</h2>
        <section>
            <ul>
                <li for(color in data.colors)>${color}</li>
            </ul>
        </section>
        <var watchers=Promise.all([data.promise1, data.promise2]) />
        <await(response from watchers) client-reorder=true>
            <await-placeholder>
                Loading data...
            </await-placeholder>
            <await-error>
                An error occurred!
            </await-error>
            <await-timeout>
                A timeout occurred!
            </await-timeout>

            <h3>Promise1</h3>
            <section>
                <ul>
                    <li for(cat in response[0])>${cat.name}</li>
                </ul>
            </section>
            <h3>Promise2</h3>
            <section>
                <ul>
                    <li for(cat2 in response[0])>${cat2.name}</li>
                </ul>
            </section>
        </await>
        <await-reorderer/>
    </body>
</html>
```

Works well :rocket: 

But i could not see the *Loading data* and i'm using the tag `await-placeholder`

Since i'm using `json-server` to fake and json api, i put an timeout to looks like the real world and could not see the loading.

Any guess?

Thanks guys!! @mlrawlings yes, but you can double check if really is server-side rendering here's the [demo](https://github.com/mauricionr/marko-demo)  In `rc.17` and earlier, Marko would automatically add a widget's `index.marko` to the internal dependency array if needed. As of `rc.20`, the `<class { ... } />` tag adds the `index.marko` to the dependency list as expected, but if a `component.js` or `component-browser.js` is used instead then it will add that to the dependencies, but *not* the corresponding `index.marko`. @mlrawlings Looks like a `console.log` slipped through, and it's not marked as `latest-beta`. But other than that it works! :)  ## Question

I'm using marko and is awesome

My question is, there's any Best Practice guide for production enviroment?

Thanks guys! For client-side, see #490; The documentation is still a work-in-progress. Patrick mentioned using `minprops` and `envify` to reduce code size, but you should really just follow the standard best practices for *all* client-side code: Minify, gzip, and cache responsibly. How you actually *do* that depends on your other libraries and frameworks - `express`, `lasso`, etc.

Server-side, the only recommendation I'm aware of is to set `NODE_ENV=production`. That's because `Marko` is designed to be the best of both worlds - convenient in development, efficient in production.  
[![Coverage Status](https://coveralls.io/builds/10269446/badge)](https://coveralls.io/builds/10269446)

Coverage increased (+0.003%) to 89.811% when pulling **35dc0c4429b9adbca2bc774e6c2a07b8d905c1d7 on 593-scriptlet-metadata** into **34f60a777ad6fd1ce9e7c78b5cca774982695ded on master**.
  Strawman argument was for:

```
<scope>
   $ var x = 1
   $ var y = 2
   This is ${x}, ${y} valid.
</scope>
This is ${x}, ${y} undefined.
```

...compiling to an IIFE for scope protection, and using `$ ...` for JS execution.

Rationale is that a dangling `$ var x = ...` at the top of a file could have spooky action at a distance towards the bottom of the file, but if it were captured in some sort of `<scope> ...` block then the area required to analyze is much smaller. A lot of tags generate nested functions, so with `$ var ...;` it's impossible to know where the scope begins or ends until you look at the compiled output - it could stop at the nearest parent tag, or extend all the way to the top-level render function. That *usually* doesn't matter, but it would be nice to have a more explicit way to handle variable scope.

I agree with using `$ ...;` for inline javascript, but things like tag scope need to be handled by the compiler. So here's my idea: The `<var>` tag could be reintroduced, with `<var ...></var>` compiling to an IIFE as before. However, self-closing `<var ... />` tags would now be *template*-scoped.

Example:
```html
<if(input.foo)>
  <var foo=input.foo /><!-- hoisted -->
  <var bar=input.bar><!-- scoped -->
    $ console.log(foo, bar);
  </var>
  <var foo=null /><!-- hoisted -->
</if>
$ console.log(foo); // input.foo ? null : undefined
$ console.log(bar); // ReferenceError
```
```js
var foo;
if (input.foo) {
  foo = input.foo;
  (function(){
    var bar = input.bar;
    console.log(foo, bar);
  })();
  foo = null;
}
console.log(foo); // input.foo ? null : undefined
console.log(bar); // ReferenceError
```

A name other than `<var>` could be used for backward-compatibility, but ~~`v4` has already shipped without it~~, and I feel it would be fairly easy to explain that "`<var ... />` is now template-scoped".

> Edit: Whoops, looks like `<var>` is still present in `v4` but it prints a deprecation warning. Still, at this point I think it would be safe enough to make this change.  just stumbled into something similar, this works:

```
class {
    sayHi() {
        alert(`Hi!`);
    }
}

<main>
    <h1>test</h1>

    <button on-click('sayHi')>Click me!</button>
</main>
```
this works:
```
<include('../../layout.marko')>
    <@body>
        <main>
            <h1>test</h1>
 
            <button>Click me!</button>
        </main>
    </@body>
</include>
```
but this doesn't:
```
class {
    sayHi() {
        alert(`Hi!`);
    }
}

<include('../../layout.marko')>
    <@body>
        <main>
            <h1>test</h1>
 
            <button on-click('sayHi')>Click me!</button>
        </main>
    </@body>
</include>
```   <!----------------------
  |     IF BUG REPORT    |
  ---------------------->
## Bug Report

### Context
placing non-breaking space (`&nbsp;`) in a template element renders out as `Ã‚` on the browser (VDOM).

### Expected Behavior
should render simply as (`&nbsp;`)

### Actual Behavior
renders as `Ã‚`.

<details><summary>Additional Info</summary>

```
< div class="cartCoupTitle" >
        ${coup.title}< br/ >
        < span class="cartCoupGUID" >${coup.GUID}< /span ><br/>
        < strong >Expires< /strong > &nbsp; &nbsp;${coup.expires}
< /div >
```

VDOM

``` marko_forEach(state.productCoupons, function(coup) { 
out.e("div", marko_attrs31, 2) 
.e("div", marko_attrs32, 7) 
.t(coup.title) .n(marko_node27) 
.e("span", marko_attrs34, 1) 
.t(coup.GUID)
 .n(marko_node28) 
.n(marko_node29)
 .t(" Ã‚Â Ã‚Â ") 
.t(coup.expires) 
.e("div", marko_attrs33, 1) 
.e("strong", null, 2) 
.t("$") 
.t(coup.authorizedPrice); }); 
```
</details>
  +1  Hello,

While refactoring for `rc14` I realise that new syntax for `data.renderBody` invocation must be like this:

```
$ if(data.renderBody) data.renderBody(out);
```
That's not looks very good inside a HTML like template. May be it's better to create a dedicated tag like `<tag-body-out />` for that purpose? It will be rendering for nothing or body... Simple and elegant? is `data` deprecated too and we should use `input` instead?  Or could be more vue like

for((key, value) in data)//object

And

for(item in data)//array

Thanks :)  ```
WARNING!!
The "<invoke>" tag is deprecated. Please use "$ <js_code>" for JavaScript in the template. See: https://github.com/marko-js/marko/wiki/Deprecation:-var-assign-invoke-tags
  at node_modules/marko/taglibs/core/invoke-tag.js:3:13
```

note the module where it happens...  
[![Coverage Status](https://coveralls.io/builds/10073306/badge)](https://coveralls.io/builds/10073306)

Coverage decreased (-0.001%) to 89.82% when pulling **724f8addf843df941416ded82c1b02f308102e86 on 574-picture-tag** into **097ebc15b3a348de2ec07ee4eb3a01b40aad7eb1 on master**.
  Compilation broken with error `Unrecognized tag: picture` while `picture` is certainly a standard HTML5 tag   
[![Coverage Status](https://coveralls.io/builds/10060503/badge)](https://coveralls.io/builds/10060503)

Coverage increased (+0.006%) to 89.391% when pulling **768d8085f7adc8811e027ec7a88cae682a703a9e on 558-deprecate-tags** into **41b2c0878a6c9af69fb22889e97cee5495fc9bdb on master**.
 
[![Coverage Status](https://coveralls.io/builds/10060503/badge)](https://coveralls.io/builds/10060503)

Coverage increased (+0.006%) to 89.391% when pulling **768d8085f7adc8811e027ec7a88cae682a703a9e on 558-deprecate-tags** into **41b2c0878a6c9af69fb22889e97cee5495fc9bdb on master**.
  
[![Coverage Status](https://coveralls.io/builds/10060177/badge)](https://coveralls.io/builds/10060177)

Coverage decreased (-0.04%) to 89.34% when pulling **608d098cffb0019bf2eee34dc4583943761434f0 on 570-ref-to-key** into **41b2c0878a6c9af69fb22889e97cee5495fc9bdb on master**.
  I do think "key" is a more accurate description, though I'm not entirely convinced the change is necessary. My only major concern would be possible naming collisions - I can think of plenty of other uses for a custom "key" attribute, but not very many for "ref", which has always been pretty much reserved for widgets anyway. That's not to say I disagree, but I'd like to hear a few more pro's and con's.

If this change is implemented, I would be in favor of providing a temporary / opt-in `"ref" -> "key"` alias, perhaps in a `marko-v3-compat` package like what was suggested in #558. Ah, forgot about React. I'd say those are pretty good reasons to make the switch.  
[![Coverage Status](https://coveralls.io/builds/10036031/badge)](https://coveralls.io/builds/10036031)

Coverage increased (+0.02%) to 89.332% when pulling **00dda0a537e306cf063e8d3103679c316617bf41 on 487-template-compiler-version** into **ffdc91382fb41484585b60ea98f840d3f8f5b25f on master**.
 
[![Coverage Status](https://coveralls.io/builds/10036496/badge)](https://coveralls.io/builds/10036496)

Coverage increased (+0.02%) to 89.332% when pulling **645d184da0abc2b854931f2718dd75e9d382c616 on 487-template-compiler-version** into **ffdc91382fb41484585b60ea98f840d3f8f5b25f on master**.
 
[![Coverage Status](https://coveralls.io/builds/10036496/badge)](https://coveralls.io/builds/10036496)

Coverage increased (+0.02%) to 89.332% when pulling **645d184da0abc2b854931f2718dd75e9d382c616 on 487-template-compiler-version** into **ffdc91382fb41484585b60ea98f840d3f8f5b25f on master**.
  <!--- Provide a general summary of your changes in the Title above -->
This fix will ensure that an empty array does not output a an empty class attribute: `class=""`.

## Description
- modified helpers.js line 55 adds ` || null` when the array is empty (because a joined empty array is falsy);
- fixed tests to accommodate

## Motivation and Context
I was attempting to use arrays for class names because of the utility of concatenating them together was taken up by Marko. But, when the array was ever empty, I would have the `class=""` throughout my app, and my tests. This issue added unnecessary bloat. Therefore, the motivation for this fix.

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [x] My code follows the code style of this project.
- [X] I have updated/added documentation affected by my changes.
- [X] I have read the **CONTRIBUTING** document.
- [X] I have added tests to cover my changes.
- [X] All new and existing tests passed.
 
[![Coverage Status](https://coveralls.io/builds/9985791/badge)](https://coveralls.io/builds/9985791)

Coverage remained the same at 84.055% when pulling **0460d268ea3a412ebb91877da56f0c7847177f4b on seangates:v3** into **3ed82b7a0013ab8f8a1e82fc33447738e156cf7e on marko-js:v3**.
 @mindeavor Noted. Fixed!  I just switched from rc 8 to 12 and my widgets getTemplateData method is no longer being called in any of my widgets. Was this removed for some reason? I have no problems with it being removed, just didn't realize it was, so it broke my code when I moved form rc 8 to 12. I couldn't tell if it was a bug or intended. I tried looking at the revisions, but couldn't make heads or tales of where the change actually happened. :)

I was only using it because the [Roadmap ](https://github.com/marko-js/marko/blob/master/ROADMAP.md) under heading **New widget lifecycle methods**  shows the getTemplateData method in the **new** list. So I thought I was supposed to be using it. :) I guess the roadmap doc just needs to be updated to remove it. 

Thanks for confirming.  An error should not be thrown -- https://html.spec.whatwg.org/multipage/scripting.html#custom-elements That just goes back to the boilerplate issue I opened a while back -- https://github.com/lasso-js/lasso-marko/issues/3

Now, if the parser encounters `<my-awesome-element>...</y-awesome-element>` then it should certainly throw an error. But the author may be fully expecting `<my-awesome-element/>` to be dumped into the rendered HTML as-is. I'm definitely against this being the default, but I would love to have this as an opt-*in* setting. Whitelisting tags is decent, but whitelisting tags b/c hopefully someday somebody will use concise-mode is making the wrong tradeoff in my mind.  Disable concise-mode by default.  All (most) issues with top-level tags magically go away  (eg: the following gem `ex0007.marko`).  Tags are tags.  `<for>` is `<for>` (and is wrapped in a tag, not a bareword).  It is a *serious* struggle to get behind "floating `class` statements" as is. (specifically referring to single-file-components).

```
$ cat ex0007.marko
this is
for
you
<h1>Test</h1>

$ markoc *.marko
- Failed to compile "ex0007.marko". Error: Error: An error occurred while trying to compile template at path "/home/rames/Git/marko-v4-spa-example/src/pages/test/ex0007.marko". Error(s) in template:
1) [ex0007.marko:2:0] Invalid <for> tag. Argument is missing. Example: <for(color in colors)>
```
 @mindeavor @ramses0 How would disabling concise mode actually solve the problem being discussed, which is whether to throw an error when an invalid tag is encountered? I understand that you don't like the syntax, but many of us do and are using it in production.

P.S.: You can use HTML syntax for the new tags, too: `<class { ... } />` `<static { ... } />`. @Hesulan - root level text is terrible.  My vote is for putting it into a `<div>`.  It is especially terrible when "for he's a jolly good fellow" gets parsed as a `<for ...` tag by marko.  However, "concise mode" has to treat every word in the file as if it _might_ be a tag (or `class` or `static` or `import` or whatever else exists in the global marko keyword namespace).  As someone who doesn't use concise mode, I see that trying to serve two masters in "single file components" is incredibly short-sighted.

The current single-file-component format has the benefit that it is backed by working code, but as an outsider / recreational user of markojs, I see it as full of traps for implementors and users, especially compared to non-single-file-components.  It also appears as though you can't really opt out of single-file component mode either. @ramses0 
You have a point, root level text is definitely a downside. But it's also easily solved with a `-- `, and aside from a "Hello World!" file, it would be difficult to find many real world use-cases.

Single-file components are still entirely optional, they're just more convenient than writing a separate `component.js` when working with small, simple components. The only component-related thing that I know of in v3 that won't work in v4 is `<script marko-init>`, which is being replaced by `<static>`.

I do understand preferring HTML over concise, and it's my opinion that the official documentation should try to use HTML syntax as much as possible (even though I almost always use concise). @mindeavor I'm still unclear on *how* disabling concise syntax would solve the problem, or how it's at the root of it. +1 for throwing an error. Many complex projects rely on knowing when there is an issue with an unknown or incorrect tag. @mindeavor I'm not sure what that has to do with throwing errors for invalid tag names, and those are all just different examples of the same thing - plain text as a root element.

@patrick-steele-idem On further thought, I think I would agree with throwing errors by default, as long as it's easy to disable and clearly documented. @mindeavor Ah, I see what you meant now. That's not the point though, the point is to catch invalid tag names. Root level text in concise mode is just one of the *many* ways that a typo could slip past, and to simply disable such a widely used feature by default would be a huge overreaction and wouldn't solve the problem of invalid tag names. Catching accidental root-level concise tags is only a nice *side*-effect of the proposed solution. @mindeavor From what I understood, the reason this came up is because if you type something like `<ing ... />` it's quite likely that you *meant* to type `<img ... />` unless you've explicitly defined a custom `ing` tag. Throwing an error would *also* help to catch accidental concise tags. I honestly can't remember the last time I even used root-level text outside of a Hello World example, but I can see how it would get annoying.

I do think only throwing on single-word tags is a reasonable condition, and I believe @mlrawlings mentioned something similar earlier in this thread. @mlrawlings would you be in favor of splitting out the potential discussion: "require concise mode to be explicitly opted in to"?

I believe it would require:

```
<class {
  onClick() { ... }
}/>
```

...which makes total sense to me.  Or a flag to explicitly opt out of the potential bugginess / confusion of mixing concise-mode, markojs single file components, javascript, and HTML?  I keep hearing `--` is the magic token, but haven't seen any documentation on that.  `"use strict"` is a precedent, `@concise-mode` was a strawman syntax, even `@strict-html` or `@disable-concise` would be welcome.  Hope I'm not hi-jacking the thread here, but on the topic of Classes, it seems you cannot use the extend keyword. If I make a component using a class that extends another class, it fails due to a instance check "_classCallCheck" where the instance is the Widget class, but it's checking for the Constructor of the parent. I get a failure of "cannot call a class as a function". This _seems_ to be caused by how Babel transpiles e6 code. Here's the relevant compiled code.

```
       function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
            }
        }
        var Test = function() {
            function Test() {
                _classCallCheck(this, Test);
            }
            _createClass(Test, [{
                key: "constrcutor",
                value: function constrcutor() {
                    console.log(parent);
                }
            }]);
            return Test;
        }();
        var Room = function(_Test) {
            _inherits(Room, _Test);
            function Room() {
                _classCallCheck(this, Room);
                return _possibleConstructorReturn(this, (Room.__proto__ || Object.getPrototypeOf(Room)).apply(this, arguments));
            }
            _createClass(Room, [{
                key: "onInput",
                value: function onInput(input) {
                    console.log("IT WORKED");
                }
            }]);
            return Room;
        }(Test);
        exports.default = Room;
        module.exports = exports["default"];
```

You can see the _classCallCheck is called twice, once for the child, once for the parent. It's the parent call that fails as the instance is "Widget" but the Constructor is "Room".

Is this the same issue as you mentioned above? @jasonmacdonald Michael was talking about the `<class { ... } />` tag. None of the code generated by Marko currently compiles to anything greater than ES5, and javascript classes are ES6. Could babel be trying to compile the `.marko` template by mistake? For sure it's Babel compiling the es6 classes. I'm trying to use a class as my component definition. But, it seems to be Marko that is adding the _classCallCheck to the compiled component definition. @jasonmacdonald I'm not quite sure what you mean, but using a class as a component definition is invalid. The `<class { ... } />` tag mentioned here is just a convenient syntax (with a bit of a misleading name), it doesn't *actually* generate an instantiable class. Sorry if I'm not being clear. I'm talking about Marko 4 widgets, defining a widget component using an ES6 Class instead of an Object. I'll start a different thread as this one isn't what I thought it was. Thanks!  @mlrawlings I think this really comes down to the developer knowing that using a v3 taglib in v4 can be tricky. These tags aren't the only breaking changes; The switch from `-` to `--` in concise comes to mind, along with several other edge-cases. Unless the parser and compiler can be switched into some sort of "legacy" mode whenever an outdated taglib is being loaded, I don't see any other way around the occasional compatibility issue, though in some cases a `marko-v3-compat` taglib might help. As a recreational user of marko v3 transitioning to v4, I am 100% in favor of "kill stuff that's going to die" (ie: `var`, etc).  `npm install markojs-v3-deprecated` is totally fine by me.

I *will* say that I am especially disappointed by the removal of the `<var>...</var>` special tag.

Conceptually being able to scope my sins of using `<var/>` in my logicless templates in the first place is invaluable.  Forgive my use of tables (throwaway code during development), but I used them like this:

```
      <var
        flavors=data.fnRandomFlavors( data.selection )
        ingredients=data.fnRandomPopularIngredients()
      >
        <h1>${data.fnCap(data.selection)} and...</h1>
             <td align="right"><a href="/drinks-with/${data.selection}/$${flavors[0]}">
              ${data.fnCap(flavors[0])}
            </a></td>
            <td>or</td>
            <td><a href="/drinks-with/${data.selection}/$${flavors[1]}">
              ${data.fnCap(flavors[1])}
            </a></td>
          </tr>
          <tr>
            <td align="right"><a href="/drinks-with/${data.selection}/${ingredients[0]}">
              ${data.fnCap(ingredients[0])}
            </a></td>
            <td>or</td>
            <td><a href="/drinks-with/${data.selection}/${ingredients[1]}">
              ${data.fnCap(ingredients[1])}
            </a></td>
          </tr>
```


The introduction of `$ var flavor=input.someFunc()` kill the template and you end up with PHP all over again.

What I mean is that with a scoped `<var>` tag, I can easily determine if the template is factorable (ie: what dependencies or requirements it might have).

With a "dangling `$ var ...`" statement... Every. Single. Line. after that `$ var ...` statement is suspect, and requires brainpower to determine if it is using any of the declared `$ var ...` variables.

In summary:

1) marko-v3-compat package is totally fine

2) killing `<var />`, or encouraging the use of `$ ...` for anything other than debugging is bordering on criminal (it basically makes the entire file unable to be reasoned about unless the human first does a "compilation pass" looking for `$ var ...` and then remembering where it is used).

I've written and seen enough bad PHP, and bad JS, written by good people (but not good programmers) that I would view use of markojs as highly suspicious.

*THINK* about this.  When you see `Array.prototype.something = function() { ... }` does that make you happy that the person before you was so clever? Or fill you with rage that now you have to audit the entire source tree for uses of `*.prototype` and then see how that interacts with the rest of the codebase?

In the below code, `<var a=...>` is demonstrable better from a maintenance programmer perspective compared to `$ var b=...;`  Neither is ideal, but `<var a=...>` as a shortcut to make the layout of the template easier, cleaner, etc. is much better.

```
<div>
    <var a=fnFoo()>
        ...snip...
        Hello ${a}
    </var>
    $ var b=fnBar();
    ...snip...
    <div>
    ...snip...
    Hello ${b}
    </div>
</div>
 @ramses0 I believe the main reason for deprecating `<var>`, `<assign>`, `<invoke>`, etc. is because the number of tags that attempt to simulate real javascript was becoming unmanageable, but you make a good point.

@mlrawlings Perhaps it would be a good idea to hold off on removing the `<var>` tag? I feel like it's enough of a special case to warrant keeping it around, especially since it fits each syntax so nicely. @mindeavor Internally, a `<var>` tag with body text compiles to an IIFE, which enforces scope:
```html
<var foo=1 bar=2>
    /* ... */
</var>
```
```js
(function(){
    var foo=1, bar=2;
    /* ... */
})();
``` Will there be (or is there) a way within marko to trigger an IIFE context for scope protection, as referenced in this comment?

https://github.com/marko-js/marko/issues/558#issuecomment-277313323 `<scope/>` is elegantly nasty in a way.  :-) ... it makes it very clear what you're doing, but still requires you to use `$ ...` but then you know your `$ ...`'s can't infect outside that `<scope>` block.  I guess I'm highly in favor of it... good design instinct.  "it would be nice" if there was a setting to emit a warning of something like the following:

```
Warning: file.marko:123  raw javascript `$ ...` found not at top of file or top of <scope> block.
```

ie: encourage `$` items to be in blocks at the beginning of the file instead of randomly sprinkled throughout.  If I can consistently open a template and know that `$ ...` is all bunched up at the top then I'll be a much happier camper.  But adding in a `$ ...debugging()...` randomly might be perfectly appropriate and encouraged (just not checked in / not for prod).

In short, though... I really appreciate you taking into consideration the issue of `<scope>` and would be highly in favor of it!  
[![Coverage Status](https://coveralls.io/builds/9949120/badge)](https://coveralls.io/builds/9949120)

Coverage increased (+0.02%) to 89.23% when pulling **526acaed4475c31379081feee143adb17b5e87a8 on 363-hot-reload-extensions** into **35517181e1e9602222b12bdfd7fb62767595c8d8 on master**.
  <!----------------------------------------------------------------------
  |     IF FEATURE SUGGESTION (skip to next section for bug reports)    |
  ---------------------------------------------------------------------->
## New Feature

### Description
I am using .html files only with marko html in it, but that prevents me from using marko's hot reload.

Lines:
- v4: https://github.com/marko-js/marko/blob/master/hot-reload/index.js#L133
- v3: https://github.com/marko-js/marko/blob/v3/hot-reload/index.js#L128 (and maybe L136 too)

### Context
I know that it's probably recommended to use .marko.html but I would like to stick with my implementation where I use `require('marko/node-require').install({ extension: '.html' })`.

### Possible Implementation
It would be cool if there would be an options object so I could simply use `{ extension: 'html' }` in the hot reload `.enable()` method too, or maybe even use the extension string from the install so that would work automatically.

### Open Questions
See above.

### Is this something you're interested in working on?
Yep, as long as it's clear how the implementation would work
 Sorry for the duplicate, I should have searched for that. Will think of that, but I have no idea how marko works so I don't know whether I will fit into this. I have currently fixed it manually editing the file for now.  Not sure if this is known, but I was testing a simple Marko 4 Widget in IE and it fails when trying to call new Symbol(). This doesn't appear to be supported in IE 11. As you can see [here ](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol) Symbol isn't supported on any IE versions. Is this intended?

Is it expected that we need to pollyfill fill this? Promise is also missing from compiled bundle. :(  Here's the snippet where it appears...

```
},{}],49:[function(require,module,exports){
var KEY = Symbol();

function UniqueId(out) {
    this.prefix = out.global.widgetIdPrefix || 'w';
    this.nextId = 0;
}

function nextWidgetId(out) {
    var global = out.global;

    var idProvider = global[KEY] ||
        (global[KEY] = new UniqueId(out));

    return idProvider.prefix + (idProvider.nextId++);
}
```

This is using Browserify to compile. Maybe Browserfiy is adding it? Nope, looks like it's coming from widgets/util.js, which is included by Widget.js

Interestingly, I switched to try and compile with Webpack and that util package doesn't seem to appear in it's output. So I guess Browserify is including stuff it shouldn't. Grr, too many options/differences with these damn bundlers. I switched over to Webpack and the issue seems to have gone away. However, if I can find a few mins I'll put together a simple project to show the issue. I'll close this for now and update if I can put something together, @jasonmacdonald Just wanted to add, because you mentioned `Promise` not being bundled: Marko doesn't provide a Promise polyfill, and as far as I know the only parts of Marko that require a global `Promise` object are the AsyncStream's `.then()` and `.catch()` methods, and only if you choose to call them.  This might be just me not fully understanding Widget scopes/states, or more likely it's working as intended, but if I have Widget (A) and Widget (B). Widget A uses Widget (B) in it's template and supplies some body content (template) for Widget B. The data scope is bound to Widget A for that body content and not Widget B (which actually renders it). 

Example

Widget A Template - data = 1
```
<widgetB data="2">
   <!-- trying to declare this inner content as a template 
   to be used to render the contents of Widget B -->
   <div>${data}</div>
</widgetB>
```

Widget B template - data = 2
```
<!--I want this to render the body declared in Widget A, but use the data scope of this Widget B-->
<div w-body></div>
```

This ends up rendering the value **1** in the div, not **2.**

What I was hoping was that the scope of WidgetB's data, value (**2**), would be supplied to the transcluded content. I suspect this is working as intended, but is there a way to get the result I was hoping for? 

What I'm trying to do is have widgetB  be able to declare a template to be used inside it's own template when rendered. Think of a tile list component, where I'm trying to supply a transcluded template to be used to render each tile when the tile list renders, rather than declaring the tile itself inside the tile list, for re-usability and flexibility. So each tiles data would be driven internal to Widget B, and I'm defining the template ${params} externally. I also tried using input.renderBody(out, WidgetB_data), inside WidgetB. But, that still seems to use WidgetA data. Thanks, mlrawlings! I'll give these a try! I think I might have a snag, all this assumes I'm only rendering the transcluded content once. But what I'm trying to do is use the transcluded content template as an itemRenderer for a loop, basically.

something like this (very simplified)

WIdget
```
<tileList data="${some_array_of_items}">
    <div>${item}</div>
</tileList>
```

TileList
```
<div for(item in items)>
    <div w-body></div>
</div>
```

Seems if I manually call input.bodyRenderer() it would just repeat the same content. Maybe I'm approaching this wrong. I'm just trying to make a reusable tielist component for an image gallery, where the user of the component can easily define how the content is rendered by specifying the item renderer in the body. I know I could have them define a path to a template to be used for rendering, was just trying to avoid extra files. oh, let me try that! You're the best, mlrawlings! Cheers! Wish I knew more of these secrets :) Can Marko Widgets use Marko 4? NPM complains that Marko Widgets wants a Peer dependency for 3.0 oh, really? I'll definitely use that then ok, awesome. Got Marko 4 all set-up and things seems to be working, for the most part. One thing I can't seem to get to work anymore is the "var" part to add the extra variable to the renderBody.

I've tried adding it to the marko-taglib and also to the top of the component with...

```
exports.tag = {
    "var": "item"
}
```

BUt the compiled output doesn't seem to add the var anymore. I had it working in Marko 3. Did this part change? I can't find anything about how to do these configs in the [Roadmap page.](https://github.com/marko-js/marko/blob/v4.0.0-rc.8/ROADMAP.md).

I'm sorry for the all the questions. :( ok, after some trial and error, I was able to get the "var" to appear in the compiled output, but only if I added a marko-tag.json file to the "Widget" component directory, along side my component.js and index.html. I used the following JSON

```
{
  "var": "item"
}
```

No clue if this is correct way though. We used to be able to add these in the component file using an exports.tag, but that doesn't seem to work anymore. Kind of annoying to have to add another file to accomplish this.

I'm still a bit muddy on all these JSON files (marko-taglib.json vs marko-tag.json vs marko.json) and where exactly they are supposed to live. It seems I need to have a marko-tag.json somewhere high in the directory that defines the components directory defining "tags-dir": "./src/components" or nothing gets found.

I'm sure it's just me fumbling my way through this without docs :(   I think it's not readable and clear like old syntax. Example if you are newbie in marko world and you see
```
<script template-helpers>
   function sum(a, b) {
      return a + b;
   }
</script>
```
You can easy understand that some logical operations is happen in script tags but if you see

```
static function sum(a, b) {
   return a + b;
}
```
You can think someone try to write in output "static function ... etc". Also if you need to write really to output something like this you need to wrap this code and it's not intuitive.

I like marko html syntax and custom tags because it make me fill everything is standard with some extra power.

Another thing why i like html syntax is if i have already written code in html it's really easy to integrate with my project without any other efforts but otherwise result can be unexpected.

I don't like concise, mix syntax and maybe i am wrong. @Eldar-X 
You're certainly not alone in preferring standard over concise syntax. I personally prefer concise, but I do feel that the official documentation should use HTML syntax whenever possible.

@mindeavor @patrick-steele-idem 
I much prefer using a separate tag rather than hijacking `<script>`. Even with the `template-helpers` or `marko-init` attribute, the first time I saw that it took a while to click. Someone new to Marko might not realize that it transforms top-level `<script>` and `<style>` tags, but when I see something like `<static>` or `static { /* ... */ }` I immediately recognize that it's special.

@patrick-steele-idem 
I really like this proposal. Correct me if I'm wrong, but I'm assuming the HTML syntax would look like:
```
<static {
    function myHelper() { /* ... */ }
} />
<component class {
    onInput() { /* ... */ }
} />
```
Would `<static>` still accept body content like `<script marko-init>` did?
```
<static>
    function myHelper() { /* ... */ }
</static>
``` If we do, it will be a problem to put spaces after $ because most of our text editors can divide our code like this
```
<div>
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris 
nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. 
Excepteur sint occaecat cupidatat non proident, sunt in culpa $
{
// What?
} qui officia deserunt mollit anim id est laborum.
<div>

``` 
Also i still think it should be at least for html version at least inside tags maybe like this
```
<$>
var myCode = true;
</$>

<{>
var myCode = true;
<}>

<${>
var myCode = true;
</}>

``` @patrick-steele-idem The only problem I see is that the `$ ...` would be parsed as a tag name in concise, but as text in HTML. I would prefer either `<$></$>`, or making that concise-only (in HTML you'd probably want to use `$${ ... }` instead anyway).

Other than that I like this proposal. Though I do feel it's important to mark this as a breaking change, since anyone previously using something like `$${price}` will now need to escape the first `$`. ~~Actually, now that I think about, I feel like it would be more intuitive if the behaviors of `$${ ... }` and `<% ... %>` were swapped (then `$${...}` would be a multi-line, multi-statement version of `${...}`), but that *might* be too much of a breaking change.~~

Edit: Whoops, nevermind. For some reason I was thinking `$${...}` would replace `static { ... }`. Haven't had my coffee yet this morning. 1) When this moves forward, will the deprecate state be eternal? Or is there a timeline to remove the old syntax? People tend to stick to the old syntax until forced to change. Will there be a migration tool?
2) I guess this is not related to the syntax change, but is JS linting possible in JS embedded in marko file?
3) I prefer a syntax that permits parsing such that we can still write easy-to-read, lint-able code (without changing a team's current JSLint/ESLint settings) - i.e., multi-lined object literal, usual indents, etc. For small JS, I am okay having it in marko; for larger JS, my preference is to put it in separate JS file. I'd want to be able to move the JS from marko to JS file without reformatting.
4) I prefer a single way of doing things - syntax flexibility of doing the same thing tends to end up in multiple ways of writing code within the same code base - and leads to endless discussion in opinions. @mikewoo200 
1. I'm not aware of anything in Marko that's ever been deprecated for too long without being removed, but with a change like this there will be plenty of deprecation notices. There will also be a migration tool sometime after v4 is released.

2. That would depend on whether the linter you're using supports linting only a section of the file. Alternatively, you could lint the entire resulting `.marko.js` file.

3. That's one of the main reasons for these changes; the way it's currently done doesn't make that easy, but the `class { ... }` syntax would. 2. What's a good linter than supports linting only a section of the file? We wouldn't lint`.marko.js` because it's a generated file that we don't check into our app codebase. @patrick-steele-idem, for "valid JS" linting (unused, undefined, etc.), what you mentioned would work. But for style linting (spaces, indents) in the template, what can we do? @patrick-steele-idem I'm a little unclear on the exact behavior of `$${ ... }`. Is it the same as `<% ... %>`, or will you be able to `return` something from it to be inserted into the document? For example, would this:
```
<div>
    $${
        return result;
    }
</div>
```
do basically the same thing as `<div>${result}</div>`?

I'm also not sure that `$${ ... }` needs to be restricted to the beginning of the line. It makes perfect sense for `$ ...`, but why not allow this:
```
<div>$${
    /* ... */
}</div>
``` @mlrawlings I like that, though I'm not sure what you mean by "special case `$` to *disallow* `$ { ... }`".

Here's my interpretation of the parser logic:
* If the tag name is `$`, immediately begin parsing as a multi-line expression (which also tracks `depth` within `{}`, `()`, and `[]` pairs)
* Continue until `char === "\n" && depth === 0` (end of line and we're not inside a pair of brackets)
* If the expression text spans multiple lines and begins with `{`, strip the opening `{` and closing `}`

If you need to enclose a multi-line tag's content in a javascript block statement, you'll simply need to use two pairs of brackets:
```
$ { /* begin script */ { /* begin block */
   /* ... */
/* end block */ } /* end script */ }
```
Optionally, the single-line syntax could *also* strip a single pair of surrounding brackets to avoid confusion. I'm late to the party, but I want to add my voice in support of *not* "concise" syntax. I do not think floating JS blocks are indicative enough of the code being associated with the template system. And as someone who abhors the "class" sugar, I'd be loath to use it solely for that reason. I would much rather see something like the following:

```
<marko-script>
module.exports = {
  handleClick: function (event) {}
}
</marko-script>
``` @jsumners I don't completely disagree - it would be nice to have a more HTML-like syntax - but after digging through the compiler code and giving it a lot of thought I'm personally convinced in favor of `class`. Also keep in mind that `<class {} />` (or `<script> module.exports = ... </script>`) is really just a convenience to avoid writing a separate `component.js` for small, simple components.

@patrick-steele-idem @mlrawlings On a related note, could `<static>` fall back to using body-text if the `{ /* ... */ }` attribute is omitted? I think a lot of users would prefer that, and it would certainly ease the transition from `<script marko-init>`. @patrick-steele-idem Yes, but could it fall back to parsing body-text if the block is omitted?
```
<static {
   /* ... */
} />
```
```
<static>
   /* ... */
</static>
``` @mlrawlings I only meant for `<static>`, and only in the way that's already used by `<script marko-init>` (which `<static>` is replacing). It wouldn't make sense for `<class>`, and I really don't like hijacking tags like `<style>`.  ## Bug Report

### Context

I'm trying to compile the following template:

```html
<script marko-init>
  const states = {
    foo: 'bar'
  };
</script>
<p>${(state_names[state] || state)[0].toUpperCase()}</p>
```

But the grouping around `(state_names[state] || state)` is not respected in the output.

### Expected Behavior

```js
// ...

  return function render(data, out) {
    out.w("<p>" +
      escapeXml((state_names[state] || state)[0].toUpperCase()) +
      "</p>");
  };
}

// ...
```

### Actual Behavior

```js
// ...

  return function render(data, out) {
    out.w("<p>" +
      escapeXml(state_names[state] || state[0].toUpperCase()) +
      "</p>");
  };
}

// ...
```

See how the grouping around `state_names[state] || state` is dropped.

### Your Environment

* Version used:
* Marko 3.14.0
* Node.js 6.9.2
* macOS Sierra (10.12.2) Thanks a lot!  I have a template that is in HTML format, but the parser is assuming concise mode, so warnings for issue 43 and 48 from htmljs-parser are now popping up in the console.

How do you disable concise mode if you do not use it? I didn't know about wrapping with `--` as I couldn't find any documentation on that.  Thanks for the tip.  That should work, and probably much easier than figuring out how to change marko to pass the concise: false option to htmljs-parser  <!----------------------
  |     IF BUG REPORT    |
  ---------------------->
## Extra quotation marks on output of non string objects

When variable is not a string output have extra quotation marks

```
const template = require('template.marko');
template.stream({
test : new Date();
})

// template file

<div data-test="${data.test}"/>
// Output is
<div data-test=""2017-01-19T12:58:42.801Z""></div> 
// In marko v3 output was
<div data-test="2017-01-19T12:58:42.801Z"></div> 
```  ## Exporting data from template

I think it would be very nice feature if we can exporting data from template files because now marko files have much power and we can make logical operations some times we just want to export result for using it somewhere else.

### Example use case:

We have cms and we want define output fields for this template then in our admin page we want get all fields of selected template file for fill them.
  Looks like what i need.
Let's make some example something like this is working?
```
// foo.marko
<script>
var fields = {};
</script>

<div class="myField-1">
 <% fields["first"] = {
 name:"firstField",
 type:"textarea"
} %>
</div>

<div class="myField-2">
 <% fields["second"] = {
 name:"secondField",
 type:"datePicker"
} %>
</div>

export var info = {
 name: "Home Page",
fields: fields
}

// bar.js
const template = require('foo.marko');
console.log(template.info) // name: "Home Page", fields: { first, second }
```  <!----------------------------------------------------------------------
  |     IF FEATURE SUGGESTION (skip to next section for bug reports)    |
  ---------------------------------------------------------------------->
## Inline output support for marko widgets

<!--- Provide a detailed description of the change or addition you are proposing -->
While marko widget now part of marko.js how about add support for printing compiled output of widgets inline to template file without bundlers? 

<!--- Why is this change important to you? How would you use it? -->
I think it's important feature because widgets must be independent from 3rd part tools but can provide support for them.
 Now for working with marko we must bundle output of widget yes? But why we can't just put output of widget into html between script tag? for example we have onclick listener in our widget why just not put in html? I know that bundled js have some better features but it also may be not bad Even the simplest widget depends on the `marko/widgets` runtime, which needs to be bundled anyway. It *might* be possible to add a compiler optimization to recognize this edge case and use plain JS instead, but that could easily break something. Alternatively, you could just add `<script>document.getElementById(...).addEventListener(...);</script>` yourself or even write a custom attribute transformer.

If you're just wanting specific widgets to be embedded in the page rather than included in the main bundle, most bundlers provide a way to do that. Lasso, for example:
```json
{
     "dependencies": [
        { "require": "./component.js", "inline": true }
    ]
}
```
Which results in something like:
```html
<body>
    ...
    <script src="/static/page-1ae394d6.js"></script>
    <script>
        /* component.js */
    </script>
</body>
```   
[![Coverage Status](https://coveralls.io/builds/9689890/badge)](https://coveralls.io/builds/9689890)

Coverage remained the same at 88.696% when pulling **7ff3d9bea59c89cc1f9346b36af288d3a832fcc2 on greenkeeper/fs-extra-2.0.0** into **f419c9f8e4bd8c285fba38c96b6a684402819597 on master**.
 
[![Coverage Status](https://coveralls.io/builds/9689890/badge)](https://coveralls.io/builds/9689890)

Coverage remained the same at 88.696% when pulling **7ff3d9bea59c89cc1f9346b36af288d3a832fcc2 on greenkeeper/fs-extra-2.0.0** into **f419c9f8e4bd8c285fba38c96b6a684402819597 on master**.
  
[![Coverage Status](https://coveralls.io/builds/9687277/badge)](https://coveralls.io/builds/9687277)

Coverage decreased (-0.03%) to 88.666% when pulling **f26e6ef22b518986f5b07621377364f1392c5c70 on 532-markoc-version** into **f419c9f8e4bd8c285fba38c96b6a684402819597 on master**.
  
[![Coverage Status](https://coveralls.io/builds/9657182/badge)](https://coveralls.io/builds/9657182)

Coverage remained the same at 88.708% when pulling **9ee4909c4c820d05faa3794028cabca3ab5cd4f9 on greenkeeper/md5-hex-2.0.0** into **1564788f2e0b84dce79d755602b7bdf9f26f8a58 on master**.
   Directories named `~node_modules` and `~runtime` seem to have been accidentally added to the NPM package starting from `4.0.0-beta.6`, bringing the `package.tgz` size from < 300 kB to > 3 MB. Still there as of `4.0.0-rc.0`.

/cc @patrick-steele-idem @mlrawlings   @patrick-steele-idem and @mlrawlings This reflects the behavior that was available in v3 with getInitialState and I don't see any problems with backwards compatibility. Thank You!  I've been following the 4.0 milestone, however I'm getting the following error: 

```
Error: An error occurred while trying to compile template at path "site/components/hero-image/index.marko". Error(s) in template:
1) [site/components/hero-image/index.marko:3:2] The include attribute must have an argument. For example: include("./target.marko") or include(data.renderBody)
```

However, with respect to https://github.com/marko-js/marko/issues/418, examples and notes illustrate the following approach:

```include()``` is the same as ```include(data.renderBody)```

Commit https://github.com/marko-js/marko/commit/306e19b88e9e305c83b9da1b4eab3fa8e028ee8f introduces the body-slot tag. 

Should we be using body-slot instead of the deprecated w-body tag, or transition to include(data.renderBody)? The `<body-slot>` tag was removed shortly after being added, and `include()` with no arguments was disallowed. I believe `include(data.renderBody)` is now the recommended way to do this.

You can also do something like:
```
<html>
    <head>
        <include(data.head) />
    </head>
    <body>
        <include(data.body || data.renderBody) />
    </body>
</html>
```
Then use it like:
```
<include('./layout.marko')>
    <@head>
        <title>Foo!</title>
    </@head>
    <@body>
        Foo!
    </@body>
</include>
```
or
```
<include('./layout.marko')>
    Foo!
</include>
``` @patrick-steele-idem Thank You. 

I have a all of the code using the proper `include(target)` due to the various research through the issues list. However, it wasn't readily apparent which direction was actually correct and I wanted a bit more feedback on what was the final decision.   In ES6 "of" gives you the value and "in" gives you the key.  Would adding `"body": "static-text"` in the `marko.json` fix that (similar to the [app-markdown](https://github.com/marko-js-samples/ui-components-playground/blob/master/src/components/app-markdown/marko-tag.json) sample component)?  
[![Coverage Status](https://coveralls.io/builds/9553643/badge)](https://coveralls.io/builds/9553643)

Coverage increased (+0.005%) to 88.435% when pulling **45c9d2e7cad4332b03ef885c80ba032d7adc1e37 on austinkelleher:514-deprecate-widget-types** into **a5ce5182b63b7614d5f4454e1502c3fdde7cffbc on marko-js:master**.
  ## Input tag is being filled with undefined value when the component's state change.

### Context
I found what I think is a bug. When I change the state of my component and there is an input in the template, Marko fills it with an undefined value even if I donâ€™t explicitly set the inputâ€™s value .


![image](https://cloud.githubusercontent.com/assets/5007653/21706817/dc09a5b2-d397-11e6-8df5-67627de085a7.png)

thatâ€™s my template markup

![image](https://cloud.githubusercontent.com/assets/5007653/21706827/f4a06b06-d397-11e6-8615-792ca4fbdb7e.png)

my componentâ€™s code

I am currently using `4.0.0-beta.5`

I updated to  `4.0.0-beta.8` and still getting that error

### Expected Behavior

Input's value shouldn't be set.

### Actual Behavior
Input's value is getting filled with an undefined value.

### Environment
* Version used: 4.0.0-beta.5 and 4.0.0-beta.8
* Environment: Chrome  55.0.2883.95 and node.js 7.3.0
* Operating System and version: macOS 10.12.2
  
[![Coverage Status](https://coveralls.io/builds/9540973/badge)](https://coveralls.io/builds/9540973)

Coverage increased (+0.001%) to 88.434% when pulling **42ba9e135d76965c2ffe49ccb543384816accdba on austinkelleher:421-deprecate-w-bind** into **6aaf8679a88e53cef644582e51edca94517a51e4 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9541118/badge)](https://coveralls.io/builds/9541118)

Coverage increased (+0.001%) to 88.434% when pulling **444550ee61753923dba844466c758f6b35d0fb52 on austinkelleher:421-deprecate-w-bind** into **6aaf8679a88e53cef644582e51edca94517a51e4 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9551413/badge)](https://coveralls.io/builds/9551413)

Coverage increased (+0.006%) to 88.436% when pulling **2e7d202cd5e8f61358c79f14ae1b1a4b865b7dd0 on austinkelleher:421-deprecate-w-bind** into **a5ce5182b63b7614d5f4454e1502c3fdde7cffbc on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9551413/badge)](https://coveralls.io/builds/9551413)

Coverage increased (+0.006%) to 88.436% when pulling **2e7d202cd5e8f61358c79f14ae1b1a4b865b7dd0 on austinkelleher:421-deprecate-w-bind** into **a5ce5182b63b7614d5f4454e1502c3fdde7cffbc on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9551413/badge)](https://coveralls.io/builds/9551413)

Coverage increased (+0.006%) to 88.436% when pulling **2e7d202cd5e8f61358c79f14ae1b1a4b865b7dd0 on austinkelleher:421-deprecate-w-bind** into **a5ce5182b63b7614d5f4454e1502c3fdde7cffbc on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9552196/badge)](https://coveralls.io/builds/9552196)

Coverage increased (+0.007%) to 88.437% when pulling **f091f35dddb0cbc524d4e46b4653c4c9231c3b8e on austinkelleher:421-deprecate-w-bind** into **a5ce5182b63b7614d5f4454e1502c3fdde7cffbc on marko-js:master**.
  ðŸ‘  ## Bug Report

### Context
<!--- Provide a more detailed introduction to the issue itself, and why you consider it to be a bug.  How has this bug affected you? What were you trying to accomplish? -->
Using latest marko 4 beta 8, I want to render a component that uses the await tag - purely in the browser. The component is built according to [http://markojs.com/try-online/#Async_Await](http://markojs.com/try-online/#Async_Await)

```JavaScript
var template = require('./template.marko');

module.exports = function(input, out) {
  template.render({
    userDataProvider: function(args, callback) {
      var backThen = Date.now();
      console.log('renderer.js:6 - starting...');
      setTimeout(function() {
        console.log('renderer.js:9 - done', Date.now() - backThen);
        callback(null, {
          firstName: 'John',
          lastName: 'Doe',
          age: 50
        });
      }, 2500);
    }
  }, out);
};
```

while being required by a simple index page that collects all the components (currently just one)

```JavaScript
var template = require('./index.marko');

template.render({}, function(err, result) {
  result.replaceChildrenOf(document.getElementById('root'));
});
```

which itself is injected via lasso `2.8.4` / lasso-cli `2.0.6` / lasso-marko `2.2.0` into a simple `index.html` file.

Checkout [https://github.com/Primajin/markojs-4-clientside](https://github.com/Primajin/markojs-4-clientside) as a reference.

### Expected Behavior
<!--- Tell us what should happen -->
Template should render asynchronously after 2,5 seconds.

### Actual Behavior
<!--- Tell us what happens instead -->
Tab / Browser uses 99% of CPU, can only be killed by taskmanager. Smells like an infinite loop.

### Possible Fix
<!--- Not obligatory, but suggest a fix or reason for the bug -->
instead of using `replaceChildrenOf` use `appendTo`

```JavaScript
var template = require('./index.marko');

template.render({}, function(err, result) {
  result.appendTo(document.getElementById('root'));
});
```

<details><summary>Additional Info</summary>

### Your Environment
<!-- Include as many relevant details about the environment you experienced the bug in -->
* Version used: 4.0.0-beta.8
* Environment name and version (e.g. Chrome 39, node.js 5.4): Chrome Version 57.0.2972.0 (Offizieller Build) **canary** (64-Bit)
* Operating System and version (desktop or mobile): Desktop MBP 10.12.2 (Sierra) 
* Link to your project: https://github.com/Primajin/markojs-4-clientside

### Steps to Reproduce
<!--- Provide a link to a live example, or an unambiguous set of steps to -->
<!--- reproduce this bug include code to reproduce, if relevant -->
1. Check out my project
2. `npm install`
3. switch lines 4 and 6 in `src/index.js`
4. `npm run build`
5. open `index.html` in your browser
</details>
 I think it's duplicate of  https://github.com/marko-js/marko/pull/505   <!----------------------
  |     IF BUG REPORT    |
  ---------------------->
## Bug Report

### Context
In node-require.js, right before the module.exports, `install()` is called. Consequently, default options are used.
* This causes an exception to be thrown on read-only systems since the default option in the compiler is to writeToDisk. 
* This also results in `install()` potentially being called twice.

### Expected Behavior
`require("marko/node-require").install({compilerOptions: {writeToDisk: false}})` should result in a single call to `install()`, with the options specified.

### Actual Behavior
`require("marko/node-require").install({compilerOptions: {writeToDisk: false}})` calls `install()` twice: Once from the base class (just before the `module.exports` line) with no options, and a second time with the options specified.

### Possible Fix
Remove `install();` on line 134 of node-require.js. Note: With this fix, `require("marko/node-require")` will no longer by default call `install()`.

<details><summary>Additional Info</summary>

### Your Environment
* Version used: 4.0.0-beta.8
* node.js version: v6.9.1
* Operating System: Windows 10 x64


</details>
 Related: #365  ../widgets/util - don't have  $__destroyWidgetForEl and $__destroyElRecursive functions

Fixed infinite loop in replaceChildrenOf function  main.marko
```
<include('../layouts/default.marko', data)>
	<@pagetitle></@pagetitle>
	<@body>
		<include ('./user.marko', data)/>
	</@body>
</include>
```
default.marko
```
<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8"/>
		<meta name="format-detection" content="telephone=no">
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1">
		<title>
			<if (data.pagetitle)><include (data.pagetitle)></include></if>
		</title>
		<link rel="stylesheet" href="/build/style/front.css">
	</head>
	<body>
		<include("../parts/sidebar.marko", data) />
		<if(data.body)>
			<main>
				<include(data.body) />
			</main>
		</if>
	</body>
</html>
```

with <!doctype html> in first line of template error has been happend
```
ERROR in ../api/views/front/layouts/default.marko
Module build failed: Error: Node does not have a `writeCode` method: {
    "type": "DocumentType"
}
    at CodeWriter.write (/var/www/node_modules/marko/compiler/CodeWriter.js:113:9)
    at writeNode (/var/www/node_modules/marko/compiler/CodeWriter.js:80:26)
    at Array.forEach (native)
    at CodeWriter.writeStatements (/var/www/node_modules/marko/compiler/CodeWriter.js:98:19)
    at CodeWriter.writeBlock (/var/www/node_modules/marko/compiler/CodeWriter.js:48:14)
    at FunctionDeclaration.writeCode (/var/www/node_modules/marko/compiler/ast/FunctionDeclaration.js:60:16)
    at CodeWriter.write (/var/www/node_modules/marko/compiler/CodeWriter.js:115:18)
    at writeNode (/var/www/node_modules/marko/compiler/CodeWriter.js:80:26)
    at Array.forEach (native)

    at CodeWriter.writeStatements (/var/www/node_modules/marko/compiler/CodeWriter.js:98:19)
    at Program.writeCode (/var/www/node_modules/marko/compiler/ast/Program.js:16:16)
    at CodeWriter.write (/var/www/node_modules/marko/compiler/CodeWriter.js:115:18)
    at CompiledTemplate.get code [as code] (/var/www/node_modules/marko/compiler/Compiler.js:99:20)
    at _compile (/var/www/node_modules/marko/compiler/index.js:90:24)
    at compile (/var/www/node_modules/marko/compiler/index.js:100:12)
    at Object.compileForBrowser (/var/www/node_modules/marko/compiler/index.js:111:12)
    at Object.module.exports (/var/www/node_modules/marko-loader/src/index.js:7:30)
 @ ../api/views/front/common/404.marko 2:23-58
```

without DOCTYPE it works.

Type of compile - vdom with compileFileForBrowser function. I can't think of any use-cases where this would really be necessary, but I also can't see much reason to throw an error. Browsers seem to silently remove the `<!DOCTYPE>` tag whenever it occurs somewhere it shouldn't, I feel like that's probably the best thing for Marko to do as well. I just tried to reuse server templates on client side. Thanks for the patch!  <!----------------------
  |     IF BUG REPORT    |
  ---------------------->
## Bug Report

### Context
```
<div id="cartShipSelList" class="prodDDList">
    <ul>
      <li for(opt in data.shipMethods) onMouseOver("handleHover") onMouseOut("handleRemHover")>Sample Text</li>
    </ul>
</div>
```

### Expected Behavior
Currently only one of them will work on it's own, they work when one is not included. You would expect to both be able to receive onMouseOver and onMouseOut events.

### Actual Behavior
Template will not compile with both as it errors at: 
```
marko_forEach(data.shipMethods, function(opt) {
    widget.e("mouseout", "handleRemHover", __widgetId1);
```

Stating that __widgetId1 is undefined


<!--- Provide a link to a live example, or an unambiguous set of steps to -->
<!--- reproduce this bug include code to reproduce, if relevant -->
1. 
2. 
3. 
4. 

### Stack Trace
index.marko.js:273 Uncaught ReferenceError: __widgetId1 is not defined
    at index.marko.js:273
    at forEachHelper (helpers.js:93)
    at render (index.marko.js:272)
    at renderer (renderer.js:273)
    at Template.renderSync (renderable.js:37)
    at displayWidget (tfv5.js:1382)
    at Object.<anonymous> (tfv5.js:1436)
    at i (jquery.min.js:2)
    at Object.fireWith [as resolveWith] (jquery.min.js:2)
    at z (jquery.min.js:4)
(anonymous) @ index.marko.js:273
forEachHelper @ helpers.js:93
render @ index.marko.js:272
renderer @ renderer.js:273
renderSync @ renderable.js:37
displayWidget @ tfv5.js:1382
(anonymous) @ tfv5.js:1436
i @ jquery.min.js:2
fireWith @ jquery.min.js:2
z @ jquery.min.js:4
(anonymous) @ jquery.min.js:4

</details>  
[![Coverage Status](https://coveralls.io/builds/9504769/badge)](https://coveralls.io/builds/9504769)

Coverage remained the same at 88.264% when pulling **e425290687ca050b3e0453dcc77a393f0273e0c6 on austinkelleher:no-update-data-attr** into **832cc6d328dcb750fc28f2c1d72c7c80ac863fcb on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9504856/badge)](https://coveralls.io/builds/9504856)

Coverage remained the same at 88.264% when pulling **e425290687ca050b3e0453dcc77a393f0273e0c6 on austinkelleher:no-update-data-attr** into **832cc6d328dcb750fc28f2c1d72c7c80ac863fcb on marko-js:master**.
  <!----------------------
  |     IF BUG REPORT    |
  ---------------------->
## Bug Report

### Context
Updating from version v3.13.0 to v3.14.0 adds lots of warnings about single hyphen for concise line being deprecated. I think such behaviour should occur on next major release as it requires a lot of code changes. Moreover, there is no clear documentation on how code should be changed as replacing `-` with `--` does not always make the warning disappear.

```
The usage of a single hyphen at the start of a concise line is now deprecated. Use "--" instead.
See: https://github.com/marko-js/htmljs-parser/issues/43
```

<details>

### Your Environment
<!-- Include as many relevant details about the environment you experienced the bug in -->
* Version used: v3.14.0
* Environment name and version: node.js 6.9

### Code sample producing warnings

This is valid v3.13 syntax
``` marko
<!DOCTYPE html>
html [lang="en"]
  body
    h1 - Title
    script
      - var a = 'marko';
```

If translated to either this styles it still outputs the warning (for line 6):

``` marko
<!DOCTYPE html>
html [lang="en"]
  body
    h1 -- Title
    script
      -- var a = 'marko';
```

``` marko
<!DOCTYPE html>
html [lang="en"]
  body
    h1 -- Title
    script
      ---
      var a = 'marko';
      ---
```

Only this style is not printing any warning: 

``` marko
<!DOCTYPE html>
html [lang="en"]
  body
    h1 -- Title
    script --
       var a = 'marko';
```

So will this last one be the only allowed style in the future?

</details>
 Thanks for the quick resolution. As wrapping code with `---` is still valid I don't think it will be a major pain. 
I just had an "oh dear, WTF" moment after updating Marko, as nothing was said in the changelog so I thought npm went crazy and messed up versions ðŸ˜‰   
[![Coverage Status](https://coveralls.io/builds/9489127/badge)](https://coveralls.io/builds/9489127)

Coverage remained the same at 88.032% when pulling **f13c75d7493cd109e5220a26fc4f9c6987e13cd2 on austinkelleher:495-import-colon** into **306e19b88e9e305c83b9da1b4eab3fa8e028ee8f on marko-js:master**.
  <!----------------------
  |     IF BUG REPORT    |
  ---------------------->
## Bug Report

### Context
Renaming destruction imports are not working in `v4.0-beta.5` :

```
<import { client: twilio } from '../../lib/twilio.js' />
```

results in compilation error, while

```
<script template-helpers>
  const { client: twilio } = require('../../lib/twilio.js');
</script>
```

works fine... Sorry, my fault, I forgot ES6 syntax while doing refactoring for `<import>` from `require`. Thank you!  
[![Coverage Status](https://coveralls.io/builds/9484750/badge)](https://coveralls.io/builds/9484750)

Coverage increased (+0.07%) to 88.105% when pulling **d67e55fda6aee9191639965ac82f6dacc7ee1ce5 on austinkelleher:422-deprecate-w-preserve-attrs** into **306e19b88e9e305c83b9da1b4eab3fa8e028ee8f on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9500522/badge)](https://coveralls.io/builds/9500522)

Coverage increased (+0.01%) to 88.242% when pulling **30575767240ca069d437f440986b9c6dcac48c92 on austinkelleher:422-deprecate-w-preserve-attrs** into **28392e985f7496aba23519c7e180e955628e595a on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9500607/badge)](https://coveralls.io/builds/9500607)

Coverage increased (+0.01%) to 88.241% when pulling **30575767240ca069d437f440986b9c6dcac48c92 on austinkelleher:422-deprecate-w-preserve-attrs** into **28392e985f7496aba23519c7e180e955628e595a on marko-js:master**.
  ## Bug Report

### Context

in dom.js exports.mixin

target[methodName] = function(referenceEl) is reached with referenceEl as a string

It then goes on to try to get the ownerDocument with referenceEl.ownerDocument which won't work on a string so doc is undefined.

it then goes through var newNode = getNode.call(this, doc); with an undefined doc but still creates the new dom element

then appendTo(newChild, referenceParentEl) is called and it appends the widget div to the referenceParentEl

it then goes into the following with the same undefined doc and emits a mount node event
if (afterInsert) {
    afterInsert.call(this, doc);
}

then emits a mount event

then entered initClientRendered(widgetDefs, doc) in init-widgets-browser.js with an undefined doc and tries to fix the undefined doc with window.doc which resolves undefined also

then initWidget(widgetDef, doc) with that undefined doc

then tries to get rootIds with var rootIds = widgetDef.roots; which returns undefined so it skips the next code block to go right to:
el = doc.getElementById(id);
el.__widget = widget;
els = [el];

this is where it errors due to doc being undefined

### Expected Behavior
getNode() should be called if the input is a string

### Actual Behavior
string is never converted to a dom reference so it continues to be treated as a string through following calls

### Possible Fix
call getNode() on initial input


### Your Environment
<!-- Include as many relevant details about the environment you experienced the bug in -->
* Version used:
* Environment name and version (e.g. Chrome 39, node.js 5.4):
* Operating System and version (desktop or mobile):
* Link to your project:

### Steps to Reproduce
<!--- Provide a link to a live example, or an unambiguous set of steps to -->
<!--- reproduce this bug include code to reproduce, if relevant -->
in a client side js file call the following (with the path changed to your widget)
1. var catProdWidget = require('src/components/cat-prod-widget');
2. catProdWidget.renderSync().appendTo('catProdList').getWidget();
3. 
4. 

### Stack Trace
<!-- If an error is thrown, provide the stack trace here -->
Uncaught TypeError: Cannot read property 'getElementById' of undefined
    at initWidget (http://localhost:3003/static/src/marko$4.0.0-beta.4/widgets/init-widgets-browser.js:117:17)
    at Object.initClientRendered (http://localhost:3003/static/src/marko$4.0.0-beta.4/widgets/init-widgets-browser.js:238:22)
    at WidgetsContext.initWidgets (http://localhost:3003/static/src/marko$4.0.0-beta.4/widgets/WidgetsContext.js:79:21)
    at EventEmitter.<anonymous> (http://localhost:3003/static/src/marko$4.0.0-beta.4/widgets/index-browser.js:80:28)
    at EventEmitter.emit (http://localhost:3003/static/src/events$1.1.1/events.js:81:17)
    at RenderResult.afterInsert (http://localhost:3003/static/src/marko$4.0.0-beta.4/runtime/RenderResult.js:69:16)
    at RenderResult.afterInsert (http://localhost:3003/static/src/marko$4.0.0-beta.4/runtime/RenderResult.js:110:14)
    at RenderResult.exports.mixin.Object.keys.forEach.target.(anonymous function) [as appendTo] (http://localhost:3003/static/src/marko$4.0.0-beta.4/runtime/dom.js:130:29)
    at loadAll (http://localhost:3003/static/src/Tree_Fort_Bikes_5_0$1.0.0/site/public/js/tfv5.js:2722:34)
    at HTMLDocument.<anonymous> (http://localhost:3003/static/src/Tree_Fort_Bikes_5_0$1.0.0/site/public/js/tfv5.js:2620:7)
</details>
  ## New Feature
Currently there is no easy way to use Marko for plain text parsing. 

### Description
Add non-renderable block to tell Marko to thread this block as text-only (still parsing variables and conditionals and such, just not forcing to transform html tags). 

### Context
The use case is for email rendering, where you probably want to render a html and text version. For example using [nodemailer ](https://github.com/nodemailer/nodemailer)> [node-email-templates](https://github.com/crocodilejs/node-email-templates) > [consolidate.js](https://github.com/tj/consolidate.js) will result in having problems to render the text version as marko will try to generate html tags out of the text sentences.

### Possible Implementation
#### Option 1)
e.g. see this proposal https://github.com/marko-js/marko/issues/343
```
<marko-parser body='static-text'>
        Content
         More Content
        ${data.myVar}
</marko-parser>
```
Important: In this example the output should not include the <marko-parser> tag

#### Option 2)
Javascript call has a new attribute to specify whether the template should be parsed as text-only or with html (transformations) Thanks for your quick response. Unfortunately i does not work. As soon as i'm using <static-text> in my template, the output is null (no error in console). I tried to move the components folder to different places, but nothing worked. Also i added a renderer.js or template.json but also... no luck. Maybe it has something to do how consolidate is calling Marko(`.load(options.filename, ContentAsStr, options`), although i would assume the actual folder lookup should not be affected by this. currently my workaround is to use

```
<div marko-preserve-whitespace>
         Content
         More Content
        ${data.myVar}
</div>
```

and then manually removing both divs from the output string. the latest from npm. 3.13.2 Perfect, now it works flawlessly. I guess the code-generator.js was the missing puzzle piece ;) Thx for the help and your (still very) quick response. Highly appreciated. And yes, it works for v3 too.   
[![Coverage Status](https://coveralls.io/builds/9452562/badge)](https://coveralls.io/builds/9452562)

Coverage increased (+0.004%) to 87.968% when pulling **405ff119b42b9eed4d88951beb932f3ef5531050 on austinkelleher:477-for-map** into **b0d77b8cb03535c42b88d4e10be14bb1a7b6f6f7 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9452562/badge)](https://coveralls.io/builds/9452562)

Coverage increased (+0.004%) to 87.968% when pulling **405ff119b42b9eed4d88951beb932f3ef5531050 on austinkelleher:477-for-map** into **b0d77b8cb03535c42b88d4e10be14bb1a7b6f6f7 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9452562/badge)](https://coveralls.io/builds/9452562)

Coverage increased (+0.004%) to 87.968% when pulling **405ff119b42b9eed4d88951beb932f3ef5531050 on austinkelleher:477-for-map** into **b0d77b8cb03535c42b88d4e10be14bb1a7b6f6f7 on marko-js:master**.
  <!----------------------------------------------------------------------
  |     IF FEATURE SUGGESTION (skip to next section for bug reports)    |
  ---------------------------------------------------------------------->
## New Feature

### Description
There are 2 use cases for this:
1. People who want to primarily use React but want to have some (perhaps presentational-only) components written in marko.
2. People who use primarily marko templates but want to use React (i.e. render React components) in some dynamic pages (this is marko-widget's use case, but let's say that a hype-driven tech lead wants React for dynamic stuff by all means necessary).

### Context
1. We need an easy-to-use template system as we have freelancers churning out new templates that come and go every once in a while. Here, marko seems like a good fit.
2. Static parts need to be easily integrated with non-React JS libraries like jQuery. Dynamic parts are written in React.
3. The team has invested quite a bit in the React ecosystem, so we are not keen on introducing something like marko-widgets.
4. We are concerned with the performance of server-side React rendering.

From reasons above, [react-templates](https://github.com/wix/react-templates) almost made it but not quite (mainly due to reasons 2 and 4).

After this, marko users can also tap into the larger React ecosystem for things like integration, off-the-shelf components.

### Possible Implementation
The 2 use cases boils down to these requirements:
1. Render React components in marko perhaps using taglib. (e.g. `<div><react-component prop1="a" prop2="b"/></div>`) This react root should be able to have isomorphic/universal rendering (meaning it can gain the ability to be re-rendered client-side, if the developer chooses to include react on client side).
2. Render marko components as React components. (e.g. in JSX: `<div><MarkoTemplate template={require("a/b.marko")} /></div>`) 

Both seems very doable to me, but would like some input on potential headaches.

1. This can (should?) be an optional module / custom taglib.
2. Each `<react-component/>` tag can live as a separate React root. Most SPAs only have one root that renders the whole page, but this usually won't be the case if rendering starts from marko. 

### Open Questions
1. Do we need to handle children tags inside templates (the content inside `MarkoTemplate`)?
2. Need to figure out how to use singleton store (redux etc) for multiple React roots.
3. Building SPAs will be difficult if we have multiple react roots in a page, but this may be a concern more for React and not for marko.

### Is this something you're interested in working on?
Yes
 I think the best solution long-term would be to have Marko have seamless interoperability with custom elements. That way, react / mithril / any library will be able to work without any extra work from marko.

For research, [server-components](https://github.com/pimterry/server-components) has done some work in this area. Thanks for the inputs. I believe v4 is just around the corner looking at the beta releases coming out these few days?

> It's possible to translate a rendered Marko VDOM tree to a React VDOM tree with a performance hit (via tree traversal of the Marko VDOM output)

This is what I pondered on as well - there is something similar for handlebars: https://github.com/stevenvachon/handlebars-react I don't know much about marko internals but maybe translating parsed AST to React VDOM directly can be a better approach?

> Alternatively, a Marko component can be rendered and mounted during the componentDidUpdate() lifecycle method (client-side only)

CMIIW, but I think if we render a new react root in `componentDidUpdate` the VDOM diffing would never work because it is a fresh re-render each time. This should be much simpler to implement though, as compared to VDOM translation.  ## New Feature

### Description
```
var str = __helpers.s,
      ...
      cv = '4.0.1-beta4'
```

### Context

Sometimes it's difficult to determine *which* compiler version output the *.js on disk (ie- command line compiler, marko-loader, etc).  This is a possible enhancement to aid in debugging, perhaps sometimes you need bug reports of "send me template.marko and template.marko.js" and it'd be nice to know *how* template.marko.js was transformed.

Drawback is an increase in filesize per template.marko.js, over a project w/ 50 templates, could be ~500 bytes, although very likely they would gzip well since all would be identical. (in addition, add `--version | -v` support to `markoc` command)  Currently:
```
  "devDependencies": {                                                          
    "marko": "^3.10.0"                                                          
  },                                                                            
```   
[![Coverage Status](https://coveralls.io/builds/9437515/badge)](https://coveralls.io/builds/9437515)

Coverage remained the same at 87.964% when pulling **39defaaf9ea434f3a3519d44ab2098f101ea844c on Hesulan:issue-484** into **291f67849215549e97f9bd7b52904d3bfa2403e0 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9437515/badge)](https://coveralls.io/builds/9437515)

Coverage remained the same at 87.964% when pulling **39defaaf9ea434f3a3519d44ab2098f101ea844c on Hesulan:issue-484** into **291f67849215549e97f9bd7b52904d3bfa2403e0 on marko-js:master**.
  The widget runtime uses a custom `.concat` method, but the native array `.concat` method returns a new array without modifying the original, which results in `window.$widgets` being an empty array and the init code being lost if the widgets are initialized before the runtime registers its custom method. 
[![Coverage Status](https://coveralls.io/builds/9397580/badge)](https://coveralls.io/builds/9397580)

Coverage remained the same at 87.934% when pulling **3eedac5e51170dcf95bd714058ff4ddb04c5ec14 on Hesulan:async-widget-bug** into **42fceecce5f10bd6c7e0ed38efe75f6bb8f54720 on marko-js:master**.
  Does this mean getRenderedWidgetIds will deprecate after 4.0? Which function can replace it then? Thanks.  <!--- Provide a general summary of your changes in the Title above -->

## Description
<!--- Describe your changes in detail -->
Minor update to documentation. Adding VSCode's syntax highlighter.

## Motivation and Context
<!--- Why is this change required? What problem does it solve? -->
<!--- If it fixes an open issue, please link to the issue here. -->

## Screenshots (if appropriate):

## Checklist:
<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->
<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
- [x] My code follows the code style of this project.
- [x] I have updated/added documentation affected by my changes.
- [x] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes.
- [x] All new and existing tests passed.
 
[![Coverage Status](https://coveralls.io/builds/9333532/badge)](https://coveralls.io/builds/9333532)

Coverage remained the same at 87.742% when pulling **ea1d74e27e360f5d4add14f718512abbcd9ee7fe on johnjv:vscode-ext** into **fae66bfb0692725edaf04025f80ff9109e52aa18 on marko-js:master**.
    <!----------------------
  |     IF BUG REPORT    |
  ---------------------->
## Bug Report

### Context
I am trying to use a dynamic expression to set an html tag. The compiled code seems to be slightly incorrect, resulting in mangled html.

My marko looks like (adding parenthesis here doesn't help):
```
<${data.type === 'primary' ? 'div' : 'span'}> 
```

### Expected Behavior
Compiled output should be
`out.w("<" + (data.type === "primary" ? "div" : "span") + ">");`

### Actual Behavior
Compiled output is:
`out.w("<" + data.type === "primary" ? "div" : "span" + ">");`

</details>
 @mlrawlings Thanks for the quick fix!  Hello,

Destructing `import` like followingÂ compiles correctly:

```html
<importÂ { readFileSync } from 'fs' />
```
results to following:
```javascript
   fs = require("fs"),
Â Â  readFileSync = fs.readFileSync,
```

However, destructing imports, like
```html
<import { asset } from '../../../shared/marko/asset' />
```

results in wrong compilation:
```javascript
asset = require("../../../shared/marko/asset"),
asset2 = asset.asset,
```

Side note: which version of Node Marko 4Â isÂ targeting? Why not current LTS (Node 6) and just keep destruction intact, as well as useÂ `const` instead of `var`?
 @tinovyatkin The compiler currently requires ES6 (Node 4+), but all built-in taglibs are currently designed to compile into ES5-compatible code (ES6+ tags *may* eventually be included if there's enough interest - see #428). This is so that templates can be rendered in all modern browsers without needing to be transpiled.

The `asset2` assignment is definitely an oversight, it's *supposed* to prevent automated naming collisions but in this case appears to be renaming the wrong one. As far I see Â `<import>` compiles into `require` and it's no way browser compatible with our without destruction. And it's new tag, so, I think it's quite fair to require `ES6` for new tags without loosing any backward compatibility
 Plenty of modern client-side code depends on a third-party library like `browserify` to implement CommonJS `require`, and Marko is no exception. In other words, `require()` most certainly *is* browser-compatible.

That being said, I do like the idea of native ES6+ tags, as long as they're opt-in and clearly marked - see #428, toward the end of the discussion. If anyone is interested, let me know and we can discuss the details. @Hesulan I'm sorry to say, but there is no logic to say `can be rendered in all modern browsers without needing to be transpiled` and then `require() most certainly is browser-compatible`. No, it's not.Â There is no browser on the planet that understand `require` without transpilationÂ / compilation / whatever you want to call it. So, the questionÂ still remain - why introduce new tag thatÂ have no way (apart of static inlining) to compile into ES5 and attempt to compile it into ES5 while you just may keep it as ES6 / node destruction? @tinovyatkin Marko and Marko Widgets run in the current versions of all major browsers without any transpiling. While `require()` certainly isn't native, it's considered a dependency, or at worst a polyfill. Native destructuring would require the entire file to be transpiled, and there's no reason to do that here since the current ES5 implementation already works perfectly aside from this bug.

Don't get me wrong, I'm certainly not against ES6+ features in the core taglibs; in fact, if you look at the PR I linked to, you'll see that I've personally been working on exactly that. But `<import>` is a *really* useful tag for all environments, and in this case the cost would far outweigh the gain. @scttdavs Another option might be to use one of the reserved template variable names ('data' or 'out') to temporarily store each module:
```js
var data = require("asset");
var asset = data.asset;
var data = ...
```
If someone needs to `<import { data as data } from 'asset' />` then they're probably doing something wrong, since it will get overwritten by `render(data, out)` anyway. If it's a vote, I certainly hope Marko developers will decide to just keep destruction intact and document that fact. It's a shame that nowadays development frameworks sometimes trying to pretend they are for people who don't know how to code. 
You are introducing new tag with `ES6 like imports`, requiring Node 4 for compiler and trying to reinvent the wheel of destruction?

Why not `<import { asset } from 'asset'>` => `const { asset } = require('asset')`?
What exactly is bad with this approach to a new, ES6-like tag? Marko is trying hard to make resulting `.marko.js` readable, and introducing namespaces, generated names, etc, no way helps that..
 It just occurred to me that `require()` is expected to cache loaded modules:
```
var foo = require('./foo').foo;
var bar = require('./foo').bar;
```
Not very pretty, but perhaps more readable, and definitely more collision-proof. Thoughts? @patrick-steele-idem Good point. I don't think execution speed would really be a problem since all of this is happening once when the module is first loaded, but minifying would be, especially with lasso since the url becomes a lot longer...

The `_module` suffix solution should work just fine, as long as it's well documented.   ```
    {
      "name": "test",
      "script": "./src/test",
      "instances": 1,
      "exec_mode": "cluster",
      "watch": true,
      "env": {
        "INTERVAL" : 60000,
        "HOST": "127.0.0.1",
        "PORT": 14211
      }
    },
```

i have error: `Error: Cannot find module 'marko'` @khmelevskii Works for me. Are you still having this problem? If so, could you give more details? I just experienced similar problems. Although my application runs under pm2, it does not render the HTML properly. For the record, I am requiring the module using `require('marko/node-require').install();`.

No problems when starting the application with `node app.js`, but with pm2, the HTML does not get rendered anymore. Google Chrome doesn't even render the HTML, but simply displays the raw HTML instead.

If you need, I could provide a more accurate description of what is happening, but please specify what kind of details you would want. @patrick-steele-idem Although the `Content-Type` header was not the issue, I can now confirm that my problems were separate from the issue discussed in the original ticket. My apologies for the inconvenience, however I can now confirm that pm2 does work with marko. I've been using pm2 successfully with both Marko v3 and Marko v4 (latest beta) without any problems. No problems here.  `include` or new `import` syntax within this `<style>` will be very good addition too! As well as an API for tag renderer to append anything to this, like `out.styles.append('.test-rule { color: red }')`   
[![Coverage Status](https://coveralls.io/builds/9053451/badge)](https://coveralls.io/builds/9053451)

Coverage increased (+0.03%) to 84.019% when pulling **99e7873d6c34d80aa754a46131cd3371322be776 on v3-render-to-string** into **91c215c054f011a148cd5d04b7fca2af28bd38ab on v3**.
  
[![Coverage Status](https://coveralls.io/builds/9013227/badge)](https://coveralls.io/builds/9013227)

Coverage increased (+0.03%) to 86.828% when pulling **eb140ab1119c217028a0d6f571bad4f6678e5ada on scttdavs:import-tag** into **41b115909066619032ae8d3e80c49432083b13c8 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9015917/badge)](https://coveralls.io/builds/9015917)

Coverage increased (+0.02%) to 86.822% when pulling **4633d841126e30a1b88f6a825983facf4e0a9f9f on scttdavs:import-tag** into **41b115909066619032ae8d3e80c49432083b13c8 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9016368/badge)](https://coveralls.io/builds/9016368)

Coverage increased (+0.05%) to 86.844% when pulling **66768de91ca07c801265898c493768230f9ac325 on scttdavs:import-tag** into **41b115909066619032ae8d3e80c49432083b13c8 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9016653/badge)](https://coveralls.io/builds/9016653)

Coverage increased (+0.02%) to 86.821% when pulling **dfe85613d42fe82b68b098f629da12b13ac00014 on scttdavs:import-tag** into **41b115909066619032ae8d3e80c49432083b13c8 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9016653/badge)](https://coveralls.io/builds/9016653)

Coverage increased (+0.02%) to 86.821% when pulling **dfe85613d42fe82b68b098f629da12b13ac00014 on scttdavs:import-tag** into **41b115909066619032ae8d3e80c49432083b13c8 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9051041/badge)](https://coveralls.io/builds/9051041)

Coverage increased (+0.02%) to 86.819% when pulling **db7fa47fa19e17dec0a836a7bf4efb65e60c9c33 on scttdavs:import-tag** into **41b115909066619032ae8d3e80c49432083b13c8 on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/9051041/badge)](https://coveralls.io/builds/9051041)

Coverage increased (+0.04%) to 86.84% when pulling **db7fa47fa19e17dec0a836a7bf4efb65e60c9c33 on scttdavs:import-tag** into **41b115909066619032ae8d3e80c49432083b13c8 on marko-js:master**.
  The autotest `compareHelper` now normalizes the ending newline of both the `expected` and `actual` strings to avoid test failures when `expected.*` is saved on a POSIX-compliant (non-Windows) OS. 
[![Coverage Status](https://coveralls.io/builds/8970748/badge)](https://coveralls.io/builds/8970748)

Coverage remained the same at 86.778% when pulling **aacab561eb2bea5436ea56df4b2615d9ea5cf238 on Hesulan:issue-446** into **aa254d165588aafb1605464dec8bd91e70991e3d on marko-js:master**.
  ### Description
The autotests work correctly when the `expected.*` file is created and saved on Windows. However, Linux and OS X comply with POSIX, which requires a proper ending newline (`\n` immediately followed by the `EOF` symbol). The produced `actual.*` file doesn't have one, which causes the autotests to fail.

### Possible Fix
The autotest runner could simply ignore the presence or absence of an ending newline. Alternatively, the rendered output could be made POSIX-compliant (by adding a proper EOF newline), but Windows displays it as a blank line and allows it to be removed which could lead to confusion.

### Steps to Reproduce
1. Open an `expected.*` file from the autotest directory in any text editor
2. Do one of the following:
  a. (Linux or OS X) Save the file with no changes
  b. (Windows) Insert a blank newline at the end of the file and save the changes
3. Run the test suite

### Example
Saving `test/autotests/render/assign-tag/actual.html` on Linux with no changes and running `npm test` produces:
```
AssertionError: 'HELLO 1230' deepEqual 'HELLO 1230\n'
```

### What does Git have to say about all of this?
Git expects there to be an ending newline (because there really *should* be), and has to internally add `"\ No newline at end of file"` as a workaround, shown by github as a red symbol on the last line - go look at the commit diff for almost any file written on Windows, you'll see what I mean.

### Workarounds
The only workaround I can find is to delete the last line and use `echo -n ... >>` to reinsert it without a trailing newline. I agree, and I feel like `/(\r\n|\n)$/` (or `/\r?\n$/`) would probably be safer. The only thing to keep in mind would be if something depends on there being a newline, but that could simply add two newlines (`\n\n`) and only the second one would be removed.  ## Description
Docs on how to create a container template using `<invoke data.renderBody(out) />`

## Motivation and Context
Useful for other users.

## Checklist:
- [x] My code follows the code style of this project.
- [ ] I have updated/added documentation affected by my changes.
- [x] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes.
- [x] All new and existing tests passed.
 
[![Coverage Status](https://coveralls.io/builds/8966592/badge)](https://coveralls.io/builds/8966592)

Coverage remained the same at 86.796% when pulling **9a5c2c33a47fa84c341eb2935f67388052c15eb7 on JeroenVdb:master** into **6a9a50402e00b746cbb07cfb6cfeacbd5c8279b9 on marko-js:master**.
  As discussed in #439, the `Promises/A+` specification explicitly defines `.then` as accepting at least two arguments: `onResolved` and `onRejected`. The `.catch` method is defined by ECMAScript for *native* implementations, but third-party libraries are under no obligation to include it (though *most* do, for convenience and compatibility).

In the interest of caution, this only calls `.then(undefined, onRejected)` if neither `.catch` nor `.fail` is a function. However, in my opinion, it would be completely safe to remove those two calls altogether, as any implementation which is even *remotely* compliant will handle this as expected. 
[![Coverage Status](https://coveralls.io/builds/8946857/badge)](https://coveralls.io/builds/8946857)

Coverage decreased (-0.02%) to 86.793% when pulling **96d93ee9fe7de57547cc979e8bd67955d00ae699 on Hesulan:issue-439** into **270ae3d17aba69ec2357fe187b7bf20fd16f11da on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/8950094/badge)](https://coveralls.io/builds/8950094)

Coverage decreased (-0.03%) to 86.778% when pulling **3f203366623733d8f5b1e17f82c94f8c2bdee52c on Hesulan:issue-439** into **270ae3d17aba69ec2357fe187b7bf20fd16f11da on marko-js:master**.
 
[![Coverage Status](https://coveralls.io/builds/8950094/badge)](https://coveralls.io/builds/8950094)

Coverage decreased (-0.03%) to 86.778% when pulling **3f203366623733d8f5b1e17f82c94f8c2bdee52c on Hesulan:issue-439** into **270ae3d17aba69ec2357fe187b7bf20fd16f11da on marko-js:master**.
  
[![Coverage Status](https://coveralls.io/builds/8937323/badge)](https://coveralls.io/builds/8937323)

Coverage decreased (-0.1%) to 86.697% when pulling **152717cbaac60dc0a19bb151dd3ae004a8a09ffa on render-api** into **270ae3d17aba69ec2357fe187b7bf20fd16f11da on master**.
 Doesn't this cause "finish" to return a new RenderResult, making the "self.on('finish', function(){ resolve(new RenderResult(out)); })" redundant?

Either way, looks great to me! I'll look a bit closer tomorrow just to be sure, but I believe this should work perfectly, at least concerning Promise compliance. (In other words, wouldn't "self.on('finish', resolve);" do the same thing? Or I might just have mis-read something.) Nevermind, was half asleep when I typed that, I did mis-read something. Just skimmed over the code again, it all looks good to me!  I finally got around to looking at the newly added `.then` method from #423 , and it turns out that it's nowhere near spec-compliant: attempting to call `.catch` causes an error to be thrown ("TypeError: fn is not a function", referring to the `undefined` passed as the first argument to `.then(fn, fnErr)`), the handlers are called synchronously, ~~and `.then` itself ceases to function properly once the stream is finished (subsequent calls return a Promise resolved with `undefined`).~~

~~There are only 3 possible solutions I can think of:~~
~~1. Let `.then` be non-compliant. It will only work if called *before* the stream is finished, among other things.~~
~~2. Attach a Promise instance to the stream regardless of whether `.then` is ever called or not. The renderer would then always require a native or polyfilled `Promise` implementation, even if `.then` is never actually used.~~
~~3. Write a partial `Promise` implementation directly into the renderer. I could do this if needed, but it would probably be better to simply require a native or polyfilled implementation.~~

EDIT: It seems I was mistaken about it ceasing to function after 'finish' is called, though it doesn't quite appear to function correctly in the first place.

EDIT 2: I'm actually getting all sorts of weird problems from this code and I'm not entirely sure what's causing most of them. In case someone else wants to take a stab at it, here's a spec-compliant solution, but it caused the test suite to throw an out-of-memory error when I tried it:
```js
then: function(fn, fnErr) {
    var self = this;
    return new Promise(function(resolve, reject) {
        self.on('error', reject);
        self.on('finish', resolve);
    }).then(fn, fnErr);
}
``` So I just now realized why that was throwing an error: The stream itself is being passed to 'finish', which is then passed to `resolve`, which attempts to call the stream's `.then` method, which leads to an infinite loop. It needs to instead pass the result string to `resolve`, but the test suite currently depends on the resolved value being the stream itself (which *definitely* violates the Promises/A+ spec, since the stream is a thenable).

In other words, the tests need to be rewritten. Then the above solution, with `self.on('finish', function(data){resolve(data.getOutput());});` instead of `self.on('finish', resolve);`, should work perfectly. (I'm *pretty* sure it's `data.getOutput()`, but double check that...)

I won't get the chance to do that tonight, or probably tomorrow either, so if anyone else would like to do the honors, be my guest. If not, I'll hopefully get to it this week. If the point is to get the stream itself when it's done rendering, then doesn't ".on('finish')" already pretty much do that?

Both in theory and practice, the point of Promises has always been to handle a single, immutable result (or error) the same way regardless of whether it is known yet or not. In this case, I feel that would be the resulting string. In other words, it seems to me that ".render().then()" should behave like ".renderSync()", but allowing for asynchronous values within the template. Either way, for a thenable to be passed to the first callback given to ".then()" explicitly defies the core of what a javascript "Promise" is. A separate non-thenable version of the stream like what you described would be the only acceptable way to do that. Hm. Somehow didn't notice that ".renderSync()" now returns a stream, too. In that case, this either needs to pass around a non-thenable version of the stream, or not be named ".then". What if we were to simply rename `.then`? The only real problem here (aside from the broken `.catch` method) is that we're passing an object (the stream) with a `.then` method to the `.then()` callback, which explicitly violates the specification. But if it were named something else, like `.promisify()`, `.and()`, or literally anything other than `.then()` or `.catch()`, then my example from "Edit 2" in the original post would work perfectly as-is. Fixed in #443. Thanks!  I'm not sure I understand. It sounds like you're saying this would cause "bar/marko.json" and "./other/marko.json" to behave as though they were directly written in the root "marko.json", correct? What would that affect? Bundling? Module loading? In other words, could you give an example use-case from the end user's perspective?

I can't see any reason not to implement this, I'm just a little unclear on the motivation to do so.
 Ah, makes sense. I would suggest either "include(s)" or "import(s)", the word "extends" doesn't sound quite right for what this would be doing.  While digging around in the compiler just now I noticed that some of the code is *not* Promises/A+ compliant, specifically the `<await>` tag. These are mostly edge-cases, and will *probably* never break anything, but here's what I found:

* The promise resolution procedure must only access the `.then` property once. So instead of `if (typeof promise.then === 'function') { promise.then(...); }` it should use `var then = promise.then; if (typeof then === 'function') { then.call(promise, ...); }`

* If attempting to retrieve the `.then` property throws an error, then the error must be caught and the resulting promise must be rejected with the error as the reason. (It currently isn't being caught.)

* The `.catch(onRejected)` method is neither defined nor required by the specification, it's simply a convenient alias for `.then(null, onRejected)` which *most* promise implementations *choose* to provide. 

Those are just the things I happened to remember, there are probably a few other technicalities that I've forgotten about since I last read through the spec. I'll try to work on this when I get the chance but until then I thought I should post this somewhere. I'll also keep an eye out for other places in the code that might handle Promises incorrectly and add them here.

Promises/A+ Specification: https://promisesaplus.com/ This also raises an interesting question: Should Marko actually be trying to handle Promise resolution directly, or would it be better to rely on a native/polyfilled `Promise` implementation? It looks like that's what #251 is currently doing.

If Marko is to handle "thenables" directly, then I would be in favor of adding a common helper utility for it - which would essentially be a built-in polyfill - so that each tag or feature which needs to handle Promise resolution won't end up re-implementing their own non-compliant handling code. I have enough experience writing spec-compliant thenables to do that, but I would much prefer letting a dedicated `Promise` implementation handle it.
 Quick update: Since #251 only applies when the user explicitly calls the `.then` method, it's considered a special case. The `<await>` tag, however, needs to be usable in pre-ES5 environments, which leaves either a built-in polyfill or just more compliant handling code as the only options.

However, I've also noticed one other issue: The `<await>` tag currently accepts either a value, a Promise, or a node-style function (last argument is an error-first callback). I'll continue working on this under the assumption that we want the `<await>` tag to continue to handle node-style functions, but be aware that this behavior defies the Promises/A+ specification. I'm basing these comments solely on the Promises/A+ specification, which defines the behavior and requirements of the ".then" method common to all implementations. ECMAScript defines the ".catch" method for native implementations, but libraries have no obligation whatsoever to include it. The second argument to ".then", however, *is* explicitly defined and must be supported by all implementations.

The ".then" only being accessed once is a subtle requirement, I wouldn't have even known about it if not for the 'promises-aplus-tests' package. To be honest, it probably won't ever affect anything.

Currently, if attempting to access ".then" throws an error, it is simply thrown. It should instead cause the resulting Promise to be rejected.

The Promises/A+ specification explicitly defines how to resolve an object *or function* - the "await" tag resolves functions in a non-compliant way. I believe the inconsistency is acceptable as long as users are aware of it, I just felt it was worth mentioning.

Ultimately, the changes I'm proposing would only really affect edge-cases, like weird (but still compliant) implementations that don't have a ".catch" method, or can't handle synchronously-thrown errors. I suppose most of those technicalities likely won't ever affect anything, so as long as the test cases are fairly thorough we should be fine. Though I do still suggest relying on the second argument to `.then`, as it's explicitly defined and used by every implementation that's even remotely compliant, while `.catch` is completely optional for third-party libraries.

The rest of it we can probably just leave as-is, as long as we acknowledge that it's not *technically* spec-compliant.  ### Open Questions
What version of the browser support ? @cheft 

None of the built-in tags currently generate anything above ES5. You can find a detailed compatibility table for all major browsers [here](https://kangax.github.io/compat-table/es5/).

The compiler currently requires at least partial ES6 support (Node.js 4+). If you're not already compiling your templates _before_ sending them to the browser, you really should.

The renderer runs in all modern browsers; if you need to support older browsers (like IE8), you will need to transpile the renderer and the compiled (".marko.js") templates with [Babel](https://babeljs.io/) before serving them to the client.
  I like this idea, and I believe I've found a simple way to implement it:

```
<await(result from promise)>
    <await-error if(process.env.NODE_ENV === 'development')>
        <script type="text/javascript">console.log("async tag failed!")</script>
    </await-error>
</await>
```

That works correctly with or without `client-reorder`. This is just a proof of concept, we would want to implement something like it directly in the renderer code and pass the actual error message through.
  Interesting, I like it! I'm still a little fuzzy on a few of the details, though I'm also reading this on my phone and half asleep... It's been a long day.

I especially like the @ syntax. `<@body></@body>` would be fine with me if getting the parser to accept `<@body></body>` is a lot of work.

It looks like the `<include>` tag combined with @ tags should be able to do everything the layout taglib does and more, if so then I'd have no problem with it being deprecated in favor of this once it's fully implemented.
 Would there ever be a situation where the target parent of the nested tag could be ambiguous? If not, then I can't see any reason not to deprecate the old syntax.
 In other words, are there any situations where "@error" could mean either "await:error" or "something-else:error"? I can't think of any, but it's worth asking.
 Hmm, that's a good question... what about a slightly different syntax for one of the two conditions? Nested tags that can be defined multiple times could use `<@tabs>`, while single-instance tags could use something like `<:tab>`, or vice-versa.
  ## Description

```js
var template = require('some.marko')
template.stream() // exception on line 234 of runtime/marko-runtime.js
```

## Motivation and Context

Fixes a runtime exception when streaming without providing a data context.

I would provide a test for this, but I can't find where it would go or any tests that resemble the case to emulate.

 [![Coverage Status](https://coveralls.io/builds/8859130/badge)](https://coveralls.io/builds/8859130)

Coverage remained the same at 83.969% when pulling **22e6ed2f94e615c0cada3ccb66258ab354e01234 on jsumners:empty-data** into **1c0c92eb360493c595e763e10305206ce5ed315f on marko-js:v3**.
 @austinkelleher thanks. I added the test.
 [![Coverage Status](https://coveralls.io/builds/8859285/badge)](https://coveralls.io/builds/8859285)

Coverage remained the same at 83.969% when pulling **ba73d974aabb46b1510fd0d1b12126b0444b6742 on jsumners:empty-data** into **1c0c92eb360493c595e763e10305206ce5ed315f on marko-js:v3**.
 @austinkelleher I wrote this against the v3 branch. It is a bug that is impacting my current usage of Marko.
 [![Coverage Status](https://coveralls.io/builds/8859934/badge)](https://coveralls.io/builds/8859934)

Coverage increased (+0.02%) to 83.985% when pulling **dd094254d0162914f5401a4d20f79643d157f075 on jsumners:empty-data** into **1c0c92eb360493c595e763e10305206ce5ed315f on marko-js:v3**.
 @mlrawlings thank you.
  [![Coverage Status](https://coveralls.io/builds/8839791/badge)](https://coveralls.io/builds/8839791)

Coverage increased (+0.6%) to 87.596% when pulling **63862a8b9204cfd8e146691920593ef6c85331d9 on charlieduong94:420-deprecate-w-on-attr** into **3eb3c286e8147448e58e623e2d294a09a75bbac4 on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/8839968/badge)](https://coveralls.io/builds/8839968)

Coverage decreased (-22.1%) to 64.874% when pulling **0716f90b2d9b1c3ace0f8976142583b8fe654b85 on charlieduong94:420-deprecate-w-on-attr** into **3eb3c286e8147448e58e623e2d294a09a75bbac4 on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/8840342/badge)](https://coveralls.io/builds/8840342)

Coverage decreased (-22.1%) to 64.874% when pulling **cfc1d8c001d14638d8f1d5b1135a51819d062513 on charlieduong94:420-deprecate-w-on-attr** into **3eb3c286e8147448e58e623e2d294a09a75bbac4 on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/8846126/badge)](https://coveralls.io/builds/8846126)

Coverage decreased (-0.4%) to 86.541% when pulling **e7ab99f66a5f92de53aef9bfedbf6f4d6a4f0bda on charlieduong94:420-deprecate-w-on-attr** into **3eb3c286e8147448e58e623e2d294a09a75bbac4 on marko-js:master**.
  [![Coverage Status](https://coveralls.io/builds/8834643/badge)](https://coveralls.io/builds/8834643)

Coverage decreased (-5.6%) to 81.331% when pulling **a19bac4cb30795292295726f90ff38cea3cb999c on austinkelleher:419-deprecate-w-preserve** into **c35bbf0b9d341211499fbe0eeca9f03d5a4691fd on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/8834744/badge)](https://coveralls.io/builds/8834744)

Coverage decreased (-18.2%) to 68.791% when pulling **a19bac4cb30795292295726f90ff38cea3cb999c on austinkelleher:419-deprecate-w-preserve** into **c35bbf0b9d341211499fbe0eeca9f03d5a4691fd on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/8835416/badge)](https://coveralls.io/builds/8835416)

Coverage decreased (-0.4%) to 86.535% when pulling **0dca32c8ba60b07e14cd47e019bf34dead0a0007 on austinkelleher:419-deprecate-w-preserve** into **c35bbf0b9d341211499fbe0eeca9f03d5a4691fd on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/8835416/badge)](https://coveralls.io/builds/8835416)

Coverage decreased (-5.6%) to 81.331% when pulling **0dca32c8ba60b07e14cd47e019bf34dead0a0007 on austinkelleher:419-deprecate-w-preserve** into **c35bbf0b9d341211499fbe0eeca9f03d5a4691fd on marko-js:master**.
  [![Coverage Status](https://coveralls.io/builds/8819913/badge)](https://coveralls.io/builds/8819913)

Coverage increased (+0.02%) to 72.134% when pulling **f192f486cca4145af4e4734e49b8ef5dc3f47775 on austinkelleher:410-await-reorderer-body-transform** into **3622cc4421458649980138950ec0fbf9ac5121dd on marko-js:master**.
  ## Pre-ES6 Support
How should Marko deal with ES6+ features in pre-ES6 environments?

### Definitions
"ES6+" refers to features and keywords introduced in ES2015 or later, and the environments which support them.

"pre-ES6" refers to environments which do *not* support features introduced in ES2015 or later, in which those features must either be transpiled or polyfilled before execution, or not used at all.

### Context
It is of course possible to use ES6+ features within user-written code, which simply gets copied into the compiled output in the case of a template or executed as-is in the case of a component or taglib. The burden then falls on the developer to know which features may or may not be used in their environment.

However, as discovered while working on #428, Marko's compiler is perfectly capable of generating ES6+ code, though it doesn't currently do so. The purpose of this issue is open a discussion on the possible ways of dealing with situations where a new enhancement or taglib wishes to make use of such features while rendering, which may not yet be supported in all environments, especially client-side.

### Possible Solutions
1. Automatically compile certain features and keywords differently based on a configuration option. This would require the most effort to implement and maintain.

2. Don't allow ES6+ to be generated by the Marko core. Any enhancement or taglib that wants to use newer language features *must* be a separate module.

3. Clearly mark all features and tags which require ES6+ support. The burden then falls once again on the end developer to know what they can or cannot use, or to run it through a transpiler before rendering.

4. Create an optional transpiler plugin. If a valid transpiler (like Babel) is passed to the compiler, then whenever an ES6+ feature is encountered it will be automatically fed through the transpiler's API. It could possibly even accept other transpilers like coffeescript or typescript. I would be willing to work on this when I find the time if others are interested.

Those are just the ideas I could think of, this is intended to start an open-ended discussion. Suggestions and constructive criticism are welcome! @patrick-steele-idem I was thinking more about long-term compatibility. I feel like `import`/`export` is just the tip of the iceburg. Aside from big things like that and `async`/`await`, the little things also start to look really tempting, like rest/spread operators, destructuring, argument defaults...

I guess a variation of my question might be something like "Where will the line be drawn on legacy support in the (near-ish) future, and what will be the recommended solutions"? The compiler already requires Node.js 4+ to run, though I believe none of the core components or tags currently _produce_ anything higher than ES5.

The idea of built-in support for running in ES3-only is ridiculous, but for the compiler to assume native ES7 `async`/`await` support would be equally laughable. Aside from the note about the compiler requiring Node 4+ I couldn't find anything that explicitly stated the lowest supported version, or detailed information on what is needed to make it work in legacy environments, but I feel that's something that needs to be addressed.
 At the moment I agree that it's pretty safe to stick with ES6 or lower for the compiler code, and the renderer doesn't use anything newer than ES5, or maybe even ES3 (unless of course the user writes ES6+ code). But things like that have a way of getting fuzzy fast, especially with constantly evolving standards like ECMAScript, Node, and the major browsers.
 I think what was really bothering me is that none of the documentation - at least that I can find - describes which features and ES versions are required by the various pieces of Marko, other than a side-note somewhere about the compiler using ES6 classes and a vague statement about the renderer being "supported in all web browsers" in the FAQ.

For example, a list like the following could be added to the documentation:
* The compiler requires and must be compatible with ES6/ES2015 (Node 4+)
* The runtime requires and must be compatible with ES5
* Built-in taglibs must generate ES5-compatible code
* Additions which use ES6+ features must only do so when called by the user (e.g. #423)

It would also be helpful to include information on how to transpile with Babel, and when that would be necessary, for new users who may not already know those things.  [![Coverage Status](https://coveralls.io/builds/8810198/badge)](https://coveralls.io/builds/8810198)

Coverage decreased (-0.01%) to 72.102% when pulling **375936a26feacf980e5312964ce7f65f4bae0875 on austinkelleher:426-deprecated-async-events** into **3622cc4421458649980138950ec0fbf9ac5121dd on marko-js:master**.
  ## Description
I simply copied `var-tag.js` and its `marko.json` entry to create `<let>` and `<const>` tags in `taglibs/core`.

## Motivation and Context
I was surprised to find that `context.builder.vars()` already had an optional second parameter for variable type ('var', 'let', or 'const'), but only `<var>` had been implemented as a tag.

This pull request is meant to be a starting point, but it could also be applied as-is. The commit is purely additive and no existing functionality should be affected.

## TODO
* Add automated tests
* Add documentation
* (optional) Throw compiler error on identifier re-declaration or on `const` re-assignment

## Additional Notes
Providing a body to a `<var>` tag causes it to compile into an IIFE to restrict its scope. Because the `<let>` and `<const>` tags simply re-use the same code they currently do the same, but they could be made to use a block statement (`{ ... }`) instead. Hmm... it seems the auto-tests are currently failing, I assume that's because I didn't write any. Unfortunately I'm not sure when I'll next get the chance to work on this. If anyone would like to take over from here, feel free to do so.
 [![Coverage Status](https://coveralls.io/builds/8803035/badge)](https://coveralls.io/builds/8803035)

Coverage decreased (-0.05%) to 85.073% when pulling **f5786f7c0dbf58fe90c3be4b5ae624de9a2bbf00 on Hesulan:let-const-tags** into **9a86d848f29b2b1780b1683d7c5903901238499c on marko-js:marko-v4**.
 [![Coverage Status](https://coveralls.io/builds/8803035/badge)](https://coveralls.io/builds/8803035)

Coverage decreased (-0.05%) to 85.073% when pulling **f5786f7c0dbf58fe90c3be4b5ae624de9a2bbf00 on Hesulan:let-const-tags** into **9a86d848f29b2b1780b1683d7c5903901238499c on marko-js:marko-v4**.
 I agree that the compiler should throw an error on re-initialization or const re-assignment, that's point number 3 in the TODO section of the pull request. It's getting compiled into actual `let` and `const` calls so it will eventually do that during render anyway, but it would be nice if it could do that at compile-time. But that's something that will need to be done deeper within the code, probably somewhere inside the `Vars` AST node; so far these commits have only touched the taglib code.

I'm not sure why I didn't think of this before, but it will also be necessary for the compiler to handle `let` and `const` differently in pre-ES6 environments, where the keywords either need to be transpiled, or require strict-mode (as two of the four travis-ci tests apparently do). In any case, it seems this isn't quite as simple as it appeared.

Assuming ES6 or higher, anyone can grab these commits to play with locally, it's worked perfectly for me so far. I might also get around to making this a separate taglib in the next day or two, at least until someone with more time on their hands (possibly my future self? I can only hope...) figures out how to make it not break things.
 So I've been mulling this over, and here are the solutions I can think of:
1. Pull these tags into a separate module. This would be fairly simple, I would just need to make a few minor changes and publish to npm.
2. Provide built-in support for compiling to `var` instead. This would be overkill, and I'm not even sure where to begin.
3. Add `'use strict';` to the top of the compiled output. This would make it work correctly in Node 4 and 5, but would also change the behavior of the entire template in very subtle ways, albeit mostly for edge cases.
4. Expect end users to know that they can't use these tags natively in pre-ES6 environments. We would also need to modify the integration tests to skip certain ones on Node 4 and 5.
5. Pull these tags into a new built-in taglib specifically made for support-breaking features (something like `es6-taglib`) which can then be enabled/disabled by a compiler flag (like `require('marko/compiler').defaultOptions.es6_tags = true`). This would be especially helpful in the case of client-side rendering, where templates might be rendered in a much lower environment version than the one they were compiled in, and developers shouldn't have to keep track of which tags support which versions. Any future tags which generate ES6+ code would also be placed here.

I'm sure there other options I haven't considered as well. Either way, I'd like to hear your thoughts!
 For me, the point of `const` and `let` is that they're clean, effective, _native_ solutions to specific problems. A separate taglib or module would provide a safe, "official" place for tags like these which are built around ES6+ features and concepts to be implemented without the risk of accidentally breaking compatibility; anyone who chooses to `require()` it knows what they're getting into. That being said, the addition of another taglib or module to maintain isn't something to propose lightly.

In any case, this certainly isn't urgent. Perhaps we could simply put this on the back-burner while we experiment with ideas for other ES6+ tags, and see how much interest there is from the community? In the meantime, I could easily port these to a separate module and publish it for everyone to play with.
 For anyone interested, I finally got around to publishing these as a standalone package: 

```
npm install --save marko-taglib-let-const
```

(Note: The `--save` part is necessary because marko only searches for taglibs listed as dependencies in your `package.json`.)
  [![Coverage Status](https://coveralls.io/builds/8801714/badge)](https://coveralls.io/builds/8801714)

Coverage decreased (-0.1%) to 71.953% when pulling **538196fc8a1dc9ecdcbea31714723dd8e544fec2 on charlieduong94:394-introduce-ref-and-for-ref-attributes** into **00b52ae5be30b9665bb289732adfd4bc985aa2e3 on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/8801798/badge)](https://coveralls.io/builds/8801798)

Coverage decreased (-0.1%) to 71.953% when pulling **4409cecb4bcb7a9ff1b642545eb1436c606cfe17 on charlieduong94:394-introduce-ref-and-for-ref-attributes** into **00b52ae5be30b9665bb289732adfd4bc985aa2e3 on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/8801850/badge)](https://coveralls.io/builds/8801850)

Coverage decreased (-0.1%) to 71.953% when pulling **e1940a7ff0d1d056c2800a1d20acf44a90b24275 on charlieduong94:394-introduce-ref-and-for-ref-attributes** into **00b52ae5be30b9665bb289732adfd4bc985aa2e3 on marko-js:master**.
  @patrick-steele-idem It seems that this currently coerces non-string values, such as `undefined`, `null`, and `{}`, into `<undefined></undefined>`, `<null></null>`, and `<[object Object]></[object Object]>`. Should it throw an error instead?  I'm more than a little hesitant about this... I do see how it could be useful, but considering what little would be gained (expression whitespace already works inside parenthesis, and is arguably easier to read most of the time) versus the potential costs (reserved operator names, inconsistent behavior, potential ambiguity, etc.), I feel this needs more discussion, especially since it would likely affect any future enhancements which deal with or depend on whitespace behavior.

Perhaps if this were to be opt-in, and only enabled by default on certain tags like `<var>` and `<assign>`? I would love to see something like that, and it would virtually eliminate the problems I mentioned (you can pretty much assume that anything on a `<var>` tag after the `=` is part of the value expression).
 I haven't peeked at the code yet, but if this could be a some sort of opt-in flag on the tag definition (or renderer, or AST node, or wherever it would fit best), then any other tags - possibly even user-made taglibs - could simply enable this "loose whitespace" support with relative ease without changing the expected behavior for anything else.
 I would much prefer a parsing mode switch based on the tag name, it seems like it would be much less messy and more reusable than having each tag manually stitch everything back together, or it might even be as simple as adding a couple of flags to the commit from the related PR. Is the parser able to read a config parameter from somewhere user-accessible, like the `marko.json` definition, or would the tag names which support this need to be hard-coded?
 I like the idea of the comma syntax being concise-specific. It already has more of a javascript-y vibe (actually python-y because of the significant indentation, but you get my point), while the standard syntax feels more like enhanced HTML, at least in my opinion. Also, my original concern was over allowing whitespace everywhere within value assignments without explicit boundaries; I can't think of any serious problems that allowing whitespace around the `=` might cause, aside from looking horrible when misused (`<tag foo = foo bar = bar baz = (baz + 1)/>`), but that can be said about almost anything.

As for only requiring commas sometimes, another possibility might be an all-or-nothing; if the tag contains values with whitespace, then there must be a comma between every attribute. As a side effect, that would also make it a bit easier to read, you would end up with either `tag foo=(1 + 2) bar=3 baz` or `tag foo = 1 + 2, bar=3, baz` instead of `tag foo = 1 + 2, bar=3 baz`.
 Requiring a semicolon at the end with the comma syntax would solve that first part, then it would be either:

```
tag baz = 3; - Hello World;  â†’  <tag baz = 3;>Hello World;</tag>
```

 or 

```
tag baz = 3 - Hello World;  â†’  <tag baz = 3 - Hello World;></tag>
```
 typed that on my phone and I think it messed up the formatting... hopefully you know what I meant
 When in *concise mode*, could a `;` (semicolon) simply end the current tag like `>` does in *HTML mode*?

For example:
```
nav.navbar; ul
    li for(link in data.links); a href=link.href - ${link.title}
```
Would be shorthand for:
```
nav.navbar
    ul
        li for(link in data.links)
            a href=link.href - ${link.title}
```
or
```
<nav.navbar><ul>
    <li for(link in data.links)><a href=link.href>${link.title}</a></li>
</ul></nav>
``` I agree with restricting this feature to concise syntax. The HTML-JS syntax is naturally more verbose, and with that verbosity you gain explicitness.

    <assign name=( lastName.toUpperCase() + ', ' + firstName.toLowerCase() ) />

This looks nice and readable to me. I have no desire to remove these parenthesis, just as I have no desire to remove general closing tags :)  [![Coverage Status](https://coveralls.io/builds/8784764/badge)](https://coveralls.io/builds/8784764)

Coverage increased (+0.03%) to 71.587% when pulling **0310d778a61fcc6931de8d39d9a97d6feb658751 on austinkelleher:251-render-promise** into **da11d73f52c2c1482124b8e189160f9a34ae1cf5 on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/8784838/badge)](https://coveralls.io/builds/8784838)

Coverage increased (+0.03%) to 71.587% when pulling **beb86527865b287e31137c50519d592db4d12ca7 on austinkelleher:251-render-promise** into **da11d73f52c2c1482124b8e189160f9a34ae1cf5 on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/8784974/badge)](https://coveralls.io/builds/8784974)

Coverage increased (+0.03%) to 71.494% when pulling **41fbe7a1d61614a05cecffc7260dc81458db3cd5 on austinkelleher:251-render-promise** into **abe0e2db2d32b729897905aba8fa17313a1f11e8 on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/8784974/badge)](https://coveralls.io/builds/8784974)

Coverage increased (+0.03%) to 71.494% when pulling **41fbe7a1d61614a05cecffc7260dc81458db3cd5 on austinkelleher:251-render-promise** into **abe0e2db2d32b729897905aba8fa17313a1f11e8 on marko-js:master**.
 The `Promises/A+` specification requires that a `Promise` instance must only ever handle the very first call to either `resolve` or `reject`, and ignore all further attempts at either. So as long as the correct one is called first it doesn't matter what happens after, the resolved/rejected `Promise` instance becomes immutable.
 That being said, do be aware that a fulfilled `Promise` exhibits _shallow_ immutability; the resolved/rejected value is effectively a `const` in that you cannot _replace_ it, but you can still modify the result's properties. And since calling `resolve` or `reject` doesn't cause the function to exit, it's entirely possible to accidentally mutate the result.
  Is there another way to achieve the same result? I can think of a few cases where it would be useful, though perhaps not strictly necessary, to be able to explicitly bind a widget file path. One example would be #514 - is there an alternative, or would that functionality no longer be possible? @patrick-steele-idem Ah, that does clarify. Thanks! Probably a good idea to mention those alternatives somewhere in the v3-v4 upgrade docs, and maybe a few examples to make refactoring easier. In marko@4.0.0-rc.17 it appears that in `onMount()`, `this.el` is the first element and `this.els` is all top-level elements (when there are multiple top-level elements).  [![Coverage Status](https://coveralls.io/builds/8752709/badge)](https://coveralls.io/builds/8752709)

Coverage decreased (-0.04%) to 71.423% when pulling **849c1193b9318ef91a3fde4b3498b6671b8594b1 on austinkelleher:387-handleFileModified-warning** into **a35e6bdbc3fe6e7f4e92fb377c435e29ab3d6e33 on marko-js:master**.
  The [language guide](https://github.com/marko-js/marko/blob/master/docs/language-guide.md) makes no reference to the `marko-body` attribute.  This attribute is necessary to keep Marko from interpreting inline scripts or inline CSS, but without being documented it's difficult to find this mechanism at all. > This means that the parser won't recognize HTML tags inside `<script>` and `<style>` tags since those tags do not contain HTML. Therefore, you should very rarely need to know about the `marko-body` attribute.

In our case we had `${` without a matching `}` (code that didn't intend to invoke Marko at all) and this caused an error.  I'd shudder to think what would've happened if it silently transformed something causing weird changes in behavior without any warning.  I mean it makes sense that maybe you want to `${JSON.stringify(foo)}` in the middle of a script tag, though it seems a bit dangerous to me that expressions are enabled in script tags by default.  I do understand the logic of keeping it consistent with other tags, however, and obviously it would be a breaking change, so I'm not suggesting that... just kind of musing.

Anyway, documenting `marko-body` would've at least made it easier to correct the problem when we figured out what it was.

I suppose the correct approach is just not to have inline JavaScript at all -- but sometimes that's nice for testing a quick template mock-up.
  [![Coverage Status](https://coveralls.io/builds/8744473/badge)](https://coveralls.io/builds/8744473)

Coverage increased (+0.03%) to 71.175% when pulling **1bb1c9ca0c1c386e52b66168daafcfe1b90bd2db on austinkelleher:407-node-require-extensions** into **36ef493526e47e4009ef7872b031c6918bfc1c3a on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/8744661/badge)](https://coveralls.io/builds/8744661)

Coverage increased (+0.04%) to 71.185% when pulling **ef71399d6acbaf302e08b2fc579b59a2469bf6c3 on austinkelleher:407-node-require-extensions** into **36ef493526e47e4009ef7872b031c6918bfc1c3a on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/8745008/badge)](https://coveralls.io/builds/8745008)

Coverage increased (+0.04%) to 71.191% when pulling **228ae8f0c7cda5660933b96713a43330c9abe47a on austinkelleher:407-node-require-extensions** into **36ef493526e47e4009ef7872b031c6918bfc1c3a on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/8745063/badge)](https://coveralls.io/builds/8745063)

Coverage increased (+0.04%) to 71.191% when pulling **228ae8f0c7cda5660933b96713a43330c9abe47a on austinkelleher:407-node-require-extensions** into **36ef493526e47e4009ef7872b031c6918bfc1c3a on marko-js:master**.
  [![Coverage Status](https://coveralls.io/builds/8699522/badge)](https://coveralls.io/builds/8699522)

Coverage remained the same at 71.14% when pulling **6ef6bb65fe6eaff0bf3ca82c7b79b49eb26a25cb on abiyasa:bug-on-nested-widget-id** into **21a43c010a75ca06857598f49ea3368b3e33c3c2 on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/8699522/badge)](https://coveralls.io/builds/8699522)

Coverage remained the same at 71.14% when pulling **6ef6bb65fe6eaff0bf3ca82c7b79b49eb26a25cb on abiyasa:bug-on-nested-widget-id** into **21a43c010a75ca06857598f49ea3368b3e33c3c2 on marko-js:master**.
  For the purpose of hoisting `require()` calls out of the `render` function, the new `<import>` tag *should* handle that (see: ECMAScript's top level requirement for `import` statements - though I haven't had the chance to look at the pull yet so I can't be sure if it actually does this). I know that's not the only use for `<script marko-init>`, but thought I should throw that out there.

Regarding `<render>` and `<init>`, why not both? `<init>` could simply be a drop-in replacement for `<script marko-init>`, while `<render>` would be optional, and if present would refactor the output in the way you described.

I get the feeling that the `<render>` tag might take a while to get working correctly, but `<init>` should be quick and easy to add (and looks much nicer and more easily recognizable than `<script marko-init>`, at least in my opinion).  When using `require('marko/hot-reload').handleFileModified`, if a not-resolvable template path is passed there will be no warning (or other notification)

A very minor quibble, but this was related to a somewhat elusive bug in my code.

Maybe just a warning, or change the existing output from:

```
[marko/hot-reload] File modified: /cant/resolve/this/path/to/index.marko
```
to something like:
```
[marko/hot-reload] ERROR! cannot resolve template path: /cant/resolve/this/path/to/index.marko
```  <!----------------------
  |     IF BUG REPORT    |
  ---------------------->
## Bug Report

Compiler throws an error on valid RegEx expressions in HTML5 `pattern` attribute for `input` elements.
### Context

Given following code example

``` html
<input type="text" pattern="\w{2,20}" />
```
### Expected Behavior

Compile normally, as it valid attribute value
### Actual Behavior

Throws Error
`'Invalid string ("\\w{1,30}"): SyntaxError: Unexpected token w in JSON at position 2'`

<details><summary>

Additional Info</summary>


### Your Environment

<!-- Include as many relevant details about the environment you experienced the bug in -->
- Version used: `"marko": "^4.0.0-beta.1"`
- Environment name and version: `node.js 7.0`
- Operating System and version (desktop or mobile): MacOS
### Stack Trace

<!-- If an error is thrown, provide the stack trace here -->

```
ERR! [10:40:05] [Marko] 1) [src/marko/vip-puj.marko:111:88] Invalid string ("\w{1,30}"): SyntaxError: Unexpected token w in JSON at position 2
ERR! [10:40:05] [Marko] 
ERR! [10:40:05] [Marko]     at handleErrors (/Users/tino/Sites/transfers.do/node_modules/marko/compiler/Compiler.js:72:21)
ERR! [10:40:05] [Marko]     at Compiler.compile (/Users/tino/Sites/transfers.do/node_modules/marko/compiler/Compiler.js:127:9)
ERR! [10:40:05] [Marko]     at _compile (/Users/tino/Sites/transfers.do/node_modules/marko/compiler/index.js:89:33)
ERR! [10:40:05] [Marko]     at doLoad (/Users/tino/Sites/transfers.do/node_modules/marko/runtime/loader/index.js:163:42)
ERR! [10:40:05] [Marko]     at compileMarkoFile (/Users/tino/Sites/transfers.do/tasks/marko.js:45:26)
ERR! [10:40:05] [Marko]   errors: 
ERR! [10:40:05] [Marko]    [ CompileError {
ERR! [10:40:05] [Marko]        context: [Object],
ERR! [10:40:05] [Marko]        node: undefined,
ERR! [10:40:05] [Marko]        message: 'Invalid string ("\\w{1,30}"): SyntaxError: Unexpected token w in JSON at position 2',
ERR! [10:40:05] [Marko]        code: 'INVALID_STRING',
ERR! [10:40:05] [Marko]        pos: [Object],
ERR! [10:40:05] [Marko]        endPos: [Object] } ] }
```

</details>
 I think accepting native RegEx as value will looks logical and very appropriate!
 Also, I'm not sure that this pattern attribute will work in same way in all browsers after escaping `\\`, but can't find related spec thought...
  It's obvious why the whitespace of `<pre>` tags is not removed, but why for `<script>` tags too? Normally, you minify javascript code too so I don't get why this is ignored by default. Is there any why to enable minification for the `<script>` tag globally? `require('marko/compiler').defaultOptions.preserveWhitespace = true` sadly only does this globally, but if I have a `<pre>` tag it's displaying incorrectly. Is there a way to do this programmatically instead of a .json config file?
  The page displays, all the js appears to load, but the onClick `handleThisClick` handler isn't firing (which should display a console log) and the c-nav.scss css isn't being applied (#c-nav). The base.scss style is working though (red).

(I'm using lasso-babel/lasso-sass)

my route:

```
    let template = require('src/marko/pages/sign_in/sign_in.marko');
    ctx.body = template.stream({
        press: 'press'
    });
```

src/marko/pages/sign_in/sign_in.marko:

```
<lasso-page package-path="./browser.json" />

<layout-use( "../../layouts/base/base.marko", data) show-header=false>
    <layout-put into="body">
        BODY CONTENT ${data.press}
        <c-nav(data) />

    </layout-put>
    <layout-put into="footer">FOOTER CONTENT</layout-put>
    </layout-use>
```

src/marko/pages/sign_in/browser.json:

```
{
    "dependencies": [
        "../../components/c-nav/browser.json"
    ]
}
```

src/marko/layouts/base/base.js:

```
console.log('base.js included');

import text from './text.js';
text();
```

src/marko/layouts/base/base.marko:

```
<!-- lasso -->
<lasso-page package-path="./browser.json" />
<!-- /lasso -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>
        <layout-placeholder name="title" />
    </title>
    <!-- lasso -->
    <lasso-head/>
    <!-- /lasso -->
</head>

<body>
    <div class="base">base.marko body below</div>

    <layout-placeholder name="body" />

    <!-- lasso -->
    <lasso-body/>
    <!-- /lasso -->
    <!-- marko widgets -->
    <init-widgets/>
    <!-- /marko widgets -->
</body>

</html>

```

src/marko/layouts/base/base.scss:

```
.base {
    width: 100px;
    height: 30px;
    background: red;
}
```

src/marko/layouts/base/browser.json:

```
{
    "dependencies": [
        "require-run: ./base",
        "./*.scss"
    ]
}
```

src/marko/layouts/base/text.js:

```
'use strict';
export default () => {
    console.log('test.js included');
};
```

src/marko/components/c-nav/browser.json:

```
{
    "dependencies": [
        "require: marko-widgets",
        "require: ./widget",
        "./*.scss"
    ]
}

```

src/marko/components/c-nav/c-nav.js:
`exports.render = require('./renderer').render;`

src/marko/components/c-nav/c-nav.marko:

```
<nav role="navigation" id="c-nav" w-bind="./widget">
    <ul class="main-navigation">
        <li>
            <a href="/">Home</a>
        </li>
        <li>
            <div w-onClick="handleThisClick">${data.press}</div>
        </li>
    </ul>
</nav>
```

src/marko/components/c-nav/c-nav.scss:

```
#c-nav {
    background: green;
    width: 100%;
    height: 40px;
}
```

src/marko/components/c-nav/renderer.js:

```
module.exports = require('marko-widgets').defineRenderer({
    template: require('./c-nav.marko'),

    getInitialProps: function (input, out) {
        console.log(input);
        return input;
    }
});
```

src/marko/components/c-nav/widget.js:

```
module.exports = require('marko-widgets').defineWidget({
    handleThisClick: function () {
        console.log('c-nav click');
    }
});

```

The console fires `base.js included` and `test.js included`.
 @patrick-steele-idem Hello! I actually found out what the issue is. It's possibly related to https://github.com/lasso-js/lasso-marko/issues/3.

I had to move the `pages/sign_in/browser.json` dependencies to the `layouts/base/browser.json`dependencies. Which is weird, since I am declaring the usage of the components in `pages/sign_in/sign_in.marko` and not in `layouts/base/base.marko`.
  ## Bug Report

Hot reload doesnt work in ExpressJS setup
### Your Environment

Win8.1 
Chrome
 Hi, the browser refresh only refreshes the browser page load.
I did manual refresh, and it doesnt work.
The file watch does work and the method handleFileModified(templatePath) is triggered, but nothing happens, even though there is console printout from that says 'file refreshed...' (or something). Also, there isnt new js file compiled/created either, even after setting write to file option as true.
 @sriver111 I happened to have this error 5 minutes ago, the console printout, is it the relative path or the absolute path. It needs to be the absolute path i.e. `/home/user/dev/yourproject/src/markofiles/component/app-mycomponent/template.marko` or on Windows `C:\yourproject\wherever-your-marko-template-files-are\template.marko`
 Hi Patrick, u are right. The path has to be absolute to work.
Thanks and cheers!
  Hi there!
This code doesn't work now. Before he worked fine.

```
let HomePage = require('./home.marko');
let response = {
    $global: {
        active: 'home',
        logged: logged,
        moment: moment,
    },
    currentPage: currentPage,
};
HomePage.stream(response).pipe(res);
```

I have a layout and his part(home.marko). I load a part of layout and give him the data for rendering, but nothing.

In a layout i tried to print data: `${out.global.active}`. What i doing wrong? Previously everything worked fine.
 @patrick-steele-idem Thanks a lot!
  Hello, marko neighbors! I use Express with Marko. Example:

```
template.render(data, res)
```

How do I handle rendering errors in this case? Thanks!
  `require('marko/compiler').taglibFinder.includeDir(dirPath);` 
would be nice feature
I have many directories inside my project folder that have `package.json` inside because i need them to have individual node_modules inside and for other reasons as well

now I cannot bubble to main project folder and make some components available across all directories

there is `taglibLookup.registerTaglib` but seems to work only in node environment :/ (in webpack doesn't seem to work)
  <!----------------------
  |     IF BUG REPORT    |
  ---------------------->
## Bug Report

I'm getting "maximum call stack exceeded". What am I doing wrong?
### Context

I'm trying to benchmark marko against our current favorite, handlebars, because I expect it'll be a lot faster. I'm running a matcha test, so I have the following code:

```
const handlebars = require('handlebars');
require('marko/node-require').install();
const fs = require('fs');

const data = // [snipped for brevity]

suite('Post template', () => {
//snipped Handlebars test 

    bench('marko', (next) => {
        const template = require('./post.marko');
        template.render(data, () => {
            //throw away the render output
            next();
        });
    }); 
```
### Expected Behavior

I should see benchmark results
### Actual Behavior

During the marko test, an error is thrown that aborts the suite

<details><summary>

Additional Info</summary>


### Your Environment

I'm using C9, running this using matcha for node.js
### Stack Trace

```
RangeError: Maximum call stack size exceeded
    at Array.join (native)
    at Object.posix.resolve (path.js:442:52)
    at Function.Module._resolveLookupPaths (module.js:249:17)
    at Function.Module._resolveFilename (module.js:316:31)
    at Function.Module._load (module.js:276:25)
    at Module.require (module.js:353:17)
    at require (internal/module.js:12:17)
    at /home/ubuntu/workspace/benchmarks/matcha-tests.js:35:20
    at iterate (/home/ubuntu/workspace/node_modules/matcha/lib/matcha/bench.js:178:5)
    at /home/ubuntu/workspace/node_modules/matcha/lib/matcha/bench.js:180:7
```

</details>
 Thanks, that worked great! Yeah, I got the idea from your benchmark set, but my group wanted to see how it performs with our templates. I figured it was simple enough to do.. until I hit this issue >.>

Thanks again!
  It seems to me that some of those tags might be simpler than others. Like you said, `<init-widgets/>` may not recognize widgets within an `<await>` tag (though I have a couple thoughts on how it might). Others, like `<browser-refresh/>`, could simply attach themselves to the compiler (or perhaps even the renderer) and append/prepend themselves unconditionally. Ordering and precedence shouldn't affect those much, but that's something we would still need to figure out eventually.

> Side note: I just noticed that the content of `<await(...) client-reorder>` ends up in `<head>` if it's the first document element; in other words, `<!DOCTYPE html><await(foo from Promise.resolve('foo')) client-reorder>${foo}</await>bar<await-reorderer/>` produces `<html><head>foo</head><body>bar</body></html>` instead of `<html><body>foobar</body></html>`. It's an uncommon edge-case, but something to be aware of if excluding the `<body>` tag, and possibly a bug in `<await-reorderer/>`.  <!--- Provide a general summary of your changes in the Title above -->
## Description

<!--- Describe your changes in detail -->

Updates old references of `htmlparser2` to `htmljs-parser`. Adjusted some of the wording in the overview doc to try and adapt the text to v3.
 [![Coverage Status](https://coveralls.io/builds/8271931/badge)](https://coveralls.io/builds/8271931)

Coverage remained the same at 83.972% when pulling **4e7c519f523a36045f5fbd14e64c0bec47453b78 on yomed:overview-docs** into **4646eef0389088df617dd87ac730186334f0efbf on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/8271931/badge)](https://coveralls.io/builds/8271931)

Coverage remained the same at 83.972% when pulling **4e7c519f523a36045f5fbd14e64c0bec47453b78 on yomed:overview-docs** into **4646eef0389088df617dd87ac730186334f0efbf on marko-js:master**.
  Hi guys!
This template engine is Awesome! Thanks for your hard work! :+1:  

**One question, exist any tuto to use with Express?**

Sorry for this bad issue, Nicholls
 Guys check an issue please!

![express](https://cloud.githubusercontent.com/assets/2154886/19223435/77eb70e4-8e35-11e6-8fe7-938e6225a373.png)

My Express route is:

```
var express = require('express');
var router = express.Router();
var template = require('../views/index.marko');

/* GET home page. */
router.get('/', function(req, res, next) {
  res.marko(template, { title: 'Express' });
});

module.exports = router;
```
 Hi Patrick, thanks for your quickly response my friend! ðŸ‘ 

Can I use your '**require('marko/node-require').install();**' line in **'./app.js'** or is required to use in every Express route? I'm using the **Express generator**.

Regards, Nicholls
 What do you think to add your example into **README** file? Maybe it's very useful for others!
  [![Coverage Status](https://coveralls.io/builds/8573081/badge)](https://coveralls.io/builds/8573081)

Coverage increased (+0.008%) to 83.969% when pulling **2b4116b9e01fc1c9129139ba2e6ba3b70262484f on await-error-events** into **d25c5ceedfc44859972980812cdd6b6d116f8818 on v3**.
  ## Description

Adds concise syntax example to README.md for applying rendering logic with separate tags.
## Motivation and Context

To make sure the concise syntax is really equivalent to the HTML template I ran this example. I think it makes sense to include it for other new users as another quick introduction to the Marko syntax and the alternative way of applying rendering logic. I would have found it helpful.
## Checklist:
- [x] My code follows the code style of this project.
- [x] I have updated/added documentation affected by my changes.
- [x] I have read the **CONTRIBUTING** document.
- [ ] I have added tests to cover my changes.
- [x] All new and existing tests passed.
 [![Coverage Status](https://coveralls.io/builds/8184714/badge)](https://coveralls.io/builds/8184714)

Coverage remained the same at 83.997% when pulling **995aaa3288b9e382d745c3632d294dff512cd483 on JonasHavers:master** into **cca2b0a452b23dcb79c1d80632c1fa59e3586705 on marko-js:master**.
  `while` was introduced in v3, but was missing from the docs. I copied this from the "what's new" page, and then modified it to the same format as the `for` loop documentation.
 [![Coverage Status](https://coveralls.io/builds/8143951/badge)](https://coveralls.io/builds/8143951)

Coverage remained the same at 83.997% when pulling **44d98f1490952cb8847696f9337f438d1835d603 on yomed:while-docs** into **a819ba3816dfeb21eb5acccd77cd0ec2fc470d8b on marko-js:master**.
  Sorry if this is answered somewhere (I couldn't find it), but can you do custom attributes without creating a custom tag? I'm curious if we can do something similar to what Angular has where you can create directives for attributes, not just tags.

As an example, lets say I wanted to provide an alternate "src" attribute (my-src) for the img tag so I could rewrite the URL before rendering. Is this possible? Or do I have to write a custom image tag and handle the src attribute that way? The docs weren't clear on this point. They mention custom tags AND attributes, but I only see examples for tags.

BTW, I'm currently using the component directory set-up, not a marko.json. 
 Thanks for the quick response, appreciate it. I'll have a look at the link you provided.
 Thanks, Patrick! I'll need to digest this a bit but it's much appreciated! I assume that you must use a marko.json to accomplish this, instead of the components directory?
  ## Bug Report
### Context

<!--- Provide a more detailed introduction to the issue itself, and why you consider it to be a bug.  How has this bug affected you? What were you trying to accomplish? -->

When Marko renders a template using `marko/express`, and there are no differences, it still sends the page over with a 200 HTTP status code.
### Expected Behavior

If no differences are detected, `marko/express` should send a 304 to avoid extra data being sent.
### Actual Behavior

Currently, no matter what, `marko/express` will send the template over with a 200 HTTP code.
### Possible Fix

Store an in memory hash of the previous render and check if it matches the current render; if they match send a 304 concluding nothing has changed.

<details><summary>

Additional Info</summary>


### Your Environment
- Version used: 3.9.4
- Environment name and version (e.g. Chrome 39, node.js 5.4): Chrome 52, node 6.3.1
- Operating System and version (desktop or mobile): Mac OS X 10.11.6
### Steps to Reproduce
1. Install Marko within an Express project.
2. Require `marko/express`
3. Use `res.marko` to compile a template and send it to a client
4. Look at the response status headers and see that Express is responding with a 200 HTTP code

</details>
 That is what I thought, but if I use pug (jade), templates will render, and if not changes are detected, express will emit a 304. With Marko, it will always send a 200, and force the client to download the entire page.
 Although you would have to store a lot of data in memory if you wanted the page controller to calculate it without a rendered template to cross check it with. One way or another the data needs to be verified, and I do agree with not wanting to waste CPU cycles if data hasn't changed.

Does anyone have any ideas that would be efficient? I'm thinking of generating hashes from the data here, but that seems like a waste of CPU cycles itself.
 Sadly I have not had any time to work on this feature as of yet.
  The current marko atom packages should use a more unique identifier in their package names.
When searching for "marko" in atom the packages appear in this order:
- language-marko (5th in list)
- autocomplete-marko (17th)
- hyperclick-marko (23rd)

This makes it difficult to find all available marko packages in a single search.
### Solution

Change the package name from `marko` to something like `markojs` or `marko-js` to make it easier to find all of the packages.

Thanks!
  How would that work with event handlers?

In [`react-templates`](https://github.com/wix/react-templates#event-handlers) for example you can assign events using the same properties React uses.
 What is the expected performance impact, if there is any at all?
  As services like https://zeit.co/now become more ubiquitous, and writing to disk in an app server becomes less kosher, this seems like a better option.

I'm having to manually load/pass-through my includes right now just so I can set writeToDisk to false, and having to set writeToDisk adds a bit more noise to my code.

My 2c. :)
 @patrick-steele-idem Do we have to compile `marko` files first in order to serve them dynamically?
 @patrick-steele-idem I see, thanks.
 @patrick-steele-idem I think I'm in favor of making `false` the default. The compiled output is extremely useful for the things you mentioned and many others, but 98% of the time it just wastes disk I/O (which is a very bad thing if you develop on cloud storage or flash drives - which I do).

On the other hand, it's extremely easy to *en*-able `writeToDisk` when you need to debug something (not as convenient as having the file already there, but still super easy), and anyone concerned with start-up time should really just pre-compile everything in their build step and never `require()` the compiler at all during production. FWIW the surprise appearance of the compiled template as a `.js` file can disrupt the typical file watching/rebuild patterns in dev environments by firing off a misleading file/directory change event. This is another thing that is easy to fix (set ignore rules), but... Indeed, in dev you probably don't even want compilation caching to happen at all (requiring even more little fixes), and you'll have to add `marko.js` files to your `.gitignore` sooner rather than later...

Easy fixes, but now a little pile of them :)

All that said, Marko is awesome and I think helping new users to avoid these surprises can only be a good thing.
 @mlrawlings I completely agree that the `*.marko.js` files are essential for debugging, but in my opinion it's already easy enough to generate them when desired with `./node_modules/.bin/markoc ./path/to/template.marko`, or even `require('marko/compiler').defaultOptions.writeToDisk = true;` for those who don't need to worry about unnecessary disk writes.

Writing out on error may be more convenient, but it would also result in files sometimes appearing with little or no explanation and littering the project folders, which could confuse new users even more.

I would be very interested in source maps, though I vaguely remember seeing discussion in an issue somewhere about them being too difficult to implement. @mlrawlings I really like the idea of using an environment variable, especially since the output files are only really used for production and debugging, and anyone worried about production start-up time should probably be compiling during a build step instead.

And I'd love to see the compiler keep better track of where the code came from. That might also help with things like #247. The environment variable might have too great an effect. My personal primary use case is inspecting the generated file of only the template I'm working with. The environment variable feature would generate *all* files in the project, wouldn't it? @mindeavor I'm thinking the environment variable would probably just switch `writeToDisk` on, which is currently Marko's default behavior.

If you need to compile only a specific template, you can either execute 
```sh
./node_modules/.bin/markoc ./path/to/template.marko
```
in a shell, or toggle `writeToDisk` on while loading that template for the first time:
```js
require('marko/compiler').defaultOptions.writeToDisk = true;
var template = require('./path/to/template.marko');
require('marko/compiler').defaultOptions.writeToDisk = false;
```

I'm not aware of any hooks or methods in the API to write a specific template to disk, but that's probably worth considering even if the default value of `writeToDisk` doesn't change. Something like `Template.prototype.writeToDisk()`, perhaps? I might look into implementing that sometime if I get the chance. I see. Personally I think it'd be great if you could add something to the code like:

```js
<script>
module.exports = {
  debug: true,
  onInput(attrs) {
    // ...
  }
}
</script>
```

where `debug` can be `true` or, if need be, an options object like `{ writeToDisk: true }`. I would find that to be really handy :) @patrick-steele-idem That's exactly what I was just thinking. Perhaps this would be a good first use case for the `<debug>` tag that was being discussed not too long ago, like `<debug write-to-disk=true />`? Yes, now that you mention it, a tag would be better. That way you can debug whether or not you have a `<script>` tag.  <!----------------------------------------------------------------------
  |     IF FEATURE SUGGESTION (skip to next section for bug reports)    |
  ---------------------------------------------------------------------->
## Custom root path for views
### Description

Sometimes, we want to use `require('marko/node-require').install(options)` to the third-part package.

But it will set the views dir to package's dir. so should need an option to set root path.
 ## example

https://github.com/trekjs/views/blob/master/packages/marko/index.js

``` js
/**
 * Install marko
 *
 * @param {Object} options
 */

function install (options) {
  require('marko/node-require').install(options)
}

/**
 * Stream render view
 *
 * @param {String} view
 * @param {Object} state
 * @return {Stream}
 */

function render (view, state) {
  return require(view).stream(state)
}

module.exports = {

  install,

  render

}
```

https://github.com/trekjs/examples/blob/next/template-marko/app.js

``` js
const path = require('path')

const Engine = require('trek-engine')

const marko = require('trek-view-marko')

marko.install()

const app = new Engine()

app.use(({ res }) => {
  res.send(200, marko.render(path.join(__dirname, './index.marko'), { name: 'Trek Engine' }))
})

app.run(3000)
```
 > Maybe something along the lines of this.

Nice work. Thanks.

> However, I would recommend having your render function take the loaded template as a parameter:

If we have many templates (> 15 pages) that not good way.
  ## Hot reload of .marko.xml not implemented
### Context

Support for XML templates in _.marko.xml_ files have some (quite good) support in runtime and tools but hot reloading remains unsupported.
### Possible Fix

Currently, the code in https://github.com/marko-js/marko/blob/master/hot-reload/index.js#L136 looks like 

```
if (path.endsWith('.marko') || path.endsWith('.marko.html')) {
            // Uncache just the modified template
            delete require.cache[path];
            delete require.cache[path + '.js'];
        }
```

A fix could be 

```
if (path.endsWith('.marko') || path.endsWith('.marko.html') || path.endsWith('.marko.xml')) {
```
 This is a though problem since we are restricted to what `require()` CAN do and not what we WANT to do.

Personally, I favor composite extensions such as `.marko.html` and `.marko.xml` since they essientially still are html and xml and thus wont break my tooling (lint, syntax hl etc).
`require()` on the other hand has no sympathy for composites and will treat `.marko.xml` as any `.xml`.

Some observations:
- a replacement api for `require('./some.marko')` isnt feasible, since `require()` is the only viable api that has the much needed implicit dependency to the module variable `__dirname` required for resolving the full path.
- hot reloading in marko is actually more of a _hot unloading_ (https://github.com/nodejs/node/blob/ebc8c37f70a84a64851b440493f3441eb9f70fdb/lib/module.js#L436)

So, a possible solution to this is to alter the semantics of install.

Consider

```
install({
    extension: '.marko.xml'
})
```
- Make the implementation of `require('marko/hot-reload').handleFileModified(<path>)` aware of the full extension, `.marko.xml`.
- Alter the `require.extensions` mapping using the effective extension, in this case `.xml` (https://github.com/marko-js/marko/blob/master/node-require.js#L76)

My guess is that this is an addition rather than a breaking change since composite extensions currently has no effect (at least not the intended) on `install()`.

Unfortunately, I have little time for this at the moment, mainly since I work full hours in windows environments which doesnt support symlinks used in the tests.

@patrick-steele-idem , let me come back on this, perhaps I dust of my old McBookPro in the weekend...
  I want a package, just dependent on marko and not modify it.
Is it ok under MIT for package?
 Thanks.
So, It's ok under MIT.
 Cool! Thank you! ðŸ»
  Safari is waiting the completion of the first await tag

When i try to render async fragment (await tag)

**In Chrome without client-reorder**
1. Outer html rendered
2. First await tags rendered
3. Second await tag rendered
_With client-order same except order of await tags like expected._

**In Safari without client-reorder**
1. Not render outer html until all await tags done
2. All html rendered together

**In Safari with client-reorder**
1. Safari is waiting until first await tag done
2. Outer html and first await tag rendered
3. Second await tag rendered
 Hi @patrick-steele-idem my safari version is 9.1.2 (11601.7.7) on OSX El Capitan and same issue on https://github.com/llambda/koa-boiler.
 I found solution! it was happen because i run server under browser-sync proxy.
  I'd like to start by saying awesome concept, finally a library which puts performance first.

Now, I've just come from an AngularJS/Gulp development background so I'm new to the whole JavaScript bundlers concept.

I'm trying to wrap my head around how the recommended file structure should look like on bigger projects. I've been downloading and testing out the samples (awesome) but I haven't been able to stitch them together. I also had a hard time understanding how client side rendering with marko works, server side wasn't too hard to figure out, coming from Handlebars it really wasn't that much different.

Tbh I think explaining from scratch for beginners who have just come from i.e. jQuery how marko works will draw _a lot_ more attention to it.

After looking at the following repos I've sot of come up with the following file structure.

```
/project/src/client.js    <---    
https://github.com/marko-js-samples/marko-widgets-client-rendering
/project
/project/build    <---    what is this directory for?
/project/node_modules    <---    no brainer, npm modules
/project/src    <---    dev files
/project/src/marko.json    <---    Haven't understood this file yet
/project/src/client.js    <---    Haven't understood why this file is here?
/project/src/common    <---    I'm guessing this is for files that all pages or components share
/project/src/common/browser.json    <---    lasso needs this to compile correctly (code splitting etc.)
/project/src/common/common.css    <---    css styles when a page/component includes the "common" package? (overrides?)
/project/src/common/common.js    <---    same as .css but with JS
/project/src/componenets    <---    Holds marko-widget reuseable componenets
/project/src/componenets/my-widget    <---    Is a marko-widget reuseable componenet
/project/src/componenets/my-widget/index.js    <---    [What does this do and what should be in it?](http://markojs.com/docs/marko-widgets/get-started/#split-renderer-and-widget-1)
/project/src/componenets/my-widget/renderer.js    <---    [What does this do and what should be in it?](http://markojs.com/docs/marko-widgets/get-started/#split-renderer-and-widget-1)
/project/src/componenets/my-widget/widget.js    <---    [What does this do and what should be in it?](http://markojs.com/docs/marko-widgets/get-started/#split-renderer-and-widget-1)
/project/src/componenets/my-widget/style.css    <---    Holds the style for the component (overrides?)
/project/src/componenets/my-widget/template.marko    <---    Holds the html markup for the component
/project/src/pages    <---    Holds marko template pages
/project/src/pages/home    <---    Holds the home marko template page
/project/src/pages/home/browser.json    <---    lasso needs this to compile correctly (code splitting etc.)
/project/src/pages/home/client.js    <---    Whats the difference between this and index.js?
/project/src/pages/home/index.js    <---    Whats the difference between this and client.js?
/project/src/pages/home/style.css    <---    Holds the style for the component (overrides?)
/project/src/pages/home/template.marko    <---    Holds the html markup for the page
/project/src/pages/home/template.marko.js    <---    auto-generated
/project/static    <---    This is the directory which should be served publicly (lasso bundles end up here)
/project/.cache    <---    Used by lasso for quicker bundling?
```

I am also wondering how does one create a template which nests another template? I would like to pass data as well.

Also tags vs. widgets?

I think being able to explain this structure well for newcomers will increase their chance of using marko. Personally I would like to see an example project which touches all areas so I can see how they could be fit together, right now I'm shooting in the dark!

As stated before client marko rendering (both non widget and widget) is still unclear to me. I tried bundling with webpack etc. however it wasn't until I looked at lasso I realised that lasso is actually needed. I think this should be more clear in the marko & marko-widgets documentation when talking about client side rendering.

Also thumbs up to upgrading to ES6 syntax (import/export). I want to completely stop writing CommonJS and starting writing just offical JS.

I probably have more questions, will take them later! :)
 Thanks for this information. But I still have a doubt. All content that are inside `src` folder, is focussed only in the modularization of client side, right? 
 @mlrawlings Brilliant example! I have another question. I've been reading and haven't found an answer to it yet. The code below you pass item.name to the tempalte. Is it possible to pass a JSON object instead?

```
<ul for(item in data.items)>
    <include('./item.marko') name=item.name />
</ul>
```
 I am having too many components in on folder  /project/src/componenets .
Whats the way of grouping components pages wise ?  http://markojs.com/docs/marko/koa/

```
require('marko/node-require').install();

var koa = require('koa');

var app = koa();

app.use(function *() {
    this.body = template.stream({
            name: 'Frank',
            count: 30,
            colors: ['red', 'green', 'blue']
        });
});

app.listen(8080);
```

However it states at http://markojs.com/docs/marko/javascript-api/#streamtemplatepath-templatedata--streamreadable

```
stream(templatePath, templateData) : stream.Readable
Deprecated. Do not use.
```

So, use stream or not? Feels like you guys should have one place for information on usage. This is confusing!
 Apologize.

http://markojs.com/docs/marko/javascript-api/#streamtemplatedata--streamreadable

Was looking at the wrong method!
  [![Coverage Status](https://coveralls.io/builds/7528756/badge)](https://coveralls.io/builds/7528756)

Coverage increased (+0.04%) to 84.316% when pulling **bd488be54823b88eaa736fd25da3fec0a9ac0a2b on issue-357** into **78a73e573e60b7d076ca51d4cc94c0b85a0150fd on master**.
  Is it possible to see a workaround for this outside of 

``` js
<script marko-init>
var empty = require('marko/helpers/empty');
var notEmpty = require('marko/helpers/notEmpty');
</script>
```

I'm using:

```
<if(data.commits && data.commits.length)>
  ...
</if>
```
   [![Coverage Status](https://coveralls.io/builds/7345040/badge)](https://coveralls.io/builds/7345040)

Coverage remained the same at 84.163% when pulling **7a53328bf02c0668ba42558a500fd2c3f868a2b9 on sdepold:patch-1** into **8017e1485d0c4f1110fe2cb089760e19fa8f0dd2 on marko-js:master**.
  [![Coverage Status](https://coveralls.io/builds/7328873/badge)](https://coveralls.io/builds/7328873)

Coverage decreased (-0.01%) to 84.163% when pulling **b1b59be5cbd62fba678b799f08f8b4adffbfefd3 on attr-empty-string** into **8382d4ce02f740c73ac6f0e9057654ace3a32719 on master**.
  Not sure if this is a problem with released artifact or not
 Seems to only affect marko even on version 3.8.1

```
robinanil 17:32:16 :~/work/admin/consumer$ npm uninstall marko
- app-module-path@1.1.0 node_modules/app-module-path
- async-writer@1.4.2 node_modules/async-writer
- browser-refresh-client@1.1.4 node_modules/browser-refresh-client
- char-props@0.1.5 node_modules/char-props
- htmljs-parser@1.5.13 node_modules/htmljs-parser
- object-assign@4.1.0 node_modules/marko/node_modules/object-assign
- property-handlers@1.1.1 node_modules/property-handlers
- raptor-args@1.0.3 node_modules/raptor-args
- raptor-async@1.1.3 node_modules/raptor-async
- lasso-caching-fs@1.0.1 node_modules/lasso-caching-fs
- lasso-package-root@1.0.0 node_modules/lasso-package-root
- raptor-polyfill@1.0.2 node_modules/raptor-polyfill
- deresolve@1.1.1 node_modules/deresolve
- raptor-regexp@1.0.1 node_modules/raptor-regexp
- raptor-stacktraces@1.0.1 node_modules/raptor-stacktraces
- raptor-logging@1.1.2 node_modules/raptor-logging
- raptor-strings@1.0.2 node_modules/raptor-strings
- raptor-json@1.1.0 node_modules/raptor-json
- raptor-util@1.0.10 node_modules/raptor-util
- raptor-promises@1.0.3 node_modules/raptor-promises
- strip-json-comments@2.0.1 node_modules/strip-json-comments
- try-require@1.2.1 node_modules/try-require
- marko@3.8.1 node_modules/marko
robinanil 17:33:11 :~/work/admin/consumer$ npm install 
consumer@1.0.0 /Users/robinanil/work/admin/consumer
â””â”€â”¬ marko@3.8.1 
  â”œâ”€â”€ app-module-path@1.1.0 
  â”œâ”€â”€ async-writer@1.4.2 
  â”œâ”€â”€ browser-refresh-client@1.1.4 
  â”œâ”€â”€ char-props@0.1.5 
  â”œâ”€â”€ deresolve@1.1.1 
  â”œâ”€â”€ htmljs-parser@1.5.13 
  â”œâ”€â”¬ lasso-package-root@1.0.0 
  â”‚ â””â”€â”€ lasso-caching-fs@1.0.1 
  â”œâ”€â”€ object-assign@4.1.0 
  â”œâ”€â”€ property-handlers@1.1.1 
  â”œâ”€â”€ raptor-args@1.0.3 
  â”œâ”€â”€ raptor-async@1.1.3 
  â”œâ”€â”€ raptor-json@1.1.0 
  â”œâ”€â”¬ raptor-logging@1.1.2 
  â”‚ â””â”€â”€ raptor-stacktraces@1.0.1 
  â”œâ”€â”€ raptor-polyfill@1.0.2 
  â”œâ”€â”€ raptor-promises@1.0.3 
  â”œâ”€â”€ raptor-regexp@1.0.1 
  â”œâ”€â”€ raptor-strings@1.0.2 
  â”œâ”€â”€ raptor-util@1.0.10 
  â”œâ”€â”€ strip-json-comments@2.0.1 
  â””â”€â”€ try-require@1.2.1 

robinanil 17:33:36 :~/work/admin/consumer$ ls node_modules/marko/runtime/
deprecateHyphens.js helpers.js          loader.js           loader.js.orig      loader_browser.js   marko-runtime.js    package.json
robinanil 17:34:06 :~/work/admin/consumer$ 
```
 3.6.1 does not have this issue

```
robinanil 17:35:52 :~/work/admin/consumer$ npm install
npm WARN deprecated minimatch@0.2.14: Please update to minimatch 3.0.2 or higher to avoid a RegExp DoS issue
consumer@1.0.0 /Users/robinanil/work/admin/consumer
â””â”€â”¬ marko@3.6.1 
  â””â”€â”¬ minimatch@0.2.14 
    â””â”€â”€ lru-cache@2.7.3 

robinanil 17:36:13 :~/work/admin/consumer$ ls node_modules/marko/runtime/
deprecateHyphens.js helpers.js          loader.js           loader_browser.js   marko-runtime.js    package.json
robinanil 17:36:19 :~/work/admin/consumer$ 
```
  [![Coverage Status](https://coveralls.io/builds/7292035/badge)](https://coveralls.io/builds/7292035)

Coverage increased (+0.02%) to 84.152% when pulling **0521933c99754fe18959f22fc77fe594f35c92d5 on issue-345** into **d433ac25aa2b428b4b46060e310c55a00183ff18 on master**.
  [![Coverage Status](https://coveralls.io/builds/7291326/badge)](https://coveralls.io/builds/7291326)

Coverage increased (+0.03%) to 84.129% when pulling **94eafb7bd6bd100bc5a722e9a8388ced1c044f87 on issue-344** into **7e76972737843b3614520242cee9a3ca2fa728c5 on master**.
  ### Description

Currently marko-widgets allows to define a UI component's renderer as `require('marko-widgets').defineRenderer({...});`. I would like to propose a similar, but simpler:

`require('marko').defineRenderer({...});`
### Context

Building our project, we've defined custom taglibs that export the simplest "components" to more complex components. For simple componets (server-rendered only, no state, little to no client behavior), our approach to custom taglibs has been to export in index.js a function that takes an `input` and then calls template.render.

```
module.exports = function(input, out) {
    template.render(input, out);
}
```

Unlike defineRenderer, this does not export a `render` function similar to defineRenderer. We could set `exports.render` or use `createRenderFunc` from `raptor-renderer`, however I would like to propose a `defineRenderer` in `marko`, with similar (but much simpler) life cycle events.

```
module.exports = require('marko').defineRenderer({
    template: require('./template.marko'),
    getTemplateData: function (input) {
        input.time = Date.now();
        return input;
    }
});
```

The added benefit (and why this beats `exports.render` or `createRenderFunc`) is that if the simple component takes on a more, complex role, adding `-widgets` + any extra lifecycle event methods is straightforward and painless.

Thanks!
 ðŸ‘  I always thought this API difference between marko and marko-widgets was a bit strange.
 ðŸ‘  totally agree here.
  ## Bug Report
### Context

I have a project where we embed another templating language inside of a marko template. Because of this, there are cases where we need to disable Marko's parsing for sections of HTML, so that Marko does not try to parse foreign template syntax that may throw errors. We use the marko-body="static-text" attribute to disable Marko parsing. 

HTML snippets that causes parser error:

Example 1:
`<div marko-body="static-text">
    <div>Content Goes Here</div>
</div>`

Example 2:
`<section marko-body="static-text">
        <div>Other Content</div>
    <section>Content Goes Here</section>
</section>`

Note that the element type of node with marko-body attribute must match some element within it. 
### Expected Behavior

The output should be:

Example 1:
`<div>
    <div>Content Goes Here</div>
</div>`

Example 2:
`<section>
        <div>Other Content</div>
    <section>Content Goes Here</section>
</section>`
### Actual Behavior

Example 1: Parser error - 'The closing "div" tag was not expected'
Example 1: Parser error - 'The closing "section " tag was not expected'
### Possible Fix

<!--- Not obligatory, but suggest a fix or reason for the bug -->

<details><summary>

Additional Info</summary>


### Your Environment
- Versions used:
- Marko 3.8.1
- Lasso 2.5.5
- Lasso-Marko 2.0.7
- Operating System and version (desktop or mobile): Ubuntu 14.04
- Link to your project: (eBay Internal)
### Steps to Reproduce

Input either of these pieces of code on http://markojs.com/try-online/

`<div marko-body="static-text">
    <div>Content Goes Here</div>
</div>`

`<section marko-body="static-text">
        <div>Other Content</div>
    <section>Content Goes Here</section>
</section>`
### Stack Trace

Example 1: Parser error - 'The closing "div" tag was not expected'
Example 1: Parser error - 'The closing "section " tag was not expected'

</details>
 A custom tag would be great! Another huge benefit of a custom marko-parser tag (versus attribute on a rendered tag) is that it can act a non-rendered parser directive, resulting in no additional HTML output/DOM structure change. 

Background: When I used the existing version of this marko-body attribute, I wanted to be able to ignore a block of HTML (which contained non-marko compatible AngularJS syntax in it), but not result in a new non-functional node that wraps the content (which can potentially affect animation and browser compositing performance depending on the kind of operations you perform on your DOM elements). I ended up attaching the marko-body attribute to each HTML element, but had to be careful of the same element type within to prevent this gotcha. 
  [![Coverage Status](https://coveralls.io/builds/7094318/badge)](https://coveralls.io/builds/7094318)

Coverage increased (+0.003%) to 84.041% when pulling **2cdc18afc52665e75a235a32932942b7147d5fd9 on exclude-dir-fix** into **f2116dc44d032bc56bb762a2e577c28fb8233004 on master**.
 [![Coverage Status](https://coveralls.io/builds/7094851/badge)](https://coveralls.io/builds/7094851)

Coverage increased (+0.06%) to 84.095% when pulling **adea7ca0a06d5cc29d9fe36a9fc0eb0f5ee81ded on exclude-dir-fix** into **f2116dc44d032bc56bb762a2e577c28fb8233004 on master**.
 [![Coverage Status](https://coveralls.io/builds/7094932/badge)](https://coveralls.io/builds/7094932)

Coverage increased (+0.06%) to 84.095% when pulling **5e070d61251b27d614cacf4ad9aa8c58d5e79bb7 on exclude-dir-fix** into **f2116dc44d032bc56bb762a2e577c28fb8233004 on master**.
  [![Coverage Status](https://coveralls.io/builds/7059387/badge)](https://coveralls.io/builds/7059387)

Coverage increased (+0.04%) to 84.038% when pulling **4f43e93da4b825136f83d914b712a3f5cf76331d on autodiscover-components** into **213e65241898b19f853f704d8e8bbca2a06c1465 on master**.
  I'm fairly new to Marko and I'm having some difficulties handling errors gracefully when rendering templates (on the server). Initially I structured my app to pipe the render stream straight to the response:

``` js
const marko = require('marko')

const template = marko.load(filename, {
  buffer: false
})

return (req, res) => {
  ...
  return template.render(data, res)
})
```

But when the rendering process errors (E.G. attempting to access an undefined property) this results in an unfinished response.

Preferably I'd like to catch the error, log it and fail more gracefully, even it means taking a small perf hit:

``` js
// with callback
return (req, res) => {
  ...
  return template.render(data, (err, data) => {
    if (err) {
      log(err)
      res.send(500).end()
    } else {
      res.send(data)
    }
  })
})

// or with streams
return (req, res) => {
  ...
  return template.stream(data)

  stream.on('data', data => { output.push(data) })

  stream.on('error', err => { errors.push(err) })

  stream.on('end', () => {
    if (errors.length) {
      log.apply(null, errors)
      res.send(500).end()
    } else {
      res.send(output.join(''))
    }
  })

  return stream
})
```

However neither the streaming nor callback interface are currently able to catch such an error, with the effect of potentially crashing the process.

Are you able to recommend a strategy whereby templates can fail more gracefully at render time?
 Thank you for your fast response @patrick-steele-idem - I actually read the article you linked to before posting my question, too ðŸ˜

I'd also tried promises (for the implicit try/catch) but I'd made the mistake of _returning__ the result of the render method - thanks to your example I'll continue with that path.

A promise based API sounds like a very good idea to me ðŸ‘ 
  I'm trying to pretty-print some JS that comes from CoffeeScript's `compile()` and  using a [compile-time tag](https://github.com/marko-js/marko/blob/master/docs/compile-time-tags.md) like so:

`marko.json`:

``` js
{
  "<coffee-script>": {
    "code-generator": "./lib/tags/coffee-script",
    "body": "static-text",
    "preserve-whitespace": true,
    "@bare": "boolean"
  },
  "<stylus-css>": {
    "code-generator": "./lib/tags/stylus-css",
    "body": "static-text",
    "preserve-whitespace": true,
    "@compress": "boolean",
    "@paths": "array"
  }, ...
}
```

`coffee-script.coffee`:

``` coffee
'use strict'

{compile} = require('coffee-script')

module.exports = (el, generator) ->
  {builder} = generator
  bare = el.getAttributeValue('bare') or yes
  print = (process.env.npm_lifecycle_event is 'standard')

  js = compile(el.bodyText, {bare, print})
  console.log js

  return builder.htmlElement 'script', {}, [
    builder.text builder.literal(js)
  ]
```

`stylus-css.coffee`:

``` coffee
'use strict'

stylus = require('stylus')

module.exports = (el, generator) ->
  {builder} = generator
  compress = (process.env.npm_lifecycle_event is 'optimized')

  css = stylus(el.bodyText)
    .set 'compress', el.getAttributeValue('compress') or compress or no
    .set 'paths', el.getAttributeValue('paths') or []
    .render()

  console.log css

  return builder.htmlElement 'style', {}, [
    builder.text builder.literal(css)
  ]
```

Sample console output (js):

``` js
var clickDefault, collapseFormat, initLayer;

initLayer = function() {
  screenad.hide('self');
  screenad.setSize('600', '250');
  screenad.setAlignment('banner', 'banner');
  screenad.setOffset(-300, 0);
  screenad.setSticky(true);
  screenad.setZIndex(100000);
  return screenad.position();
};

collapseFormat = function() {
  screenad.event('user_close');
  return screenad.hide();
};

clickDefault = function() {
  return screenad.click();
};

var init_layer;

init_layer = function() {
  screenad.hide('self');
  screenad.setAlignment('banner', 'banner');
  screenad.setSticky(layer.sticky);
  screenad.setSize(layer.width, layer.height);
  screenad.setOffset(layer.x, layer.y);
  screenad.setZIndex(layer.z);
  screenad.position();
};
```

Sample console output (css):

``` css
body {
  background-color: #000;
}
#closebutton {
  background-image: url("close.png");
  bottom: 0px;
  cursor: pointer;
  height: 20px;
  position: absolute;
  right: 0px;
  width: 90px;
  z-index: 110000;
}
#closebutton:hover {
  opacity: 0.8;
}
#wrap_bg {
  background-image: url("backup-layer.jpg");
  background-repeat: no-repeat;
  cursor: pointer;
  height: 100%;
  width: 100%;
  z-index: 100010;
}
```

Sample compiled html (notice the output between `<script>` and `<style>` tags):

``` html
<!DOCTYPE html>
<html lang="en">
  <head>
    [...]
    <script>
      var init_banner; init_banner = function() { screenad.setAlignment('banner', 'banner'); screenad.setSticky(banner.sticky); screenad.setSize(banner.width, banner.height); screenad.setOffset(banner.x, banner.y); screenad.setZIndex(banner.z); screenad.position(); };
    </script>
    <style>
      body { font-family: "Trebuchet MS"; text-align: center; } #content { height: 100%; width: 100%; } #container { background-color: #fff; z-index: 1000; } #clicktoexpand { background-color: #fff; background-image: url("clicktoexpand.png"); background-repeat: no-repeat; bottom: 0px; cursor: pointer; height: 23px; left: 0px; position: absolute; width: 170px; z-index: 10000; } #clicktoexpand:hover { opacity: 0.8; }
    </style>
    <script>
      var _autoExpand, _click, _expandType, clickDefault, ignite, init, showLayer, start; _click = 'click'; _expandType = _click; _autoExpand = false; ignite = false; init = function() { screenad.event(screenad.deviceType); if (!ignite) { screenad.onSync = start; ignite = true; } }; start = function() { if (_expandType === _click) { document.getElementById('container').addEventListener(_click, clickDefault); } if (_autoExpand && ignite) { showLayer(); } screenad.setSize('300', '250'); screenad.setAlignment('banner', 'banner'); screenad.setOffset(0, 0); screenad.setSticky(true); screenad.setZIndex(100); screenad.position(); }; showLayer = function() { screenad.event('expand'); screenad.show('all'); }; clickDefault = function() { screenad.click(); };
    </script>
    [...]
  </head>  
  <body onload="init_banner()">
    <script>
      window.banner = {"width":320,"height":240,"sticky":true,"x":0,"y":0,"z":1,"libraries":["//media.adrcdn.com/scripts/external/velocityjs/1.2.3/velocity.min.js","//media.adrcdn.com/scripts/external/velocityjs/1.2.3/velocity.ui.min.js"]};
    </script>
    [...]
  </body>
</html>
```

Expected output:
I would like the js whitespace to be preserved whenever `process.env.npm_lifecycle_event === "standard"` (i.e. when `npm run standard` is run) and minified whenever the same env var is set to `optimized`. Is there a way to accomplish this?
 @mlrawlings perfect! I should've looked at `builder.text` instead of `builder.literal` firstâ€¦ Thanks!
  HTH
  HTH
  Marko is not showing any error related to unexpected characters / invalid JSON config.

Invalid json config - browser.json :

`[
 {
            "type": "js",
            "url": "https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.3/js/select2.min.js"
        },
]`

Error shown after some time : 

`Error: Async fragment failed (lasso-slot:head). Exception: Error: Async fragment (lasso-slot:head) timed out after 30000ms`

I believe a parsing error can be thrown right away if browser.json or any other config file is invalid and marko is unable to parse such file.
  [![Coverage Status](https://coveralls.io/builds/7034622/badge)](https://coveralls.io/builds/7034622)

Coverage remained the same at 83.998% when pulling **fd9e5413ab812d38072ffbe3f763e3cf2321a91e on contributing** into **207102bccab3566ebc8cab1212744e0340cb71c2 on master**.
  It seems like there are a lot of other pieces where we have convention with the additional option of providing your own. E.g. `renderer.js` will be found automatically, but you can specify your own renderer naming if desired. Might be more consistent to apply that to custom tag discovery as well, so that we look for `components/` by default, but allow customization if needed. This would mean that the name `components/` can't be used for anything else though.

Practically speaking, my `components/` folder is not usually completely flat, so my nested components would need the discovery path in marko.json anyway.
 @mlrawlings I see, although in my case I don't normally need an entire new `components` folder for my sub components, so it would be like

```
/
 â¤· src/
    â¤· components/
        â¤· some-component/
               â¤· some-subcomponent/
               â¤· another-subcomponent/
           â¤· index.js
           â¤· template.marko
```

So if this change was made it would mean that my small projects wouldn't need a `marko.json` file, while my larger projects would have one string removed from the config lookup array.
  The `alt` attribute has a few scenarios where it should be an empty string, particularly when used on decorative images: https://developers.whatwg.org/embedded-content-1.html#a-purely-decorative-image-that-doesn%27t-add-any-information

In marko v3, rendering `<img alt="">` will become `<img alt>`. Haven't checked the exact output in v2, but I believe the issue is there too. Is there a workaround to get empty strings to show up? I imagine there might be similar cases out there for other attributes, but maintaining a list of exceptions would be unfortunate.
 There are probably cases where people rely on empty string not rendering the attribute, as in `<div class=${data.someClass}>` when `data.someClass` is an empty string. Technically it wouldn't break anything to have it output as `<div class="">`, but that's probably worse off than before. Maybe it's worth it to maintain the exceptions?
 @mlrawlings This came up in a PR recently where using an a single space alt was the best solution we could come up with, but stood out as a clear hack. Apparently alt is "required no matter what" (probably due to screen reader behavior?) which then leads to weird cases where the official suggestion is to have `alt=""`.

I haven't tried any exhaustive testing to clarify the differences between `alt` and `alt=""`, but since the latter seems to be recommended, I imagine they're treated differently by screen readers.
 But it's an officially sanctioned hack! ðŸ˜† 
 I'm not sure, in that case I think I'd personally prefer leaving it as-is. Empty string is a nice shortcut to avoid rendering an attribute, and it's only wrong in this one case.
  ## Summary

Adding type annotations to JavaScript in order to get compile-time guarantees has become popular with tools like [TypeScript](https://www.typescriptlang.org) and [Flow](https://flowtype.org/). Would it be feasible to get the same benefits in Marko template files?
## Rationale

View engines that are "just JavaScript" like React can easily be type-checked (both TypeScript and Flow actually have out-of-the box support for React).

When working with templates though, you loose the benefit of type-checking as soon as you cross the boundary into the template file. In a type-checked project, this can make refactoring trickier, for example you rename a property but forget to update the template.

On the other hand, templates have the advantage of compile-time optimizations (ex: [ server-side rendering performance](http://markojs.com/blog/announcing-marko-v3/#compile-time-optimizations)). Being able to have type-checked templates could be a big win. I don't think this has been done yet in the JavaScript community.

Note: My knowledge of compiling templates or type-checking is close to none, so I don't even know if this is feasible :) This issue is intended to start a discussion.
## What it could look like

(I'm using TypeScript in my examples but this could very well be translated to Flow.)

Say I have declared these types:

``` typescript
// types.ts

export interface Cat {
  name: string;
  meow: string;
}

export interface Dog {
  name: string;
  woof: string;
}
```

A TypeScript file would immediately tell me if I'm accessing wrong properties:

``` typescript
// test.ts

import { Cat, Dog } from "./types";

function run(cat: Cat, dog: Dog) {
  // Error: Property 'woof' does not exist on type 'Cat'.
  console.log(cat.name, cat.woof);
  // Error: Property 'meow' does not exist on type 'Dog'.
  console.log(dog.name, dog.meow);
}
```

But a Marko template wouldn't:

``` html
<!-- templates/animals.marko -->

<div>
  <h3>${data.cat.name}</h3>
  <p>${data.cat.woof}</p> <!-- cat.woof is undefined -->
  <h3>${data.dog.name}</h3>
  <p>${data.dog.meow}</p> <!-- dog.meow is undefined -->
</div>
```

What if I could declare the type of the data my template expects?

``` html
<!-- templates/animals.marko -->

<script marko-import>
  import { Cat, Dog } from "../types";

  interface TemplateData {
    cat: Cat;
    dog: Dog;
  }
</script>

<div>
  <h3>${data.cat.name}</h3>
  <p>${data.cat.woof}</p>
  <h3>${data.dog.name}</h3>
  <p>${data.dog.meow}</p>
</div>
```

And tell Marko to generate type-annotated files?

``` bash
$ markoc templates --types=typescript
```

The TypeScript compiler would then catch the errors on the generated JavaScript:

``` typescript
// templates/animals.marko.ts

import marko from "marko";

import { Cat, Dog } from "../types";

interface TemplateData {
  cat: Cat;
  dog: Dog;
};

function create(__helpers) {
  var str = __helpers.s,
      empty = __helpers.e,
      notEmpty = __helpers.ne,
      escapeXml = __helpers.x;

  return function render(data: TemplateData, out) {
    out.w("<div><h3>" +
      escapeXml(data.cat.name) +
      "</h3><p>" +
      // Error: Property 'woof' does not exist on type 'Cat'.
      escapeXml(data.cat.woof) +
      "</p><h3>" +
      escapeXml(data.dog.name) +
      "</h3><p>" +
      // Error: Property 'meow' does not exist on type 'Dog'.
      escapeXml(data.dog.meow) +
      "</p></div>");
  };
}

let template: MarkoTemplate;
template = marko.c(__filename)).c(create);

export default template;
```

And as I use the template in my type-checked project I would get auto-completion and type errors:

``` typescript
// render.ts

import template from "./templates/animals.marko";
import { Cat, Dog } from "./types";

let cat: Cat;
cat = {
  name: "Felix",
  meow: "Meow!"
};

let dog: Dog;
dog = {
  name: "Rex",
  woof: "Woof!"
};

// Error: Argument of type '{ cat: Dog; dog: Cat; }' is not assignable to parameter of type 'TemplateData'.
//  Types of property 'cat' are incompatible.
//    Type 'Dog' is not assignable to type 'Cat'.
//      Property 'meow' is missing in type 'Dog'.
var html = template.renderSync({
  cat: dog,
  dog: cat
});
console.log(html);
```
## Open questions
- Source-maps & errors: If a runtime error occurs in the generated JS, can we show the line in the `.marko` file that caused it?
- Editor integration: A nice feature of TypeScript is the auto-completion and real-time type-checking. Would it be feasible to have that directly in the the `.marko` file?
## Relevant links
- https://github.com/Microsoft/TypeScript/issues/5151
- Original discussion: https://twitter.com/MarkoDevTeam/status/748638615937245185
 @patrick-steele-idem @mlrawlings I haven't gotten a change to explore this much, but I saw that Marko v4 is just around the corner (congratz btw! ðŸ˜„). I definitely don't expect this to make it to v4, but I did want to see if there were any changes in v4 that would make it hard to add TypeScript support in the future (should we want to of course), without any breaking changes.

I've quickly put this together: https://github.com/nicolashery/explore-marko-typescript

You can take a look at how I had to change the original Marko output ([src/components/search-results-item.marko.js](https://github.com/nicolashery/explore-marko-typescript/blob/master/src/components/search-results-item.marko.js)) to make it useful with TypeScript ([src/components/search-results-item.marko.ts](https://github.com/nicolashery/explore-marko-typescript/blob/master/src/components/search-results-item.marko.ts)).

There are a couple things in there, but the main one that caught my attention is probably Marko's `class` tag. It is rather prescriptive and also the JS seems to get parsed, so I can't use TypeScript syntax (like I can in Marko's `static` tag). I also can't use an ES6 class (which reminds me of React switching from `React.createClass()` to standard ES6 class).

Off the top of my mind, one option could be for the `class` tag to be an actually ES6 class. Or it could be a `component` tag instead, that works more like the `static` tag (i.e. allows any text assumed to be valid JavaScript, and that JS should evaluate to a valid Marko component). Thoughts?

Of course I don't want to distract, I know you guys are focused on shipping v4 and that's the most important. But I thought it could be worth thinking about this now, even if just a little bit. Thanks @mindeavor, I hadn't seen that. From skimming through it, I think this will help with the question of editor integration (ex: [VSCode Angular Language Service](https://github.com/angular/vscode-ng-language-service)). I looks like it's been open for a while though.

What I had in mind as a first step is more along the lines of [Angular's Ahead of Time (AOT) compilation](https://angular.io/docs/ts/latest/cookbook/aot-compiler.html), which outputs TypeScript code that can be used when type-checking the whole app (business logic code + templates):

```
$ markoc src/ --typescript
Compiling:
  Input:  src/components/search-results-item.marko
  Output: src/components/search-results-item.marko.ts

Compiled 1 templates(s)

$ tsc
src/components/search-results-item.marko.ts(98,26): error TS2339: Property 'pric' does not exist on type 'SearchResultsItem'.
``` I haven't looked closely, but looks like the plugin support released in [TypeScript 2.3](https://blogs.msdn.microsoft.com/typescript/2017/04/27/announcing-typescript-2-3/) may be of help for type-checking `.marko` files, and more generally providing editor tooling for Marko (autocompletion, etc.). Here is an example [plugin for the Vue.js framework](https://github.com/octref/vetur/).  [![Coverage Status](https://coveralls.io/builds/6826187/badge)](https://coveralls.io/builds/6826187)

Coverage remained the same at 83.885% when pulling **32c820fe8f194975b69648b0adec732740cb7f53 on patrick-steele-idem:markoc-tests** into **4e9a6b108c5f4b633dcd2590df8dc7ef447f9fcc on marko-js:master**.
  Hello,

while trying out Marko I tested how it's autoescaping works in different contexts.

The contexts I tested it in:
- inside html tag
- inside html attribute
- inside html script tag

In first two Marko correctly detected context and chose proper escaping functions (I saw escapeXml and escapeXmlAttr in compiled templates), but in the last one I was able to do XSS.

You can replicate it on http://markojs.com/try-online/

marko template

``` html
<p onclick='alert("${ data }")'>${ data }</p>
<script>var x = "${ data }"</script>
```

data

``` js
"\"; alert('xss');\""
```

HTML output

```
<p onclick="alert(&quot;&quot;; alert(&#39;xss&#39;);&quot;&quot;)">"; alert('xss');"</p>
<script>
    var x = ""; alert('xss');""
</script>
```
 @patrick-steele-idem thanks for the detailed reply,

Is it really inherently unsafe to put user data in script tag? Even if you escape all characters like `>` into unicode? This seems to be what some template engines are doing.

Some provide escapejs filter - https://docs.djangoproject.com/en/1.9/ref/templates/builtins/#escapejs
Some even do this automatically by detecting context where variable is used https://latte.nette.org/en/#toc-context-aware-escaping

But you seem to be much more knowledgeable about this topic than me, so I am not sure if these filters catch 100% of XSS attackers inputs
 @patrick-steele-idem With this fix in place, is there still any reason to avoid putting data in inline scripts? The strategy of using empty dom elements with data-attributes always seemed strange to me.
  -use retina image for logo
-center logo with html
-move "Try Marko Online" to first paragraph
-move badges below first paragraph

The only way to reliably test this was by putting it on my fork master, so you can see here https://github.com/yomed/marko. Spacing is a bit worse on mobile, but there's only so much customization you can do before github takes over. Let me know of any concerns.

Desktop:
<img width="1044" alt="screen shot 2016-06-28 at 7 25 02 pm" src="https://cloud.githubusercontent.com/assets/3595986/16438603/1b3e4486-3d66-11e6-986c-dbac05f89c0d.png">

Mobile (iPhone 6 size):
<img width="403" alt="screen shot 2016-06-28 at 7 26 11 pm" src="https://cloud.githubusercontent.com/assets/3595986/16438612/363d35e4-3d66-11e6-8fa2-be0c4b3be95f.png">
 [![Coverage Status](https://coveralls.io/builds/6793825/badge)](https://coveralls.io/builds/6793825)

Coverage remained the same at 83.872% when pulling **c15c11329325566fe61fa8184dafd1b0aba245a7 on yomed:master** into **f6feffcef06e6a55dbaa208d006304febf957977 on marko-js:master**.
  â€¦ configuration variable. If files are hot reloaded, we should never assume that they are up to date.

Fixes issue #319
 [![Coverage Status](https://coveralls.io/builds/6770368/badge)](https://coveralls.io/builds/6770368)

Coverage remained the same at 83.872% when pulling **c76ffa2382e9544f57fbb3445d76ba04efa1faec on ianvonholt:ISSUE_319** into **fd318a8621ae7418a4b805f24c9f4ec01403c8ce on marko-js:master**.
  When using includes or layouts while setting writeToDisk to false, Marko still writes the JS rendered files for these.

Is this a bug? Or is there a way to disable this as well?
 Hi @patrick-steele-idem ,

I just tested the compilation process again. I'm running Marko 3.7.1 only (no other versions or duplicates are installed). For some reason the includes still write a separate JS file.

For what it's worth, I'm using Brunch in combination with https://github.com/thomastorfs/static-marko-brunch

Any ideas?
 I have having a problem with this bug as well.
 Hey Patrick, I'm also seeing this now where layout-use(template) is generating a file system compile of the template, while all other templates are not written to disk. Let me see if I can put a simpler demo together for you. 
 Ok, here's the simplest project I could make that shows the issue. When you first run this, it will create a layout.marko.js, but not a template.marko.js. It shouldn't create either, the compiler option is set to 

``` javascript
{ 
   compilerOptions: { 
         writeToDisk: false
   } 
}
```

https://github.com/jasonmacdonald/layout_generates_file
 @patrick-steele-idem I've managed to trace it back to requireResolve method in CompileContext but can't seem to understand where to go from there. It seems memberExpression() constructs a call combining require and resolve, but I can't really see what it's doing that would bypass the 'marko/node-require' which should see the flag for writeToDisk.
 Ok, further digging it seems layout.html in my example gets loaded by a helper, which uses loader/index files loadFile() method which does not get passed the options we passed in through require('marko/node-require').install({config...});. It only sees options that were set using the markoCompiler.defaultOptions.

Looking in the helper, the only thing the helper passes to load is the path, no options. 

I confirmed that switching to setting global.__MARKO_CONFIG does stop layout.html from being written to disk.

So it seems the bug is only when you set compilerOptions via the config on node-require.

My suggestion would be to have the install(config) on node-require actually set the global.__MARKO_CONFIG so it acts as expected in all loading scenarios. Just my $0.02.
 @patrick-steele-idem I figured as much, it was more just to test if that would work. :)
  [![Coverage Status](https://coveralls.io/builds/6730864/badge)](https://coveralls.io/builds/6730864)

Coverage increased (+0.06%) to 83.527% when pulling **7b1bbf3ed817964a8952d2a7d236c0f52e317097 on issue-314** into **74120dbbbea4a92be055f63d10b54804134c613e on master**.
 [![Coverage Status](https://coveralls.io/builds/6730864/badge)](https://coveralls.io/builds/6730864)

Coverage increased (+0.06%) to 83.527% when pulling **7b1bbf3ed817964a8952d2a7d236c0f52e317097 on issue-314** into **74120dbbbea4a92be055f63d10b54804134c613e on master**.
  Good idea! I need it.
 If there's enough interest, it would be fairly simple for `<await>` to also accept streams - though as Michael pointed out, it would need to buffer the stream until it was finished, so I'm not sure how useful that would be.

Alternatively, most streams can simply be converted to Promises with something like
```js
new Promise(function(resolve, reject) {
    var buffer = [];
    stream.on('error', reject);
    stream.on('data', function(data) {
        buffer.push(data);
    });
    stream.on('end', function() {
        var result = Buffer.concat(buffer).toString();
        resolve(result);
    });
});
```

Hopefully this weekend I'll get the chance to play with the `<on>` tag a bit, looks awesome! @patrick-steele-idem If `<await>` was to handle multiple-flush streams / event emitters (which I don't believe it should), I would prefer something similar to "deferred.progress()"; perhaps a separate await-specific nested tag, like `<await-on-data>`.

Though here's another thought that just popped to mind: What about something like that for the `<on>` tag? For example...
```
<ul on(streamOrEventEmitter)>
    <li on-data(result)><!-- maps to ".on('data', ...)" -->
        ${result}
    </li>
</ul>
```
...as an alternate syntax to allow binding to events other than just 'data'? On second thought, something like this might be better instead:
```
<ul>
    <li on(var1, var2 from 'eventName' of emitter)>
        ${var1 + ', ' + var2}
    </li>
</ul>
```
('from' and 'of' are just what came off the top of my head, it may need re-wording) (Just noticed the original post had an example of using a generic EventEmitter which accomplishes basically the same thing as my previous post, not sure how I missed that a few days ago.)

Hmm... Rather than starting with standard streams and adding different syntaxes to support non-standard use cases, what if we looked at this the other way around? We could start by exposing the generic behavior:
```
<ul>
    <li on(user from 'data' in data.usersStream) repeat=true>
        ${user.name}
    </li>
    <li on('end' in data.usersStream)>
        <button>load more</button>
    </li>
</ul>
```
Then add convenience syntaxes for the most common uses:
```
<ul>
    <li on(user from data.usersStream)>
        ${user.name}
        <on-finish>
            <li><button>load more</button></li>
        </on-finish>
    </li>
</ul>
```
Note that `<on(user from data.usersStream)>` and `<on-finish>` are just syntactic sugar for `<on(user from 'data' in data.usersStream) repeat=true>` and `<on('end' in data.usersStream)>`, respectively. @patrick-steele-idem - this sounds good to me. Looks lot cleaner! @patrick-steele-idem @mlrawlings - will <awaits> accept event emitter going forward. right now, its not supporting event emitter. i think its essential to support that with respect to streaming I can't think of any reason not to. Just one question: If the object has both `.on()` and `.then()` methods, should it be treated as an emitter or a thenable? (I'm leaning toward emitter, but that *might* be considered a breaking change...)

Also, a few more ideas:
* `<await(data.userStream until 'finished' or 'cancelled')>`
* `<on(user)>` (defaults to 'data' event)
* `<once(...)>` @mlrawlings @austinkelleher @patrick-steele-idem 

any tips and tricks for applying infinite scrolling with marko?  [![Coverage Status](https://coveralls.io/builds/6656558/badge)](https://coveralls.io/builds/6656558)

Coverage increased (+0.3%) to 83.728% when pulling **b3c3c564a46534b6972c3af0eae44d9b12b5d9ca on mlrawlings:await-tag** into **74120dbbbea4a92be055f63d10b54804134c613e on marko-js:master**.
 When I read `await theUserDataProvider as user`, I thought I am creating an alias `user` for `theUserDataProvider`, where as `await user from theUserDataProvider` seem to make the intent clear.
 [![Coverage Status](https://coveralls.io/builds/6679660/badge)](https://coveralls.io/builds/6679660)

Coverage increased (+0.3%) to 83.728% when pulling **ef294526d15e6e48ad20b46098584da4a533752f on mlrawlings:await-tag** into **74120dbbbea4a92be055f63d10b54804134c613e on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/6679660/badge)](https://coveralls.io/builds/6679660)

Coverage increased (+0.3%) to 83.728% when pulling **ef294526d15e6e48ad20b46098584da4a533752f on mlrawlings:await-tag** into **74120dbbbea4a92be055f63d10b54804134c613e on marko-js:master**.
 [![Coverage Status](https://coveralls.io/builds/6679660/badge)](https://coveralls.io/builds/6679660)

Coverage increased (+0.3%) to 83.728% when pulling **ef294526d15e6e48ad20b46098584da4a533752f on mlrawlings:await-tag** into **74120dbbbea4a92be055f63d10b54804134c613e on marko-js:master**.
  So I used a progressive rendering demo and changed `addEventListener` to `w-onClick`. Now header widget reacts on clicks only after rendering is finished. Problem appeared after upgrading Marko 2 to 3.

Demo here: https://marko-progressive-bug.herokuapp.com

Forked repo to show a bug: https://github.com/darkwebdev/marko-progressive-rendering

Commit with changes: https://github.com/darkwebdev/marko-progressive-rendering/commit/afe5c03567b77b641d54404ee2eac7243b417661
  Documented exclusion of folder or node module from marko.json autodiscovery;
 Just an excuse in advance:
I'm rookie in open-source contribution and my english is not a native language. So any blame is accepted. :-)
 [![Coverage Status](https://coveralls.io/builds/6590782/badge)](https://coveralls.io/builds/6590782)

Coverage remained the same at 83.464% when pulling **748c5d7643cfdc9b114823a4e23077d35e0af7fd on oxala:feature/exclude** into **117be25411bd4ee595c5f8d6c03d2947a8eef4bc on marko-js:master**.
  Hey Patrick,

I will bother you again with specific folder/package exclusion from the automatic marko.json search.
Since we finally moved to marko3, i've reimplemented that functionality here as well.

Below you will find:
- Actual functionality implementation;
- Updated tests to cover the implementation;
 [![Coverage Status](https://coveralls.io/builds/6587535/badge)](https://coveralls.io/builds/6587535)

Coverage increased (+0.02%) to 83.445% when pulling **f8c8b5f3319b5e5b8d32aeaf7baa4b831442f07d on oxala:feature/exclude** into **9f240e7bea17116a05a9e961c14d52dab735d292 on marko-js:master**.
 No worries, thank you for accepting. Sure, i'll update the docs: https://github.com/marko-js/marko/pull/310
  [![Coverage Status](https://coveralls.io/builds/6581856/badge)](https://coveralls.io/builds/6581856)

Coverage remained the same at 83.42% when pulling **01f8a24dc04867d3d2a51907a7c4b2fb1ab08657 on mlrawlings:shorthand-classes** into **a60d0078b97c42f6c0ee85894428f808cddefa9e on marko-js:master**.
  Given:

``` html
<input type="text"
           name="username"
           placeholder="username"
           spellcheck="false"
           autocomplete="off"
           autocorrect="off"
           pattern="[\w0-9]+">
```

Marko will fail with an error:

> Error(s) in template:
> 1) [templates/views/askForUsername.marko:16:20] Invalid string ("[\w0-9]+"): SyntaxError: Unexpected token w

This is "fixable" by `pattern="[\\w0-9]+`, but that doesn't follow the HTML spec -- https://html.spec.whatwg.org/multipage/forms.html#attr-input-pattern . In other words, the value should be a regular expression that can be directly substituted into a JavaScript regular expression literal, e.g. `/[\w0-9]+/`.
 I understand the underlying issue. But my opinion is that when writing HTML within the template we shouldn't have to remember "no, this isn't really HTML, it's an escaped JavaScript string."

I think a solution to this, and probably other cases, would be to have a `<raw></raw>` Marko directive.
 I suppose if extra syntax is added, what about something closer to what is already present for skipping HTML escaping?

``` html
<input#foo class=${a: true, b: false} pattern=!"[\w0-9]">
```

It has the bonus of being _almost_ like a CSS attribute selector.
 My point is "who knows?" Anyone can stick pretty much anything they want in a `data` attribute. And future spec graced attributes could have anything as well.

My use case is a simple fix on my end (other than remembering when I come back to the project in 6 months why there is an extra `\`). I just think that it would be wise to provide a template language specific method for dealing with such scenarios so that someone who knows the language can read the intention.
  [![Coverage Status](https://coveralls.io/builds/6522068/badge)](https://coveralls.io/builds/6522068)

Coverage increased (+0.003%) to 83.434% when pulling **5c7eb271dc376e2393752110014e1ae243abcdea on mlrawlings:asyncfragment-info** into **06f6e37fdc0ed18d1684b779a01c06f87026ed9c on marko-js:master**.
  I was running karma + PhantomJS on some Marko Widgets with async-fragments, I got the following error:

```
Running "karma:test" (karma) task
     Saving optimization output to: ./.test/static
START:
PhantomJS 2.1.1 (Mac OS X 0.0.0) ERROR
  SyntaxError: Unexpected token '>'
  at /Users/isuhardi/works/feproject/.test/static/index/marko$3.4.4/taglibs/async/async-fragment-tag-transformer.js:28
```

This is due to arrow syntax at async-fragment-tag-transformer, which PhantomJS cannot run due to lack of ES6 support.
  Nice PR @mlrawlings! Did you consider using `--include-all-sources` in the istanbul command for  coverage against the whole codebase?
  Ideally, all our errors in generating code would be developer friendly and added through `context.addError`, however, not every case is covered currently.  

This pull request catches errors from code generators, adds context about the node (including line number in the template when available), and rethrows the error while maintaining the original stack trace.

In the ideal case it looks something like this:

```
Error: Something Happened! -- Generating code for <custom-tag> tag (test/autotests/render/error-thrown-in-generator/template.marko:2:4)
```

Even in cases where we don't have the line number, you at least have a better idea of what might be causing the error.  The following is what the error @seangates encountered earlier would have looked like:

```
Error: 
Unexpected token ): (+)
                      ^ -- Generating code for <assign> tag
```

_Note: I'm actually not quite sure why the node doesn't have the line number attached in this case - I may look into this at a later point in time._

For non-html nodes, the type of node is listed (and will list line number if available):

```
Error: some error message -- Generating code for ForEach node
```
 @mlrawlings Wonderful! Thanks!
  I'm probably doing something really stupid but with the following code I can't get Marko to recompile the template when I make a change directly to the template file. Can anyone tell me what mistake I'm making?

```
'use strict';
process.env.MARKO_CLEAN = true;
require('marko/node-require').install();

require('marko/compiler').defaultOptions.checkUpToDate = true;
require('marko/compiler').defaultOptions.writeToDisk = true;
require('marko/compiler').defaultOptions.preserveWhitespace = true;
require('marko/compiler').defaultOptions.assumeUpToDate = false;

const Hapi = require('hapi');
const server = new Hapi.Server();

server.connection({ port: 4000 });

server.start((err) => {
    if (err) {
        throw err;
    }
    console.log('Server running at:', server.info.uri);
});

server.route({
    method: 'GET',
    path: '/',
    handler: function (request, reply) {
        var template = require('./template.marko');

        console.log('Render Template');
        template.render({ name: 'Frank', count: 30 }, function(err, output) {
                if (err) {
                    console.error('Rendering failed');
                    return;
                }

                return reply(output);
            }
        );
    }
});
```
 @patrick-steele-idem perfect! Thanks a ton, I knew I had to be missing something. I'm not sure how I missed the hot-reload options.
   @patrick-steele-idem @mlrawlings - Pls review, if this change makes sense.
    I'm adding some more detail to this, mostly so I don't forget: The issue is seen in v2, not sure if it is also an issue in v3.

The template that calls `<include template="./deferred.marko" template-data="data" />` is being rendered **client side**.  The widget **is** registered, but for the first render it does not call any of the [rendering methods](http://markojs.com/docs/marko-widgets/component-lifecycle/#rendering-methods), nor is the state properly set.  We can access the widget through `element.__widget`, and calling `setStateDirty()` does cause a re-render in which the rendering methods **are** called, but then the widget (which gets its contents from state) is empty because the state is not set from the first render.
    Hi,
I am using Marko v3 and facing the following issue.

An error occurred while trying to compile template at path "D:\Projects\Test\Test\views\admin\Dashboard.marko". Error(s) in template: 1) [views\admin\Dashboard.marko:1:25] Invalid string ("./browser.json"/>): SyntaxError: Unexpected token / in JSON at position 16 

```
Error: An error occurred while trying to compile template at path "D:\Projects\Test\Test\views\admin\Dashboard.marko". Error(s) in template:
1) [views\admin\Dashboard.marko:1:25] Invalid string ("./browser.json"/>): SyntaxError: Unexpected token / in JSON at position 16

    at Compiler.compile (D:\Projects\Test\Test\node_modules\marko\compiler\Compiler.js:124:25)
    at Object.compileFile (D:\Projects\Test\Test\node_modules\marko\compiler\index.js:91:25)
    at loadFile (D:\Projects\Test\Test\node_modules\marko\runtime\loader.js:116:34)
    at load (D:\Projects\Test\Test\node_modules\marko\runtime\loader.js:157:16)
    at Object.load (D:\Projects\Test\Test\node_modules\marko\runtime\marko-runtime.js:296:33)
    at exports.DashboardPage (D:\Projects\Test\Test\controllers\admin\Dashboard.js:2:26)
    at Layer.handle [as handle_request] (D:\Projects\Test\Test\node_modules\express\lib\router\layer.js:82:5)
    at next (D:\Projects\Test\Test\node_modules\express\lib\router\route.js:100:13)
    at Route.dispatch (D:\Projects\Test\Test\node_modules\express\lib\router\route.js:81:3)
    at Layer.handle [as handle_request] (D:\Projects\Test\Test\node_modules\express\lib\router\layer.js:82:5)
```

My template is as below

``` xml
<lasso-page package-path="./browser.json"/>
<!DOCTYPE html>
<html ng-app="MyPortal" lang="en">
  <head>
    <title>${data.title}</title>
    <meta charset="UTF-8" />
    <meta content='width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no' name='viewport'/>      
    <link href="${data.CDNUrl}/stylesheets/style.css" rel="stylesheet" type="text/css" />
    <lasso-head/>
  </head>
  <body >
    <div style="border:1px solid;border-color:#595959;width:100%;height:100%;">
      <table style="width:100%;height:100%;border:0px solid;border-collapse:collapse">
        <tr>
          <td style="height:120px;margin:0;padding:0px">
            <table style="width:100%;border:0px solid;border-collapse:collapse">
              <tr style="height:80px;background-color:#e9eaed">
                <td>
                  <a href="/">
                    <img src="${data.CDNUrl}/images/Logo.png" alt="" />
                  </a>
                </td>
              </tr>
              <tr style="height:40px;background-color:#333">
                <td>
                  <a class="link" href="/Admin/Dashboard">Dashboard</a>
                </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td style="background-color:white;margin:0;padding:0px">

          </td>
        </tr>
        <tr>
          <td style="height:50px;margin:0;padding:0px">

          </td>
        </tr>
      </table>
    </div>
    <lasso-body/>
    <init-widgets/>
    <browser-refresh/>
  </body>
</html>
```

Can you tell me what is the wrong with the template?
 Hi @sanjeevashrivastava, is it possible that the JSON in your `browser.json` file is malformed?
 content of browser.json is as below

{
    "dependencies": [
        "style.css"
    ]
}
 I am using htmljs-parser@1.5.12
 I am not using npm-strinkwrap.json
 at position 16 / is in `<lasso-page package-path="./browser.json"/>` of package-path attribute
 i also noticed that if template is in views folder then it is working and if this template is in views/admin folder then it is throwing this error
 If I put space after second " in `<lasso-page package-path="./browser.json" />` it is throwing following error

Lasso page result not found for slot "head". The <lasso-page> tag should be used to lasso the page.

Error: Lasso page result not found for slot "head". The <lasso-page> tag should be used to lasso the page.
    at render (D:\Projects\Test\Test\node_modules\lasso\taglib\slot-tag.js:51:15)
    at render (D:\Projects\Test\Test\node_modules\lasso\taglib\head-tag.js:10:5)
    at render (D:\Projects\Test\Test\views\admin\Dashboard.marko.js:20:5)
    at Object.Template.render (D:\Projects\Test\Test\node_modules\marko\runtime\marko-runtime.js:193:9)
    at exports.DashboardPage (D:\Projects\Test\Test\controllers\admin\Dashboard.js:4:14)
    at Layer.handle [as handle_request](D:ProjectsTestTestnode_modulesexpresslibrouterlayer.js:82:5)
    at next (D:\Projects\Test\Test\node_modules\express\lib\router\route.js:100:13)
    at Route.dispatch (D:\Projects\Test\Test\node_modules\express\lib\router\route.js:81:3)
    at Layer.handle [as handle_request](D:ProjectsTestTestnode_modulesexpresslibrouterlayer.js:82:5)
    at D:\Projects\Test\Test\node_modules\express\lib\router\index.js:234:24

and FYI I am using lasso@2.3.4
and using same browser.json in admin folder
 [Dashboard.marko.txt](https://github.com/marko-js/marko/files/254175/Dashboard.marko.txt)
[Home.marko.txt](https://github.com/marko-js/marko/files/254176/Home.marko.txt)

if you go with above files. both files are same but Home.marko is not working while Dashboard.marko works fine.
 [Home.marko.txt](https://github.com/marko-js/marko/files/255408/Home.marko.txt)

I have tried htmljs-parser separately using the following code with attached file. it is throwing same error.

```
var parser = require('htmljs-parser').createParser({
    onText: function (event) {
        // Text within an HTML element
        var value = event.value;
    },

    onPlaceholder: function (event) {
        //  ${<value>]} // escape = true
        // $!{<value>]} // escape = false
        var value = event.value; // String
        var escaped = event.escaped; // boolean
        var withinBody = event.withinBody; // boolean
        var withinAttribute = event.withinAttribute; // boolean
        var withinString = event.withinString; // boolean
        var withinOpenTag = event.withinOpenTag; // boolean
        var pos = event.pos; // Integer
    },

    onCDATA: function (event) {
        // <![CDATA[<value>]]>
        var value = event.value; // String
        var pos = event.pos; // Integer
    },

    onOpenTag: function (event) {
        var tagName = event.tagName; // String
        var attributes = event.attributes; // Array
        var argument = event.argument; // Object
        var pos = event.pos; // Integer
    },

    onCloseTag: function (event) {
        // close tag
        var tagName = event.tagName; // String
        var pos = event.pos; // Integer
    },

    onDocumentType: function (event) {
        // Document Type/DTD
        // <!<value>>
        // Example: <!DOCTYPE html>
        var value = event.value; // String
        var pos = event.pos; // Integer
    },

    onDeclaration: function (event) {
        // Declaration
        // <?<value>?>
        // Example: <?xml version="1.0" encoding="UTF-8" ?>
        var value = event.value; // String
        var pos = event.pos; // Integer
    },

    onComment: function (event) {
        // Text within XML comment
        var value = event.value; // String
        var pos = event.pos; // Integer
    },

    onScriptlet: function (event) {
        // Text within <% %>
        var value = event.value; // String
        var pos = event.pos; // Integer
    },

    onError: function (event) {
        // Error
        var message = event.message; // String
        var code = event.code; // String
        var pos = event.pos; // Integer
    }
});
var fs = require('fs');

fs.readFile('./views/Home.marko', 'utf8', function (err, contents) {
    parser.parse(contents);
});
```

So it is confirmed that the issue is in htmljs-parser. Please try to debug it. FYI I am using Windows OS.
 Thank you very much. New version htmljs-parser@1.5.13 fixed the issue.
  Hi! After upgrade nodemon, node and migrating from marko 2.x to 3.x version i getting next problem:
**Node.js version: 6.0.0**

```
npm start

Appname@1.3.0 start /home/baddad/Projects/Appname
NODE_ENV=development nodemon app.js -e js,marko,json --trace-sync-io --verbose

[nodemon] 1.9.2
[nodemon] to restart at any time, enter rs
[nodemon] ignoring: .git .nyc_output .sass-cache bower_components coverage /home/baddad/Projects/Appname/node_modules/\*/
[nodemon] watching: .
[nodemon] watching extensions: js,marko,json
[nodemon] starting node app.js --trace-sync-io
[nodemon] child pid: 20375
[nodemon] watching 2,134 files
[nodemon] files triggering change check: application/frontend/home/home.marko.js
[nodemon] matched rule: \*\/.\*
[nodemon] changes after filters (before/after): 1/1
[nodemon] restarting due to changes...
[nodemon] application/frontend/home/home.marko.js

[nodemon] starting node app.js --trace-sync-io
[nodemon] child pid: 20383
[nodemon] files triggering change check: application/frontend/home/home.marko.js
[nodemon] matched rule: \*/.\*
[nodemon] changes after filters (before/after): 1/1
[nodemon] restarting due to changes...
[nodemon] application/frontend/home/home.marko.js

[nodemon] starting node app.js --trace-sync-io
[nodemon] child pid: 20391
[nodemon] files triggering change check: application/frontend/home/home.marko.js
[nodemon] matched rule: \*/.\*
[nodemon] changes after filters (before/after): 1/1
[nodemon] restarting due to changes...
[nodemon] application/frontend/home/home.marko.js

[nodemon] starting node app.js --trace-sync-io
[nodemon] child pid: 20399
[nodemon] files triggering change check: application/frontend/home/home.marko.js
[nodemon] matched rule: \*/.\*
[nodemon] changes after filters (before/after): 1/1
[nodemon] restarting due to changes...
[nodemon] application/frontend/home/home.marko.js
```
 @patrick-steele-idem Thanks you very much! All works fine :) :+1: But in previous version(2.x) i did not see this problem.
  Adds a submodule (`marko/express`) that provides an `injectInto` method that will add a `marko` method to the express response prototype.  We get access to express locals, and it automatically sets the content type of the request.
 This latest update removes the need to pass `express` to the submodule.  It is required from the parent module's context.  Test coverage has been increased as well.
  We need a way to disable `client-reorder` on all `<async-fragment>` tags.  This will be useful when serving content to bots/crawlers and users that might have js disabled.
  the if="conditional" attribute syntax is deprecated in v3
  #281 
  Hi,

I have a project where part of the content is inserted on a database using a CMS. That content sometimes have paragraphs. I tried to replace `\\n` (and others) with `<br>`, but then Marko replaces the `<` whit `&lt;` for security reasons I guess. How can I avoid that at least with some tags?
 For example:

**_data_**

``` json
{
    "name": "<br>Markojs"
}
```

**_marko template hello.marko_**

``` html
- Hello ${data.name}!
<span>Other text</span>
```

**_output html_**

```
Hello &lt;br>Markojs! <span>Other text</span>
```

> Hello &lt;br>Markojs! Other text

By default, all special HTML characters will be escaped in dynamic text to prevent Cross-site Scripting (XSS) Attacks. To disable HTML escaping, you can use $! as shown in the following sample code:
**_data_**

``` json
{
    "name": "<br>Markojs"
}
```

**_marko template hello.marko_**

``` html
- Hello $!{data.name}!
<span>Other text</span>
```

**_output html_**

```
Hello
<br>Markojs! <span>Other text</span>
```

> Hello
> Markojs! Other text

Ref: [Language Guide // Marko](http://markojs.com/docs/marko/language-guide/#text-replacement)
 Thanks a lot, I remembered to have read it somewhere but I couldn't find it.
  Adding some files to npmignore which are not required to be published to npm registry
  I am using Jade doc as a reference at the moment, they suggest using html tag directly for inline tags, does marko recommend the same strategy or does it have a better solution? eg.

```
p - hello there, <strong>username</strong>.
```

A demo on http://markojs.com/try-online/ would help. Currently the only demo with inline tags are using macro. I think it's an overkill to do this with macro.
 Ah interesting, so whitespace demo does sort of address my question, not quite sure what `---` stands for though.

http://markojs.com/try-online/#Whitespace_Simple
 Closing this as the answer is:

```
p
  - hello there,
  strong - username
  - .
```
  @patrick-steele-idem - Note, the error is misleading, as I just modified the existing template, however the hot reloader module, somehow looks for new compiled templates.

`Error: ENOENT: no such file or directory, open '/Users/prashjain/projects/xonyx/node_modules/lasso/head-116-3-26-29630-12vpaz3.marko'
   at Error (native)
   at Object.fs.openSync (fs.js:549:18)
   at Object.fs.readFileSync (fs.js:397:15)
   at loadFile (/Users/prashjain/projects/xonyx/node_modules/marko/runtime/loader.js:82:23)
   at load (/Users/prashjain/projects/xonyx/node_modules/marko/runtime/loader.js:124:16)
   at Object.load (/Users/prashjain/projects/xonyx/node_modules/marko/runtime/marko-runtime.js:295:33)
   at Object.marko.load (/Users/prashjain/projects/xonyx/index.js:21:18)
   at Object.Template.(anonymous function) [as renderSync] (/Users/prashjain/projects/xonyx/node_modules/marko/hot-reload/index.js:67:48)
   at Object.LassoPageResult.getHtmlForSlot (/Users/prashjain/projects/xonyx/node_modules/lasso/lib/LassoPageResult.js:111:25)
   at Object.LassoPageResult.getSlotHtml (/Users/prashjain/projects/xonyx/node_modules/lasso/lib/LassoPageResult.js:150:21)
   at renderSlot (/Users/prashjain/projects/xonyx/node_modules/lasso/taglib/slot-tag.js:35:36)
   at render (/Users/prashjain/projects/xonyx/node_modules/lasso/taglib/slot-tag.js:57:9)
   at render (/Users/prashjain/projects/xonyx/node_modules/lasso/taglib/head-tag.js:9:5)
   at module.exports.t (/Users/prashjain/projects/xonyx/node_modules/marko/runtime/helpers.js:284:13)
   at render (/Users/prashjain/projects/xonyx/src/pres/layouts/ryp/desktop/ryp-layout.marko.js:44:5)
   at Object.Template.render (/Users/prashjain/projects/xonyx/node_modules/marko/runtime/marko-runtime.js:192:9)
   at Object.Template.(anonymous function) [as render] (/Users/prashjain/projects/xonyx/node_modules/marko/hot-reload/index.js:72:34)
   at render (/Users/prashjain/projects/xonyx/node_modules/marko/node_modules/marko-layout/use-tag.js:14:20)
   at module.exports.t (/Users/prashjain/projects/xonyx/node_modules/marko/runtime/helpers.js:284:13)
   at render (/Users/prashjain/projects/xonyx/src/pres/pages/ryp/desktop/ryp-page.marko.js:40:5)
   at Object.Template.render (/Users/prashjain/projects/xonyx/node_modules/marko/runtime/marko-runtime.js:192:9)
   at Object.Template.(anonymous function) [as render] (/Users/prashjain/projects/xonyx/node_modules/marko/hot-reload/index.js:72:34)
`
  It's now out as "stable," and will be the LTS release come October. So here's a fun one:

``` bash
% npm test                                                                                                           

> marko@3.0.2 test /Users/jsumners/Projects/marko
> npm run init-tests && node_modules/.bin/mocha --ui bdd --reporter spec ./test && node_modules/.bin/jshint compiler/ runtime/ taglibs/


> marko@3.0.2 init-tests /Users/jsumners/Projects/marko
> ./test/init-tests.sh

/Users/jsumners/Projects/marko/node_modules/property-handlers/lib/index.js:21
                throw cause;
                ^

Error: Error while handling properties for <assign> tag in /Users/jsumners/Projects/marko/taglibs/core/marko.json: Error while applying option of "code-generator". Cause: TypeError: Path must be a string. Received undefined
    at assertPath (path.js:7:11)
    at Object.dirname (path.js:1324:5)
    at /Users/jsumners/Projects/marko/node_modules/raptor-modules/resolver/lib/serverResolveRequire.js:27:65
    at Object.find (/Users/jsumners/Projects/marko/node_modules/raptor-modules/resolver/lib/search-path.js:14:31)
    at serverResolveRequire (/Users/jsumners/Projects/marko/node_modules/raptor-modules/resolver/lib/serverResolveRequire.js:18:29)
    at Object.TagHandlers.codeGenerator (/Users/jsumners/Projects/marko/compiler/taglib-loader/loader-tag.js:175:20)
    at invokeHandlers (/Users/jsumners/Projects/marko/node_modules/property-handlers/lib/index.js:66:29)
npm ERR! Test failed.  See above for more details.
```
  I've created a few prototypes:
- Core marko generator project [link](https://github.com/BryceEWatson/marko-js-generator)
- Atom marko generator project [link](https://github.com/BryceEWatson/marko-js-generator-atom)

Having a separate core project allows use to centralized set of layout templates for ui components, and later, entire projects. The core is generic and doesn't contain any logic related to atom, but contains the templates (see example [here](https://github.com/BryceEWatson/marko-js-generator/tree/master/templates/ui-component)) and the logic needed to copy them to any destination path.

The atom project contains all the logic needed to surface the proper menu items, etc, and has the core project as a dependency (not implemented yet, need to npm publish).

Curious what everyone thinks of this approach, I think the core library starts to allow us to branch into other frameworks like yeoman, sublime, etc.
 @patrick-steele-idem Good points. I agree that the prototype is too rigid in enforcing .less, etc. Maybe we could add an option (to both core & atom projects?) to save a new template directory. The option could be surfaced in the atom in the right click menu, allowing the user to right click a module and select "Save as template". I'm not sure how simple this would be in practice, as dynamic data for module name would need to be included.

Also, yes I avoided yeoman this time. The last time we went down the yeoman path it became very tightly coupled to the framework. It's worth exploring a generic solution that uses atom-yeoman instead of ejs.

I also like the generic Generator option. This goes beyond simple marko support, and might overlap with some existing solutions. Will need to research this further.

Thanks for the feedback!
 I think it would be nice to make something like https://github.com/dsandstrom/atom-double-tag and highlight of closing tags for marko.
 @patrick-steele-idem thank very much now i am happy like a child :) for this features even vodka is not enough! Also i see some colors in syntax highlighting are changed for example < > and now it's much better. Good job!
 Didn't find such issue for Visual Studio Code, do you have any plans for it?
 @mlrawlings oh no what did I `commit` to ;)
  The only item from that list that I've found myself actively missing is "click to go to tag definition" (i.e. jump to custom tag template file) but the others would be great too!
 Many fullstack engineers use IntelliJ, so such a plugin would definitely make sense.
 Autocompletion of `${data.something}` would be great. Hopefully the tag attributes would autocomplete layout elements.
 Yes please! Also a default widget component files generator via right-click would be nice.
 Any update on this?
 Official website lists Webstorm integration, but link points to textmate:

http://markojs.com/docs/editor-plugins/
 Given the complexity of implementing this, anyone interested in such a plugin should also login to JetBrains's issue tracker and vote for the issue https://youtrack.jetbrains.com/issue/WEB-20821 Done  I am not sure what is this supposed to be: http://markojs.com/docs/marko-widgets/get-started/#widget-state

in the `getTemplateData` function there is an assignment to nothing to `style`:

```
getTemplateData: function(state, input) {
        var style = ;

        return {
            name: state.name,
            color: state.selected ? 'yellow' : 'transparent'
        };
    },
```
 https://github.com/marko-js/marko-widgets/pull/132 done
  Would it be better if the macro file: `helpers.marko` could be included in other files ? `custom-taglibs` is a little complicate for the beginners, IMO.
 Cool, this is more easy to understand than the doc. Thanks a lot.
  Example:

`<mywidget w-preserve-attrs="style,class" />`

Will result in the template compiler throwing the following error:

``` javascript
/webapp/node_modules/lasso/lib/dependency-walker.js dependency.getPackageManifest failed: Error: An error occurred while trying to compile template at path "/webapp/src/code/components/cover-profile/index.marko". Error(s) in template:
1) [src/code/components/cover-profile/index.marko:25:8] Unsupported attribute of "data-w-preserve-attrs" found on the <tinput> custom tag.

    at Compiler.compile (/webapp/node_modules/marko/compiler/Compiler.js:124:25)
    at /webapp/node_modules/marko/compiler/index.js:84:41
    at tryToString (fs.js:414:3)
    at FSReqWrap.readFileAfterClose [as oncomplete] (fs.js:401:12)
```
  This is my template:

```
<!DOCTYPE html>
    <html lang="en"> 
        <head>
            <title>Estimake.co</title>
            <include template="./partials/includes.marko" />
            <link rel="stylesheet" type="text/css" href="editProject.css">
            <script src="editProject.js" type="text/javascript"></script>
        </head>
        <body>
            <include("./partials/menu.marko", data)/>
            <include("./partials/footer.marko")/>
        </body>
    </html>
```

This is what I am getting when the template is rendered in v3.

`<ï»¿<!DOCTYPE html>><html lang="en"> <head> <title>Estimake.co</title> ... </body> </html></ï»¿<!DOCTYPE>`

Any idea why I have the 'strangeness' with the DOCTYPE?
 Ok, thanks. I tried yours and got the same issue 

'<ï»¿<!DOCTYPE html>></ï»¿<!DOCTYPE><html lang="en">'

but there must be something wrong with my installation, because apparently the original file should not have even compiled.

I take it from your answer that with 3.0 indention is now significant like with the Jade engine even with the HTML approach?
 Let me play around with my installation first. I won't to make sure I am not doing something stupid before I bug you about it. I am not sure how the first template compiled given the error in indention.

Thanks for your quick response.
    Howto reproduce:
1. Open the online "try-out" "Simple" example at http://markojs.com/try-online/ 
2. Modify the line 3rd line to add an attribute
`<li data-bind="\$foo" for(color in data.colors)>`
3. The expected output for the above is `<li data-bind="$foo">` but instead a syntax error occurs.

It works if the dollar-sign isn't escaped at all.
`<li data-bind="$foo" for(color in data.colors)>`

In marko-js pre v3 this worked as expected...
 Worth to mention is that the migration tool translates attr="\$foo" into attr="\$foo" which is not what is expected... 
 The migration script translates \$foo into double \ $foo

Since I'm using knockout js some special variables need to be prefixed with $, luke $parent and such. In this case the output needs to be attr="$parent" without any \
 Great, I will try it out in a couple of days!
 Thanks, the solution worked!
  when using the `require('marko').install()` the compiled files seem to cut the .marko extension from all require.resolve() calls.

When i have compiled using `$ markoc master.marko` my output contains:

```
navigation_template = loadTemplate(require.resolve("./components/navigation/template.marko"));
```

but when i have installed the node-require module, and simply required the template with 
`require('./src/master.marko')` the same line is:

```
navigation_template = loadTemplate(require.resolve("./components/navigation/template"));
```
 Sweet. As soon as that work as expected i think i have a functioning pull
request for markoify.

On 11 April 2016 at 16:41, Patrick Steele-Idem notifications@github.com
wrote:

> Thanks for reporting the problem. I'm looking into it.
> 
> â€”
> You are receiving this because you authored the thread.
> Reply to this email directly or view it on GitHub
> https://github.com/marko-js/marko/issues/262#issuecomment-208379670
 Ok, i will see if i can recreate it again.

On 11 April 2016 at 17:37, Patrick Steele-Idem notifications@github.com
wrote:

> @lohfu https://github.com/lohfu I was not able to reproduce the problem
> using a fresh npm install. I tried to recreate your setup and the
> template is compiling as expected:
> 
> function create(__helpers) {
>   var str = __helpers.s,
>       empty = __helpers.e,
>       notEmpty = __helpers.ne,
>       escapeXml = __helpers.x,
>       loadTemplate = __helpers.l,
>       navigation_template = loadTemplate(require.resolve("./components/navigation/template.marko"));
> 
>   return function render(data, out) {
>     navigation_template.render({}, out);
>   };
> }
> 
> (module.exports = require("marko").c(__filename)).c(create);
> 
> â€”
> You are receiving this because you were mentioned.
> Reply to this email directly or view it on GitHub
> https://github.com/marko-js/marko/issues/262#issuecomment-208405916
 Hey Patrick,

Yes i was. I created a repository at https://github.com/lohfu/marko-test.
Simply running `node server/server.js` will create a master.marko.js with

```
navigation_template =
loadTemplate(require.resolve("./components/navigation/template")),
```

On 17 April 2016 at 00:08, Patrick Steele-Idem notifications@github.com
wrote:

> Hey @lohfu https://github.com/lohfu, just wanted to check in and see if
> you were able to reproduce. Thanks.
> 
> â€”
> You are receiving this because you were mentioned.
> Reply to this email directly or view it on GitHub
> https://github.com/marko-js/marko/issues/262#issuecomment-210913456
  - Added ability to exclude specific node_module from marko-taglib.json lookup;
- Added tests for excluding specific directory and specific node_modules from marko-taglib.json lookup;
  Steps to reproduce
1. `require('marko/compiler').defaultOptions.writeToDisk = false;`
2. `require('marko/node-require').install();`
3. Create a custom tag that includes an instance of itself.

```
<li class=[data.page.name, data.currentPage.path === data.page.path && 'current']>
    <a href="${data.page.path}"><span>${data.page.title}</span></a>

    <if(data.page.pages)>
        <ul>
            <for(page in data.page.pages)>
                <navigation-item({ page: page, currentPage: data.currentPage })></navigation-item>
            </for>
        </ul>
    </if>
</li>
```
  I'm trying to do something very simple but I can't seem to get it to work. I have a basic template like this...

`<div>
   <customTag></customTag>
</div>`

And in custom tag's template I include another custom tag...

`<div>
    <customTag2></customTag2>
</div>`

And then finally, customTag2's template simply renders.

`I'm custom tag 2`

When I render all this, I end up with 

`<div>
   <div>
      <customTag2></customTag2>
   </div>
</div>`

It never renders customTag2. And I know the tag lib is found becuase if I go to my main template and include both custom tags, they both render, but not if they are nested. 

Am I doing something wrong? Or is including one custom tag in another's template not supported? Do I have to do the Parent/Child thing? I'd rather not since the child tag is intended to be used in many places.
 Sure, it's a pretty simple set-up.
- tags
  - customTag1
    - template.marko
  - customTag2
    - template.marko
- template
  - mainTemplate.marko
- Index.js
- marko.json

Here, the index file is rendering the ./template/mainTemplate.marko. The marko.json is as follows

`{
    "tags-dir": "./tags/"
}`
 No, sorry that's just my bad typing here. I fixed the above example.

It is strange because as I said, if I include both custom tags in the root template, they both render, it's only if one is nested inside the other that the inner template does not render.
 You are right, that works. It must be something with my set-up. I'll close this for now, since it is possible to do it, and I'll try to figure out where I messed up. :) Thanks for all the help!
   I feel there is not enough awareness out in the community about Markojs, nor is there a curated list of examples, articles, and good libraries from around the net. May there should be one ...
 I agree with this. For example, I think it would be really cool if there was an article showing how eBay leverages Marko for their main site 
 Since I suggested this, I really should join in the fun; I will be submitting libs, components, etc as I make them over the next couple of weeks. I will do my best to get some articles out about Markjs on my Medium blog.
 love it, will commit something when you define a format
 +1 I have been looking for UI kits such as vuematerial.github.io, vuetifyjs.com for marko but haven't found any so far. An awesome-marko repo would be very helpful to group all available resources under one page  In some of the custom elements I've written, I want to use different root elements based on the context. I want to put `w-bind` on these root elements. The content inside these root elements is the same across variations and I would like to use a macro to avoid repetition. However, when I try to use `w-body` in the macro, I get an error saying that w-body can only be used inside a element with w-bind. This prohibits my ability to use a macro to render the content.

What is the best way to pass a rendered body to the macro?
 Thanks for the suggestion. I'll try it.
 @mlrawlings I tried the technique you suggested and the element renders correctly. However, the new element is not bound. 

With this template:

```
<${data.tag} class=data.classes w-bind >
  <div class="content">
    <invoke data.renderBody(out) />
    <div class="sub header" if(data.subheader)>${data.subheader}</div>
  </div>
</>
```

I get:

```
<h2 class="ui-heading" w-bind>
<div class="content">My Header</div>
</h2>
```

And when I use `w-body` instead of `<invoke data.renderBody(out) />` I still get a compile error complaining about w-body without w-bind.

Let me know if I missed something that enabled the suggestion to work.
 Works like a charm. Thanks!
  I just migrated to v3 and now only custom taglibs in the same directory as the page are resolved.

Here's a sample of the directory structure:

```
root
   package.json
   marko.json
   node_modules
   plugins
      components
         my-hello
             template.marko
      pages
         test
            page.marko
```

`marko.json` has:

```
{
  "tags-dir": [
    "./plugins/components"
  ]
}
```

I can get the `my-hello` custom tag to render in `page.marko` only when it and marko.json are located in `/plugins/pages/test`.

I believe related to this issue, `<init-widgets/>` and `<browser-refresh/>` don't render either. They appear as tags in the outputted page. 

It was my understanding that marko would walk up the directory tree from the page to the project's root looking for marko.json. Once found, it would use marko.json to pull in any custom tag definitions. I'm not sure what changed with v3.
 Walking up the directory tree from plugins/pages/test, I only have package.json at the root. Some of the other plugins have a package.json file but they are not parents of the test page. 

Did this behavior change between v2 and v3? I ask because in the v2 version of the repo Iâ€™m working on I have a page directory with a package.json and everything is working fine.

From:  Patrick Steele-Idem notifications@github.com
Reply-To:  marko-js/marko reply@reply.github.com
Date:  Sunday, March 20, 2016 at 1:40 PM
To:  marko-js/marko marko@noreply.github.com
Cc:  Todd Bashor tbashor@gmail.com
Subject:  Re: [marko] Custom taglibs not found after migrating to v3 (#252)

@tbashor by any chance, do you have any intermediate package.json files? The taglib finder stops when it gets to the "root" of the package? The root of the package is determined by looking for a package.json file with a "name" property. I suspect that the search for taglibs is being ended prematurely due to the root directory not being as expected. FYI, here is the code that is used to discover taglibs for marko: https://github.com/marko-js/marko/blob/master/compiler/taglib-finder/index.js

Please let me know if that is the case. Thanks.

â€”
You are receiving this because you were mentioned.
Reply to this email directly or view it on GitHub
 @patrick-steele-idem You were right that there was a package.json stopping the lookup. I'm still having trouble getting the lasso tags to resolve, but I think that has to do with my particular setup. Thanks for your help.
  Currently rendering a template returns an `AsyncWriter`, it would be handy though if when a callback is omitted that templates render function returned a promise.

``` js
var template = require("template.marko");

template.render({ hello: "world" })
    .then(function (html) { ... })
    .catch(function (err) { ... });
```

If you're using promises already it makes using marko a bit easier.
 You can use temporarily **bluebird** module.

```
let Promise = require('bluebird');
let EntryCommentsMarkup = require('./views/EntryComments.marko');
Promise.promisifyAll(EntryCommentsMarkup);
```

then in routing we invoke **renderAsync** method:

```
app.get('/example', function(req, res) {
    let Data = { ... };
    return EntryCommentsMarkup.renderAsync(Data)
        .then((markup) => res.status(200).json({ markup: markup }))
        .catch((error) => res.status(400).json({ message: error.message }));
});
```
 A bit late, just throwing this out there: The Promises/A+ specification requires that if the result is an `object` or `function` with a `then` method, it _must_ be treated as a "thenable". In other words, this solution is explicitly permitted by the specification, and any `Promise` library which doesn't handle this correctly is - by definition - "broken". That's all, carry on. :)
  This pull request fixes a case wherein if `renderSync` receives no context then it will still render the template. Currently, if you don't supply at least an empty object (`{}`) then `renderSync` bombs with an error like:

```
Debug: internal, implementation, error 
    TypeError: Uncaught error: Cannot read property '$global' of undefined
    at Object.Template.renderSync (/some/project/node_modules/marko/runtime/marko-runtime.js:109:17)
    ....
```
 Excellent. Thank you.
  I am building a reusable component "data grid" using marko templates.

The component renders set of passed data in html `<table>`. The component internally supports couple of cell renderers which injects content inside `<td>`.
1. Text - for displaying paragraph of text/ list of links
2. Image - for displaying an image

I would also like to allow clients to configure custom cell renderers if you they choose to implement something on their own.

I don't see a way to invoke templates dynamically. As expected `<include>`  directly invokes the template and don't execute the renderer.

Am I missing something?

 **P.S:** I am using marko-v2 and this component is server side rendered.
 :+1: 

Thanks @patrick-steele-idem.
 ðŸ‘ Looking forward to Marko v4.
  `<invoke console.log(someData)/>`

This is good, but it could be much better. :smile: 

Some thoughts on creating a debugger:
- Pretty printing to the browser
- Additional information about the data (object type, length of the data)
- processing time
- the template path in which the debugger it's called
- limiting the debugger to only show in non-prod environments (don't know if this is possible, but ... would be nice)
- etc.
 I've seen at least a few other major projects add HTML comments like that to their output for various reasons, including debugging. Angular even uses a similar syntax to bind code to the DOM (`<!-- ngRepeat: post in posts -->`). On the other hand, element attributes might provide some benefits that comments couldn't, especially within the parser/compiler/renderer, as they would be assigned directly to the relevant AST nodes - though the idea of using element attributes (which are usually supposed to affect something) to display debug information (which is never supposed to affect anything) is a bit unnerving.

What about something in-between? Throughout the parsing/compiling/rendering process the debug information could be stored in a property on the relevant AST node - or _maybe_ in a parent node similar to an HtmlComment element, or perhaps even some combination of the two - then eventually rendered as HTML comments like in the example above. Then tools could be written to simply hook into the property/node to extract debug information during the compiling and rendering processes, and there would also be helpful HTML comments in the final output.

Special debugging tags and attributes could also be added, like `debug=true` to toggle verbose debugging on specific element trees, `debug-render-time` to track and report how long nodes take to render, and _maybe_ even something like `<observe(someData)>` to watch an object for changes, just to name a few. If all of this was handled by the special debug property/node, and only when some special flag (like `DEBUG=marko` or `--debug`) is detected, I would think this could be implemented without too many side effects. Thoughts?
  # Example

## Install hapi and marko

```
[sudo] npm install hapi --save
[sudo] npm install marko --save
```

## _directory structure:_

```
â”œâ”€â”€ hapi-marko/
â”‚   â”œâ”€â”€ public/
â”‚   â”‚   â”œâ”€â”€ assets/
â”‚   â”‚   â”‚   â”œâ”€â”€ css/
â”‚   â”‚   â”‚   â”œâ”€â”€ js/
â”‚   â”‚   â”‚   â”œâ”€â”€ img/
â”‚   â”‚   â”œâ”€â”€ resources/
â”‚   â”‚   â”‚   â”œâ”€â”€ errors/
â”‚   â”‚   â”‚   â”‚     â”œâ”€â”€ 404.marko
â”‚   â”‚   â”‚   â”œâ”€â”€ partials/
â”‚   â”‚   â”‚   â”‚     â”œâ”€â”€ aside.marko
â”‚   â”‚   â”‚   â”‚     â”œâ”€â”€ footer.marko
â”‚   â”‚   â”‚   â”‚     â”œâ”€â”€ header.marko
â”‚   â”‚   â”‚   â”œâ”€â”€ template/
â”‚   â”‚   â”‚   â”‚     â”œâ”€â”€ master.marko
â”‚   â”‚   â”‚   â”œâ”€â”€ index.marko
â”‚   â”œâ”€â”€ index.js
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ README.md

/public/assets
Web resources that are publicly available (css, js, img, fonts)

/public/resouces
Server and browser-side templates

index.js
Application entry point
```

## Server side rendering

**_index.js_**

``` js
const Hapi = require('hapi'); 
// The following line installs the Node.js require extension
// for '.marko' files. Once installed, '*.marko' files can be
// required just like any other JavaScript modules. 
require('marko/node-require').install();

// If true(the default)then compiled templates will be written to disk. If false,
// compiled templates will not be written to disk (i.e., no '.marko.js' file will
// be generated)
require('marko/compiler').defaultOptions.writeToDisk = false;

const server = new Hapi.Server();
server.connection();

//Load template
const index = require('./public/resources/index.marko');

server.route({
    method: 'GET',
    path: '/',
    handler: function (request, reply) {

        index.render({'message': 'hello world!'}, reply);
    }
});

server.start( () => {
    console.log('Running at:' + server.info.uri);
});
```

**_index.marko_**

``` html
<layout-use template="./template/master.marko" show-header="$true">
    <layout-put into="content">
       <div >${data.message}</div>
       or
       <div >$data.message</div>
    </layout-put>
</layout-use>
```

**_master.marko_**

``` html
<!DOCTYPE html>
<html lang="es">
    <head>
    </head>
    <body>
        <div id="layout">
            <aside>
                <include template="../partials/aside.marko"/>
            </aside>
            <section class="section">
                <layout-placeholder name="content" />
            </section>
        <footer class="footer">
                <include template="../partials/footer.marko"/>
        </footer>
        </div>
    </body>
</html>
```

**_header.marko_**

``` html
<div>header content</div>
```

**_aside.marko_**

``` html
<div>aside content</div>
```

**_footer.marko_**

``` html
<div>footer content</div>
```

### execute

```
node index.js
```

### Open your browser and visit http://localhost:8000

#### gives the following output

```
aside content
hello world!
or
hello world!
footer content
```

### Clone the example

[example-hapi-marko](https://github.com/davidenq/example-hapi-marko)
 I'm agree. I'll work on a new tutorial. Have a great weekend!
 If you want to adjust the response type:

``` javascript
server.route({
    method: 'GET',
    path: '/',
    handler: function (request, reply) {

        reply(index.stream({'message': 'hello world!'})).type('text/html');
    }
});
```
 Both `.render` and `.stream` are very useful, However they are deprecated. Is it OK to still use them with hapi? Is there a better option?
 No, they aren't.

http://markojs.com/docs/marko/javascript-api/#streamtemplatedata--streamreadable
is not
http://markojs.com/docs/marko/javascript-api/#streamtemplatepath-templatedata--streamreadable
 FYI -> https://github.com/hapijs/vision/pull/111  `<marko-compiler-options>` shouldn't add a newline to rendered output because it's an option to the compiler, not part of the template at all. So it shouldn't cause any side-effect in the output.

I was about to submit a PR with a fix, but @patrick-steele-idem said in gitter:

> The marko compiler allows certain nodes/tags to be marked as "noOutput" so that they get ignored when applying whitespace removal rules. We probably just need to set that flag for the <marko-compiler-options> tag. We should add a test case to verify.

So that's a better solution. I was also trying to provide a PR for this, but i have no idea about how to do it.

I was about to add `el.noOutput = true;` below line 138 in [Parser.js](https://github.com/marko-js/marko/blob/master/compiler/Parser.js#L138), but i think the PR shouldn't/wouldn't be accepted like that.
  Somewhat related to #235, what do you think about defaulting to a template file without the name `template.marko` if it is the only one in that directory level?

Currently I avoid naming my templates `template.marko` because file navigation is much quicker if I name it after the component. So my component naming tends to have some duplication (`component.marko` `component.js` `component.less`) but allows me to easily jump to files without having to type `component/template.marko` in navigation commands.

However, I end up having to copy paste tons of `index.js` files like so:

``` js
'use strict';

var template = require('./component.marko');

module.exports = function render(input, out) {
    template.render(input, out);
};
```

It would be nice if marko could discover these automatically since it is the only template there anyway.
 Yep, that's exactly what I do. So in my case, matching the directory name would be enough. I actually only follow this convention for my own personal projects. For larger projects with more people, I follow the standard convention for the reasons you mentioned - while suffering through slower file navigation.

It's fairly simple to work around this, but I think it would be nice if marko was slightly less opinionated on file names. Looking for `template.marko`, then `dir-name.marko`, before finally looking through the templates in the directory, might be a nice way to optimize for the primary cases. I guess it depends how much magic we want vs. config.
 That's true on the first point. Since about half my components have renderers and half have templates, I set them all up as renderers for "consistency," although it could really go either way. 

When I used Atom, I did notice that the fuzzy autocomplete was pretty good. But for a bunch of other reasons, I've gone back to Webstorm for now. Webstorm isn't as good with directory matching and I would to type `full-directory-name/t` to get to the template.

Regarding the `js` naming - my own personal convention is to use marko defaults when needed on the server like `index.js` `renderer.js`, but to use component name for client side js - `component.js`. You're right that having a lot of index files is a bit awkward considering my other file names, but that's more part of node.js than Marko. This convention does help me differentiate server/client a bit better.

On the last point, I'm not sure. I think as long as Webstorm autocomplete stays the way it is, it is significantly faster for me to keep my current naming conventions. If I move back to Atom, then the point is moot. Sucks to make IDE-specific decisions, but I just really hate typing out long directory names, and the other benefits of Webstorm over Atom (in my opinion) keep me there.
 Wanted to add that in playing around with this some more, you do have to type the `/` but not the entire folder names in Webstorm. So it's not quite as bad. I still think some flexibility might be nice here regardless.
 I've since moved to generic file names in components (and haven't had any issues with quick navigation in VS Code). We can close this, unless you were still considering expanding auto-discovery.
  In one of my projects, I use `short` and `long` for property names in objects (I didn't realize these were technically reserved). It turns out that these fail in Marko v3 when used as `${data.short} and ${data.long}` in a template. It's worth noting that this is server-only since I'm not using marko widgets in this case.

Apparently, these two keywords, along with a host of others, are no longer reserved as of ES5. So if that's all it is I'm happy to submit a quick PR to update https://github.com/marko-js/marko/blob/master/compiler/util/javaScriptReservedWords.js to the ES5 list. Just wanted to check if there were any concerns in doing that, or if you prefer to keep pre-ES5 list.

If this is intentional (and that we're also intentionally disallowing property names as reserved keywords for IE8 support in case the template goes to the browser), maybe we should have an option to disable such behavior.
  For custom dynamic tags, I have a function using the `try-require` module that works as follows:

```
function loadRenderer(path) {
    var renderer = rendererCache[path];
    if (!renderer) {
        renderer = rendererCache[path] = tryRequire(path) || 'not-found';
    }
    return renderer;
}
```

I then use this to determine whether to require a renderer or a template:

```
    if (!isWidget && !widgetId) {
        module.type = 'renderer';
        module.renderer = loadRenderer(path.join(modulePath, 'renderer.js'));
        if (module.renderer === 'not-found') {
            module.template = loadRenderer(path.join(modulePath, 'template.marko'));
            module.type = 'template';
        }
    }
```

This works fine normally, but in functional tests through karma, it looks like the runtime is attempting to resolve `not-found` to a module. This results in the following error:

```
Cannot find module "not-found" from "/$/marko/runtime"
    require@.../.test/static/node_modules/lasso/node_modules/raptor-modules/client/lib/raptor-modules-client.js:568:52
    instanceRequire@.../.test/static/node_modules/lasso/node_modules/raptor-modules/client/lib/raptor-modules-client.js:113:75
    load@.../.test/static/node_modules/marko/runtime/loader_browser.js:21:19
    load@.../.test/static/node_modules/marko/runtime/marko-runtime.js:295:39
    l@.../.test/static/node_modules/marko/runtime/helpers.js:197:36

```

I tried setting renderer to a handful of other types based on the relevant marko code, but ran into different issues each time. Do you know how I could effectively make this a no-op? Or if there is a better way to achieve the same thing?
 I think you're right - and I think it's because of https://github.com/marko-js/marko-widgets/issues/130
Looks like I might need to artificially require everything that goes through `dynamic-tag`
  If you don't have an `index.js` file, it defaults to the template. But it should search for other possible renderers, such as a `index.coffee.js` file before defaulting to the template.
  Cool concept @patrick-steele-idem 

I think it greatly improves the expressiveness of Marko templates.
Love the idea that you can make a very generic template more 
specific by importing it into another template and giving it an alias!
So yeah, I would love to have them.

Just some thoughts:
1. Function wise, nothing is added - basically one could do the same
by simply using the name of the custom tag as it has been done until know (probably surrounded
by a `<if>` clause) - the dependencies would be resolved by lasso and the compiled 
code for both templates would be available in the client package...
The difference here is compile time; right? - anything else to differentiate (probably from a user perspective)?
2. Is there a specific reason not to use a syntax like:
`<import-tag componentA="component-a">`

Great concept!
 In my case I have 15 components which I want to call dynamically. When there were only a few components, just using `<if>` works fine. But with a large list, it becomes pretty tedious. I don't think this is too far out of an edge case, since we are encouraging the use of lots of small components.

So I ended up invoking renderers directly and then passing them through a `<dynamic-tag>` component, which cleans up the `marko` files quite a bit, but also leaves implementation to the user (handling templates, renderers, widgets without ids, widgets with ids, etc., all of which marko should already know how to do). But applying that case here, I'm not sure this new feature helps too much. It would mean 15 lines of importing components directly by name.

Can we ever resolve the tags later to be fully dynamic?

```
<import-tags "data.tags" as data.names>

<for each="name in names">
    <invoke-tag(name, { name: 'Frank', count: 30 })/>
</for>
```
 I think we could implement this and #172 with a similar syntax:

``` xml
<import(<tag-name> from './component')/>
```

Then just use it:

``` xml
<tag-name/>
```

And for es2015 style inputs (#172):

``` xml
<import({ dedupe } from './utils')/>
```

And they'd look slightly nicer without the argument parentheses:

``` xml
<import <tag-name> from './component'/>
<import { dedupe } from './utils'/>
```
 @philidem I've been playing with the parsing, from here it should be pretty trival to generate the necessary AST nodes: https://tonicdev.com/mlrawlings/573b709ca492941100e1140e
 As Yoni mentioned, the real value in this is to have something like:

``` html
<for(card in model.cards)>
  <${card.name} model=card />
</for>
```

I would think the name could be resolved and the component found from the `marko.json` file. Are there any major issues with that I'm missing?
  Awesome! :tada: 
  Hi all,

It seems that after a few different implementations of basic w-onClick, it does not work on mobile or tablet devices at all; the event/function attached to it simply does not fire at all. I'm not really sure what else to put here, other than to try it yourself and see the issue firsthand :+1: 
 This probably relates to how mobile browsers detect clickable elements. For example, iOS Safari has some quirks:
https://developer.apple.com/library/ios/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html
http://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html

I wonder if marko-widgets should try to handle this at all.
 Related: https://github.com/facebook/react/issues/134
  It is my understanding that should be able to change the tagName of an element at the transform stage and have it trigger a code-generator/renderer at the generate stage, but this does not appear to be the case.  Am I doing something wrong? Is this expected behavior? A bug?

NOTE: This is on the lastest version of the `htmljs-parser` branch.
# Setup

_index.js_

``` javascript
require('marko/node-require').install();
require('./test.marko').stream().pipe(process.stdout);
```

_marko-tabglib.json_

``` json
{
    "<new>": {
        "code-generator":"./test-generator"
    },
    "<*>": {
        "transformer":"./test-transformer"
    }
}
```

_test-transformer.js_

``` javascript
module.exports = function transform(el, context) {
    console.log('CALLED TRANSFORM')
    if(el.tagName !== 'new') {
        if(el.getAttributeValue('transform')) {
            el.setTagName('new')
        }
    }
}
```

_test-generator.js_

``` javascript
module.exports = function codeGenerator(el, codegen) {
    console.log('CALLED GENERATOR')
    el.removeAttribute('new')
    return el
};
```
# Test 1, unexpected

Rendering the following template:

_test.marko_

``` html
<div transform=true />
```

I get the **output**:

```
CALLED TRANSFORM
<new transform></new>
```

But I'm **expecting**:

```
CALLED TRANSFORM
CALLED GENERATOR
<new></new>
```
# Test 2, working as expected

If I change the template to use the `<new>` tag initally I do get the expected output:

_test.marko_

``` html
<new transform=true />
```

**output**:

```
CALLED TRANSFORM
CALLED GENERATOR
<new></new>
```

The node still goes through the transform function, but it is not touched.  I'm guessing this is the difference.
 Makes sense.  Thanks for clarifying, and the `replaceWith` method is much appreciated!
  ```
exports.taglibs.registerTaglib(require.resolve('../taglibs/core/marko-taglib.j
                                       ^
TypeError: undefined is not a function
```

Code snippet from `marko/compiler/marko-compiler`:

```
exports.TemplateCompiler = require('./TemplateCompiler');
exports.taglibs = require('./taglibs');
exports.taglibs.excludeDir(nodePath.join(__dirname, '../'));

exports.taglibs.registerTaglib(require.resolve('../taglibs/core/marko-taglib.json'));
exports.taglibs.registerTaglib(require.resolve('../taglibs/html/marko-taglib.json'));
exports.taglibs.registerTaglib(require.resolve('../taglibs/caching/marko-taglib.json'));
exports.taglibs.registerTaglib(require.resolve('marko-layout/marko-taglib.json'));
exports.taglibs.registerTaglib(require.resolve('marko-async/marko-taglib.json'));
```

While doing: 

```
browserify --node -t reactify -t markoify -o dist/server.js build/source/server.js
```
 I don't want any external npm packages hanging out on an application server.
 Is there a way to exclude the marko-compiler from being bundled? Can I only bundle the Marko-runtime, and precompile the Marko templates in Gulp or something?

Here is my implementation:

```
import Marko from 'marko';

...
...

app.use((req, res) => {
    Marko.load('./views/index.marko', { writeToDisk: false }).stream({
        props: JSON.stringify(props),
        reactOutput,
        title: 'Site Title Here',
    }).pipe(res);});
});
```
  ```
Error: Cannot find module './raptor-logging-impl'
    at Function.Module._resolveFilename (module.js:336:15)
    at Function.Module._load (module.js:278:25)
    at Module.require (module.js:365:17)
    at require (module.js:384:17)
```

Offending code snippet:

```
module.exports = stubs;

if (!process.browser) {
    var implPath = './raptor-logging-impl';
    require(implPath);
}
},{}],497:[function(require,module,exports){
(function (__dirname){
```

Here is my build script:

```
browserify -t markoify --node -t reactify  -o dist/server.js build/source/server.js
```

Dependencies in `package.json`:

```
"dependencies": {
    "browserify": "^12.0.1",
    "browserify-shim": "^3.8.11",
    "bunyan": "^1.5.1",
    "bunyan-request-logger": "^1.0.2",
    "express": "^4.12.4",
    "markoify": "^1.1.2",
    "react": "^0.14.0",
    "react-dom": "^0.14.5",
    "react-tools": "^0.13.3",
    "reactify": "^1.0.0"
  },
```
 @patrick-steele-idem awesome, thanks. Browserify supports building server-side modules, it just requires some clever configuration, which is actually not fully adopted by browserify but seems to work for most applications.

My motivation here is to bundle all of my server side code to one file to make deploys easier, and save space on hosting instances.
 Fixed, but spawned this issue:

https://github.com/marko-js/marko/issues/213
  Is there clamoring for jade-like syntax? I guess the current HTML-like syntax makes marko somewhat opinionated, but I didn't think that was problematic.
 I agree with your main points - I think as long as the new parser is generic enough to easily support multiple syntaxes, neither fragmentation nor maintenance costs should really be an issue. `jarko` sounds funny too, so that's a plus.
 I dunno. Back in my day we didn't need these newfangled languages to write HTML. We wrote our `<blink>` tags uphill both ways and we never complained about it. :stuck_out_tongue: 

In all seriousness though, the development cost of supporting another dialect is something that should be well considered. I'd really hate to see Marko development slowed or delayed due to the support of a (fringe) dialect. Yeah, I said it.

Also, consider that Marko is already an HTML-_like_ syntax, and it sounds like you'd be creating a "jade-_like_" syntax. Since Marko is an abstraction of HTML, and Jade is _already_ an abstraction of HTML, Jarko would therefore be an abstraction of an abstraction. Talk about fringe.

Sass (or Less) is a good example of a useful abstractionâ€”the benefits of using Less or Sass to write CSS are huge (variables, nesting, extensions, modularization)â€”and they are still mainly pure CSS at their core. But with Jade, you're basically just talking about laziness and simple dialect. I don't see the benefit beyond the popularity/adoption points. Just my 2Â¢.
 +1 [Btw the name Jade is changing to Pug with v2](https://github.com/pugjs/jade/issues/2184) so jarko might not be a good idea. Also I think this concise syntax is a lot different from Jade (better in that sense), so it shouldn't be named after it, it should have its own identity. "concise-marko" sounds perfect. or if it's too long, maybe "cmarko"?
 .pugo

Just kidding. Mug is better.
 Following the discussion, I want to add a few pros/cons I have found... (some are already mentioned)

Pros:
1. Gain additional attraction from the dev community; Everything that looks familiar will improve the adoption rate of Marko - as Marko is still growing, this is important
2. Makes life easier by putting over legacy code written in Jade; we all know that putting something over without changes seldom works flawlessly... but it should be less work than porting over existing markup into Marko v3....
3. Easy to get started for people who worked already with Jade... similar to point 1.

Cons:
1. "Readability" While Jade offers a sparse syntax, I do not really think it offers much more "readability" than Marko v3... I think template statements do not really "raise from the environment"; it makes it really hard to see what is really going on without looking at it in detail... on the other hand, Jade might reduce "noise" by having less stuff that has to be written ("<", ">"...) - it both has its advantages...
2. "Fragmentation" what are the examples written in - with JavaScript server and client side we left the times when there were different languages (and the mental overhead between switching between them). Now with different template languages we kinda "sacrifice" that...
3. Implementation (+ testing) overhead + maintenance... strongly depends how it is implemented... I am confident that the Marko devs can do a great job here.... but it should be considered nevertheless....

Marko v3's main selling point is "as close to HTML" as possible... one could ask if this is really "enough" to have it... why not consider Jade-like as the only template syntax? If there will be a way to easy auto-convert Marko v3 into Jade (and back?) why not have jarko the only syntax and allow people to auto convert over Marko v2 into Jarko (if compatibility is an issue)?
 > why not consider Jade-like as the only template syntax?

Please, no. Abstraction languages come and goâ€”they are in a sense fads. HTML is universally known and familiar to most developers.
 I'm with @danrichman. I think ditching the proper HTML-like syntax all together would be a mistake, at least at this stage. That said, I'm all for giving the jade-like syntax a go. If you can bake both of them into a universal Marko compiler, I think it's going to be a really great move @patrick-steele-idem. Let people decide how they want to use Marko.

There are some drawback's you guys might want to consider though:

(1) As Marko matures and the user base grows, the ambiguity of questions online could get quite confusing for developers. Consider someone researching how to do something in Marko, and they scour through StackOverflow, videos, blog posts etc... 50% of answers with one syntax, 50% with the other syntax. People are going to end up with some kind of psuedo marko language in their app, where they have a mixture of the compact syntax and traditional syntax. That's a bad experience for everyone.
(2) More documentation, and it's going to have to be really well written to avoid confusion.
(3) Ultimately there's probably going to have to be two seperate docs - one for traditional Marko, the other for compact.

I think you can get around both of those issues with really well defined documentation, and pushing out the message early on that there's two syntax options with Marko. But for that to happen, we all need to be up for that challenge. Personally I hate Jade syntax with a passion, but damn, it's 2016. I'll willing to give new things a try.
 Just to be clear:

Having Jade-like (jarko/mug) as the default would mean to prepend every plain text with a specific well-defined symbol (e.g. a dot)... otherwise plain text would be mis-interpreted as a tag (original Jade uses pipes for plain text)

Regular HTML like syntax would of course be allowed as well (and mixed in within jarko):

```
. This has to be prefixed
<div>
  No worries here
</div>
```
 Jade is a rabbit hole. Could be a third-party option, but as a core feature? I dunno. One of the selling points of Jade, according to [its own website](http://jade-lang.com) is...

> Jade is a terse and simple templating language with a strong focus on performance and **powerful features**.

This is a good reason to _avoid_ Jade actually. Something more powerful is always coming along. Why would we want more powerful features if Marko is intentionally trying to adhere to the _Rule of Least Power_?

> **The Rule of Least Power**
> http://www.w3.org/2001/tag/doc/leastPower
> 
> When designing computer systems, one is often faced with a choice between using a more or less powerful language for publishing information, for expressing constraints, or for solving some problem. This finding explores tradeoffs relating the choice of language to reusability of information. The "Rule of Least Power" suggests choosing the least powerful language suitable for a given purpose.
> 
> [...]
> 
> **Good Practice:** Use the least powerful language suitable for expressing information, constraints or programs on the World Wide Web.

I was under the impression that Marko was designed to adhere to the _Rule of Least Power_. By promoting Jade, it's no longer adhering to that rule.

See also:
- [We need less powerful languages](http://lukeplant.me.uk/blog/posts/less-powerful-languages/) by [Luke Plant](http://lukeplant.me.uk/)
- [In Defense of Templates](https://www.youtube.com/watch?v=VY-r7Ac06ho&feature=youtu.be&t=498) (YouTube clip) by [Tom Dale](http://tomdale.net/)
 @patrick-steele-idem Isn't there more to Jade than that? Conditionals, extends, etc. Wouldn't Jade developers just end up demanding those more powerful features?
 I meant that by supporting the Jade syntax, you're going to open yourself up to demands for supporting the specific (less clean) Jade-forms of those and other featuresâ€”particularly as Jade becomes more complex over time. I don't know how this would be avoided. At some point, you know someone is going come along and demand more support for the Jade syntax to trigger those various features.

As in..

> Hey Patrick, if would be great if the Jarko syntax could do XYZ just like in Jade.

It's a slippery slope. Where do Marko devs draw the line? Can I get a nickel for each such request? :)
 Just chiming in.. Please avoid overcomplicating marko at all costs, keep the core simple then allow extension if desired. I won't be using any of the html-like syntax anyway, in our environment the users specify mark-up over which we have no control, we will just be exposing widgets for them to hook into using attributes.
 For what it's worth, some opinionated Angular devs seemed to beÂ largely against the idea of using Jade in Angular. For starters, they say mixing the two syntaxes in Angular documentation, examples, and in templates is _way_ more confusing than the simplicity that the syntax is supposed to provide in the first place.

See: [What's the use of Jade or Handlebars when writing AngularJs apps](http://stackoverflow.com/questions/18174856/whats-the-use-of-jade-or-handlebars-when-writing-angularjs-apps)

> **Q:** "...As far as I can tell, it would make most sense to create the templates in Angular using proper HTML...The reason for this confusion is that a lot of the examples I find on GitHub make use of Jade, and it seems counter intuitive for me."
> 
> **A:** Those who _unquestioningly_ favour Jade in an Angular environment fail to understand that view logic belongs on the client, and business logic on the server, just as the OP commented.
> 
> _Don't do it unless you have a very good reason to do it_. In engineering, a system with fewer moving parts is a more reliable system, and a system where interface boundaries (client/server) are respected is more maintainable over the long term, so default to the simplest architecture and clean division of labour if possible. If you have overriding reasons, do what you must, but _caveat emptor_.
> 
> Recently I reviewed some code where straight Angular templating would have done a far better job than mixing in Jade, just through maintaining simplicity.
> 
> Aside from template extension, Jade brings nothing worthwhile to the table that Angular doesn't already supply. Let's be honest: Using the sound principle of "favour composition over inheritance" (i.e. partials), you shouldn't ever need template extensibility. Jade is hardly "easier to parse" than HTML. They are but _trivially_ different, while Jade adds another level of indirection - best avoided.
> 
> There is one valid, specialised case for server-side templating: Optimisation, remembering that premature optimisation is generally a Bad Thing. Where performance is truly at issue, and you have the server capacity to spare to handle this, server side templating can assist. This applies to products like Twitter and Basecamp, where the cost of doing a lot of server side work is offset by the gains of reduced requests to the server.
 I just wanted to chime in on our team and experience with marko. We like marko and what it offers, but we were definitely _not_ a fan of the syntax when we started using it. I think it would be a much more enjoyable experience to have the concise syntax, as you are putting it.

I also don't think it would be a slippery slope to supporting all jade features. The biggest gripe is that it is a pain to write in and look at, especially as files grow in size and complexity. That is why languages like jade and haml are so popular. I don't think I've used marko and ever thought "this could use some more features from _x_ language". I have thought, however, that the template looked cluttered and hard to read/scan. But then again, I've used haml and jade for years, so the HTML like syntax seems like a step backward to me.
 @patrick-steele-idem  :+1:  thanks for experimenting with real-world examples! Curious about the outcome.
 Here's the rub.. Less and Sass are similar abstractions of CSS. Yet, [neither abstraction is a core plugin of Lasso](https://github.com/lasso-js/lasso#available-plugins) despite the fact that every front-end developer will tell you that Less and Sass make CSS so much easier to manage. And it's not a problem since any developer can just install [lasso-sass](https://github.com/lasso-js/lasso-sass) or [lasso-less](https://github.com/lasso-js/lasso-less)....or [lasso-jade](https://github.com/lasso-js/lasso-jade) (for JS) if they prefer.

So, why would Jade for Marko be any different? Why not just make it a third-party plugin? (If it becomes crazy popular, then maybe one day it becomes a core plugin).

If Jade were a core feature (never mind it's an added layer of architecture to maintain), then the question is where does that leave all the documentation, tutorials and shared examples? Do you have a competing ecosystem of documentation?

> I'm starting to feel that the concise syntax is something that can grow on you, but that most people (me included) initially dislike it

I think this is probably the key point here, if anything. Anything distasteful will grow on you, eventually. Jade is being added to make Marko more accessible _to the Jade crowd_.

But, by making it a core feature, the risk is perhaps making Marko initially disliked by the majority of non-Jade users, which would be counterproductive. I suppose Jade could be generally avoided in the documentation, but then what's the point of having it be a core feature in the first place?

If the only reason for adding Jade-like syntax is to appease the population of Jade developers, then that implies that Jade would make a very good non-core plugin. Wouldn't that make everyone happy? People who want Jade can easily install the plugin and people who don't just follow the documentation and the HTML they are familiar with (without the mysterious `.` before lines of text to turn off the seemingly non-essential Jade syntax).

If the Jade-like syntax were the _de facto_ syntax, then that would imply that the documentation, tutorials and shared examples would all be in the Jade-like syntax or some confusing mixture of the two. But, of course, doing so would turn off all the people who dislike Jade at first glance (yourself included). Is it worth it to make it a core feature then? I dunno. Seems like a third-party plugin to me, just like [Less or Sass is for Lasso](https://github.com/lasso-js/lasso#available-plugins).
 @danrichman I like that idea. If templating syntax can be abstracted out into a plugin, then marko could ship with the `html-syntax` plugin by default. Developers could install `jade-syntax` which would be responsible for its own documentation and maintenance. Plus, there is some room to experiment with new syntaxes in the future.

Eventually you need to consider what plugins should be moved to core, but it seems like we're pretty far from that point right now.
 Seems like it could be risky to get married to a particular syntax in the core when, for all we know, a more popular or easier abbreviated HTML syntax might come along 2 or 3 years from now and make Jade obsolete. For instance, [some people prefer Slim syntax over Jade](http://vschart.com/compare/slim-lang/vs/jade-template-engin) because [Slim is less cryptic](http://slim-lang.com). By making Jade core, nobody gets to use Slim.

In 2006 Sass was the ultimate CSS abstraction. But then Less was released in 2009 and of course now there is a choice between the two and people [have their opinions about each language](https://css-tricks.com/sass-vs-less/)â€”even though they are nearly identical in almost every way and their syntaxes are only trivially different from CSS. 

@patrick-steele-idem maybe there's a way to keep it more separated within projects. Could there be a flag at the top of individual templates to enable such an optional Jade-like syntax, for those who want it? Or is it just all or none?
 Very sorry to be such a downer here :smile: but thought of another issue.

The tendency to mix Marko syntax within a large company, like eBay, could add significant risk.

Since Jade is an _individual_ preference, this can cause issues to develop over time within a large team or organization using Marko. For instance, someone in one area of a large team or company (say eBay) prefers Jade and then they leave the company or go on vacation. A non-Jade employeeâ€”perhaps even days, months or even years laterâ€”might have to jump into those Jade files at any given time and be able to quickly troubleshoot them. A critical fix that should've taken minutes to troubleshoot ends up dragging out into far longer (perhaps hours) because the next employee to open up the files isn't familiar with the Jade syntax and can't get the complex files to build properly. In that case, the benefit of saving a few keystrokes became a liability for that company. It's a barrier to code completion, for a templating language that was intended to tear down barriers.

Actually, the same is true even within a small team, but if it's risky to mix a template syntaxes within a large company then one solution is to force all eBay developers to learn and use Jade in all of the codebase and documentation. But then the idea of it being optional would be an illusion.

As teams then attempt to avoid those inconsistencies and inevitably make team-wide standardizations to Jade, it ends up being a distasteful barrier to entry (newcomers and new hires getting up to speed, for instance) as well code sharing and information sharing. It promotes a lack of standardization because the standard _would actually be Jade_ with documentation, tutorials and examples pretending it's HTML. 

As an aside, I went to the [Jade playground](http://jade-lang.com) and tried pasting in a chunk of deeply nested/indented HTML code and I still can't get it to render the same HTML using their `.` or `|` syntax. Can we see an example of a chunk of nested HTML-preserving Jade? My initial experience suggests that this move to Jade may lead to _lower_ adoption rates once people realize that Marko v3 is really Jade disguised as HTML. I would point out that even Jade contributors [admit that Jade often makes a bad first impression](http://webapplog.com/jade/).
 > The tendency to mix Marko syntax within a large company, like eBay, could add significant risk.

@danrichman Agreed, but to use an earlier example, I think no more risk than an online newspaper using Markdown to collaborate on articles. One tech savvy journalist could start off by using HTML to draft the document with, while another journalist with no HTML experience could come along and feel inclined to either a) use HTML also, or b) use Markdown and we end up with a psuedo document.

Either way, this I think the arguments currently being presented are _internal_ issues and beyond the scope of what Marko should have to consider.

> Jade is being added to make Marko more accessible to the Jade crowd.

There also seems to be a general misconception (I think) that the Marko Concise option is being added purely for Jade user's. I think that's wrong. I hate Jade, but I feel as if I would at least give the concise option a legitimate chance - maybe even using it often in cases where I need to draft HTML quickly (in front of a client, or scaffolding for instance).

If we add this, _I think_ it has to be shipped together under the same file name and no additional plugins required.
 @adammcarth Well, if a journalist messes up a Markdown tag, the worst thing that happens is the text looks a little funnyâ€”it's one of the features of Markdown (looks publishable as-is, as plain text, without looking like itâ€™s been marked up with tags or formatting instructions) and the CMS prevents them from doing any real damage to the site. If you mess up the Jarko syntax, the code fails.

Markdown isn't cryptic like Jade is. Markdown is purposefully readable as is. Jade's cryptic syntax is [why some people prefer Slim over Jade](http://slim-lang.com/about.html).

Technically, the Markdown comparison is the opposite of what's being proposed here with Jade. When mixing Markdown and HTML, you have to _opt-in_ to Markdown. You write standard HTML and if you want to use Markdown, you just start using the Markdown tags and enable a Markdown attribute. Easy peasy. Markdown doesn't interfere with your ability to write HTML. That really does make everyone happy.

For example...

```
# Heading 1

<div class="something" markdown="1">
  ## Heading 2
  Some **bold** text. Some <em>emphasis</em>.
  <div class="something-else">
    This is easy. I don't have to change my habits.
  </div>
</div>
```

The `markdown="1"` attribute is how you _opt-in_ to Markdown when you want to use Markdown tags within an HTML tag. Everything is treated as plain text if you forget that attribute. **HTML is a first-class citizen in Markdown**.

With Jade, it's the other way around. Should you want to indent your HTML or plain text, you'll need to _opt-out_ of Jade.

For example...

```
.  <div class="something">
.    <h2>Heading 2</h2>
.    Some <b>bold</b> text. Some <em>emphasis</em>.
.    <div class="something-else">
.      Why do I have to put
.      periods everywhere?
.    </div>
.  </div>
```

If you want to wrap that chunk of indented HTML with a Jade-generated `<div></div>` tag, you have to indent your periods like this.

```
#container.col
 .  <div class="something">
 .    <h2>Heading 2</h2>
 .    Some <b>bold</b> text. Some <em>emphasis</em>.
 .    <div class="something-else">
 .      Why do I have to put
 .      periods everywhere?
 .    </div>
 .  </div>
```

Feels almost like we're being punished for using HTML.
 @patrick-steele-idem Whew. Yes! That does look good. Sorry, I was really getting worried after trying to paste HTML into the [Jade playground](http://jade-lang.com) and coming up with nothing but errors. :sweat_drops: 

However, to allay further fears, can you show us how the top pure HTML would look if someone should choose to wrap it in a Jade-generated `<div>` tag, like `#another-div`?

Would the periods be necessary then?

The reason I ask is because just like a mixed HTML/Markdown example, someone may want to come along and insert HTML inside someone's `#another-div` Jade tag. And I don't understand how they could allow Jade to wrap their chunk of nested HTML without using periods. Thanks so much.
 @patrick-steele-idem Fantastic. I don't know how you did it, but you've managed to create something _way better_ than Jade. Awesome job.

Ok. I'm on board. :+1:

Sorry for all the frenetic comments above. I had mistakenly gotten the impression that we were bastardizing HTML. Clearly that's not the case. I'm impressed.

The real beauty of your example is that it actually allows people to slowly dip their toe into the concise syntaxâ€”it's the best of both worlds. I can start with a single line and wrap all my HTML with it. And then I can use that single line to tip-toe into another line, and another if I please.. and so on. Itâ€™s really hard to dive into the whole Jade syntax at once. But youâ€™ve managed to make it seemingly painless. 

> If we get this right then I see no reason why anyone would want to use Jade.

Yup. Completely agree. This looks awesome. Carry on.
  Current template:

``` javascript
<if test="Array.isArray(data.author) and data.author.length ne 1">
    <if test="data.author.length == 1">
        <dc:creator id="creator">${data.author}</dc:creator>
        <meta refines="#creator" property="role" scheme="marc:relators">aut</meta>
    </if>
    <else>
        <for each="author in data.author" status-var="loop">
            <dc:creator id="creator${loop.getIndex()+1}">${author}</dc:creator>
            <meta refines="#creator${loop.getIndex()+1}" property="role" scheme="marc:relators">aut</meta>
            <meta refines="#creator${loop.getIndex()+1}" property="display-seq">${loop.getIndex()+1}</meta>
        </for>
    </else>
</if>
<else>
    author is not array.
</else>
```

This object is being passed into the template:

``` javascript
{author: ['Author One', 'Author Two', 'Author Two', 'Author Two']}
```

Output:

``` xml
<dc:creator id="creator1">Author One</dc:creator><meta refines="#creator1" property="role" scheme="marc:relators">aut <meta refines="#creator1" property="display-seq">1<dc:creator id="creator2">Author Two</dc:creator><meta refines="#creator2" property="role" scheme="marc:relators">aut <meta refines="#creator2" property="display-seq">2<dc:creator id="creator3">Author Two</dc:creator><meta refines="#creator3" property="role" scheme="marc:relators">aut <meta refines="#creator3" property="display-seq">3<dc:creator id="creator4">Author Two</dc:creator><meta refines="#creator4" property="role" scheme="marc:relators">aut <meta refines="#creator4" property="display-seq">4

```

The `</meta>` closing tags are not appearing, what is Marko doing?
 It completely slipped my mind that I was expecting XML, I'm quite used to template engines supporting both HTML and XML.

Changing the extension completely breaks the code (`<if>` and `<for>` tested so far, all breaking)

``` javascript
test.marko.xml:1
(function (exports, require, module, __filename, __dirname) { <if test="Array.isArray(data.author) and data.author.length ne 1">
                                                              ^

SyntaxError: Unexpected token <
    at exports.runInThisContext (vm.js:53:16)
    at Module._compile (module.js:373:25)
    at Object.Module._extensions..js (module.js:404:10)
    at Module.load (module.js:343:32)
    at Function.Module._load (module.js:300:12)
    at Module.require (module.js:353:17)
    at require (internal/module.js:12:17)
    at Object.<anonymous> (/home/george/coding/marko-playground/index.js:8:16)
    at Module._compile (module.js:397:26)
    at Object.Module._extensions..js (module.js:404:10)

```
 Bump for those who still faces this problem...

For me things start to work when I do

```
require('marko/node-require').install({ extension: '.xml' })
```

My guess is that internally `require('some.marko.xml')` looks for loader associated with '.xml', which is more in line with `require('path').extname('some.marko.xml')`

#363 adresses an issue with xml and `marko/hot-reload`.
  It seems like http://markojs.com/docs/marko/get-started needs some improvement.

Angular 2's use of file name labels on their code samples is helpful here: https://angular.io/docs/ts/latest/quickstart.html  You see this a lot throughout the community.   It's a nice way to help people get their head around the setup process quickly so they can get down to learning the syntax and API and also building something.
  I need it, so I believe I can implement this feature.
I can make fork, pull test, develop  & pull request.

Before I am going deeply in the source code, can you give me some direction where you think is the best place to implement it? (links to files&lines&functions will be appreciated) 
 I prefer sandbox via vm or vm2 (https://github.com/patriksimek/vm2).
Regular VM, of node can make the entire process not responding `while (true) {}`.
 static code analysis never can be perfect, and in case of break, it is a backdoor to entire server. That why we must choose sandbox:
https://nodejs.org/api/vm.html
https://github.com/patriksimek/vm2
 We only talking about server side. web worker, is mostly for client side. 
 Out-of-process will make all global variables not works. It is break-change. Can we do that kind of break change to Marko?
 Just to clarify. For securing client side, all we need to do is use XSS library. (https://www.npmjs.com/package/xss). We are only talking about securing server side code executing
 I believe that to not break current code using global variables, we have to add it as an option.
Maybe like this:

```
require('marko').load(src,{secure:true})
```

http://markojs.com/docs/marko/javascript-api/#loadtemplatepath-templatesrc-options--template
 The problem is that maybe there are user that now using templates, that running insecure code, but this is what they want. We cannot make break change to community project.
 we can simply use child_process.spawn (or fork), and send data between the process.

A question There is any timeout for async function loading in Marko? 
We don't want that a template that contain a infinite loop, will work forever.
 @patrick-steele-idem . That what I mean it will be opt-in only
 So, we have to add timeout, (default: 1 min)

```
require('marko').load(src,{secure:/* true/false  */, timeout: /*in ms*/ }
```
 Maybe the timeout need to be in the render function (not at template loading time)
 It is supported for vm2. 
`options={timeout:1000}`
 Maybe it is possible to add modules to VM2 context using the sandbox option, instead of requiring it:

```
sandbox={marko: require('...'), `marko-async`:require('marko-async')}
```

What do you think/
 For timeout, You can do

```
vm.call('setTimeout(function(){process.exit()},60000)')
```

It will stop the vm, after 1 minute
 Anyway Maybe it be easier to implement it simply, using `child_process.spawn` that run native vm module.

and not be depended on other modules. vm2 not giving as so much.

I think, that child_process can give us, secure way of running things, and vm module, can give as "javascript from text " compiler.

In short:
1. We will create a short JS file, that render templates in native vm.
2. We will run this js file as spawned process.
  Maybe try add the creator of vm2, to the conversion...
 The problem is, that today, I can use helper, with extenal data.

var y=3
templateDat={
my_helper:function (x) {return x*y}
}

If we use vm2, or out-of-process rendering, the `y` variable will not available.
  So, there is any solution how to to stop vm2, in case of infinite loop
  I think a folder within `node_modules` is a very sound place to compile templates to _by default_. Reference the full path to a compiled file if an error occurs, and the person can easily navigate their way to the destination for further inspection.

I know it's awesome and cool to see the Javascript that is compiled from `.marko` syntax files, but I stand by my opinion that they serve quite literally no real purpose besides debugging and, for a lack of a better term, pure self-interest in how Marko works. In either case, at no point should these files need to be visible in a project. You don't edit or make changes to compiled Marko files, and they shouldn't ever need to be included in version control.

The `node_modules` folder ticks as a solution to all these boxes. PLUS the fact it's already checked out of version control in 99% of projects means compiled files are hidden straight away, instead of realising down the track and needing to add line(s) to your `.gitignore` file.
 Hey @patrick-steele-idem! Sorry I missed your reply to this :(. Better now than never though, I guess.

Hmmmm. That's a tricky one. In regards to your second use case, I still stand by the fact that even if you did decide to delete your original Marko templates as some kind of release process - you'd probably be doing more harm than good. Unless you have some incredibly unique situation where storage space is an issue, what would deleting the originals and keeping the compiled achieve? You'd have compiled Marko templates that would serve literally no purpose to anyone except the process workers, right? I guess if it was part of some kind of testing environment I could see the use for that though. That kind of makes sense, but I don't see any real advantage of that over the files being in a seperate directory.

As for not using the `node_modules` folder - I think that's a fair enough reservation to have. Something like `.mark-compiled` would work well, if you were going to go down the whole, _compiling-to-a-different-directory_ path.

Let me know what you decide on anyway. Glad to see v3 is gradually getting rolled out, keep up the good work mate :+1: 
 It would be very nice to be able to supply an alternate directory. It could be the case that the user running the application doesn't have write permissions to `node_modules`, but does have write permissions elsewhere.
 +1 for `.marko-compiled` (or `.marko-cache`) on the root, in a similar way as Sass does.
 The compiled template location is handled on lines `38` and `92` of `node-require.js`: . Right now they just append '.js' to the end of the source template's filename. I've hacked on my local copy a bit and added new compiler options for defining the source and cache directories, and it works perfectly under ideal circumstances.

The problems I'm looking at now are ensuring that the requested template is actually _below_ the given source directory (which I suppose could be handled by throwing an error if `path.relative(<src-dir>, <filename>).startsWith('..')`) and that the target cache directory exists before trying to write to it (ideally without too much extra code or pulling in another dependency like `mkdirp`). I'll try to poke at this a bit more tomorrow if I get the chance, but I'm running out of time for today.

EDIT:
The reason for worrying about the path relative to the source directory is that otherwise it just dumps everything in the same place, which is fine until you start having name collisions. The only other option I can think of would be naming the files by some kind of unique hash, but that would make debugging a nightmare.
 It seems this isn't quite as simple as I'd thought. After posting I noticed the comment above about it only storing in the alternate location for reference purposes, and it seems that is what's happening. It also doesn't seem to affect layouts. I'll still try to poke at this a bit when I get the chance, but disregard my previous post as premature optimism.
 I did some more digging and found that `node-require.js` isn't the only place that is hard-coded to simply append '.js' to the source filename. I'm seeing 3 more such lines in `runtime/loader/index.js`. Fortunately the line always seems to be basically the same thing, `var targetFile = templatePath + '.js';`, sometimes with different variable names. I'll keep poking at this whenever I get the chance.

In the meantime, regardless of the solution, we'll still need to ensure that the target directory exists. My first idea was to use the `mkdirp` module, but that would mean adding another dependency. Any thoughts or suggestions?
 I tested every scenario I could think of, and it _appears_ to work perfectly except for two things:
1.) I got a "Cannot find module" error when trying to use a component, though that's _probably_ the result of my being lazy and hard-coding some of it just to see if this was even viable.
2.) I _think_ with the current setup, if the source template has been deleted, moved, or renamed, it falls back to require()'s built-in behavior of attempting to append '.js' to the end of the filename. This is probably an easy fix.

To anyone who would like to put my research into practice:

Step 1: Edit lines `38` and `92` of `node-require.js`, and lines `55`, `82`, and `92` of `runtime/loader/index.js`(marko v3.10.1); They should all look something like `var targetFile = templatePath + '.js';`. You'll want to modify them to point to wherever you want the compiled templates to be cached (+1 to the previous suggestion of using `.cache/marko` by default). You could probably implement a new compiler option for users to specify the source and cache directory paths, both modules already have access to markoCompiler.defaultOptions.

Step 2: Ensure valid file paths; All sources should be below `src/`, all compiled templates should be below `.cache/marko/`, and the target directory should exist before attempting to write to it - for example, `.cache/marko/layouts/main/` must exist before attempting to write `.cache/marko/layouts/main/layout.marko.js` - ideally without adding too much extra code or another dependency.

Step 3: Make sure components work correctly. The error I saw may just have been a fluke, or it may be a quirk in how components are loaded as opposed to layouts (which did work correctly for me).

Step 4 (optional): Modify the require() extension to check for an existing compiled version of the requested template even if it can't find the source file.

I apologize for the length and number of my posts. I'm not sure if or when I'll get around to forking or initiating a pull request, so I want to make sure that if anyone wants to finish what I've started they'll have as much information as possible.
   Working great! Thanks. Do you know off-top if there are any other places that scan node_modules where this check would be necessary?
  Hi,
Just to let you know there seems to be a problem with npm installing dependencies for the 'marko' package (in particular I noticed marko-layout wasn't being installed). I made sure 'marko-layout' wasn't installed in the main projects package.json file. Tries a clean uninstall of all npm packages, npm cache clean, and then install and still no joy. I think it is linked to the version on npm.
I managed to resolve this by 'cd' into node_modules/marko and running npm install there.

Hope it helps someone.
 Thanks this solved it. Was pulling my hair out. Would be good to get this in the marko docs, maybe in a section about moving an app to production. 
What I actually did was stop grunt from copying the 'template.marko.js' files to the build so they were generated again on the server. Is that a suitable way of doing it?
  I have a marko tag with the following marko-tag.json:

```
{
    "@class" : "string",
    "@items <item>[]": {
        "@wallpaper <wallpaper>": {
            "@class": "string"
        },
        "@panel <panel>": {
            "@class": "string"
        },
        "@someProp": "string"
    }
}
```

And the following index.js:

```
module.exports = require('marko-widgets').defineComponent({
    template: require('./template.marko.html'),
    getTemplateData: function(state, input) {
        input.items = input.items || [];
        var items = [];

        for (var i = 0; i < items.length; i++) {
            var item = items[i];

            var wallpaper = (item.wallpaper || {renderBody:''}).renderBody;
            var panel = (item.panel || {renderBody:''}).renderBody;
            var someProp = item.someProp || 'default';

            items.push({
                wallpaper: wallpaper,
                panel: panel,
                someProp: someProp
            });
        }
        return {
            items: items
        };
    }
});
```

Attempting to use it in the following way doesn't seem to work:

```
<img-carousel>
  <img-carousel.item someProp="someValue" for="item in data.items">
    <img-carousel.item.wallpaper>
      <img alt="${item.img.alt}" src="${item.img.src}">
    </img-carousel.item.wallpaper>
    <img-carousel.item.panel>
      <p if="item.text">$!{item.text}</p>
    </img-carousel.item.panel>
  </img-carousel.item>
</img-carousel>
```
  Hey all.

So at the present, Marko doesn't have a uniform way of defining configuration options when first initializing the library in your project. For example, setting the `writeToDisk` option (which prevents templates from compiling to the file system) is achieved with:

``` javascript
// Current configuration method
require("marko/compiler").defaultOptions.writeToDisk = false; // what if more config options arise?
require("marko/node-require").install();
```

It works for now, but it's not ideal - particularly with the future in mind where configuration could play a bigger role with Marko. Here are some alternatives for defining configuration that have been suggested so far...
#### 01. Configuration File

This solution is probably the most promising on this list. Essentially, the idea is that you can create a file in the base directory of your project that Marko will read and pull configuration options from. A potential name for the file might be `.markoc` (a hidden file, standing for 'marko config')...

``` javascript
{
    "writeToDisk": false,
    ...
}
```

One debate that does arise from this is whether your _Marko Tag Lib_ should also be defined here with the compiler configuration, or if it should still be kept in a seperate `marko-taglib.json`. My personal opinion is that all Marko configuration should be defined from a central place to make life easier, but the argument for keeping the `marko-taglib.json` seperate from compiler configuration is that it's less complex. My question to that response is, how often do we intend to add/update component directories? If it's very infrequently (as I suspect), then I just don't see why it needs its own file. Just my $0.02 on the matter though. Please share your own thoughts.
#### 02. Pass Configuration Block To Installer

An idea I had was to potentially pass in a configuration object when Marko is required...

``` javascript
// Example
require("marko/node-require").install({
    writeToDisk: false,
    ...
});
```

It's certainly a more traditional solution, but this approach is not ideal given the way the Marko runtime is loaded by Node.js so this one is not recommended.
#### 03. ???

If you've got any ideas or suggestions for alternative ways that configuration could be defined for Marko, please share it with us below. I think it's important that we have this discussion now so that more default configuration options can be introduced by the community down the track. If we can agree on a standard now, we can start exploring other potential config for Marko. Please share any thoughts you have :)
 I agree with @philidem. I think a centralised configuration file in the project root for all default Marko settings, and the name `marko.json` gets my vote so far. Good point about the potential hidden file issue with Unix based systems.

Do you want to elaborate more on why you would want to keep the Marko Taglib seperate @patrick-steele-idem?
 I would prefer being able to pass a configuration object into some sort of `require('marko').config()` method. I don't like the idea of messing with Node's `require` function, so I don't use `marko/node-require`. I use `marko.load()` for loading templates.

I normally write my applications to look for an application specific configuration file, or have one fed to it. The application then uses the properties of that configuration file to initialize any modules it uses that could potentially need some configuring. I don't really want to edit multiple configuration files for one application.
 My statement about the require patching was in response to idea 2 in the original post. It proposes passing the configuration in during the install of the require patch. I was merely pointing out that not everyone uses that aspect of Marko. I understand that it is a convenience method, and that Marko is really just compiling the HTML based language into JS. It doesn't matter to me if Babel or other things also patch the require method -- I don't use any of them.
  Hey team.

Are there any plans on the roadmap for an Express JS rendering plugin for Marko? Currently we render templates with...

``` javascript
require("marko/node-require").install();
var app = require("express")();
var template = require("./hello.marko");

app.get("/hello", function(req, res) {
    template.render({
        name: "Adam",
        fruits: ["Apples", "Oranges", "Grapes"]
    }, res);
});
```

But what about a plugin that leverages Express's built-in render helper?:

``` javascript
var app = require("express")();

var Marko = require("marko-express"); // example lib name
app.engine("marko", Marko({ fabulous: "options" }));
app.set("view engine", "marko");

app.get("/hello", function(req, res) {
    res.render("hello", {
        name: "Adam",
        fruits: ["Apples", "Oranges", "Grapes"]
    });
});
```

Is something like this on the cards, or did you avoid it because of performance reasons/Marko best practices or something? I guess one of the advantages of initializing Marko as an express app engine (like above) is that  you can pass options to Marko, such as `writeToDisk`, in a far nicer way than currently available. It also means we can set a base directory to reference `.marko` templates relative from, and not need to have an extra line to load the template into a variable before rendering content.
 Thanks for the response @patrick-steele-idem. That blog post you wrote pretty much cleared everything up for me - seems like using the built-in express renderer can indeed be quite harmful in some cases.

I'm interested in making my apps more modular. I like the structure you use for basic apps...
- pages/
  - home/
    - index.js
    - style.css
    - template.marko
  - login/
    - index.js
    - style.css
    - template.marko

...but I'm wondering how that idea gets applied, to, say - a blog post? Would you opt for something like?:
- pages/
  - posts/
  - post_show/
  - post_edit/
  - post_update/

Just trying to get the Marko concepts down-pat. Thanks for all your help :)
 Cheers mate, wonderful.
  @patrick-steele-idem Is it possible to add js and less file to the components/taglibs? 

I've tried `<lasso-page name="hello" package-path="./browser.json"/>` and someway similar to it, I found that only one `lasso-page` tag would be work. 

is that a possible way to get `lasso` and `marko taglib` working together to support the dependencies which would be required by the component/taglib itself?
 @patrick-steele-idem sure
  Would be useful to be able to tell from reading the first paragraph of the readme whether mark is server, client side or both. I guess it's both, but if it was mentioned I would feel more confident trying marko out
 Excellent - thanks. So far, after 1 evening, I'm a big marko fan - the most comprehensible compiled templates I've ever come across - great for debugging
  Given this template

``` html
<p>Author ${data.author.name}</p>
```

this data:

``` js
template.render({});
```

I get this error

```
      escapeXml(data.author.name) +
                           ^
TypeError: Cannot read property 'name' of undefined
```

Is this normal behavior ? Does marko handle properties on undefined paths or am I missing something ?
 thanks @patrick-steele-idem that's what I did (lodash).

On the other hand, wouldn't it be interesting to have that handled by marko ? It seems most template engines have such a feature. 
 I see what you mean.

As for offering  `get` as builtin helper, one can use lodash as you suggested. May be it's good to keep the library as slim as possible by not providing extra features, until there's sufficient demand for it by the community?
   Hey @patrick-steele-idem, I see, absolutely!
Thank you for brilliant template engine and very interesting test harness created for it.
  Excuse me, I'm newbie to marko. I'v tried the hello-world example on koa.js with a stream via pipe proccess.stdout. So first time in template all was OK written as must to be. Via console terminal all was also fine, it's work but when I opened the file next morning I'v seen that marko engin rewrite the file of  his own way with helper's javascript functions, but my  Hallo ${data.name}!   is gone, simple disapeared. What I'v wrong made? Or all that features must be by default?

``` javascript
var fs=require('fs')
var  duf=''
require('marko/node-require').install();
//two ways at once
//first way:
var template=require('./views/hello-world.marko');
template.render({name:"Bob",colors:["yellow","red","brown"]},function(err,output){
    if(err) console.log('error :',err);
    console.log('output :',output)
})
//2th way:
var das=template.stream({name:"bobika"});
das.on('end',function(){console.log('\nDAS END DAS END!!! ON END!!\n')})
das.once('end',()=>console.log('\nDAS Once END ONCE END!!!\n'))
das.on('finish',()=>console.log('\r\nDAS ON FINISH!!!\n'))
das.on('error',(e)=> console.log('\n DAS ERROR!!!! :',e))
das.on('data',(c)=> console.log('DATA!!! :',c.toString()))
das.on('readable',()=> {var buf;while((buf=das.read())!==null){
    duf+=buf;console.log("\nBUF :",duf)}})
var sis=process.stdin;
var sisout=process.stdout;
process.stdout.on('error',process.exit);
process.stdout.on('exit',function(){console.log('ended')})
sis.pipe(das).pipe(sisout);
```

---

and here my hallo-world.marko in the morning:

``` javascript
function create(__helpers) {
  var str = __helpers.s,
      empty = __helpers.e,
      notEmpty = __helpers.ne,
      escapeXml = __helpers.x,
      forEach = __helpers.f,
      escapeXmlAttr = __helpers.xa;

  return function render(data, out) {
    out.w(' hello ' +
      escapeXml(data.name) +
      '! ');

    if (notEmpty(data.colors)) {
      out.w('<ul>');

      forEach(data.colors, function(color) {
        out.w('<li style="color: ' +
          escapeXmlAttr(color) +
          '">' +
          escapeXml(color) +
          '</li>');
      });

      out.w('</ul>');
    }
    else {
      out.w('<div>no colors!</div>');
    }

    out.w(escapeXml(data.bazar) +
      '<b>simka: </b>' +
      str(data.simka));
  };
}
(module.exports = require("marko").c(__filename)).c(create);
```
 In the file hierarchie must be two files? One for hello-world. marko and one compiled  hello-world.js???
is that by default? Hmm. The server must be restart to keep changes in the template file every time. So bad and slowly for a site developing. Is it true?
In docs about marko.js said nothing about that. About files structure and about server restarting.
 In a hello-world example for colors /li produces extra empty li pairs. Why? When you delete last /li, so ok. Is a bug?  I try in for="color in data.colors - 1" produces NaN. Is there a way write data.colors.length?
 Only opening tags are modified for conditionals and looping???
  Hi Patrick,

We are using Marko JS on our application. Below is the GitHub URL:

https://github.corp.ebay.com/OCS-Dev/webforms/tree/rti

One of our component we provide dependency: 
https://github.corp.ebay.com/OCS-Dev/webforms/blob/rti/src/components/email-form/browser.json

{
  "dependencies": [
    "require: ./index",
    "src/ds3/browser.json",
    "src/third-party/jquery.js",
    "require: src/components/call-me",
    "require: src/components/submit-button"
  ]
}

Relative path is not getting resolved in On Windows environment(working expected on MAC though). I see below exception in browser console when I hit our page: 

http:/localhost:8080/email/compose/AQABAAAC0CtGM/B68cFDXP472Z5EMUy3itN2JRaj564KXegqAHIAcDOylgBccNyhrWzcCHXX8kyHd81d6zeVrAZ5NEj0cUgs9X3aPVuBb0a7nf45lhmYUUZQTFGsjCbg408mqCvMT4NheESGWhArH+yzWgabsk4+fav0SAH3OpnVL5D2FBxkkBKbKx/7aa/AmDwMgronfRfDBJQued354L337awe7pBXlXHA6BO7ThumDHPch6n6qwytqQ4oEnaKoCcCgYO/d+/5TjiCWbo3FhQNzjicgj1z6Zm7OX4RkbfY5nJpdixp3JJzaKLtmyxp24cLy1SY+8ckVqdOvEPfPJyspLxkixDHQXqRyEi7/vJ7dAhbPACJ8Msr6bfMxg+geA15ei7D0n+JY5sMnqm/IM7A7oH5hvmhs0p3DHRzLcNPNOB9ieI1Em0KpQaTzyLdP+7XKK9ExgVSkK+IRBrey6NXwf4gFo3KJsDkzKYUJ/qMZjZdsAwpxXmRTLbJzMx8CqxEVz54R/H6OQTOHHksx1Jnyq9UzuNw/1UVFa3NkdDvVnN/mHtBeMWrJmWBqpMhzAoXsgi5btfDRIj6TLSKDQP4/7h5diDcRtdIt3ZRsOl6KvabSx8X0HnAljzE0M7AzO2BK50+76RtzAor2mc4wqv/TYYfk5EOfoXTIP5Xu2i+oRDP8EnaYR2pM5jaJn8m4V8Iz3XHt1Cr7qEuCep4q0gKUtxIRrXSxoqYKzJtbjryfnEkNTDXVX2YirAyeOtITN1QJHtv/GPaE09NGCcxvuJz51fPkBpVWa9WS5YaYXo5px6svVnCXWt8ip+yhhDjA28Hgepjy9oqoMaexfKBtnecoOJp0+8/xJPWUT6RlZDnMMraDgCfqBfHtuVnl5kMbZbAmuWVKI2n+ddhg/GaT23NQ6IATuv3XoZ1KCJu9JKgIbo9ULEgb1fnQVnYmDWPuVXAA5qIDg==

Cannot find module "..\call-me" from "/src/components/email-form"

Basically the generated Marko.js file creates the dependencies like below: (template.marko.js) 

  ___call_me_index_js = __renderer(require("..\call-me")),
      ___submit_button_index_js = __renderer(require("..\submit-button"));

Any pointer would be helpful.

Thanks
Rajesh
  Travis upgraded its infrastructure which allows CI tests to be ran in docker containers. The result is faster tests. 

To use it you just have to specify `sudo: false` in the travis CI.
 @patrick-steele-idem which build? The only thing that I saw that has failed recently was a rebuild that triggered on my PR after it was merged (which failed because the git ref that PRs point to are deleted after merge). 
  It might not be as simple as this, but one can hope, right?

The purpose of this change is to allow this to be written in the renderer

``` javascript
module.exports.tag = { name: "my-tag-name" }
```

That would result in the template being named to whatever was specified.
 So I'm looking for the proper location to place the renderer fixture that I use for the test. Should it just go in `test/fixtures/taglib`? Also, any preferred name for it?

**Edit**: It seems like there are no tests for renaming tags through `marko-tag.json` either. This PR would likely be a good place to go ahead and add that test as well. 
 I definitely still think it has value. I try to put as little as possible in `marko-taglib.json` or any `marko-tag.json`. With that being said I think basing it on the folder name that it's inside is a valid compromise. 

Ultimately if you keep the ability to set it in the `marko-tag` I think this PR should happen. If not, then it likely shouldn't. 

It's just nice to me:

``` javascript
export default defineComponent({
  name: 'gh-notification',
  template,
  ...
});
```
 Sounds good.
  The below line is not working in marko5 and I have tested the `$(document).append()` in some other pages and It is working fine . I think Marko interrupt this append method. Kindly let me know If you have any idea about this issue.

Testing append method:-

``` javascript
$(document).append($('<script>alert("")</script>'));
```

In js code:-

``` javascript
$(document).append($(response.inlineJs));
```
 The below function loads the inline js in the page and it is wrapped with script tag.
The below code is inside widget.js file .

``` javascript
loadInlineJs: function(response) {
        if (response && response.inlineJs) {
            $(document).append($(response.inlineJs));
        }
    }
```

eg:-

``` javascript

<script>(function(){})();</script>
```

It was working fine with marko4 and It is not working with marko5.
 ![image](https://cloud.githubusercontent.com/assets/286382/10465666/e5b2df4e-71a4-11e5-8b5a-680a647ca947.png)
  I want to use custom images in marko templates. But not able to find any documentation related this.
 Use just regular html tags 

`<img src="http://i.imgur.com/L7TM5P1.jpg">`
 That's great and totally makes sense for local images.

On a side note for lasso-image - Would be also great if it would deliver webp images if the browser supports it. Conversion might be too expensive ... just an idea.
  https://nodejs.org/api/globals.html#globals_require_extensions

Given that this method is deprecated, we might want to look into requiring .marko files differently. Maybe by handling compilation separately and then `require('template.marko.js')` instead?
  Hi:

I know that Marko "avoids evil global variables and global helpers", but I think I have a situation where they could be useful:

I'm using Marko in a Koa app. This app uses koa-locale which provides two methods: `this.__(key)`, which looks for the translated text by key, and `this.__getLocale()` which returns the selected language from URL, cookie, HTTP header, sub-domain, etc. So, I have a layout like this one:

```
<!doctype html>
<html lang="${out.global.__getLocale()}">
    <head>
        <meta charset="utf-8"/>
        <meta content="width=device-width" name="viewport"/>
        <link rel="stylesheet" href="styles.css"/>
        <title>${out.global.title}</title>
    </head>
    <body>
        <layout-placeholder name="content"/>
    </body>
</html>
```

With a view like:

```
<layout-use template="./boilerplate.marko">
    <layout-put into="content">
        <h1>${out.global.__('Welcome!')}</h1>
    </layout-put>
</layout-use>
```

And I use them as follow:

```
this.response.body = require('../templates/index.marko').renderSync({
    $global: {
        __: this.__.bind(this),
        __getLocale: this.__getLocale.bind(this),
        title: this.__('Welcome!')
    }
})
```

Of course, I don't want to pass `this.__()` and `this.__getLocale()` in every router, so I'm wondering if there is a better way to accomplish this.
 Currently I'm using `.renderSync()` just because I'm learning Marko. I plan to start rendering to an HTTP response directly. In any case I think my problem is that koa-locale does its work automatically.
In the first case, if I understand well, you pass the complete output to a helper that replaces some text with its translated version. As far as I know I can't do that because `__(key)` only receives the key to be replaced.

In the second case you are referring to require a JavaScript module, aren't you?

```
<require module="./util" var="util" />
```

The problem with that is that koa-locale receives the app instance as an argument and I don't see a way to do that inside a .marko file.

That's why I was wondering if there's is a a way to pass helpers to the compiled `__helpers` object, maybe before calling `.install()`.
 @patrick-steele-idem thanks for the transformer example!
 Hi again @patrick-steele-idem,

Thanks for your example, it makes things clearer, but you are still passing `i18n` to `$global` every time you render a template and that's why I'm trying to avoid because I'm pretty sure I will do that everywhere. Anyway I think it's just a minor drawback.
 Here must be some middleware for koa. Some thing like this:
https://gist.github.com/Globik/d612dce121de3e1cd996
For a global access to this.state. Any use for every global dynamic stuff like configurable menus, rubricas, categories etc
 @patrick-steele-idem I like your proposal of `i18n-var` so I tried to move it into my `tags-dir` without success:

`Error: Error while handling properties for /app/src/marko-taglib.json: Error while applying option of "tags-dir". Cause: Error: Invalid tag file: /app/src/components/i18n-var/marko-tag.json. Neither a renderer or a template was found for tag.`

marko-tag.json

```
{
    "@name": "identifier",
    "transformer": "./transformer.js"
}
```

This is the same definition [here](https://github.com/marko-js-samples/marko-koa-i18n/blob/master/src/marko-taglib.json#L3) - so shouldn't it work the same?
 Hi @patrick-steele-idem. Sorry for the delay and thanks for the input. Just for future reference in case someone has the same doubt: In the end I followed @Globik's advice. I have developed two projects using Koa and Marko in this way and I'm pretty happy with the result.
  This should resolve issues with circular dependency rendering. Previously, whenever this function was called, it would throw an error because `typeof renderFunc` was always `undefined`. With this fix, `rendererFunc` will (in valid cases) be a function.
  How do you envision this? I assume it would automatically
1) transform if/else/for syntax in all files
2) transform syntax for all custom tags
2) remove attribute references in marko-taglib.json files
4) delete marko-tag.json files

Anything else?
  Please review and merge :)
 Test pass locally :)
 Alright, will do :)
 Whenever I use expected and actual, I always end up in this strange situation:

``` sh
  1) render unless-else:
     Unexpected output for "/Users/kristianmandrup/repos/markoa/marko/test/fixtures/templates/unless-else/template.marko":
EXPECTED (/Users/kristianmandrup/repos/markoa/marko/test/fixtures/templates/unless-else/expected.html):
---------
B , A , A , <div>A</div>

---------
ACTUAL (/Users/kristianmandrup/repos/markoa/marko/test/fixtures/templates/unless-else/actual.html):
---------
B , A , A , <div>A</div>
```

I even copy paste the actual into expected, and still the same error! Must be a whitespace issue?
 I also get this warning

``` sh
    âœ“ if-else
WARN marko/runtime/helpers: data.invokeBody() deprecated. Use data.body instead. Error
    at Object.data.invokeBody (/Users/kristianmandrup/repos/markoa/marko/runtime/helpers.js:326:89)
    âœ“ include
```

From `include-nested-content.marko`

```
    <p>
        ${data.invokeBody()} <!-- deprecated -->
    </p>
```
 Yup exactly! Using Atom, haha :P Thanks for the tip. Now it works ;)
I recommend you enhance your string compare to trim trailing whitespace or at least have it as an option.
 Really, hmm... that was not my intention. Guess I made a Markdown error of some sort. 
I only inserted a few more examples in the relevant section. I'll fix that shortly.
 I just reviewed my changes and reverted what I think you call "stylistic changes". If you are still not happy, please edit as you like. I tried my best to improve the docs while keeping with the original intent and styling.
  Marko + koa currently misbehaves due to errors thrown during template stream rendering are uncaught, leading to hard crashes of node.

The sample code below illustrates a very simplied setup, and this patch ensures that errors during template rendering are indeed picked up by the koa error handling system.

```
// Simplified koa usage
app.use(function * () {
  this.type = 'text/plain'
  this.body = require('template.marko').stream({...})
})

app.on('error', function (err) {
  log.error(err) 
})
```

Thanks for an awesome piece of work. Marko+koa is my bread and butter...
 @patrick-steele-idem, I get your points regarding V8. 
The more idiomatic use of `render()` works well with Koa too, as in

```
app.use(function * () {
  template.render({...}, this.res)
})  
```

A simple change for me and I accept that as an answer :)

I think I have spotted an edge case here. Everything that goes down to Async-Writer/async-fragment seems to work super nice, It's just the initial synchronous invocation that needs some loving care. 
I'm still rather dependent on streams in some peculiar situations, so I will try to make a better PR respecting performance and also covering asynchronous situations.

Feel free to discard this PR ;)
  Would help clean up conditionals a lot :) 

`if='!loop.isLast()'` is kinda ugly and hard to notice those `!` exclamation marks.

``` jade
  for(each='item in data.list; status-var=loop"' if='data.list')
    ui-button(attrs='item')
    div(class='or' if='data.or' data-text='$data.or' unless='loop.isLast()')
```
 My PR has been merged! Thanks guys :)
  I was wondering if it is possible to load custom functions or even set one or more globals, such as `lodash` or `underscore` before "running" all the custom tags, in order to make these globals available for tags to use if needed (load once, use anywhere). 

Must be a very common use case ;) 
Thanks. 

In my case, I would like the following to be generally available for many of my tags:

``` js
String.prototype.capitalizeFirst = function() {
    return this.charAt(0).toUpperCase() + this.slice(1);
}
```
 Hi Patrick, thanks for your response. I was just curious if there was a way. Kind of like a base class or decorator for all renderers to leverage common functionality. So far I've been using `require` but can feel like duplication and I like to keep my prod code super slim and DRY. 
I guess I will just introduce a "compile step" of some sort to prepend or inject whatever code I want according to some global rules...
  Per email thread:

We probably need to look into a better way to prevent the same taglib from being loaded multiple times, but currently the Marko compiler walks up the directory tree to find taglibs and will happily load the "same" taglib multiple times if it is found multiple times in the search path. The marko-widgets taglib being loaded multiple times is causing the same template to be transformed multiple times and that is resulting in unexpected behavior. De-duping taglibs by module name would solve the problem.
 +1 facing the same issue
  Would really like if we had the ability to use the index on iteration somehow...
Here using the imaginary `index='pos'` `for` attribute (default `index='index')

``` jade
ui-grid(ui='inverted')
  ui-row(ui='green' list='data.users.header')
  for(each='item in data.users.list' index='pos')
    ui-row(ui='silver' attrs='item' if='pos % 2 == 0')
    ui-row(ui='blue' attrs='item' if='pos % 2 == 1')
```
 Sweet :) Learning every day...
  to allow for dynamic runtime tag name transformation :)

This will enable my https://github.com/kristianmandrup/marko-dynamic-tag to work :)
And loads of other powerful use cases...!!!
 Awesome :) I sure don't mind!!!
 Would it also be possible to dynamically decide which component (function I assume) to call using a similar approach?
 BTW: On the PR, all the tests passed on my local machine running `mocha`, so I was surprised to see it fail on Travis CI. 
 Exactly what I was thinking!!! :)
 In my scenario I would have an incoming list with varying types of data (ie. some attributes undefined)...
Depending on the data I what to render an appropriate tag, such as icon-item if it has an icon, link-item if there is a link and so on. Of course I could have a "catch all" item, but it would have to contain loads of conditional logic... the dynamic tag would come in very handy to make for a more elegant solution :)
Cheers!
 An example:

Here I decide whether to render a checkbox as a `toggle`, `slider`, or a normal `checkbox`. 
Not very elegant, but gets the work done :P

``` jade
ui-toggle(attrs='data' if='data.toggle')
ui-slider(attrs='data' if='data.slider')
div(class='$data.field field' body-only-if='!data.field' if='data.default')
  div(class='ui $data.ui checkbox' body-only-if='!data.ui')
    input.hidden(type='checkbox' name='$data.name' checked='$data.checked' tabindex='$data.tab')
    label(if='data.label') $data.label
```
 Sweet :) Thanks for the tip. Didn't even know you could do complex conditional logic inline like that :)
I agree, those tasks are way more important for now than these obscure bonus features!!!
Good job :) Looking better every day and every week :D
  I have the following template

``` html
<div class="ui list">
  <for each="item in data.list">
    $item.ui
    <icon-item attrs="item">
      <div tag-body="item.body" class="description"></div>
    </icon-item>
  </for>
</div>
```

with the following data"

``` js
[ { ui: 'large orange',
    icon: 'user',
    label: 'kmandrup',
    body: 'I DREAM in CODE' },
  { ui: 'large blue',
    icon: 'user',
    label: 'isaura',
    body: 'I LOVE web DESIGN' } ]
```

It correctly prints `large orange` and so on for `$item.ui` but for `<icon-item attrs="item"` no attributes are passed to the custom tag `icon-item`. Why is that?

In the docs for `attrs` it is used on a normal `div` tag, but I would have assumed I could also use this technique for custom tags??? Otherwise tag maintenance will quickly become very "fragile" IMO.

Even more convenient would be if I could somehow list the attributes I wanna transfer, then have marko use the schema to transfer and type convert values accordingly:

`use-attrs="item:name,icon,label"`
 Sweet :)
  With the coming standard ES6 loader support currently implemented in [SystemJS](https://github.com/systemjs/systemjs) & [jspm](http://jspm.io/) having a MarkoJS plugin would be great! Using the [SystemJS Handlebars](https://github.com/davis/plugin-hbs) plugin as a starter might be a good idea: 

**PS:** Since AMD support was [dropped](http://psteeleidem.com/announcing-marko/#switched-to-commonjs-modules-for-compiled-templates) by switching to CommonJS, I'm just wondering what's the currently recommended (non-Browserify!) recipe for using MarkoJS with AMD/RequireJS (including bundling/compiling) :question:
 10x for your detailed answers. So ... no easy AMD/RequireJS MarkoJS integration here :worried: 
Anyhow, I'm currently looking into the maturing SystemJS/jspm since aside of supporting any module format (AMD, CommonJS, global, ES6, System/register) and native-transpilers (TypeScript, Babel, Traceur) it is future-proof being the (single AFAIK) reference implementation/polyfill of the ES6 module loader. 
If time permits I'll look into creating a **plugin-marko** plugin & bundler for MarkoJS integration.
 I've been mulling over which cool new thing to ditch from my project: jspm or marko. 

Marko wins :+1: (i.e. it's not getting ditched)
  It works just fine, except html equality test breaks even though I copy paste `actual.html` and `expected.html` to match!?. 

See `test/fixtures/templates/tag-body`
 Awesome! Much better :) Thanks a lot! 

Of course this solution is just excellent! I learned a lot from my experiments, and this little helper lib you made clearly demonstrates how to enhance Marko in an elegant way!!! 

Have a nice evening @patrick-steele-idem  :)
 Cool :) Yeah, next step IMO is to improve the documentation some more. 
Perhaps by going away from having everything in one huge README? A github "blog/page" or wiki?
 On another note, I was wondering if there is a way to dynamically generate the tag name, such that:

``` html
h1(class='ui header' tag-body='data.label' if='data.lv == 1')
h2(class='ui header' tag-body='data.label' if='data.lv == 2')
h3(class='ui header' tag-body='data.label' if='data.lv > 2')
```

Could be rewritten something like

``` html
<dynamic-tag tag-name='h${data.lv}' class='ui header' tag-body='data.label'/>
```

Would love to have another small lib like the one you created for this use case :)
 I would think I could achieve this something like this?

``` js
module.exports = function transform(node, compiler, template) {
    var name = node.getAttribute('tag-name');
    if (name != null) {
        node.removeAttribute('tag-name');
        var tagNode = this.compiler.createNode(name, node.getAttributes());

        node.parentNode.replaceChild(tagNode, node);
        node.forEachChild(function(child) {
          tagNode.appendChild(child);
        })
    }
};
```
 Fuck, I spent all morning trying to figure out how to evaluate an expression :P
Like trying to find a needle in a haystack... and looks like I don't have the data on the template at this stage?
I think the "replace tag name" should be done in the `doGenerateCode` somehow in order to have access to template data? I'm lost again...

I get this: If only I could substitute the template data on this string as a "template" and write it to `out`.

`<h$data.lv>hello world</h$data.lv>`
  I have an accordion tag like this `<div w-body="" class="ui $data.ui accordion"></div>`

When I use it like:

``` html
    <ui-accordion>
      <acc-block active="true" label="Yeah" text="hello world"></acc-block>
    </ui-accordion>
```

It compiles to:

``` js
function create(__helpers) {
  var str = __helpers.s,
      empty = __helpers.e,
      notEmpty = __helpers.ne,
      escapeXmlAttr = __helpers.xa;

  return function render(data, out) {
    out.w('<div w-body class="ui ' +
      escapeXmlAttr(data.ui) +
      ' accordion"></div>');
  };
}
(module.exports = require("marko").c(__filename)).c(create);
```

and so, renders:

`<div w-body="" class="ui  accordion"></div>`

I would have thought the compiler would use `w-body` attribute to understand, that the (internal) body tags of the accordion tag should be inserted as children to the container tag to build up the accordion?

``` js
    /// accordion start tag
    if (input.renderBody) {
        input.renderBody(out);
    }
    /// accordion end tag
```
 oh, I thought w-bind was only required for widgets? This is just a custom tag
 With `w-bind` I get:

``` js
  return function render(data, out) {
    out.w('<div w-body w-bind class="ui ' +
      escapeXmlAttr(data.ui) +
      ' accordion"></div>');
  };
```

So this only works for widgets then?
 why not enable `w-body` for tags? why have two different ways of achieving the same?
 Great! it works :) But then the marko docs need to be updated to reflect this.

https://github.com/marko-js/marko/#tag-renderer
 Why not make some kind of convenience attribute or tag like w-body for this common use case at least? 
<tag-body>
 Fx `<tag-body/>`, which simply calls `<invoke function="data.renderBody(out)" if="data.renderBody"/>`
 Trying to patch this fix in marko

`core-tag-transformer.js`

``` js
var BodyNode = require('./BodyNode');
...
    [
        'tag-body', function(attr, node) {
            console.log('tag-body attr');
            var bodyNode = this.compiler.createNode(BodyNode, {
                    renderBody: true,
                    pos: node.getPosition()
                });
            node.parentNode.replaceChild(bodyNode, node);
            bodyNode.appendChild(node);
        }
    ],
```

`BodyNode.js`

``` js
'use strict';
function BodyNode(props) {
    BodyNode.$super.call(this, 'tag-body');
    if (props) {
        this.setProperties(props);
    }
}
BodyNode.prototype = {
    doGenerateCode: function (template) {
      template.statement('').indent(function () {
          this.generateCodeForChildren(template);
      }, this).line('');
    }
};

module.exports = BodyNode;
```

`accordion-tag.marko`

``` html
<div class='container' tag-body=''>
</div>
```

`accordion-tag.js`

``` js
var template = require('./accordion-tag.marko');

exports.renderer = function(input, out) {
  console.log('accordion input', input);
  template.render(input, out);
};
```

`accordion-tag.json`

``` js
{
    "renderer": "./accordion-tag.js"
}
```

`marko-taglib.json`

``` json
...
        "test-accordion": "taglib/accordion-tag.json",
```

``` html
<test-accordion>
  <h3>I'm your Buddy</h3>
</test-accordion>
```

What am I missing? I really don't like the idea of having to pollute my tags 
with `<invoke` everywhere...

It generates this:

``` js
  return function render(data, out) {
    __tag(out,
      ______taglib_accordion_tag_js,
      {},
      function(out) {
        out.w('<h3>I\'m your Buddy</h3>');
      });
  };
}
```

So I guess I just need to make the inner body output function self-calling!?
 And I even try this, trying to simply wrap the InvokeNode invocation directly...

``` js
var InvokeNode = require('./InvokeNode');

function BodyNode(props) {
    console.log('BodyNode', props);
    return InvokeNode({function: "data.renderBody(out)", if: "data.renderBody"});
}

module.exports = BodyNode;
```
 Yeah, I know, but still... I'm just trying to understand some of the marko internals. 
Why won't this work?

``` js
'use strict';

var InvokeNode = require('./InvokeNode');

function BodyNode(props) {
  console.log('BodyNode', props);
  InvokeNode(props);
}

module.exports = BodyNode;
```

Looks like a pretty logical way to wrap `<invoke>` tag to me...

``` js
        'tag-body', function(attr, node) {
            var bodyNode = this.compiler.createNode(BodyNode, {
                    function: "data.renderBody(out)",
                    if: "data.renderBody",
                    pos: node.getPosition()
                });
            console.log('bodyNode', bodyNode);
            node.parentNode.replaceChild(bodyNode, node);
            bodyNode.appendChild(node);
        }
```
 Thanks ;) I give up for now... tried all the ways I could think of.
 Haha ;) As always, when I finally gave up a saw the light, and now I got it working in elegant fashion, exactly  like wanted to :)

Pure and simple!

``` js
    [
        'tag-body', function(attr, node) {
            // node.setAttribute('renderBody', true, false);
            var invokeNode = this.compiler.createNode(InvokeNode, {
                    function: "data.renderBody(out)",
                    if: "data.renderBody",
                    pos: node.getPosition()
                });
            node.appendChild(invokeNode);
        }
    ],
```
 My only problem is the test:

``` sh
  1 failing

  1) render tag-body:
     Unexpected output for "/Users/kristianmandrup/repos/markoa/marko/test/fixtures/templates/tag-body/template.marko":
EXPECTED (/Users/kristianmandrup/repos/markoa/marko/test/fixtures/templates/tag-body/expected.html):
---------
<div class="container"><h3>I'm your Buddy</h3></div>

---------
ACTUAL (/Users/kristianmandrup/repos/markoa/marko/test/fixtures/templates/tag-body/actual.html):
---------
<div class="container"><h3>I'm your Buddy</h3></div>
---------
  Error: Unexpected output for "test/fixtures/templates/tag-body/template.marko":
  EXPECTED (test/fixtures/templates/tag-body/expected.html):
  ---------
  <div class="container"><h3>I'm your Buddy</h3></div>

  ---------
  ACTUAL (test/fixtures/templates/tag-body/actual.html):
  ---------
  <div class="container"><h3>I'm your Buddy</h3></div>
  ---------
      at EventEmitter.<anonymous> (test/util.js:72:27)
      at testRender (test/util.js:90:14)
      at Context.<anonymous> (test/util.js:116:13)
```

Very strange!?
  I'm writing a huge set of taglibs to wrap all of Semantic UI. 
Problem is that if I/when make any mistake, no taglibs seem be loaded and no errors are shown in the console either. 

I'm trying to heavily leverage taglib imports:

``` js
{
  "tags-dir": ".",
  "taglib-imports": [
    "./list/marko-taglib.json"
  ]  
}
```

In my real scenario, there would be ~20 taglibs imported.
Is there a way to turn on some kind of debugging, logging of how marko resolves the taglibs and where it gives up? This is becoming a real PAIN to me :(
Thanks :)
 I tried cloning marko, npm linking it and then inserting debug statements...

``` sh
Marko appplication ready on port 4000
[browser-refresh] Server is ready. Watching files for changes.
[browser-refresh] Triggering refresh of client pages...
[browser-refresh] Refresh triggered
page state { title: 'Repo manager',
  header: 'Repo manager',
  content: 'Hello',
  lists: { users: [ [Object], [Object] ] } }
template data { title: 'Repo manager',
  header: 'Repo manager',
  content: 'Hello',
  lists: { users: [ [Object], [Object] ] } }
rendering template: /Users/kristianmandrup/repos/test123/repo-manager-v3/apps/index/page/index.marko
state: { title: 'Repo manager',
  header: 'Repo manager',
  content: 'Hello',
  lists: { users: [ [Object], [Object] ] },
  '$global': 
   { menus: { main: [Object], session: [Object] },
     lists: { repos: [Object], teams: [Object], users: [Object] },
     feeds: { activity: [Object] },
     appName: 'Repo Manager v3' } }
loadTagLib /Users/kristianmandrup/repos/markoa/marko/taglibs/core/marko-taglib.json
loadTagLib /Users/kristianmandrup/repos/markoa/marko/taglibs/html/marko-taglib.json
loadTagLib /Users/kristianmandrup/repos/markoa/marko/taglibs/caching/marko-taglib.json
loadTagLib /Users/kristianmandrup/repos/markoa/marko/node_modules/marko-layout/marko-taglib.json
loadTagLib /Users/kristianmandrup/repos/markoa/marko/node_modules/marko-async/marko-taglib.json
```

But my own custom taglibs are NEVER loaded it seems?

``` js
    tagsDir: function(dir) {
        // The "tags-dir" property is used to supporting scanning
        // of a directory to discover custom tags. Scanning a directory
        // is a much simpler way for a developer to create custom tags.
        // Only one tag is allowed per directory and the directory name
        // corresponds to the tag name. We only search for directories
        // one level deep.
        var taglib = this.taglib;
        var path = this.path;
        var dirname = this.dirname;
        // TAGLIB DIR
        console.log('tagsDir', dir);
        if (Array.isArray(dir)) {
            for (var i = 0; i < dir.length; i++) {
                scanTagsDir(path, dirname, dir[i], taglib);
            }
        } else {
            scanTagsDir(path, dirname, dir, taglib);
        }
    },

    taglibImports: function(imports) {
        // The "taglib-imports" property allows another taglib to be imported
        // into this taglib so that the tags defined in the imported taglib
        // will be part of this taglib.
        //
        // NOTE: If a taglib import refers to a package.json file then we read
        //       the package.json file and automatically import *all* of the
        //       taglibs from the installed modules found in the "dependencies"
        //       section
        var taglib = this.taglib;
        var dirname = this.dirname;
        var importPath;
        var resolveFrom = require('resolve-from');
        // ITERATE
        console.log('imports', imports);
        if (imports && Array.isArray(imports)) {
            for (var i=0; i<imports.length; i++) {
                var curImport = imports[i];
                // CURRENT
                console.log('import', curImport);
                if (typeof curImport === 'string') {

                    } else {
                        importPath = resolveFrom(dirname, curImport);
                        // ADDED
                        console.log('taglib.addImport', importPath);
                        taglib.addImport(importPath);
                    }
...
```

Please provide much better documentation on this feature and guidance on how to debug issues with resolution of tags and taglibs.  
 I simply don't understand how to interpret the documentation on this. Does marko ONLY use the first `marko-taglib.json` it encounters as it travels up the path, or does it resolve all taglibs that it finds on its way? What if multiple taglibs import the same other taglibs? etc. etc?

In my scenario I have the following structure:

``` sh
apps
  /_global
    /components
      /list
        /ui-list (tag)
          template.marko
          ...
       marko-taglib.json `tags-dir: '.'`
    marko-taglib.json `taglib-imports: [ './list/marko-taglib.json', ...]`
 marko-taglib.json `taglib-imports: [ './components/marko-taglib.json']`  

  /index
   /components
     ...
    /page
     index.marko (references `ui-list` tag)
   marko-taglib.json `tags-dir: './components'`
```

Should I also reference the global taglib from the index taglib, or will it auto-resolve as it goes up?
I had it working until I introduced the extra level in the components folder in order to group tags by type/category. Why!? Im lost...
 Looks like the problem is in part caused by using `browser-refresh` :O
With some more debugging in the taglibs compiler (which is in BIG NEED of REFACTORING!!!)

``` sh
taglib lookup: buildLookup /Users/kristianmandrup/repos/test123/repo-manager-v3/apps/_global/components/icon-item
tryDir /Users/kristianmandrup/repos/test123/repo-manager-v3/apps/_global/components/icon-item/marko-taglib.json
tryDir /Users/kristianmandrup/repos/test123/repo-manager-v3/apps/_global/components/marko-taglib.json
tryDir /Users/kristianmandrup/repos/test123/repo-manager-v3/apps/_global/marko-taglib.json
tryDir /Users/kristianmandrup/repos/test123/repo-manager-v3/apps/marko-taglib.json
tryDir /Users/kristianmandrup/repos/test123/repo-manager-v3/marko-taglib.json
tryDir /Users/kristianmandrup/repos/test123/marko-taglib.json
tryDir /Users/kristianmandrup/repos/marko-taglib.json
tryDir /Users/kristianmandrup/marko-taglib.json
tryDir /Users/marko-taglib.json
tryDir /marko-taglib.json
taglib lookup: buildLookup /Users/kristianmandrup/repos/test123/repo-manager-v3/apps/_global/components/ui-icon
tryDir /Users/kristianmandrup/repos/test123/repo-manager-v3/apps/_global/components/ui-icon/marko-taglib.json
tryDir /Users/kristianmandrup/repos/test123/repo-manager-v3/apps/_global/components/marko-taglib.json
tryDir /Users/kristianmandrup/repos/test123/repo-manager-v3/apps/_global/marko-taglib.json
tryDir /Users/kristianmandrup/repos/test123/repo-manager-v3/apps/marko-taglib.json
tryDir /Users/kristianmandrup/repos/test123/repo-manager-v3/marko-taglib.json
tryDir /Users/kristianmandrup/repos/test123/marko-taglib.json
tryDir /Users/kristianmandrup/repos/marko-taglib.json
tryDir /Users/kristianmandrup/marko-taglib.json
tryDir /Users/marko-taglib.json
tryDir /marko-taglib.json
```
 My conclusion so far: You can only import at ONE level. You CANNOT currently have a taglib which imports a taglib which imports yet another taglib. But WHY this LIMIT!? Is just a basic recursive model...
 By going through the code I can see that it seems it is not currently setup to allow this. It assumes any imported taglib is a "leaf" taglib apparently...

``` js
exports.loadTaglib = function(path) {
    console.log('loadTagLib', path);
    var taglibProps = taglibReader.readTaglib(path);

    var taglib = new Taglib(path);
    taglib.addInputFile(path);
```

I'm completely baffled!!! This ruins my whole design... I simply can't believe it. Please help me resolve this bug ASAP. Thanks :)
 Was a hunch. But no. However I ran into a caching issue as well. If I had a taglib, importing another taglib which referenced a tag dir, the final taglib did not resolve until I inserted a space in that taglib and saved.
 Thanks :) Please make a test case to cover my issue. I would love to help out myself. This is bugging me down...
 I just sent you a zip with a fixture for this scenario.
 and here my attempt at testing taglib imports (currently NO test coverage)

`taglib-imports-test.js`

``` js
'use strict';
var chai = require('chai');
chai.Assertion.includeStack = true;
require('chai').should();
var expect = require('chai').expect;
var nodePath = require('path');

describe('taglib-lookup' , function() {

    beforeEach(function(done) {
        for (var k in require.cache) {
            if (require.cache.hasOwnProperty(k)) {
                delete require.cache[k];
            }
        }

        done();
    });

    it('should lookup taglibs with nested-import', function() {
      var taglibLookup = require('../compiler').taglibs.lookup;
      var lookup = taglibLookup.buildLookup(nodePath.join(__dirname, 'fixtures/nested-import'));
      console.log('lookup', lookup);
      // NOT SURE WHAT TO TEST FOR FROM HERE
    });
});
```
 Awesome! I can hardly believe it :) Thanks a million @patrick-steele-idem :)
 Would be even better if there was a way to add some kind of basic logging for taglib and tag resolution somehow ;) 
 I tried it out. Still doesn't work. In my case, for some reason it never even calls `handleImports`.
I added a console log directly to the `node_modules/marko/compiler/taglibs/taglib-lookup.js`

Seems like marko "stalls" before ever starting to resolve even my first taglib, never ever calling `tagDir` for some reason :( And this stalling only occurs when I have nested taglibs like in the example I sent. Strange indeed!
 Thanks. Just tried it. Still same problem.
 I have the exactly the setup I described above.

A page `index.marko` referencing a tag `icon-list`
Then a `marko-taglib.json` in parent folder referencing "internal" taglib to the page via `tags-dir`, then one level further up, a taglib, importing the global components via `taglib-imports`. From here it gets tricky. 
In `global/components/marko-taglib.json`, if I only use `tags-dir` everything "just works". However if I use `taglib-imports`, the lookup only looks up the pre-registered taglibs and never even attempts to find my own taglibs.

``` js
function buildLookup(dirname) {
  var taglibs = taglibFinder.find(dirname, exports.registeredTaglibs);
  ...
```

Never goes beyond `exports.registeredTaglibs` for some reason!?

``` js
    var lookup = lookupCache[lookupCacheKey];
    if (lookup === undefined) {
          // do your magic
```

For some reason `lookup` is NOT undefined!? in this case or what? hmm...
 Not crashing, just never trying to resolve any tag libs not pre-registered. 
PS: How would I preregister my own taglibs? Perhaps better/easier to use the `package.json` import strategy? They are global components after all...
 no, all is local. I'm using latest master. `buildLookup` is never called. What is the entry point?

``` js
function buildLookup(dirname) {
    console.log('buildLookup', dirname);
```

TemplateCompiler never called either? Something is VERY fishy!

``` js
function TemplateCompiler(path, options) {
    this.dirname = nodePath.dirname(path);
    this.path = path;
    this.taglibs = taglibs.buildLookup(this.dirname);
```
 Yeah, I run with `MARKO_CLEAN=true node .` each time. Neither `compile` nor `compileFile` of `marko-compiler.js` are being called :P
 But when I move my `icon-list` tag up to the next level of tag libs (ie. not nested anymore) - everything works again, template is compiled etc:

Problem is when I put my template at `apps/_global/components/list/ui-icon/template.marko`
ie. inside `list` folder. I wonder if somehow list is a reserved name or sth very strange?!

``` sh
createCompiler /Users/kristianmandrup/repos/test123/repo-manager-v3/apps/_global/components/ui-icon/template.marko
TemplateCompiler path /Users/kristianmandrup/repos/test123/repo-manager-v3/apps/_global/components/ui-icon/template.marko
buildLookup /Users/kristianmandrup/repos/test123/repo-manager-v3/apps/_global/components/ui-icon
lookup /Users/kristianmandrup/repos/test123/repo-manager-v3/apps/_global/components/marko-taglib.json,/Users/kristianmandrup/repos/test123/repo-manager-v3/apps/marko-taglib.json,markoa-skeleton-app,browser-refresh-taglib,marko-core,marko-html,marko-caching,marko-layout,marko-async { merged: 
   { path: '/Users/kristianmandrup/repos/test123/repo-manager-v3/node_modules/marko/node_modules/marko-async/marko-taglib.json',
```
 How can we make a test for this?
 ``` js
if (process.env.MARKO_CLEAN === '' || process.env.MARKO_CLEAN === 'true') {
    defaultOptions.checkUpToDate = false;
}
```

So the problem could be in this "up to date" logic I guess?
 It operates on taglibs to determine if they have been updated...

``` js
exports.getLastModified = function(sourceFile, taglibs) {
    var statSource = fs.statSync(sourceFile);
    var lastModifiedTime = statSource.mtime.getTime();
    var taglibFiles = taglibs.getInputFiles();

    ...
    // Now check if any of the taglib files have been modified after the target file was generated
```

I think this is a naive check, and that is the problem. Only checks first level taglibs, again not recursive :P
 Yes, NO templates are compiled when I have nested taglibs for some strange reason... trying to figure out why/where it decided to skip this step.
 Doesn't even call `checkUpToDate` :O

``` js
 checkUpToDate: function(targetFile) {
    console.log('checkUpToDate', targetFile);
```
 What is top level entry point to start compilation or decide whether to compile template?

`module.exports = function load(templatePath) {` in `loader.js` perhaps?
 Thanks for all your assistance :)
  In the `marko-widget` docs, you use the following to indicate the placeholder for contained body content:

`<span w-body></span>`

"used to determine the nested external content that is to be injected into the body of the UI component (to support transclusion). The actual injection point is determined by the `w-body` attribute."

Can I use this for regular tags as well? If so, please document use in this project as well ;)
What is a valid attribute value for `w-body` if one must be provided for whatever reason?
 Answer from https://github.com/marko-js/marko-widgets

If it helps, an attribute with no value is equivalent to an attribute with a value of an empty string:

`<span w-body></span> === <span w-body=""></span>`

The purpose of the `w-body` attribute is to support transclusion. If the user of a custom tag nested content inside the custom tag then that content will get injected into the output HTML relative to the `w-body` marker. In addition, if the widget rerenders then the body content will be preserved (since that content is external to the widget). For example, below is the usage of a custom tag with nested content:

``` html
<my-awesome-component>
    This is nested content that will be injected into the `w-body` element.
</my-awesome-component>
```
 Yeah, was a way to add docs via a FAQ entry using an issue :P

Please make a note in tag-renderer section that the `w-body` attribute can be used in the marko template for the same effect as `renderBody(out)`. That would connect the dots I think. 
Thanks :)
 @kristianmandrup please see the PR if it fits your needs....
    Fixes https://github.com/marko-js/marko-widgets/issues/64
 fixes: https://github.com/marko-js/marko/issues/15
   thanks. happy to be part of a great team!
  I pass an array of the form:

``` js
[
{label: 'my label', icon: 'users'},
{label: 'extra', icon: 'feed'},
]
```

`index.marko`

``` html
<icon-list items="${data.items}"/>
```

`icon-list.marko`

``` html
<for each="item in $data.items">
  $item.label
</for>
```

But when I debug, I get a strange '*': entry as my first key!? WTF!?

`list { '*': { items: [ [Object], [Object] ] } }`

Looks like it should be `data` in this case (`for each`) without the `$` sign. 
Not clear from the docs IMO.

``` html
<for each="item in data.items">
  $item.label
</for>
```

Now we get an error about some strange error, 'unexpected token {'  Damn!
 Thanks, I figured that was the issue, since I had seen a brief mention somewhere about the `@*` being a "catch all" in your docs about the schema. But wasn't really clear that not declaring the schema value would cause this kind of problem. I guess when you go beyond strings, you currently have to specify the schema carefully in order to make marko understand. Kinda makes sense. I posted my solution/suggestion for proposal #90 which would make it awesome!!
  I think it comes down to a missing dependency or something, but would be nice with a clearer error message than this:

the `marko-taglib.json` it complains about.

``` json
{
    "tags-dir": "./_global/components"
}
```

Confusing error message:

``` sh
Error: Error while handling properties for /home/isaura/tecla5/repo-manager-v2/apps/marko-taglib.json: Error while applying option of "tags-dir". Cause: SyntaxError: Unexpected token }
      at Object.parse (native)
      at scanTagsDir (/home/isaura/tecla5/repo-manager-v2/node_modules/marko/compiler/taglibs/taglib-loader/scanTagsDir.js:66:27)
      at Object.TaglibHandlers.tagsDir (/home/isaura/tecla5/repo-manager-v2/node_modules/marko/compiler/taglibs/taglib-loader/loader-taglib.js:134:13)
      at invokeHandlers (/home/isaura/tecla5/repo-manager-v2/node_modules/marko/node_modules/property-handlers/lib/index.js:66:29)
      at Object.exports.loadTaglib (/home/isaura/tecla5/repo-manager-v2/node_modules/marko/compiler/taglibs/taglib-loader/loader-taglib.js:257:5)
```
 Awesome :) Gracias amigo! When do you expect a Marko Widgets 5.0 release? 1wk, 2wks, more?
  It keeps downloading the file. this is the gist of my code.

``` js
'use strict';
let koa    = require('koa')
let app    = koa()
app.use(function* () {
    this.body = require('marko').load(require.resolve('./views/index.marko')).stream()
    this.type = 'type/html'
})
app.listen(3000);
```

Whenever I navigate to localhost:3000/, it downloads a file with "hello" in it. I have no idea what's happening or what I'm doing wrong.

views/index.marko is just 

``` html
hello
```

right now.
 No, that. was a good thought, but unfortunately that did not solve my problem. It is still just downloading the file.
 omg...I hate when it's a stupid error like this...had to change `type/html` to `text/html`

Thanks for your help!
 So is correct: this.type = "html";
 Your marko is "simple" enough, but how do I build a binary tree with marko? In ejs template I can just like so using pure javascript write helper functions for a tree hierarchy inner <% functinon buildTree(root){ var html="blablabla"; return html;}%> <%- buildTree(someRoot)%>. But with marko I don't understand how to do it like this. Where is marko's tutos can i find?
 Many, many thanks, it's just incredible!
  Hello team,

I was wondering if there is any way to access messages set with flash using the following api.

``` javascript
req.flash('success', 'Account Created Successfully!');
```

is it `${flash}`? or something else within a `.marko` file?

Thank you.

Deep
 Thank you! That worked!!

Now I have a debug question. I am getting a 500 error when trying to do the following:

`<require module="../private_libraries/globals_v1.js" var="globals"/>`
`<if test="!globals.isEmpty(data.messages)">Not Empty</if>`

```
// globals_v1.js
exports.isEmpty = function (obj) {
for(var prop in obj) {
    if(obj.hasOwnProperty(prop))
        return false;
}

return true;
};
```

where data.messages is being passed in as the flashMessage. isEmpty is a function that runs through that object to make sure nothing is contained in that data.messages object, but I'm getting a 500.

Any ideas on how to resolve and/or better yet, debug that 500? there are no messages that get spit out besides the 500 error result.

Thank you.

Deep
 Hello Patryk, will comment here because I have a related question.
What if the flash messages are sent before a

```
res.redirect('/');
```

?

In this case how can I pass the parameter to the .marko layout since I am not calling the render method?
  The utility function `getLength()` for loop status variables was previously undocumented.
  I tried to add:

``` json
 "marko": {
  "extends": "html"
}
```

but no luck...
  I'm planning to leverage Jade to make it easier/faster to write the marko templates...

So far I've uncovered the following special marko and lasso tags:

```
<if
<include
<require
<var
<assign
<with
<else-if
<else>
<for
<def
<invoke
<layout-placeholder
<layout-use
<layout-put
<lasso-page
<lasso-head
<lasso-body
```

Am I missing any important pieces? Looks like [pencil](https://www.npmjs.com/package/pencil) would make it pretty easy to add such custom tags to Jade and then I can have a `gulp watch` task auto-compile to marko. Sweet :)
    es6 template strings use the format ${expression}

I was wondering if marko can handle this (apparent) conflict? Sorry if I missed something in the docs.
 Great. Thanks for the response!
  Please add a way to programmatically add specific folders to perform `Taglib Discovery` in order not to be forced to rely on node default search strategy. Something like:

`marko.taglibs.discovery([myTaglibsPath, myOtherTaglibsPath, ...]);`

Thanks :)
 Thanks :) Trying to make sense of this...

Various "clever" ways for using taglibs:

``` js
{
    "<my-hello>": {
        "renderer": "./hello-renderer",
        "@name": "string"
    }
}
```

Importing other taglibs :)

``` js
taglibImports: function(imports) {
    // The "taglib-imports" property allows another taglib to be imported
    // into this taglib so that the tags defined in the imported taglib
    // will be part of this taglib.
    //
    // NOTE: If a taglib import refers to a package.json file then we read
    //       the package.json file and automatically import *all* of the
    //       taglibs from the installed modules found in the "dependencies"
    //       section
```

The "normal" way

`importPath = resolveFrom(dirname, dependencyName + '/marko-taglib.json')`

Trying to combine local with global/shared taglibs

``` js
{
  tagsDir: './my-tags',
  taglibImports: ['../../package.json']
}
```

// package.json

``` js
{
  dependencies: {
    // how does the import expect to find taglibs from external module??
    // what are the conventions in this case!?
    'my-global-taglib': 'x',
    ...
  }
}
```

Another proposal - direct require (why traverse all dependencies?)

``` js
{
  tagsDir: './my-tags',
  // refers to a package in my package.json
  // why not require module directly? (ie. not local since not prefixed by ./ )
  taglibImports: ['my-global-taglib', 'my-other-shared-taglib-module']
}
```
 Hi, 

I'm trying to use the `taglib-import` feature as I really need it now. I think I understand the `package.json` mechanism, but not sure about the `else` part, line `176`. What should be at `./_global/components/menu` for this to work? I assume resolveFrom it just a special wrapper for node `require` using `curImport` as the base path?

``` js
else
  importPath = resolveFrom(dirname, curImport);
  taglib.addImport(importPath);
```

``` json
{
    "tags-dir": ".components",
    "taglib-imports": [
      "./components/menu",
      ...
    ]
}
```

My target file structure

``` sh
/components
  /my-comp
  /menu
    /other-comp
```
 I got it, must be `"./components/menu/marko-taglib.json"`, however why not assume that by default given a path without it? At least it works for me now. So cool :)
  i make layout file

``` html
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@ taglib prefix="sec" uri="http://www.springframework.org/security/tags" %>
<%@ taglib prefix="spring" uri="http://www.springframework.org/tags" %>
<%

%>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>

</body>
</html>
```

and run `marko`

this is result

``` html
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@ taglib prefix="sec" uri="http://www.springframework.org/security/tags" %>
<%@ taglib prefix="spring" uri="http://www.springframework.org/tags" %>
<% %>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>


</body>
</html></%></%@></%@></%@>
```

i want to ignore the tag ( `<%`, `<%@` ). Is there a possibility that does not analyze the specific tag?
 Thank you very much~~ :+1: 
  unless i'm missing something, it seems all compiled files are created in the same directory / path as the template sources.

this means having additional complex rules for `.gitignore` in cases where `.marko` is not used as the extension!

would be a lot simpler to store all compiled files (under the same directory tree) starting a temp root path, that can be easily cleared / deleted as needed, and can be simply ignored from the project/repository version control. 
 > the Marko compiler puts the compiled templates next to the original template because the Node.js module loader is context aware and we want the stack traces to match up with location that the Node.js module loader associates with the loaded compiled template

fully agree with this _(just wanted to be clear)_

> While we could place the compiled template at a different location on disk, we would need to change how the relative require paths are generated. 

I have not looked at the internals _\- yet -_, but in theory, should be done in such a way that changing the `cwd` or `root` would be sufficient. 

your example is exactly what I'm interested in. but I would also add that each module (and module maintainer, whether internal or external) should be free to determine the best setup for that module.

I'm guessing your basing your use-case on a hierarchy of modules used within one system, but the moment you go out of the scope of the one system then the module wouldn't know where to look for its compiled templates.

so it's best to keep the separation between modules to ensure true portability of the module itself.

that of course would become complicated if you're doing template dependencies between modules, but rather than solve that problem a better pattern would be to have only the main / root module be responsible for compiling, and if there are dependant module templates, they are simply pointed to, and the compiled output is stored elsewhere.

###### example

for this module, the package maintainer chooses to store in a folder `.marko-compiled-location-a`, this is only relevant when that module is used on its own.

```
my-installed-module/
    .marko-compiled-location-a/
        foo/
            template.marko.js
        bar/
            template.marko.js
    foo/
        template.marko
    bar/
        template.marko
```

but when the module is used as a dependency of another system, the dependant chooses where the final compiled files should live:

```
my-app/
    .marko-compiled/
        foo/
            template.marko.js
        bar/
            template.marko.js
        .marko-dependants/
            foo/
                template.marko.js
            bar/
                template.marko.js
    foo/
        template.marko
    bar/
        template.marko
    node_modules/
        my-installed-module/
            foo/
                template.marko
            bar/
                template.marko
```

again, not sure what the best path design here would be, but, with the current setup, it makes it very noisy (for simple usage like static site building) and cumbersome with server-side live systems, especially if you're doing live reloading of the application, your template changes may not get refreshed.
 yes indeed this does satisfy the ask here :+1: 

wish there was a cleaner way to set this option though ..
 I have to play around with it more first ... I'm thinking this should be done on the main include:

``` js
var marko = require('marko')
marko.compiler({
  ...
})
```

or 

``` js
marko.compilerConfig = {
  ...
}
```

etc ..
 @ahmadnassri If you're using Express JS, there could be a cleaner way to define configuration with an API similar to what I've proposed in #165. If there was a Marko Express plugin, when initializing the engine you could pass configuration options to Marko similar to how defined them above...

``` javascript
var Marko = require("marko-express"); // example lib name
app.engine("marko", Marko({ writeToDisk: false }));
app.set("view engine", "marko");
```
 not using express for this particular project (It's a static site builder, no server required), though that example makes sense.
  I am creating `grunt marko plugin'
https://github.com/thomasJang/grunt-ax-marko

i have question. can i change marko-taglib.json path?
i know marko-taglib.json is same template path
 i'm sorry @patrick-steele-idem 
can be changed to another location, not the position determined the location of a file
 There is no big problem.It can be used now as.

However, if you want to place the resources and content, such as preferences for `java` project to another space may become a problem.
Also, in the case of the I, as follows, when you try to be able to set the location of each of the environment file it seems to be a problem.

https://www.npmjs.com/package/grunt-ax-marko#overview

``` js
grunt.initConfig({
    ax_marko: {
        default: {
            options: {
                preserveWhitespace: true // expected output whitespace 
            },
            files: [
                {
                    src: "test/fixtures/*.html",
                    global_data: { // append data 
                        layout_path: "../layouts/basic.marko" // src relative path 
                    },
                    lang: {
                        ko: "test/lang/ko.json",
                        en: "test/lang/en.json"
                    },
                    dest: "test/expected",
                    output_extension: "html"
                }
            ]
        }
    },
});
```

Have met in such highly-level project is sincerely happy.
I is JSUI developers. Opportunity I want to make even UI in which the `marko` to base if.
  i try 

``` js
tmpl.render(data, function(err, output){
    if(!err)
        grunt.file.write(dest, output);
    else
        grunt.log.error(err);
});
```

output is

``` html
<!DOCTYPE html> <html lang="en"><head><meta charset="UTF-8"><title></title></head><body><h1>My Page</h1>Hello World! <ul><li style="color: red">red</li><li style="color: green">green</li><li style="color: blue">blue</li></ul></body></html>
```

Is there a way, get output with `\n` 
plz help me
 and i'm sorry i can't speak english
 thank you very much ~ marko perfect : )
  I might be doing something wrong, but whenever my express app hits the `var template = require('./hello.marko');` a `hello.marko.js` file is created alongside the original file.  Is there a way to render marko templates from node without this filesystem dependency?

Thanks.
 One of the main benefits of Marko is that templates are compiled to javascript so that they can be executed on both client and server. Theoretically, you could compile to the javascript API and handle it yourself - see the bottom of this section: https://github.com/raptorjs/marko#template-compilation). Is there a particular reason that you're trying to avoid compilation?
 I don't have any problem with a compilation step, most templating systems behave similarly.  I'm just wondering if it's required to compile to the filesystem as opposed to having a purely in-memory compilation.
 Sorry I missed your part about the template-compilation with Javascript API.

I attempted using compileFile but the source that is returned is in the format of a common js module, which still isn't of much use unless it gets written to a file.  I was kind of hoping to somehow get back a compiled template function that can be instantly ran, similar to https://lodash.com/docs#template
 Thanks for the relevant issue, I searched but did not find that somehow.  That answers my question.
  Hi again,

I've been working on a large Koa server project where we want to allow mounting of multiple SPAs using Marko. Each SPA is a separate Node package (module).
It would be really nice if we could specify the root common templates folder for each page. 

The following should give an idea of my ideal application layout, split into a module for each SPA.
The `app.js` is the main app, which contains shared layout and partials for all SPAs to leverage.

``` sh
app.js
: require koa-server.js
  - default-layout.marko
  - partials
    - _header.marko
    - _footer,marko

index.je
: require app.js
  - index.marko
  - index-layout.marko

live.js 
: require app.js
  - live.marko
  - live-layout.marko
```

Alternatively I would have a `common.js` module, with the templates, layouts and partials common (shared) across multiple SPAs.

``` sh
common.js
  - partials
    - _header.marko
    - _footer,marko

live.js
: require app.js
: require common.js
  - live.marko
  - live-layout.marko
```

How would I conveniently reference such shared templates locations in other node modules, without hard coding a long ugly path such as `./node_modules/common/partials/_header`?
Would this be a feature enhancement/request?

Any ideas or recommendations greatly appreciated. Thanks ;)
 Awesome! Thanks a lot Patrick! Will start switching to Custom Tags for more awesome power and flexibility.
  Is this all it takes? => https://github.com/tj/consolidate.js/pull/158/files
 @patrick-steele-idem Do you happen to know if we can disable cache (aka the generated .js files) when using `consolidate.js`?

I am interested in this because I use marko as a template language for static site generator `metalsmith`, but because marko is smart enough to generate js files, it prevents us from using a watcher to reload template just by running the build process again on template change.

Is there a solution for that?

ref:
- https://github.com/FWeinb/metalsmith-watch @patrick-steele-idem Thx I did enable `invalidateCache`, it doesn't appear to find the right entry in `require.cache` to delete though. I need to figure out [why](https://github.com/FWeinb/metalsmith-watch/issues/36)...  We initially tried to use 

`<include name="xyz.marko" data="${data}"/>`

but this is (obviously!) a terrible idea whioch doesn't work. What is the recommended pattern, besides copying down each specific value which the partial is depending on, which can quickly make for tight coupling in the hierarchy!!

`<include name="xyz.marko" page="${data.page}" providers="${data.providers}"/>`
 We have this problem 

views/layouts/default-layout.marko:
 ....  <include template="./../partials/header/header.marko" menu_items="$data.globals"/>

views/partials/header/header.marko:

<p>${data.menu_items}</p>

and is empty data
  When `<include>` is given a hard-coded path, it can be relative, as said in the docs, or absolute. However, when it is given a variable path, as in `<include template="$data.templatePath" />`, it must be absolute (it will error out if relative).

**Works**

``` html
<include template="../relative/path/to/template.marko" />
```

**Works**

``` html
<var name="templatePath" value="'/absolute/path/to/template.marko'" />
<include template="$templatePath" />
```

**Works**

``` html
<include template="/absolute/path/to/template.marko" />
```

**Does Not Work**

``` html
<var name="templatePath" value="'../relative/path/to/template.marko'" />
<include template="$templatePath" />
```

It seems as if the issue is that hard-coded paths are `require.resolve`'d, while variable paths are not. Also, the docs could use an update, since it says that the template path must be relative, even for hard-coded paths.
  I would like to determine which custom tags get called via my renderer.js

So in the renderer, something like this:
`data.details=['d1','d2','d3']`

And then in template.marko (which doesn't work):
`<for each="detail in data.details">`
&nbsp;&nbsp;&nbsp;&nbsp;`<${detail} />`
`</for>`

One solution would be to explicitly call out tags conditionally:
`<for each="detail in data.details">`
&nbsp;&nbsp;&nbsp;&nbsp;`<if test="detail==='d1'">`
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`<d1 />`
&nbsp;&nbsp;&nbsp;&nbsp;`</if>`
`</for>`

But is there any other way to accomplish this?
 Thanks Patrick, that seems to work well. Do you know how I might include w-id in this case?

So that 

```
<detail w-id="detail[]" />
```

would become something like this...

```
<invoke function="renderer(data, out)" w-id="detail[]" />
```
 Ok thanks. That would be great if this could be supported.
  Custom Attributes is a great functionality. But current implementation does NOT support attribute value to come from a object.

Following statement is currently supported. but what if class name is coming dynamically from the JavaScript object.

<div class="{?data.active;tab-active}"></div>


Support for following is needed

<div class="{?data.active;data.model.class}"></div>


Also there is inconsistency across marko for defining JavaScript expression. Some places its using ${}, some places it dosent needs ${} and here its using {?condition;value} (WITHOUT $ sign)
 Thank you Patrick I didnt knew about attrs attribute, I have to finish up reading entire doc :)

On the second note It would be helpful if we can unify conditional statements as well for example below dosent with with `<assign>` but works with `<html class={?}>`
`<assign var="viewDetailsClass" value="{?data.listingModel.bin.binAction;btn;btn btn--primary}"/>`

May be using just using javascript inline if statement everywhere can solve the problem.
  I was working on creating reusable helper utility which will add _sp, class and id to any element when passing a common data model. After alot of try and error with variables, functions and ${} and without ${} I finally concluded that it may not be supported.

Support for calling a Helper Utility to render anything within the HTML element is desired.

Currently Marko supports calling JavaScript expression on right hand side after = sign (as below)

However following is not supported. hello

I have created a sample to explain the same.
https://github.corp.ebay.com/sugurnani/marko-dynamic-attributes/tree/master
 Thank you @patrick-steele-idem 

I was saw the documentation for defining custom tags but was unable to find info about creating custom attributes. Can you please point me to that doc?
  How about any JavaScript Object and JavaScript Arrays ?

my-component dynamic-int="${1==1? 25 : 26}" 
 I think it's a good idea to remove the noise of extra files. Making this part of the (marko-)html makes sense. 
:+1:

@SunnyGurnani I assume that should also work as Patrick mentioned support for the ${...} syntax.
 If you want to consider attribute value as JS expression, would you also support calling functions?

``` HTML
<my-component count=results.count() />
```
 Hi,
maybe it's worth considering the upcoming ES6 Template-Strings.
https://babeljs.io/docs/learn-es2015/#template-strings

If the proposal is a thought about getting the parser more towards js, the following:

``` html
<my-component dynamic-string='hello ${name}'/>
```

would lead towards:

``` html
<my-component template-string=`hello ${name}`/>
```

(yes, the backticks) if I got it right.
Not to talk about multiline strings.
And we'll be able to omit string-concatenation

``` html
<my-component string-concatenated=("hello "+name)/>
```

or am I completely wrong
greets Achim
 @patrick-steele-idem, I understand the migration-argument completely. For me as a total marko-noob, my thoughts were totally js-driven. It's the language I'm most familiar with, loving the new possibilities
and features of the upcoming es6. And with something like these...

``` html
<my-component string-concatenated=("hello "+name)/>
<my-component complex-function-call=(data.foo() + data.bar())/>
```

...I have to leave my way of js-thinking towards some marko-specials. If everything after the "=" is familiar js I don't have to think about marko. It just works.
Maybe this kind of thinking is too naive.
 My Suggestion would be to allow all javascript expression in ${} only to avoid any confusion.

With proposed method it would be very confusing for anyone who is new to Marko to figure out which is plain text and which is javascript expression.
 As i think more about it, i think what @SunnyGurnani proposed makes more sense and less confusing.

Few things to consider:
1. 'hello ${name}' is not a valid JS expression
2. If you want to actually have a string "[1, 2, 3]" as attribute value in mystring=[1, 2, 3] then it would have to be encoded which would make it look odd, otherwise it becomes array value.
 :+1:
 Thanks @pswar and @patrick-steele-idem 

JavaScript has given us the freedom from Classes and Types with current proposal we are taking away all that beauty and simplicity. I personally would prefer simplicity ${} for all expressions and let library handle the rest.

Current proposal suggest different implementation based on individual Types as following. However in JavaScript we never define type in the parameter or declare variable with type.

For dynamic string use ES6 strings
component attribute=`hello ${name}' 

Single function don't use anything
component attribute=data.foo()

For Multiple Functions use ()
component attribute=(data.foo() + data.bar())

For Object use {}
component attribute={hello: 'world'}

For Array use []
component attribute=[1,2,3]

@pswar I don't see any problem in following expression. Hello is static and ${name} is JavaScript expression. Please correct me if I am wrong?
component attribute="hello ${name}" 
 I was following up until the proposal that ${...} only be allowed within backtick-quoted attribute values, which would be a significant BC break.  I understand the desire to simplify, but that seems a step too far to me vs retaining the existing behavior where quoted attribute values are scanned for ${...} replacements.
 @patrick-steele-idem I understand where you're coming from, and in the end either way will work.  I guess the way I was looking at the interpolation within quoted attributes question was that it's simple to think of replacement working the same way there as it does within CDATA sections, since they're both "text" parts of HTML.

One question this does bring up is how the different quoting styles in the template would affect the quoting in the generated HTML.  For example, does this:

```
<my-component foo=`Hello ${data.name}`/>
```

compile to:

```
<my-component foo="Hello Dan" />
```

or:

```
<my-component foo='Hello Dan' />
```

or something else?
 I got your point @patrick-steele-idem 

I think then it would help to remove/depricate ${} from the language.
is there a need to use ES6 backticks ? Cant we just use following ? 
my-component string-concatenated=("hello "+name)

This would avoid confusion and make Marko much easier to learn for people new to language.
 @patrick-steele-idem So are we considering this just got custom tags or more generally?  My gut reaction would be that the syntax for custom tags should be as similar to "normal" tags as possible, which is where my (admittedly rushed) example came from, thinking about these template semantics in terms of defining attributes on regular tags.
 Coming from JSX-land, I suggest:

``` xml
<my-component foo={`Hello ${data.name}`} />
```

It would be great to have more overlap between the two standards. Many of us using marko on the back will be using Angular 2 or React/JSX on the front. I personally render React components and inject them into marko templates. 
 For conditional operators, how about something like this: 

```
<div if(x > 5)>
   Do something
</div>
```

instead of 

```
<div if=(x > 5)>
   Do something
</div>
```

For iterators, 

```
<ul>
   <li for(color in colors)>
       ${color}
   </li>
</ul>
```

instead of 

```
<ul>
    <li for="color in colors">
        ${color}
    </li>
</ul>
```
 @patrick-steele-idem 
I think the suggestion needs to be fixed to 

```
<div if(x > 5)>
   Do something
</div>
```

I see an '=' after the if, in the suggestion. 
 My gut reaction to this proposal was: "OH NO, NOT ANGULAR 2 SYNTAX!!!"

But reading a bit further on, I fully understand the reasoning. More power, less limits!!!
However I don't think it should be "all or nothin", breaking existing templates etc. 
My proposal: 
Allow the HTML "flavor" described above, but also allow/enable it while keeping in full HTML attribute compatibility mode, ie `x="y"`.

`<div x=(5-2*sqr(2))/>`

AND

`<div x.e="(5-2*sqr(2))"/>`

Where the `.e` means that the internals should be _evaluated_ as pure javascript and returned as:

`<div x=(5-2*sqrt(2))/>`

Then evaluated as javascript to finally render `<div x="12"/>`

It think this combines the best of both worlds (and would allow me to keep using jade to marko compilation!). The same principle would apply for string interpolation etc., ie. simply having `.e` attribute name postfix means a first "compilation" phase, basically just stripping the `"`s and understanding the intention as javascript evaluation :)
 Looks very cool :) Good job!!!
 Hi @philidem, 

When can we expect to begin experimenting with this or contribute? 
How do we hook the parser into markojs to replace the default Parser? 
Please add usage/install instructions. Cheers :)
 re: multiple variables, I don't know. I think most javascript styles these days prefer writing out one variable per line anyway.
 @patrick-steele-idem Sure, and it isn't necessarily bad to support multiple styles, it's just additional things to maintain, document, etc.

re: conditionals - I actually think that looks better. It is uglier, but it's standard js.
 Regarding conditionals, depending on how a falsy value is handled for the class attribute, the following would work... and it looks quite nice.

``` html
<div class=(data.isActive && 'active')>
```
  I suggest a new major version which uses Angular 2's new template syntax. Like Marko, this extends HTML well. I think this would quickly attract a wide set of people to the project!
  Might be able to close this per http://markojs.com/docs/syntax/#dynamic-attributes  With a marko page like this:
`<include template="./header.marko"/>`
`${data.bodyText}`
`<include template="./footer.marko"/>`

The rendered result is:
header content
footer content
body content

The expected result is:
header
body
footer
 Thanks for creating that.  This has to be my misunderstanding of what include would do.  Stripping the extra code from my header and footer I found the issue was if I have an open tag in the header (i.e. a `<body>` tag) and a closing tag in the footer (`</body>`), Marko adds a closing tag to the header and drops the closing tag from the footer.  

So it seems each included template has to be a stand-alone template, not depending on HTML tags opened or closed outside of that template.  Is that correct?
  Hi,
How can query params be added to a url when rendering a template `template.render({}, res);` so they can be accessed from the url e.g. http://domain.com/book?id=123 ?
 Assuming you have a request object like Express provides:

```
template.render({id: req.query.id}, res);
```

Then in the template:

```
<a href="http://domain.com/book?id=${data.id}">click</a>
```
 Thanks. I want to be able to append it to the url so I can then parse the URL for the page to access all the params via JS. I understand I can render a `<script>` tag in the template with the values but it would be a better solution to parse the URL in this case.

Is this possible do you know?
 I'm not sure that I follow what you're asking to be honest.  If you just want to access the query params from js in the browser you can do that without marko involvement at all by parsing `window.location.search` with client-side js. If you want to use marko to pass any requested params back to the template you could stick the entire `req.query` object into `data` like:

```
template.render({query: req.query}, res);
```

Then:

```
<script>
  var query = $!{JSON.stringify(data.query)};
</script>
```
 I've not explained this great. I'll have another go. 
(using Express + Marko)
Say I have a form submitted to '/book/:id' route, this is handled by a controller which saves the book to the DB. Once the book is saved I render a template '/book/complete'. But instead of the url being '/book/complete' I want it to be '/book/complete?id=123' (123 being the last ID added to the DB).
My problem is rendering the query string onto the URL on page load.

Your second solution makes sense but having script tags could get unwieldy across pages.

Does that explain it any better?
Thanks for persevering. 
 Honestly this doesn't sound like a marko issue at all, the URL in the browser isn't related to the name of the template.  If you want to have the browser show that URL you'll need to add a GET route for it and at the end of your POST handler use a redirect to make the browser load the desired URL.

```
return res.redirect('/book/complete?id=' + new_id);
```
 Couldn't see the wood for the trees! Thanks @DanCech.
  This tightens the entity matching regular expression to explicitly handle numeric and hexadecimal entities separately from named entities.  It also adds a simple test that entities are being properly matched.
  I didn't get how is it possible to render a template from string. Is it possible at all?

Thanks.
 Doesn't work in browser using browserify. I am getting
`require.resolve is not a function`
on

`exports.taglibs.registerTaglib(require.resolve("../taglibs/core/marko-taglib.json"));`
 Thanks for the directions, but I have already switched to another template engine, too much hassle for such a simple thing. As for me marko.load should be able to work with a raw template string or there should be any other method do this job in one line as it is in the most of the template engines.
Anyway thanks for your help.
 @patrick-steele-idem of course I agree with you. But I bet you will not notice a difference in case of simple templates between precompiled and compiled in browser. I am actually doing a simple Chrome extension and don't need 60 fps. Another thing is that usually you want to make it workable asap and after that do the optimizations so it is usually very handy to just have a single method for a single render operation to see it right away.
 Hi, I'd like to add a use case for client compilation.
We're currently not using nodejs on the server (but a CMS system) and would like our users to add their own custom templates to a "templates library". We don't mind if this means a second or two delay compiling the template before its pushed to the library. These templates are then used in the main app.
Unfortunately at the moment it seems templates have to be pushed by the development team with access to a node environment. 
  It seems like the layout-put tag is not working as expected anymore. The test confirms this:

```
4) render layout-use:
     Error: Unexpected output for "/marko/test/fixtures/templates/layout-use/template.marko":
EXPECTED (/marko/test/fixtures/templates/layout-use/expected.html):
---------
<div>BODY CONTENT</div>FOOTER CONTENT<h1>HEADER CONTENT</h1><div>BODY CONTENT</div>FOOTER CONTENT<h1>VALUE HEADER</h1><div>BODY CONTENT</div>FOOTER CONTENT<h1>DEFAULT TITLE</h1><div>BODY CONTENT</div>FOOTER CONTENT
---------
ACTUAL (/marko/test/fixtures/templates/layout-use/actual.html):
---------
<div></div><h1>DEFAULT TITLE</h1><div></div><h1>DEFAULT TITLE</h1><div></div><h1>DEFAULT TITLE</h1><div></div>
---------
```

Instead of using the content from layout-put it falls back to the default if available.

Any idea what's wrong here?
 That is strange. If I checkout the latest version with a blank npm install ... it's still failing. 

I'm using node 0.10.36.

Any idea how I could triage this issue?
 Did the same on a different machine. Everything went fine without issues. Most likely it's just a problem with my machine. 

Let me know if you have any idea how I could isolate this issue.

Thanks
-Vivian
 Yes, did that without success.

Anyhow, found the issue.

There was a node_modules directory in a parent directory by accident. So for some reason it interfered with that and caused these errors.

Thanks for your quick help!
-Vivian
    The parser seems to be converting strings to logical values, for example 'and' is getting converted to '&&', and 'or' to '||'. It seems to be linked to the way html elements are nested. The text is being used in a <layout-put into="body"> tag.

Here is some html that breaks it:
`<div class="c c2 span-8-collapse">
                    <div class="c-inner">
                        <dl class="summary-list">
                            <dt>
                                <h3>Intuitive Features Wrapped Up In a Smart Interface</h3>
                            </dt>
                            <dd>
                                <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</p>
                                <span class="blue">&#9656; </span><a href="/features">Explore the Features</a>
                            </dd>

```
                        <dt>
                            <h3>Pay-as-you-go + Monthly Plans Available</h3>
                        </dt>
                        <dd>
                            <p>Whether you're publishing lots or publishing little we have a plan that's great value and can scale up/down as your needs do, and you're free to cancel anytime.</p>
                            <span class="blue">&#9656; </span><a href="/pricing">Choose a plan that's right for you</a>
                        </dd>
                        <dt>
                            <h3 class="green">Start Now - No Obligation 14 Day Free Trial</h3>
                        </dt>
                        <dd>
                            <p>We don't expect you to make a decision before you've kicked the tyres and shown your boss so we offer a no obligation 14 day free trial to everyone.</p>
                            <span class="green">&#9656; </span><a href="/features#analytics" class="green">Bored of reading and want to try it for yourself? Start your free trial now</a>
                        </dd>
                    </dl>
                </div>
            </div>`
```
 I'm using the 'view-engine' and 'view-engine-marko' modules. I think the dependencies are well out of date. Is this still supported: https://github.com/patrick-steele-idem/view-engine-marko.git?
  I created a custom tag component, app-fieldset, which can include other custom tags, eg. app-text-field.
It works fine if the inside custom tag are other types, but I get error if it refers itself.

Template.marko in app-fieldset:

`...
<if test="fType === 'text'">
    <app-text-field viewModel="field" />
 </if>
 <else-if test="fType === 'fieldset'">
   <app-fieldset viewModel="field" /> //refers self 
 </else-if>
`

The error in console is:
Thu, 30 Apr 2015 04:14:22 GMT uncaughtException Invalid tag handler: [object Object]
Error: Invalid tag handler: [object Object]
    at Function.deferredRenderer.renderer (...../node_modules/marko/runtime/helpers.js:35:19)
    at deferredRenderer (..../node_modules/marko/runtime/helpers.js:27:26)
    at module.exports.t (..../node_modules/marko/runtime/helpers.js:181:9)
    at ..../src/components/app-fieldset/template.marko.js:59:15

I used the latest version of marko: "2.3.2" per https://github.com/raptorjs/marko/issues/66
but seems not work for this case.

Thanks,
Sara
 Hi Patrick,

Yes, it has renderer.js and use option 1.

Thanks,
Sara

From: Patrick Steele-Idem <notifications@github.com<mailto:notifications@github.com>>
Reply-To: raptorjs/marko <reply@reply.github.com<mailto:reply@reply.github.com>>
Date: Thursday, April 30, 2015 8:06 AM
To: raptorjs/marko <marko@noreply.github.com<mailto:marko@noreply.github.com>>
Cc: sara xu <lijxu@ebay.com<mailto:lijxu@ebay.com>>
Subject: Re: [marko] Custom tag self reference does not work (#69)

Hi Sara,

Does your <app-fieldset> custom tag have a renderer.js? If so, which syntax of the following does your renderer.js use?

Option 1:

exports.renderer = function(input, out) { ... }

Option 2:

module.exports = function renderer(input, out) { ... }

If you have a circular dependency you need to use Option 1 since it allows for a partially loaded module to be returned. It is recommended that you always use the syntax shown in Option 1. If you do not have a renderer.js then I'll probably need more details to reproduce the problem.

Thanks,
Patrick

â€”
Reply to this email directly or view it on GitHubhttps://github.com/raptorjs/marko/issues/69#issuecomment-97830257.
  Proposal #61 suggests some solution to simplify "parent/child relationships". I'm trying to understand how conceptually we are selling this solution to the end user. We are telling that user should "connect" parent and child tags, but maybe user does not need child tags? Maybe he just needs a way to express complex `input` object using declarative markup.

If we step back and overview tags again, we can say that tag is a function with the following signature:

``` js
var customTag = function(input, out) {
    // ...
};
```

Instead of calling it directly in the code, we found a way to "call" it declaratively with the following markup:

``` html
<custom-tag title="Hello" href="/some/url" />
```

Naive equivalent of the above declarative "call" is the following function call:

``` js
customTag({ title: "Hello", href: "/some/url", renderBody: function() {} });
```

It means that declarative `<custom-tag />` is used to define the shape of the `input` object for `customTag` function. Nothing new here, this is just an introduction.

But you can notice, that declaratively you can define only first-level properties or functions of the `input` object. 
### Alternative definition of the problem

In proposal #61 idea was to simplify parent/child relationship. But maybe we can solve the same problem if declarative "call" would support definition of complex `input` objects. Actually, the notion of the `target-property` suggests us that we are really looking to support complex `input` object, not just single-level attributes.

Sometimes we really would like to call our tag function with complex `input` object. In JavaScript this is really simple and straightforward:

``` js
appTabs({
    orientation: "vertical",
    tabs : [
        { label: "Tab 1", renderBody: function() { return "Content for Tab 1" } },
        { label: "Tab 2", renderBody: function() { return "Content for Tab 2" } }
    ],
    renderBody: function() { ... }
};
```

Today we cannot easily do the same declaratively. We can pass `orientation` attribute, but we cannot pass `tabs[]` array. Proposal #61 tries to solve this, but conceptually it is a bit complex, because it requires to introduce another tag that is defined separately from the `attributes` attribute in `marko-taglib.json`, while still attaching to the `input` object with the help of `target-property`. I see mismatch here: from one side we have independent child tag, from other side we are trying to embed it to our parent's `input` object.

What if the problem can be defined as the following: _how can we make declarative "call" of tag function that accepts complex `input` objects?_ This definition of the problem is differ from the current problem: _how can we simplify parent/child relationships?_
### Proposal for `marko-taglib.json` syntax

If our tag function can accept complex `input` objects then shape of such object should be defined inside `attributes`, where we currently have support for only first-level attributes. Here is a possible definition of `app-tabs` taglib:

``` js
{
    "attributes": {
        "orientation": "string",
        "tabs": {
            "type": "object[]",
            "implicit": true,    // only one attribute can be implicit (more about this below)
            "attributes": {
                "label": "string"
            }
    }
}
```
### Nested tags vs. nested attributes

Nested tag is a complete Marko tag which is nested to another tag and can be reused. Nested attributes can look like ordinary Marko tags, but they cannot be reused outside of the root tag.

In the following example, `<app-panel />` is a nested tag, while `<app-tab />` is a nested attribute of `<app-tabs />`:

``` html
<app-tabs orientation="vertical">
    <app-tab label="Tab 1">
        <app-panel title="Title" />
    </app-tab>
    <app-tab label="Tab 2">
        Content for Tab 2
    </app-tab>
</app-tabs>
```

We cannot reuse `<app-tab />` outside of the root `<app-tabs />`. That is why this is a nested attribute. But we can reuse `<app-panel />`, because this is a nested tag.

Important part of this proposal is a proposal to treat nested tags differently from the nested attributes.
### Proposal for the syntax of nested attributes

There are several possible ways to express nested attributes. First possible way is to use `tag-name.property` notation:

``` html
<app-tabs orientation="vertical">
    <app-tabs.tab label="Tab 1">
        <app-panel title="Title" />
    </app-tabs.tab>
    <app-tabs.tab label="Tab 2">
        Content for Tab 2
    </app-tabs.tab>
</app-tabs>
```

The following `input` object will be created (renderBody etc. are omitted):

``` js
{
    "orientation": "vertical",
    "tabs": [
        { "label": "Tab 1" },
        { "label": "Tab 2" },
    ]
```

I saw such notation in the [XAML](https://msdn.microsoft.com/en-us/library/ms788723%28v=vs.110%29.aspx?f=255&MSPPError=-2147217396) language:

``` xml
<Button Text="Save">
  <Button.ContextMenu>   <!-- nested attribute -->
    <ContextMenu>     <!-- nested tag -->
      <MenuItem Header="1">First item</MenuItem>
      <MenuItem Header="2">Second item</MenuItem>
    </ContextMenu>
  </Button.ContextMenu>
  Right-click me!
</Button>
```

Second possible way is to use some special `param` tag, like in [Google Closure Templates](https://developers.google.com/closure/templates/docs/commands#param):

``` txt
{template <template_name>}
  {@param <param_name>: <param_type>}
  {@param? <optional_param_name>: <param_type>}
  ...
{/template}
```

In case of Marko it can be `<@param attribute1="value" attribute2="value" />`, although I also don't like special symbols (maybe simple `<param ... />` is enough):

``` html
<app-tabs orientation="vertical">
    <@tab label="Tab 1">
        <app-panel title="Title" />
    </@tab>
    <@tab label="Tab 2">
        Content for Tab 2
    </@tab>
</app-tabs>
```

Marko already has special syntax for string interpolation: `${value}`, `$!{value}` and `${value}`. Maybe it still worth to add another special syntax for nested attributes: `<@name />` or any other.

I'm not voting for any particular syntax, my idea is to evaluate problem that we are trying to solve from different angle (from declarative definition of complex `input` objects). I'm sure that together we can find a better syntax.
#### 

In my comment to #61 I asked about support for more than one level of nested tags with the following use case:

``` html
<sidebar-navigation>
    <sidebar-navigation-section title="Software">
        <sidebar-navigation-item href="/linux" title="linux"/>
        <sidebar-navigation-item href="/windows" title="Windows"/>
    </sidebar-navigation-section>
    <sidebar-navigation-section title="Devices">
        <sidebar-navigation-item href="/ipad" title="iPad"/>
        <sidebar-navigation-item href="/xbox" title="Xbox"/>
    </sidebar-navigation-section>
</sidebar-navigation>
```

When looking on this template, can you answer on what tags are "nested tags" and what are just "nested attributes"? It is hard to answer on this question without reading `marko-taglib.json`. If we can find a way to differentiate tags from attributes, it can be expressed in the following way (using some of the proposed syntax):

``` html
<sidebar-navigation>
    <@section title="Software">
        <@item href="/linux" title="linux"/>
        <@item href="/windows" title="Windows"/>
    </@section>
    <@section title="Devices">
        <@item href="/ipad" title="iPad"/>
        <@item href="/xbox" title="Xbox"/>
    </@section>
</sidebar-navigation>
```

Definition of this tag in `marko-taglib.json`:

``` js
{
    "attributes": {
        "orientation": "string",
        "sections": {
            "type": "object[]",
            "implicit": true,    // only one attribute on the same level can be implicit 
            "attributes": {
                "title": "string",
                "items": {
                    "type": "object[]",
                    "implicit": true,   // only one attribute on the same level can be implicit 
                    "attributes": {
                        "title": "string",
                        "href": "string"
                    }
                }
            }
        }
    }
}
```

`implicit` flag means that we can assign value to this property using shorter notation. Instead of this (technically valid):

``` html
<sidebar-navigation>
    <@sections>
        <@section title="Software" />
    </@sections>
<sidebar-navigation>
```

 We can write it in the shorter form:

``` html
<sidebar-navigation>
    <@section title="Software" />
<sidebar-navigation>
```

In XAML this flag is named [`ContentProperty`](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.markup.contentpropertyattribute.Aspx).
#### Conclusion

This is just a proposal. You probably see much more corner stones than I am. 

Thank you!
 It might be possible sidestep the tag-name issues and instead define a new marko-tag like `<attribute name="X">value</attribute>`, which would set an attribute on the parent tag.  In this use-case the markup for the tabs might look something like:

```
<app-tabs>
    <attribute name="tab">
        <attribute name="label">Tab 1</attribute>
        Content for Tab 1
    </attribute>
    <attribute name="tab">
        <attribute name="label">Tab 2</attribute>
        Content for Tab 1
    </attribute>
</app-tabs>
```

This scheme could potentially be used for defining attributes on regular html tags as well as on our custom taglib tags too, though I have no idea how much complexity that would add to the parser.
 Interesting, I didn't know about <attr>.  Is that something that's intended to be documented and officially supported?

I think the colon approach will result confusion since the `app-tabs` "namespace" wouldn't actually be declared, and could cause problems for people trying to use marko to generate xml.

The . or - separated syntax seems cleanest, if a little repetitive.  The ability to just declare arbitrary subtag names in the taglib definition could result in some interesting use-cases and has the potential to make the template markup more "semantic", which is a pretty big pro in my book.
 > I'm in favor of supporting the dot-notation for using nested tags in your HTML. 
> A short-hand of only using something like <.tab> would be great too if we can 
> tweak the HTML parser.

Because you are already planning to use `@` symbol for attributes, maybe it makes sense to introduce `@<nested-tag />` notation, instead of `<.nested-tag />` and `<@nested-tag />`:

``` html
<app-tabs>
    @<tab label="Tab 1">
        Content for Tab 1
    </tab>
    @<tab label="Tab 2">
        Content for Tab 2
    </tab>
</app-tabs>
```

It seems that in this case we shouldn't worry about HTML parsers and all editors will work fine with this syntax.

As a side note, we also can continue to use `$` symbol for this and do not introduce new symbol:

``` html
<app-tabs>
    $<tab label="Tab 1">
        Content for Tab 1
    </tab>
    $<tab label="Tab 2">
        Content for Tab 2
    </tab>
</app-tabs>
```

Mnemonic is the following: when `$` is in front of open curly bracket (`{`), you are going to evaluate JavaScript expression. When `$` is in front of open tag (`<tag>`), you are going to decoratively define  sub-property. 

But I agree that `@` is suited better for attributes...
  Hi,
Is there a way to make a variable available to all layouts templates without having to pass it in every template.render()?
For example, i'm using <layout> and have a <app-nav> component in that layout. I want to be able to render/not render certain navigation elements depending on whether the suer is logged in or not. At present I have to pass a variable in every controller like this:
`$global: { env: locals.env, user: locals.user }`
but I have to do that in every controller ( where I call template.render() ) e.g. login, signup etc etc. Is there any way to make variable available to all templates/components rather than sending the data each time in template.render()?

Thanks,
Pat
  This proposal looks really nice! Just trying to understand how flexible it is. First thing that come to my mind is about more than one level of hierarchy. How can be the following tag described in `marko-taglib.json`:

``` html
<sidebar-navigation>
    <sidebar-navigation-section title="Software">
        <sidebar-navigation-item href="/linux" title="linux"/>
        <sidebar-navigation-item href="/windows" title="Windows"/>
    </sidebar-navigation-section>
    <sidebar-navigation-section title="Devices">
        <sidebar-navigation-item href="/ipad" title="iPad"/>
        <sidebar-navigation-item href="/xbox" title="Xbox"/>
    </sidebar-navigation-section>
</sidebar-navigation>
```

And there are use-cases for unlimited hierarchy (though very uncommon):

``` html
<menu-widget>
    <menu-item title="Help">
        <menu-item title="About" />
        <menu-item title="FAQ" />
    </menu-item>
    <menu-item title="File">
        <menu-item title="Save" />
        <menu-item title="Open with">
            <menu-item title="Sublime" />
            <menu-item title="VIM" />
        </menu-item>
    </menu-item>
    <menu-item title="View" />
</menu-widget>
```

Will it be possible to describe such nesting? If we'll go with the proposed way, we need to define taglib inside taglib inside taglib :) 

Here is an example for the `sidebar-navigation` shown above:

``` js
{
    "attributes": { },
    "taglib": {
        "tags": {
            "sidebar-navigation-section": {
                "target-property": "sections[]",
                "attributes": {
                    "title": "string"
                },
                "taglib": {
                    "tags": {
                        "sidebar-navigation-item": {
                            "target-property": "items[]",
                            "attributes": {
                                "href": "string",
                                "title": "string"
                            }
                        }
                    }
                }
            }
        }
    }
}
```
  In the latest Marko versions and in some cases `and` words in templates are replaced with `&&` symbols. 

For this template:

``` html
We're young.
<div>
    You and me are friends and teammates.
</div>
```

The following `*.marko.js` file will be generated:

``` js
out.w('We\'re\' \'young. <div>You && me are friends && teammates.</div><div style="color:blue">You '
```
## Necessary Conditions
1. You should use `marko-layout` module.
2. You should have unpaired `'` symbol in your template.

There are probably other conditions, when this issue happens, but I know only one set of conditions.
## Minimal project

Here I prepared a minimal project that will help to reproduce this issue:
https://github.com/schetnikovich/marko-substitution-poltergeist
# Reasons

I don't know actual reason of this problem, but for the end user this is because of `'` symbol, that
makes all subsequent `and` words be replaced by `&&` symbol.

If you'll "close" single quotes, i.e. `We'are' young` - everything will be correct.
# Workaround

Replace all single quotes with the following:

```
$("'")
```
 Thank you very much for so quick fix! Issue disappeared. 
  I have three points regarding progressive rendering of marko templates.
1. As out of order rendering requires JS on the client side, the docs should mention that as well (including the impact this has on on things like progressive enhancement etc.) The only mention of this that I have found is on the ebay tech blog article about progressive rendering. I might be missing something here; I made some thoughts, if out of order rendering could be achieved without the need of client side JS... unfortunately I did find a way to do so.... is this a point of interest for marko?
2. I wonder, if google does correct indexing with out-of order rendering, as A) JS is required and B) the initial HTML is rendered into a hidden div. Point A might be a no-issue, since google (and others?) now performs JS when requesting pages. If not, point B is critical because hidden content could be ignored/identified as lower priority (less relevant to a page) so pages might not be correctly indexed. If google runs JS and considers the page when it is fully loaded, point B might be a no-issue. Please provide some thoughts/practical experiences regarding A and B.
3. When running the examples on https://marko-progressive-rendering.herokuapp.com/?renderMode=progressive-in-order&jsLocation=middle everything is fine until you reload the iframe (hitting the inner refresh button on the page) in the chrome browser. Strangely, progressive rendering of async-elements only works when you move the mouse after refresh - Safari and Firefox render every chunk as soon as it arrives. Reloading the entire page in chrome shows the same effect while running the example in a separate window works fine (most of the time). I tested the behaviour with a bigger first chunk (additional textual data) but the data refuses to render until you move the mouse. It seems, that the browser ignores chunked responses and renders the content like a single chunk. I see the same behaviour on Mac and Linux. Does somebody know the reason and if this is a known/intended behaviour or a bug on the marko/chrome part?
 hi @patrick-steele-idem thanks for looking into the issue - I am fine with closing it - if something pops up again, I will create a new issue.

Sadly, I have not done any further investigation towards indexing but as soon as I get more information, I will share it.
  Hi,
I have a problem with components having their HTML tags closed, incorrectly, by the compiler. For example if I have the following components and html content (shown simplified):
<app-header> (components/app-header/template.marko)
HTML content: `<div class="wrapper"><div class="content">`

<app-footer> (components/app-footer/template.marko)
HTML content: `</div></div>`

index.js
HTML content: `<app-header></app-header><div>content here</div><app-footer></app-footer>`

I can see the problem. The `<app-header>` component's compiled .js file has added the closing 'div' tags automatically, which breaks the layout as the 'wrapper' and 'content' elements are now closed, when they should be left open to contain the main page content.

Is there any setting to prevent this or a different way of laying out the pages?

Thanks,
Pat
 Ok, that makes sense. Once again thanks for the quick response and easy to understand explanation - it really makes a difference.
Thanks,
Pat
  Hi,
Whats the best way to pass data to components. At present it appears you have to pass data from every template to the components e.g. in index.marko you would have
`<app-header title="$data.title" env="$data.env" csrf="$data.csrf"></app-header>`

I can then access the data from the component e.g.
`<if test="data.env == 'development'">`

If I try to access data.env without passing the data in from index.marko I get an error. Doing it this way if I want to pass new data into the app-header component in the future I would have to change ALL templates. 
Is there a better way of doing this?

Thanks,
Pat (new to Marko and Node)
 Wow, exactly what I needed, and fast! I can get on with a productive day, much appreciated.
  ![marko0](https://cloud.githubusercontent.com/assets/8730277/6872950/1f4f32d8-d4ad-11e4-9edd-4718197d4ba5.png)
 ![marko1](https://cloud.githubusercontent.com/assets/8730277/6872952/2807186e-d4ad-11e4-8d85-26981939383d.png)
 :D these are the '< >'  it all can be customised I have .ai files saved
 Dumb, but worth the "idea".
![marko-logo](https://cloud.githubusercontent.com/assets/105656/6873249/9affb1fc-d474-11e4-8e5f-65e7e15a4aa5.png)
 ![marko3](https://cloud.githubusercontent.com/assets/8730277/6873580/9f302990-d4b1-11e4-8c19-1c3eadfd3823.png)
 @philidem Yeah, I saw that as soon as I made it, but said, "What the heck? Worth a post."
 ![marko2](https://cloud.githubusercontent.com/assets/8730277/6876374/2dc9b080-d4c7-11e4-8832-5a4347acf696.png)
Since Marko is a dudes name I gave him some personality
 ![marko4](https://cloud.githubusercontent.com/assets/8730277/6876740/de88c28c-d4ca-11e4-990f-ca09efb4e3d9.png)
Some Urban Style.
 Alright time to leave Illustrator. Good night Gentleman!, I will be bugging you tomorrow since I haven't implementetd optimizer yet ;)
 ![screen shot 2015-03-27 at 2 47 34 pm](https://cloud.githubusercontent.com/assets/7464488/6877671/72464764-d490-11e4-83b9-8d8fc7aedd66.png)

Maybe you could play around with the color... 
 ![marko3](https://cloud.githubusercontent.com/assets/6454552/8861384/755b9178-318a-11e5-967a-4b8990787b94.png)

Some thoughts (additional love to detail required): 
- the brackets at the end should appear 3D "stacked"; meaning: tags can be wrapped... forming components... the "k" and the first bracket form the letter "o"
- the font should appear dynamic, "agile", quick and nice
- the sub text describes marko as template engine with binding (behavior) and gives an insight about how marko components are written
 Lol how about some fancy..

${marko}

   Ryan Pavely
    Net Access
    http://www.nac.net/

On 8/5/2015 1:53 PM, Patrick Steele-Idem wrote:

> Accidentally pressed the wrong button... Comment updated with link to contest. Thanks.
> 
> â€”
> Reply to this email directly or view it on GitHub https://github.com/marko-js/marko/issues/54#issuecomment-128090635.
 haha had a funny idea.... marko and an abstract grining face

![marko_face](https://cloud.githubusercontent.com/assets/6454552/9115315/b139b948-3c5e-11e5-9edd-0ec5a9e25110.png)
 Well deserved, congrats Marko!
  `c-input` works well for nested tags, but there are times when we need to pass down extra information from the parent tag, like this:

```
<tagname c-input="data.someObj" attribute="test"/>
```

Examples include when the parent contains the loop and we might need an index in the nested tag, or if parent tag-level logic affects a child tag. 

This should also include support for passing a conditional, or at least a variable (that we can set with a conditional earlier in the file).

Thanks!
 Yes to @patrick-steele-idem and thanks!
  Removing the else if block in order to allow complex var names on the left hand of the assignment.
 Funny, because I did the edits directly in Github. :-)

## 

Sean Gates
Sent from my iPhone

> On Mar 18, 2015, at 5:15 PM, Phillip Gates-Idem notifications@github.com wrote:
> 
> Please fix the jshint error so that the build will pass. Also, jshint plugins/packages for your code editor are really helpful if you don't have one installed.
> 
> See https://travis-ci.org/raptorjs/marko/jobs/54955691
> 
> â€”
> Reply to this email directly or view it on GitHub.
 You bet!

## 

Sean Gates
Sent from my iPhone

> On Mar 18, 2015, at 6:15 PM, Phillip Gates-Idem notifications@github.com wrote:
> 
> Published marko@2.1.4
> Thanks Sean!
> 
> â€”
> Reply to this email directly or view it on GitHub.
  Usecase:

We would like to add a library of components. The path would be:
/node_modules/component-library/node_modules/custom-component/lib/

If the rendered template is somewhere else then this path won't be discovered. 

Suggestion:

Add a way to add paths to the [discovery feature](https://github.com/raptorjs/marko#taglib-discovery)
 That would be great. 
  Especially with regards to breaking changes and feature deprecations.

It will help us make informed decisions about if/when to upgrade and what app-changes we need to make to stay up to date with the latest and greatest.

We have gotten ourselves into trouble a few times with mismatched versions between marko and supporting modules. I think having an accurate Changelog on each module would be hugely helpful in tracking down where we went awry.

Thanks!
 Thanks @philidem -- That sounds like it would be a big help!
 Hi @patrick-steele-idem,

I think the Marko ChangeLog was a bit out of date when I opened this issue, but it seems to be all caught up now.  Thanks for that!  (Or, I may just be crazy ...)

Upgrade guides are definitely fantastic help, and much appreciated.

It seems some supporting modules don't have ChangeLogs, however, and that's what I was trying to get at in my initial message.  Here are a few, as examples: raptorjs/optimizer, raptorjs/optimizer-marko, raptorjs/optimizer-less.

Maybe it wouldn't be practical or helpful to have Changelogs for each .. I'm not sure.  As a Marko-user, it's probably easier to have a single ChangeLog/Upgrade guide to follow.  But the interdependencies between modules complicates things.

I like @philidem's suggestion of having some runtime detection of incompatibilities.

Meanwhile, I'm using 'npm shrinkwrap' to freeze my module versions so that any future upgrades are deliberate and that is a working solution for me, for now.

Thank you for the great project!

-Ben
  Hello,
is there a way to work with marko and webpack, a marko-loader perhaps ?
Thanks
 Thanks, i will try !
 @maxwarch Hi! Have you succeed with webpack and marko? I'd tried it and encountered the problem that webpack 'Cannot find module 'raptor-logging-impl''. Direct installation of 'raptor-logging-impl' doesn't help. Will be nice to get your feedback. Thanks!
 @KateKate hi, unfortunately i haven't the time to try this. I hope i will have !
 @patrick-steele-idem thank you for your feedback.
 It's a bit of a hack, but if a module uses `process` and it's bundled by webpack then webpack (and browserify) sets `process.browser: true`. So if the try/catches in raptor and marko's src are only there for the benefit of browserify then replacing them with `if(!process.browser)` would mean the code compiles properly in webpack too @patrick-steele-idem 
 I've found, and found a potential workaround for, another bug in webpack.

Because, I guess, it places a higher importance on loading files with extensions other than `.js` webpack tries to load `mypartial.marko` rather than `mypartial.marko.js` when using `<include` in any template. The workaround I found is to compile `<include` to e.g. `__loadTemplate(require("../../components/nav/tpl.marko.js"), require)` instead of `__loadTemplate(require.resolve("../../components/nav/tpl.marko"), require)`

Whether this breaks anything else I don't know. If it does I'll have a go at writing a marko loader for webpack, though it wouldn't surprise me if the use of `require.resolve` instead of a plain `require` is still   a problem
 On investigating, this would involve a change to TypeConverter. Is this something you'd consider?
 I tried with transform-loader and the markoify. It worked for me, but webpack does not track any changes in templates, so I just wrote no-brainer marko-loader for webpack, which solves this problem.

``` js
var marko = require('marko/compiler');

module.exports = function (source) {
  if (this.cacheable) this.cacheable();

  return marko.compile(source, '.', {
    writeToDisk: false
  });
};
```
 @sergiirocks I'm using your loader but getting this error when building:

> the request of a dependency is an expression

Any idea what might be happening?

Do you have an example on how to use it in `webpack.config.js`?
 @patrick-steele-idem I have created this test project.

https://github.com/PierBover/markojs-webpack-test

You just need to `npm install` and then `webpack` to reproduce the error.
 Awesome @patrick-steele-idem !
 It does work, although I'm still getting Webpack warnings:

> WARNING in ./~/marko/runtime/stream/index-browser.js
> Critical dependencies:
> 6:17-40 the request of a dependency is an expression
> 10:13-32 the request of a dependency is an expression
>  @ ./~/marko/runtime/stream/index-browser.js 6:17-40 10:13-32
  Hello,

is there a way to use marko with webpack ?

Thanks
  Please, please please :) Anything we can do to help. Any sample repo to use as reference?
Cheers!
  I started writing some code that I was really hoping would work but it doesn't seem to. I was wondering if self-nested taglibs would be possible because it would be extremely handy for my use case:

``` json
{
  "tags": {
    "mytag": {
      "renderer": "./mytag",
      "attributes": {
        "data": "string"
      },
      "body-function": "getChildren(__children)",
      "import-var": {
        "children": "__children"
      }
    }
  }
}
```

``` js
exports.render = function(input, out) {
  var children;
  if (input.getChildren) {
    children = [];
    input.getChildren({
      addChild: function(child) {
        children.push(child);
      }
    });
  }
  if (input.children)
    input.children.addChild(/* implementation detail */);
  else
    out.write(/* something utilizing children */);
};
```

``` html
<mytag data="a">
  <mytag data="b" />
  <mytag data="c" />
</mytag>
```

So basically my question is whether or not it is somehow possible to include both "body-function" and "import-var" on the same tag and self-nest them. When I try this I get an error that __children is undefined. Is there a way to achieve this currently?
 I actually solved my problem for now with a hack of using `"import-var": { "children": "arguments[1] }`, but obviously it would be much better if `children` existed in the compiled template and was null.
 Ah yeah that makes sense. I've replaced my hack with that and it's working great now. Thanks so much!
 Ok cool, I'm still trying to figure out exactly how this all works. I have a little ways to go I think but so far so good. I started looking through the tests and have modified my taglib to use `"var": "children"` now and I've removed `body-function` in favor of using `renderBody(out, {...})` in my renderer. It's working perfectly now. Although I don't feel like I can be completely confident that I'm doing everything correctly because the documentation is a little lacking in this area at the moment, but I'm sure that'll change in the future.

FYI I'm building a simple taglib to render React components and it's actually working great. Maybe I'll publish it on npm if I get some time.
  - https://github.com/raptorjs/marko/issues/28
  This is not supported 

``` javascript
template.renderSync({
  $global: {
    foo: "foo!"
   }
});
```

But this is (as seen in https://github.com/raptorjs/marko/issues/16)

``` javascript
template.render{
  $global: {
    name: 'Frank'
  }
}, res);
```

The issue seems to be that `$global` processing is missing from the `renderSync` function.

https://github.com/raptorjs/marko/blob/master/runtime/marko-runtime.js#L65-L72

``` javascript
Template.prototype = {
   renderSync: function(data) {
       var out = new AsyncWriter();
       out.sync();
       this._(data, out);
       out.end();
       return out.getOutput();
}
```

But can be found in the `render` function.

https://github.com/raptorjs/marko/blob/master/runtime/marko-runtime.js#L84-L126

``` javascript
 render: function(data, out, callback) {
      ...
       var $global = data.$global;
       if ($global) {
           extend(out.global, $global);
       }
```
  I am trying to target IE browsers with some simple IE conditionals, but it seem to fail in marko template.

My template has these simple conditionals, but its not getting targeted properly. I donâ€™t see the classes being added. (works however in plain html)

&#x3C;!--[if lt IE 7]&#x3E; &#x3C;html class=&#x22;lt-ie9 lt-ie8 lt-ie7&#x22; lang=&#x22;${locale}&#x22;&#x3E; &#x3C;![endif]--&#x3E;
&#x3C;!--[if IE 7]&#x3E; &#x3C;html class=&#x22;lt-ie9 lt-ie8&#x22; lang=&#x22;${locale}&#x22;&#x3E; &#x3C;![endif]--&#x3E;
&#x3C;!--[if IE 8]&#x3E; &#x3C;html class=&#x22;lt-ie9&#x22; lang=&#x22;${locale}&#x22;&#x3E; &#x3C;![endif]--&#x3E;
&#x3C;!--[if !IE]&#x3E; --&#x3E;&#x3C;html lang=&#x22;${locale}&#x22;&#x3E;&#x3C;!--&#x3C;![endif]&#x2014;&#x3E;

anything to do with the HTML commentâ€™s?
 Hey @patrick-steele-idem, not a big deal, but you may want to update your code sample above to use `renderBody(out)` instead of `invokeBody()`
 I had noticed that even though they are preserved, variables weren't output correctly. I didn't dig into it too much, but I saw this issue and liked your `app-html` better anyway so I went with that.

So for example:

```
<!--[if IE 9]>
<html class="ie9" lang="$data.language"> <![endif]-->
<!--[if gt IE 9]><!-->
<html lang="$data.language">
<!--<![endif]-->
```

Would end up as:

```
<!--[if IE 9]>
<html class="ie9" lang="$data.language"> <![endif]-->
<!--[if gt IE 9]><!-->
<html lang="en">
<!--<![endif]-->
```
  Any value under the `value` attribute are referenced to marko `objects` but the same is not true for custom tags.

```
<assign var="options" value = "util.getOptions(options, pattern)" />
```

Custom Tag only accepts `$DATA` 

```
<ebayui-refit-itemgrid-pattern viewModel = $grid options = $options />
```

The below code will through an error in marko

```
<ebayui-refit-itemgrid-pattern viewModel = "grid" options = "options" />
```

Marko should promote one way of passing variables to support consistency.
  We are getting errors similar to what we see below, it will be great to get the entire stack trace here so we know what line has is the problem.

```
ERROR r1coltv/src/controllers/dealsHub: { '0': [TypeError: Cannot read property 'left' of undefined] } bad error
```
 Try accessing a property of an object which doesn't exist in the `renderer.js`. @patrick-steele-idem 
 ```
ERROR r1coltv/src/controllers/dealsHub: { '0': [TypeError: Cannot read property 'a' of null] } bad error
```

try running the code below

renderer.js

```
module.exports = function render(input, context) {
    var t = null;
    var a = t.a;
    console.log("asdasd", a);
    var model = getTemplateModel(input);
    if (model) {
        if(model.options.mode === 'large'){
            largeTemplate.render(model, context);
        }else{
            template.render(model, context);
        }
    }
};
```
  Hey,
This might be a hard thing to integrate, but I'd like to discuss it, maybe you will find it useful.
What want to accomplish is to load a component dynamically. Instead of using a html tag, I want to load it through a dedicated attributes value, lets say 'taglib'-attribute.

``` html
<div for="item in data.components" taglib="$!{item.component}-component" model="$!{item.value}">
```

or

``` html
<div for="item in data.components" taglib="item.component" model="$!{item.value}">
```

The problem is, if we'd like to be able to use every template available, we would need some sort of index with template names and their relative path. Alternatively, we could scope the available templates to only a certain directory, which would be easier, but not as clean. 

This would require us to have a compiled template like this.

``` javascript
templates = { "component-one": "./components/component-one/template.marko" };
return function render(data, out) {
      out.w('xxx');
      forEach(data.components, function(item) {
       __helpers.l(require.resolve(templates[item.component])).render({"value": str(item.value)}, out);
      });
    out.w('xxx');
  };
```

or

``` javascript
templates = {
            "component-one": __helpers.l(require.resolve("./components/component-one/template.marko"))
        };
return function render(data, out) {
      out.w('xxx');
      forEach(data.components, function(item) {
          templates[item.component].render({"value": str(item.value)}, out);
      });
    out.w('xxx');
  };
```

Of course we could check, if array contains element etc. This is just a dirty example. I know that this adds a bit of an overhead to the lightweight templates, especially if you got lots of components, but I couldn't think of any different/better way of doing this without sacrificing client-side compatibility. What do you think?

I could integrate it, though it will take me some time to dive into the code. A few hints where I find the responsible bits would surely help me.
 @philidem This is a nice approach, unfortunately not what I'm looking for.

Thanks to both of you for taking the time to respond in such detail., this helped me understand marko more. And sorry for apparently not explaining my issue properly, when re-reading the docs I found a great solution already in place: the `include`-tag. It seems to do all the required stuff like loading and rendering.

```
<include template="app/components/$!{item.component}/template.marko.html" value="$!{item.value}">
```

This will help me get started for now!

I will add .marko.html support to optimizer-marko in the next days.
  Let's introduce a new tag attribute that will do the same thing as `body-only-if`.
Most of the time the intention is to skip the container and the focus is less in the body.

``` html
<a href="${data.linkUrl}" body-only-if="!data.linkUrl">
    Some body content
</a>
```

Can get changed to:

``` html
<a href="${data.linkUrl}" render-tag-if="data.linkUrl">
    Some body content
</a>
```
 I think you had a good point. The meaning of `body-only-if` is more clear than `render-tag-if`, because, like you said, the condition is relative to the content in the tag, not to the tag itself. 
 Not really important but "body-only-if" confused me at first since it could be read as "render body, only if condition", instead of "render body only, if condition". May be changing to "only-body-if" could make it clearer...?
 Good suggestion, `only-body-if` seems much clearer to me. I was also confused when I first used this feature.
 I would add to this that maybe `only-body-when` or `only-body-if` make sense :)  Maybe the current wording comes off a bit strange because it intends to group the words "body only," but "only if" is already a phrase (as in "if and only if").  the Html color highlighting is not good enough for marko template files in Sublime, it will be great if we can create one for Marko templates
 Hey guys, I just started working w/ Marko recently and found this thread.

I've ported your Atom grammar file to a Sublime/Textmate format.  I've also ported the snippets as sublime completions.  Should be handy for us ST fans.

https://github.com/merwan7/sublime-marko

I've currently got a [PR](https://github.com/wbond/package_control_channel/pull/4652) to get this into the Package Control default channel.  Will update the readme once it gets merged.
 @patrick-steele-idem. Sure thing!  I will update that section as soon as it's added to the package control channel.

I couldn't find a tool to convert the grammars in that direction (atom->tm) so I wrote a little script which I am still working on, actually (will add to github soon).  There was some manual effort involved, too :)
 Not to toot my own horn here, but I ported @merwan7's Sublime syntax package to VS Code :). For anyone needing this, check it out here:
https://github.com/pcanella/vscode-marko
  There are several use-cases where youâ€™d want .html files instead of .marko files. So Iâ€™ve added support for â€ž.marko.htmlâ€œ files.
 Hey, thanks for the quick reply, I've refactored the code as requested, it should be all fine now. The tests do pass.
  I was struggling with this issue for an hour until one of our coworkers told me how to do it.
Please add it to the documentation. ( to reassign a value to an existing variable we need to use assign)

```
<assign var="itemModel" value="items[itemIndex]" />
```
  Yes please :)
  Is it possible to programmatically call taglibs?

Currently we can do the following when including template fragments:

```
<include template="src/modules/${module.alias}.marko"/>
```

I can include a different template based on the value of "module.alias".

I'd like to be able to have the same logic with taglibs. Something like this:

```
<var name="path" value="data.type" />
<app-test-${path} attr1="${data.attr1}" attr2="${data.attr2}" attr2="${data.attr2}"/>
```

Currently I can do the following:

```
<if test="data.type === "a">
    <app-test-a attr1="${data.attr1}" attr2="${data.attr2}" attr2="${data.attr2}"/>
</if>
<else-if test="data.type === "b">
    <app-test-b attr1="${data.attr1}" attr2="${data.attr2}" attr2="${data.attr2}"/>
</else-if>
<else>
    <app-test-c attr1="${data.attr1}" attr2="${data.attr2}" attr2="${data.attr2}"/>
</else>
```

This would work but I'd like to avoid having to copy over the same parameter code.
 This will work. Thanks.
  ```
<my-first-tag>
<my-second-tag>
```

The new line between these two custom tags should be preserved.
  Hi,

I need to define my custom tags using `marko` node module but not using JSON files described [here](https://github.com/raptorjs/marko#marko-taglibjson).

Maybe there is something like that?

``` javascript
var marko = require('marko');

marko.defineTag('my-hello', {
  renderer: require('./hello-renderer'),
  attributes: {
    name: 'string'
  }
});
```
 Thank you, @philidem! 
Looking forward to use this feature in my project.
 I agree with you, this is right decision in this case.

But in my situation I need to integrate Marko into my framework. It means I need to register some module-wrappers as custom tags and it is needed to do before calling `compile` method.

Actually, this is not a big problem for me because I have simplified stream-based HTML parser for using these module-wrappers as custom tags. I just wanted to remove my implementation and replace it with Marko functionality.

Thank you, anyway.
  I really like the idea of html templating, but I discovered an issue when I tried to use it in my usual dev flow.

As I understand: 
now the require-able templates are made possible through a temp file

```
fs.writeFileSync(tempFile, compiledSrc, {encoding: 'utf8'});
fs.renameSync(tempFile, targetFile);
return require(targetFile);
```

and although you can bust template cache with `unload(templatePath)`, this doesn't clear node's module cache. So every time you `require(targetFile)` it will return the same compiled template regardless your meddling with marko's cache. 
It's possible to clear node's cache with `delete require.cache["absolutePath"]` though, but manually it would be tedious to track every unneeded compiled template.

The problem this makes is during development when a file changes, I want to clear the cache so the engine can re-render the template, or refresh the browser for instance. 

I think writing the compiled template to disk should be a feature, or an option, rather than a byproduct of rendering. 

Is there a way not to write the compiled template directly to disk, but rather keep it only in memory?
I think it would be useful in development.

Thanks in advance!
 Yes, restarting the whole process is a way. But it takes a little more time than just letting a few templates re-render. And updating templates is a fairly frequent occurrence sometimes.

About the hackery: once I saw a method where a module was loaded from raw string and executed. I think it's a way of instantiating modules on the fly. 
...
Ah, there, I found it: http://nodejs.org/api/vm.html
But it's not really module loading/creating though.
 Well first, I really appreciate the detailed response.
Indeed you can clear node's require cache, I thought about that too. A bit hacky for my taste, but that's just me. 

As for the template loading for disk: I see, a sound reason. I've always missed the ability to debug templates (easily). Although I have to admit, it feels clutter to generate a script for each template, but it might just take some getting used to. I see the benefits however.

And thank you for the resources, I'll check them out soon. 
 Have to said that I'm really interested in this issue but I can't get it to work.

My workflow

adding this to the top of app.js

``` javascript
var marko = require("marko")
require('marko/browser-refresh').enable()
require('marko/hot-reload').enable()

require('fs').watch('web/marko', function (event, filename) {
  if (/\.marko$/.test(filename)) {
    require('marko/hot-reload').handleFileModified(filename);
  }
});
```

At this point starting my app with iojs app.js doesn't serve the template anymore and got TypeError: Cannot read property 'pipe' of undefined, 

Then I npm install browser-refresh and browser-refresh-taglib and add <browser-refresh enabled="true" /> to my layout

``` javascript
var server = app.listen(3000, function() {
    var host = server.address().address
    var port = server.address().port

    console.log('App listening at http://%s:%s', host, port)

    if (process.send) {
      process.send('online');
      console.log('Sending online message')
    }

})
```

Inside the listen of app.

Finally launching the command with browser-refresh 

```
[browser-refresh] App started (pid: 7888)
[browser-refresh] Waited 1500ms without receiving "online" from child process. Page refresh triggered over WebSockets co
nnection.
App listening at http://:::3000
Sending online message
[browser-refresh] Server is ready. Page refresh triggered over WebSockets connection.
::1
TypeError: Cannot read property 'pipe' of undefined
    at E:\JS.Next\app.js:71:27
    at Layer.handle [as handle_request] (E:\JS.Next\node_modules\express\lib\router\layer.js:82:5)
    at next (E:\JS.Next\node_modules\express\lib\router\route.js:110:13)
    at Route.dispatch (E:\JS.Next\node_modules\express\lib\router\route.js:91:3)
    at Layer.handle [as handle_request] (E:\JS.Next\node_modules\express\lib\router\layer.js:82:5)
    at E:\JS.Next\node_modules\express\lib\router\index.js:267:22
    at Function.proto.process_params (E:\JS.Next\node_modules\express\lib\router\index.js:321:12)
    at next (E:\JS.Next\node_modules\express\lib\router\index.js:261:10)
    at E:\JS.Next\node_modules\express-stormpath\lib\stormpath.js:171:7
    at E:\JS.Next\node_modules\express-stormpath\node_modules\async\lib\async.js:254:17
```

Also require('marko/browser-refresh').enable() is already calling hotreload.

I'm not sure where I miss the point in the setup ! 

HotReload is called in the debugging and here's how I called my template

``` javascript
var formulaTemplate = marko.load(require.resolve('./web/marko/formula.marko'))
app.get('/formula', function(req, res) {
  formulaTemplate.stream().pipe(res)
})
```
 It's a whole new project all packages are up to date on Windows.
Replacing pipe() with the direct rendering solved the problem.
All is working now, it's great to play like this to better understand Marko.

Also I supposed that browser-refresh called 'node' cmd and no more 'iojs', is there a way to tune this ?

Thx Patrick !
 Hi Patrick, here's another beginner question,

I have a fragment that render properly when directly called.

For testing purpose I only use this code :

Hello ${data.name}!

<ul if="notEmpty(data.colors)">
  <li style="color: $color" for="color in data.colors">
    $color
  </li>
</ul>

<div else>
  No colors!
</div>

This fragment is then included in the main layout but when I render a page
that extend the layout the
$data fields are no more presents and the resulting html is different from
a direct call. How is that possible ?
  A couple minor fixes.
